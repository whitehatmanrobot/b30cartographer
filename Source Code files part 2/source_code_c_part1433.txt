eLength - Supplies the byte length for the allocation request.
        This should be sizeof(UL_LOG_FILE_BUFFER) but is basically ignored.

    Tag - Supplies the tag to use for the pool. This should be
        UL_LOG_FILE_BUFFER_POOL_TAG, but is basically ignored.

    Note: These parameters are required so that this function has a
        signature identical to ExAllocatePoolWithTag.

Return Value:

    PVOID - Pointer to the newly allocated block if successful, FALSE
        otherwise.

--***************************************************************************/
PVOID
UlAllocateLogBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;

    //
    // Sanity check.
    //

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_LOG_FILE_BUFFER) );
    ASSERT( Tag == UL_LOG_FILE_BUFFER_POOL_TAG );

    //
    // Allocate the default log buffer.
    //

    pLogBuffer = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    UL_LOG_FILE_BUFFER,
                    g_UlLogBufferSize,
                    UL_LOG_FILE_BUFFER_POOL_TAG
                    );

    if ( pLogBuffer != NULL )
    {
        pLogBuffer->Signature = MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG);
        pLogBuffer->BufferUsed = 0;
        pLogBuffer->Buffer = (PUCHAR) (pLogBuffer + 1);
    }

    return pLogBuffer;

}   // UlAllocateLogBufferPool


/***************************************************************************++

Routine Description:

    Frees the pool allocated for a UL_LOG_FILE_BUFFER structure.

Arguments:

    pBuffer - Supplies the buffer to free.

--***************************************************************************/
VOID
UlFreeLogBufferPool(
    IN PVOID pBuffer
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;

    pLogBuffer = (PUL_LOG_FILE_BUFFER) pBuffer;

    UL_FREE_POOL_WITH_SIG( pLogBuffer, UL_LOG_FILE_BUFFER_POOL_TAG );

}   // UlFreeLogBufferPool


//
// Private routines.
//

/***************************************************************************++

Routine Description:

    Completion handler for device control IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request. In
        this case, it's a pointer to a UL_STATUS_BLOCK structure.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_STATUS_BLOCK pStatus;

    //
    // If we attached an MDL to the IRP, then free it here and reset
    // the MDL pointer to NULL. IO can't handle a nonpaged MDL in an
    // IRP, so we do it here.
    //

    if (pIrp->MdlAddress != NULL)
    {
        UlFreeMdl( pIrp->MdlAddress );
        pIrp->MdlAddress = NULL;
    }

    //
    // Complete the request.
    //

    pStatus = (PUL_STATUS_BLOCK)pContext;

    UlSignalStatusBlock(
        pStatus,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    //
    // Tell IO to continue processing this IRP.
    //

    return STATUS_SUCCESS;

}   // UlpRestartDeviceControl


/*++

Routine Description:

    Routine to initialize the utilitu code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeHttpUtil(
    VOID
    )
{
    ULONG i;
    UCHAR c;

    // Initialize the HttpChars array appropriately.

    for (i = 0; i < 128; i++)
    {
        HttpChars[i] = HTTP_CHAR;
    }

    for (i = 'A'; i <= 'Z'; i++)
    {
        HttpChars[i] |= HTTP_UPCASE;
    }

    for (i = 'a'; i <= 'z'; i++)
    {
        HttpChars[i] |= HTTP_LOCASE;
    }

    for (i = '0'; i <= '9'; i++)
    {
        HttpChars[i] |= (HTTP_DIGIT | HTTP_HEX);
    }


    for (i = 0; i <= 31; i++)
    {
        HttpChars[i] |= HTTP_CTL;
    }

    HttpChars[127] |= HTTP_CTL;

    HttpChars[SP] |= HTTP_LWS;
    HttpChars[HT] |= HTTP_LWS;


    for (i = 'A'; i <= 'F'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    for (i = 'a'; i <= 'f'; i++)
    {
        HttpChars[i] |= HTTP_HEX;
    }

    HttpChars['('] |= HTTP_SEPERATOR;
    HttpChars[')'] |= HTTP_SEPERATOR;
    HttpChars['<'] |= HTTP_SEPERATOR;
    HttpChars['>'] |= HTTP_SEPERATOR;
    HttpChars['@'] |= HTTP_SEPERATOR;
    HttpChars[','] |= HTTP_SEPERATOR;
    HttpChars[';'] |= HTTP_SEPERATOR;
    HttpChars[':'] |= HTTP_SEPERATOR;
    HttpChars['\\'] |= HTTP_SEPERATOR;
    HttpChars['"'] |= HTTP_SEPERATOR;
    HttpChars['/'] |= HTTP_SEPERATOR;
    HttpChars['['] |= HTTP_SEPERATOR;
    HttpChars[']'] |= HTTP_SEPERATOR;
    HttpChars['?'] |= HTTP_SEPERATOR;
    HttpChars['='] |= HTTP_SEPERATOR;
    HttpChars['{'] |= HTTP_SEPERATOR;
    HttpChars['}'] |= HTTP_SEPERATOR;
    HttpChars[SP] |= HTTP_SEPERATOR;
    HttpChars[HT] |= HTTP_SEPERATOR;


    //
    // URL "reserved" characters (rfc2396)
    //

    HttpChars[';'] |= URL_LEGAL;
    HttpChars['/'] |= URL_LEGAL;
    HttpChars['\\'] |= URL_LEGAL;
    HttpChars['?'] |= URL_LEGAL;
    HttpChars[':'] |= URL_LEGAL;
    HttpChars['@'] |= URL_LEGAL;
    HttpChars['&'] |= URL_LEGAL;
    HttpChars['='] |= URL_LEGAL;
    HttpChars['+'] |= URL_LEGAL;
    HttpChars['$'] |= URL_LEGAL;
    HttpChars[','] |= URL_LEGAL;


    //
    // URL escape character
    //

    HttpChars['%'] |= URL_LEGAL;

    //
    // URL "mark" characters (rfc2396)
    //

    HttpChars['-'] |= URL_LEGAL;
    HttpChars['_'] |= URL_LEGAL;
    HttpChars['.'] |= URL_LEGAL;
    HttpChars['!'] |= URL_LEGAL;
    HttpChars['~'] |= URL_LEGAL;
    HttpChars['*'] |= URL_LEGAL;
    HttpChars['\''] |= URL_LEGAL;
    HttpChars['('] |= URL_LEGAL;
    HttpChars[')'] |= URL_LEGAL;


    //
    // RFC2396 describes these characters as `unwise' "because gateways and
    // other transport agents are known to sometimes modify such characters,
    // or they are used as delimiters". However, for compatibility with IIS
    // 5.0 and DAV, we must allow these unwise characters in URLs.
    //

    HttpChars['{'] |= URL_LEGAL;
    HttpChars['}'] |= URL_LEGAL;
    HttpChars['|'] |= URL_LEGAL;
    HttpChars['^'] |= URL_LEGAL;
    HttpChars['['] |= URL_LEGAL;
    HttpChars[']'] |= URL_LEGAL;
    HttpChars['`'] |= URL_LEGAL;

    //
    // These US-ASCII characters are "excluded"; i.e. not URL_LEGAL (see RFC):
    //      '<' | '>' | '#' | '%' | '"' (0x22) | ' ' (0x20)
    // In addition, control characters (0x00-0x1F and 0x7F) and
    // non US-ASCII characters (0x80-0xFF) are not URL_LEGAL.
    //

    for (i = 0; i < 128; i++)
    {
        if (!IS_HTTP_SEPERATOR(i) && !IS_HTTP_CTL(i))
        {
            HttpChars[i] |= HTTP_TOKEN;
        }
    }


    //
    // Fast path for PopChar
    //

    RtlZeroMemory(FastPopChars, 256 * sizeof(USHORT));
    RtlZeroMemory(DummyPopChars, 256 * sizeof(USHORT));

    for (i = 0; i < 256; i++)
    {
        c = (UCHAR)i;

        if (IS_URL_TOKEN(c) && c != '%' && (c & 0x80) != 0x80)
        {
            FastPopChars[i] = (USHORT)c;
        }
    }

    //
    // Turn backslashes into forward slashes
    //

    FastPopChars['\\'] = L'/';


    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    Allocates brand new UL_NONPAGED_RESOURCE structures from the
    lookaside lists

Arguments:


Return Value:

    the resource.  NULL = out of memory.

--***************************************************************************/
PUL_NONPAGED_RESOURCE
UlResourceNew(
    ULONG OwnerTag
    )
{
    PUL_NONPAGED_RESOURCE pResource;

    pResource = (PUL_NONPAGED_RESOURCE)(
                    PplAllocate(
                        g_pUlNonpagedData->ResourceLookaside
                        )
                    );

    if (pResource != NULL)
    {
        pResource->Signature = UL_NONPAGED_RESOURCE_SIGNATURE;
#if DBG
        pResource->Resource.OwnerTag = OwnerTag;
#endif
        pResource->RefCount = 1;

        UlTrace(
            REFCOUNT,
            ("ul!UlResourceNew res=%p tag=0x%08x refcount=%d\n",
                pResource, OwnerTag,
                pResource->RefCount)
            );

    }

    return pResource;
}

/***************************************************************************++

Routine Description:

    Reference a resource.

Arguments:

    pResource - the resource

Return Value:

    VOID

--***************************************************************************/
VOID
UlReferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_UL_NONPAGED_RESOURCE(pResource));

    refCount = InterlockedIncrement( &pResource->RefCount );

    UlTrace(
        REFCOUNT,
        ("ul!UlReferenceResource res=%p refcount=%d\n",
            pResource,
            refCount)
        );

}   // UlReferenceResource


/***************************************************************************++

Routine Description:

    Dereference a resource.

Arguments:

    pResource - the resource

Return Value:

    VOID

--***************************************************************************/
VOID
UlDereferenceResource(
    PUL_NONPAGED_RESOURCE pResource
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_UL_NONPAGED_RESOURCE(pResource));

    refCount = InterlockedDecrement( &pResource->RefCount );

    UlTrace(
        REFCOUNT,
        ("ul!UlDereferenceResource res=%p refcount=%d\n",
            pResource,
            refCount)
        );

    if (refCount == 0)
    {
        //
        // free it
        //

        PplFree(
            g_pUlNonpagedData->ResourceLookaside,
            pResource
            );
    }

}   // UlDereferenceResource


/***************************************************************************++

Routine Description:

    support function for lookasides to allocate the memory for
    UL_NONPAGED_RESOURCEs

Arguments:

    PoolType - the pool type

    ByteLength - how much to alloc

    Tag - the tag to use

Return Value:

    nt status code

--***************************************************************************/
PVOID
UlResourceAllocatePool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    )
{
    NTSTATUS Status;
    PUL_NONPAGED_RESOURCE pResource;

    ASSERT( PoolType == NonPagedPool );
    ASSERT( ByteLength == sizeof(UL_NONPAGED_RESOURCE) );
    ASSERT( Tag == UL_NONPAGED_RESOURCE_POOL_TAG );


    pResource = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    UL_NONPAGED_RESOURCE,
                    UL_NONPAGED_RESOURCE_POOL_TAG
                    );

    if (pResource != NULL)
    {
        pResource->Signature = UL_NONPAGED_RESOURCE_SIGNATURE;
        pResource->RefCount = 1;

        Status = UlInitializeResource(
                        &pResource->Resource,
                        "UL_NONPAGED_RESOURCE[%p].Resource",
                        pResource,
                        UL_NONPAGED_RESOURCE_POOL_TAG
                        );

        if (NT_SUCCESS(Status) == FALSE)
        {
            UL_FREE_POOL_WITH_SIG(pResource, UL_NONPAGED_RESOURCE_POOL_TAG);
            return NULL;
        }

    }

    return (PVOID)(pResource);
}

/***************************************************************************++

Routine Description:

    support function for lookasides to free the memory for
    UL_NONPAGED_RESOURCE's

Arguments:

    pBuffer - the UL_NONPAGED_RESOURCE buffer to free

Return Value:

    VOID

--***************************************************************************/
VOID
UlResourceFreePool(
    IN PVOID pBuffer
    )
{
    PUL_NONPAGED_RESOURCE pResource;
    NTSTATUS Status;

    pResource = (PUL_NONPAGED_RESOURCE)(pBuffer);

    ASSERT(pResource != NULL);
    ASSERT(pResource->Signature == UL_NONPAGED_RESOURCE_SIGNATURE);

    pResource->Signature = UL_NONPAGED_RESOURCE_SIGNATURE_X;


    Status = UlDeleteResource(&pResource->Resource);
    ASSERT(NT_SUCCESS(Status));

    UL_FREE_POOL_WITH_SIG(
        pResource,
        UL_NONPAGED_RESOURCE_POOL_TAG
        );

}   // UlResourceFreePool

/***************************************************************************++

Routine Description:

    Invokes the completion routine (if specified) and determines the
    appropriate return code. This routine ensures that, if the completion
    routine is invoked, the caller always returns STATUS_PENDING.

Arguments:

    Status - Supplies the completion status.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status. Will always be STATUS_PENDING if the
        completion routine is invoked.

--***************************************************************************/
NTSTATUS
UlInvokeCompletionRoutine(
    IN NTSTATUS Status,
    IN ULONG_PTR Information,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    if (pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            Information
            );

        Status = STATUS_PENDING;
    }

    return Status;

}   // UlInvokeCompletionRoutine


//
// constants used by the date formatter
//

const PWSTR pDays[] =
{
   L"Sun", L"Mon", L"Tue", L"Wed", L"Thu", L"Fri", L"Sat"
};

const PWSTR pMonths[] =
{
    L"Jan", L"Feb", L"Mar", L"Apr", L"May", L"Jun", L"Jul",
    L"Aug", L"Sep", L"Oct", L"Nov", L"Dec"
};

__inline
VOID
TwoDigitsToUnicode(
    PWSTR pBuffer,
    ULONG Number
    )
{
    pBuffer[0] = L'0' + (WCHAR)(Number / 10);
    pBuffer[1] = L'0' + (WCHAR)(Number % 10);
}


/***************************************************************************++

Routine Description:

    Converts the given system time to string representation containing
    GMT Formatted String.

Arguments:

    pTime - System time that needs to be converted.

    pBuffer - pointer to string which will contain the GMT time on
        successful return.

    BufferLength - size of pszBuff in bytes

Return Value:

    NTSTATUS

History:

     MuraliK        3-Jan-1995
     paulmcd        4-Mar-1999  copied to ul

--***************************************************************************/

NTSTATUS
TimeFieldsToHttpDate(
    IN  PTIME_FIELDS pTime,
    OUT PWSTR pBuffer,
    IN  ULONG BufferLength
    )
{
    NTSTATUS Status;

    ASSERT(pBuffer != NULL);

    if (BufferLength < (HTTP_DATE_COUNT + 1)*sizeof(WCHAR))
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //                          0         1         2
    //                          01234567890123456789012345678
    //  Formats a string like: "Thu, 14 Jul 1994 15:26:05 GMT"
    //

    //
    // write the constants
    //

    pBuffer[3] = L',';
    pBuffer[4] = pBuffer[7] = pBuffer[11] = L' ';
    pBuffer[19] = pBuffer[22] = L':';

    //
    // now the variants
    //

    //
    // 0-based Weekday
    //

    RtlCopyMemory(&(pBuffer[0]), pDays[pTime->Weekday], 3*sizeof(WCHAR));

    TwoDigitsToUnicode(&(pBuffer[5]), pTime->Day);

    //
    // 1-based Month
    //

    RtlCopyMemory(&(pBuffer[8]), pMonths[pTime->Month - 1], 3*sizeof(WCHAR)); // 1-based

    Status = _RtlIntegerToUnicode(pTime->Year, 10, 5, &(pBuffer[12]));
    ASSERT(NT_SUCCESS(Status));

    pBuffer[16] = L' ';

    TwoDigitsToUnicode(&(pBuffer[17]), pTime->Hour);
    TwoDigitsToUnicode(&(pBuffer[20]), pTime->Minute);
    TwoDigitsToUnicode(&(pBuffer[23]), pTime->Second);

    RtlCopyMemory(&(pBuffer[25]), L" GMT", sizeof(L" GMT"));

    return STATUS_SUCCESS;

}   // TimeFieldsToHttpDate


__inline
SHORT
FASTCALL
AsciiToShort(
    PCHAR pString
    )
{
    return (SHORT)atoi(pString);
}


__inline
SHORT
FASTCALL
TwoAsciisToShort(
    PCHAR pString
    )
{
    SHORT Value;
    SHORT Number;

    Number = pString[1] - '0';

    if (Number <= 9)
    {
        Value = Number;
        Number = pString[0] - '0';

        if (Number <= 9)
        {
            Value += Number * 10;
            return Value;
        }
    }

    return 0;
}


/***************************************************************************++
  DateTime function ported from user mode W3SVC
--***************************************************************************/

/************************************************************
 *   Data
 ************************************************************/

static const PSTR s_rgchMonths[] = {
    "Jan", "Feb", "Mar", "Apr",
    "May", "Jun", "Jul", "Aug",
    "Sep", "Oct", "Nov", "Dec"
};

// Custom hash table for NumericToAsciiMonth() for mapping "Apr" to 4
static const CHAR MonthIndexTable[64] = {
   -1,'A',  2, 12, -1, -1, -1,  8, // A to G
   -1, -1, -1, -1,  7, -1,'N', -1, // F to O
    9, -1,'R', -1, 10, -1, 11, -1, // P to W
   -1,  5, -1, -1, -1, -1, -1, -1, // X to Z
   -1,'A',  2, 12, -1, -1, -1,  8, // a to g
   -1, -1, -1, -1,  7, -1,'N', -1, // f to o
    9, -1,'R', -1, 10, -1, 11, -1, // p to w
   -1,  5, -1, -1, -1, -1, -1, -1  // x to z
};

/************************************************************
 *   Functions
 ************************************************************/

/***************************************************************************++

    Converts three letters of a month to numeric month

    Arguments:
        s   String to convert

    Returns:
        numeric equivalent, 0 on failure.

--***************************************************************************/
__inline
SHORT
FASTCALL
NumericToAsciiMonth(
    PCHAR s
    )
{
    UCHAR monthIndex;
    UCHAR c;
    PSTR monthString;

    //
    // use the third character as the index
    //

    c = (s[2] - 0x40) & 0x3F;

    monthIndex = MonthIndexTable[c];

    if ( monthIndex < 13 ) {
        goto verify;
    }

    //
    // ok, we need to look at the second character
    //

    if ( monthIndex == 'N' ) {

        //
        // we got an N which we need to resolve further
        //

        //
        // if s[1] is 'u' then Jun, if 'a' then Jan
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 1;
        } else {
            monthIndex = 6;
        }

    } else if ( monthIndex == 'R' ) {

        //
        // if s[1] is 'a' then March, if 'p' then April
        //

        if ( MonthIndexTable[(s[1]-0x40) & 0x3f] == 'A' ) {
            monthIndex = 3;
        } else {
            monthIndex = 4;
        }
    } else {
        goto error_exit;
    }

verify:

    monthString = (PSTR) s_rgchMonths[monthIndex-1];

    if ( (s[0] == monthString[0]) &&
         (s[1] == monthString[1]) &&
         (s[2] == monthString[2]) ) {

        return(monthIndex);

    } else if ( (toupper(s[0]) == monthString[0]) &&
                (tolower(s[1]) == monthString[1]) &&
                (tolower(s[2]) == monthString[2]) ) {

        return monthIndex;
    }

error_exit:
    return(0);

} // NumericToAsciiMonth


/***************************************************************************++

  Converts a string representation of a GMT time (three different
  varieties) to an NT representation of a file time.

  We handle the following variations:

    Sun, 06 Nov 1994 08:49:37 GMT   (RFC 822 updated by RFC 1123)
    Sunday, 06-Nov-94 08:49:37 GMT  (RFC 850)
    Sun Nov  6 08:49:37 1994        (ANSI C's asctime() format

  Arguments:
    pszTime             String representation of time field
    pliTime             large integer containing the time in NT format.

  Returns:
    TRUE on success and FALSE on failure.

  History:

    Johnl       24-Jan-1995     Modified from WWW library
    ericsten    30-Nov-2000     Ported from user-mode W3SVC

--***************************************************************************/
BOOLEAN
StringTimeToSystemTime(
    IN  const PSTR pszTime,
    OUT LARGE_INTEGER * pliTime
    )
{

    PCHAR s;
    TIME_FIELDS    st;

    if (pszTime == NULL) {
        return FALSE;
    }

    st.Milliseconds = 0;

    if ((s = strchr(pszTime, ','))) {

        ULONG len;

        //
        // Thursday, 10-Jun-93 01:29:59 GMT
        // or: Thu, 10 Jan 1993 01:29:59 GMT */
        //

        s++;

        while (*s && *s==' ') s++;
        len = strlen(s);

        if (len < 18) {
            return FALSE;
        }

        if ( *(s+2) == '-' ) {        /* First format */

            st.Day    = AsciiToShort(s);
            st.Month  = NumericToAsciiMonth(s+3);
            st.Year   = AsciiToShort(s+7);
            st.Hour   = AsciiToShort(s+10);
            st.Minute = AsciiToShort(s+13);
            st.Second = AsciiToShort(s+16);

        } else {                /* Second format */

            if (len < 20) {
                return FALSE;
            }

            st.Day    = TwoAsciisToShort(s);
            st.Month  = NumericToAsciiMonth(s+3);
            st.Year   = TwoAsciisToShort(s+7) * 100 + TwoAsciisToShort(s+9);
            st.Hour   = TwoAsciisToShort(s+12);
            st.Minute = TwoAsciisToShort(s+15);
            st.Second = TwoAsciisToShort(s+18);

        }
    } else {    /* Try the other format:  Wed Jun  9 01:29:59 1993 GMT */

        s = (PCHAR) pszTime;
        while (*s && *s==' ') s++;

        if ((int)strlen(s) < 24) {
            return FALSE;
        }

        if (isdigit(*(s+8))) {
            st.Day    = AsciiToShort(s+8);
        } else {
            if ( ' ' != *(s+8) ) {
                return FALSE;
            }
            st.Day    = AsciiToShort(s+9);
        }
        st.Month  = NumericToAsciiMonth(s+4);
        st.Year   = AsciiToShort(s+20);
        st.Hour   = AsciiToShort(s+11);
        st.Minute = AsciiToShort(s+14);
        st.Second = AsciiToShort(s+17);
    }

    //
    //  Adjust for dates with only two digits
    //

    if ( st.Year < 1000 ) {
        if ( st.Year < 50 ) {
            st.Year += 2000;
        } else {
            st.Year += 1900;
        }
    }

    if ( !RtlTimeFieldsToTime( &st, pliTime )) {
        return FALSE;
    }
    return(TRUE);
}

/***************************************************************************++
  End of DateTime function ported from user mode W3SVC
--***************************************************************************/


//
// Some Unicode to Utf8 conversion utilities taken and modified frm
// base\win32\winnls\utf.c. Use this until they expose the same functionality
// in kernel.
//

/***************************************************************************++

Routine Description:

    Maps a Unicode character string to its UTF-8 string counterpart

    Conversion continues until the source is finished or an error happens in
    either case it returns the number of UTF-8 characters written.

    If the supllied buffer is not big enough it returns 0.

--***************************************************************************/

ULONG
HttpUnicodeToUTF8(
    IN  PCWSTR  lpSrcStr,
    IN  LONG    cchSrc,
    OUT LPSTR   lpDestStr,
    IN  LONG    cchDest
    )
{
    LPCWSTR     lpWC  = lpSrcStr;
    LONG        cchU8 = 0;                // # of UTF8 chars generated
    DWORD       dwSurrogateChar;
    WCHAR       wchHighSurrogate = 0;
    BOOLEAN     bHandled;

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 | (unsigned char)(dwSurrogateChar >> 18));             // 3 bits from 1st byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (unsigned char)((dwSurrogateChar >> 12) & 0x3f));    // 6 bits from 2nd byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (unsigned char)((dwSurrogateChar >> 6) & 0x3f));     // 6 bits from 3rd byte
                         lpDestStr[cchU8++] = (UTF8_TRAIL    | (unsigned char)(0x3f &dwSurrogateChar));             // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        return 0;
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return cchU8;
}


/*++

Routine Description:
    Search input list of ETags for one that matches our local ETag.

Arguments:
    pLocalETag   - The local ETag we're using.
    pETagList    - The ETag list we've received from the client.
    bWeakCompare - Whether using Weak Comparison is ok

Returns:

    TRUE if we found a matching ETag, FALSE otherwise.

Author:
     Anil Ruia (AnilR)            3-Apr-2000

History:
     Eric Stenson (EricSten)      6-Dec-2000    ported from user-mode


--*/
BOOLEAN FindInETagList(
    IN PUCHAR    pLocalETag,
    IN PUCHAR    pETagList,
    IN BOOLEAN   fWeakCompare
    )
{
    ULONG     QuoteCount;
    PUCHAR    pFileETag;
    BOOLEAN   Matched;

    // We'll loop through the ETag string, looking for ETag to
    // compare, as long as we have an ETag to look at.

    do
    {
        while (isspace(*pETagList))
        {
            pETagList++;
        }

        if (!*pETagList)
        {
            // Ran out of ETag.
            return FALSE;
        }

        // If this ETag is *, it's a match.
        if (*pETagList == '*')
        {
            return TRUE;
        }

        // See if this ETag is weak.
        if (pETagList[0] == 'W' && pETagList[1] == '/')
        {
            // This is a weak validator. If we're not doing the weak
            // comparison, fail.

            if (!fWeakCompare)
            {
                return FALSE;
            }

            // Skip over the 'W/', and any intervening whitespace.
            pETagList += 2;

            while (isspace(*pETagList))
            {
                pETagList++;
            }

            if (!*pETagList)
            {
                // Ran out of ETag.
                return FALSE;
            }
        }

        if (*pETagList != '"')
        {
            // This isn't a quoted string, so fail.
            return FALSE;
        }

        // OK, right now we should be at the start of a quoted string that
        // we can compare against our current ETag.

        QuoteCount = 0;

        Matched = TRUE;
        pFileETag = pLocalETag;

        // Do the actual compare. We do this by scanning the current ETag,
        // which is a quoted string. We look for two quotation marks, the
        // the delimiters if the quoted string. If after we find two quotes
        // in the ETag everything has matched, then we've matched this ETag.
        // Otherwise we'll try the next one.

        do
        {
            CHAR Temp;

            Temp = *pETagList;

            if (Temp == '"')
            {
                QuoteCount++;
            }

            if (*pFileETag != Temp)
            {
                Matched = FALSE;
            }

            if (!Temp)
            {
                return FALSE;
            }

            pETagList++;

            if (*pFileETag == '\0')
            {
                break;
            }

            pFileETag++;


        }
        while (QuoteCount != 2);

        if (Matched)
        {
            return TRUE;
        }

        // Otherwise, at this point we need to look at the next ETag.

        while (QuoteCount != 2)
        {
            if (*pETagList == '"')
            {
                QuoteCount++;
            }
            else
            {
                if (*pETagList == '\0')
                {
                    return FALSE;
                }
            }

            pETagList++;
        }

        while (isspace(*pETagList))
        {
            pETagList++;
        }

        if (*pETagList == ',')
        {
            pETagList++;
        }
        else
        {
            return FALSE;
        }

    }
    while ( *pETagList );

    return FALSE;
}


/*++

Routine Description:
    Build a NULL terminated UNICODE string from the IP and Port address

Arguments:
    IpAddressStringW    - String buffer to place the UNICODE string
                          (caller allocated)
    IpAddress           - 32-bit version of the IP address
    IpPortNum           - 16-bit version of the TCP Port

Returns:

    Count of bytes written into IpAddressStringW.

Author:
     Eric Stenson (EricSten)      29-Jan-2001

--*/

ULONG
HostAddressAndPortToStringW(
    IN OUT PWCHAR  IpAddressStringW,
    IN ULONG  IpAddress,
    IN USHORT IpPortNum
    )
{
    PWCHAR pszW = IpAddressStringW;

    pszW = UlStrPrintUlongW(pszW, (IpAddress >> 24) & 0xFF, 0, '.');
    pszW = UlStrPrintUlongW(pszW, (IpAddress >> 16) & 0xFF, 0, '.');
    pszW = UlStrPrintUlongW(pszW, (IpAddress >>  8) & 0xFF, 0, '.');
    pszW = UlStrPrintUlongW(pszW, (IpAddress >>  0) & 0xFF, 0, ':');
    pszW = UlStrPrintUlongW(pszW, IpPortNum,                0, '\0');

    return DIFF(pszW - IpAddressStringW) * sizeof(WCHAR);
}

/*++

Routine Description:

    Calculates current bias (daylight time aware) and time zone ID.    

    Captured from base\client\datetime.c

    Until this two functions are exposed in the kernel we have to 
    keep them here.
    
Arguments:

    IN CONST TIME_ZONE_INFORMATION *ptzi - time zone for which to calculate bias
    OUT KSYSTEM_TIME *pBias - current bias

Return Value:

    TIME_ZONE_ID_UNKNOWN - daylight saving time is not used in the 
        current time zone.

    TIME_ZONE_ID_STANDARD - The system is operating in the range covered
        by StandardDate.

    TIME_ZONE_ID_DAYLIGHT - The system is operating in the range covered
        by DaylightDate.

    TIME_ZONE_ID_INVALID - The operation failed.

--*/

ULONG 
UlCalcTimeZoneIdAndBias(
     IN  RTL_TIME_ZONE_INFORMATION *ptzi,
     OUT PLONG pBias
     )
{
    LARGE_INTEGER TimeZoneBias;
    LARGE_INTEGER NewTimeZoneBias;
    LARGE_INTEGER LocalCustomBias;
    LARGE_INTEGER UtcStandardTime;
    LARGE_INTEGER UtcDaylightTime;
    LARGE_INTEGER StandardTime;
    LARGE_INTEGER DaylightTime;
    LARGE_INTEGER CurrentUniversalTime;
    ULONG CurrentTimeZoneId = UL_TIME_ZONE_ID_INVALID;
    
    NewTimeZoneBias.QuadPart = Int32x32To64(ptzi->Bias*60, 10000000);

    //
    // Now see if we have stored cutover times
    //
    
    if (ptzi->StandardStart.Month && ptzi->DaylightStart.Month) 
    {       
        KeQuerySystemTime(&CurrentUniversalTime);

        //
        // We have timezone cutover information. Compute the
        // cutover dates and compute what our current bias
        // is
        //

        if((!UlCutoverTimeToSystemTime(
                    &ptzi->StandardStart,
                    &StandardTime,
                    &CurrentUniversalTime)
                    ) || 
           (!UlCutoverTimeToSystemTime(
                    &ptzi->DaylightStart,
                    &DaylightTime,
                    &CurrentUniversalTime)
                    )
           ) 
        {
            return UL_TIME_ZONE_ID_INVALID;
        }

        //
        // Convert standard time and daylight time to utc
        //

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->StandardBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcDaylightTime.QuadPart = DaylightTime.QuadPart + TimeZoneBias.QuadPart;

        LocalCustomBias.QuadPart = Int32x32To64(ptzi->DaylightBias*60, 10000000);
        TimeZoneBias.QuadPart = NewTimeZoneBias.QuadPart + LocalCustomBias.QuadPart;
        UtcStandardTime.QuadPart = StandardTime.QuadPart + TimeZoneBias.QuadPart;

        //
        // If daylight < standard, then time >= daylight and
        // less than standard is daylight
        //

        if (UtcDaylightTime.QuadPart < UtcStandardTime.QuadPart) 
        {
            //
            // If today is >= DaylightTime and < StandardTime, then
            // We are in daylight savings time
            //

            if ((CurrentUniversalTime.QuadPart >= UtcDaylightTime.QuadPart) &&
                (CurrentUniversalTime.QuadPart < UtcStandardTime.QuadPart)) 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_DAYLIGHT;
            } 
            else 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_STANDARD;
            }
        } 
        else 
        {
            //
            // If today is >= StandardTime and < DaylightTime, then
            // We are in standard time
            //

            if ((CurrentUniversalTime.QuadPart >= UtcStandardTime.QuadPart) &&
                (CurrentUniversalTime.QuadPart < UtcDaylightTime.QuadPart)) 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_STANDARD;

            } 
            else 
            {
                CurrentTimeZoneId = UL_TIME_ZONE_ID_DAYLIGHT;
            }
        }

        // Bias in minutes
        
        *pBias = ptzi->Bias + (CurrentTimeZoneId == UL_TIME_ZONE_ID_DAYLIGHT ?
                                ptzi->DaylightBias : ptzi->StandardBias
                                );
        
    } 
    else 
    {
        *pBias = ptzi->Bias;
        CurrentTimeZoneId = UL_TIME_ZONE_ID_UNKNOWN;
    }

    return CurrentTimeZoneId;
}

BOOLEAN
UlCutoverTimeToSystemTime(
    PTIME_FIELDS    CutoverTime,
    PLARGE_INTEGER  SystemTime,
    PLARGE_INTEGER  CurrentSystemTime
    )
{
    TIME_FIELDS     CurrentTimeFields;

    //
    // Get the current system time
    //

    RtlTimeToTimeFields(CurrentSystemTime,&CurrentTimeFields);

    //
    // check for absolute time field. If the year is specified,
    // the the time is an abosulte time
    //

    if ( CutoverTime->Year ) 
    {
        return FALSE;
    }
    else 
    {
        TIME_FIELDS WorkingTimeField;
        TIME_FIELDS ScratchTimeField;
        LARGE_INTEGER ScratchTime;
        CSHORT BestWeekdayDate;
        CSHORT WorkingWeekdayNumber;
        CSHORT TargetWeekdayNumber;
        CSHORT TargetYear;
        CSHORT TargetMonth;
        CSHORT TargetWeekday;     // range [0..6] == [Sunday..Saturday]
        BOOLEAN MonthMatches;
        //
        // The time is an day in the month style time
        //
        // the convention is the Day is 1-5 specifying 1st, 2nd... Last
        // day within the month. The day is WeekDay.
        //

        //
        // Compute the target month and year
        //

        TargetWeekdayNumber = CutoverTime->Day;
        if ( TargetWeekdayNumber > 5 || TargetWeekdayNumber == 0 ) {
            return FALSE;
            }
        TargetWeekday = CutoverTime->Weekday;
        TargetMonth = CutoverTime->Month;
        MonthMatches = FALSE;
        
        TargetYear = CurrentTimeFields.Year;
        
        try_next_year:
            
        BestWeekdayDate = 0;

        WorkingTimeField.Year = TargetYear;
        WorkingTimeField.Month = TargetMonth;
        WorkingTimeField.Day = 1;
        WorkingTimeField.Hour = CutoverTime->Hour;
        WorkingTimeField.Minute = CutoverTime->Minute;
        WorkingTimeField.Second = CutoverTime->Second;
        WorkingTimeField.Milliseconds = CutoverTime->Milliseconds;
        WorkingTimeField.Weekday = 0;

        //
        // Convert to time and then back to time fields so we can determine
        // the weekday of day 1 on the month
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);

        //
        // Compute bias to target weekday
        //
        if ( ScratchTimeField.Weekday > TargetWeekday ) {
            WorkingTimeField.Day += (7-(ScratchTimeField.Weekday - TargetWeekday));
            }
        else if ( ScratchTimeField.Weekday < TargetWeekday ) {
            WorkingTimeField.Day += (TargetWeekday - ScratchTimeField.Weekday);
            }

        //
        // We are now at the first weekday that matches our target weekday
        //

        BestWeekdayDate = WorkingTimeField.Day;
        WorkingWeekdayNumber = 1;

        //
        // Keep going one week at a time until we either pass the
        // target weekday, or we match exactly
        //

        while ( WorkingWeekdayNumber < TargetWeekdayNumber ) {
            WorkingTimeField.Day += 7;
            if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
                break;
                }
            RtlTimeToTimeFields(&ScratchTime,&ScratchTimeField);
            WorkingWeekdayNumber++;
            BestWeekdayDate = ScratchTimeField.Day;
            }
        WorkingTimeField.Day = BestWeekdayDate;

        //
        // If the months match, and the date is less than the current
        // date, then be have to go to next year.
        //

        if ( !RtlTimeFieldsToTime(&WorkingTimeField,&ScratchTime) ) {
            return FALSE;
            }
        if ( MonthMatches ) {
            if ( WorkingTimeField.Day < CurrentTimeFields.Day ) {
                MonthMatches = FALSE;
                TargetYear++;
                goto try_next_year;
                }
            if ( WorkingTimeField.Day == CurrentTimeFields.Day ) {

                if (ScratchTime.QuadPart < CurrentSystemTime->QuadPart) {
                    MonthMatches = FALSE;
                    TargetYear++;
                    goto try_next_year;
                    }
                }
            }
        *SystemTime = ScratchTime;

        return TRUE;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\opaqueid.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    opaqueid.cxx

Abstract:

    This module implements the opaque ID table. The ID table is
    implemented as a two-level array.

    The first level is an array of pointers to the second-level arrays.
    This first-level array is not growable, but its size is controlled
    by a registry key.

    The second level is an array of ID_TABLE_ENTRY structures. These
    structures contain a cyclic (to detect stale IDs) and caller-supplied
    context value.

    The data structures may be diagrammed as follows:

        g_FirstLevelTable[i]
               |
               |   +-----+
               |   |     |      +-----+-----+-----+----+...--+-----+-----+
               |   |     |      | ID_       | ID_      |     | ID_       |
               +-->|  *-------->| TABLE_    | TABLE_   |     | TABLE_    |
                   |     |      | ENTRY     | ENTRY    |     | ENTRY     |
                   |     |      +-----+-----+-----+----+--...+-----+-----+
                   +-----+
                   |     |      +-----+-----+-----+----+...--+-----+-----+
                   |     |      | ID_       | ID_      |     | ID_       |
                   |  *-------->| TABLE_    | TABLE_   |     | TABLE_    |
                   |     |      | ENTRY     | ENTRY    |     | ENTRY     |
                   |     |      +-----+-----+-----+----+--...+-----+-----+
                   +-----+
                   |     .
                   |     .
                   .     .
                   .     |
                   .     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+

    Because the lock protecting the single, global table of opaque IDs
    turned out to be a major scalability bottleneck on SMP machines, we
    now maintain per-processor subtables of opaque IDs. In addition, each
    ID_TABLE_ENTRY itself has a small lock that protects the fields inside
    it. This means we usually don't need to take the per-table spinlock.
    The per-table lock is only used when we grow the second-level table,
    in which case we have to protect the first-level table index and its
    pointer to the new second-level table.

    Note that all free ID_TABLE_ENTRY structures are kept on a single
    (global) free list. Whenever a new ID needs to be allocated, the free
    list is consulted. If it's not empty, an item is popped from the list
    and used. If the list is empty, then new space must be allocated. This
    will involve the allocation of a new second-level array.

    A HTTP_OPAQUE_ID is opaque at user-mode. Internally, it consists of 5
    fields:

        1) A processor number the ID was allocated on. This tells which
           per-processor table to free the ID.
        2) An index into the first-level array.
        3) An index into the second-level array referenced by the
           first-level index.
        4) A cyclic for the ID, used to detect stale IDs.
        5) An opaque ID type, used to guard against misuse of opaque IDs.

    See the OPAQUE_ID_INTERNAL structure definition (opaqueidp.h) for details.

    Note that most of the routines in this module assume they are called
    at PASSIVE_LEVEL.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private globals.
//

DECLSPEC_ALIGN(UL_CACHE_LINE)
UL_ALIGNED_OPAQUE_ID_TABLE g_UlOpaqueIdTable[MAXIMUM_PROCESSORS];


#ifdef OPAQUE_ID_INSTRUMENTATION
LONGLONG g_NumberOfTotalGets = 0;
LONGLONG g_NumberOfSuccessfulGets = 0;
#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeOpaqueIdTable )
#pragma alloc_text( PAGE, UlTerminateOpaqueIdTable )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlAllocateOpaqueId
NOT PAGEABLE -- UlFreeOpaqueId
NOT PAGEABLE -- UlGetObjectFromOpaqueId
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the opaque ID package.

Arguments:

    None

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeOpaqueIdTable(
    VOID
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    LONG i;

    //
    // Allocate the first-level opaque ID table arrry.
    //

    for (i = 0; i < (LONG)g_UlNumberOfProcessors; i++)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

        RtlZeroMemory(
            pOpaqueIdTable,
            sizeof(UL_OPAQUE_ID_TABLE)
            );

        pOpaqueIdTable->FirstLevelTable = UL_ALLOCATE_ARRAY(
                                                NonPagedPool,
                                                PUL_OPAQUE_ID_TABLE_ENTRY,
                                                g_UlOpaqueIdTableSize,
                                                UL_OPAQUE_ID_TABLE_POOL_TAG
                                                );

        if (pOpaqueIdTable->FirstLevelTable != NULL)
        {
            //
            // Initialization.
            //

            InitializeSListHead( &pOpaqueIdTable->FreeOpaqueIdSListHead );

            UlInitializeSpinLock( &pOpaqueIdTable->Lock, "OpaqueIdTableLock" );

            pOpaqueIdTable->FirstLevelTableSize = g_UlOpaqueIdTableSize;
            pOpaqueIdTable->FirstLevelTableInUse = 0;
            pOpaqueIdTable->Processor = (UCHAR)i;

            //
            // Zero out the first-level table.
            //

            RtlZeroMemory(
                pOpaqueIdTable->FirstLevelTable,
                g_UlOpaqueIdTableSize * sizeof(PUL_OPAQUE_ID_TABLE_ENTRY)
                );
        }
        else
        {
            while (--i >= 0)
            {
                pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

                UL_FREE_POOL(
                    pOpaqueIdTable->FirstLevelTable,
                    UL_OPAQUE_ID_TABLE_POOL_TAG
                    );
            }

            return STATUS_NO_MEMORY;
        }
    }

    return STATUS_SUCCESS;
}


/***************************************************************************++

Routine Description:

    Performs global termination of the opaque ID package.

Arguments:

    None

Return Value:

    None

--***************************************************************************/
VOID
UlTerminateOpaqueIdTable(
    VOID
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    ULONG i, j;

    for (i = 0; i < g_UlNumberOfProcessors; i++)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[i].OpaqueIdTable;

#ifdef OPAQUE_ID_INSTRUMENTATION
        ASSERT( pOpaqueIdTable->NumberOfAllocations ==
                pOpaqueIdTable->NumberOfFrees );
#endif

        //
        // Free all allocated second-level tables.
        //

        for (j = 0; j < pOpaqueIdTable->FirstLevelTableInUse; j++)
        {
            ASSERT( pOpaqueIdTable->FirstLevelTable[j] != NULL );

            UL_FREE_POOL(
                pOpaqueIdTable->FirstLevelTable[j],
                UL_OPAQUE_ID_TABLE_POOL_TAG
                );
        }

        //
        // Free the first-level table.
        //

        if (pOpaqueIdTable->FirstLevelTable != NULL)
        {
            UL_FREE_POOL(
                pOpaqueIdTable->FirstLevelTable,
                UL_OPAQUE_ID_TABLE_POOL_TAG
                );
        }
    }
}


/***************************************************************************++

Routine Description:

    Allocates a new opaque ID and associates it with the specified
    context. A new opaque ID takes a new slot in the opaque ID table.

Arguments:

    pOpaqueId - Receives the newly allocated opaque ID if successful.

    OpaqueIdType - Supplies the opaque ID type to be associated with
        the opaque ID and associated object.

    pContext - Supplies the context to associate with the new opaque ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAllocateOpaqueId(
    OUT PHTTP_OPAQUE_ID pOpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PVOID pContext
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    PSINGLE_LIST_ENTRY pListEntry;
    PUL_OPAQUE_ID_INTERNAL pInternalId;
    ULONG CurrentProcessor;
    ULONG CapturedFirstTableInUse;
    NTSTATUS Status;
    KIRQL OldIrql;

    //
    // Allocate a new opaque ID from the current processor table.  We need
    // a new entry for each ID.
    //

    CurrentProcessor = KeGetCurrentProcessorNumber();
    pOpaqueIdTable = &g_UlOpaqueIdTable[CurrentProcessor].OpaqueIdTable;

    //
    // Loop, trying to allocate an item from the table.
    //

    do
    {
        //
        // Remember the first-level table index if we need to expand later.
        //

        CapturedFirstTableInUse =
            *((volatile LONG *) &pOpaqueIdTable->FirstLevelTableInUse);

        pListEntry = InterlockedPopEntrySList(
                        &pOpaqueIdTable->FreeOpaqueIdSListHead
                        );

        if (pListEntry != NULL)
        {
            //
            // The free list isn't empty, so we can just use this
            // entry. We'll calculate the indices for this entry
            // and initialize the entry.
            //

            pEntry = CONTAINING_RECORD(
                        pListEntry,
                        UL_OPAQUE_ID_TABLE_ENTRY,
                        FreeListEntry
                        );

            pInternalId = (PUL_OPAQUE_ID_INTERNAL) pOpaqueId;

            UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

            //
            // Processor and FirstIndex are ready to use.
            //

            pInternalId->Index = pEntry->Index;

            //
            // Re-compute SecondIndex because its corresponding field has
            // been overwritten by Cyclic and OpaqueIdType when the entry
            // is in use.
            //

            pInternalId->SecondIndex =
                (pEntry - pOpaqueIdTable->FirstLevelTable[pEntry->FirstIndex]);

            //
            // Set the context associated with this entry.
            //

            pEntry->pContext = pContext;

            //
            // Update the cyclic and ID type of the entry.
            //

            pEntry->OpaqueIdCyclic = ++pEntry->EntryOpaqueIdCyclic;
            pEntry->OpaqueIdType = OpaqueIdType;

            pInternalId->Cyclic = pEntry->Cyclic;

            UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );

#ifdef OPAQUE_ID_INSTRUMENTATION
            UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfAllocations );
#endif

            Status = STATUS_SUCCESS;
            break;
        }

        //
        // We only make it to this point if the free list is empty,
        // meaning we need to do some memory allocations before
        // we can continue. We'll put this off into a separate routine
        // to keep this one small (to avoid cache thrash). The realloc
        // routine returns STATUS_SUCCESS if it (or another thread)
        // managed to successfully reallocate the tables. Otherwise, it
        // returns a failure code.
        //

        Status = UlpExpandOpaqueIdTable(
                    pOpaqueIdTable,
                    CapturedFirstTableInUse
                    );

    } while ( Status == STATUS_SUCCESS );

    return Status;
}


/***************************************************************************++

Routine Description:

    Frees the specified opaque ID. This frees up the slot in the ID
    table as well.

Arguments:

    OpaqueId - Supplies the opaque ID to free.

    OpaqueIdType - Supplies the opaque ID type associated with the opaque ID.

Return Value:

    None

--***************************************************************************/
VOID
UlFreeOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    ULONG Processor;
    ULONG FirstIndex;
    ULONG SecondIndex;
    BOOLEAN Result;
    KIRQL OldIrql;

    //
    // Obtain the global opaque ID table and the entry associated with the
    // opaque ID passed in.
    //

    Result = UlpExtractIndexFromOpaqueId(
                OpaqueId,
                &Processor,
                &FirstIndex,
                &SecondIndex
                );

    ASSERT( Result );

    pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
    pEntry = pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;

    UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

    ASSERT( pEntry->OpaqueIdType != UlOpaqueIdTypeInvalid );
    ASSERT( pEntry->OpaqueIdType == OpaqueIdType );
    ASSERT( pEntry->pContext != NULL );
    ASSERT( pEntry->OpaqueIdCyclic ==
            ((PUL_OPAQUE_ID_INTERNAL)&OpaqueId)->OpaqueIdCyclic );

    //
    // Restore the processor and first-level index but set the ID type
    // to invalid. This ensures subsequent mapping attempts on the stale
    // opaque ID entry will fail.
    //

    pEntry->Processor = Processor;
    pEntry->FirstIndex = FirstIndex;

    //
    // Setting OpaqueIdType to UlOpaqueIdTypeInvalid means the entry is freed.
    //

    pEntry->OpaqueIdType = UlOpaqueIdTypeInvalid;

    UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );

    InterlockedPushEntrySList(
        &pOpaqueIdTable->FreeOpaqueIdSListHead,
        &pEntry->FreeListEntry
        );

#ifdef OPAQUE_ID_INSTRUMENTATION
    UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfFrees );
#endif
}


/***************************************************************************++

Routine Description:

    Maps the specified opaque ID to the corresponding context value.

Arguments:

    OpaqueId - Supplies the opaque ID to map.

    OpaqueIdType - Supplies the opaque ID type associated with the opaque ID.

    pReferenceRoutine - Supplies the reference routine to call on the mapped
        context if there is a match.

Return Value:

    PVOID - Returns the original context associated with the opaqued ID.

--***************************************************************************/
PVOID
UlGetObjectFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE pReferenceRoutine
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    UL_OPAQUE_ID_INTERNAL InternalId;
    ULONG Processor;
    ULONG FirstIndex;
    ULONG SecondIndex;
    PVOID pContext = NULL;
    BOOLEAN Result;
    KIRQL OldIrql;

    //
    // Sanity check.
    //

    ASSERT( OpaqueIdType != UlOpaqueIdTypeInvalid );
    ASSERT( pReferenceRoutine != NULL );

#ifdef OPAQUE_ID_INSTRUMENTATION
    UlInterlockedIncrement64( &g_NumberOfTotalGets );
#endif

    InternalId.OpaqueId = OpaqueId;

    //
    // Preliminary checking.
    //

    if (InternalId.OpaqueIdType != OpaqueIdType)
    {
        return pContext;
    }

    //
    // Obtain a matching ID table entry. If we get one, this means the
    // processor, first-level table index and second-level table index of
    // the ID passed in are valid.
    //

    Result = UlpExtractIndexFromOpaqueId(
                OpaqueId,
                &Processor,
                &FirstIndex,
                &SecondIndex
                );

    if (Result)
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
        pEntry = pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;
    }
    else
    {
        pEntry = NULL;
    }

    if (pEntry != NULL)
    {
#ifdef OPAQUE_ID_INSTRUMENTATION
        UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfTotalGets );
#endif

        //
        // Check other things inside the lock.
        //

        UlpAcquireOpaqueIdLock( &pEntry->Lock, &OldIrql );

        if (pEntry->OpaqueIdType == OpaqueIdType &&
            pEntry->OpaqueIdCyclic == InternalId.OpaqueIdCyclic)
        {
            ASSERT( pEntry->pContext != NULL );

            //
            // All matched so we set pContext.
            //

            pContext = pEntry->pContext;

            //
            // Invoke the caller's reference routine with the lock held.
            //

            (pReferenceRoutine)(
                pContext
                REFERENCE_DEBUG_ACTUAL_PARAMS
                );

#ifdef OPAQUE_ID_INSTRUMENTATION
            UlInterlockedIncrement64( &pOpaqueIdTable->NumberOfSuccessfulGets );
            UlInterlockedIncrement64( &g_NumberOfSuccessfulGets );
#endif
        }

        UlpReleaseOpaqueIdLock( &pEntry->Lock, OldIrql );
    }

    return pContext;
}


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Allocates a new second-level table.

Arguments:

    pOpaqueIdTable - Supplies the per-processor opaque ID table that we need
        to grow the second-level table.

    CapturedFirstTableInUse - Supplies the size of the first-level table as
        captured before InterlockedPopEntrySList. If this changes, it
        would mean another thread has allocated a new second-level table
        already and we return success right away in that case.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpExpandOpaqueIdTable(
    IN PUL_OPAQUE_ID_TABLE pOpaqueIdTable,
    IN LONG CapturedFirstTableInUse
    )
{
    PUL_OPAQUE_ID_TABLE_ENTRY pNewTable;
    PUL_OPAQUE_ID_TABLE_ENTRY pEntry;
    LONG FirstIndex;
    LONG Processor;
    NTSTATUS Status;
    KIRQL OldIrql;
    LONG i;

    //
    // Acquire the lock when expanding the table.  This protects the
    // FirstLevelTableInUse and its associated first-level table.
    //

    UlAcquireSpinLock( &pOpaqueIdTable->Lock, &OldIrql );

    //
    // Bail out if FirstLevelTableInUse has changed.  This means, though
    // unlikely, another thread has expanded the table for us.
    //

    if (CapturedFirstTableInUse < (LONG)(pOpaqueIdTable->FirstLevelTableInUse))
    {
        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // Fail the expansion if we reach the limit.
    //

    if (pOpaqueIdTable->FirstLevelTableInUse >=
        pOpaqueIdTable->FirstLevelTableSize)
    {
        Status = STATUS_ALLOTTED_SPACE_EXCEEDED;
        goto end;
    }

    //
    // Allocate a new second-level table.
    //

    pNewTable = UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    UL_OPAQUE_ID_TABLE_ENTRY,
                    SECOND_LEVEL_TABLE_SIZE,
                    UL_OPAQUE_ID_TABLE_POOL_TAG
                    );

    if (pNewTable == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // Initialize each table entry and push them to the global table's
    // free list.
    //

    RtlZeroMemory(
        pNewTable,
        sizeof(UL_OPAQUE_ID_TABLE_ENTRY) * SECOND_LEVEL_TABLE_SIZE
        );

    Processor = pOpaqueIdTable->Processor;
    FirstIndex = pOpaqueIdTable->FirstLevelTableInUse;

    for (i = 0, pEntry = pNewTable; i < SECOND_LEVEL_TABLE_SIZE; i++, pEntry++)
    {
        pEntry->Processor = Processor;
        pEntry->FirstIndex = FirstIndex;

        UlpInitializeOpaqueIdLock( &pEntry->Lock );

        InterlockedPushEntrySList(
            &pOpaqueIdTable->FreeOpaqueIdSListHead,
            &pEntry->FreeListEntry
            );
    }

    //
    // Adjust the first-level index forward.  Do this only after all entries
    // have been pushed to the global list so the IDs only become valid when
    // they indeed exist.  Because we have raised IRQL to DISPATCH level by
    // acquiring a spinlock, it is impossible for another thread to get in
    // and allocate an opaque ID from the current processor and its assoicated
    // global ID table.  All the map attempts on the IDs being pushed will
    // duely fail because we haven't moved first-level index forward during
    // the push.
    //

    ASSERT( pOpaqueIdTable->FirstLevelTable[FirstIndex] == NULL );

    pOpaqueIdTable->FirstLevelTable[FirstIndex] = pNewTable;
    pOpaqueIdTable->FirstLevelTableInUse++;

    Status = STATUS_SUCCESS;

end:

    UlReleaseSpinLock( &pOpaqueIdTable->Lock, OldIrql );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\nt4hack.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    nt4hack.h

Abstract:

    Random typedefs and macros stolen from the NT5 header files to
    make this driver build with the NT4 header files.

Author:

    Keith Moore (keithmo)       09-Aug-1999

Revision History:

--*/


#ifndef _NT4HACK_H_
#define _NT4HACK_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Typedefs and constants missing from the NT4 header files.
//

#ifdef TARGET_NT4
#include <basetsd.h>

#define C_ASSERT(e) typedef char __C_ASSERT__[(e)?1:-1]

#ifdef __cplusplus
#define EXTERN_C extern "C"
#else
#define EXTERN_C extern
#endif

#define ANSI_NULL ((CHAR)0)
#endif  // TARGET_NT4


//
// Wrap ExInterlockedCompareExchange64() and InterlockedCompareExchange()
// so they'll look the same on NT4 and NT5.
//

#ifdef TARGET_NT4
#define UlInterlockedCompareExchange64(pDest, pExch, pComp, pLock)      \
    (LONGLONG)ExInterlockedCompareExchange64(                           \
                    (PULONGLONG)(pDest),                                \
                    (PULONGLONG)(pExch),                                \
                    (PULONGLONG)(pComp),                                \
                    (pLock)                                             \
                    )

#define UlInterlockedCompareExchange(pDest, Exch, Comp)                 \
    (LONG)InterlockedCompareExchange(                                   \
                (PVOID *)(pDest),                                       \
                (PVOID)(Exch),                                          \
                (PVOID)(Comp)                                           \
                )
#else   // !TARGET_NT4
#define UlInterlockedCompareExchange64(pDest, pExch, pComp, pLock)      \
    (LONGLONG)ExInterlockedCompareExchange64(                           \
                    (PLONGLONG)(pDest),                                 \
                    (PLONGLONG)(pExch),                                 \
                    (PLONGLONG)(pComp),                                 \
                    (pLock)                                             \
                    )

#define UlInterlockedCompareExchange(pDest, Exch, Comp)                 \
    (LONG)InterlockedCompareExchange(                                   \
                (LONG *)(pDest),                                        \
                (LONG)(Exch),                                           \
                (LONG)(Comp)                                            \
                )
#endif  // TARGET_NT4


//
// NT5 introduced the OBJ_KERNEL_HANDLE object attribute, which is
// a Very Good Thing. We'd like to use it everywhere we create
// handles, but unfortunately NT4 does not support it.
//
// Here, we make an attempt to hide this.
//

#ifdef TARGET_NT4

#define UL_KERNEL_HANDLE 0

#define UlAttachToSystemProcess()                                       \
    do                                                                  \
    {                                                                   \
        ASSERT( g_pUlSystemProcess != NULL );                           \
        if (g_pUlSystemProcess != (PKPROCESS)PsGetCurrentProcess())     \
        {                                                               \
            KeAttachProcess( g_pUlSystemProcess );                      \
        }                                                               \
    } while (FALSE)

#define UlDetachFromSystemProcess()                                     \
    do                                                                  \
    {                                                                   \
        ASSERT( g_pUlSystemProcess != NULL );                           \
        if (g_pUlSystemProcess != (PKPROCESS)PsGetCurrentProcess())     \
        {                                                               \
            KeDetachProcess();                                          \
        }                                                               \
    } while (FALSE)

#else   // !TARGET_NT4

#define UL_KERNEL_HANDLE OBJ_KERNEL_HANDLE

#define UlAttachToSystemProcess() ASSERT( g_pUlSystemProcess != NULL )
#define UlDetachFromSystemProcess() ASSERT( g_pUlSystemProcess != NULL )

#endif  // TARGET_NT4


//
// Close a system handle, attaching to and detaching from the system
// process if necessary. Uses the above macros to hide the attach/detach.
//

#define UlCloseSystemHandle( handle )                                   \
    do                                                                  \
    {                                                                   \
        UlAttachToSystemProcess();                                      \
        (VOID)ZwClose( handle );                                        \
        UlDetachFromSystemProcess();                                    \
    } while (FALSE)


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _NT4HACK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\notify.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    notify.h

Abstract:

    This module contains the notification list utilities.
    A notification list is optionally synchronized with
    a user specified UL_ERESOURCE, and provides an iterator
    called UlNotifyAllEntries.

Author:

    Michael Courage (mcourage)  25-Jan-2000

Revision History:

--*/

#ifndef _NOTIFY_H_
#define _NOTIFY_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// forwards
//
typedef struct _UL_NOTIFY_ENTRY *PUL_NOTIFY_ENTRY;

//
// Notification function prototype.
// Invoked on a list notification.
//
// Arguments:
//      pEntry - the entry that is being notified
//      pv     - "anything" parameter from UlNotifyEntries caller
//
// Return Value:
//      Function returns TRUE to continue iterating through the list
//      or FALSE to stop iterating.
//
typedef
BOOLEAN
(*PUL_NOTIFY_FUNC)(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID            pHost,
    IN PVOID            pv
    );


//
// The head of a notification list
//
typedef struct _UL_NOTIFY_HEAD
{
    //
    // A list of UL_NOTIFY_ENTRYs
    //
    LIST_ENTRY      ListHead;
    PUL_ERESOURCE   pResource;


} UL_NOTIFY_HEAD, *PUL_NOTIFY_HEAD;

//
// An entry in the notification list.
//
typedef struct _UL_NOTIFY_ENTRY
{
    //
    // List information.
    //
    LIST_ENTRY      ListEntry;
    PUL_NOTIFY_HEAD pHead;

    //
    // A pointer to the object containting this entry
    //
    PVOID           pHost;

} UL_NOTIFY_ENTRY, *PUL_NOTIFY_ENTRY;

//
// Notification List functions
//

VOID
UlInitializeNotifyHead(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_ERESOURCE pResource OPTIONAL
    );

VOID
UlInitializeNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID pHost
    );

VOID
UlAddNotifyEntry(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_NOTIFY_ENTRY pEntry
    );

VOID
UlRemoveNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry
    );

VOID
UlNotifyAllEntries(
    IN PUL_NOTIFY_FUNC pFunction,
    IN PUL_NOTIFY_HEAD pHead,
    IN PVOID pv OPTIONAL
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _NOTIFY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\notify.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    notify.cxx

Abstract:

    This module implements notification lists.

Author:

    Michael Courage (mcourage)  25-Jan-2000

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlAddNotifyEntry )
#pragma alloc_text( PAGE, UlRemoveNotifyEntry )
#pragma alloc_text( PAGE, UlNotifyAllEntries )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlInitializeNotifyHead
NOT PAGEABLE -- UlInitializeNotifyEntry
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes the head of the list.

Arguments:

    pHead - pointer to the head of list structure
    pResource - an optional pointer to a resource to synchronize access

--***************************************************************************/
VOID
UlInitializeNotifyHead(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_ERESOURCE pResource
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pHead);

    InitializeListHead(&pHead->ListHead);
    pHead->pResource = pResource;
}

/***************************************************************************++

Routine Description:

    Initializes an entry in a notify list.

Arguments:

    pEntry - the entry to be initialized
    pHost - A void context pointer assumed to be the containing object

--***************************************************************************/
VOID
UlInitializeNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry,
    IN PVOID pHost
    )
{
    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
    ASSERT(pEntry);
    ASSERT(pHost);

    pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;
    pEntry->pHead = NULL;
    pEntry->pHost = pHost;
}

/***************************************************************************++

Routine Description:

    Adds an entry to the tail of the list.

Arguments:

    pHead - Head of the target list
    pEntry - the entry to be added to the list

--***************************************************************************/
VOID
UlAddNotifyEntry(
    IN PUL_NOTIFY_HEAD pHead,
    IN PUL_NOTIFY_ENTRY pEntry
    )
{
    PAGED_CODE();
    ASSERT(pEntry);
    ASSERT(pHead);
    ASSERT(pEntry->pHead == NULL);
    ASSERT(pEntry->ListEntry.Flink == NULL);

    if (pHead->pResource) {
        UlAcquireResourceExclusive(pHead->pResource, TRUE);
    }

    pEntry->pHead = pHead;
    InsertTailList(&pHead->ListHead, &pEntry->ListEntry);

    if (pHead->pResource) {
        UlReleaseResource(pHead->pResource);
    }
}

/***************************************************************************++

Routine Description:

    Removes an entry from the notify list it is on.

Arguments:

    pEntry - the entry to be removed

--***************************************************************************/
VOID
UlRemoveNotifyEntry(
    IN PUL_NOTIFY_ENTRY pEntry
    )
{
    PUL_NOTIFY_HEAD pHead;

    PAGED_CODE();
    ASSERT(pEntry);

    pHead = pEntry->pHead;

    if (pHead) {

        ASSERT(pEntry->ListEntry.Flink);


        if (pHead->pResource) {
            UlAcquireResourceExclusive(pHead->pResource, TRUE);
        }

        pEntry->pHead = NULL;
        RemoveEntryList(&pEntry->ListEntry);
        pEntry->ListEntry.Flink = pEntry->ListEntry.Blink = NULL;

        if (pHead->pResource) {
            UlReleaseResource(pHead->pResource);
        }
    }
}

/***************************************************************************++

Routine Description:

    An internal iterator that applies pFunction to every element in the
    list.

    We start at the head of the list, and keep iterating until we get to
    the end OR pFunction returns FALSE.

Arguments:

    pFunction - the function to call for each member of the list
    pHead - the head of the list over which we'll iterate
    pv - an arbitrary context pointer that will be passed to pFunction

--***************************************************************************/
VOID
UlNotifyAllEntries(
    IN PUL_NOTIFY_FUNC pFunction,
    IN PUL_NOTIFY_HEAD pHead,
    IN PVOID pv
    )
{
    PLIST_ENTRY pEntry;
    PUL_NOTIFY_ENTRY pNotifyEntry;
    PLIST_ENTRY pNextEntry;
    BOOLEAN Continue;

    PAGED_CODE();
    ASSERT(pHead);

    // grab the resource
    if (pHead->pResource) {
        UlAcquireResourceExclusive(pHead->pResource, TRUE);
    }


    //
    // Iterate through the list
    //
    pEntry = pHead->ListHead.Flink;
    Continue = TRUE;

    while (Continue && (pEntry != &pHead->ListHead)) {
        ASSERT(pEntry);

        pNotifyEntry = CONTAINING_RECORD(
                            pEntry,
                            UL_NOTIFY_ENTRY,
                            ListEntry
                            );

        pEntry = pEntry->Flink;

        //
        // Call the notification function
        //
        Continue = pFunction(
                        pNotifyEntry,
                        pNotifyEntry->pHost,
                        pv
                        );
    }

    // let go of the resource
    if (pHead->pResource) {
        UlReleaseResource(pHead->pResource);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\opaqueid.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    opaqueid.h

Abstract:

    This module contains declarations for manipulating opaque IDs to
    kernel-mode objects.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#ifndef _OPAQUEID_H_
#define _OPAQUEID_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// The maximum size of the first-level table.  Out of 32 bits, we use 6 bits
// for the processor (64) and 8 bits for the second-level table (256).  So
// we have 18 = (32 - 6 - 8) bits left, or 262,144 first-level tables per
// processor, for a total of 67,108,864 opaque IDs per processor.
//

#define MAX_OPAQUE_ID_TABLE_SIZE    (1 << (32 - 6 - 8))


//
// Types to set opaque IDs to for tag-like free checking.
//

typedef enum _UL_OPAQUE_ID_TYPE
{
    UlOpaqueIdTypeInvalid = 0,
    UlOpaqueIdTypeConfigGroup,
    UlOpaqueIdTypeHttpConnection,
    UlOpaqueIdTypeHttpRequest,
    UlOpaqueIdTypeRawConnection,

    UlOpaqueIdTypeMaximum

} UL_OPAQUE_ID_TYPE, *PUL_OPAQUE_ID_TYPE;


//
// Routines invoked to manipulate the reference count of an object.
//

typedef
VOID
(*PUL_OPAQUE_ID_OBJECT_REFERENCE)(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );


//
// Public functions.
//

NTSTATUS
UlInitializeOpaqueIdTable(
    VOID
    );

VOID
UlTerminateOpaqueIdTable(
    VOID
    );

NTSTATUS
UlAllocateOpaqueId(
    OUT PHTTP_OPAQUE_ID pOpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PVOID pContext
    );

VOID
UlFreeOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    );

PVOID
UlGetObjectFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PUL_OPAQUE_ID_OBJECT_REFERENCE pReferenceRoutine
    );


#ifdef __cplusplus
}; // extern "C"
#endif


#endif  // _OPAQUEID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\opaqueidp.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    opaqueidp.h

Abstract:

    This module contains declarations private to the opaque ID table. These
    declarations are placed in a separate .H file to make it easier to access
    them from within the kernel debugger extension DLL.

Author:

    Keith Moore (keithmo)       10-Sep-1999

Revision History:

--*/


#ifndef _OPAQUEIDP_H_
#define _OPAQUEIDP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// The internal structure of an HTTP_OPAQUE_ID.
//
// N.B. This structure must be EXACTLY the same size as an HTTP_OPAQUE_ID!
//

#define PROCESSOR_BIT_WIDTH             6
#define FIRST_INDEX_BIT_WIDTH           18
#define SECOND_INDEX_BIT_WIDTH          8
#define OPAQUE_ID_CYCLIC_BIT_WIDTH      29
#define OPAQUE_ID_TYPE_BIT_WIDTH        3

typedef union _UL_OPAQUE_ID_INTERNAL
{
    HTTP_OPAQUE_ID OpaqueId;

    struct
    {
        union
        {
            ULONG Index;

            struct
            {
                ULONG Processor :       PROCESSOR_BIT_WIDTH;
                ULONG FirstIndex :      FIRST_INDEX_BIT_WIDTH;
                ULONG SecondIndex :     SECOND_INDEX_BIT_WIDTH;
            };
        };

        union
        {
            ULONG Cyclic;

            struct
            {
                ULONG OpaqueIdCyclic :  OPAQUE_ID_CYCLIC_BIT_WIDTH;
                ULONG OpaqueIdType :    OPAQUE_ID_TYPE_BIT_WIDTH;
            };
        };
    };

} UL_OPAQUE_ID_INTERNAL, *PUL_OPAQUE_ID_INTERNAL;

C_ASSERT( sizeof(HTTP_OPAQUE_ID) == sizeof(UL_OPAQUE_ID_INTERNAL) );
C_ASSERT( 8 * sizeof(HTTP_OPAQUE_ID) == (PROCESSOR_BIT_WIDTH +          \
                                        FIRST_INDEX_BIT_WIDTH +         \
                                        SECOND_INDEX_BIT_WIDTH +        \
                                        OPAQUE_ID_CYCLIC_BIT_WIDTH +    \
                                        OPAQUE_ID_TYPE_BIT_WIDTH        \
                                        ));
C_ASSERT((1 << PROCESSOR_BIT_WIDTH) >= MAXIMUM_PROCESSORS);


//
// A per-entry opaque ID lock.
//

#define OPAQUE_ID_DPC

#ifdef OPAQUE_ID_DPC
typedef KSPIN_LOCK UL_OPAQUE_ID_LOCK, *PUL_OPAQUE_ID_LOCK;

__inline
VOID
FASTCALL
UlpInitializeOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock
    )
{
    KeInitializeSpinLock( pLock );

}

__inline
VOID
FASTCALL
UlpAcquireOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    OUT PKIRQL pOldIrql
    )
{
    KeAcquireSpinLock( pLock, pOldIrql );

}

__inline
VOID
FASTCALL
UlpReleaseOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    IN KIRQL OldIrql
    )
{
    KeReleaseSpinLock( pLock, OldIrql );

}
#else
typedef volatile LONG UL_OPAQUE_ID_LOCK, *PUL_OPAQUE_ID_LOCK;

__inline
VOID
FASTCALL
UlpInitializeOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock
    )
{
    *pLock = 0;

}

__inline
VOID
FASTCALL
UlpAcquireOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    OUT PKIRQL pOldIrql
    )
{
    while (TRUE)
    {
        while (*pLock == 1)
        {
            PAUSE_PROCESSOR
        }

        if (0 == InterlockedCompareExchange( pLock, 1, 0 ))
        {
            break;
        }
    }

}

__inline
VOID
FASTCALL
UlpReleaseOpaqueIdLock(
    IN PUL_OPAQUE_ID_LOCK pLock,
    IN KIRQL OldIrql
    )
{
    ASSERT( *pLock == 1 );

    InterlockedExchange( pLock, 0 );

}
#endif


//
// A second-level table entry.
//
// Note that FreeListEntry and pContext are in an anonymous
// union to save space; an entry is either on the free list or in use,
// so only one of these fields will be used at a time.
//
// Also note that Cyclic is in a second anonymous union. It's overlayed
// with FirstLevelIndex (which is basically the second-level table's
// index in the first-level table) and ID type (used to distinguish
// free entries from in-use entries).
//

#define SECOND_LEVEL_TABLE_SIZE 256

C_ASSERT( SECOND_LEVEL_TABLE_SIZE == 1 << SECOND_INDEX_BIT_WIDTH );

typedef struct _UL_OPAQUE_ID_TABLE_ENTRY
{
    //
    // NonPagedPool
    //

    union
    {
        //
        // To ensure FreeListEntry is aligned on 8-byte boundary.
        //

        ULONGLONG Alignment;

        struct
        {
            union
            {
                //
                // An entry to the global ID table's free ID list.
                //

                SINGLE_LIST_ENTRY FreeListEntry;

                //
                // Context associated with the opaque ID.
                //

                PVOID pContext;
            };

            //
            // A per-entry ID cyclic that guarantees we can generate
            // 2 ^ OPAQUE_ID_CYCLIC_BIT_WIDTH of opaque IDs from the
            // current entry without repeating. This gives us extra
            // protection than using a global ID cyclic.
            //

            ULONG EntryOpaqueIdCyclic;
        };
    };

    //
    // A per-entry lock that protects the entry.
    //

    UL_OPAQUE_ID_LOCK Lock;

    //
    // The ID index for the opaque ID when the entry is free or the cyclic
    // when the entry is in use.
    //

    union
    {
        union
        {
            ULONG Index;

            struct
            {
                ULONG Processor :       PROCESSOR_BIT_WIDTH;
                ULONG FirstIndex :      FIRST_INDEX_BIT_WIDTH;
                ULONG Reserved :        SECOND_INDEX_BIT_WIDTH;
            };
        };

        union
        {
            ULONG Cyclic;

            struct
            {
                ULONG OpaqueIdCyclic :  OPAQUE_ID_CYCLIC_BIT_WIDTH;
                ULONG OpaqueIdType :    OPAQUE_ID_TYPE_BIT_WIDTH;
            };
        };
    };

} UL_OPAQUE_ID_TABLE_ENTRY, *PUL_OPAQUE_ID_TABLE_ENTRY;


//
// We keep a per-processor first-level ID tables. A single table is a
// major scalability bottleneck on SMP machines. The size of the first-level
// table is controlled by a registry setting.
//

#if DBG
#define OPAQUE_ID_INSTRUMENTATION
#endif

typedef struct _UL_OPAQUE_ID_TABLE
{
    //
    // A list of free IDs available on this table.
    //

    SLIST_HEADER FreeOpaqueIdSListHead;

    //
    // An arrary of second-level ID table entries.
    //

    PUL_OPAQUE_ID_TABLE_ENTRY *FirstLevelTable;

    //
    // The corresponding CPU this table represents.
    //

    UCHAR Processor;

    //
    // The lock really only protects FirstLevelTableInUse.
    //

    UL_SPIN_LOCK Lock;

    //
    // The current number of first-level tables allocated.
    //

    ULONG FirstLevelTableInUse;

    //
    // The maximum size we can grow for the first-level tables.
    //

    ULONG FirstLevelTableSize;

#ifdef OPAQUE_ID_INSTRUMENTATION
    LONGLONG NumberOfAllocations;
    LONGLONG NumberOfFrees;
    LONGLONG NumberOfTotalGets;
    LONGLONG NumberOfSuccessfulGets;
#endif
} UL_OPAQUE_ID_TABLE, *PUL_OPAQUE_ID_TABLE;


//
// Necessary to ensure our array of UL_OPAQUE_ID_TABLE structures is
// cache aligned.
//

typedef union _UL_ALIGNED_OPAQUE_ID_TABLE
{
    UL_OPAQUE_ID_TABLE OpaqueIdTable;

    UCHAR CacheAlignment[(sizeof(UL_OPAQUE_ID_TABLE) + UL_CACHE_LINE - 1) & ~(UL_CACHE_LINE - 1)];

} UL_ALIGNED_OPAQUE_ID_TABLE, *PUL_ALIGINED_OPAQUE_ID_TABLE;


//
// An inline function that maps a specified HTTP_OPAQUE_ID to the
// corresponding ID table entry.
//

extern UL_ALIGNED_OPAQUE_ID_TABLE g_UlOpaqueIdTable[];

__inline
BOOLEAN
FASTCALL
UlpExtractIndexFromOpaqueId(
    IN HTTP_OPAQUE_ID OpaqueId,
    OUT PULONG pProcessor,
    OUT PULONG pFirstIndex,
    OUT PULONG pSecondIndex
    )
{
    UL_OPAQUE_ID_INTERNAL InternalId;
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;

    InternalId.OpaqueId = OpaqueId;

    //
    // Verify the processor portion of the index.
    //

    *pProcessor = InternalId.Processor;

    if (*pProcessor >= g_UlNumberOfProcessors)
    {
        return FALSE;
    }

    //
    // Verify the first-level index.
    //

    pOpaqueIdTable = &g_UlOpaqueIdTable[*pProcessor].OpaqueIdTable;
    *pFirstIndex = InternalId.FirstIndex;

    if (*pFirstIndex >= pOpaqueIdTable->FirstLevelTableInUse)
    {
        return FALSE;
    }

    //
    // Second-level index is always valid since we only allocated 8-bits.
    //

    ASSERT( InternalId.SecondIndex < SECOND_LEVEL_TABLE_SIZE );

    *pSecondIndex = InternalId.SecondIndex;

    return TRUE;

}

__inline
PUL_OPAQUE_ID_TABLE_ENTRY
FASTCALL
UlpMapOpaqueIdToTableEntry(
    IN HTTP_OPAQUE_ID OpaqueId
    )
{
    PUL_OPAQUE_ID_TABLE pOpaqueIdTable;
    ULONG Processor;
    ULONG FirstIndex;
    ULONG SecondIndex;

    if (UlpExtractIndexFromOpaqueId(
            OpaqueId,
            &Processor,
            &FirstIndex,
            &SecondIndex
            ))
    {
        pOpaqueIdTable = &g_UlOpaqueIdTable[Processor].OpaqueIdTable;
        return pOpaqueIdTable->FirstLevelTable[FirstIndex] + SecondIndex;
    }
    else
    {
        return NULL;
    }

}


//
// Private prototypes.
//

NTSTATUS
UlpExpandOpaqueIdTable(
    IN PUL_OPAQUE_ID_TABLE pOpaqueIdTable,
    IN LONG CapturedFirstTableInUse
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _OPAQUEIDP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ownerref.cxx ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    ownerref.cxx

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


// Globals
LIST_ENTRY      g_OwnerRefTraceLogGlobalListHead;
UL_SPIN_LOCK    g_OwnerRefTraceLogGlobalSpinLock;
LONG            g_OwnerRefTraceLogGlobalCount;


VOID
UlInitializeOwnerRefTraceLog(
    VOID)
{
    InitializeListHead(&g_OwnerRefTraceLogGlobalListHead);
    UlInitializeSpinLock( &g_OwnerRefTraceLogGlobalSpinLock,
                          "OwnerRefTraceLogGlobal" );
    g_OwnerRefTraceLogGlobalCount = 0;
} // UlInitializeOwnerRefTraceLog


VOID
UlTerminateOwnerRefTraceLog(
    VOID)
{
    ASSERT( IsListEmpty(&g_OwnerRefTraceLogGlobalListHead) );
    ASSERT( 0 == g_OwnerRefTraceLogGlobalCount );
} // UlTerminateOwnerRefTraceLog



#if ENABLE_OWNER_REF_TRACE

POWNER_REF_TRACELOG
CreateOwnerRefTraceLog(
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader
    )
{
    POWNER_REF_TRACELOG pOwnerRefTraceLog = NULL;

    PTRACE_LOG pTraceLog
        = CreateTraceLog(
                OWNER_REF_TRACELOG_SIGNATURE,
                LogSize,
                sizeof(OWNER_REF_TRACELOG)
                    - FIELD_OFFSET(OWNER_REF_TRACELOG, OwnerHeader)
                    + ExtraBytesInHeader,
                sizeof(OWNER_REF_TRACE_LOG_ENTRY)
                );

    if (pTraceLog != NULL)
    {
        pOwnerRefTraceLog = (POWNER_REF_TRACELOG) pTraceLog;

        ASSERT(pOwnerRefTraceLog->TraceLog.TypeSignature
                    == OWNER_REF_TRACELOG_SIGNATURE);

        InitializeListHead(&pOwnerRefTraceLog->OwnerHeader.ListHead);
        UlInitializeSpinLock( &pOwnerRefTraceLog->OwnerHeader.SpinLock,
                              "OwnerRefTraceLog" );
        pOwnerRefTraceLog->OwnerHeader.MonotonicId = 0;
        pOwnerRefTraceLog->OwnerHeader.OwnersCount = 0;

        // insert into global list

        ExInterlockedInsertTailList(
            &g_OwnerRefTraceLogGlobalListHead,
            &pOwnerRefTraceLog->OwnerHeader.GlobalListEntry,
            KSPIN_LOCK_FROM_UL_SPIN_LOCK(&g_OwnerRefTraceLogGlobalSpinLock)
            );

        InterlockedIncrement(&g_OwnerRefTraceLogGlobalCount);
    }

    return pOwnerRefTraceLog;
}   // CreateOwnerRefTraceLog


PREF_OWNER
NewRefOwner(
    POWNER_REF_TRACELOG pOwnerRefTraceLog,
    PVOID               pOwner,
    IN PPREF_OWNER      ppRefOwner,
    IN ULONG            OwnerSignature
    )
{
    PREF_OWNER pRefOwner;

    ASSERT( UlDbgSpinLockOwned( &pOwnerRefTraceLog->OwnerHeader.SpinLock ) );

    pRefOwner = UL_ALLOCATE_STRUCT(
                    NonPagedPool,
                    REF_OWNER,
                    UL_OWNER_REF_POOL_TAG
                    );

    if (pRefOwner != NULL)
    {
        int i;

        pRefOwner->Signature = OWNER_REF_SIGNATURE;
        pRefOwner->OwnerSignature = OwnerSignature;

        InsertTailList(
            &pOwnerRefTraceLog->OwnerHeader.ListHead,
            &pRefOwner->ListEntry
            );

        ++pOwnerRefTraceLog->OwnerHeader.OwnersCount;

        pRefOwner->pOwner = pOwner;
        pRefOwner->pOwnerRefTraceLog = pOwnerRefTraceLog;
        pRefOwner->RelativeRefCount = 0;
        pRefOwner->OwnedNextEntry = -1;

        for (i = 0;  i < OWNED_REF_NUM_ENTRIES;  ++i)
        {
            pRefOwner->RecentEntries[i].RefIndex    = -1;
            pRefOwner->RecentEntries[i].MonotonicId = -1;
            pRefOwner->RecentEntries[i].Action      = -1;
        }

        *ppRefOwner = pRefOwner;
    }

    return pRefOwner;
} // NewRefOwner


VOID
InsertRefOwner(
    IN POWNER_REF_TRACELOG  pOwnerRefTraceLog,
    IN PVOID                pOwner,
    IN PPREF_OWNER          ppRefOwner,
    IN ULONG                OwnerSignature,
    IN LONGLONG             RefIndex,
    IN LONG                 MonotonicId,
    IN LONG                 IncrementValue,
    IN USHORT               Action
    )
{
    PREF_OWNER  pRefOwner = NULL;
    KIRQL       OldIrql;

    ASSERT(RefIndex >= 0);

    UlAcquireSpinLock(&pOwnerRefTraceLog->OwnerHeader.SpinLock, &OldIrql);

    pRefOwner = *ppRefOwner;

    if (pRefOwner == NULL)
    {
        pRefOwner = NewRefOwner(
                         pOwnerRefTraceLog,
                         pOwner,
                         ppRefOwner,
                         OwnerSignature
                         );
    }

    if (pRefOwner != NULL)
    {
        ULONG Index;

        ASSERT(pRefOwner->Signature == OWNER_REF_SIGNATURE);
        ASSERT(pRefOwner->pOwner == pOwner);
        ASSERT(pRefOwner->OwnerSignature == OwnerSignature);
        ASSERT(pRefOwner->pOwnerRefTraceLog == pOwnerRefTraceLog);

        Index = ((ULONG) ++pRefOwner->OwnedNextEntry) % OWNED_REF_NUM_ENTRIES;

        pRefOwner->RecentEntries[Index].RefIndex    = RefIndex;
        pRefOwner->RecentEntries[Index].MonotonicId = MonotonicId;
        pRefOwner->RecentEntries[Index].Action      = Action;

        if (IncrementValue > 0)
            ++pRefOwner->RelativeRefCount;
        else if (IncrementValue < 0)
            --pRefOwner->RelativeRefCount;
        // else do nothing if IncrementValue == 0.

        ASSERT(pRefOwner->RelativeRefCount >= 0);
    }

    UlReleaseSpinLock(&pOwnerRefTraceLog->OwnerHeader.SpinLock, OldIrql);

} // InsertRefOwner


LONGLONG
WriteOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG  pOwnerRefTraceLog,
    IN PVOID                pOwner,
    IN PPREF_OWNER          ppRefOwner,
    IN ULONG                OwnerSignature,
    IN USHORT               Action,
    IN LONG                 NewRefCount,
    IN LONG                 MonotonicId,
    IN LONG                 IncrementValue,
    IN PVOID                pFileName,
    IN USHORT               LineNumber
    )
{
    OWNER_REF_TRACE_LOG_ENTRY entry;
    LONGLONG RefIndex;

    ASSERT(NULL != ppRefOwner);
    ASSERT(Action < (1 << REF_TRACE_ACTION_BITS));

    if (NULL == pOwnerRefTraceLog)
        return -1;

    entry.NewRefCount = NewRefCount;
    entry.pOwner = pOwner;
    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;
    entry.Action = Action;

    RefIndex = WriteTraceLog( &pOwnerRefTraceLog->TraceLog, &entry );

    InsertRefOwner(
        pOwnerRefTraceLog,
        pOwner,
        ppRefOwner,
        OwnerSignature,
        RefIndex,
        MonotonicId,
        IncrementValue,
        Action
        );

    return RefIndex;
} // WriteOwnerRefTraceLog


VOID
DestroyOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG pOwnerRefTraceLog
    )
{
    if (pOwnerRefTraceLog != NULL)
    {
        KIRQL       OldIrql;
        PLIST_ENTRY pEntry;
        int         i = 0;

        UlAcquireSpinLock(&pOwnerRefTraceLog->OwnerHeader.SpinLock, &OldIrql);

        for (pEntry =   pOwnerRefTraceLog->OwnerHeader.ListHead.Flink;
             pEntry != &pOwnerRefTraceLog->OwnerHeader.ListHead;
             ++i)
        {
            PREF_OWNER pRefOwner =
                CONTAINING_RECORD(pEntry, REF_OWNER, ListEntry);

            pEntry = pEntry->Flink; // save before deletion

            ASSERT(pRefOwner->Signature == OWNER_REF_SIGNATURE);
            ASSERT(pRefOwner->RelativeRefCount == 0);

            UL_FREE_POOL_WITH_SIG(pRefOwner, UL_OWNER_REF_POOL_TAG);
        }

        UlReleaseSpinLock(&pOwnerRefTraceLog->OwnerHeader.SpinLock, OldIrql);

        ASSERT(i == pOwnerRefTraceLog->OwnerHeader.OwnersCount);

        // Remove log from global list

        UlAcquireSpinLock(&g_OwnerRefTraceLogGlobalSpinLock, &OldIrql);
        RemoveEntryList(&pOwnerRefTraceLog->OwnerHeader.GlobalListEntry);
        UlReleaseSpinLock(&g_OwnerRefTraceLogGlobalSpinLock, OldIrql);
        InterlockedDecrement(&g_OwnerRefTraceLogGlobalCount);

        DestroyTraceLog( (PTRACE_LOG) pOwnerRefTraceLog );
    }
}   // DestroyOwnerRefTraceLog



VOID
ResetOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG pOwnerRefTraceLog
    )
{
    // CODEWORK: reset OwnerHeader?
    if (pOwnerRefTraceLog != NULL)
    {
        ResetTraceLog(&pOwnerRefTraceLog->TraceLog);
    }
} // ResetOwnerRefTraceLog

#endif  // ENABLE_OWNER_REF_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ownerref.h ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    ownerref.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems - by owner. It's an enhanced
    version of the reftracing in reftrace.h.

    Reference counting implies ownership. We associate a REF_OWNER structure
    with every object that holds a reference on the refcounted object and
    keep track of its relative refcount. Currently, this is used to keep
    track of which UL_CONNECTIONs have an active reference to their
    UL_ENDPOINT. Because UL_CONNECTIONs are recycled, we use the MonotonicId
    to keep track of each generation.

Author:

    George V. Reilly  Jan-2001

Revision History:

--*/


#ifndef _OWNERREF_H_
#define _OWNERREF_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


// Owned Reference stuff

typedef struct _OWNER_REF_TRACELOG *POWNER_REF_TRACELOG; // fwd decl

typedef struct _OWNED_REFERENCE
{
    LONGLONG    RefIndex;   // index of corresponding OWNER_REF_TRACE_LOG_ENTRY
                            // in the master OwnerRefTraceLog
    LONG        MonotonicId;// "generation" of this owner
    USHORT      Action;     // what happened
} OWNED_REFERENCE;


#define OWNED_REF_NUM_ENTRIES 16
#define OWNER_REF_SIGNATURE ((ULONG) 'wOfR')

// Each owner has one of these associated with it. Note: it is not
// stored inline within the owner, as it must survive past the lifetime
// of the owner
typedef struct _REF_OWNER
{
    ULONG               Signature;      // OWNER_REF_SIGNATURE
    ULONG               OwnerSignature; // e.g., UL_CONNECTION_SIGNATURE
    PVOID               pOwner;         // owning object
    POWNER_REF_TRACELOG pOwnerRefTraceLog; // back pointer
    LIST_ENTRY          ListEntry;      // within list of REF_OWNERs
    LONG                RelativeRefCount;// held by this owner
    LONG                OwnedNextEntry; // index within RecentEntries
    OWNED_REFERENCE     RecentEntries[OWNED_REF_NUM_ENTRIES]; // circular buff
} REF_OWNER, *PREF_OWNER, **PPREF_OWNER;


// Additional data stored at the end of the TRACELOG header.
typedef struct _OWNER_REF_TRACELOG_HEADER
{
    UL_SPIN_LOCK        SpinLock;
    LONG                OwnersCount;    // length of list of REF_OWNERs
    LONG                MonotonicId;
    LIST_ENTRY          ListHead;       // list of REF_OWNERs
    LIST_ENTRY          GlobalListEntry;// entry within global list of ORTLs
} OWNER_REF_TRACELOG_HEADER, *POWNER_REF_TRACELOG_HEADER;


#define OWNER_REF_TRACELOG_SIGNATURE ((ULONG) 'gLRO')

typedef struct _OWNER_REF_TRACELOG
{
    TRACE_LOG                   TraceLog;
    OWNER_REF_TRACELOG_HEADER   OwnerHeader;
} OWNER_REF_TRACELOG, *POWNER_REF_TRACELOG;


typedef struct _OWNER_REF_TRACE_LOG_ENTRY
{
    PVOID       pOwner;         // an object that has an assoc'd REF_OWNER
    PVOID       pFileName;      // source file
    LONG        NewRefCount;    // new absolute refcount. -1 => non ref action
    USHORT      LineNumber;     // line within source file
    USHORT      Action : REF_TRACE_ACTION_BITS;
    USHORT      Pad    : REF_TRACE_PROCESSOR_BITS;
} OWNER_REF_TRACE_LOG_ENTRY, *POWNER_REF_TRACE_LOG_ENTRY;


//
// Manipulators.
//

VOID
UlInitializeOwnerRefTraceLog(
    VOID);

VOID
UlTerminateOwnerRefTraceLog(
    VOID);

POWNER_REF_TRACELOG
CreateOwnerRefTraceLog(
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader
    );

LONGLONG
WriteOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG  pOwnerRefTraceLog,
    IN PVOID                pOwner,
    IN PPREF_OWNER          ppRefOwner,
    IN ULONG                OwnerSignature,
    IN USHORT               Action,
    IN LONG                 NewRefCount,
    IN LONG                 MonotonicId,
    IN LONG                 IncrementValue,
    IN PVOID                pFileName,
    IN USHORT               LineNumber
    );

VOID
DestroyOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG pOwnerRefTraceLog
    );

VOID
ResetOwnerRefTraceLog(
    IN POWNER_REF_TRACELOG pOwnerRefTraceLog
    );

#if ENABLE_OWNER_REF_TRACE

// Owner RefTrace stuff

#define CREATE_OWNER_REF_TRACE_LOG( ptr, size, extra )                      \
    (ptr) = CreateOwnerRefTraceLog( (size), (extra) )

#define DESTROY_OWNER_REF_TRACE_LOG( ptr )                                  \
    do                                                                      \
    {                                                                       \
        DestroyOwnerRefTraceLog( ptr );                                     \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define WRITE_OWNER_REF_TRACE_LOG(                                          \
    plog, powner, pprefowner, sig, act, newrefct, monoid, incrval, pfile, line )\
    WriteOwnerRefTraceLog(                                                  \
        (plog),                                                             \
        (powner),                                                           \
        (pprefowner),                                                       \
        (sig),                                                              \
        (act),                                                              \
        (newrefct),                                                         \
        (monoid),                                                           \
        (incrval),                                                          \
        (pfile),                                                            \
        (line)                                                              \
        )

#define SET_OWNER_REF_TRACE_LOG_MONOTONIC_ID( var, plog )                   \
    (var) = (((plog) == NULL)                                               \
             ? -1 : InterlockedIncrement(&(plog)->OwnerHeader.MonotonicId))

#define OWNER_REFERENCE_DEBUG_FORMAL_PARAMS     \
    , PVOID         pOwner                      \
    , PPREF_OWNER   ppRefOwner                  \
    , ULONG         OwnerSignature              \
    , USHORT        Action                      \
    , LONG          MonotonicId                 \
    , PSTR          pFileName                   \
    , USHORT        LineNumber

#define OWNER_REFERENCE_DEBUG_ACTUAL_PARAMS     \
        , act, powner, pprefowner, monoid       \
        , (PSTR)__FILE__,(USHORT)__LINE__

#else // !ENABLE_OWNER_REF_TRACE

#define CREATE_OWNER_REF_TRACE_LOG( ptr, size, extra )                      \
    (ptr) = NULL

#define DESTROY_OWNER_REF_TRACE_LOG( ptr )

#define WRITE_OWNER_REF_TRACE_LOG(                                          \
    plog, powner, pprefowner, sig, act, newrefct, monoid, incrval, pfile, line )

#define SET_OWNER_REF_TRACE_LOG_MONOTONIC_ID( var, plog )

#define OWNER_REFERENCE_DEBUG_FORMAL_PARAMS
#define OWNER_REFERENCE_DEBUG_ACTUAL_PARAMS

#endif // !ENABLE_OWNER_REF_TRACE


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _OWNERREF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\parsep.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    parsep.h

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       04-May-1998

Revision History:

--*/

#ifndef _PARSEP_H_
#define _PARSEP_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// External variables.
//

extern PUSHORT NlsLeadByteInfo;

//
// Constants
//

#define MIN_VERSION_SIZE    (sizeof("HTTP/1.1") - 1)

#define MAX_VERB_LENGTH     (sizeof("PROPPATCH"))

#define HTTP_11_VERSION 0x312e312f50545448
#define HTTP_10_VERSION 0x302e312f50545448

#define UPCASE_MASK ((ULONGLONG)0xdfdfdfdfdfdfdfdf)

#define MAX_HEADER_LONG_COUNT           (3)
#define MAX_HEADER_LENGTH               (MAX_HEADER_LONG_COUNT * sizeof(ULONGLONG))

#define NUMBER_HEADER_INDICIES          (26)

#define NUMBER_HEADER_HINT_INDICIES     (8)

//
// Default Server: header if none provided by the application.
//

#define DEFAULT_SERVER_HDR          "Microsoft-IIS/6.0"
#define DEFAULT_SERVER_HDR_LENGTH   (sizeof(DEFAULT_SERVER_HDR) - sizeof(CHAR))

//
// One second in 100ns system time units. Used for generating
// Date: headers.
//

#define ONE_SECOND                  10000000

//
// Size of Connection: header values
//

#define CONN_CLOSE_HDR              "close"
#define CONN_CLOSE_HDR_LENGTH       (sizeof(CONN_CLOSE_HDR) - sizeof(CHAR))

#define CONN_KEEPALIVE_HDR          "keep-alive"
#define CONN_KEEPALIVE_HDR_LENGTH   (sizeof(CONN_KEEPALIVE_HDR) - sizeof(CHAR))

//
// These are backwards because of little endian.
//

#define HTTP_PREFIX         'PTTH'
#define HTTP_PREFIX_SIZE    4
#define HTTP_PREFIX_MASK    0xdfdfdfdf

#define HTTP_PREFIX1        '\0//:'
#define HTTP_PREFIX1_SIZE   3
#define HTTP_PREFIX1_MASK   0x00ffffff

#define HTTP_PREFIX2        '//:S'
#define HTTP_PREFIX2_SIZE   4
#define HTTP_PREFIX2_MASK   0xffffffdf


typedef NTSTATUS (*PFN_SERVER_HEADER_HANDLER)(
                        PUL_INTERNAL_REQUEST    pRequest,
                        PUCHAR                  pHttpRequest,
                        ULONG                   HttpRequestLength,
                        HTTP_HEADER_ID          HeaderID,
                        ULONG *                 pBytesTaken
                        );

typedef NTSTATUS (*PFN_CLIENT_HEADER_HANDLER)(
                    PHTTP_KNOWN_HEADER  pKnownHeaders,
                    PUCHAR              *pOutBufferHead,
                    PUCHAR              *pOutBufferTail,
                    PULONG              BytesAvailable,
                    PUCHAR              pHeader,
                    ULONG               HeaderLength,
                    HTTP_HEADER_ID      HeaderID,
                    ULONG  *            pBytesTaken
                    );


//
// Structure of the fast verb lookup table. The table consists of a series of
// entries where each entry contains an HTTP verb represented as a ulonglong,
// a mask to use for comparing that verb, the length of the verb and the
// translated id.
//

typedef struct _FAST_VERB_ENTRY
{
    union
    {
        UCHAR       Char[sizeof(ULONGLONG)+1];
        ULONGLONG   LongLong;
    }           RawVerb;
    ULONGLONG   RawVerbMask;
    ULONG       RawVerbLength;
    HTTP_VERB   TranslatedVerb;

} FAST_VERB_ENTRY, *PFAST_VERB_ENTRY;


//
// Stucture of the all verb lookup table. This table holds all verbs that
// we understand, including those that are too long to fit in the fast
// verb table.
//

typedef struct _LONG_VERB_ENTRY
{
    ULONG       RawVerbLength;
    UCHAR       RawVerb[MAX_VERB_LENGTH];
    HTTP_VERB   TranslatedVerb;

} LONG_VERB_ENTRY, *PLONG_VERB_ENTRY;


//
// Structure for a header map entry. Each header map entry contains a
// verb and a series of masks to use in checking that verb.
//

typedef struct _HEADER_MAP_ENTRY
{
    ULONG                      HeaderLength;
    ULONG                      ArrayCount;
    ULONG                      MinBytesNeeded;
    union
    {
        UCHAR                  HeaderChar[MAX_HEADER_LENGTH];
        ULONGLONG              HeaderLong[MAX_HEADER_LONG_COUNT];
    }                          Header;
    ULONGLONG                  HeaderMask[MAX_HEADER_LONG_COUNT];
    UCHAR                      MixedCaseHeader[MAX_HEADER_LENGTH];

    HTTP_HEADER_ID             HeaderID;
    BOOLEAN                    AutoGenerate;
    PFN_SERVER_HEADER_HANDLER  pServerHandler;
    PFN_CLIENT_HEADER_HANDLER  pClientHandler;
    LONG                       HintIndex;

}  HEADER_MAP_ENTRY, *PHEADER_MAP_ENTRY;


//
// Structure for a header index table entry.
//

typedef struct _HEADER_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    ULONG               Count;

} HEADER_INDEX_ENTRY, *PHEADER_INDEX_ENTRY;

//
// Structure for a header hint index table entry.
//

typedef struct _HEADER_HINT_INDEX_ENTRY
{
    PHEADER_MAP_ENTRY   pHeaderMap;
    UCHAR               c;

} HEADER_HINT_INDEX_ENTRY, *PHEADER_HINT_INDEX_ENTRY, **PPHEADER_HINT_INDEX_ENTRY;

//
// A (complex) macro to create a mask for a header map entry,
// given the header length and the mask offset (in bytes). This
// mask will need to be touched up for non-alphabetic characters.
//

#define CREATE_HEADER_MASK(hlength, maskoffset) \
    ((hlength) > (maskoffset) ? UPCASE_MASK : \
        (((maskoffset) - (hlength)) >= 8 ? 0 : \
        (UPCASE_MASK >> ( ((maskoffset) - (hlength)) * (ULONGLONG)8))))


//
// Macro for creating header map entries. The mask entries are created
// by the init code.
//

#define CREATE_HEADER_MAP_ENTRY(header, ID, auto, serverhandler, clienthandler, HintIndex)\
{                                                        \
                                                         \
    sizeof(#header) - 1,                                 \
    ((sizeof(#header) - 1) / 8) +                        \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1),      \
    (((sizeof(#header) - 1) / 8) +                       \
        (((sizeof(#header) - 1) % 8) == 0 ? 0 : 1)) * 8, \
    { #header },                                         \
    { 0, 0, 0},                                          \
    { #header },                                         \
    ID,                                                  \
    auto,                                                \
    serverhandler,                                       \
    clienthandler,                                       \
    HintIndex                                            \
    }

//
// Macro for defining fast verb table entries. Note that we don't subtrace 1
// from the various sizeof occurences because we'd just have to add it back
// in to account for the seperating space.
//

#define CREATE_FAST_VERB_ENTRY(verb)    { {#verb " "}, \
                                                (0xffffffffffffffff >> \
                                                ((8 - (sizeof(#verb))) * 8)), \
                                                (sizeof(#verb)), HttpVerb##verb }


//
// Macro for defining all verb table entries.
//

#define CREATE_LONG_VERB_ENTRY(verb)    { sizeof(#verb) - 1, \
                                             #verb,\
                                             HttpVerb##verb }

#define IS_UTF8_TRAILBYTE(ch)      (((ch) & 0xc0) == 0x80)


NTSTATUS
CheckForAbsoluteUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pURL,
    IN  ULONG                   URLLength,
    IN  PUCHAR *                pHostPtr,
    IN  ULONG  *                BytesTaken
    );

NTSTATUS
LookupVerb(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
UlParseHeaderWithHint(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderHintMap,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
UlParseHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    );

NTSTATUS
UlLookupHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pCurrentHeaderMap,
    IN  ULONG                   HeaderMapCount,
    OUT ULONG  *                pBytesTaken
    );

typedef enum _URL_PART
{
    Scheme,
    HostName,
    AbsPath,
    QueryString

} URL_PART;

typedef enum _URL_TYPE
{
    UrlTypeUtf8,
    UrlTypeAnsi,
    UrlTypeDbcs
} URL_TYPE;


NTSTATUS
UlpCleanAndCopyUrl(
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    );

NTSTATUS
UlpCleanAndCopyUrlByType(
    IN      URL_TYPE    UrlType,
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    );


NTSTATUS
Unescape(
    IN  PUCHAR pChar,
    OUT PUCHAR pOutChar
    );

//
// PopChar is used only if the string is not UTF-8, or UrlPart != QueryString,
// or the current character is '%' or its high bit is set.  In all other cases,
// the FastPopChars table is used for fast conversion.
//

__inline
NTSTATUS
FASTCALL
PopChar(
    IN URL_TYPE UrlType,
    IN URL_PART UrlPart,
    IN PUCHAR pChar,
    OUT WCHAR * pUnicodeChar,
    OUT PULONG pCharToSkip
    )
{
    NTSTATUS Status;
    WCHAR   UnicodeChar;
    UCHAR   Char;
    UCHAR   Trail1;
    UCHAR   Trail2;
    ULONG   CharToSkip;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // validate it as a valid url character
    //

    if (UrlPart != QueryString)
    {
        if (IS_URL_TOKEN(pChar[0]) == FALSE)
        {
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            UlTrace(PARSER, (
                "ul!PopChar(pChar = %p) first char isn't URL token\n",
                pChar
                ));

            goto end;
        }
    }
    else
    {
        //
        // Allow anything but linefeed in the query string.
        //

        if (pChar[0] == LF)
        {
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            UlTrace(PARSER, (
                "ul!PopChar(pChar = %p) linefeed in query string\n",
                pChar
                ));

            goto end;
        }

        UnicodeChar = (USHORT) pChar[0];
        CharToSkip = 1;

        // skip all the decoding stuff
        goto slash;
    }

    //
    // need to unescape ?
    //
    // can't decode the query string.  that would be lossy decodeing
    // as '=' and '&' characters might be encoded, but have meaning
    // to the usermode parser.
    //

    if (pChar[0] == '%')
    {
        Status = Unescape(pChar, &Char);
        if (NT_SUCCESS(Status) == FALSE)
            goto end;
        CharToSkip = 3;
    }
    else
    {
        Char = pChar[0];
        CharToSkip = 1;
    }

    if (UrlType == UrlTypeUtf8)
    {
        //
        // convert to unicode, checking for utf8 .
        //
        // 3 byte runs are the largest we can have.  16 bits in UCS-2 =
        // 3 bytes of (4+4,2+6,2+6) where it's code + char.
        // for a total of 6+6+4 char bits = 16 bits.
        //

        //
        // NOTE: we'll only bother to decode utf if it was escaped
        // thus the (CharToSkip == 3)
        //
        if ((CharToSkip == 3) && ((Char & 0xf0) == 0xe0))
        {
            // 3 byte run
            //

            // Unescape the next 2 trail bytes
            //

            Status = Unescape(pChar+CharToSkip, &Trail1);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            Status = Unescape(pChar+CharToSkip, &Trail2);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            if (IS_UTF8_TRAILBYTE(Trail1) == FALSE ||
                IS_UTF8_TRAILBYTE(Trail2) == FALSE)
            {
                // bad utf!
                //
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

                UlTrace(PARSER, (
                            "ul!PopChar( 0x%x 0x%x ) bad trail bytes\n",
                            Trail1,
                            Trail2
                            ));

                goto end;
            }

            // handle three byte case
            // 1110xxxx 10xxxxxx 10xxxxxx

            UnicodeChar = (USHORT) (((Char & 0x0f) << 12) |
                                    ((Trail1 & 0x3f) << 6) |
                                    (Trail2 & 0x3f));

        }
        else if ((CharToSkip == 3) && ((Char & 0xe0) == 0xc0))
        {
            // 2 byte run
            //

            // Unescape the next 1 trail byte
            //

            Status = Unescape(pChar+CharToSkip, &Trail1);
            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            CharToSkip += 3; // %xx

            if (IS_UTF8_TRAILBYTE(Trail1) == FALSE)
            {
                // bad utf!
                //
                Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

                UlTrace(PARSER, (
                            "ul!PopChar( 0x%x ) bad trail byte\n",
                            Trail1
                            ));

                goto end;
            }

            // handle two byte case
            // 110xxxxx 10xxxxxx

            UnicodeChar = (USHORT) (((Char & 0x1f) << 6) |
                                    (Trail1 & 0x3f));

        }

        // now this can either be unescaped high-bit (bad)
        // or escaped high-bit.  (also bad)
        //
        // thus not checking CharToSkip
        //

        else if ((Char & 0x80) == 0x80)
        {
            // high bit set !  bad utf!
            //
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;

            UlTrace(PARSER, (
                        "ul!PopChar( 0x%x ) ERROR: high bit set! bad utf!\n",
                        Char
                        ));

            goto end;

        }
        //
        // Normal character (again either escaped or unescaped)
        //
        else
        {
            //
            // Simple conversion to unicode, it's 7-bit ascii.
            //

            UnicodeChar = (USHORT)Char;
        }

    }
    else // UrlType != UrlTypeUtf8
    {
        UCHAR AnsiChar[2];
        ULONG AnsiCharSize;

        //
        // Convert ANSI character to Unicode.
        // If the UrlType is UrlTypeDbcs, then we may have
        // a DBCS lead/trail pair.
        //

        if (UrlType == UrlTypeDbcs && NlsLeadByteInfo[Char])
        {
            //
            // This is a double-byte character.
            //

            AnsiCharSize = 2;
            AnsiChar[0] = Char;

            Status = Unescape(pChar+CharToSkip, &AnsiChar[1]);
            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            CharToSkip += 3; // %xx

        }
        else
        {
            //
            // This is a single-byte character.
            //

            AnsiCharSize = 1;
            AnsiChar[0] = Char;

        }

        Status = RtlMultiByteToUnicodeN(
                        &UnicodeChar,
                        sizeof(WCHAR),
                        NULL,
                        (PCHAR) &AnsiChar[0],
                        AnsiCharSize
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }
    }


slash:
    //
    // turn backslashes into forward slashes
    //

    if (UrlPart != QueryString && UnicodeChar == L'\\')
    {
        UnicodeChar = L'/';
    }
    else if (UnicodeChar == UNICODE_NULL)
    {
        //
        // we pop'd a NULL.  bad!
        //
        Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
        goto end;
    }

    *pCharToSkip  = CharToSkip;
    *pUnicodeChar = UnicodeChar;

    Status = STATUS_SUCCESS;

end:
    return Status;

}   // PopChar


// Call this only after the entire request has been parsed
//
NTSTATUS
UlpCookUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest
    );


ULONG
UlpParseHttpVersion(
    PUCHAR pString,
    ULONG  StringLength,
    PHTTP_VERSION pVersion
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _PARSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\pipelinep.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    pipelinep.h

Abstract:

    This module contains private declarations for the pipeline package.
    These are kept in a separate file to make them accessible by the
    ULKD kernel debuggger extension.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PIPELINEP_H_
#define _PIPELINEP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Per-thread data we keep for the pipeline worker threads.
//

typedef struct _UL_PIPELINE_THREAD_DATA
{
    HANDLE ThreadHandle;
    PVOID pThreadObject;

#if DBG
    ULONG QueuesHandled;
    ULONG WorkItemsHandled;
#endif

} UL_PIPELINE_THREAD_DATA, *PUL_PIPELINE_THREAD_DATA;


//
// The UL_PIPELINE_RARE structure contains rarely used data. The data
// in this structure is typically accessed only during pipeline creation
// and termination. This structure located immediately after the
// UL_PIPELINE data.
//

typedef struct _UL_PIPELINE_RARE
{
    //
    // The UL_PIPELINE structure is carefully aligned on a cache-line
    // boundary. To do this, we allocate a block of memory slightly
    // larger than necessary and round up to the next cache-line.
    // Therefore, the block of memory allocated is not necessarily the
    // one actually used. The following field points to the actual
    // block of allocated memory.
    //

    PVOID pAllocationBlock;

    //
    // Per-thread data for the worker threads goes here. The number of
    // items in this array is:
    //
    //     ( ThreadsPerCpu * UlNumberOfProcessors )
    //
    // UL_PIPELINE_THREAD_DATA ThreadData[ANYSIZE_ARRAY];
    //

} UL_PIPELINE_RARE, *PUL_PIPELINE_RARE;


//
// Macro for calculating the memory size required for a pipeline given
// the number of queues and the number of worker threads.
//

#define PIPELINE_LENGTH( queues, threads )                                  \
    ( sizeof(UL_PIPELINE)                                                  \
        - sizeof(UL_PIPELINE_QUEUE)                                        \
        + sizeof(UL_PIPELINE_RARE)                                         \
        + ( (ULONG)(queues) * sizeof(UL_PIPELINE_QUEUE) )                  \
        + ( (ULONG)(threads) * sizeof(UL_PIPELINE_THREAD_DATA) ) )


//
// Macros for mapping a UL_PIPELINE pointer to the corresponding
// UL_PIPELINE_RARE and UL_PIPELINE_THREAD_DATA structures.
//

#define PIPELINE_TO_RARE_DATA( pipeline )                                   \
    ( (PUL_PIPELINE_RARE)( &(pipeline)->Queues[(pipeline)->QueueCount] ) )

#define PIPELINE_TO_THREAD_DATA( pipeline )                                 \
    (PUL_PIPELINE_THREAD_DATA)( PIPELINE_TO_RARE_DATA( pipeline ) + 1 )


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PIPELINEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\pipeline.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    pipeline.h

Abstract:

    This module contains public declarations for the pipeline package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PIPELINE_H_
#define _PIPELINE_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// A simple lock used to serialize access to a pipeline queue. Use
// UlInterlockedCompareExchange() to see if you can acquire it.
//

typedef LONG UL_PIPELINE_QUEUE_LOCK;

#define L_LOCKED    0
#define L_UNLOCKED  1


//
// An ordinal used to identify a specific queue within a pipeline.
//

typedef SHORT UL_PIPELINE_QUEUE_ORDINAL, *PUL_PIPELINE_QUEUE_ORDINAL;


//
// A queueable work item.
//

typedef struct _UL_PIPELINE_WORK_ITEM   // WorkItem
{
    //
    // Links onto the pipeline queue's work queue.
    //

    LIST_ENTRY WorkQueueEntry;

} UL_PIPELINE_WORK_ITEM, *PUL_PIPELINE_WORK_ITEM;


//
// Pointer to a queue handler. The handler is invoked for each queued
// work item.
//

typedef
VOID
(NTAPI * PFN_UL_PIPELINE_HANDLER)(
    IN PUL_PIPELINE_WORK_ITEM WorkItem
    );


//
// A pipeline queue. Note that two queues will fit into a single cache line.
//

typedef struct _UL_PIPELINE_QUEUE   // Queue
{
    //
    // The list of enqueued work items.
    //

    LIST_ENTRY WorkQueueHead;

    //
    // The lock protecting this queue.
    //

    UL_PIPELINE_QUEUE_LOCK QueueLock;

    //
    // Pointer to the handler for this queue.
    //

    PFN_UL_PIPELINE_HANDLER pHandler;

} UL_PIPELINE_QUEUE, *PUL_PIPELINE_QUEUE;


//
// A pipeline.
//

typedef struct _UL_PIPELINE     // Pipeline
{
    //
    // The spinlock protecting this pipeline.
    //

    UL_SPIN_LOCK PipelineLock;

    //
    // The number of threads currently servicing queue requests.
    //

    SHORT ThreadsRunning;

    //
    // The number of queues with non-empty work queue lists.
    //

    SHORT QueuesWithWork;

    //
    // The maximum number of threads allowed to run simultaneously
    // for this pipeline.
    //

    SHORT MaximumThreadsRunning;

    //
    // The number of queues in this pipeline.
    //

    SHORT QueueCount;

    //
    // Shutdown flag.
    //

    BOOLEAN ShutdownFlag;
    BOOLEAN Spares[3];

    //
    // An event object signalled whenever there's work to be done. We take
    // great pains to ensure this event is never signalled frivolously.
    //

    KEVENT WorkAvailableEvent;

    //
    // The actual queues go here.
    //

    UL_PIPELINE_QUEUE Queues[ANYSIZE_ARRAY];

    //
    // Additional opaque (pipeline package-specific) data may go here,
    // but don't count on it.
    //

} UL_PIPELINE, *PUL_PIPELINE;


//
// Public functions.
//

NTSTATUS
UlCreatePipeline(
    OUT PUL_PIPELINE * ppPipeline,
    IN SHORT QueueCount,
    IN SHORT ThreadsPerCpu
    );

VOID
UlInitializeQueuePipeline(
    IN PUL_PIPELINE pPipeline,
    IN UL_PIPELINE_QUEUE_ORDINAL QueueOrdinal,
    IN PFN_UL_PIPELINE_HANDLER pHandler
    );

NTSTATUS
UlDestroyPipeline(
    IN PUL_PIPELINE pPipeline
    );

VOID
UlQueueWorkPipeline(
    IN PUL_PIPELINE pPipeline,
    IN UL_PIPELINE_QUEUE_ORDINAL QueueOrdinal,
    IN PUL_PIPELINE_WORK_ITEM pWorkItem
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PIPELINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\pipeline.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    pipeline.cxx

Abstract:

    This module implements the pipeline package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include <precomp.h>


//
// Private types.
//

//
// The UL_PIPELINE_THREAD_CONTEXT structure is used as a parameter to the
// pipeline worker threads. This structure enables primitive communication
// between UlCreatePipeline() and the worker threads.
//

typedef struct _UL_PIPELINE_THREAD_CONTEXT
{
    PUL_PIPELINE pPipeline;
    ULONG Processor;
    NTSTATUS Status;
    KEVENT InitCompleteEvent;
    PUL_PIPELINE_THREAD_DATA pThreadData;

} UL_PIPELINE_THREAD_CONTEXT, *PUL_PIPELINE_THREAD_CONTEXT;


//
// Private prototypes.
//

BOOLEAN
UlpWaitForWorkPipeline(
    IN PUL_PIPELINE pPipeline
    );

PLIST_ENTRY
UlpDequeueAllWorkPipeline(
    IN PUL_PIPELINE pPipeline,
    IN PUL_PIPELINE_QUEUE Queue
    );

BOOLEAN
UlpLockQueuePipeline(
    IN PUL_PIPELINE_QUEUE pQueue
    );

VOID
UlpUnlockQueuePipeline(
    IN PUL_PIPELINE_QUEUE pQueue
    );

PUL_PIPELINE_QUEUE
UlpFindNextQueuePipeline(
    IN PUL_PIPELINE pPipeline,
    IN OUT PUL_PIPELINE_QUEUE_ORDINAL pQueueOrdinal
    );

VOID
UlpPipelineWorkerThread(
    IN PVOID pContext
    );

PUL_PIPELINE
UlpPipelineWorkerThreadStartup(
    IN PUL_PIPELINE_THREAD_CONTEXT pContext
    );

VOID
UlpKillPipelineWorkerThreads(
    IN PUL_PIPELINE pPipeline
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlCreatePipeline )
#pragma alloc_text( INIT, UlInitializeQueuePipeline )
#pragma alloc_text( PAGE, UlDestroyPipeline )
#pragma alloc_text( PAGE, UlpLockQueuePipeline )
#pragma alloc_text( PAGE, UlpUnlockQueuePipeline )
#pragma alloc_text( PAGE, UlpFindNextQueuePipeline )
#pragma alloc_text( PAGE, UlpPipelineWorkerThread )
#pragma alloc_text( PAGE, UlpPipelineWorkerThreadStartup )
#endif
#if 0
NOT PAGEABLE -- UlQueueWorkPipeline
NOT PAGEABLE -- UlpWaitForWorkPipeline
NOT PAGEABLE -- UlpDequeueAllWorkPipeline
NOT PAGEABLE -- UlpKillPipelineWorkerThreads
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Creates a new pipeline and the associated queues.

Arguments:

    ppPipeline - Receives a pointer to the new pipeline object.

    QueueCount - Supplies the number of queues in the new pipeline.

    ThreadsPerCpu - Supplies the number of worker threads to create
        per CPU.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreatePipeline(
    OUT PUL_PIPELINE * ppPipeline,
    IN SHORT QueueCount,
    IN SHORT ThreadsPerCpu
    )
{
    NTSTATUS status;
    PVOID pAllocation;
    PUL_PIPELINE pPipeline;
    PUL_PIPELINE_QUEUE pQueue;
    PUL_PIPELINE_RARE pRareData;
    ULONG bytesRequired;
    ULONG totalThreads;
    ULONG i;
    PUL_PIPELINE_THREAD_DATA pThreadData;
    UL_PIPELINE_THREAD_CONTEXT context;
    OBJECT_ATTRIBUTES objectAttributes;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( QueueCount > 0 );
    ASSERT( ThreadsPerCpu > 0 );

    //
    // Allocate the pool. Note that we allocate slightly larger than
    // necessary then round up to the next cache-line. Also note that
    // we allocate the pipeline, rare data, and thread data structures
    // in a single pool block.
    //

    totalThreads = (ULONG)ThreadsPerCpu * g_UlNumberOfProcessors;

    bytesRequired = PIPELINE_LENGTH( QueueCount, totalThreads ) +
        CACHE_LINE_SIZE - 1;

    pAllocation = UL_ALLOCATE_POOL(
                        NonPagedPool,
                        bytesRequired,
                        UL_PIPELINE_POOL_TAG
                        );

    if( pAllocation == NULL )
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        pAllocation,
        bytesRequired
        );

    //
    // Ensure the pipeline starts on a cache boundary.
    //

    pPipeline = (PUL_PIPELINE)ROUND_UP( pAllocation, CACHE_LINE_SIZE );

    //
    // Initialize the static portion of the pipeline.
    //

    UlInitializeSpinLock( &pPipeline->PipelineLock, "PipelineLock" );

    pPipeline->ThreadsRunning = (SHORT)totalThreads;
    pPipeline->QueuesWithWork = 0;
    pPipeline->MaximumThreadsRunning = (SHORT)totalThreads;
    pPipeline->QueueCount = QueueCount;
    pPipeline->ShutdownFlag = FALSE;

    KeInitializeEvent(
        &pPipeline->WorkAvailableEvent,         // Event
        SynchronizationEvent,                   // Type
        FALSE                                   // State
        );

    //
    // Initialize the rare data. Note the PIPELINE_TO_RARE_DATA() macro
    // requires the QueueCount field to be set before the macro can be
    // used.
    //

    pRareData = PIPELINE_TO_RARE_DATA( pPipeline );
    pRareData->pAllocationBlock = pAllocation;

    //
    // Setup the thread start context. This structure allows us to
    // pass enough information to the worker thread that it can
    // set its affinity correctly and return any failure status
    // back to us.
    //

    context.pPipeline = pPipeline;
    context.Processor = 0;
    context.Status = STATUS_SUCCESS;

    KeInitializeEvent(
        &context.InitCompleteEvent,             // Event
        SynchronizationEvent,                   // Type
        FALSE                                   // State
        );

    //
    // Create the worker threads.
    //

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        NULL,                                   // ObjectName
        UL_KERNEL_HANDLE,                       // Attributes
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    UlAttachToSystemProcess();

    pThreadData = PIPELINE_TO_THREAD_DATA( pPipeline );

    for (i = 0 ; i < totalThreads ; i++)
    {
        context.pThreadData = pThreadData;

        status = PsCreateSystemThread(
                     &pThreadData->ThreadHandle,    // ThreadHandle
                     THREAD_ALL_ACCESS,             // DesiredAccess
                     &objectAttributes,             // ObjectAttributes
                     NULL,                          // ProcessHandle
                     NULL,                          // ClientId
                     &UlpPipelineWorkerThread,      // StartRoutine
                     &context                       // StartContext
                     );

        if (!NT_SUCCESS(status))
        {
            UlDetachFromSystemProcess();
            UlDestroyPipeline( pPipeline );
            return status;
        }

        //
        // Wait for it to initialize.
        //

        KeWaitForSingleObject(
            &context.InitCompleteEvent,         // Object
            UserRequest,                        // WaitReason
            KernelMode,                         // WaitMode
            FALSE,                              // Alertable
            NULL                                // Timeout
            );

        status = context.Status;

        if (!NT_SUCCESS(status))
        {
            //
            // The current thread failed initialization. Since we know it
            // has already exited, we can go ahead and close & NULL the
            // handle. This allows UlpKillPipelineWorkerThreads() to just
            // look at the first thread handle in the array to determine if
            // there are any threads that need to be terminated.
            //

            ZwClose( pThreadData->ThreadHandle );
            UlDetachFromSystemProcess();
            pThreadData->ThreadHandle = NULL;
            pThreadData->pThreadObject = NULL;

            UlDestroyPipeline( pPipeline );
            return status;

        }

        ASSERT( pThreadData->ThreadHandle != NULL );
        ASSERT( pThreadData->pThreadObject != NULL );

        //
        // Advance to the next thread.
        //

        pThreadData++;
        context.Processor++;

        if (context.Processor >= g_UlNumberOfProcessors)
        {
            context.Processor = 0;
        }
    }

    UlDetachFromSystemProcess();

    //
    // At this point, the pipeline is fully initialized *except* for
    // the individual work queues. It is the caller's responsibility
    // to initialize those queues.
    //

    *ppPipeline = pPipeline;
    return STATUS_SUCCESS;

}   // UlCreatePipeline


/***************************************************************************++

Routine Description:

    Initializes the specified pipeline queue.

Arguments:

    pPipeline - Supplies the pipeline that owns the queue.

    QueueOrdinal - Supplies the queue to initialize.

    pHandler - Supplies the handler routine for the queue.

--***************************************************************************/
VOID
UlInitializeQueuePipeline(
    IN PUL_PIPELINE pPipeline,
    IN UL_PIPELINE_QUEUE_ORDINAL QueueOrdinal,
    IN PFN_UL_PIPELINE_HANDLER pHandler
    )
{
    PUL_PIPELINE_QUEUE pQueue;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( QueueOrdinal < pPipeline->QueueCount );

    //
    // Initialize it.
    //

    pQueue = &pPipeline->Queues[QueueOrdinal];

    InitializeListHead(
        &pQueue->WorkQueueHead
        );

    pQueue->QueueLock = L_UNLOCKED;
    pQueue->pHandler = pHandler;

}   // UlInitializeQueuePipeline


/***************************************************************************++

Routine Description:

    Destroys the specified pipeline, freeing any allocated resources
    and killing the worker threads.

Arguments:

    pPipeline - Supplies the pipeline to destroy.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlDestroyPipeline(
    IN PUL_PIPELINE pPipeline
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( pPipeline != NULL );
    ASSERT( PIPELINE_TO_RARE_DATA( pPipeline ) != NULL );
    ASSERT( PIPELINE_TO_RARE_DATA( pPipeline )->pAllocationBlock != NULL );

    UlpKillPipelineWorkerThreads( pPipeline );

    UL_FREE_POOL(
        PIPELINE_TO_RARE_DATA( pPipeline )->pAllocationBlock,
        UL_PIPELINE_POOL_TAG
        );

    return STATUS_SUCCESS;

}   // UlDestroyPipeline


/***************************************************************************++

Routine Description:

    Enqueues a work item to the specified pipeline queue.

Arguments:

    pPipeline - Supplies the pipeline that owns the queue.

    QueueOrdinal - Supplies the queue to enqueue the work on.

    pWorkItem - Supplies the work item to enqueue.

--***************************************************************************/
VOID
UlQueueWorkPipeline(
    IN PUL_PIPELINE pPipeline,
    IN UL_PIPELINE_QUEUE_ORDINAL QueueOrdinal,
    IN PUL_PIPELINE_WORK_ITEM pWorkItem
    )
{
    KIRQL oldIrql;
    PUL_PIPELINE_QUEUE pQueue;
    BOOLEAN needToSetEvent = FALSE;

    ASSERT( QueueOrdinal < pPipeline->QueueCount );
    pQueue = &pPipeline->Queues[QueueOrdinal];

    UlAcquireSpinLock(
        &pPipeline->PipelineLock,
        &oldIrql
        );

    if (!pPipeline->ShutdownFlag)
    {
        //
        // If the queue is currently empty, then remember that we have new
        // queue with work pending. If the number of pending queues is now
        // greater than the number of threads currently running (but less
        // than the maximum configured), then remember that we'll need to
        // set the event to unblock a new worker thread.
        //

        if (IsListEmpty( &pQueue->WorkQueueHead ))
        {
            pPipeline->QueuesWithWork++;

            if (pPipeline->QueuesWithWork > pPipeline->ThreadsRunning &&
                pPipeline->ThreadsRunning < pPipeline->MaximumThreadsRunning)
            {
                needToSetEvent = TRUE;
            }
        }

        InsertTailList(
            &pQueue->WorkQueueHead,
            &pWorkItem->WorkQueueEntry
            );
    }

    UlReleaseSpinLock(
        &pPipeline->PipelineLock,
        oldIrql
        );

    if (needToSetEvent)
    {
        KeSetEvent(
            &pPipeline->WorkAvailableEvent,     // Event
            g_UlPriorityBoost,                  // Increment
            FALSE                               // Wait
            );
    }

}   // UlQueueWorkPipeline


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Blocks the current thread if necessary until work is available on one
    of the pipeline queues.

Arguments:

    pPipeline - Supplies the pipeline to block on.

Return Value:

    BOOLEAN - TRUE if the thread should exit, FALSE if it should continue
        to service requests.

--***************************************************************************/
BOOLEAN
UlpWaitForWorkPipeline(
    IN PUL_PIPELINE pPipeline
    )
{
    KIRQL oldIrql;
    BOOLEAN needToWait;
    BOOLEAN firstPass = TRUE;

    while (TRUE)
    {
        UlAcquireSpinLock(
            &pPipeline->PipelineLock,
            &oldIrql
            );

        if (pPipeline->ShutdownFlag)
        {
            UlReleaseSpinLock(
                &pPipeline->PipelineLock,
                oldIrql
                );
            return TRUE;
        }

        //
        // If there are more threads running than there is work available
        // or if we've reached our maximum thread count, then we'll need
        // to wait on the event. Otherwise, we can update the running thread
        // count and bail.
        //

        if (pPipeline->QueuesWithWork <= pPipeline->ThreadsRunning ||
            pPipeline->ThreadsRunning >= pPipeline->MaximumThreadsRunning)
        {
            needToWait = TRUE;

            if (firstPass)
            {
                pPipeline->ThreadsRunning--;
                firstPass = FALSE;
            }
        }
        else
        {
            pPipeline->ThreadsRunning++;
            needToWait = FALSE;
        }

        UlReleaseSpinLock(
            &pPipeline->PipelineLock,
            oldIrql
            );

        if (needToWait)
        {
            KeWaitForSingleObject(
                &pPipeline->WorkAvailableEvent, // Object
                UserRequest,                    // WaitReason
                KernelMode,                     // WaitMode
                FALSE,                          // Alertable
                NULL                            // Timeout
                );
        }
        else
        {
            break;
        }
    }

    return FALSE;

}   // UlpWaitForWorkPipeline


/***************************************************************************++

Routine Description:

    Dequeues all work items from the specified queue.

Arguments:

    pPipeline - Supplies the pipeline owning the queue.

    pQueue - Supplies the queue dequeue the work items from.

Return Value:

    PLIST_ENTRY - Pointer to the first work item if successful, or a
        pointer to the head of the work queue if it is empty.

--***************************************************************************/
PLIST_ENTRY
UlpDequeueAllWorkPipeline(
    IN PUL_PIPELINE pPipeline,
    IN PUL_PIPELINE_QUEUE pQueue
    )
{
    KIRQL oldIrql;
    PLIST_ENTRY pListEntry;

    UlAcquireSpinLock(
        &pPipeline->PipelineLock,
        &oldIrql
        );

    //
    // Dequeue all work items and update the count of queues with work.
    //

    pListEntry = pQueue->WorkQueueHead.Flink;

    if (pListEntry != &pQueue->WorkQueueHead)
    {
        pPipeline->QueuesWithWork--;
    }

    InitializeListHead( &pQueue->WorkQueueHead );

    UlReleaseSpinLock(
        &pPipeline->PipelineLock,
        oldIrql
        );

    return pListEntry;

}   // UlpDequeueAllWorkPipeline


/***************************************************************************++

Routine Description:

    Attempts to acquire the lock protecting the queue.

    N.B. Queue locks cannot be acquired recursively.

Arguments:

    pQueue - Supplies the queue to attempt to lock.

Return Value:

    BOOLEAN - TRUE if the queue was locked successfully, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlpLockQueuePipeline(
    IN PUL_PIPELINE_QUEUE pQueue
    )
{
    LONG result;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Try to exchange the lock value with L_LOCKED. If the previous value
    // was L_UNLOCKED, then we know the lock is ours.
    //

    result = UlInterlockedCompareExchange(
                 &pQueue->QueueLock,
                 L_LOCKED,
                 L_UNLOCKED
                 );

    return ( result == L_UNLOCKED );

}   // UlpLockQueuePipeline


/***************************************************************************++

Routine Description:

    Unlocks a locked queue.

Arguments:

    pQueue - Supplies the queue to unlock.

--***************************************************************************/
VOID
UlpUnlockQueuePipeline(
    IN PUL_PIPELINE_QUEUE pQueue
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // No need to interlock this, as we own the lock.
    //

    pQueue->QueueLock = L_UNLOCKED;

}   // UlpUnlockQueuePipeline


/***************************************************************************++

Routine Description:

    Scans the specified pipeline's queues looking for one that is not
    currently locked.

    N.B. The queues are searched backwards (from high index to low index).

Arguments:

    pPipeline - Supplies the pipeline to scan.

    pQueueOrdinal - Supplies a pointer to the ordinal of the most recently
        touched queue. This value will get updated with the ordinal of the
        queue returned (if successful).

Return Value:

    PUL_PIPELINE_QUEUE - Pointer to a queue if succesful, NULL otherwise.

--***************************************************************************/
PUL_PIPELINE_QUEUE
UlpFindNextQueuePipeline(
    IN PUL_PIPELINE pPipeline,
    IN OUT PUL_PIPELINE_QUEUE_ORDINAL pQueueOrdinal
    )
{
    UL_PIPELINE_QUEUE_ORDINAL ordinal;
    SHORT count;
    PUL_PIPELINE_QUEUE pQueue;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Start at the current values.
    //

    ordinal = *pQueueOrdinal;
    pQueue = &pPipeline->Queues[ordinal];

    for (count = pPipeline->QueueCount ; count > 0 ; count--)
    {
        //
        // Go to the previous value. We scan backwards to make the
        // math (and the generated code) a bit simpler.
        //

        pQueue--;
        ordinal--;

        if (ordinal < 0)
        {
            ordinal = pPipeline->QueueCount - 1;
            pQueue = &pPipeline->Queues[ordinal];
        }

        //
        // If the queue is not empty and we can lock the queue,
        // then return it.
        //

        if (!IsListEmpty( &pQueue->WorkQueueHead ) &&
            UlpLockQueuePipeline( pQueue ))
        {
            *pQueueOrdinal = ordinal;
            return pQueue;
        }
    }

    //
    // If we made it this far, then all queues are being handled.
    //

    return NULL;

}   // UlpFindNextQueuePipeline


/***************************************************************************++

Routine Description:

    Worker thread for the pipeline package.

Arguments:

    pContext - Supplies the context for the thread. This is actually a
        PUL_PIPELINE_THREAD_CONTEXT pointer containing startup information
        for this thread.

--***************************************************************************/
VOID
UlpPipelineWorkerThread(
    IN PVOID pContext
    )
{
    PUL_PIPELINE pPipeline;
    PUL_PIPELINE_QUEUE pQueue;
    PUL_PIPELINE_WORK_ITEM pWorkItem;
    UL_PIPELINE_QUEUE_ORDINAL ordinal;
    PFN_UL_PIPELINE_HANDLER pHandler;
    PUL_PIPELINE_THREAD_DATA pThreadData;
    PLIST_ENTRY pListEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pContext != NULL );

    //
    // Initialize the thread data.
    //

    pThreadData = ((PUL_PIPELINE_THREAD_CONTEXT)pContext)->pThreadData;
    pThreadData->pThreadObject = (PVOID)PsGetCurrentThread();

    //
    // Initialize the thread. If this fails, we're toast.
    //

    pPipeline = UlpPipelineWorkerThreadStartup(
                    (PUL_PIPELINE_THREAD_CONTEXT)pContext
                    );

    if (!pPipeline)
    {
        return;
    }

    //
    // Loop forever, or at least until we're told to quit.
    //

    ordinal = 0;

    while (TRUE)
    {
        //
        // Wait for something to do.
        //

        if (UlpWaitForWorkPipeline( pPipeline ))
        {
            break;
        }

        //
        // Try to find an unowned queue.
        //

        pQueue = UlpFindNextQueuePipeline( pPipeline, &ordinal );

        if (pQueue != NULL)
        {
#if DBG
            pThreadData->QueuesHandled++;
#endif

            //
            // Snag the handler routine from the queue.
            //

            pHandler = pQueue->pHandler;

            //
            // Loop through all of the work items on the queue and
            // invoke the handler for each.
            //

            pListEntry = UlpDequeueAllWorkPipeline(
                                pPipeline,
                                pQueue
                                );

            while (pListEntry != &pQueue->WorkQueueHead)
            {
                pWorkItem = CONTAINING_RECORD(
                                pListEntry,
                                UL_PIPELINE_WORK_ITEM,
                                WorkQueueEntry
                                );
                pListEntry = pListEntry->Flink;

                (pHandler)( pWorkItem );

#if DBG
                pThreadData->WorkItemsHandled++;
#endif
            }

            //
            // We're done with the queue, so unlock it.
            //

            UlpUnlockQueuePipeline( pQueue );
        }
    }

}   // UlpPipelineWorkerThread


/***************************************************************************++

Routine Description:

    Startup code for pipeline worker threads.

Arguments:

    pContext - Supplies a pointer to the startup context for this thread.
        The context will receive the final startup completion status.

Return Value:

    PUL_PIPELINE - A pointer to the thread's pipeline if successful,
        NULL otherwise.

--***************************************************************************/
PUL_PIPELINE
UlpPipelineWorkerThreadStartup(
    IN PUL_PIPELINE_THREAD_CONTEXT pContext
    )
{
    NTSTATUS status;
    ULONG affinityMask;
    PUL_PIPELINE pPipeline;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pContext != NULL );
    ASSERT( pContext->pPipeline != NULL );
    ASSERT( pContext->pThreadData != NULL );

    //
    // Disable hard error popups.
    //

    IoSetThreadHardErrorMode( FALSE );

    //
    // Set our affinity.
    //

    ASSERT( pContext->Processor < g_UlNumberOfProcessors );
    affinityMask = 1 << pContext->Processor;

    status = NtSetInformationThread(
                 NtCurrentThread(),             // ThreadHandle
                 ThreadAffinityMask,            // ThreadInformationClass
                 &affinityMask,                 // ThreadInformation
                 sizeof(affinityMask)           // ThreadInformationLength
                 );

    if (!NT_SUCCESS(status))
    {
        pContext->Status = status;
        return NULL;
    }

    //
    // Capture the pipeline from the context before setting the
    // init complete event. Once we set the event, we are not allowed
    // to touch the context structure.
    //

    pPipeline = pContext->pPipeline;
    ASSERT( pPipeline != NULL );

    KeSetEvent(
        &pContext->InitCompleteEvent,           // Event
        0,                                      // Increment
        FALSE                                   // Wait
        );

    return pPipeline;

}  // UlpPipelineWorkerThreadStartup


/***************************************************************************++

Routine Description:

    Kills all worker threads associated with the given pipeline and
    waits for them to die.

Arguments:

    pPipeline - Supplies the pipeline to terminate.

--***************************************************************************/
VOID
UlpKillPipelineWorkerThreads(
    IN PUL_PIPELINE pPipeline
    )
{
    KIRQL oldIrql;
    SHORT totalThreads;
    SHORT i;
    PUL_PIPELINE_THREAD_DATA pThreadData;
    LARGE_INTEGER delayInterval;

    //
    // Sanity check.
    //

    ASSERT( pPipeline != NULL );

    //
    // Count the number of running threads.
    //

    pThreadData = PIPELINE_TO_THREAD_DATA( pPipeline );
    totalThreads = 0;

    for (i = 0 ; i < pPipeline->MaximumThreadsRunning ; i++)
    {
        if (pThreadData->ThreadHandle == NULL)
        {
            break;
        }

        pThreadData++;
        totalThreads++;
    }

    if (totalThreads > 0)
    {
        //
        // We have threads running, so we'll need to signal them to stop.
        //

        UlAcquireSpinLock(
            &pPipeline->PipelineLock,
            &oldIrql
            );

        pPipeline->ShutdownFlag = TRUE;

        UlReleaseSpinLock(
            &pPipeline->PipelineLock,
            oldIrql
            );

        while (pPipeline->ThreadsRunning > 0)
        {
            KeSetEvent(
                &pPipeline->WorkAvailableEvent, // Event
                g_UlPriorityBoost,              // Increment
                FALSE                           // Wait
                );

            delayInterval.QuadPart = -1*10*1000*500; // .5 second

            KeDelayExecutionThread(
                KernelMode,                     // WaitMode
                FALSE,                          // Alertable
                &delayInterval                  // Interval
                );
        }

        //
        // Wait for them to die.
        //

        pThreadData = PIPELINE_TO_THREAD_DATA( pPipeline );

        for (i = 0 ; i < totalThreads ; i++)
        {
            KeWaitForSingleObject(
                (PVOID)pThreadData->pThreadObject,  // Object
                UserRequest,                        // WaitReason
                KernelMode,                         // WaitMode
                FALSE,                              // Alertable
                NULL                                // Timeout
                );

            UlCloseSystemHandle( pThreadData->ThreadHandle );

            pThreadData->ThreadHandle = NULL;
            pThreadData->pThreadObject = NULL;

            pThreadData++;
        }
    }

}  // UlpKillPipelineWorkerThreads
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\parse.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    parse.cxx

Abstract:

    Contains all of the kernel mode HTTP parsing code.

Author:

    Henry Sanders (henrysa)       27-Apr-1998

Revision History:

    Paul McDaniel   (paulmcd)       3-Mar-1998  finished up

--*/


#include "precomp.h"
#include "parsep.h"
#include "rcvhdrs.h"

//
// Global initialization flag.
//

BOOLEAN g_DateCacheInitialized = FALSE;


//
// The fast verb translation table
//

FAST_VERB_ENTRY FastVerbTable[] =
{
    CREATE_FAST_VERB_ENTRY(GET),
    CREATE_FAST_VERB_ENTRY(HEAD),
    CREATE_FAST_VERB_ENTRY(PUT),
    CREATE_FAST_VERB_ENTRY(POST),
    CREATE_FAST_VERB_ENTRY(DELETE),
    CREATE_FAST_VERB_ENTRY(TRACE),
    CREATE_FAST_VERB_ENTRY(TRACK),
    CREATE_FAST_VERB_ENTRY(OPTIONS),
    CREATE_FAST_VERB_ENTRY(CONNECT),
    CREATE_FAST_VERB_ENTRY(MOVE),
    CREATE_FAST_VERB_ENTRY(COPY),
    CREATE_FAST_VERB_ENTRY(MKCOL),
    CREATE_FAST_VERB_ENTRY(LOCK),
    CREATE_FAST_VERB_ENTRY(UNLOCK),
    CREATE_FAST_VERB_ENTRY(SEARCH)
};


//
// The long verb translation table. All verbs more than 7 characters long
// belong in this table.
//

LONG_VERB_ENTRY LongVerbTable[] =
{
    CREATE_LONG_VERB_ENTRY(PROPFIND),
    CREATE_LONG_VERB_ENTRY(PROPPATCH)
};


//
// The request header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
// for nice perf, group unused headers low in the sub-sort order
//
// it's important that the header name is <= 24 characters (3 ULONGLONG's).
//

HEADER_MAP_ENTRY g_RequestHeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(Accept:,
                            HttpHeaderAccept,
                            FALSE,
                            UlAcceptHeaderHandler,
                            NULL,
                            0),

    CREATE_HEADER_MAP_ENTRY(Accept-Language:,
                            HttpHeaderAcceptLanguage,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            1),

    CREATE_HEADER_MAP_ENTRY(Accept-Encoding:,
                            HttpHeaderAcceptEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            3),

    CREATE_HEADER_MAP_ENTRY(Accept-Charset:,
                            HttpHeaderAcceptCharset,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Authorization:,
                            HttpHeaderAuthorization,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Allow:,
                            HttpHeaderAllow,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Connection:,
                            HttpHeaderConnection,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            7),

    CREATE_HEADER_MAP_ENTRY(Cache-Control:,
                            HttpHeaderCacheControl,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Cookie:,
                            HttpHeaderCookie,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Length:,
                            HttpHeaderContentLength,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Type:,
                            HttpHeaderContentType,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Encoding:,
                            HttpHeaderContentEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Language:,
                            HttpHeaderContentLanguage,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Location:,
                            HttpHeaderContentLocation,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-MD5:,
                            HttpHeaderContentMd5,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Range:,
                            HttpHeaderContentRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Date:,
                            HttpHeaderDate,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expect:,
                            HttpHeaderExpect,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expires:,
                            HttpHeaderExpires,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(From:,
                            HttpHeaderFrom,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Host:,
                            HttpHeaderHost,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            6),

    CREATE_HEADER_MAP_ENTRY(If-Modified-Since:,
                            HttpHeaderIfModifiedSince,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            4),

    CREATE_HEADER_MAP_ENTRY(If-None-Match:,
                            HttpHeaderIfNoneMatch,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            5),

    CREATE_HEADER_MAP_ENTRY(If-Match:,
                            HttpHeaderIfMatch,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(If-Unmodified-Since:,
                            HttpHeaderIfUnmodifiedSince,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(If-Range:,
                            HttpHeaderIfRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Last-Modified:,
                            HttpHeaderLastModified,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),


    CREATE_HEADER_MAP_ENTRY(Max-Forwards:,
                            HttpHeaderMaxForwards,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Pragma:,
                            HttpHeaderPragma,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Proxy-Authorization:,
                            HttpHeaderProxyAuthorization,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Referer:,
                            HttpHeaderReferer,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Range:,
                            HttpHeaderRange,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Trailer:,
                            HttpHeaderTrailer,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Transfer-Encoding:,
                            HttpHeaderTransferEncoding,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(TE:,
                            HttpHeaderTe,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Translate:,
                            HttpHeaderTranslate,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(User-Agent:,
                            HttpHeaderUserAgent,
                            FALSE,
                            UlSingleHeaderHandler,
                            NULL,
                            2),

    CREATE_HEADER_MAP_ENTRY(Upgrade:,
                            HttpHeaderUpgrade,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Via:,
                            HttpHeaderVia,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Warning:,
                            HttpHeaderWarning,
                            FALSE,
                            UlMultipleHeaderHandler,
                            NULL,
                            -1),
};

// The response header map table. These entries don't need to be in strict
// alphabetical order, but they do need to be grouped by the first character
// of the header - all A's together, all C's together, etc. They also need
// to be entered in uppercase, since we upcase incoming verbs before we do
// the compare.
//
// for nice perf, group unused headers low in the sub-sort order
//
// it's important that the header name is <= 24 characters (3 ULONGLONG's).
//
// BUGBUG: Fix the AUTO-GENERATE fields for the ones we auto-generate!!!
//

#define UcSingleHeaderHandler   NULL
#define UcMultipleHeaderHandler NULL

HEADER_MAP_ENTRY g_ResponseHeaderMapTable[] =
{
    CREATE_HEADER_MAP_ENTRY(Accept-Ranges:,
                            HttpHeaderAcceptRanges,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Age:,
                            HttpHeaderAge,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Allow:,
                            HttpHeaderAllow,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),


    CREATE_HEADER_MAP_ENTRY(Cache-Control:,
                            HttpHeaderCacheControl,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Connection:,
                            HttpHeaderConnection,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Encoding:,
                            HttpHeaderContentEncoding,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Language:,
                            HttpHeaderContentLanguage,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Length:,
                            HttpHeaderContentLength,
                            TRUE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Location:,
                            HttpHeaderContentLocation,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-MD5:,
                            HttpHeaderContentMd5,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Range:,
                            HttpHeaderContentRange,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Content-Type:,
                            HttpHeaderContentType,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Date:,
                            HttpHeaderDate,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(ETag:,
                            HttpHeaderEtag,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Expires:,
                            HttpHeaderExpires,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Last-Modified:,
                            HttpHeaderLastModified,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Location:,
                            HttpHeaderLocation,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Pragma:,
                            HttpHeaderPragma,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Proxy-Authenticate:,
                            HttpHeaderProxyAuthenticate,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Retry-After:,
                            HttpHeaderRetryAfter,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Server:,
                            HttpHeaderServer,
                            FALSE,
                            NULL,
                            UcSingleHeaderHandler,
                            -1),

#if 0
    CREATE_HEADER_MAP_ENTRY(Set-Cookie:,
                            HttpHeaderSetCookie,
                            FALSE,
                            NULL,
                            -1),
#endif

    CREATE_HEADER_MAP_ENTRY(Trailer:,
                            HttpHeaderTrailer,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Transfer-Encoding:,
                            HttpHeaderTransferEncoding,
                            TRUE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Upgrade:,
                            HttpHeaderUpgrade,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Vary:,
                            HttpHeaderVary,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Via:,
                            HttpHeaderVia,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(Warning:,
                            HttpHeaderWarning,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1),

    CREATE_HEADER_MAP_ENTRY(WWW-Authenticate:,
                            HttpHeaderWwwAuthenticate,
                            FALSE,
                            NULL,
                            UcMultipleHeaderHandler,
                            -1)
};

ULONG g_RequestHeaderMap[HttpHeaderMaximum];
ULONG g_ResponseHeaderMap[HttpHeaderMaximum];


//
// The header index table. This is initialized by the init code.
//

HEADER_INDEX_ENTRY  g_RequestHeaderIndexTable[NUMBER_HEADER_INDICIES];
HEADER_INDEX_ENTRY  g_ResponseHeaderIndexTable[NUMBER_HEADER_INDICIES];

HEADER_HINT_INDEX_ENTRY g_RequestHeaderHintIndexTable[NUMBER_HEADER_HINT_INDICIES];

#define NUMBER_FAST_VERB_ENTRIES    (sizeof(FastVerbTable)/sizeof(FAST_VERB_ENTRY))
#define NUMBER_LONG_VERB_ENTRIES    (sizeof(LongVerbTable)/sizeof(LONG_VERB_ENTRY))
#define NUMBER_REQUEST_HEADER_MAP_ENTRIES  \
              (sizeof(g_RequestHeaderMapTable)/sizeof(HEADER_MAP_ENTRY))
#define NUMBER_RESPONSE_HEADER_MAP_ENTRIES \
              (sizeof(g_ResponseHeaderMapTable)/sizeof(HEADER_MAP_ENTRY))

const char DefaultChar = '_';


/*++

Routine Description:

    A utility routine to find a token. We take an input pointer, skip any
    preceding LWS, then scan the token until we find either LWS or a CRLF
    pair.

Arguments:

    pBuffer         - Buffer to search for token.
    BufferLength    - Length of data pointed to by pBuffer.
    TokenLength     - Where to return the length of the token.

Return Value:

    A pointer to the token we found, as well as the length, or NULL if we
    don't find a delimited token.

--*/
PUCHAR
FindWSToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *pTokenLength
    )
{
    PUCHAR  pTokenStart;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First, skip any preceding LWS.
    //

    while (BufferLength > 0 && IS_HTTP_LWS(*pBuffer))
    {
        pBuffer++;
        BufferLength--;
    }

    // If we stopped because we ran out of buffer, fail.
    if (BufferLength == 0)
    {
        return NULL;
    }

    pTokenStart = pBuffer;

    // Now skip over the token, until we see either LWS or a CR or LF.
    while (BufferLength != 0 &&
           (*pBuffer != CR &&
            *pBuffer != SP &&
            *pBuffer != LF &&
            *pBuffer != HT)
           )
    {
        pBuffer++;
        BufferLength--;
    }

    // See why we stopped.
    if (BufferLength == 0)
    {
        // Ran out of buffer before end of token.
        return NULL;
    }

    // Success. Set the token length and return the start of the token.
    *pTokenLength = DIFF(pBuffer - pTokenStart);
    return pTokenStart;

}   // FindWSToken

/*++

Routine Description:

    The slower way to look up a verb. We find the verb in the request and then
    look for it in the LongVerbTable. If it's not found, we'll return
    UnknownVerb. If it can't be parsed we return UnparsedVerb. Otherwise
    we return the verb type.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by pHttpRequest.
    pVerb               - Where we return a pointer to the verb, if it's an
                            unknown ver.
    ppVerbLength        - Where we return the length of the verb
    pBytesTaken         - The total length consumed, including the length of
                            the verb plus preceding & 1 trailing whitespace.

Return Value:

    The verb we found, or the appropriate error.

--*/
NTSTATUS
LookupVerb(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    )
{
    ULONG       TokenLength;
    PUCHAR      pToken;
    PUCHAR      pTempRequest;
    ULONG       TempLength;
    ULONG       i;

    //
    // Sanity check.
    //

    PAGED_CODE();

    // Since we may have gotten here due to a extraneous CRLF pair, skip
    // any of those now. Need to use a temporary variable since
    // the original input pointer and length are used below.

    pTempRequest = pHttpRequest;
    TempLength = HttpRequestLength;

    while ( TempLength != 0 &&
            ((*pTempRequest == CR) || (*pTempRequest == LF)) )
    {
        pTempRequest++;
        TempLength--;
    }

    // First find the verb.

    pToken = FindWSToken(pTempRequest, TempLength, &TokenLength);

    if (pToken == NULL)
    {
        // Didn't find it, let's get more buffer
        //
        pRequest->Verb = HttpVerbUnparsed;

        *pBytesTaken = 0;

        return STATUS_SUCCESS;
    }

    // Make sure we stopped because of a SP.

    if (*(pToken + TokenLength) != SP)
    {
        // Bad verb section!
        //
        pRequest->Verb = HttpVerbInvalid;

        pRequest->ErrorCode = UlErrorVerb;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!LookupVerb(pRequest = %p) ERROR: no space after verb\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Otherwise, we found one, so update bytes taken and look up up in
    // the tables.

    *pBytesTaken = DIFF(pToken - pHttpRequest) + TokenLength + 1;

    //
    // If we ate some leading whitespace, or if the HttpRequestLength is less than
    // sizeof(ULONGLONG), we must look through the "fast" verb table again, but do
    // it the "slow" way.
    //
    for (i = 0; i < NUMBER_FAST_VERB_ENTRIES; i++)
    {
        if ((FastVerbTable[i].RawVerbLength == (TokenLength + 1)) &&
            RtlEqualMemory(pToken, FastVerbTable[i].RawVerb.Char, TokenLength))
        {
            // It matched. Save the translated verb from the
            // table, and bail out.
            //
            pRequest->Verb = FastVerbTable[i].TranslatedVerb;
            return STATUS_SUCCESS;
        }
    }

    //
    // Now look through the "long" verb table
    //
    for (i = 0; i < NUMBER_LONG_VERB_ENTRIES; i++)
    {
        if (LongVerbTable[i].RawVerbLength == TokenLength &&
            RtlEqualMemory(pToken, LongVerbTable[i].RawVerb, TokenLength))
        {
            // Found it.
            //
            pRequest->Verb = LongVerbTable[i].TranslatedVerb;
            return STATUS_SUCCESS;
        }
    }

    //
    // If we got here, we searched both tables and didn't find it.
    //

    //
    // It's a raw verb
    //

    pRequest->Verb              = HttpVerbUnknown;
    pRequest->pRawVerb          = pToken;
    pRequest->RawVerbLength     = TokenLength;

    //
    // include room for the terminator
    //

    pRequest->TotalRequestSize += (TokenLength + 1) * sizeof(CHAR);

    ASSERT( !(pRequest->RawVerbLength==3 && RtlEqualMemory(pRequest->pRawVerb,"GET",3)));

    return STATUS_SUCCESS;

}   // LookupVerb


/*++

Routine Description:

    A utility routine to parse an absolute URL in a URL string. When this
    is called we already have loaded the entire url into RawUrl.pUrl and
    know that it start with "http".

    this functions job is to set RawUrl.pHost + RawUrl.pAbsPath.

Arguments:

    pRequest        - Pointer to the HTTP_REQUEST

Return Value:

    NTSTATUS

Author:

    Henry Sanders ()                        1998
    Paul McDaniel (paulmcd)                 6-Mar-1999

--*/
NTSTATUS
ParseFullUrl(
    IN  PUL_INTERNAL_REQUEST    pRequest
    )
{
    PUCHAR  pURL;
    ULONG   UrlLength;
    PUCHAR  pUrlStart;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pURL = pRequest->RawUrl.pUrl;
    UrlLength = pRequest->RawUrl.Length;

    //
    // When we're called, we know that the start of the URL must point at
    // an absolute scheme prefix. Adjust for that now.
    //

    pUrlStart = pURL + HTTP_PREFIX_SIZE;
    UrlLength -= HTTP_PREFIX_SIZE;

    //
    // Now check the second half of the absolute URL prefix. We use the larger
    // of the two possible prefix length here to do the check, because even if
    // it's the smaller of the two we'll need the extra bytes after the prefix
    // anyway for the host name.
    //

    if (UrlLength < HTTP_PREFIX2_SIZE)
    {
        pRequest->ErrorCode = UlErrorUrl;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseFullUrl(pRequest = %p) ERROR: no room for URL scheme name\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    if ( (*(UNALIGNED64 ULONG *)pUrlStart & HTTP_PREFIX1_MASK) == HTTP_PREFIX1)
    {
        // Valid absolute URL.
        pUrlStart += HTTP_PREFIX1_SIZE;
        UrlLength -= HTTP_PREFIX1_SIZE;
    }
    else
    {
        if ( (*(UNALIGNED64 ULONG *)pUrlStart & HTTP_PREFIX2_MASK) == HTTP_PREFIX2)
        {
            // Valid absolute URL.
            pUrlStart += HTTP_PREFIX2_SIZE;
            UrlLength -= HTTP_PREFIX2_SIZE;
        }
        else
        {
            pRequest->ErrorCode = UlErrorUrl;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!ParseFullUrl(pRequest = %p) ERROR: invalid URL scheme name\n",
                        pRequest
                        ));

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    //
    // OK, we've got a valid absolute URL, and we've skipped over
    // the prefix part of it. Save a pointer to the host, and
    // search the host string until we find the trailing slash,
    // which signifies the end of the host/start of the absolute
    // path.
    //

    pRequest->RawUrl.pHost = pUrlStart;

    //
    // scan the host looking for the terminator
    //

    while (UrlLength > 0 && pUrlStart[0] != '/')
    {
        pUrlStart++;
        UrlLength--;
    }

    if (UrlLength == 0)
    {
        //
        // Ran out of buffer, can't happen, we get the full url passed in
        //

        pRequest->ErrorCode = UlErrorUrl;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "ul!ParseFullUrl(pRequest = %p) ERROR: end of host name not found\n",
                    pRequest
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Otherwise, pUrlStart points to the start of the absolute path portion.
    //

    pRequest->RawUrl.pAbsPath = pUrlStart;

    return STATUS_SUCCESS;

}   // ParseFullUrl

/*++

Routine Description:

    Look up a header that we don't have in our fast lookup table. This
    could be because it's a header we don't understand, or because we
    couldn't use the fast lookup table due to insufficient buffer length.
    The latter reason is uncommon, but we'll check the input table anyway
    if we're given one. If we find a header match in our mapping table,
    we'll call the header handler. Otherwise we'll try to allocate an
    unknown header element, fill it in and chain it on the http connection.

Arguments:

    pHttpConn           - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderMap          - Pointer to start of an array of header map entries
                            (may be NULL).
    HeaderMapCount      - Number of entries in array pointed to by pHeaderMap.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/
NTSTATUS
UlLookupHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderMap,
    IN  ULONG                   HeaderMapCount,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   CurrentOffset;
    ULONG                   HeaderNameLength;
    ULONG                   i;
    ULONG                   BytesTaken;
    ULONG                   HeaderValueLength;
    UCHAR                   CurrentChar;
    PUL_HTTP_UNKNOWN_HEADER pUnknownHeader;
    PLIST_ENTRY             pListStart;
    PLIST_ENTRY             pCurrentListEntry;
    ULONG                   OldHeaderLength;
    PUCHAR                  pHeaderValue;
    BOOLEAN                 ExternalAllocated;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // First, let's find the terminating : of the header name, if there is one.
    // This will also give us the length of the header, which we can then
    // use to search the header map table if we have one.
    //

    for (CurrentOffset = 0; CurrentOffset < HttpRequestLength; CurrentOffset++)
    {
        CurrentChar = *(pHttpRequest + CurrentOffset);

        if (CurrentChar == ':')
        {
            // We've found the end of the header.
            break;
        }
        else
        {
            if (!IS_HTTP_TOKEN(CurrentChar))
            {
                // Uh-oh, this isn't a valid header. What do we do now?
                //
                pRequest->ErrorCode = UlErrorHeader;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "UlLookupHeader(pRequest = %p) CurrentChar = 0x%x\n"
                            "    ERROR: invalid header char\n",
                            pRequest,
                            CurrentChar
                            ));

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }
        }

    }

    // Find out why we got out. If the current offset is less than the
    // header length, we got out because we found the :.

    if (CurrentOffset < HttpRequestLength)
    {
        // Found the terminator.
        CurrentOffset++;            // Update to point beyond termintor.
        HeaderNameLength = CurrentOffset;
    }
    else
    {
        // Didn't find the :, need more.
        //
        *pBytesTaken = 0;
        goto end;
    }

    // See if we have a header map array we need to search.
    //
    if (pHeaderMap != NULL)
    {
        // We do have an array to search.
        for (i = 0; i < HeaderMapCount; i++)
        {
            ASSERT(pHeaderMap->pServerHandler != NULL);

            if (HeaderNameLength == pHeaderMap->HeaderLength &&
                _strnicmp(
                    (const char *)(pHttpRequest),
                    (const char *)(pHeaderMap->Header.HeaderChar),
                    HeaderNameLength
                    ) == 0  &&
                pHeaderMap->pServerHandler != NULL)
            {
                // This header matches. Call the handling function for it.
                Status = (*(pHeaderMap->pServerHandler))(
                                pRequest,
                                pHttpRequest + HeaderNameLength,
                                HttpRequestLength - HeaderNameLength,
                                pHeaderMap->HeaderID,
                                &BytesTaken
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    goto end;

                // If the handler consumed a non-zero number of bytes, it
                // worked, so return that number plus the header length.

                //
                // BUGBUG - it might be possible for a header handler to
                // encounter an error, for example being unable to
                // allocate memory, or a bad syntax in some header. We
                // need a more sophisticated method to detect this than
                // just checking bytes taken.
                //

                if (BytesTaken != 0)
                {
                    *pBytesTaken = HeaderNameLength + BytesTaken;
                    goto end;
                }

                // Otherwise he didn't take anything, so return 0.
                // we need more buffer
                //
                *pBytesTaken = 0;
                goto end;
            }

            pHeaderMap++;
        }
    }

    // OK, at this point either we had no header map array or none of them
    // matched. We have an unknown header. Just make sure this header is
    // terminated and save a pointer to it.

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pHttpRequest + HeaderNameLength,
                    HttpRequestLength - HeaderNameLength,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken == 0)
    {
        *pBytesTaken = 0;
        goto end;
    }

    //
    // Strip of the trailing CRLF from the header value length
    //

    HeaderValueLength = BytesTaken - CRLF_SIZE;

    pHeaderValue = pHttpRequest + HeaderNameLength;

    //
    // skip any preceding LWS.
    //

    while ( HeaderValueLength > 0 && IS_HTTP_LWS(*pHeaderValue) )
    {
        pHeaderValue++;
        HeaderValueLength--;
    }

    // Have an unknown header. Search our list of unknown headers,
    // and if we've already seen one instance of this header add this
    // on. Otherwise allocate an unknown header structure and set it
    // to point at this header.

    pListStart = &pRequest->UnknownHeaderList;

    for (pCurrentListEntry = pRequest->UnknownHeaderList.Flink;
         pCurrentListEntry != pListStart;
         pCurrentListEntry = pCurrentListEntry->Flink
        )
    {
        pUnknownHeader = CONTAINING_RECORD(
                            pCurrentListEntry,
                            UL_HTTP_UNKNOWN_HEADER,
                            List
                            );

        //
        // somehow HeaderNameLength includes the ':' character,
        // which is not the case of pUnknownHeader->HeaderNameLength.
        //
        // so we need to adjust for this here
        //

        if ((HeaderNameLength-1) == pUnknownHeader->HeaderNameLength &&
            _strnicmp(
                (const char *)(pHttpRequest),
                (const char *)(pUnknownHeader->pHeaderName),
                (HeaderNameLength-1)
                ) == 0)
        {
            // This header matches.

            OldHeaderLength = pUnknownHeader->HeaderValue.HeaderLength;

            Status = UlAppendHeaderValue(
                            pRequest,
                            &pUnknownHeader->HeaderValue,
                            pHeaderValue,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Successfully appended it. Update the total request
            // length for the length added.  no need to add 1 for
            // the terminator, just add our new char count.
            //

            pRequest->TotalRequestSize +=
                (pUnknownHeader->HeaderValue.HeaderLength
                    - OldHeaderLength) * sizeof(CHAR);

            //
            // don't subtract for the ':' character, as that character
            // was "taken"
            //

            *pBytesTaken = HeaderNameLength + BytesTaken;
            goto end;

        }   // if (headermatch)

    }   // for (walk list)

    //
    // Didn't find a match. Allocate a new unknown header structure, set
    // it up and add it to the list.
    //

    if (pRequest->NextUnknownHeaderIndex < DEFAULT_MAX_UNKNOWN_HEADERS)
    {
        ExternalAllocated = FALSE;
        pUnknownHeader = &pRequest->UnknownHeaders[pRequest->NextUnknownHeaderIndex];
        pRequest->NextUnknownHeaderIndex++;
    }
    else
    {
        ExternalAllocated = TRUE;
        pUnknownHeader = UL_ALLOCATE_STRUCT(
                                NonPagedPool,
                                UL_HTTP_UNKNOWN_HEADER,
                                UL_HTTP_UNKNOWN_HEADER_POOL_TAG
                                );

        //
        // Assume the memory allocation will succeed so just blindly set the
        // flag below to TRUE which forces us to take a slow path in
        // UlpFreeHttpRequest.
        //

        pRequest->HeadersAppended = TRUE;
    }

    if (pUnknownHeader == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // subtract the : from the header name length
    //

    pUnknownHeader->HeaderNameLength = HeaderNameLength - 1;
    pUnknownHeader->pHeaderName = pHttpRequest;

    //
    // header value
    //

    pUnknownHeader->HeaderValue.HeaderLength = HeaderValueLength;
    pUnknownHeader->HeaderValue.pHeader = pHeaderValue;

    //
    // null terminate our copy, the terminating CRLF gives
    // us space for this
    //

    pHeaderValue[HeaderValueLength] = ANSI_NULL;

    //
    // flags
    //

    pUnknownHeader->HeaderValue.OurBuffer = 0;
    pUnknownHeader->HeaderValue.ExternalAllocated = ExternalAllocated;

    InsertTailList(&pRequest->UnknownHeaderList, &pUnknownHeader->List);

    pRequest->UnknownHeaderCount++;

    //
    // subtract 1 for the ':' and add space for the 2 terminiators
    //

    pRequest->TotalRequestSize +=
        ((HeaderNameLength - 1 + 1) + HeaderValueLength + 1) * sizeof(CHAR);


    *pBytesTaken = HeaderNameLength + BytesTaken;

end:
    return Status;

}   // UlLookupHeader



/*++

Routine Description:

    The routine to parse an individual header based on a hint. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header based on the hint passed.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.
    pHeaderHintMap      - Hint to the Map that may match the current request

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/

__inline
NTSTATUS
UlParseHeaderWithHint(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    IN  PHEADER_MAP_ENTRY       pHeaderHintMap,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    ULONG               i;
    ULONG               j;

    ASSERT(pHeaderHintMap != NULL);

    if (HttpRequestLength >= pHeaderHintMap->MinBytesNeeded)
    {
        for (j = 0; j < pHeaderHintMap->ArrayCount; j++)
        {
            Temp = *(UNALIGNED64 ULONGLONG *)(pHttpRequest +
                                    (j * sizeof(ULONGLONG)));

            if ((Temp & pHeaderHintMap->HeaderMask[j]) !=
                pHeaderHintMap->Header.HeaderLong[j] )
            {
                break;
            }
        }

        // See why we exited out.
        if (j == pHeaderHintMap->ArrayCount &&
            pHeaderHintMap->pServerHandler != NULL)
        {
            // Exited because we found a match. Call the
            // handler for this header to take cake of this.

            Status = (*(pHeaderHintMap->pServerHandler))(
                            pRequest,
                            pHttpRequest +
                             pHeaderHintMap->HeaderLength,
                            HttpRequestLength -
                             pHeaderHintMap->HeaderLength,
                            pHeaderHintMap->HeaderID,
                            &BytesTaken
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            // If the handler consumed a non-zero number of
            // bytes, it worked, so return that number plus
            // the header length.


            if (BytesTaken != 0)
            {
                *pBytesTaken = pHeaderHintMap->HeaderLength +
                                    BytesTaken;
                goto end;
            }

            // Otherwise need more buffer

            *pBytesTaken = 0;
        }
        else
        {
            // No match

            *pBytesTaken = -1;
        }
    }
    else
    {
        // No match

        *pBytesTaken = -1;
    }

end:

    return Status;

} // UlParseHeaderWithHint

/*++

Routine Description:

    The routine to parse an individual header. We take in a pointer to the
    header and the bytes remaining in the request, and try to find
    the header in our lookup table. We try first the fast way, and then
    try again the slow way in case there wasn't quite enough data the first
    time.

    On input, HttpRequestLength is at least CRLF_SIZE.

Arguments:

    pRequest            - Pointer to the current connection on which the
                            request arrived.
    pHttpRequest        - Pointer to the current request.
    HttpRequestLength   - Bytes left in the request.

Return Value:

    Number of bytes in the header (including CRLF), or 0 if we couldn't
    parse the header.

--*/

NTSTATUS
UlParseHeader(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG  *                pBytesTaken
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    ULONG               i;
    ULONG               j;
    ULONG               BytesTaken;
    ULONGLONG           Temp;
    UCHAR               c;
    PHEADER_MAP_ENTRY   pCurrentHeaderMap;
    ULONG               HeaderMapCount;
    PUL_HTTP_HEADER     pFoundHeader;
    BOOLEAN             SmallHeader = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(HttpRequestLength >= CRLF_SIZE);


    c = *pHttpRequest;

    // message-headers start with field-name [= token]
    //
    if (IS_HTTP_TOKEN(c) == FALSE)
    {
        pRequest->ErrorCode = UlErrorHeader;
        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "UlParseHeader (pRequest = %p) c = 0x%02x ERROR: invalid header char \n",
                    pRequest,
                    c
                    ));

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Does the header start with an alpha?
    //
    if (IS_HTTP_ALPHA(c))
    {
        // Uppercase the character, and find the appropriate set of header map
        // entries.
        //
        c = UPCASE_CHAR(c);

        c -= 'A';

        pCurrentHeaderMap = g_RequestHeaderIndexTable[c].pHeaderMap;
        HeaderMapCount    = g_RequestHeaderIndexTable[c].Count;

        // Loop through all the header map entries that might match
        // this header, and check them. The count will be 0 if there
        // are no entries that might match and we'll skip the loop.

        for (i = 0; i < HeaderMapCount; i++)
        {

            ASSERT(pCurrentHeaderMap->pServerHandler != NULL);

            // If we have enough bytes to do the fast check, do it.
            // Otherwise skip this. We may skip a valid match, but if
            // so we'll catch it later.

            if (HttpRequestLength >= pCurrentHeaderMap->MinBytesNeeded)
            {
                for (j = 0; j < pCurrentHeaderMap->ArrayCount; j++)
                {
                    Temp = *(UNALIGNED64 ULONGLONG *)(pHttpRequest +
                                            (j * sizeof(ULONGLONG)));

                    if ((Temp & pCurrentHeaderMap->HeaderMask[j]) !=
                        pCurrentHeaderMap->Header.HeaderLong[j] )
                    {
                        break;
                    }
                }

                // See why we exited out.
                if (j == pCurrentHeaderMap->ArrayCount &&
                    pCurrentHeaderMap->pServerHandler != NULL)
                {
                    // Exited because we found a match. Call the
                    // handler for this header to take cake of this.

                    Status = (*(pCurrentHeaderMap->pServerHandler))(
                                    pRequest,
                                    pHttpRequest +
                                     pCurrentHeaderMap->HeaderLength,
                                    HttpRequestLength -
                                     pCurrentHeaderMap->HeaderLength,
                                    pCurrentHeaderMap->HeaderID,
                                    &BytesTaken
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;

                    // If the handler consumed a non-zero number of
                    // bytes, it worked, so return that number plus
                    // the header length.


                    if (BytesTaken != 0)
                    {
                        *pBytesTaken = pCurrentHeaderMap->HeaderLength +
                                            BytesTaken;
                        goto end;
                    }

                    // Otherwise need more buffer
                    //
                    *pBytesTaken = 0;
                    goto end;
                }

                // If we get here, we exited out early because a match
                // failed, so keep going.
            }
            else if (SmallHeader == FALSE)
            {
                //
                // Remember that we didn't check a header map entry
                // because the bytes in the buffer was not LONGLONG
                // aligned
                //
                SmallHeader = TRUE;
            }

            // Either didn't match or didn't have enough bytes for the
            // check. In either case, check the next header map entry.

            pCurrentHeaderMap++;
        }

        // Got all the way through the appropriate header map entries
        // without a match. This could be because we're dealing with a
        // header we don't know about or because it's a header we
        // care about that was too small to do the fast check. The
        // latter case should be very rare, but we still need to
        // handle it.

        // Update the current header map pointer to point back to the
        // first of the possibles. If there were no possibles,
        // the pointer will be NULL and the HeaderMapCount 0, so it'll
        // stay NULL. Otherwise the subtraction will back it up the
        // appropriate amount.

        if (SmallHeader)
        {
            pCurrentHeaderMap -= HeaderMapCount;
        }
        else
        {
            pCurrentHeaderMap = NULL;
            HeaderMapCount = 0;
        }

    }
    else
    {
        pCurrentHeaderMap = NULL;
        HeaderMapCount = 0;
    }

    // At this point either the header starts with a non-alphabetic
    // character or we don't have a set of header map entries for it.

    Status = UlLookupHeader(
                    pRequest,
                    pHttpRequest,
                    HttpRequestLength,
                    pCurrentHeaderMap,
                    HeaderMapCount,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    // Lookup header returns the total bytes taken, including the header name
    //
    *pBytesTaken = BytesTaken;

end:

    return Status;

}   // UlParseHeader

NTSTATUS
UlParseHeaders(
    PUL_INTERNAL_REQUEST pRequest,
    PUCHAR pBuffer,
    ULONG BufferLength,
    PULONG pBytesTaken
    )
{
    NTSTATUS            Status;
    ULONG               BytesTaken;
    LONG                HintIndex;
    PHEADER_MAP_ENTRY   pHeaderHintMap;

    *pBytesTaken = 0;

    HintIndex = 0;

    //
    // loop over all headers
    //

    while (BufferLength >= CRLF_SIZE)
    {

        //
        // If this is an empty header, we're done with this stage
        //

        if (*(UNALIGNED64 USHORT *)pBuffer == CRLF ||
            *(UNALIGNED64 USHORT *)pBuffer == LFLF)
        {

            //
            // consume it
            //

            pBuffer += CRLF_SIZE;
            *pBytesTaken += CRLF_SIZE;
            BufferLength -= CRLF_SIZE;

            Status = STATUS_SUCCESS;
            goto end;
        }

        // Otherwise call our header parse routine to deal with this.


        //
        // Try to find a header hint based on the first char and certain order
        //

        pHeaderHintMap = NULL;

        while (1)
        {
            if (
                (HintIndex >= 0) &&
                (HintIndex < NUMBER_HEADER_HINT_INDICIES) &&
                (g_RequestHeaderHintIndexTable[HintIndex].c == UPCASE_CHAR(*pBuffer))
               )
            {

                pHeaderHintMap = g_RequestHeaderHintIndexTable[HintIndex].pHeaderMap;

                break;
            }


            if (HintIndex >= NUMBER_HEADER_HINT_INDICIES)
            {
                break;
            }

            ++HintIndex;

        }

        if (NULL != pHeaderHintMap)
        {
            Status = UlParseHeaderWithHint(
                            pRequest,
                            pBuffer,
                            BufferLength,
                            pHeaderHintMap,
                            &BytesTaken
                            );

            if (-1 == BytesTaken)
            {
                // hint failed

                Status = UlParseHeader(
                                pRequest,
                                pBuffer,
                                BufferLength,
                                &BytesTaken
                                );
            }

        }
        else
        {

            Status = UlParseHeader(
                            pRequest,
                            pBuffer,
                            BufferLength,
                            &BytesTaken
                            );
        }

        if (NT_SUCCESS(Status) == FALSE)
            goto end;

        //
        // Check if the parsed headers are longer than maximum allowed.
        //

        if ( (*pBytesTaken+BytesTaken) > g_UlMaxFieldLength )
        {
            pRequest->ErrorCode  = UlErrorFieldLength;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                    "UlParseHeaders(pRequest = %p) ERROR: Header field is too big\n",
                    pRequest
                    ));

            Status = STATUS_SECTION_TOO_BIG;
            goto end;
        }

        //
        // If no bytes were consumed, the header must be incomplete, so
        // bail out until we get more data on this connection.
        //

        if (BytesTaken == 0)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // Otherwise we parsed a header, so update and continue.
        //

        pBuffer += BytesTaken;
        *pBytesTaken += BytesTaken;
        BufferLength -= BytesTaken;

        ++HintIndex;
    }

    //
    // we only get here if we didn't see the CRLF headers terminator
    //
    // we need more data
    //

    Status = STATUS_MORE_PROCESSING_REQUIRED;

end:

    //
    // Terminate the header index table when we are done with parsing headers.
    //

    pRequest->HeaderIndex[pRequest->HeaderCount] = HttpHeaderRequestMaximum;

    return Status;

}    // UlParseHeaders

NTSTATUS
UlParseChunkLength(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesTaken,
    OUT PULONGLONG pChunkLength
    )
{
    NTSTATUS Status;
    PUCHAR  pToken;
    UCHAR   SaveChar;
    ULONG   TokenLength;
    ULONG   BytesTaken;
    ULONG   TotalBytesTaken = 0;

    ASSERT(pBytesTaken != NULL);
    ASSERT(pChunkLength != NULL);

    //
    // 2 cases:
    //
    //  1) the first chunk where the length follows the headers
    //  2) subsequent chunks where the length follows a previous chunk
    //
    // in case 1 pBuffer will point straight to the chunk length.
    //
    // in case 2 pBuffer will point to the CRLF that terminated the previous
    // chunk, this needs to be consumed, skipped, and then the chunk length
    // read.

    //
    // BUGBUG: need to handle chunk-extensions embedded in the length field
    //


    //
    // if we are case 2 (see above)
    //

    if (pRequest->ParsedFirstChunk == 1)
    {
        //
        // make sure there is enough space first
        //

        if (BufferLength < CRLF_SIZE)
        {
            Status = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // now it better be a terminator
        //

        if (*(UNALIGNED64 USHORT *)pBuffer != CRLF &&
            *(UNALIGNED64 USHORT *)pBuffer != LFLF)
        {
            UlTrace(PARSER, (
                "http!UlParseChunkLength(pRequest = %p) "
                "ERROR: No CRLF at the end of chunk-data\n",
                pRequest
                ));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        //
        // update our book-keeping
        //

        pBuffer += CRLF_SIZE;
        TotalBytesTaken += CRLF_SIZE;
        BufferLength -= CRLF_SIZE;
    }

    pToken = FindWSToken(pBuffer, BufferLength, &TokenLength);
    if (pToken == NULL)
    {
        //
        // not enough buffer
        //

        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;

    }

    //
    // Was there any token ?
    //

    if (TokenLength == 0)
    {
        UlTrace(PARSER, (
            "http!UlParseChunkLength(pRequest = %p) ERROR: No length!\n",
            pRequest
            ));

        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // Add the bytes consumed by FindWSToken
    // (the token bytes plus preceding bytes)
    //

    TotalBytesTaken += DIFF((pToken + TokenLength) - pBuffer);

    //
    // and find the end
    //

    Status = FindChunkHeaderEnd(
                    pToken + TokenLength,
                    BufferLength - DIFF((pToken + TokenLength) - pBuffer),
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        pRequest->ErrorCode = UlErrorCRLF;
        pRequest->ParseState = ParseErrorState;
        goto end;
    }

    if (BytesTaken == 0)
    {
        Status = STATUS_MORE_PROCESSING_REQUIRED;
        goto end;
    }

    TotalBytesTaken += BytesTaken;

    //
    // now update the HTTP_REQUEST
    //

    SaveChar = pToken[TokenLength];
    pToken[TokenLength] = ANSI_NULL;

    Status = UlAnsiToULongLong(
                    pToken,
                    16,                             // Base
                    pChunkLength
                    );

    pToken[TokenLength] = SaveChar;

    UlTrace(PARSER, (
        "http!UlParseChunkLength(pRequest = %p) %sfirst chunk=0x%I64x bytes, "
        "consumed %d bytes\n",
        pRequest,
        (pRequest->ParsedFirstChunk == 1) ? "non-" : "",
        *pChunkLength,
        TotalBytesTaken
        ));

    //
    // Did the number conversion fail ?
    //

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (Status == STATUS_SECTION_TOO_BIG)
        {
            pRequest->ErrorCode = UlErrorEntityTooLarge;
        }
        else
        {
            pRequest->ErrorCode = UlErrorNum;
        }

        pRequest->ParseState = ParseErrorState;

        UlTrace(PARSER, (
                    "http!UlParseChunkLength(pRequest = %p) "
                    "ERROR: didn't grok chunk length\n",
                    pRequest
                    ));

        goto end;
    }

    //
    // all done, return the bytes consumed
    //

    *pBytesTaken = TotalBytesTaken;

end:

    RETURN(Status);

}   // UlParseChunkLength

/*++

Routine Description:

    This is the core HTTP protocol request engine. It takes a stream of bytes
    and parses them as an HTTP request.

Arguments:

    pHttpRequest        - Pointer to the incoming HTTP request.
    HttpRequestLength   - Length of data pointed to by HttpRequest.

Return Value:

    Status of parse attempt.

--*/
NTSTATUS
UlParseHttp(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG *                 pBytesTaken
    )

{
    ULONG           OriginalBufferLength;
    ULONG           TokenLength;
    ULONG           CurrentBytesTaken;
    ULONG           TotalBytesTaken;
    ULONG           i;
    NTSTATUS        ReturnStatus;
    PUCHAR          pStart;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );

    ReturnStatus = STATUS_SUCCESS;
    TotalBytesTaken = 0;

    //
    // remember the original buffer length
    //

    OriginalBufferLength = HttpRequestLength;

    //
    // put this label here to allow for a manual re-pump of the
    // parser.  this is currently used for 0.9 requests.
    //

parse_it:

    //
    // what state are we in ?
    //

    switch (pRequest->ParseState)
    {
    case ParseVerbState:

        // Look through the fast verb table for the verb. We can only do
        // this if the input data is big enough.
        if (HttpRequestLength >= sizeof(ULONGLONG))
        {
            ULONGLONG   RawInputVerb;

            RawInputVerb = *(UNALIGNED64 ULONGLONG *)pHttpRequest;

            // Loop through the fast verb table, looking for the verb.
            for (i = 0; i < NUMBER_FAST_VERB_ENTRIES;i++)
            {
                // Mask out the raw input verb and compare against this
                // entry.

                if ((RawInputVerb & FastVerbTable[i].RawVerbMask) ==
                    FastVerbTable[i].RawVerb.LongLong)
                {
                    // It matched. Save the translated verb from the
                    // table, update the request pointer and length,
                    // switch states and get out.

                    pRequest->Verb = FastVerbTable[i].TranslatedVerb;
                    CurrentBytesTaken = FastVerbTable[i].RawVerbLength;

                    pRequest->ParseState = ParseUrlState;
                    break;
                }
            }
        }

        if (pRequest->ParseState != ParseUrlState)
        {
            // Didn't switch states yet, because we haven't found the
            // verb yet. This could be because a) the incoming request
            // was too small to allow us to use our fast lookup (which
            // might be OK in an HTTP/0.9 request), or b) the incoming
            // verb is a PROPFIND or such that is too big to fit into
            // our fast find table, or c) this is an unknown verb, or
            // d) there was leading white-space before the verb.
            // In any of these cases call our slower verb parser to try
            // again.

            ReturnStatus = LookupVerb(
                                pRequest,
                                pHttpRequest,
                                HttpRequestLength,
                                &CurrentBytesTaken
                                );

            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            if (CurrentBytesTaken == 0)
            {
                ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
                goto end;
            }

            //
            // we finished parsing the custom verb
            //

            pRequest->ParseState = ParseUrlState;

        }

        //
        // now fall through to ParseUrlState
        //

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

    case ParseUrlState:

        //
        // We're parsing the URL. pHTTPRequest points to the incoming URL,
        // HttpRequestLength is the length of this request that is left.
        //

        //
        // Find the WS terminating the URL.
        //

        pRequest->RawUrl.pUrl = FindWSToken(
                                    pHttpRequest,
                                    HttpRequestLength,
                                    &TokenLength
                                    );

        if (pRequest->RawUrl.pUrl == NULL)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        if (TokenLength > g_UlMaxFieldLength)
        {
            //
            // The URL is longer than maximum allowed size
            //

            pRequest->ErrorCode  = UlErrorUrlLength;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                    "UlParseHttp(pRequest = %p) ERROR: URL is too big\n",
                    pRequest
                    ));

            ReturnStatus = STATUS_SECTION_TOO_BIG;
            goto end;
        }

        //
        // Bytes taken includes WS in front of URL
        //
        CurrentBytesTaken = DIFF(pRequest->RawUrl.pUrl - pHttpRequest) + TokenLength;

        //
        // set url length
        //

        pRequest->RawUrl.Length = TokenLength;

        //
        // Now, let's see if this is an absolute URL.
        //

        // BUGBUG: this is not case-insens.

        if (pRequest->RawUrl.Length >= HTTP_PREFIX_SIZE &&
            (*(UNALIGNED64 ULONG *)pRequest->RawUrl.pUrl & HTTP_PREFIX_MASK) ==
                HTTP_PREFIX)
        {
            //
            // It is.  let's parse it and find the host.
            //

            ReturnStatus = ParseFullUrl(pRequest);
            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;
        }
        else
        {
            pRequest->RawUrl.pHost  = NULL;
            pRequest->RawUrl.pAbsPath = pRequest->RawUrl.pUrl;
        }

        //
        // count the space it needs in the user's buffer, including terminator.
        //

        pRequest->TotalRequestSize +=
            (pRequest->RawUrl.Length + 1) * sizeof(CHAR);

        //
        // adjust our book keeping vars
        //

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;

        TotalBytesTaken += CurrentBytesTaken;

        //
        // fall through to parsing the version.
        //

        pRequest->ParseState = ParseVersionState;

    case ParseVersionState:

        //
        // skip lws
        //

        pStart = pHttpRequest;

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // is this a 0.9 request (no version) ?
        //

        if (HttpRequestLength >= CRLF_SIZE)
        {
            if (*(UNALIGNED64 USHORT *)(pHttpRequest) == CRLF ||
                *(UNALIGNED64 USHORT *)(pHttpRequest) == LFLF)
            {
                // This IS a 0.9 request. No need to go any further,
                // since by definition there are no more headers.
                // Just update things and get out.

                TotalBytesTaken += DIFF(pHttpRequest - pStart) + CRLF_SIZE;

                HTTP_SET_VERSION(pRequest->Version, 0, 9);

                //
                // set the state to CookState so that we parse the url
                //

                pRequest->ParseState = ParseCookState;

                //
                // manually restart the parse switch, we changed the
                // parse state
                //

                goto parse_it;
            }
        }

        //
        // do we have enough buffer to strcmp the version?
        //

        if (HttpRequestLength < MIN_VERSION_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        //
        // let's compare it
        //

        if (*(UNALIGNED64 ULONGLONG *)pHttpRequest == HTTP_11_VERSION)
        {
            HTTP_SET_VERSION(pRequest->Version, 1, 1);
            HttpRequestLength -= MIN_VERSION_SIZE;
            pHttpRequest += MIN_VERSION_SIZE;
        }
        else
        {
            ULONG   VersionBytes;

            if (*(UNALIGNED64 ULONGLONG *)pHttpRequest == HTTP_10_VERSION)
            {
                HTTP_SET_VERSION(pRequest->Version, 1, 0);
                HttpRequestLength -= MIN_VERSION_SIZE;
                pHttpRequest += MIN_VERSION_SIZE;
            }
            else if ( 0 != (VersionBytes = UlpParseHttpVersion(
                                            pHttpRequest,
                                            HttpRequestLength,
                                            &pRequest->Version )) )
            {
                pHttpRequest += VersionBytes;
                HttpRequestLength -= VersionBytes;
            }
            else
            {
                // Bad version.

                pRequest->ErrorCode = UlErrorVersion;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "UlParseHttp(pRequest = %p) ERROR: unknown HTTP version\n",
                            pRequest
                            ));


                ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

        }

        //
        // skip lws
        //

        while (HttpRequestLength > 0 && IS_HTTP_LWS(*pHttpRequest))
        {
            pHttpRequest++;
            HttpRequestLength--;
        }

        //
        // Make sure we're terminated on this line.
        //

        if (HttpRequestLength < CRLF_SIZE)
        {
            ReturnStatus = STATUS_MORE_PROCESSING_REQUIRED;
            goto end;
        }

        if (*(UNALIGNED64 USHORT *)pHttpRequest != CRLF && *(UNALIGNED64 USHORT *)pHttpRequest != LFLF)
        {
            // Bad line termination after successfully grabbing version.

            pRequest->ErrorCode = UlError;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "UlParseHttp(pRequest = %p) ERROR: HTTP version not terminated correctly\n",
                        pRequest
                        ));

            ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }

        pHttpRequest += CRLF_SIZE;
        HttpRequestLength -= CRLF_SIZE;

        TotalBytesTaken += DIFF(pHttpRequest - pStart);

        //
        // Fall through to parsing the headers
        //

        pRequest->ParseState = ParseHeadersState;

    case ParseHeadersState:

        ReturnStatus = UlParseHeaders(
                            pRequest,
                            pHttpRequest,
                            HttpRequestLength,
                            &CurrentBytesTaken
                            );

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

        if (NT_SUCCESS(ReturnStatus) == FALSE)
            goto end;

        //
        // fall through, this is the only way to get here, we never return
        // pending in this state
        //

        pRequest->ParseState = ParseCookState;

    case ParseCookState:

        //
        // time for post processing.  cook it up!
        //

        {
            //
            // First cook up the url, unicode it + such.
            //

            ReturnStatus = UlpCookUrl(pRequest);
            if (NT_SUCCESS(ReturnStatus) == FALSE)
                goto end;

            //
            // mark if we are chunk encoded (only possible for 1.1)
            //

            if ((HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1)) &&
                (pRequest->HeaderValid[HttpHeaderTransferEncoding]))
            {
                ASSERT(pRequest->Headers[HttpHeaderTransferEncoding].pHeader != NULL);

                //
                // CODEWORK, there can be more than 1 encoding
                //

                if (_stricmp(
                        (const char *)(
                            pRequest->Headers[HttpHeaderTransferEncoding].pHeader
                            ),
                        "chunked"
                        ) == 0)
                {
                    pRequest->Chunked = 1;
                }
                else
                {
                    //
                    // CODEWORK: temp hack for bug#352
                    //

                    UlTrace(PARSER, (
                                "UlParseHttp(pRequest = %p)"
                                    " ERROR: unknown Transfer-Encoding!\n",
                                pRequest
                                ));

                    pRequest->ErrorCode = UlErrorNotImplemented;
                    pRequest->ParseState = ParseErrorState;

                    ReturnStatus = STATUS_INVALID_DEVICE_REQUEST;
                    goto end;
                }
            }

            //
            // Now let's decode the content length header
            //

            if (pRequest->HeaderValid[HttpHeaderContentLength])
            {
                ASSERT(pRequest->Headers[HttpHeaderContentLength].pHeader != NULL);

                ReturnStatus = UlAnsiToULongLong(
                                    pRequest->Headers[HttpHeaderContentLength].pHeader,
                                    10,
                                    &pRequest->ContentLength
                                    );

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                {
                    if (ReturnStatus == STATUS_SECTION_TOO_BIG)
                    {
                        pRequest->ErrorCode = UlErrorEntityTooLarge;
                    }
                    else
                    {
                        pRequest->ErrorCode = UlErrorNum;
                    }

                    pRequest->ParseState = ParseErrorState;

                    UlTrace(PARSER, (
                                "UlParseHttp(pRequest = %p) ERROR: couldn't decode Content-Length\n",
                                pRequest
                                ));

                    goto end;
                }

                if (pRequest->Chunked == 0)
                {
                    //
                    // prime the first (and only) chunk size
                    //

                    pRequest->ChunkBytesToParse = pRequest->ContentLength;
                    pRequest->ChunkBytesToRead = pRequest->ContentLength;
                }

            }

        }

        pRequest->ParseState = ParseEntityBodyState;

        //
        // fall through
        //

    case ParseEntityBodyState:

        //
        // the only parsing we do here is chunk length calculation,
        // and that is not necessary if we have no more bytes to parse
        //

        if (pRequest->ChunkBytesToParse == 0)
        {
            //
            // no more bytes left to parse, let's see if there are any
            // more in the request
            //

            if (pRequest->Chunked == 1)
            {

                //
                // the request is chunk encoded
                //

                //
                // attempt to read the size of the next chunk
                //

                ReturnStatus = UlParseChunkLength(
                                    pRequest,
                                    pHttpRequest,
                                    HttpRequestLength,
                                    &CurrentBytesTaken,
                                    &(pRequest->ChunkBytesToParse)
                                    );

                UlTraceVerbose(PARSER, (
                    "http!UlParseHttp(pRequest = %p): Status = 0x%x. "
                    "chunk length: %d bytes taken, 0x%I64x bytes to parse.\n",
                    pRequest, ReturnStatus, CurrentBytesTaken,
                    pRequest->ChunkBytesToParse
                    ));

                if (NT_SUCCESS(ReturnStatus) == FALSE)
                    goto end;

                //
                // Otherwise we parsed it, so update and continue.
                //

                pHttpRequest += CurrentBytesTaken;
                TotalBytesTaken += CurrentBytesTaken;
                HttpRequestLength -= CurrentBytesTaken;

                //
                // was this the first chunk?
                //

                if (pRequest->ParsedFirstChunk == 0)
                {
                    //
                    // Prime the reader, let it read the first chunk
                    // even though we haven't quite parsed it yet....
                    //

                    UlTraceVerbose(PARSER, (
                        "UlParseHttp (pRequest=%p) first-chunk seen\n",
                        pRequest
                        ));

                    pRequest->ChunkBytesToRead = pRequest->ChunkBytesToParse;

                    pRequest->ParsedFirstChunk = 1;

                }

                //
                // is this the last chunk (denoted with a 0 byte chunk)?
                //

                if (pRequest->ChunkBytesToParse == 0)
                {
                    //
                    // time to parse the trailer
                    //

                    UlTraceVerbose(PARSER, (
                        "UlParseHttp (pRequest=%p) last-chunk seen\n",
                        pRequest
                        ));

                    pRequest->ParseState = ParseTrailerState;

                }

            }
            else    // if (pRequest->Chunked == 1)
            {
                //
                // not chunk-encoded , all done
                //

                UlTraceVerbose(PARSER, (
                    "UlParseHttp (pRequest=%p) State: EntityBody->Done\n",
                    pRequest
                    ));

                pRequest->ParseState = ParseDoneState;
            }

        }   // if (pRequest->ChunkBytesToParse == 0)

        else
        {
            UlTraceVerbose(PARSER, (
                "UlParseHttp (pRequest=%p) State: EntityBody, "
                "ChunkBytesToParse=0x%I64x.\n",
                pRequest, pRequest->ChunkBytesToParse
                ));
        }
        //
        // looks all good
        //

        if (pRequest->ParseState != ParseTrailerState)
        {
            break;
        }

        //
        // fall through
        //


    case ParseTrailerState:

        //
        // parse any existing trailer
        //
        // ParseHeaders will bail immediately if CRLF is
        // next in the buffer (no trailer)
        //

        ReturnStatus = UlParseHeaders(
                            pRequest,
                            pHttpRequest,
                            HttpRequestLength,
                            &CurrentBytesTaken
                            );

        pHttpRequest += CurrentBytesTaken;
        HttpRequestLength -= CurrentBytesTaken;
        TotalBytesTaken += CurrentBytesTaken;

        if (NT_SUCCESS(ReturnStatus) == FALSE)
            goto end;

        //
        // all done
        //

        UlTrace(PARSER, (
            "UlParseHttp (pRequest=%p) State: Trailer->Done\n",
            pRequest
            ));

        pRequest->ParseState = ParseDoneState;

        break;

    default:
        //
        // this should never happen!
        //
        ASSERT(! "Unhandled ParseState");
        break;

    }   // switch (pRequest->ParseState)

end:
    *pBytesTaken = TotalBytesTaken;

    if (ReturnStatus == STATUS_MORE_PROCESSING_REQUIRED &&
        TotalBytesTaken == OriginalBufferLength)
    {
        //
        // convert this to success, we consumed the entire buffer
        //

        ReturnStatus = STATUS_SUCCESS;
    }

    UlTrace(PARSER, (
        "UlParseHttp returning 0x%x, (%p)->ParseState = %d, bytesTaken = %d\n",
        ReturnStatus,
        pRequest,
        pRequest->ParseState,
        TotalBytesTaken
        ));

    return ReturnStatus;
}   // UlParseHttp

/*++

Routine Description:

    Routine to initialize the parse code.

Arguments:


Return Value:


--*/
NTSTATUS
InitializeParser(
    VOID
    )
{
    ULONG               i;
    ULONG               j;
    PHEADER_MAP_ENTRY   pHeaderMap;
    PHEADER_INDEX_ENTRY pHeaderIndex;
    UCHAR               c;

    //
    // Make sure the entire table starts life as zero
    //

    RtlZeroMemory(
            &g_RequestHeaderIndexTable,
            sizeof(g_RequestHeaderIndexTable)
            );

    RtlZeroMemory(
            &g_ResponseHeaderIndexTable,
            sizeof(g_ResponseHeaderIndexTable)
            );

    RtlZeroMemory(
            &g_RequestHeaderHintIndexTable,
            sizeof(g_RequestHeaderHintIndexTable)
            );

    for (i = 0; i < NUMBER_REQUEST_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &g_RequestHeaderMapTable[i];

        //
        // Map the header to upper-case.
        //

        for (j = 0 ; j < pHeaderMap->HeaderLength ; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];

            if ((c >= 'a') && (c <= 'z'))
            {
                pHeaderMap->Header.HeaderChar[j] = c - ('a' - 'A');
            }
        }

        ASSERT(pHeaderMap->pServerHandler != NULL);

        c = pHeaderMap->Header.HeaderChar[0];

        pHeaderIndex = &g_RequestHeaderIndexTable[c - 'A'];

        if (pHeaderIndex->pHeaderMap == NULL)
        {
            pHeaderIndex->pHeaderMap = pHeaderMap;
            pHeaderIndex->Count = 1;
        }
        else
        {
            pHeaderIndex->Count++;
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] = CREATE_HEADER_MASK(
                                            pHeaderMap->HeaderLength,
                                            sizeof(ULONGLONG) * (j+1)
                                            );
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

        //
        // setup the mapping from header id to map table index
        //

        g_RequestHeaderMap[pHeaderMap->HeaderID] = i;

        //
        // Save the Header Map and first char in the hint table if the entry is part of the hints
        //

        if ((pHeaderMap->HintIndex >= 0) && (pHeaderMap->HintIndex < NUMBER_HEADER_HINT_INDICIES))
        {

            g_RequestHeaderHintIndexTable[pHeaderMap->HintIndex].pHeaderMap = pHeaderMap;
            g_RequestHeaderHintIndexTable[pHeaderMap->HintIndex].c          = pHeaderMap->Header.HeaderChar[0];

        }
    }

    for (i = 0; i < NUMBER_RESPONSE_HEADER_MAP_ENTRIES;i++)
    {
        pHeaderMap = &g_ResponseHeaderMapTable[i];

        //
        // Map the header to upper-case.
        //

        for (j = 0 ; j < pHeaderMap->HeaderLength ; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];

            if ((c >= 'a') && (c <= 'z'))
            {
                pHeaderMap->Header.HeaderChar[j] = c - ('a' - 'A');
            }
        }

        ASSERT(pHeaderMap->pClientHandler == NULL);

        c = pHeaderMap->Header.HeaderChar[0];
        pHeaderIndex = &g_ResponseHeaderIndexTable[c - 'A'];

        if (pHeaderIndex->pHeaderMap == NULL)
        {
            pHeaderIndex->pHeaderMap = pHeaderMap;
            pHeaderIndex->Count = 1;
        }
        else
        {
            pHeaderIndex->Count++;
        }

        // Now go through the mask fields for this header map structure and
        // initialize them. We set them to default values first, and then
        // go through the header itself and convert the mask for any
        // non-alphabetic characters.

        for (j = 0; j < MAX_HEADER_LONG_COUNT; j++)
        {
            pHeaderMap->HeaderMask[j] = CREATE_HEADER_MASK(
                                            pHeaderMap->HeaderLength,
                                            sizeof(ULONGLONG) * (j+1)
                                            );
        }

        for (j = 0; j < pHeaderMap->HeaderLength; j++)
        {
            c = pHeaderMap->Header.HeaderChar[j];
            if (c < 'A' || c > 'Z')
            {
                pHeaderMap->HeaderMask[j/sizeof(ULONGLONG)] |=
                    (ULONGLONG)0xff << ((j % sizeof(ULONGLONG)) * (ULONGLONG)8);
            }
        }

        //
        // setup the mapping from header id to map table index
        //

        g_ResponseHeaderMap[pHeaderMap->HeaderID] = i;

    }

    return STATUS_SUCCESS;

}   // InitializeParser


ULONG
UlpFormatPort(
    OUT PWSTR pString,
    IN ULONG Port
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    ULONG digit;
    ULONG length;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Fast-path common ports. While we're at it, special case port 0,
    // which is definitely not common, but handling it specially makes
    // the general conversion code a bit simpler.
    //

    switch (Port)
    {
    case 0:
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 1;

    case 80:
        *pString++ = L'8';
        *pString++ = L'0';
        *pString = UNICODE_NULL;
        return 2;

    case 443:
        *pString++ = L'4';
        *pString++ = L'4';
        *pString++ = L'3';
        *pString = UNICODE_NULL;
        return 3;
    }

    //
    // Pull the least signifigant digits off the port value and store them
    // into the pString. Note that this will store the digits in reverse
    // order.
    //

    p1 = p2 = pString;

    while (Port != 0)
    {
        digit = Port % 10;
        Port = Port / 10;

        *p1++ = L'0' + (WCHAR)digit;
    }

    length = DIFF(p1 - pString);

    //
    // Reverse the digits in the pString.
    //

    *p1-- = UNICODE_NULL;

    while (p1 > p2)
    {
        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;
    }

    return length;

}   // UlpFormatPort


ULONG
HostAddressAndPortToString(
    PCHAR  IpAddressString,
    ULONG  IpAddress,
    USHORT IpPortNum
    )
{
    PCHAR psz = IpAddressString;

    psz = UlStrPrintUlong(psz, (IpAddress >> 24) & 0xFF, '.');
    psz = UlStrPrintUlong(psz, (IpAddress >> 16) & 0xFF, '.');
    psz = UlStrPrintUlong(psz, (IpAddress >>  8) & 0xFF, '.');
    psz = UlStrPrintUlong(psz, (IpAddress >>  0) & 0xFF, ':');
    psz = UlStrPrintUlong(psz, IpPortNum,                '\0');

    return DIFF(psz - IpAddressString);
}



NTSTATUS
UlpCookUrl(
    PUL_INTERNAL_REQUEST pRequest
    )
{
    NTSTATUS    Status;
    PUCHAR      pHost;
    ULONG       HostLength;
    PUCHAR      pAbsPath;
    ULONG       AbsPathLength;
    ULONG       UrlLength;
    ULONG       PortLength;
    ULONG       LengthCopied;
    PWSTR       pUrl = NULL;
    PWSTR       pCurrent;
    ULONG       Index;
    BOOLEAN     PortInUrl;
    CHAR        IpAddressString[MAX_ADDRESS_LENGTH+1];
    USHORT      IpPortNum;
    BOOLEAN     HostFromTransport = FALSE;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // We must have already parsed the entire headers + such
    //

    if (pRequest->ParseState < ParseCookState)
        return STATUS_INVALID_DEVICE_STATE;

    //
    // better have an absolute url .
    //

    if (pRequest->RawUrl.pAbsPath[0] != '/')
    {

        //
        // allow * for Verb = OPTIONS
        //

        if (pRequest->RawUrl.pAbsPath[0] == '*' &&
            pRequest->Verb == HttpVerbOPTIONS)
        {
            // ok
        }
        else
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
    }

    //
    // collect the host + abspath sections
    //

    if (pRequest->RawUrl.pHost != NULL)
    {
        pHost = pRequest->RawUrl.pHost;
        HostLength = DIFF(pRequest->RawUrl.pAbsPath - pRequest->RawUrl.pHost);

        pAbsPath = pRequest->RawUrl.pAbsPath;
        AbsPathLength = pRequest->RawUrl.Length - DIFF(pAbsPath - pRequest->RawUrl.pUrl);

    }
    else
    {
        pHost = NULL;
        HostLength = 0;

        pAbsPath = pRequest->RawUrl.pAbsPath;
        AbsPathLength = pRequest->RawUrl.Length;
    }

    //
    // found a host yet?
    //

    if (pHost == NULL)
    {
        //
        // do we have a host header?
        //

        if (pRequest->HeaderValid[HttpHeaderHost] &&
           (pRequest->Headers[HttpHeaderHost].HeaderLength > 0) )
        {
            ASSERT(pRequest->Headers[HttpHeaderHost].pHeader != NULL);

            pHost       = pRequest->Headers[HttpHeaderHost].pHeader;
            HostLength  = pRequest->Headers[HttpHeaderHost].HeaderLength;
        }
        else
        {
            ULONG           CharCopied;
            ULONG           IpAddress;

            //
            // first, if this was a 1.1 client, it's an invalid request
            // to not have a host header, fail it.
            //

            if (HTTP_GREATER_EQUAL_VERSION(pRequest->Version, 1, 1))
            {
                pRequest->ErrorCode = UlErrorHost;
                pRequest->ParseState = ParseErrorState;

                UlTrace(PARSER, (
                            "http!UlpCookUrl(pRequest = %p) ERROR: 1.1 (or greater) request w/o host header\n",
                            pRequest
                            ));

                Status = STATUS_INVALID_DEVICE_REQUEST;
                goto end;
            }

            //
            // get the ip address from the transport
            //

            IpAddress = pRequest->pHttpConn->pConnection->LocalAddress;
            IpPortNum = pRequest->pHttpConn->pConnection->LocalPort;

            //
            // format it into a string
            //

            pHost = (PUCHAR)(IpAddressString);

            HostLength = HostAddressAndPortToString(
                            IpAddressString,
                            IpAddress,
                            IpPortNum);

            ASSERT(HostLength < sizeof(IpAddressString));

            HostFromTransport = TRUE;
            PortInUrl = TRUE;

        }

    }

    if (HostFromTransport == FALSE)
    {

        //
        // is there a port # already there ?
        //

        Index = HostLength;

        while (Index > 0)
        {
            Index -= 1;

            if (pHost[Index] == ':')
                break;

        }

        if (Index == 0)
        {
            PortInUrl = FALSE;

            //
            // no port number, get the port number from the transport
            //
            // we could simply assume port 80 at this point, but some
            // browsers don't sent the port number in the host header
            // even when their supposed to
            //

            IpPortNum = pRequest->pHttpConn->pConnection->LocalPort;

        }
        else
        {
            PortInUrl = TRUE;
        }
    }

    UrlLength = (HTTP_PREFIX_SIZE+HTTP_PREFIX2_SIZE) +
                HostLength +
                (sizeof(":")-1) +
                MAX_PORT_LENGTH +
                AbsPathLength;

    UrlLength *= sizeof(WCHAR);

    //
    // allocate a new buffer to hold this guy
    //

    if (UrlLength > g_UlMaxInternalUrlLength)
    {
        pUrl = UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    WCHAR,
                    (UrlLength/sizeof(WCHAR)) + 1,
                    URL_POOL_TAG
                    );
    }
    else
    {
        pUrl = pRequest->pUrlBuffer;
    }

    if (pUrl == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    pRequest->CookedUrl.pUrl = pCurrent = pUrl;

    //
    // compute the scheme
    //

    if (pRequest->Secure)
    {
        //
        // yep, ssl
        //

        // copy the NULL for the hash function to work
        //
        RtlCopyMemory(pCurrent, L"https://", sizeof(L"https://"));

        pRequest->CookedUrl.Hash     = HashStringNoCaseW(pCurrent, 0);

        pCurrent                    += (sizeof(L"https://")-sizeof(WCHAR)) / sizeof(WCHAR);
        pRequest->CookedUrl.Length   = (sizeof(L"https://")-sizeof(WCHAR));

    }
    else
    {
        //
        // not ssl
        //

        RtlCopyMemory(pCurrent, L"http://", sizeof(L"http://"));

        pRequest->CookedUrl.Hash     = HashStringNoCaseW(pCurrent, 0);

        pCurrent                    += (sizeof(L"http://")-sizeof(WCHAR)) / sizeof(WCHAR);
        pRequest->CookedUrl.Length   = (sizeof(L"http://")-sizeof(WCHAR));

    }

    //
    // assemble the rest of the url
    //

    //
    // host
    //

    Status = UlpCleanAndCopyUrl(
                    HostName,
                    pCurrent,
                    pHost,
                    HostLength,
                    &LengthCopied,
                    NULL,
                    &pRequest->CookedUrl.Hash
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    pRequest->CookedUrl.pHost   = pCurrent;
    pRequest->CookedUrl.Length += LengthCopied;

    pCurrent += LengthCopied / sizeof(WCHAR);


    //
    // port
    //


    if (PortInUrl == FALSE)
    {
        *pCurrent = L':';

        PortLength = UlpFormatPort( pCurrent+1, IpPortNum ) + 1;

        //
        // update the running hash
        //
        pRequest->CookedUrl.Hash = HashStringNoCaseW(pCurrent, pRequest->CookedUrl.Hash);

        pCurrent += PortLength;

        //
        // swprintf returns char not byte count
        //

        pRequest->CookedUrl.Length += PortLength * sizeof(WCHAR);

    }


    // abs_path
    //
    Status = UlpCleanAndCopyUrl(
                    AbsPath,
                    pCurrent,
                    pAbsPath,
                    AbsPathLength,
                    &LengthCopied,
                    &pRequest->CookedUrl.pQueryString,
                    &pRequest->CookedUrl.Hash
                    );

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (STATUS_OBJECT_PATH_INVALID == Status)
        {
            pRequest->ErrorCode  = UlErrorForbiddenUrl;
            pRequest->ParseState = ParseErrorState;
        }
        goto end;
    }

    pRequest->CookedUrl.pAbsPath = pCurrent;
    pRequest->CookedUrl.Length  += LengthCopied;

    ASSERT(pRequest->CookedUrl.Length <= UrlLength);

    //
    // Update pRequest, include space for the terminator
    //

    pRequest->TotalRequestSize += pRequest->CookedUrl.Length + sizeof(WCHAR);

    //
    // let's just make sure the hash is the right value
    //
    ASSERT(pRequest->CookedUrl.Hash
           == HashStringNoCaseW(pRequest->CookedUrl.pUrl, 0));

    //
    // Scramble it
    //

    pRequest->CookedUrl.Hash = HashRandomizeBits(pRequest->CookedUrl.Hash);

    ASSERT(pRequest->CookedUrl.pHost != NULL);
    ASSERT(pRequest->CookedUrl.pAbsPath != NULL);

    //
    // validate the host part of the url
    //

    pCurrent = wcschr(pRequest->CookedUrl.pHost, L':');

    //
    // Check for :
    //
    //      No colon ||
    //
    //      no hostname ||
    //
    //      No colon in the host OR no port number.
    //

    if (pCurrent == NULL ||
        pCurrent == pRequest->CookedUrl.pHost ||
        pCurrent >= (pRequest->CookedUrl.pAbsPath-1))
    {
        //
        // bad.  no colon for the port.
        //
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto end;
    }

    //
    // skip the colon
    //

    pCurrent += 1;

    //
    // now make sure the port number is in good shape
    //

    while (pCurrent < pRequest->CookedUrl.pAbsPath)
    {
        if (IS_HTTP_DIGIT(pCurrent[0]) == FALSE)
        {
            //
            // bad.  non digit.
            //
            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;
        }
        pCurrent += 1;
    }

    Status = STATUS_SUCCESS;

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pUrl != NULL)
        {
            if (pUrl != pRequest->pUrlBuffer)
            {
                UL_FREE_POOL(pUrl, URL_POOL_TAG);
            }

            RtlZeroMemory(&pRequest->CookedUrl, sizeof(pRequest->CookedUrl));
        }

        //
        // has a specific error code been set?
        //

        if (pRequest->ErrorCode == UlError)
        {
            pRequest->ErrorCode = UlErrorUrl;
            pRequest->ParseState = ParseErrorState;
        }

        UlTrace(PARSER, (
                    "ul!UlpCookUrl(pRequest = %p) ERROR: unhappy. Status = 0x%x\n",
                    pRequest,
                    Status
                    ));
    }

    return Status;

}   // UlpCookUrl

NTSTATUS
Unescape(
    IN  PUCHAR pChar,
    OUT PUCHAR pOutChar
    )

{
    UCHAR Result, Digit;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (pChar[0] != '%' ||
        IS_HTTP_HEX(pChar[1]) == FALSE ||
        IS_HTTP_HEX(pChar[2]) == FALSE)
    {
        UlTrace(PARSER, (
                    "ul!Unescape( %c%c%c ) not HTTP_HEX format\n",
                    pChar[0],
                    pChar[1],
                    pChar[2]
                    ));

        return STATUS_OBJECT_PATH_SYNTAX_BAD;
    }

    //
    // HexToChar() inlined
    //

    // uppercase #1
    //
    if (IS_HTTP_ALPHA(pChar[1]))
        Digit = UPCASE_CHAR(pChar[1]);
    else
        Digit = pChar[1];

    Result = ((Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0')) << 4;

    // uppercase #2
    //
    if (IS_HTTP_ALPHA(pChar[2]))
        Digit = UPCASE_CHAR(pChar[2]);
    else
        Digit = pChar[2];

    Result |= (Digit >= 'A') ? (Digit - 'A' + 0xA) : (Digit - '0');

    *pOutChar = Result;

    return STATUS_SUCCESS;

}   // Unescape


//
// PAULMCD(2/99): stolen from iisrtl\string.cxx and incorporated
// and added more comments
//

//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000

//
// Private globals
//

//
// this table says what to do based on the current state and the current
// character
//
ULONG  pActionTable[16] =
{
    //
    // state 0 = fresh, seen nothing exciting yet
    //
    ACTION_EMIT_CH,         // other = emit it                      state = 0
    ACTION_EMIT_CH,         // "."   = emit it                      state = 0
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_EMIT_CH,         // "/"   = we saw the "/", emit it      state = 1

    //
    // state 1 = we saw a "/" !
    //
    ACTION_EMIT_CH,         // other = emit it,                     state = 0
    ACTION_NOTHING,         // "."   = eat it,                      state = 2
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = extra slash, eat it,         state = 1

    //
    // state 2 = we saw a "/" and ate a "." !
    //
    ACTION_EMIT_DOT_CH,     // other = emit the dot we ate.         state = 0
    ACTION_NOTHING,         // "."   = eat it, a ..                 state = 3
    ACTION_NOTHING,         // EOS   = normal finish                state = 4
    ACTION_NOTHING,         // "/"   = we ate a "/./", swallow it   state = 1

    //
    // state 3 = we saw a "/" and ate a ".." !
    //
    ACTION_EMIT_DOT_DOT_CH, // other = emit the "..".               state = 0
    ACTION_EMIT_DOT_DOT_CH, // "."   = 3 dots, emit the ".."        state = 0
    ACTION_BACKUP,          // EOS   = we have a "/..\0", backup!   state = 4
    ACTION_BACKUP           // "/"   = we have a "/../", backup!    state = 1
};

//
// this table says which newstate to be in given the current state and the
// character we saw
//
ULONG  pNextStateTable[16] =
{
    // state 0
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    //  state 1
    0 ,              // other
    2 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 2
    0 ,             // other
    3 ,             // "."
    4 ,             // EOS
    1 ,             // "\"

    // state 3
    0 ,             // other
    0 ,             // "."
    4 ,             // EOS
    1               // "\"
};

//
// this says how to index into pNextStateTable given our current state.
//
// since max states = 4, we calculate the index by multiplying with 4.
//
#define IndexFromState( st)   ( (st) * 4)


/***************************************************************************++

Routine Description:


    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode
    computes the case insensitive hash

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
UlpCleanAndCopyUrl(
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    )
{
    NTSTATUS Status;
    URL_TYPE AnsiUrlType = g_UlEnableDBCS ? UrlTypeDbcs : UrlTypeAnsi;

    if (!g_UlEnableNonUTF8)
    {
        //
        // Only accept UTF-8 URLs.
        //

        Status = UlpCleanAndCopyUrlByType(
                        UrlTypeUtf8,
                        UrlPart,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString,
                        pUrlHash
                        );

    }
    else if (!g_UlFavorDBCS)
    {
        //
        // The URL may be either UTF-8 or ANSI. First
        // try UTF-8, and if that fails go for ANSI.
        //

        Status = UlpCleanAndCopyUrlByType(
                        UrlTypeUtf8,
                        UrlPart,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString,
                        pUrlHash
                        );

        if (!NT_SUCCESS(Status))
        {
            Status = UlpCleanAndCopyUrlByType(
                            AnsiUrlType,
                            UrlPart,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied,
                            ppQueryString,
                            pUrlHash
                            );

        }

    }
    else
    {
        //
        // The URL may be either ANSI or UTF-8. First
        // try the ANSI interpretation, and if that fails
        // go for UTF-8.
        //
        Status = UlpCleanAndCopyUrlByType(
                        AnsiUrlType,
                        UrlPart,
                        pDestination,
                        pSource,
                        SourceLength,
                        pBytesCopied,
                        ppQueryString,
                        pUrlHash
                        );

        if (!NT_SUCCESS(Status))
        {
            Status = UlpCleanAndCopyUrlByType(
                            UrlTypeUtf8,
                            UrlPart,
                            pDestination,
                            pSource,
                            SourceLength,
                            pBytesCopied,
                            ppQueryString,
                            pUrlHash
                            );

        }
    }

    return Status;

}

/***************************************************************************++

Routine Description:

    This function can be told to clean up UTF-8, ANSI, or DBCS URLs.

    Unescape
    Convert backslash to forward slash
    Remove double slashes (empty directiories names) - e.g. // or \\
    Handle /./
    Handle /../
    Convert to unicode
    computes the case insensitive hash

Arguments:


Return Value:

    NTSTATUS - Completion status.


--***************************************************************************/
NTSTATUS
UlpCleanAndCopyUrlByType(
    IN      URL_TYPE    UrlType,
    IN      URL_PART    UrlPart,
    IN OUT  PWSTR       pDestination,
    IN      PUCHAR      pSource,
    IN      ULONG       SourceLength,
    OUT     PULONG      pBytesCopied,
    OUT     PWSTR *     ppQueryString OPTIONAL,
    OUT     PULONG      pUrlHash
    )
{
    NTSTATUS Status;
    PWSTR   pDest;
    PUCHAR  pChar;
    ULONG   CharToSkip;
    UCHAR   Char;
    BOOLEAN HashValid;
    ULONG   UrlHash;
    ULONG   BytesCopied;
    PWSTR   pQueryString;
    ULONG   StateIndex;
    WCHAR   UnicodeChar;
    BOOLEAN MakeCanonical;
    PUSHORT pFastPopChar;

    //
    // Sanity check.
    //

    PAGED_CODE();

//
// a cool local helper macro
//

#define EMIT_CHAR(ch)                                   \
    do {                                                \
        pDest[0] = (ch);                                \
        pDest += 1;                                     \
        BytesCopied += 2;                               \
        if (HashValid)                                  \
            UrlHash = HashCharNoCaseW((ch), UrlHash);   \
    } while (0)


    pDest = pDestination;
    pQueryString = NULL;
    BytesCopied = 0;

    pChar = pSource;
    CharToSkip = 0;

    HashValid = TRUE;
    UrlHash = *pUrlHash;

    StateIndex = 0;

    MakeCanonical = (UrlPart == AbsPath) ? TRUE : FALSE;

    if (UrlType == UrlTypeUtf8 && UrlPart != QueryString)
    {
        pFastPopChar = FastPopChars;
    }
    else
    {
        pFastPopChar = DummyPopChars;
    }

    while (SourceLength > 0)
    {
        //
        // advance !  it's at the top of the loop to enable ANSI_NULL to
        // come through ONCE
        //

        pChar += CharToSkip;
        SourceLength -= CharToSkip;

        //
        // well?  have we hit the end?
        //

        if (SourceLength == 0)
        {
            UnicodeChar = UNICODE_NULL;
        }
        else
        {
            //
            // Nope.  Peek briefly to see if we hit the query string
            //

            if (UrlPart == AbsPath && pChar[0] == '?')
            {
                ASSERT(pQueryString == NULL);

                //
                // remember it's location
                //

                pQueryString = pDest;

                //
                // let it fall through ONCE to the canonical
                // in order to handle a trailing "/.." like
                // "http://foobar:80/foo/bar/..?v=1&v2"
                //

                UnicodeChar = L'?';
                CharToSkip = 1;

                //
                // now we are cleaning the query string
                //

                UrlPart = QueryString;

                //
                // cannot use fast path for PopChar anymore
                //

                pFastPopChar = DummyPopChars;
            }
            else
            {
                USHORT NextUnicodeChar = pFastPopChar[*pChar];

                //
                // Grab the next character. Try to be fast for the
                // normal character case. Otherwise call PopChar.
                //

                if (NextUnicodeChar == 0)
                {
                    Status = PopChar(
                                    UrlType,
                                    UrlPart,
                                    pChar,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    if (NT_SUCCESS(Status) == FALSE)
                        goto end;
                }
                else
                {
#if DBG
                    Status = PopChar(
                                    UrlType,
                                    UrlPart,
                                    pChar,
                                    &UnicodeChar,
                                    &CharToSkip
                                    );

                    ASSERT(NT_SUCCESS(Status));
                    ASSERT(UnicodeChar == NextUnicodeChar);
                    ASSERT(CharToSkip == 1);
#endif
                    UnicodeChar = NextUnicodeChar;
                    CharToSkip = 1;
                }
            }
        }

        if (MakeCanonical)
        {
            //
            // now use the state machine to make it canonical .
            //

            //
            // from the old value of StateIndex, figure out our new base StateIndex
            //
            StateIndex = IndexFromState(pNextStateTable[StateIndex]);

            //
            // did we just hit the query string?  this will only happen once
            // that we take this branch after hitting it, as we stop
            // processing after hitting it.
            //

            if (UrlPart == QueryString)
            {
                //
                // treat this just like we hit a NULL, EOS.
                //

                StateIndex += 2;
            }
            else
            {
                //
                // otherwise based the new state off of the char we
                // just popped.
                //

                switch (UnicodeChar)
                {
                case UNICODE_NULL:      StateIndex += 2;    break;
                case L'.':              StateIndex += 1;    break;
                case L'/':              StateIndex += 3;    break;
                default:                StateIndex += 0;    break;
                }
            }

        }
        else
        {
            StateIndex = (UnicodeChar == UNICODE_NULL) ? 2 : 0;
        }

        //
        //  Perform the action associated with the state.
        //

        switch (pActionTable[StateIndex])
        {
        case ACTION_EMIT_DOT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_DOT_CH:

            EMIT_CHAR(L'.');

            // fall through

        case ACTION_EMIT_CH:

            EMIT_CHAR(UnicodeChar);

            // fall through

        case ACTION_NOTHING:
            break;

        case ACTION_BACKUP:

            //
            // pDest currently points 1 past the last '/'.  backup over it and
            // find the preceding '/', set pDest to 1 past that one.
            //

            //
            // backup to the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest[0] == L'/');

            //
            // are we at the start of the string?  that's bad, can't go back!
            //

            if (pDest == pDestination)
            {
                ASSERT(BytesCopied == 0);

                UlTrace(PARSER, (
                            "ul!UlpCleanAndCopyUrl() Can't back up for ..\n"
                            ));

                Status = STATUS_OBJECT_PATH_INVALID;
                goto end;
            }

            //
            // back up over the '/'
            //

            pDest       -= 1;
            BytesCopied -= 2;

            ASSERT(pDest > pDestination);

            //
            // now find the previous slash
            //

            while (pDest > pDestination && pDest[0] != L'/')
            {
                pDest       -= 1;
                BytesCopied -= 2;
            }

            //
            // we already have a slash, so don't have to store 1.
            //

            ASSERT(pDest[0] == L'/');

            //
            // simply skip it, as if we had emitted it just now
            //

            pDest       += 1;
            BytesCopied += 2;

            //
            // mark our running hash invalid
            //

            HashValid = FALSE;

            break;

        default:
            ASSERT(!"UL!UlpCleanAndCopyUrl: Invalid action code in state table!");
            Status = STATUS_OBJECT_PATH_SYNTAX_BAD;
            goto end;
        }

        //
        // Just hit the query string ?
        //

        if (MakeCanonical && UrlPart == QueryString)
        {
            //
            // Stop canonical processing
            //

            MakeCanonical = FALSE;

            //
            // Need to emit the '?', it wasn't emitted above
            //

            ASSERT(pActionTable[StateIndex] != ACTION_EMIT_CH);

            EMIT_CHAR(L'?');

        }

    }

    //
    // terminate the string, it hasn't been done in the loop
    //

    ASSERT((pDest-1)[0] != UNICODE_NULL);

    pDest[0] = UNICODE_NULL;

    //
    // need to recompute the hash?
    //
    if (HashValid == FALSE)
    {
        //
        // this can happen if we had to backtrack due to /../
        //

        UrlHash = HashStringNoCaseW(pDestination, *pUrlHash);
    }

    *pUrlHash = UrlHash;
    *pBytesCopied = BytesCopied;
    if (ppQueryString != NULL)
    {
        *ppQueryString = pQueryString;
    }

    Status = STATUS_SUCCESS;


end:
    return Status;

}   // UlpCleanAndCopyUrlByType


/***************************************************************************++

Routine Description:

    Figures out how big the fixed headers are. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    Version - HTTP Version of the request: 0.9, 1.0., 1.1

    pUserResponse - the response containing the headers

    pHeaderLength - result: the number of bytes in the fixed headers.

Return Value:

    NTSTATUS - STATUS_SUCCESS or an error code (possibly from an exception)

--***************************************************************************/
NTSTATUS
UlComputeFixedHeaderSize(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    OUT PULONG pHeaderLength
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG HeaderLength = 0;
    ULONG i;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pHeaderLength != NULL);

    if ((pUserResponse == NULL) || (HTTP_EQUAL_VERSION(Version, 0, 9)))
    {
        *pHeaderLength = 0;
        return STATUS_SUCCESS;
    }

    //
    // The pUserResponse is user-mode data and cannot be trusted.
    // Hence the try/except.
    //

    __try
    {
        HeaderLength
            += (VERSION_SIZE +                              // HTTP-Version
                1 +                                         // SP
                3 +                                         // Status-Code
                1 +                                         // SP
                pUserResponse->ReasonLength / sizeof(CHAR) +// Reason-Phrase
                CRLF_SIZE                                   // CRLF
               );

        //
        // Loop through the known headers.
        //
        
        for (i = 0; i < HttpHeaderResponseMaximum; ++i)
        {
            USHORT RawValueLength
                = pUserResponse->Headers.pKnownHeaders[i].RawValueLength;

            // skip some headers we'll generate
            if ((i == HttpHeaderDate) || (i == HttpHeaderConnection)) {
                continue;
            }
            
            if (RawValueLength > 0)
            {
                HeaderLength
                    += (g_ResponseHeaderMapTable[
                            g_ResponseHeaderMap[i]
                            ].HeaderLength +                // Header-Name
                        1 +                                 // SP
                        RawValueLength / sizeof(CHAR) +     // Header-Value
                        CRLF_SIZE                           // CRLF
                       );
            }
        }

        //
        // Include default headers we may need to generate for the application.
        //

        if (pUserResponse->Headers.pKnownHeaders[HttpHeaderServer
                ].RawValueLength == 0)
        {
            HeaderLength += (g_ResponseHeaderMapTable[
                                g_ResponseHeaderMap[HttpHeaderServer]
                                ].HeaderLength +             // Header-Name
                             1 +                             // SP
                             DEFAULT_SERVER_HDR_LENGTH +     // Header-Value
                             CRLF_SIZE                       // CRLF
                            );
        }

        //
        // And the unknown headers (this might throw an exception).
        //
        
                pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;

        if (pUnknownHeaders != NULL)
        {
            for (i = 0 ; i < pUserResponse->Headers.UnknownHeaderCount; ++i)
            {
                USHORT Length;
                
                if (pUnknownHeaders[i].NameLength > 0)
                {
                    HeaderLength += (pUnknownHeaders[i].NameLength /
                                        sizeof(CHAR) +       // Header-Name
                                     1 +                     // ':'
                                     1 +                     // SP
                                     pUnknownHeaders[i].RawValueLength /
                                        sizeof(CHAR) +       // Header-Value
                                     CRLF_SIZE               // CRLF
                                    );
                }
            }
        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
        HeaderLength = 0;
    }

    *pHeaderLength = HeaderLength;

    return Status;

}   // UlComputeFixedHeaderSize


/***************************************************************************++

Routine Description:

    Figures out how big the variable headers are. Variable headers include
    Date and Connection.

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    pRequest - Supplies the request to query.

    ForceDisconnect - Supplies TRUE if we'll be forcing a disconnect
        at the end of the response.

    pContentLengthString - Supplies a header value for an optional
        Content-Length header. If this is the empty string "", then no
        Content-Length header is generated.

    ContentLengthStringLength - Supplies the length of the above string.

    pConnHeader - Receives information on the Connection: header to
        generate.

Return Values:

    The number of bytes in the fixed headers.

--***************************************************************************/
ULONG
UlComputeVariableHeaderSize(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN BOOLEAN ForceDisconnect,
    IN PUCHAR pContentLengthString,
    IN ULONG ContentLengthStringLength,
    OUT PUL_CONN_HDR pConnHeader
    )
{
    ULONG Length;
    PHEADER_MAP_ENTRY pEntry;
    UL_CONN_HDR connHeader;

    //
    // Sanity check.
    //

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pRequest ) );
    ASSERT( pContentLengthString != NULL );
    ASSERT( pConnHeader != NULL );

    //
    // Determine the appropriate connection: header.
    //

    Length = 0;

    connHeader = UlChooseConnectionHeader( pRequest->Version, ForceDisconnect );
    *pConnHeader = connHeader;

    //
    // Date: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderDate]]);
    Length += pEntry->HeaderLength;     // header name
    Length += 1;                        // SP
    Length += DATE_HDR_LENGTH;          // header value
    Length += CRLF_SIZE;                // CRLF

    //
    // Connection: header
    //
    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderConnection]]);

    switch (connHeader) {
    case ConnHdrNone:
        // no header
        break;

    case ConnHdrClose:
        Length += pEntry->HeaderLength;
        Length += 1;
        Length += CONN_CLOSE_HDR_LENGTH;
        Length += CRLF_SIZE;
        break;

    case ConnHdrKeepAlive:
        Length += pEntry->HeaderLength;
        Length += 1;
        Length += CONN_KEEPALIVE_HDR_LENGTH;
        Length += CRLF_SIZE;
        break;

    default:
        ASSERT( connHeader < ConnHdrMax );
        break;
    }

    //
    // Any Content-Length: header we may need to generate.
    //

    if (pContentLengthString[0] != '\0')
    {
        ASSERT( ContentLengthStringLength > 0 );

        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderContentLength]]);

        Length += pEntry->HeaderLength;
        Length += 1;
        Length += ContentLengthStringLength;
        Length += CRLF_SIZE;
    }
    else
    {
        ASSERT( ContentLengthStringLength == 0 );
    }

    //
    // final CRLF
    //
    Length += CRLF_SIZE;

    return Length;

}   // UlComputeVariableHeaderSize


/***************************************************************************++

Routine Description:

    Figures out how big the maximum default variable headers are. Variable
    headers include Date, Content and Connection.

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

Return Values:

    The maximum number of bytes in the variable headers.

--***************************************************************************/
ULONG
UlComputeMaxVariableHeaderSize( VOID )
{
    ULONG Length = 0;
    PHEADER_MAP_ENTRY pEntry;

    //
    // Date: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderDate]]);
    Length += pEntry->HeaderLength;     // header name
    Length += 1;                        // SP
    Length += DATE_HDR_LENGTH;          // header value
    Length += CRLF_SIZE;                // CRLF

    //
    // Connection: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderConnection]]);

    Length += pEntry->HeaderLength;
    Length += 1;
    Length += MAX(CONN_CLOSE_HDR_LENGTH, CONN_KEEPALIVE_HDR_LENGTH);
    Length += CRLF_SIZE;

    //
    // Content-Length: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderContentLength]]);

    Length += pEntry->HeaderLength;
    Length += 1;
    Length += MAX_ULONGLONG_STR;
    Length += CRLF_SIZE;

    //
    // final CRLF
    //

    Length += CRLF_SIZE;

    return Length;

}   // UlComputeMaxVariableHeaderSize


/***************************************************************************++

Routine Description:

    Generates the varaible part of the header, including Date:, Connection:,
    and final CRLF.

Arguments:

    ConnHeader - Supplies the type of Connection: header to generate.

    pContentLengthString - Supplies a header value for an optional
        Content-Length header. If this is the empty string "", then no
        Content-Length header is generated.

    ContentLengthStringLength - Supplies the length of the above string.

    pBuffer - Supplies the target buffer for the generated headers.

    pBytesCopied - Receives the number of header bytes generated.

    pDateTime - Receives the system time equivalent of the Date: header

--***************************************************************************/
VOID
UlGenerateVariableHeaders(
    IN UL_CONN_HDR ConnHeader,
    IN PUCHAR pContentLengthString,
    IN ULONG ContentLengthStringLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied,
    OUT PLARGE_INTEGER pDateTime
    )
{
    PHEADER_MAP_ENTRY pEntry;
    PUCHAR pStartBuffer;
    PUCHAR pCloseHeaderValue;
    ULONG CloseHeaderValueLength;
    ULONG BytesCopied;

    ASSERT( pContentLengthString != NULL );
    ASSERT( pBuffer );
    ASSERT( pBytesCopied );
    ASSERT( pDateTime );

    pStartBuffer = pBuffer;

    //
    // generate Date: header
    //

    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderDate]]);

    RtlCopyMemory(
        pBuffer,
        pEntry->MixedCaseHeader,
        pEntry->HeaderLength
        );

    pBuffer += pEntry->HeaderLength;

    pBuffer[0] = SP;
    pBuffer += 1;

    BytesCopied = GenerateDateHeader( pBuffer, pDateTime );

    pBuffer += BytesCopied;

    ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
    pBuffer += sizeof(USHORT);

    //
    // generate Connection: header
    //

    switch (ConnHeader) {
    case ConnHdrNone:
        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;

    case ConnHdrClose:
        pCloseHeaderValue = (PUCHAR) CONN_CLOSE_HDR;
        CloseHeaderValueLength = CONN_CLOSE_HDR_LENGTH;
        break;

    case ConnHdrKeepAlive:
        pCloseHeaderValue = (PUCHAR) CONN_KEEPALIVE_HDR;
        CloseHeaderValueLength = CONN_KEEPALIVE_HDR_LENGTH;
        break;

    default:
        ASSERT(ConnHeader < ConnHdrMax);

        pCloseHeaderValue = NULL;
        CloseHeaderValueLength = 0;
        break;
    }

    if (pCloseHeaderValue != NULL) {
        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderConnection]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        RtlCopyMemory(
            pBuffer,
            pCloseHeaderValue,
            CloseHeaderValueLength
            );

        pBuffer += CloseHeaderValueLength;

        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }

    if (pContentLengthString[0] != '\0')
    {
        ASSERT( ContentLengthStringLength > 0 );

        pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderContentLength]]);

        RtlCopyMemory(
            pBuffer,
            pEntry->MixedCaseHeader,
            pEntry->HeaderLength
            );

        pBuffer += pEntry->HeaderLength;

        pBuffer[0] = SP;
        pBuffer += 1;

        RtlCopyMemory(
            pBuffer,
            pContentLengthString,
            ContentLengthStringLength
            );

        pBuffer += ContentLengthStringLength;

        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
        pBuffer += sizeof(USHORT);
    }
    else
    {
        ASSERT( ContentLengthStringLength == 0 );
    }

    //
    // generate final CRLF
    //

    ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
    pBuffer += sizeof(USHORT);

    //
    // make sure we didn't use too much
    //

    BytesCopied = DIFF(pBuffer - pStartBuffer);
    *pBytesCopied = BytesCopied;

}



ULONG
_WideCharToMultiByte(
    ULONG uCodePage,
    ULONG dwFlags,
    PCWSTR lpWideCharStr,
    int cchWideChar,
    PSTR lpMultiByteStr,
    int cchMultiByte,
    PCSTR lpDefaultChar,
    PBOOLEAN lpfUsedDefaultChar
    )
{
    int i;

    //
    // simply strip the upper byte, it's supposed to be ascii already
    //

    for (i = 0; i < cchWideChar; ++i)
    {
        if ((lpWideCharStr[i] & 0xff00) != 0 || IS_HTTP_CTL(lpWideCharStr[i]))
        {
            lpMultiByteStr[0] = *lpDefaultChar;
        }
        else
        {
            lpMultiByteStr[0] = (UCHAR)(lpWideCharStr[i]);
        }
        lpMultiByteStr += 1;
    }

    return (ULONG)(i);

}   // _WideCharToMultiByte

ULONG
_MultiByteToWideChar(
    ULONG uCodePage,
    ULONG dwFlags,
    PCSTR lpMultiByteStr,
    int cchMultiByte,
    PWSTR lpWideCharStr,
    int cchWideChar
    )
{
    int i;

    //
    // simply add a 0 upper byte, it's supposed to be ascii
    //

    for (i = 0; i < cchMultiByte; ++i)
    {
        if (lpMultiByteStr[i] > 128)
        {
            lpWideCharStr[i] = (WCHAR)(DefaultChar);
        }
        else
        {
            lpWideCharStr[i] = (WCHAR)(lpMultiByteStr[i]);
        }
    }

    return (ULONG)(i);

}   // _MultiByteToWideChar


/***************************************************************************++

Routine Description:

    Generates the fixed part of the header. Fixed headers include the
    status line, and any headers that don't have to be generated for
    every request (such as Date and Connection).

    The final CRLF separating headers from body is considered part of
    the variable headers.

Arguments:

    Version         - the http version for the status line
    pUserResponse   - the user specified response
    BufferLength    - length of pBuffer
    pBuffer         - generate the headers here
    pBytesCopied    - gets the number of bytes generated

--***************************************************************************/
NTSTATUS
UlGenerateFixedHeaders(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN ULONG BufferLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied
    )
{
    PUCHAR                  pStartBuffer;
    PUCHAR                  pEndBuffer;
    ULONG                   BytesCopied;
    ULONG                   BytesToCopy;
    ULONG                   i;
    PHTTP_UNKNOWN_HEADER    pUnknownHeaders;
    NTSTATUS                Status = STATUS_SUCCESS;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUserResponse != NULL);
    ASSERT(pBuffer != NULL && BufferLength > 0);
    ASSERT(pBytesCopied != NULL);

    //
    // The pUserResponse is user-mode data and cannot be trusted.
    // Hence the try/except.
    //

    __try
    {
        pStartBuffer = pBuffer;
        pEndBuffer = pBuffer + BufferLength;

        //
        // Build the response headers.
        //

        if (HTTP_NOT_EQUAL_VERSION(Version, 0, 9))
        {
            BytesToCopy =
                sizeof("HTTP/1.1 ") - 1 +
                4 +
                pUserResponse->ReasonLength / sizeof(CHAR) +
                sizeof(USHORT);

            if ((pBuffer + BytesToCopy) > pEndBuffer)
            {
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            //
            // Always send back 1.1 in the response.
            //

            RtlCopyMemory(pBuffer, "HTTP/1.1 ", sizeof("HTTP/1.1 ") - 1);
            pBuffer += sizeof("HTTP/1.1 ") - 1;

            //
            // Status code.
            //

            pBuffer[0] = '0' + ((pUserResponse->StatusCode / 100) % 10);
            pBuffer[1] = '0' + ((pUserResponse->StatusCode / 10)  % 10);
            pBuffer[2] = '0' + ((pUserResponse->StatusCode / 1)   % 10);
            pBuffer[3] = SP;

            pBuffer += 4;

            //
            // Copy the reason, converting from widechar.
            //

            BytesCopied = pUserResponse->ReasonLength / sizeof(CHAR);

            RtlCopyMemory(
                pBuffer,
                pUserResponse->pReason,
                BytesCopied
                );
            
            pBuffer += BytesCopied;

            //
            // Terminate with the CRLF.
            //

            ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
            pBuffer += sizeof(USHORT);

            //
            // Loop through the known headers.
            //

            for (i = 0; i < HttpHeaderResponseMaximum; ++i)
            {
                //
                // Skip some headers we'll generate.
                //

                if ((i == HttpHeaderDate) || (i == HttpHeaderConnection))
                {
                    continue;
                }

                if (pUserResponse->Headers.pKnownHeaders[i].RawValueLength > 0)
                {
                    PHEADER_MAP_ENTRY pEntry;

                    pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[i]]);

                    BytesToCopy =
                        pEntry->HeaderLength +
                        1 +
                        pUserResponse->Headers.pKnownHeaders[i].RawValueLength / sizeof(CHAR) +
                        sizeof(USHORT);

                    if ((pBuffer + BytesToCopy) > pEndBuffer)
                    {
                        return STATUS_INSUFFICIENT_RESOURCES;
                    }

                    RtlCopyMemory(
                        pBuffer,
                        pEntry->MixedCaseHeader,
                        pEntry->HeaderLength
                        );

                    pBuffer += pEntry->HeaderLength;

                    pBuffer[0] = SP;
                    pBuffer += 1;

                    BytesCopied = pUserResponse->Headers.pKnownHeaders[i].RawValueLength / sizeof(CHAR);

                    RtlCopyMemory(
                        pBuffer,
                        pUserResponse->Headers.pKnownHeaders[i].pRawValue,
                        BytesCopied
                        );

                    pBuffer += BytesCopied;

                    ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                    pBuffer += sizeof(USHORT);
                }
            }

            //
            // Append some default headers if not provided by the application.
            //

            if (pUserResponse->Headers.pKnownHeaders[HttpHeaderServer].RawValueLength == 0)
            {
                PHEADER_MAP_ENTRY pEntry;

                pEntry = &(g_ResponseHeaderMapTable[g_ResponseHeaderMap[HttpHeaderServer]]);

                BytesToCopy =
                    pEntry->HeaderLength +
                    1 +
                    DEFAULT_SERVER_HDR_LENGTH +
                    sizeof(USHORT);

                if ((pBuffer + BytesToCopy) > pEndBuffer)
                {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlCopyMemory(
                    pBuffer,
                    pEntry->MixedCaseHeader,
                    pEntry->HeaderLength
                    );

                pBuffer += pEntry->HeaderLength;

                pBuffer[0] = SP;
                pBuffer += 1;

                RtlCopyMemory(
                    pBuffer,
                    DEFAULT_SERVER_HDR,
                    DEFAULT_SERVER_HDR_LENGTH
                    );

                pBuffer += DEFAULT_SERVER_HDR_LENGTH;

                ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                pBuffer += sizeof(USHORT);
            }

            //
            // And now the unknown headers (this might throw an exception).
            //

            pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;
            if (pUnknownHeaders != NULL)
            {
                for (i = 0 ; i < pUserResponse->Headers.UnknownHeaderCount; ++i)
                {
                    if (pUnknownHeaders[i].NameLength > 0)
                    {
                        BytesToCopy =
                            pUnknownHeaders[i].NameLength / sizeof(CHAR) +
                            1 +
                            1 +
                            pUnknownHeaders[i].RawValueLength / sizeof(CHAR) +
                            sizeof(USHORT);

                        if ((pBuffer + BytesToCopy) > pEndBuffer)
                        {
                            return STATUS_INSUFFICIENT_RESOURCES;
                        }

                        BytesCopied = pUnknownHeaders[i].NameLength / sizeof(CHAR);

                        RtlCopyMemory(
                            pBuffer,
                            pUnknownHeaders[i].pName,
                            BytesCopied
                            );
                        
                        pBuffer += BytesCopied;

                        *pBuffer++ = ':';
                        *pBuffer++ = SP;

                        BytesCopied = pUnknownHeaders[i].RawValueLength / sizeof(CHAR);

                        RtlCopyMemory(
                            pBuffer,
                            pUnknownHeaders[i].pRawValue,
                            BytesCopied
                            );

                        pBuffer += BytesCopied;

                        ((UNALIGNED64 USHORT *)pBuffer)[0] = CRLF;
                        pBuffer += sizeof(USHORT);

                    }   // if (pUnknownHeaders[i].NameLength > 0)

                }

            }   // if (pUnknownHeaders != NULL)

            *pBytesCopied = DIFF(pBuffer - pStartBuffer);

        }   // if (Version > UlHttpVersion09)
        else
        {
            *pBytesCopied = 0;
        }

        //
        // Ensure we didn't use too much.
        //

        ASSERT(DIFF(pBuffer - pStartBuffer) <= BufferLength);

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    return Status;

}   // UlGenerateFixedHeaders


PSTR Weekdays[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
PSTR Months[] = { "Jan", "Feb", "Mar", "Apr", "May", "Jun",
                  "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

/***************************************************************************++

Routine Description:

    Generates a date header string from a LARGE_INTEGER.

Arguments:

    pBuffer: Buffer to store generated date string

    systemTime: A 64 bit Time value to be converted

--***************************************************************************/
ULONG
GenerateDateHeaderString(
    OUT PUCHAR pBuffer,
    IN LARGE_INTEGER systemTime
    )
{
    TIME_FIELDS timeFields;
    int length;

    RtlTimeToTimeFields( &systemTime, &timeFields );

    length = sprintf(
                 (char *) pBuffer,
                 "%s, %02d %s %04d %02d:%02d:%02d GMT",
                 Weekdays[timeFields.Weekday],
                 timeFields.Day,
                 Months[timeFields.Month - 1],
                 timeFields.Year,
                 timeFields.Hour,
                 timeFields.Minute,
                 timeFields.Second
                 );

    ASSERT( length <= DATE_HDR_LENGTH );

    return (ULONG)length;

}   // GenerateDateHeaderString


/***************************************************************************++

Routine Description:

    Generates a date header and updates cached value if required.

Arguments:

    pBuffer: Buffer to store generated date header.

    pSystemTime: caller allocated buffer to receive the SystemTime equivalent
                 of the generated string time.

--***************************************************************************/
ULONG
GenerateDateHeader(
    OUT PUCHAR pBuffer,
    OUT PLARGE_INTEGER pSystemTime
    )
{
    LARGE_INTEGER CacheTime;

    int length;
    LONGLONG timediff;

    //
    // Get the current time.
    //

    KeQuerySystemTime( pSystemTime );
    CacheTime.QuadPart = g_UlSystemTime.QuadPart;

    //
    // Check the difference between the current time, and
    // the cached time. Note that timediff is signed.
    //

    timediff = pSystemTime->QuadPart - CacheTime.QuadPart;

    if (timediff < ONE_SECOND) {

        //
        // The entry hasn't gone stale yet. We can copy.
        // Force a barrier around reading the string into memory.
        //

        UL_READMOSTLY_READ_BARRIER();
        RtlCopyMemory(pBuffer, g_UlDateString, g_UlDateStringLength+1);
        UL_READMOSTLY_READ_BARRIER();


        //
        // Inspect the global time value again in case it changed.
        //

        if (CacheTime.QuadPart == g_UlSystemTime.QuadPart) {
            //
            // Global value hasn't changed. We are all set.
            //
            pSystemTime->QuadPart = CacheTime.QuadPart;
            return g_UlDateStringLength;

        }

    }

    //
    // The cached value is stale, or is/was being changed. We need to update or re-read it.
    // Note that we could also spin trying to re-read and acquire the lock.
    //

    UlAcquireResourceExclusive(
        &g_pUlNonpagedData->DateHeaderResource,
        TRUE
        );

    //
    // Has someone else updated the time while we were blocked?
    //

    CacheTime.QuadPart = g_UlSystemTime.QuadPart;
    timediff = pSystemTime->QuadPart - CacheTime.QuadPart;

    if (timediff >= ONE_SECOND)
    {
        g_UlSystemTime.QuadPart = 0;
        KeQuerySystemTime( pSystemTime );

        UL_READMOSTLY_WRITE_BARRIER();
        g_UlDateStringLength = GenerateDateHeaderString(
                                    g_UlDateString,
                                    *pSystemTime
                                    );
        UL_READMOSTLY_WRITE_BARRIER();

        g_UlSystemTime.QuadPart = pSystemTime->QuadPart;
    }
    else
    {
        // Capture the system time used to generate the buffer
        pSystemTime->QuadPart = g_UlSystemTime.QuadPart;
    }

    //
    // The time has been updated. Copy the new string into
    // the caller's buffer.
    //
    RtlCopyMemory(
        pBuffer,
        g_UlDateString,
        g_UlDateStringLength + 1
        );

    UlReleaseResource(&g_pUlNonpagedData->DateHeaderResource);

    return g_UlDateStringLength;

}   // GenerateDateHeader


/***************************************************************************++

Routine Description:

    Initializes the date cache.

--***************************************************************************/
NTSTATUS
UlInitializeDateCache( VOID )
{
    LARGE_INTEGER now;
    NTSTATUS status;

    KeQuerySystemTime(&now);
    g_UlDateStringLength = GenerateDateHeaderString(g_UlDateString, now);

    status = UlInitializeResource(
                    &g_pUlNonpagedData->DateHeaderResource,
                    "DateHeaderResource",
                    0,
                    UL_DATE_HEADER_RESOURCE_TAG
                    );

    if (NT_SUCCESS(status))
    {
        g_DateCacheInitialized = TRUE;
    }

    return status;
}


/***************************************************************************++

Routine Description:

    Terminates the date header cache.

--***************************************************************************/
VOID
UlTerminateDateCache( VOID )
{
    if (g_DateCacheInitialized)
    {
        UlDeleteResource(&g_pUlNonpagedData->DateHeaderResource);
    }
}


/***************************************************************************++

Routine Description:

    Parses the http version from a string.  Assumes string begins with "HTTP/".  Eats
    leading zeros.  Puts resulting version in HTTP_VERSION structure passed in to
    function.

Arguments:

    pString         array of chars to parse

    StringLength    number o bytes in pString

    pVersion        where to put parsed version.

Returns:

    Number of bytes parsed out of string.  Zero indicates parse failure, and no version
    information was found.  Number of bytes does not include trailing linear white space nor
    CRLF line terminator.

--***************************************************************************/
ULONG
UlpParseHttpVersion(
    PUCHAR pString,
    ULONG  StringLength,
    PHTTP_VERSION pVersion
    )
{
    ULONG   BytesRemaining = StringLength;
    BOOLEAN Done = FALSE;

    ASSERT( pString );
    ASSERT( StringLength > HTTP_PREFIX_SIZE + 1 );
    ASSERT( pVersion );

    // Deal with leading zeros.  Buffer should look like "HTTP/00000n.n"...
    pVersion->MajorVersion = 0;
    pVersion->MinorVersion = 0;

    //
    // compare 'HTTP' away
    //
    if ( *(UNALIGNED64 ULONG *)pString == (ULONG) HTTP_PREFIX )
    {
        BytesRemaining -= HTTP_PREFIX_SIZE;
        pString += HTTP_PREFIX_SIZE;
    }
    else
    {
        goto End;
    }

    if ( '/' == *pString )
    {
        BytesRemaining--;
        pString++;
    }
    else
    {
        goto End;
    }

    //
    // Parse major version
    //
    while ( (0 != BytesRemaining) && IS_HTTP_DIGIT(*pString) )
    {
        pVersion->MajorVersion *= 10;
        pVersion->MajorVersion += (*pString - '0');

        BytesRemaining--;
        pString++;
    }

    if ( 0 == BytesRemaining )
    {
        goto End;
    }

    //
    // find '.'
    //
    if ( '.' != *pString )
    {
        // Error: No decimal place; bail out.
        goto End;
    }
    else
    {
        BytesRemaining--;
        pString++;
    }

    if ( 0 == BytesRemaining || !IS_HTTP_DIGIT(*pString) )
    {
        goto End;
    }

    //
    // Parse minor version
    //
    while ( (0 != BytesRemaining) && IS_HTTP_DIGIT(*pString) )
    {
        pVersion->MinorVersion *= 10;
        pVersion->MinorVersion += (*pString - '0');

        BytesRemaining--;
        pString++;
    }

    Done = TRUE;


 End:
    if (!Done)
    {
        return 0;
    }
    else
    {
        UlTrace(PARSER, (
            "http!UlpParseHttpVersion: found version HTTP/%d.%d\n",
            pVersion->MajorVersion,
            pVersion->MinorVersion
            ));


        return (StringLength - BytesRemaining);
    }

} // UlpParseHttpVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\parse.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    parse.h

Abstract:

    Contains all of the public definitions for the HTTP parsing code.

Author:

    Henry Sanders (henrysa)         04-May-1998

Revision History:

    Paul McDaniel (paulmcd)         14-Apr-1999

--*/

#ifndef _PARSE_H_
#define _PARSE_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Size of a Date: header value.
//

#define DATE_HDR_LENGTH (sizeof("Mon, 05 May 1975 00:05:00 GMT") - sizeof(CHAR))



//
// The initialization routine.
//
NTSTATUS InitializeParser(VOID);

//
// The main HTTP parse routine(s).
//

NTSTATUS
UlParseHttp(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHttpRequest,
    IN  ULONG                   HttpRequestLength,
    OUT ULONG                   *pBytesTaken
    );

NTSTATUS
UlParseChunkLength(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUCHAR pBuffer,
    IN ULONG BufferLength,
    OUT PULONG pBytesTaken,
    OUT PULONGLONG pChunkLength
    );

//
// Date header cache.
//

NTSTATUS
UlInitializeDateCache(
    VOID
    );

VOID
UlTerminateDateCache(
    VOID
    );

//
// Utility tokenizing routine.
//

PUCHAR
FindWSToken(
    IN  PUCHAR pBuffer,
    IN  ULONG  BufferLength,
    OUT ULONG  *TokenLength
    );

NTSTATUS
UlComputeFixedHeaderSize(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    OUT PULONG pHeaderLength
    );

ULONG
UlComputeVariableHeaderSize(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN BOOLEAN ForceDisconnect,
    IN PUCHAR pContentLengthString,
    IN ULONG ContentLengthStringLength,
    OUT PUL_CONN_HDR pConnHeader
    );

ULONG
UlComputeMaxVariableHeaderSize(
    VOID
    );

NTSTATUS
UlGenerateFixedHeaders(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN ULONG BufferLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied
    );

VOID
UlGenerateVariableHeaders(
    IN UL_CONN_HDR ConnHeader,
    IN PUCHAR pContentLengthString,
    IN ULONG ContentLengthStringLength,
    OUT PUCHAR pBuffer,
    OUT PULONG pBytesCopied,
    OUT PLARGE_INTEGER pDateTime
    );


ULONG
_MultiByteToWideChar(
    ULONG uCodePage,
    ULONG dwFlags,
    PCSTR lpMultiByteStr,
    int cchMultiByte,
    PWSTR lpWideCharStr,
    int cchWideChar
    );

ULONG
GenerateDateHeader(
    OUT PUCHAR pBuffer,
    OUT PLARGE_INTEGER pSystemTime
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _PARSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\rcvhdrs.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    rcvhdrs.cxx

Abstract:

    Contains all of the per header handling code for received headers.

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#include    "precomp.h"
#include    "rcvhdrs.h"

/*++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a header.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    TokenLength     - Where to return the length of the token.

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--*/
NTSTATUS
FindHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    UCHAR       CurrentChar;
    ULONG       CurrentOffset;
    BOOLEAN     HaveHeader;

    //
    // Important this is above the label (and our of the for loop)
    // to support goto repeats.
    //

    CurrentOffset = 0;

look_for_crlf:

    HaveHeader = FALSE;

    //
    // Always start from the second character.
    //

    CurrentOffset++;

    //
    // While we still have data, loop through looking for a CRLF or LFLF pair.
    //

    for (; CurrentOffset < HeaderLength; CurrentOffset += 2)
    {
        CurrentChar = *(pHeader + CurrentOffset);

        //
        // Try CR first because if we hit CR we only need to look at the
        // character to the right to see if it is LF.  The chance of hitting
        // either CF or LF is 50/50, but the path length is shorter in the
        // case we hit CR so check it first.
        //

        if (CurrentChar == CR)
        {
            //
            // Be a bit aggressive to assume we will hit CRLF by adjusting
            // CurrentOffset forward.  If this is not CRLF, restore it back.
            //

            CurrentOffset++;

            if (CurrentOffset < HeaderLength &&
                *(pHeader + CurrentOffset) == LF)
            {
                //
                // Cool, we are done so break the loop.
                //

                HaveHeader = TRUE;
                break;
            }
            else
            {
                CurrentOffset--;
            }
        }

        //
        // Now check to see if this is LF.  If so, we look backward to see
        // if we have a CR, and if that is not the case, look forward to
        // see if we have another LF.  It is assumed CRLF is more common
        // than LFLF so we always look backward first.
        //

        if (CurrentChar == LF)
        {
            if (*(pHeader + CurrentOffset - 1) == CR)
            {
                //
                // Everything is set so simply break the loop.
                //

                HaveHeader = TRUE;
                break;
            }

            //
            // It is still possible this can be LFLF so verify it.
            //

            CurrentOffset++;

            if (CurrentOffset < HeaderLength &&
                *(pHeader + CurrentOffset) == LF)
            {
                //
                // Cool, we are done so break the loop.
                //

                HaveHeader = TRUE;
                break;
            }
            else
            {
                CurrentOffset--;
            }
        }
    }

    //
    // If we found the termination OK, return the length of the value.
    //

    if (HaveHeader)
    {
        ASSERT(CurrentOffset < HeaderLength);

        //
        // OK, we found a CRLF or LFLF, peek ahead 1 char to handle header
        // value continuation.
        //

        //
        // Skip the LF.
        //

        CurrentOffset += 1;

        if (CurrentOffset == HeaderLength)
        {
            //
            // Not enough buffer to check, need more.
            //

            *pBytesTaken = 0;
            return STATUS_SUCCESS;
        }

        CurrentChar = *(pHeader + CurrentOffset);

        //
        // Is this a second line of the same header value?  Check for
        // continuation.
        //

        if (IS_HTTP_LWS(CurrentChar))
        {
            ASSERT(pHeader[CurrentOffset - 1] == LF);
            ASSERT(CurrentOffset >= 2);

            //
            // Replace the CRLF|LFLF with SPSP.
            //

            pHeader[CurrentOffset - 1] = SP;
            pHeader[CurrentOffset - 2] = SP;

            //
            // Skip this WS char.
            //

            CurrentOffset += 1;

            //
            // Find the real end of the header value.
            //

            goto look_for_crlf;
        }

        //
        // All done!
        //

        *pBytesTaken = CurrentOffset;
        return STATUS_SUCCESS;
    }

    //
    // Did not find the end of a header, let's get more buffer.
    //

    *pBytesTaken = 0;
    return STATUS_SUCCESS;
}

/*++

Routine Description:

    A utility routine, to find the terminating CRLF or LFLF of a
    chunk header.

Arguments:

    pHeader         - Header whose end is to be found.
    HeaderLength    - Length of data pointed to by pHeader.
    TokenLength     - Where to return the length of the token.

Return Value:

    Length of the header, or 0 if we couldn't find the end.

--*/
NTSTATUS
FindChunkHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    )
{
    UCHAR       CurrentChar;
    ULONG       CurrentOffset;
    BOOLEAN     HaveCR;
    BOOLEAN     HaveHeader;

    CurrentOffset = 0;
    HaveCR = FALSE;
    HaveHeader = FALSE;

    //
    // While we still have data, loop through looking for a CRLF or LFLF pair.
    //

    for (; CurrentOffset < HeaderLength; CurrentOffset++)
    {
        CurrentChar = *(pHeader + CurrentOffset);

        //
        // If this character is a CR or LF, we may be done.
        //

        if (CurrentChar == CR || CurrentChar == LF)
        {
            //
            // If we've already seen a CR (or LF) immediately preceding this,
            // see if this is a LF to terminate the line.
            //

            if (HaveCR)
            {
                if (CurrentChar == LF)
                {
                    // It is a LF, so we're done.

                    HaveHeader = TRUE;

                    break;
                }

                // Otherwise, we have a non LF after a CR (or LF). The only
                // character this could be is a CR, since we're inside
                // the if statement. This could be the start of a CRLF
                // sequence, if this is some bizarre LFCRLF or CRCRLF
                // sort of thing. Anyway, we don't want to set HaveCR
                // to false here.

                ASSERT(CurrentChar == CR);

                return STATUS_INVALID_DEVICE_REQUEST;

            }
            else
            {
                // Otherwise, we haven't seen the start of the terminating pair
                // yet, so remember that we now have.

                HaveCR = TRUE;
            }
        }
        else if (HaveCR)
        {
            //
            // it's illegal to have CR|LF and non trailing LF.
            //

            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    //
    // If we found the termination OK, return the length of the value.
    //

    if (HaveHeader)
    {
        ASSERT(CurrentOffset < HeaderLength);

        //
        // All done!
        //

        *pBytesTaken = CurrentOffset + 1;
        return STATUS_SUCCESS;
    }

    // Did not find the end of a header, let's get more buffer..
    //
    *pBytesTaken = 0;
    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Append a header value to an existing HTTP_HEADER entry, allocating
    a buffer and copying the existing buffer.

Arguments:

    pHttpHeader     - Pointer to HTTP_HEADER structure to append to.
    pHeader         - Pointer header to be appended.
    HeaderLength    - Length of data pointed to by pHeader.

Return Value:

    TRUE if we succeed, FALSE otherwise.

--*/
NTSTATUS
UlAppendHeaderValue(
    PUL_INTERNAL_REQUEST    pRequest,
    PUL_HTTP_HEADER pHttpHeader,
    PUCHAR          pHeader,
    ULONG           HeaderLength
    )
{
    PUCHAR          pNewHeader, pOldHeader;
    ULONG           OldHeaderLength;


    OldHeaderLength = pHttpHeader->HeaderLength;

    pNewHeader = UL_ALLOCATE_ARRAY(
                        NonPagedPool,
                        UCHAR,
                        OldHeaderLength + HeaderLength + sizeof(", "), // sizeof gives space
                                                                       // for the NULL
                        HEADER_VALUE_POOL_TAG
                        );

    if (pNewHeader == NULL)
    {
        // Had a failure.
        return STATUS_NO_MEMORY;
    }

    //
    // Copy the old data into the new header.
    //
    RtlCopyMemory(pNewHeader, pHttpHeader->pHeader, OldHeaderLength);

    // And copy in the new data as well, seperated by a comma.
    //
    *(pNewHeader + OldHeaderLength) = ',';
    *(pNewHeader + OldHeaderLength + 1) = ' ';
    OldHeaderLength += sizeof(", ") - 1;

    RtlCopyMemory( pNewHeader + OldHeaderLength, pHeader, HeaderLength);

    // Now replace the existing header.
    //
    pOldHeader = pHttpHeader->pHeader;
    pHttpHeader->HeaderLength = OldHeaderLength + HeaderLength;
    pHttpHeader->pHeader = pNewHeader;

    // If the old header was our buffer, free it too.
    //
    if (pHttpHeader->OurBuffer)
    {
        UL_FREE_POOL( pOldHeader, HEADER_VALUE_POOL_TAG );
    }

    pHttpHeader->OurBuffer = 1;

    //
    // null terminate it
    //

    pHttpHeader->pHeader[pHttpHeader->HeaderLength] = ANSI_NULL;

    pRequest->HeadersAppended = TRUE;

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  this does not allow multiple header
    values to exist for this header.  use UlMultipleHeaderHandler for
    handling that by appending the values together (CSV) .

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
UlSingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    ULONG       HeaderValueLength;

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pHeader,
                    HeaderLength,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken > 0)
    {
        // Strip of the trailing CRLF from the header value length
        //
        HeaderValueLength = BytesTaken - CRLF_SIZE;

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // remove any trailing LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

        }
        else
        {
            //
            // uh oh.  Have an existing header, fail the request.
            //

            pRequest->ErrorCode = UlErrorHeader;
            pRequest->ParseState = ParseErrorState;

            UlTrace(PARSER, (
                        "ul!UlSingleHeaderHandler(pRequest = %p, pHeader = %p)\n"
                        "    ERROR: multiple headers not allowed.\n",
                        pRequest,
                        pHeader
                        ));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            goto end;

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlSingleHeaderHandler

/*++

Routine Description:

    The default routine for handling headers. Used when we don't want to
    do anything with the header but find out if we have the whole thing
    and save a pointer to it if we do.  this function handles multiple
    headers with the same name, and appends the values together seperated
    by commas.

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.

--*/
NTSTATUS
UlMultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    ULONG       HeaderValueLength;

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pHeader,
                    HeaderLength,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken > 0)
    {
        // Strip of the trailing CRLF from the header value length
        //
        HeaderValueLength = BytesTaken - CRLF_SIZE;

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // remove any trailing LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

        }
        else
        {
            ULONG OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pRequest->Headers[HeaderID].HeaderLength;

            Status = UlAppendHeaderValue(
                            pRequest,
                            &pRequest->Headers[HeaderID],
                            pHeader,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Update total request length for the amount we just added.
            // space for the terminator is already in there
            //

            pRequest->TotalRequestSize +=
                (pRequest->Headers[HeaderID].HeaderLength - OldHeaderLength) *
                    sizeof(CHAR);

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlMultipleHeaderHandler

/*++

Routine Description:

    The routine for handling Accept headers. 

Arguments:

    pHttpConn       - HTTP connection on which this header was received.
    pHeader         - Pointer to the header value.
    HeaderLength    - Length of data pointed to by pHeader.
    HeaderID        - ID of the header.

Return Value:

    The length of the header value, or 0 if it's not terminated.
    Wildcard bit is set in the request if found

--*/
NTSTATUS
UlAcceptHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    ULONG       BytesTaken;
    ULONG       HeaderValueLength;

    // Find the end of the header value
    //
    Status = FindHeaderEnd(
                    pHeader,
                    HeaderLength,
                    &BytesTaken
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    if (BytesTaken > 0)
    {
        // Strip of the trailing CRLF from the header value length
        //
        HeaderValueLength = BytesTaken - CRLF_SIZE;

        //
        // skip any preceding LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(*pHeader))
        {
            pHeader++;
            HeaderValueLength--;
        }

        //
        // remove any trailing LWS.
        //

        while (HeaderValueLength > 0 && IS_HTTP_LWS(pHeader[HeaderValueLength-1]))
        {
            HeaderValueLength--;
        }

        // do we have an existing header?
        //
        if (pRequest->HeaderValid[HeaderID] == FALSE)
        {
            // No existing header, just save this pointer for now.
            //
            pRequest->HeaderIndex[pRequest->HeaderCount] = (UCHAR)HeaderID;
            pRequest->HeaderCount++;
            pRequest->HeaderValid[HeaderID] = TRUE;
            pRequest->Headers[HeaderID].HeaderLength = HeaderValueLength;
            pRequest->Headers[HeaderID].pHeader = pHeader;
            pRequest->Headers[HeaderID].OurBuffer = 0;

            //
            // null terminate it.  we have space as all headers end with CRLF.
            // we are over-writing the CR
            //

            pHeader[HeaderValueLength] = ANSI_NULL;

            //
            // make space for a terminator
            //

            pRequest->TotalRequestSize += (HeaderValueLength + 1) * sizeof(CHAR);

            if (HeaderValueLength > WILDCARD_SIZE)
            {

                // 
                // for the fast path, we'll check only */* at the end
                //

                if (
                    (*(UNALIGNED64 ULONG *) (&pHeader[HeaderValueLength - WILDCARD_SIZE]) == WILDCARD_SPACE) || 
                    (*(UNALIGNED64 ULONG *) (&pHeader[HeaderValueLength - WILDCARD_SIZE]) == WILDCARD_COMMA)
                   )
                {
                    pRequest->AcceptWildcard = TRUE;
                }
            }

        }
        else
        {
            ULONG OldHeaderLength;

            // Have an existing header, append this one.

            OldHeaderLength = pRequest->Headers[HeaderID].HeaderLength;

            Status = UlAppendHeaderValue(
                            pRequest,
                            &pRequest->Headers[HeaderID],
                            pHeader,
                            HeaderValueLength
                            );

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            //
            // Update total request length for the amount we just added.
            // space for the terminator is already in there
            //

            pRequest->TotalRequestSize +=
                (pRequest->Headers[HeaderID].HeaderLength - OldHeaderLength) *
                    sizeof(CHAR);

        }

    }

    // Success!
    //
    *pBytesTaken = BytesTaken;

end:
    return Status;

}   // UlAcceptHeaderHandler
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\pplasl.cxx ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pplasl.cxx

Abstract:

    This file contains the implementation of a per-processor lookaside
    list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#include "precomp.h"

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    )
{
    HANDLE PoolHandle;
    SIZE_T PoolSize;
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    NumberProcessors = KeNumberProcessors;

    // Allocate room for 1 lookaside list per processor plus 1 extra
    // lookaside list for overflow.  Only allocate 1 lookaside list if
    // we're on a single processor machine.
    //
    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    PoolSize = sizeof(NPAGED_LOOKASIDE_LIST) * NumberLookasideLists;

    PoolHandle = ExAllocatePoolWithTag(NonPagedPool, PoolSize, Tag);
    if (PoolHandle)
    {
        for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
             i < NumberLookasideLists;
             i++, Lookaside++)
        {
            ExInitializeNPagedLookasideList(
                Lookaside,
                Allocate,
                Free,
                Flags,
                Size,
                Tag,
                Depth);

            // ExInitializeNPagedLookasideList doesn't really set the
            // maximum depth to Depth, so we'll do it here.
            //
            if (Depth != 0) {
                Lookaside->L.MaximumDepth = Depth;
            }
        }
    }

    return PoolHandle;
}

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    )
{
    CCHAR NumberProcessors;
    CCHAR NumberLookasideLists;
    CCHAR i;
    PNPAGED_LOOKASIDE_LIST Lookaside;

    if (!PoolHandle)
    {
        return;
    }

    NumberProcessors = KeNumberProcessors;

    NumberLookasideLists = NumberProcessors;
    if (NumberProcessors > 1)
    {
        NumberLookasideLists++;
    }

    for (i = 0, Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;
         i < NumberLookasideLists;
         i++, Lookaside++)
    {
        ExDeleteNPagedLookasideList(Lookaside);
    }

    ExFreePool(PoolHandle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\pplasl.h ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    pplasl.c

Abstract:

    This file contains definitions and function prototypes of a per-processor
    lookaside list manager.

Author:

    Shaun Cox (shaunco) 25-Oct-1999

--*/

#ifndef _PPLASL_H_
#define _PPLASL_H_

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
PplCreatePool(
    IN PALLOCATE_FUNCTION Allocate,
    IN PFREE_FUNCTION Free,
    IN ULONG Flags,
    IN SIZE_T Size,
    IN ULONG Tag,
    IN USHORT Depth
    );

VOID
PplDestroyPool(
    IN HANDLE PoolHandle
    );

__inline
PVOID
FASTCALL
PplAllocate(
    IN HANDLE PoolHandle
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;
    PVOID Entry;

    NumberProcessors = KeNumberProcessors;

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalAllocates += 1;
    Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
    if (!Entry)
    {
        Lookaside->L.AllocateMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalAllocates += 1;
        Entry = InterlockedPopEntrySList(&Lookaside->L.ListHead);
        if (!Entry)
        {
            Lookaside->L.AllocateMisses += 1;
            Entry = (Lookaside->L.Allocate)(
                        Lookaside->L.Type,
                        Lookaside->L.Size,
                        Lookaside->L.Tag);
        }
    }
    return Entry;
}

__inline
VOID
FASTCALL
PplFree(
    IN HANDLE PoolHandle,
    IN PVOID Entry
    )
{
    PNPAGED_LOOKASIDE_LIST Lookaside;
    CCHAR NumberProcessors;

    NumberProcessors = KeNumberProcessors;

    if (1 == NumberProcessors)
    {
        goto SingleProcessorCaseOrMissedPerProcessor;
    }

    // Try first for the per-processor lookaside list.
    //
    Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle +
                    KeGetCurrentProcessorNumber() + 1;

    Lookaside->L.TotalFrees += 1;
    if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
    {
        Lookaside->L.FreeMisses += 1;

SingleProcessorCaseOrMissedPerProcessor:
        // We missed on the per-processor lookaside list, (or we're
        // running on a single processor machine) so try for
        // the overflow lookaside list.
        //
        Lookaside = (PNPAGED_LOOKASIDE_LIST)PoolHandle;

        Lookaside->L.TotalFrees += 1;
        if (ExQueryDepthSList(&Lookaside->L.ListHead) >= Lookaside->L.Depth)
        {
            Lookaside->L.FreeMisses += 1;
            (Lookaside->L.Free)(Entry);
        }
        else
        {
            InterlockedPushEntrySList(
                &Lookaside->L.ListHead,
                (PSINGLE_LIST_ENTRY)Entry);
        }
    }
    else
    {
        InterlockedPushEntrySList(
            &Lookaside->L.ListHead,
            (PSINGLE_LIST_ENTRY)Entry);
    }
}

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PPLASL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\rcvhdrs.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    rcvhdrs.h

Abstract:

    Contains definitions for rcvhdrs.c .

Author:

    Henry Sanders (henrysa)       11-May-1998

Revision History:

--*/

#ifndef _RCVHDRS_H_
#define _RCVHDRS_H_

#ifdef __cplusplus
extern "C" {
#endif

#define WILDCARD_SIZE       (sizeof("*/*"))
#define WILDCARD_SPACE      '*/* '
#define WILDCARD_COMMA      '*/*,'

NTSTATUS
UlAcceptHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlMultipleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlSingleHeaderHandler(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    IN  HTTP_HEADER_ID          HeaderID,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
FindHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
FindChunkHeaderEnd(
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength,
    OUT PULONG                  pBytesTaken
    );

NTSTATUS
UlAppendHeaderValue(
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_HTTP_HEADER         pHttpHeader,
    IN  PUCHAR                  pHeader,
    IN  ULONG                   HeaderLength
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _RCVHDRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\proc.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    This module contains routine prototypes for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PROC_H_
#define _PROC_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Device driver entry routine from INIT.C.
//

EXTERN_C
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );


//
// IRP handlers from various modules.
//

NTSTATUS
UlCleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlCreate(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
UlDeviceControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );


//
// Fast IO handler from DEVCTRL.C.
//

BOOLEAN
UlFastDeviceControl(
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );


//
// Global data initialization/termination from DATA.C.
//

NTSTATUS
UlInitializeData(
    PUL_CONFIG pConfig
    );

VOID
UlTerminateData(
    VOID
    );


//
// Utility functions from MISC.C.
//

NTSTATUS
UlOpenRegistry(
    IN PUNICODE_STRING BaseName,
    OUT PHANDLE ParametersHandle
    );

LONG
UlReadLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONG DefaultValue
    );

LONGLONG
UlReadLongLongParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    IN LONGLONG DefaultValue
    );

NTSTATUS
UlReadGenericParameter(
    IN HANDLE ParametersHandle,
    IN PWCHAR ValueName,
    OUT PKEY_VALUE_PARTIAL_INFORMATION * Value
    );

VOID
UlBuildDeviceControlIrp(
    IN OUT PIRP Irp,
    IN ULONG IoControlCode,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    IN PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN PMDL MdlAddress,
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STATUS_BLOCK IoStatusBlock,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext,
    IN PETHREAD TargetThread OPTIONAL
    );

PSTR
UlULongLongToAscii(
    IN PSTR String,
    IN ULONGLONG Value
    );

NTSTATUS
_RtlIntegerToUnicode(
    IN ULONG Integer,
    IN ULONG Base OPTIONAL,
    IN LONG BufferLength,
    OUT PWSTR pBuffer
    );

NTSTATUS
UlAnsiToULongLong(
    PUCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    );

NTSTATUS
UlUnicodeToULongLong(
    PWCHAR      pString,
    ULONG       Base,
    PULONGLONG  pValue
    );

NTSTATUS
UlIssueDeviceControl(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PVOID pIrpParameters,
    IN ULONG IrpParametersLength,
    IN PVOID pMdlBuffer OPTIONAL,
    IN ULONG MdlBufferLength OPTIONAL,
    IN UCHAR MinorFunction
    );

NTSTATUS
UlInvokeCompletionRoutine(
    IN NTSTATUS Status,
    IN ULONG_PTR Information,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );


//
// Initialize a TA_IP_ADDRESS structure.
//

#define UlInitializeIpTransportAddress( ta, ipaddr, port )             \
    do {                                                                \
        RtlZeroMemory( (ta), sizeof(*(ta)) );                           \
        (ta)->TAAddressCount = 1;                                       \
        (ta)->Address[0].AddressLength = sizeof(TDI_ADDRESS_IP);        \
        (ta)->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;             \
        (ta)->Address[0].Address[0].in_addr = SWAP_LONG( (ipaddr) );    \
        (ta)->Address[0].Address[0].sin_port = SWAP_SHORT( (port) );    \
    } while (FALSE)


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  UL_BUG_CHECK_ values defined below and then use UlBugCheck to bugcheck
//  the system.
//

#define UL_BUG_CHECK_CLOSE              (0x00010000)
#define UL_BUG_CHECK_CREATE             (0x00020000)
#define UL_BUG_CHECK_DEBUG              (0x00030000)
#define UL_BUG_CHECK_DEVCTRL            (0x00040000)
#define UL_BUG_CHECK_INIT               (0x00050000)
#define UL_BUG_CHECK_IOCTL              (0x00060000)
#define UL_BUG_CHECK_MISC               (0x00070000)
#define UL_BUG_CHECK_ULDATA             (0x00080000)

#define UlBugCheck(A,B,C)                                                   \
    KeBugCheckEx(                                                           \
        UL_INTERNAL_ERROR,                                                  \
        BugCheckFileId | __LINE__,                                          \
        (A),                                                                \
        (B),                                                                \
        (C)                                                                 \
        )


//
// IRP context manipulators.
//

#define UlPplAllocateIrpContext()                                           \
    (PUL_IRP_CONTEXT)(PplAllocate(                                          \
        g_pUlNonpagedData->IrpContextLookaside                              \
        ))

#define UlPplFreeIrpContext( pContext )                                     \
    PplFree(                                                                \
        g_pUlNonpagedData->IrpContextLookaside,                             \
        (pContext)                                                          \
        )

PVOID
UlAllocateIrpContextPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeIrpContextPool(
    IN PVOID pBuffer
    );


//
// Buffer allocators.
//

#define UlPplAllocateReceiveBuffer()                                        \
    (PUL_RECEIVE_BUFFER)(PplAllocate(                                       \
        g_pUlNonpagedData->ReceiveBufferLookaside                           \
        ))

#define UlPplFreeReceiveBuffer( pBuffer )                                   \
    PplFree(                                                                \
        g_pUlNonpagedData->ReceiveBufferLookaside,                          \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateReceiveBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeReceiveBufferPool(
    IN PVOID pBuffer
    );


//
// Request buffer allocators.
//

#define UlPplAllocateRequestBuffer()                                        \
    (PUL_REQUEST_BUFFER)(PplAllocate(                                       \
        g_pUlNonpagedData->RequestBufferLookaside                           \
        ))

#define UlPplFreeRequestBuffer( pBuffer )                                   \
    PplFree(                                                                \
        g_pUlNonpagedData->RequestBufferLookaside,                          \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateRequestBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeRequestBufferPool(
    IN PVOID pBuffer
    );


//
// Internal request buffer allocators.
//

#define UlPplAllocateInternalRequest()                                      \
    (PUL_INTERNAL_REQUEST)(PplAllocate(                                     \
        g_pUlNonpagedData->InternalRequestLookaside                         \
        ))

#define UlPplFreeInternalRequest( pBuffer )                                 \
    PplFree(                                                                \
        g_pUlNonpagedData->InternalRequestLookaside,                        \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateInternalRequestPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeInternalRequestPool(
    IN PVOID pBuffer
    );


//
// Chunk tracker allocators.
//

#define UlPplAllocateChunkTracker()                                         \
    (PUL_CHUNK_TRACKER)(PplAllocate(                                        \
        g_pUlNonpagedData->ChunkTrackerLookaside                            \
        ))

#define UlPplFreeChunkTracker( pBuffer )                                    \
    PplFree(                                                                \
        g_pUlNonpagedData->ChunkTrackerLookaside,                           \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateChunkTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeChunkTrackerPool(
    IN PVOID pBuffer
    );


//
// Full tracker allocators.
//

#define UlPplAllocateFullTracker()                                          \
    (PUL_FULL_TRACKER)(PplAllocate(                                         \
        g_pUlNonpagedData->FullTrackerLookaside                             \
        ))

#define UlPplFreeFullTracker( pBuffer )                                     \
    PplFree(                                                                \
        g_pUlNonpagedData->FullTrackerLookaside,                            \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateFullTrackerPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeFullTrackerPool(
    IN PVOID pBuffer
    );


//
// Internal response buffer allocators.
//

#define UlPplAllocateResponseBuffer()                                       \
    (PUL_INTERNAL_RESPONSE)(PplAllocate(                                    \
        g_pUlNonpagedData->ResponseBufferLookaside                          \
        ))

#define UlPplFreeResponseBuffer( pBuffer )                                  \
    PplFree(                                                                \
        g_pUlNonpagedData->ResponseBufferLookaside,                         \
        (pBuffer)                                                           \
        )

PVOID
UlAllocateResponseBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeResponseBufferPool(
    IN PVOID pBuffer
    );


//
// Log buffer allocators.
//

__inline
PUL_LOG_FILE_BUFFER
FASTCALL
UlPplAllocateLogBuffer(
    VOID
    )
{
    PUL_LOG_FILE_BUFFER pBuffer;

    PAGED_CODE();

    pBuffer = (PUL_LOG_FILE_BUFFER)
                PplAllocate(
                    g_pUlNonpagedData->LogBufferLookaside
                    );

    if (pBuffer)
    {
        ASSERT(pBuffer->Signature == MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG));
        pBuffer->Signature = UL_LOG_FILE_BUFFER_POOL_TAG;
    }

    return pBuffer;
}

__inline
VOID
FASTCALL
UlPplFreeLogBuffer(
    IN PUL_LOG_FILE_BUFFER pBuffer
    )
{
    PAGED_CODE();
    IS_VALID_LOG_FILE_BUFFER(pBuffer);

    pBuffer->BufferUsed = 0;
    pBuffer->Signature = MAKE_FREE_TAG(UL_LOG_FILE_BUFFER_POOL_TAG);

    PplFree(
        g_pUlNonpagedData->LogBufferLookaside,
        pBuffer
        );
}

PVOID
UlAllocateLogBufferPool(
    IN POOL_TYPE PoolType,
    IN SIZE_T ByteLength,
    IN ULONG Tag
    );

VOID
UlFreeLogBufferPool(
    IN PVOID pBuffer
    );


//
// Trivial macro that should probably be in ntos\inc\io.h.
//

#define UlUnmarkIrpPending( Irp ) ( \
    IoGetCurrentIrpStackLocation( (Irp) )->Control &= ~SL_PENDING_RETURNED )


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\precomp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This is the local header file for UL. It includes all other
    necessary header files for UL.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define __HTTP_SYS__

//
// System include files.
//

#ifdef __cplusplus
extern "C" {
#endif

// Need this hack until somebody expose
// the QoS Guids in a kernel lib.
#ifndef INITGUID
#define INITGUID
#endif

#define PsThreadType _PsThreadType_
#include <ntosp.h>
#undef PsThreadType
extern POBJECT_TYPE *PsThreadType;

#include <zwapi.h>
//#include <fsrtl.h>
//#include <ntifs.h>

#include <ntddtcp.h>
#include <ipexport.h>
#include <tdikrnl.h>
#include <tdiinfo.h>
#include <tcpinfo.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

//
// NT QoS Stuff Related Include files
//
#include <wmistr.h>
#include <ntddndis.h>
#include <qos.h>
#include <traffic.h>
#include <Ipinfo.h>
#include <Llinfo.h>

//
// Stop using the local copies of this headers
// and use them frm public\internal\net\inc when
// they are available.
//
#include <ntddtc.h>
#include <gpcifc.h>
#include <gpcstruc.h>

#ifdef __cplusplus
} // extern "C"
#endif


//
// Force the memxxx() functions to be intrinsics so we can build
// the driver even if MSC_OPTIMIZATION=/Od is specified. This is
// necessary because the memxxx() functions are not exported by
// NTOSKRNL.
//

#pragma intrinsic( memcmp, memcpy, memset )

//
// Fake up some Windows types for kernel mode
//

typedef unsigned long       DWORD;
typedef unsigned int        UINT;
typedef unsigned char       BYTE;
typedef BYTE*               PBYTE;

//
// Project include files.
//

#include "nt4hack.h"
#include <http.h>


// Local include files.
//

#pragma warning( disable: 4200 )    //  zero length arrays

#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

#include "hashfn.h"
#include "iisdef.h"
#include "config.h"
#include "pplasl.h"
#include "debug.h"
#include "notify.h"
#include "rwlock.h"
#include "type.h"
#include "tracelog.h"
#include "reftrace.h"
#include "ownerref.h"
#include "irptrace.h"
#include "timetrace.h"
#include "largemem.h"
#include "pipeline.h"
#include "pipelinep.h"
#include "mdlutil.h"
#include "opaqueid.h"
#include "httptdi.h"
#include "thrdpool.h"
#include "filterp.h"
#include "filter.h"
#include "filtqtrace.h"
#include "ioctl.h"
#include "cgroup.h"
#include "ullog.h"
#include "cache.h"
#include "data.h"
#include "httptypes.h"
#include "misc.h"
#include "ultdi.h"
#include "ultdip.h"
#include "repltrace.h"
#include "engine.h"
#include "parse.h"
#include "apool.h"
#include "httpconn.h"
#include "filecache.h"
#include "sendresponse.h"
#include "proc.h"
#include "httprcv.h"
#include "opaqueidp.h"
#include "control.h"
#include "ultci.h"
#include "counters.h"
#include "seutil.h"
#include "ultcip.h"
#include "fastio.h"
#include "timeouts.h"
#include "hash.h"

// BUGBUG: should not need to declare these

NTKERNELAPI
BOOLEAN
FsRtlMdlReadDev (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
BOOLEAN
FsRtlMdlReadCompleteDev (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

NTKERNELAPI
VOID
SeOpenObjectAuditAlarm (
    IN PUNICODE_STRING ObjectTypeName,
    IN PVOID Object OPTIONAL,
    IN PUNICODE_STRING AbsoluteObjectName OPTIONAL,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN PACCESS_STATE AccessState,
    IN BOOLEAN ObjectCreated,
    IN BOOLEAN AccessGranted,
    IN KPROCESSOR_MODE AccessMode,
    OUT PBOOLEAN GenerateOnClose
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\refaction.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    refaction.h

Abstract:

    Action codes for reftracing http.sys. The !ulkd.ref debugger extension
    uses this file with a different definition of REF_ACTION() to
    print out symbolic information.

--*/

//
// Action codes.
//

#ifndef BEGIN_REF_ACTION
# define BEGIN_REF_ACTION()     enum REFTRACE_ACTION {
# define END_REF_ACTION()       };
# define REF_ACTION(x)          REF_ACTION_##x ,
#endif // !BEGIN_REF_ACTION

BEGIN_REF_ACTION()
    REF_ACTION( NO_OP )  // == 0
    
    REF_ACTION( REFERENCE_ENDPOINT )
    REF_ACTION( DEREFERENCE_ENDPOINT )

    REF_ACTION( REFERENCE_CONNECTION )
    REF_ACTION( DEREFERENCE_CONNECTION )

    REF_ACTION( CLOSE_UL_CONNECTION_GRACEFUL )
    REF_ACTION( CLOSE_UL_CONNECTION_ABORTIVE )
    REF_ACTION( CLOSE_UL_CONNECTION_RAW_CLOSE )
    REF_ACTION( DRAIN_UL_CONNECTION_START )
    REF_ACTION( DRAIN_UL_CONNECTION_RESTART )
    REF_ACTION( DRAIN_UL_CONNECTION_DISCONNECT_COMPLETE )

    REF_ACTION( INIT )
    REF_ACTION( REPLENISH )
    REF_ACTION( CONNECT )
    REF_ACTION( RESTART_ACCEPT )
    REF_ACTION( DISCONN_ACTIVE )
    REF_ACTION( UNBIND_CONN )
    REF_ACTION( DISCONN_ALL )
    REF_ACTION( FINAL_DEREF )
    REF_ACTION( CONN_CLEANUP )

    REF_ACTION( ADD_URI_ENTRY )
    REF_ACTION( CHECKIN_URI_ENTRY )
    REF_ACTION( CHECKOUT_URI_ENTRY )
    REF_ACTION( FLUSH_URI_ENTRY )
    REF_ACTION( FILTER_URI_ENTRY )
    REF_ACTION( CREATE_URI_ENTRY )
    REF_ACTION( ZOMBIFY_URI_ENTRY )
    REF_ACTION( UNZOMBIFY_URI_ENTRY )
    REF_ACTION( CLEAR_URI_ENTRY )

    REF_ACTION( ALLOCATE_MDL )
    REF_ACTION( FREE_MDL )
    REF_ACTION( SEND_MDL )
    REF_ACTION( SEND_MDL_COMPLETE )

    REF_ACTION( ACQUIRE_RESOURCE_EXCLUSIVE )
    REF_ACTION( ACQUIRE_RESOURCE_SHARED )
    REF_ACTION( RELEASE_RESOURCE )
    REF_ACTION( CONVERT_RESOURCE_EXCLUSIVE_TO_SHARED )
    REF_ACTION( TRY_ACQUIRE_RESOURCE_EXCLUSIVE )

    REF_ACTION( REFERENCE_HTTP_CONNECTION )
    REF_ACTION( DEREFERENCE_HTTP_CONNECTION )
    REF_ACTION( DESTROY_HTTP_CONNECTION )

    REF_ACTION( REFERENCE_HTTP_REQUEST )
    REF_ACTION( DEREFERENCE_HTTP_REQUEST )

    REF_ACTION( INSERT_BUFFER )
    REF_ACTION( INSERT_REQUEST )

    REF_ACTION( REFERENCE_BUFFER )
    REF_ACTION( DEREFERENCE_BUFFER )

    REF_ACTION( REFERENCE_APP_POOL )
    REF_ACTION( DEREFERENCE_APP_POOL )

    REF_ACTION( REFERENCE_CONFIG_GROUP )
    REF_ACTION( DEREFERENCE_CONFIG_GROUP )

    REF_ACTION( REFERENCE_HTTP_RESPONSE )
    REF_ACTION( DEREFERENCE_HTTP_RESPONSE )

    REF_ACTION( REFERENCE_FILTER )
    REF_ACTION( DEREFERENCE_FILTER )

    REF_ACTION( REFERENCE_SITE_COUNTER_ENTRY )
    REF_ACTION( DEREFERENCE_SITE_COUNTER_ENTRY )

    REF_ACTION( REFERENCE_CONFIG_GROUP_INFO )
    REF_ACTION( DEREFERENCE_CONFIG_GROUP_INFO )

    REF_ACTION( REFERENCE_CONNECTION_COUNT_ENTRY )
    REF_ACTION( DEREFERENCE_CONNECTION_COUNT_ENTRY )

    REF_ACTION( REFERENCE_CHUNK_TRACKER )
    REF_ACTION( DEREFERENCE_CHUNK_TRACKER )

    REF_ACTION( REFERENCE_THREAD )
    REF_ACTION( DEREFERENCE_THREAD )

    REF_ACTION( QUEUE_WORK_ITEM )
    REF_ACTION( QUEUE_BLOCKING_ITEM )
    REF_ACTION( CALL_PASSIVE )
    REF_ACTION( FLUSH_WORK_ITEM )
    REF_ACTION( PROCESS_WORK_ITEM )
    REF_ACTION( PUSH_BACK_WORK_ITEM )

    REF_ACTION( MAX )   // *must* be last

END_REF_ACTION();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\repltrace.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    repltrace.cxx

Abstract:

    This module implements an endpoint replenish tracing facility.

Author:

    Michael Courage (mcourage)  3-Oct-2000

Revision History:

--*/


#include "precomp.h"

#if ENABLE_REPL_TRACE

ENDPOINT_SYNCH DummySynch;

/***************************************************************************++

Routine Description:

    Creates a new (empty) replenish trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateReplenishTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    //
    // Init the global placeholder synch value.
    //
    DummySynch.Value = 0;

    //
    // Create the actual log.
    //

    return CreateTraceLog(
               REPLENISH_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(REPLENISH_TRACE_LOG_ENTRY)
               );

}   // CreateReplenishTraceLog


/***************************************************************************++

Routine Description:

    Destroys a replenish trace log buffer created with
    CreateReplenishTraceLog().

Arguments:

    pLog - Supplies the replenish trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyReplenishTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog );

}   // DestroyReplenishTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified replenish trace log.

Arguments:

    pLog - Supplies the log to write to.

    pEndpoint - the endpoint we're tracing

    Previous - the previous replenish state information

    Current - the current replenish state information

    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
WriteReplenishTraceLog(
    IN PTRACE_LOG pLog,
    IN PUL_ENDPOINT pEndpoint,
    IN ENDPOINT_SYNCH Previous,
    IN ENDPOINT_SYNCH Current,
    IN USHORT Action
    )
{
    REPLENISH_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //

    entry.pEndpoint = pEndpoint;
    entry.Previous.Value = Previous.Value;
    entry.Current.Value = Current.Value;
    entry.Action = Action;
    entry.Processor = (USHORT)KeGetCurrentProcessorNumber();

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteReplenishTraceLog


#endif  // ENABLE_REPL_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\reftrace.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    reftrace.cxx

Abstract:

    This module implements a reference count tracing facility.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#if REFERENCE_DEBUG

/***************************************************************************++

Routine Description:

    Creates a new (empty) ref count trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateRefTraceLog(
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               REF_TRACELOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(REF_TRACE_LOG_ENTRY)
               );

}   // CreateRefTraceLog


/***************************************************************************++

Routine Description:

    Destroys a ref count trace log buffer created with CreateRefTraceLog().

Arguments:

    pLog - Supplies the ref count trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyRefTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog );

}   // DestroyRefTraceLog


/***************************************************************************++

Routine Description:

    W/O destroying the ref trace this function simply does reset and cleanup.

Arguments:

    pLog - Supplies the ref count trace log buffer to destroy.

--***************************************************************************/
VOID
ResetRefTraceLog(
    IN PTRACE_LOG pLog
    )
{
    ResetTraceLog( pLog );

}   // ResetTraceLog

/***************************************************************************++

Routine Description:

    Writes a new entry to the specified ref count trace log.

Arguments:

    pLog - Supplies the log to write to.

    pLog2 - Supplies a secondary log to write to.

    Action - Supplies an action code for the new log entry.

    NewRefCount - Supplies the updated reference count.

    pContext - Supplies an uninterpreted context to associate with
        the log entry.

    pFileName - Supplies the filename of the routine writing the log entry.

    LineNumber - Supplies he line number of the routine writing the log
        entry.

--***************************************************************************/
LONGLONG
WriteRefTraceLog(
    IN PTRACE_LOG pLog,
    IN PTRACE_LOG pLog2,
    IN USHORT     Action,
    IN LONG       NewRefCount,
    IN PVOID      pContext,
    IN PVOID      pFileName,
    IN USHORT     LineNumber
    )
{
    REF_TRACE_LOG_ENTRY entry;
    LONGLONG index;

    ASSERT(Action < (1 << REF_TRACE_ACTION_BITS));

    //
    // Initialize the entry.
    //

    RtlGetCallersAddress( &entry.pCaller, &entry.pCallersCaller );

    entry.NewRefCount = NewRefCount;
    entry.pContext = pContext;
    entry.pFileName = pFileName;
    entry.LineNumber = LineNumber;
    entry.Action = Action;
    entry.Processor = (UCHAR)KeGetCurrentProcessorNumber();
    entry.pProcess = PsGetCurrentProcess();
    entry.pThread = PsGetCurrentThread();

    //
    // Write it to the logs.
    //

    WriteTraceLog( g_pMondoGlobalTraceLog, &entry );
    index = WriteTraceLog( pLog, &entry );

    if (pLog2 != NULL)
        index = WriteTraceLog( pLog2, &entry );

    return index;

}   // WriteRefTraceLog

#endif  // REFERENCE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\reftrace.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    reftrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging reference count problems. This module uses the generic
    TRACE_LOG facility in tracelog.h.

    The REF_ACTION_* codes are declared separately in refaction.h

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _REFTRACE_H_
#define _REFTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus

//
// Pull in the action codes
//

#include "refaction.h"


#define REF_TRACE_PROCESSOR_BITS   6  // MAXIMUM_PROCESSORS == 64 on Win64
#define REF_TRACE_ACTION_BITS    (16 - REF_TRACE_PROCESSOR_BITS)

C_ASSERT((1 << REF_TRACE_PROCESSOR_BITS) >= MAXIMUM_PROCESSORS);
C_ASSERT((1 << REF_TRACE_ACTION_BITS) >= REF_ACTION_MAX);


//
// This defines the entry written to the trace log.
//

typedef struct _REF_TRACE_LOG_ENTRY
{
    PVOID     pContext;
    PVOID     pFileName;
    PEPROCESS pProcess;
    PETHREAD  pThread;
    PVOID     pCaller;
    PVOID     pCallersCaller;
    LONG      NewRefCount;
    USHORT    LineNumber;
    USHORT    Action    : REF_TRACE_ACTION_BITS;
    USHORT    Processor : REF_TRACE_PROCESSOR_BITS;

} REF_TRACE_LOG_ENTRY, *PREF_TRACE_LOG_ENTRY;

#define REF_TRACELOG_SIGNATURE ((ULONG) 'gLfR')


//
// Subtract REF_TRACE_OVERHEAD from a power of 2 when calculating the
// number of entries in a reftrace log, to ensure that overall size is
// a nice power of 2 and doesn't spill onto another page. This accounts
// for the size of the TRACE_LOG struct itself and the overhead
// imposed by the pool and the verifier. On x86, a REF_TRACE_LOG_ENTRY
// is currently 32 bytes. If you modify the struct, please recalculate
// REF_TRACE_OVERHEAD and *change the per-object* reftrace logs (in
// UL_CONNECTION, UL_HTTP_CONNECTION, and UL_INTERNAL_REQUEST) accordingly.
//

#define REF_TRACE_OVERHEAD 2        // entries



//
// Manipulators.
//

PTRACE_LOG
CreateRefTraceLog(
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader
    );

VOID
DestroyRefTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
ResetRefTraceLog(
    IN PTRACE_LOG pLog
    );

LONGLONG
WriteRefTraceLog(
    IN PTRACE_LOG pLog,
    IN PTRACE_LOG pLog2,
    IN USHORT     Action,
    IN LONG       NewRefCount,
    IN PVOID      pContext,
    IN PVOID      pFileName,
    IN USHORT     LineNumber
    );


#if REFERENCE_DEBUG

#define CREATE_REF_TRACE_LOG( ptr, size, extra )                            \
    (ptr) = CreateRefTraceLog( (size), (extra) )

#define DESTROY_REF_TRACE_LOG( ptr )                                        \
    do                                                                      \
    {                                                                       \
        DestroyRefTraceLog( ptr );                                          \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define RESET_REF_TRACE_LOG( ptr )                                          \
    ResetRefTraceLog( ptr )

#define WRITE_REF_TRACE_LOG( plog, act, ref, pctx, pfile, line )            \
    WriteRefTraceLog(                                                       \
        (plog),                                                             \
        NULL,                                                               \
        (act),                                                              \
        (ref),                                                              \
        (pctx),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#define WRITE_REF_TRACE_LOG2( plog1, plog2, act, ref, pctx, pfile, line )   \
    WriteRefTraceLog(                                                       \
        (plog1),                                                            \
        (plog2),                                                            \
        (act),                                                              \
        (ref),                                                              \
        (pctx),                                                             \
        (pfile),                                                            \
        (line)                                                              \
        )

#else // !REFERENCE_DEBUG

#define CREATE_REF_TRACE_LOG( ptr, size, extra )
#define DESTROY_REF_TRACE_LOG( ptr )
#define RESET_REF_TRACE_LOG( ptr )
#define WRITE_REF_TRACE_LOG( plog, act, ref, pctx, pfile, line )
#define WRITE_REF_TRACE_LOG2( plog1, plog2 , act, ref, pctx, pfile, line )

#endif // !REFERENCE_DEBUG


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REFTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\repltrace.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    repltrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging the endpoint replenish code.

Author:

    Michael Courage (mcourage)  3-Oct-2000

Revision History:

--*/


#ifndef _REPLTRACE_H_
#define _REPLTRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus

//
// Globals.
//

extern ENDPOINT_SYNCH DummySynch;

//
// This defines the entry written to the trace log.
//

typedef struct _REPLENISH_TRACE_LOG_ENTRY
{
    PUL_ENDPOINT            pEndpoint;
    ENDPOINT_SYNCH          Previous;
    ENDPOINT_SYNCH          Current;
    USHORT                  Action;
    USHORT                  Processor;

} REPLENISH_TRACE_LOG_ENTRY, *PREPLENISH_TRACE_LOG_ENTRY;

//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\replenish.c.
//

#define REPLENISH_ACTION_START_REPLENISH            0
#define REPLENISH_ACTION_END_REPLENISH              1
#define REPLENISH_ACTION_QUEUE_REPLENISH            2
#define REPLENISH_ACTION_INCREMENT                  3
#define REPLENISH_ACTION_DECREMENT                  4

#define REPLENISH_ACTION_COUNT                      5

#define REPLENISH_TRACE_LOG_SIGNATURE   ((LONG)'gLpR')

//
// Manipulators.
//

PTRACE_LOG
CreateReplenishTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyReplenishTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteReplenishTraceLog(
    IN PTRACE_LOG pLog,
    IN PUL_ENDPOINT pEndpoint,
    IN ENDPOINT_SYNCH Previous,
    IN ENDPOINT_SYNCH Current,
    IN USHORT Action
    );


#if ENABLE_REPL_TRACE

#define CREATE_REPLENISH_TRACE_LOG( ptr, size, extra )                      \
    (ptr) = CreateReplenishTraceLog( (size), (extra) )

#define DESTROY_REPLENISH_TRACE_LOG( ptr )                                  \
    do                                                                      \
    {                                                                       \
        DestroyReplenishTraceLog( ptr );                                    \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define WRITE_REPLENISH_TRACE_LOG( plog, pendp, prev, cur, act )            \
    WriteReplenishTraceLog(                                                 \
        (plog),                                                             \
        (pendp),                                                            \
        (prev),                                                             \
        (cur),                                                              \
        (act)                                                               \
        )

#else   // !ENABLE_REPL_TRACE

#define CREATE_REPLENISH_TRACE_LOG( ptr, size, extra )
#define DESTROY_REPLENISH_TRACE_LOG( ptr )
#define WRITE_REPLENISH_TRACE_LOG( plog, pendp, prev, cur, act )

#endif  // ENABLE_REPL_TRACE

#define TRACE_REPLENISH( pendp, prev, cur, act )                                         \
    WRITE_REPLENISH_TRACE_LOG(                                              \
        g_pReplenishTraceLog,                                               \
        (pendp),                                                            \
        (prev),                                                             \
        (cur),                                                              \
        (act)                                                               \
        )

#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _REPLTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\sendresponse.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    sendresponse.cxx

Abstract:

    This module implements the UlSendHttpResponse() API.

    CODEWORK: The current implementation is not super performant.
    Specifically, it ends up allocating & freeing a ton of IRPs to send
    a response. There are a number of optimizations that need to be made
    to this code:

        1.  Coalesce contiguious from-memory chunks and send them
            with a single TCP send.

        2.  Defer sending the from-memory chunks until either

                a)  We reach the end of the response

                b)  We reach a from-file chunk, have read the
                    (first?) block of data from the file,
                    and are ready to send the first block. Also,
                    after that last (only?) file block is read and
                    subsequent from-memory chunks exist in the response,
                    we can attach the from-memory chunks before sending.

            The end result of these optimizations is that, for the
            common case (one or more from-memory chunks containing
            response headers, followed by one from-file chunk containing
            static file data, followed by zero or more from-memory chunks
            containing footer data) the response can be sent with a single
            TCP send. This is a Good Thing.

        3.  Build a small "IRP pool" in the send tracker structure,
            then use this pool for all IRP allocations. This will
            require a bit of work to determine the maximum IRP stack
            size needed.

        4.  Likewise, build a small "MDL pool" for the MDLs that need
            to be created for the various MDL chains. Keep in mind that
            we cannot chain the MDLs that come directly from the captured
            response structure, nor can we chain the MDLs that come back
            from the file system. In both cases, these MDLs are considered
            "shared resources" and we're not allowed to modify them. We
            can, however, "clone" the MDLs and chain the cloned MDLs
            together. We'll need to run some experiments to determine
            if the overhead for cloning a MDL is worth the effort. I
            strongly suspect it will be.

Author:

    Keith Moore (keithmo)       07-Aug-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified to handle
                                                multiple sends

    Michael Courage (mcourage)  15-Jun-1999     Integrated cache functionality
--*/


#include "precomp.h"
#include "iiscnfg.h"
#include "sendresponsep.h"


//
// Private globals.
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlCaptureHttpResponse )
#pragma alloc_text( PAGE, UlPrepareHttpResponse )
#pragma alloc_text( PAGE, UlCleanupHttpResponse )
#pragma alloc_text( PAGE, UlpSendHttpResponseWorker )
#pragma alloc_text( PAGE, UlpSendCompleteWorker )
#pragma alloc_text( PAGE, UlpFreeMdlRuns )

#pragma alloc_text( PAGE, UlSendCachedResponse )
#pragma alloc_text( PAGE, UlCacheAndSendResponse )
#pragma alloc_text( PAGE, UlpBuildCacheEntry )
#pragma alloc_text( PAGE, UlpBuildCacheEntryWorker )
#pragma alloc_text( PAGE, UlpBuildBuildTrackerWorker )
#pragma alloc_text( PAGE, UlpCompleteCacheBuildWorker )
#pragma alloc_text( PAGE, UlpSendCacheEntry )
#pragma alloc_text( PAGE, UlpAllocateCacheTracker )
#pragma alloc_text( PAGE, UlpFreeCacheTracker )
#pragma alloc_text( PAGE, UlpAllocateLockedMdl )
#pragma alloc_text( PAGE, UlpInitializeAndLockMdl )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlSendHttpResponse
NOT PAGEABLE -- UlReferenceHttpResponse
NOT PAGEABLE -- UlDereferenceHttpResponse
NOT PAGEABLE -- UlpDestroyCapturedResponse
NOT PAGEABLE -- UlpAllocateChunkTracker
NOT PAGEABLE -- UlpFreeChunkTracker
NOT PAGEABLE -- UlpCompleteSendRequest
NOT PAGEABLE -- UlpRestartMdlRead
NOT PAGEABLE -- UlpRestartMdlReadComplete
NOT PAGEABLE -- UlpRestartMdlSend
NOT PAGEABLE -- UlpIncrementChunkPointer

NOT PAGEABLE -- UlpRestartCacheMdlRead
NOT PAGEABLE -- UlpRestartCacheMdlFree
NOT PAGEABLE -- UlpIssueFileChunkIo
NOT PAGEABLE -- UlpCompleteCacheBuild
NOT PAGEABLE -- UlpCompleteSendCacheEntry
NOT PAGEABLE -- UlpCheckCacheControlHeaders
NOT PAGEABLE -- UlpCompleteSendRequestWorker
NOT PAGEABLE -- UlpCompleteSendCacheEntryWorker
NOT PAGEABLE -- UlpFreeLockedMdl
NOT PAGEABLE -- UlpIsAcceptHeaderOk
NOT PAGEABLE -- UlpGetTypeAndSubType

#endif



//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Sends an HTTP response on the specified connection.

Arguments:

    pConnection - Supplies the HTTP_CONNECTION to send the response on.

    pResponse - Supplies the HTTP response.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the send has completed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN ULONG Flags,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;
    PUL_CHUNK_TRACKER pTracker;
    PUL_HTTP_CONNECTION pHttpConn;
    UL_CONN_HDR ConnHeader;
    BOOLEAN Disconnect;
    ULONG VarHeaderGenerated;
    ULONGLONG TotalResponseSize;
    ULONG contentLengthStringLength;
    UCHAR contentLength[MAX_ULONGLONG_STR];
    BOOLEAN CompleteEarly;

    pHttpConn = pRequest->pHttpConn;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION( pHttpConn ) );

    //
    // do a little tracing
    //
    TRACE_TIME(
        pRequest->ConnectionId,
        pRequest->RequestId,
        TIME_ACTION_SEND_RESPONSE
        );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pTracker = NULL;
    CompleteEarly = FALSE;

    //
    // Tracker will keep a reference to the connection
    //
    UL_REFERENCE_HTTP_CONNECTION(pHttpConn);

    //
    // Should we close the connection?
    //

    Disconnect = FALSE;

    if ((Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) == 0)
    {
        if ((Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) != HTTP_SEND_RESPONSE_FLAG_MORE_DATA)
        {
            //
            // No more data is coming, should we disconnect?
            //

            if ( UlCheckDisconnectInfo(pRequest) ) {
                Disconnect = TRUE;
                Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
            }
        }
    }
    else
    {
        //
        // Caller is forcing a disconnect.
        //

        Disconnect = TRUE;
    }

    //
    // how big is the response? (keep track for early complete)
    //

    TotalResponseSize = pResponse->ResponseLength;

    //
    // figure out what space we need for variable headers
    //

    if ((pResponse->HeaderLength > 0) &&        // response (not entity body)
        !pResponse->ContentLengthSpecified &&   // app didn't provide content length
        !pResponse->ChunkedSpecified &&         // app didn't generate a chunked response
        UlNeedToGenerateContentLength(
            pRequest->Verb,
            pResponse->StatusCode,
            Flags
            ))
    {
        //
        // Autogenerate a content-length header.
        //

        PCHAR pszEnd = UlStrPrintUlonglong(
                           (PCHAR) contentLength,
                           pResponse->ResponseLength - pResponse->HeaderLength,
                           '\0');
        contentLengthStringLength = DIFF(pszEnd - (PCHAR) contentLength);
    }
    else
    {
        //
        // Either we cannot or do not need to autogenerate a
        // content-length header.
        //

        contentLength[0] = '\0';
        contentLengthStringLength = 0;
    }

    ConnHeader = UlChooseConnectionHeader( pRequest->Version, Disconnect );

    //
    // Allocate and initialize a tracker for this request.
    //

    pTracker =
        UlpAllocateChunkTracker(
            UlTrackerTypeSend,
            pHttpConn->pConnection->ConnectionObject.pDeviceObject->StackSize,
            pResponse->MaxFileSystemStackSize,
            pHttpConn,
            Flags,
            pRequest,
            pResponse,
            pCompletionRoutine,
            pCompletionContext
            );

    if (pTracker == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto cleanup;
    }

    UlpInitMdlRuns( pTracker );

    //
    // generate var headers, and init the second chunk
    //

    if (pResponse->HeaderLength)
    {
        UlGenerateVariableHeaders(
            ConnHeader,
            contentLength,
            contentLengthStringLength,
            pTracker->pVariableHeader,
            &VarHeaderGenerated,
            &pResponse->CreationTime
            );

        ASSERT( VarHeaderGenerated <= g_UlMaxVariableHeaderSize );

        pTracker->VariableHeaderLength = VarHeaderGenerated;

        //
        // increment total size
        //
        TotalResponseSize += VarHeaderGenerated;

        //
        // build an mdl for it
        //

        pResponse->pDataChunks[1].ChunkType = HttpDataChunkFromMemory;
        pResponse->pDataChunks[1].FromMemory.BufferLength = VarHeaderGenerated;

        pResponse->pDataChunks[1].FromMemory.pMdl =
            UlAllocateMdl(
                pTracker->pVariableHeader,  // VirtualAddress
                VarHeaderGenerated,         // Length
                FALSE,                      // SecondaryBuffer
                FALSE,                      // ChargeQuota
                NULL                        // Irp
                );

        if (pResponse->pDataChunks[1].FromMemory.pMdl == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        MmBuildMdlForNonPagedPool(
            pResponse->pDataChunks[1].FromMemory.pMdl
            );
    }

    //
    // see if we're supposed to do an early completion call
    //
    if (pResponse->CompleteIrpEarly &&
        (TotalResponseSize < MAX_BYTES_BUFFERED) &&
        (pResponse->ChunkCount < MAX_MDL_RUNS))
    {
        //
        // NULL out the tracker's completion routine so it
        // won't try to complete the request later.
        //
        pTracker->pCompletionRoutine = NULL;

        //
        // Remember that we're supposed to complete early
        // but don't do it until after we've initiated
        // the actual TCP send.
        //
        CompleteEarly = TRUE;

    }

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlSendHttpResponse: tracker %p, response %p\n",
            pTracker,
            pResponse
            ));
    }

    //
    // Start MinKBSec timer, since we now know TotalResponseSize
    //

    UlSetMinKBSecTimer(
        &pHttpConn->TimeoutInfo,
        TotalResponseSize
        );

    //
    // RefCount the chunk tracker up for the UlpSendHttpResponseWorker.
    // It will DeRef it when it's done with the chunk tracker itself.
    //

    UL_REFERENCE_CHUNK_TRACKER( pTracker );

    //
    // Let the worker do the dirty work, no reason to queue off
    // it will queue the first time it needs to do blocking i/o
    //

    UlpSendHttpResponseWorker(&pTracker->WorkItem);

    //
    // If we're supposed to complete early, do it now.
    //
    if (CompleteEarly)
    {
        //
        // do the completion
        //
        UlpCompleteSendIrpEarly(
            pCompletionRoutine,
            pCompletionContext,
            STATUS_SUCCESS,
            TotalResponseSize
            );
    }

    //
    // Release the original reference on the chunk tracker. So that it get
    // freed up as soon as all the outstanding IO initiated by the
    // UlpSendHttpResponseWorker is complete. This dereference matches with
    // our allocation.
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

    return STATUS_PENDING;

cleanup:

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlSendHttpResponse: failure %08lx\n",
            status
            ));
    }

    ASSERT( !NT_SUCCESS(status) );

    if (pTracker != NULL)
    {
        //
        // Very early termination for the chunk tracker. RefCounting not
        // even started yet. ( Means UlpSendHttpResponseWorker hasn't been
        // called ). Therefore straight cleanup.
        //

        ASSERT( pTracker->RefCount == 1 );

        UlpFreeChunkTracker( pTracker );
    }

    //
    // Tracker doesn't have a reference after all..
    //
    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);

    return status;

}   // UlSendHttpResponse


/***************************************************************************++

Routine Description:

    Captures a user-mode HTTP response and morphs it into a form suitable
    for kernel-mode.

Arguments:

    pUserResponse - Supplies the user-mode HTTP response.

    Flags - Supplies zero or more UL_CAPTURE_* flags.

    pKernelResponse - Receives the captured response if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCaptureHttpResponse(
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN HTTP_VERSION Version,
    IN HTTP_VERB Verb,
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pUserDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    IN BOOLEAN CaptureCache,
    IN PHTTP_LOG_FIELDS_DATA pUserLogData OPTIONAL,
    OUT PUL_INTERNAL_RESPONSE *ppKernelResponse
    )
{
    ULONG                       i;
    NTSTATUS                    Status = STATUS_SUCCESS;
    PUL_INTERNAL_RESPONSE       pKeResponse = NULL;
    ULONG                       AuxBufferLength;
    ULONG                       CopiedBufferLength;
    ULONG                       UncopiedBufferLength;
    ULONGLONG                   FromFileLength;
    BOOLEAN                     CompleteEarly;
    PUCHAR                      pBuffer;
    USHORT                      FileLength;
    ULONG                       HeaderLength;
    ULONG                       SpaceLength;
    PUL_INTERNAL_DATA_CHUNK     pKeDataChunks;
    BOOLEAN                     FromKernelMode;
    BOOLEAN                     IsFromLookaside;
    BOOLEAN                     BufferedSend = TRUE;
    ULONG                       KernelChunkCount;
    PHTTP_KNOWN_HEADER          pETagHeader = NULL;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pUserDataChunks != NULL || ChunkCount == 0);
    ASSERT(ppKernelResponse != NULL);

    __try
    {
        FromKernelMode = ((Flags & UlCaptureKernelMode) == UlCaptureKernelMode);
        
        //
        // ProbeTestForRead every buffer we will access
        //

        if (!FromKernelMode) {
            Status = UlpProbeHttpResponse(
                            pUserResponse,
                            ChunkCount,
                            pUserDataChunks,
                            Flags,
                            pUserLogData
                            );

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }
        }

        //
        // figure out how much memory we need
        //
        Status = UlComputeFixedHeaderSize(
                        Version,
                        pUserResponse,
                        &HeaderLength
                        );

        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        UlpComputeChunkBufferSizes(
            ChunkCount,     // number of chunks
            pUserDataChunks,    // array of chunks
            Flags,          // capture flags
            &AuxBufferLength,
            &CopiedBufferLength,
            &UncopiedBufferLength,
            &FromFileLength
            );

        //
        // check if we can still buffer sends
        //
        if ((Flags & UlCaptureCopyData) == 0 &&
            (CopiedBufferLength + pRequest->pHttpConn->SendBufferedBytes)
                > g_UlMaxSendBufferedBytes)
        {
            BufferedSend = FALSE;
        }

        //
        // see if we can complete the IRP early
        //
        if (BufferedSend && (UncopiedBufferLength + FromFileLength) == 0)
        {
            //
            // we've got all the data in the kernel, so
            // we can just tell user mode it's done.
            //
            CompleteEarly = TRUE;
        }
        else
        {
            //
            // we're using a handle or buffer from user space
            // so they have to wait for us to finish for real.
            //
            CompleteEarly = FALSE;
        }

        UlTrace(SEND_RESPONSE, (
            "Http!UlCaptureHttpResponse(pUserResponse = %p) "
            "CompleteEarly = %s\n"
            "    ChunkCount             = %d\n"
            "    Flags                  = 0x%x\n"
            "    AuxBufferLength        = 0x%x\n"
            "    UncopiedBufferLength   = 0x%x\n"
            "    FromFileLength         = 0x%I64x\n",
            pUserResponse,
            CompleteEarly ? "TRUE" : "FALSE",
            ChunkCount,
            Flags,
            AuxBufferLength,
            UncopiedBufferLength,
            FromFileLength
            ));

        //
        // add two extra chunks for the headers (fixed & variable)
        //

        if (HeaderLength > 0)
        {
            KernelChunkCount = ChunkCount + HEADER_CHUNK_COUNT;
        }
        else
        {
            KernelChunkCount = ChunkCount;
        }

        //
        // compute the space needed for all of our structures
        //

        SpaceLength = (KernelChunkCount * sizeof(UL_INTERNAL_DATA_CHUNK))
            + ALIGN_UP(HeaderLength, sizeof(CHAR))
            + AuxBufferLength;

        //
        // Add space for ETag, if it exists.
        //
        if (CaptureCache &&
            pUserResponse &&
            pUserResponse->Headers.pKnownHeaders[HttpHeaderEtag].RawValueLength)
        {
            pETagHeader = &pUserResponse->Headers.pKnownHeaders[HttpHeaderEtag];
            SpaceLength += (pETagHeader->RawValueLength + sizeof(CHAR)); // Add space for NULL

            UlTrace(SEND_RESPONSE, (
                "ul!UlCaptureHttpResponse(pUserResponse = %p) \n"
                "    ETag: %s \n"
                "    Length: %d\n",
                pUserResponse,
                pETagHeader->pRawValue,
                pETagHeader->RawValueLength
                ));
        }
    
        //
        // allocate the internal response.
        //

        if (g_UlResponseBufferSize
                < (ALIGN_UP(sizeof(UL_INTERNAL_RESPONSE), PVOID) + SpaceLength)
            )
        {
            pKeResponse = UL_ALLOCATE_STRUCT_WITH_SPACE(
                NonPagedPool,
                UL_INTERNAL_RESPONSE,
                SpaceLength,
                UL_INTERNAL_RESPONSE_POOL_TAG
                );
            IsFromLookaside = FALSE;
        }
        else
        {
            pKeResponse = UlPplAllocateResponseBuffer();
            IsFromLookaside = TRUE;
        }

        if (pKeResponse == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto end;
        }
    
        //
        // Initialize the fixed fields in the response.
        //

        pKeResponse->IsFromLookaside = IsFromLookaside;

        pKeResponse->Signature = UL_INTERNAL_RESPONSE_POOL_TAG;
        pKeResponse->ReferenceCount = 1;
        pKeResponse->ChunkCount = KernelChunkCount;

        RtlZeroMemory(
            pKeResponse->pDataChunks,
            sizeof(UL_INTERNAL_DATA_CHUNK) * KernelChunkCount
            );

        pKeResponse->ContentLengthSpecified = FALSE;
        pKeResponse->ChunkedSpecified = FALSE;
        pKeResponse->ResponseLength = 0;
        pKeResponse->MaxFileSystemStackSize = 0;
        pKeResponse->CreationTime.QuadPart = 0;
        pKeResponse->ETagLength = 0;
        pKeResponse->pETag = NULL;

        RtlZeroMemory(
            &pKeResponse->ContentType,
            sizeof(UL_CONTENT_TYPE)
            );

        //
        // Remember how much we have buffered.
        //

        if (BufferedSend)
        {
            pKeResponse->SendBufferedBytes = CopiedBufferLength;
        }
        else
        {
            pKeResponse->SendBufferedBytes = 0;
        }

        //
        // Remember if it's ok to do early IRP completion.
        //

        pKeResponse->CompleteIrpEarly = CompleteEarly;

        //
        // point to the header buffer space
        //

        pKeResponse->HeaderLength = HeaderLength;
        pKeResponse->pHeaders =
            (PUCHAR)(pKeResponse->pDataChunks + pKeResponse->ChunkCount);

        //
        // and the aux buffer space
        //

        pKeResponse->AuxBufferLength = AuxBufferLength;
        pKeResponse->pAuxiliaryBuffer = (PVOID)(
                    pKeResponse->pHeaders +
                    ALIGN_UP(HeaderLength, sizeof(CHAR))
                    );
        //
        // and the ETag buffer space
        //
        if (pETagHeader)
        {
            pKeResponse->ETagLength = pETagHeader->RawValueLength + 1; // Add space for NULL
            pKeResponse->pETag = ((PUCHAR)pKeResponse->pAuxiliaryBuffer) +
                AuxBufferLength;
        }

        //
        // Capture the logging data if it exists. Allocate an internal
        // log data buffer. This buffer will be released later when we 
        // are done with logging the stuff, either before freeing the 
        // chunk trucker (in UlpCompleteSendRequestWorker) or before
        // freeing the cache tracker (in UlpCompleteSendCacheEntryWorker)
        // please see the definition of UlLogHttpHit.
        //

        ASSERT( pRequest != NULL || pUserLogData == NULL);
 
        if (NULL != pUserLogData && 
            1 == pRequest->SentLast && 
            pRequest->ConfigInfo.pLoggingConfig)
        {
            pKeResponse->pLogData = &pRequest->LogData;

            Status = UlAllocateLogDataBuffer( 
                            pKeResponse->pLogData, 
                            pRequest,
                            pRequest->ConfigInfo.pLoggingConfig 
                            );
            ASSERT(NT_SUCCESS(Status));

            Status = UlCaptureLogFields(
                            pUserLogData,
                            Version,
                            pKeResponse->pLogData
                            );             
            if (!NT_SUCCESS(Status)) 
            {
                goto end;
            }        
        }
        else
        {
            //
            // User didn't pass down a log buffer so no need to 
            // do logging for this response. Or it's possible that
            // user passed down log buffer but logging wasn't enabled
            //

            pKeResponse->pLogData = NULL;
        }

        //
        // User didn't pass down a log buffer so no need to
        // do logging for this response. Or it's possible that
        // user passed down log buffer but logging wasn't enabled
        //

        //
        // Remember if a Content-Length header was specified.
        //

        if (pUserResponse != NULL)
        {
            pKeResponse->StatusCode = pUserResponse->StatusCode;
            pKeResponse->Verb = Verb;

            if (pUserResponse->Headers.pKnownHeaders[HttpHeaderContentLength].RawValueLength > 0)
            {
                pKeResponse->ContentLengthSpecified = TRUE;
            }

            //
            // As long as we're here, also remember if "Chunked"
            // Transfer-Encoding was specified.
            //

            if (pUserResponse->Headers.pKnownHeaders[HttpHeaderTransferEncoding].RawValueLength > 0 &&
                (0 == _strnicmp(pUserResponse->Headers.pKnownHeaders[HttpHeaderTransferEncoding].pRawValue,
                                "chunked",
                                sizeof("chunked")-1)))
            {
                // NOTE: If a response has a chunked Transfer-Encoding,
                // then it shouldn't have a Content-Length
                ASSERT(!pKeResponse->ContentLengthSpecified);
                pKeResponse->ChunkedSpecified = TRUE;
            }

            //
            // Only capture the following if we're building a cached response
            //
            if ( CaptureCache )
            {
                //
                // Capture the ETag and put it on the UL_INTERNAL_RESPONSE
                //

                if (pETagHeader)
                {
                    RtlCopyMemory(
                        pKeResponse->pETag,     // Dest
                        pETagHeader->pRawValue, // Src
                        pKeResponse->ETagLength // Bytes
                        );

                    // Add NULL termination
                    //
                    pKeResponse->pETag[pETagHeader->RawValueLength] = '\0';
                }

                //
                // Capture the ContentType and put it on the UL_INTERNAL_RESPONSE
                //
                if (pUserResponse->Headers.pKnownHeaders[HttpHeaderContentType].RawValueLength > 0)
                {
                    UlpGetTypeAndSubType(
                        pUserResponse->Headers.pKnownHeaders[HttpHeaderContentType].pRawValue,
                        pUserResponse->Headers.pKnownHeaders[HttpHeaderContentType].RawValueLength,
                        &pKeResponse->ContentType
                        );

                    UlTrace(SEND_RESPONSE, (
                        "http!UlCaptureHttpResponse(pUserResponse = %p) \n"
                        "    Content Type: %s \n"
                        "    Content SubType: %s\n",
                        pUserResponse,
                        pKeResponse->ContentType.Type,
                        pKeResponse->ContentType.SubType
                        ));

                }

                //
                // Capture the Last-Modified time (if it exists)
                //

                if (pUserResponse->Headers.pKnownHeaders[HttpHeaderLastModified].RawValueLength)
                {
                    StringTimeToSystemTime(
                        (const PSTR)  pUserResponse->Headers.pKnownHeaders[HttpHeaderLastModified].pRawValue,
                        &pKeResponse->CreationTime);
                }
            }

        }

        //
        // copy the aux bytes from the chunks
        //

        pBuffer = (PUCHAR)(pKeResponse->pAuxiliaryBuffer);

        //
        // skip the header chunks
        //

        if (pKeResponse->HeaderLength > 0)
        {
            pKeDataChunks = pKeResponse->pDataChunks + HEADER_CHUNK_COUNT;
        }
        else
        {
            pKeDataChunks = pKeResponse->pDataChunks;
        }

        for (i = 0 ; i < ChunkCount ; i++)
        {
            pKeDataChunks[i].ChunkType = pUserDataChunks[i].DataChunkType;

            switch (pUserDataChunks[i].DataChunkType)
            {
            case HttpDataChunkFromMemory:
                //
                // From-memory chunk. If the caller wants us to copy
                // the data (or if its relatively small), then do it
                // We allocate space for all of the copied data and any
                // filename buffers. Otherwise (it's OK to just lock
                // down the data), then allocate a MDL describing the
                // user's buffer and lock it down. Note that
                // MmProbeAndLockPages() and MmLockPagesSpecifyCache()
                // will raise exceptions if they fail.
                //

                pKeDataChunks[i].FromMemory.pCopiedBuffer = NULL;

                if ((Flags & UlCaptureCopyData) ||
                    pUserDataChunks[i].FromMemory.BufferLength <= g_UlMaxCopyThreshold)
                {
                    ASSERT(pKeResponse->AuxBufferLength > 0);

                    pKeDataChunks[i].FromMemory.pUserBuffer =
                        pUserDataChunks[i].FromMemory.pBuffer;

                    pKeDataChunks[i].FromMemory.BufferLength =
                        pUserDataChunks[i].FromMemory.BufferLength;

                    RtlCopyMemory(
                        pBuffer,
                        pKeDataChunks[i].FromMemory.pUserBuffer,
                        pKeDataChunks[i].FromMemory.BufferLength
                        );

                    pKeDataChunks[i].FromMemory.pCopiedBuffer = pBuffer;
                    pBuffer += pKeDataChunks[i].FromMemory.BufferLength;

                    //
                    // Allocate a new MDL describing our new location
                    // in the auxiliary buffer, then build the MDL
                    // to properly describe nonpaged pool.
                    //

                    pKeDataChunks[i].FromMemory.pMdl =
                        UlAllocateMdl(
                            pKeDataChunks[i].FromMemory.pCopiedBuffer, // VirtualAddress
                            pKeDataChunks[i].FromMemory.BufferLength,  // Length
                            FALSE,                              // SecondaryBuffer
                            FALSE,                              // ChargeQuota
                            NULL                                // Irp
                            );

                    if (pKeDataChunks[i].FromMemory.pMdl == NULL)
                    {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                        break;
                    }

                    MmBuildMdlForNonPagedPool(pKeDataChunks[i].FromMemory.pMdl);

                }
                else
                {
                    //
                    // build an mdl describing the user's buffer
                    //

                    pKeDataChunks[i].FromMemory.BufferLength =
                        pUserDataChunks[i].FromMemory.BufferLength;

                    pKeDataChunks[i].FromMemory.pMdl =
                        UlAllocateMdl(
                            pUserDataChunks[i].FromMemory.pBuffer,      // VirtualAddress
                            pUserDataChunks[i].FromMemory.BufferLength, // Length
                            FALSE,                                  // SecondaryBuffer
                            FALSE,                                  // ChargeQuota
                            NULL                                    // Irp
                            );

                    if (pKeDataChunks[i].FromMemory.pMdl == NULL)
                    {
                        ExRaiseStatus( STATUS_INSUFFICIENT_RESOURCES );
                        break;
                    }

                    //
                    // lock it down
                    //

                    MmProbeAndLockPages(
                        pKeDataChunks[i].FromMemory.pMdl,   // MDL
                        UserMode,                           // AccessMode
                        IoReadAccess                        // Operation
                        );

                    MmMapLockedPagesSpecifyCache(
                        pKeDataChunks[i].FromMemory.pMdl,   // MDL
                        KernelMode,                         // AccessMode
                        MmCached,                           // CacheType
                        NULL,                               // BaseAddress
                        FALSE,                              // BugCheckOnFailure
                        LowPagePriority                     // Priority
                        );
                }

                break;

            case HttpDataChunkFromFileName:

                ASSERT(pKeResponse->AuxBufferLength > 0);

                //
                // It's a filename. buffer's already been probed
                //

                FileLength = pUserDataChunks[i].FromFileName.FileNameLength;

                pKeDataChunks[i].FromFile.FileName.Buffer = (PWSTR)pBuffer;

                pKeDataChunks[i].FromFile.FileName.Length = FileLength;

                pKeDataChunks[i].FromFile.FileName.MaximumLength =
                    FileLength + sizeof(WCHAR);

                pKeDataChunks[i].FromFile.ByteRange =
                    pUserDataChunks[i].FromFileName.ByteRange;

                pKeDataChunks[i].FromFile.pFileCacheEntry = NULL;

                //
                // have to inline convert this fully qualified win32 filename
                // into an nt filename.
                //
                // CODEWORK: need to handle UNC's.
                //

                RtlCopyMemory(
                    pBuffer,
                    L"\\??\\",
                    sizeof(L"\\??\\") - sizeof(WCHAR)
                    );

                pBuffer += sizeof(L"\\??\\") - sizeof(WCHAR);

                //
                // copy the win32 filename (including the terminator)
                //

                RtlCopyMemory(
                    pBuffer,
                    pUserDataChunks[i].FromFileName.pFileName,
                    FileLength + sizeof(WCHAR)
                    );

                pBuffer += FileLength + sizeof(WCHAR);

                //
                // adjust the string sizes for the new prefix
                //

                pKeDataChunks[i].FromFile.FileName.Length +=
                    sizeof(L"\\??\\") - sizeof(WCHAR);

                pKeDataChunks[i].FromFile.FileName.MaximumLength +=
                    sizeof(L"\\??\\") - sizeof(WCHAR);

                break;

            case HttpDataChunkFromFileHandle:

                //
                // From handle.
                //

                pKeDataChunks[i].FromFile.ByteRange =
                    pUserDataChunks[i].FromFileHandle.ByteRange;

                pKeDataChunks[i].FromFile.FileHandle =
                    pUserDataChunks[i].FromFileHandle.FileHandle;


                break;

            default :
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
                break;

            }   // switch (pUserDataChunks[i].DataChunkType)

        }   // for (i = 0 ; i < ChunkCount ; i++)
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Ensure we didn't mess up our buffer calculations.
    //

    ASSERT(DIFF(pBuffer - (PUCHAR)(pKeResponse->pAuxiliaryBuffer)) ==
            AuxBufferLength);

    UlTrace(SEND_RESPONSE, (
        "Http!UlCaptureHttpResponse: captured %p from user %p\n",
        pKeResponse,
        pUserResponse
        ));

end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        if (pKeResponse != NULL)
        {
            UlpDestroyCapturedResponse( pKeResponse );
            pKeResponse = NULL;
        }
    }

    //
    // Return the captured response.
    //

    *ppKernelResponse = pKeResponse;

    RETURN(Status);

}   // UlCaptureHttpResponse


/***************************************************************************++

Routine Description:

    Probes all the buffers passed to use in a user mode http response.

Arguments:

    pUserResponse   - the response to probe
    ChunkCount      - the number of data chunks
    pDataChunks     - the array of data chunks
    Flags           - Capture flags

--***************************************************************************/
NTSTATUS
UlpProbeHttpResponse(
    IN PHTTP_RESPONSE pUserResponse,
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pUserDataChunks,
    IN ULONG Flags,
    IN PHTTP_LOG_FIELDS_DATA pUserLogData
    )
{
    NTSTATUS Status;
    ULONG i;
    PHTTP_UNKNOWN_HEADER pUnknownHeaders;

    Status = STATUS_SUCCESS;

    __try
    {
        //
        // Validate the response.
        //

        if (pUserResponse != NULL)
        {
            if ((pUserResponse->Flags & ~HTTP_RESPONSE_FLAG_VALID) ||
                (pUserResponse->StatusCode > 999))
            {
                ExRaiseStatus( STATUS_INVALID_PARAMETER );
            }
        }

        //
        // Probe the log data if it exists
        //

        if (pUserLogData)
        {
            Status = UlProbeLogData( pUserLogData );
            if (!NT_SUCCESS(Status))
            {
                ExRaiseStatus( Status );
            }
        }

        //
        // first count the headers part
        //

        if (pUserResponse != NULL)
        {
            // check the response structure
            ProbeTestForRead(
                pUserResponse,
                sizeof(HTTP_RESPONSE),
                sizeof(USHORT)
                );

            // check the reason string
            ProbeTestForRead(
                pUserResponse->pReason,
                pUserResponse->ReasonLength,
                sizeof(CHAR)
                );

            //
            // Loop through the known headers.
            //

            for (i = 0; i < HttpHeaderResponseMaximum; ++i)
            {
                USHORT RawValueLength
                    = pUserResponse->Headers.pKnownHeaders[i].RawValueLength;

                if (RawValueLength > 0)
                {
                    ProbeTestForRead(
                        pUserResponse->Headers.pKnownHeaders[i].pRawValue,
                        RawValueLength,
                        sizeof(CHAR)
                        );
                }
            }

            //
            // And the unknown headers (this might throw an exception).
            //

            pUnknownHeaders = pUserResponse->Headers.pUnknownHeaders;

            if (pUnknownHeaders != NULL)
            {
                ProbeTestForRead(
                    pUnknownHeaders,
                    sizeof(HTTP_UNKNOWN_HEADER)
                        * pUserResponse->Headers.UnknownHeaderCount,
                    sizeof(ULONG)
                    );

                for (i = 0 ; i < pUserResponse->Headers.UnknownHeaderCount; ++i)
                {
                    USHORT Length;

                    if (pUnknownHeaders[i].NameLength > 0)
                    {
                            ProbeTestForRead(
                                pUnknownHeaders[i].pName,
                                pUnknownHeaders[i].NameLength,
                                sizeof(CHAR)
                                );

                            ProbeTestForRead(
                                pUnknownHeaders[i].pRawValue,
                                pUnknownHeaders[i].RawValueLength,
                                sizeof(CHAR)
                                );
                    }
                }
            }

        }

        //
        // and now the body part
        //

        if (pUserDataChunks != NULL)
        {
            ProbeTestForRead(
                pUserDataChunks,
                sizeof(HTTP_DATA_CHUNK) * ChunkCount,
                sizeof(PVOID)
                );

            for (i = 0 ; i < ChunkCount ; i++)
            {
                switch (pUserDataChunks[i].DataChunkType)
                {
                case HttpDataChunkFromMemory:
                    //
                    // From-memory chunk.
                    //

                    if (pUserDataChunks[i].FromMemory.BufferLength == 0 ||
                        pUserDataChunks[i].FromMemory.pBuffer == NULL)
                    {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                    if ((Flags & UlCaptureCopyData) ||
                        (pUserDataChunks[i].FromMemory.BufferLength <= g_UlMaxCopyThreshold))
                    {
                        ProbeTestForRead(
                            pUserDataChunks[i].FromMemory.pBuffer,
                            pUserDataChunks[i].FromMemory.BufferLength,
                            sizeof(CHAR)
                            );
                    }

                    break;

                case HttpDataChunkFromFileName:
                    //
                    // From-file chunk. probe the filename buffer.
                    //

                    //
                    // better be a filename there
                    //

                    if (pUserDataChunks[i].FromFileName.FileNameLength == 0 ||
                        pUserDataChunks[i].FromFileName.pFileName == NULL)
                    {
                        ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    }

                    ProbeTestForRead(
                        pUserDataChunks[i].FromFileName.pFileName,
                        pUserDataChunks[i].FromFileName.FileNameLength + sizeof(WCHAR),
                        sizeof(WCHAR)
                        );

                    break;

                case HttpDataChunkFromFileHandle:
                    //
                    // From handle chunk.  the handle will be validated later
                    // by the object manager.
                    //

                    break;


                default :
                    ExRaiseStatus( STATUS_INVALID_PARAMETER );
                    break;

                }   // switch (pUserDataChunks[i].DataChunkType)

            }   // for (i = 0 ; i < ChunkCount ; i++)

        }   // if (pUserDataChunks != NULL)
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Figures out how much space we need in the internal response aux buffer.
    The buffer contains copied memory chunks, and names of files to open.

    CODEWORK: need to be aware of chunk encoding

Arguments:

    ChunkCount  - number of chunks in the array
    pDataChunks - the array of data chunks
    Flags       - capture flags

--***************************************************************************/
VOID
UlpComputeChunkBufferSizes(
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN ULONG Flags,
    OUT PULONG pAuxBufferSize,
    OUT PULONG pCopiedMemorySize,
    OUT PULONG pUncopiedMemorySize,
    OUT PULONGLONG pFromFileSize
    )
{
    ULONG AuxLength = 0;
    ULONG CopiedLength = 0;
    ULONG UncopiedLength = 0;
    ULONGLONG FromFileLength = 0;
    ULONG i;

    for (i = 0; i < ChunkCount; i++)
    {

        switch (pDataChunks[i].DataChunkType)
        {
        case HttpDataChunkFromMemory:
            //
            // if we're going to copy the chunk, then make some space in
            // the aux buffer.
            //
            if ((Flags & UlCaptureCopyData) ||
                (pDataChunks[i].FromMemory.BufferLength <= g_UlMaxCopyThreshold))
            {
                AuxLength += pDataChunks[i].FromMemory.BufferLength;
                CopiedLength += pDataChunks[i].FromMemory.BufferLength;
            } else {
                UncopiedLength += pDataChunks[i].FromMemory.BufferLength;
            }

            break;

        case HttpDataChunkFromFileName:
            //
            // add up the string length
            //

            AuxLength += sizeof(L"\\??\\");
            AuxLength += pDataChunks[i].FromFileName.FileNameLength;

            FromFileLength += pDataChunks[i].FromFileName.ByteRange.Length.QuadPart;

            break;

        case HttpDataChunkFromFileHandle:
            FromFileLength += pDataChunks[i].FromFileHandle.ByteRange.Length.QuadPart;

            break;

        default:
            // we should have caught this in the probe
            ASSERT(!"Invalid chunk type");
            break;

        } // switch

    }

    *pAuxBufferSize = AuxLength;
    *pCopiedMemorySize = CopiedLength;
    *pUncopiedMemorySize = UncopiedLength;
    *pFromFileSize = FromFileLength;
}


/***************************************************************************++

Routine Description:

    Prepares the specified response for sending. This preparation
    consists mostly of opening any files referenced by the response.

Arguments:

    pResponse - Supplies the response to prepare.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlPrepareHttpResponse(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN PUL_INTERNAL_RESPONSE pResponse
    )
{
    ULONG i;
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_INTERNAL_DATA_CHUNK internalChunk;
    PUL_FILE_CACHE_ENTRY pFileCacheEntry;
    ULONGLONG offset;
    ULONGLONG length;
    ULONGLONG fileLength;
    CCHAR maxStackSize;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(SEND_RESPONSE, (
        "Http!UlPrepareHttpResponse: response %p\n",
        pResponse
        ));

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    //
    // build the http response protocol part
    //
    // check that the caller passed in headers to send
    //

    if (pResponse->HeaderLength > 0)
    {
        ULONG HeaderLength;

        ASSERT(pUserResponse != NULL);

        //
        // generate the response
        //

        Status = UlGenerateFixedHeaders(
                        Version,
                        pUserResponse,
                        pResponse->HeaderLength,
                        pResponse->pHeaders,
                        &HeaderLength
                        );

        if (!NT_SUCCESS(Status))
            goto end;

        //
        // it is possible that no headers got generated (0.9 request) .
        //

        if (HeaderLength > 0)
        {
            //
            // build an mdl for it
            //

            pResponse->pDataChunks[0].ChunkType = HttpDataChunkFromMemory;
            pResponse->pDataChunks[0].FromMemory.BufferLength =
                pResponse->HeaderLength;

            pResponse->pDataChunks[0].FromMemory.pMdl =
                UlAllocateMdl(
                    pResponse->pHeaders,        // VirtualAddress
                    pResponse->HeaderLength,    // Length
                    FALSE,                      // SecondaryBuffer
                    FALSE,                      // ChargeQuota
                    NULL                        // Irp
                    );

            if (pResponse->pDataChunks[0].FromMemory.pMdl == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto end;
            }

            MmBuildMdlForNonPagedPool(
                pResponse->pDataChunks[0].FromMemory.pMdl
                );
        }
    }

    //
    // Scan the chunks looking for "from file" chunks.
    //

    internalChunk = pResponse->pDataChunks - 1;
    maxStackSize = 0;

    for (i = 0 ; i < pResponse->ChunkCount ; i++)
    {
        internalChunk++;

        switch (internalChunk->ChunkType)
        {
        case HttpDataChunkFromFileHandle:
        case HttpDataChunkFromFileName:

            if (IS_FROM_FILE_HANDLE(internalChunk))
            {

                IF_DEBUG( SEND_RESPONSE )
                {
                    KdPrint((
                        "UlPrepareHttpResponse: opening handle %p\n",
                        &internalChunk->FromFile.FileHandle
                        ));
                }

                //
                // Found one. Try to open it.
                //

                Status = UlCreateFileEntry(
                                NULL,
                                internalChunk->FromFile.FileHandle,
                                UserMode,
                                &pFileCacheEntry
                                );

                if (NT_SUCCESS(Status) == FALSE)
                    goto end;
            }
            else
            {
                ASSERT(IS_FROM_FILE_NAME(internalChunk));

                IF_DEBUG( SEND_RESPONSE )
                {
                    KdPrint((
                        "UlPrepareHttpResponse: opening %wZ\n",
                        &internalChunk->FromFile.FileName
                        ));
                }

                //
                // Found one. Try to open it.
                //

                Status = UlCreateFileEntry(
                                &internalChunk->FromFile.FileName,
                                NULL,
                                UserMode,
                                &pFileCacheEntry
                                );

            } // if (IS_FROM_FILE_HANDLE(internalChunk))

            if (NT_SUCCESS(Status) == FALSE)
                goto end;

            internalChunk->FromFile.pFileCacheEntry = pFileCacheEntry;

            if (pFileCacheEntry->pDeviceObject->StackSize > maxStackSize)
            {
                maxStackSize = pFileCacheEntry->pDeviceObject->StackSize;
            }

            //
            // Validate & sanitize the specified byte range.
            //

            fileLength = pFileCacheEntry->FileInfo.EndOfFile.QuadPart;
            offset = internalChunk->FromFile.ByteRange.StartingOffset.QuadPart;
            length = internalChunk->FromFile.ByteRange.Length.QuadPart;

            if (offset >= fileLength)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // The offset looks good. If the user is asking for
            // "to eof", then calculate the number of bytes in the
            // file beyond the specified offset.
            //

            if (length == HTTP_BYTE_RANGE_TO_EOF)
            {
                length = fileLength - offset;
            }

            if ((offset + length) > fileLength)
            {
                Status = STATUS_INVALID_PARAMETER;
                goto end;
            }

            //
            // The specified length is good. Sanitize the byte range.
            //

            internalChunk->FromFile.ByteRange.StartingOffset.QuadPart = offset;
            internalChunk->FromFile.ByteRange.Length.QuadPart = length;

            pResponse->ResponseLength += length;

            break;

        case HttpDataChunkFromMemory:

            pResponse->ResponseLength += internalChunk->FromMemory.BufferLength;

            break;

        default:

            ASSERT(FALSE);
            Status = STATUS_INVALID_PARAMETER;
            goto end;

        }   // switch (internalChunk->ChunkType)
    }

    pResponse->MaxFileSystemStackSize = maxStackSize;


end:
    if (NT_SUCCESS(Status) == FALSE)
    {
        //
        // Undo anything done above.
        //

        UlCleanupHttpResponse( pResponse );
    }

    RETURN(Status);

}   // UlPrepareHttpResponse


/***************************************************************************++

Routine Description:

    Cleans a response by undoing anything done in UlPrepareHttpResponse().

Arguments:

    pResponse - Supplies the response to cleanup.

--***************************************************************************/
VOID
UlCleanupHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    )
{
    ULONG i;
    NTSTATUS status;
    PUL_INTERNAL_DATA_CHUNK internalChunk;

    //
    // Sanity check.
    //

    PAGED_CODE();

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlCleanupHttpResponse: response %p\n",
            pResponse
            ));
    }

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

//
// paulmcd(9/27/99) removed. can't do this anymore.  since handle chunks
// don't use any auxbuffer, it's possible that we have some chunks to
// look through
//
#if 0

    //
    // If this response does not have an attached file name buffer,
    // then we know there are no embedded "from file" chunks and
    // we can just bail quickly.
    //

    if (pResponse->AuxBufferLength == 0)
    {
        return;
    }
#endif

    //
    // Scan the chunks looking for "from file" chunks.
    //

    internalChunk = pResponse->pDataChunks - 1;

    for (i = 0 ; i < pResponse->ChunkCount ; i++)
    {
        internalChunk++;

        if (IS_FROM_FILE(internalChunk))
        {
            if (internalChunk->FromFile.pFileCacheEntry == NULL)
            {
                break;
            }

            DereferenceCachedFile(
                internalChunk->FromFile.pFileCacheEntry
                );

            internalChunk->FromFile.pFileCacheEntry = NULL;
        }
        else
        {
            ASSERT( IS_FROM_MEMORY(internalChunk) );
        }
    }

}   // UlCleanupHttpResponse


/***************************************************************************++

Routine Description:

    References the specified response.

Arguments:

    pResponse - Supplies the response to reference.

--***************************************************************************/
VOID
UlReferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    refCount = InterlockedIncrement( &pResponse->ReferenceCount );

    WRITE_REF_TRACE_LOG(
        g_pHttpResponseTraceLog,
        REF_ACTION_REFERENCE_HTTP_RESPONSE,
        refCount,
        pResponse,
        pFileName,
        LineNumber
        );

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlReferenceHttpResponse: response %p refcount %ld\n",
            pResponse,
            refCount
            ));
    }

}   // UlReferenceHttpResponse


/***************************************************************************++

Routine Description:

    Dereferences the specified response.

Arguments:

    pResponse - Supplies the response to dereference.

--***************************************************************************/
VOID
UlDereferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE( pResponse ) );

    refCount = InterlockedDecrement( &pResponse->ReferenceCount );

    WRITE_REF_TRACE_LOG(
        g_pHttpResponseTraceLog,
        REF_ACTION_DEREFERENCE_HTTP_RESPONSE,
        refCount,
        pResponse,
        pFileName,
        LineNumber
        );

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlDereferenceHttpResponse: response %p refcount %ld\n",
            pResponse,
            refCount
            ));
    }

    if (refCount == 0)
    {
        UlpDestroyCapturedResponse( pResponse );
    }

}   // UlDereferenceHttpResponse


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Destroys an internal HTTP response captured by UlCaptureHttpResponse().
    This involves closing open files, unlocking memory, and releasing any
    resources allocated to the response.

Arguments:

    pResponse - Supplies the internal response to destroy.

--***************************************************************************/
VOID
UlpDestroyCapturedResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    )
{
    ULONG i;

    ASSERT( UL_IS_VALID_INTERNAL_RESPONSE(pResponse) );

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpDestroyCapturedResponse: response %p\n",
            pResponse
            ));
    }

    //
    // Scan the chunks.
    //

    for (i = 0; i < pResponse->ChunkCount ; ++i)
    {
        if (IS_FROM_MEMORY(&(pResponse->pDataChunks[i])))
        {
            //
            // It's from memory. If necessary, unlock the pages, then
            // free the MDL.
            //

            if (pResponse->pDataChunks[i].FromMemory.pMdl != NULL)
            {
                if (IS_MDL_LOCKED(pResponse->pDataChunks[i].FromMemory.pMdl))
                {
                    MmUnlockPages( pResponse->pDataChunks[i].FromMemory.pMdl );
                }

                UlFreeMdl( pResponse->pDataChunks[i].FromMemory.pMdl );
                pResponse->pDataChunks[i].FromMemory.pMdl = NULL;
            }
        }
        else
        {
            //
            // It's a filename. If there is an associated file cache
            // entry, then dereference it.
            //

            ASSERT( IS_FROM_FILE(&(pResponse->pDataChunks[i])) );

            if (pResponse->pDataChunks[i].FromFile.pFileCacheEntry != NULL)
            {
                DereferenceCachedFile(
                    pResponse->pDataChunks[i].FromFile.pFileCacheEntry
                    );

                pResponse->pDataChunks[i].FromFile.pFileCacheEntry = NULL;
            }
        }
    }

    //
    // We should clean up the log buffer here if nobody has cleaned it up yet.
    // Unless there's an error during capture, the log buffer will be cleaned
    // up when send tracker's (cache/chunk) are completed in their respective
    // routines.
    //

    if ( pResponse->pLogData )
    {
        UlDestroyLogDataBuffer( pResponse->pLogData );
    }

    pResponse->Signature = MAKE_FREE_SIGNATURE(UL_INTERNAL_RESPONSE_POOL_TAG);

    if (pResponse->IsFromLookaside)
    {
        UlPplFreeResponseBuffer(pResponse);
    }
    else
    {
        UL_FREE_POOL_WITH_SIG( pResponse, UL_INTERNAL_RESPONSE_POOL_TAG );
    }

}   // UlpDestroyCapturedResponse


/***************************************************************************++

Routine Description:

    Worker routine for managing an in-progress UlSendHttpResponse().

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

--***************************************************************************/
VOID
UlpSendHttpResponseWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;
    NTSTATUS status;
    PUL_INTERNAL_DATA_CHUNK pCurrentChunk;
    PUL_FILE_CACHE_ENTRY pFileCacheEntry;
    PUL_FILE_BUFFER pFileBuffer;
    PMDL pNewMdl;
    ULONG runCount;
    ULONG bytesToRead;
    PMDL pMdlTail;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpSendHttpResponseWorker: tracker %p\n",
            pTracker
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    status = STATUS_SUCCESS;

    while( TRUE )
    {
        //
        // Capture the current chunk pointer, then check for end of
        // response.
        //

        pCurrentChunk = pTracker->pCurrentChunk;

        if (IS_REQUEST_COMPLETE(pTracker))
        {
            ASSERT( status == STATUS_SUCCESS );
            break;
        }

        runCount = pTracker->SendInfo.MdlRunCount;

        //
        // Determine the chunk type.
        //

        if (IS_FROM_MEMORY(pCurrentChunk))
        {
            //
            // It's from a locked-down memory buffer. Since these
            // are always handled in-line (never pended) we can
            // go ahead and adjust the current chunk pointer in the
            // tracker.
            //

            UlpIncrementChunkPointer( pTracker );

            //
            // ignore empty buffers
            //

            if (pCurrentChunk->FromMemory.BufferLength == 0)
            {
                continue;
            }

            //
            // Clone the incoming MDL.
            //

            ASSERT( pCurrentChunk->FromMemory.pMdl->Next == NULL );
            pNewMdl = UlCloneMdl( pCurrentChunk->FromMemory.pMdl );

            if (pNewMdl == NULL)
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            //
            // Update the buffered byte count and append the cloned MDL
            // onto our MDL chain.
            //

            pTracker->SendInfo.BytesBuffered += MmGetMdlByteCount( pNewMdl );
            (*pTracker->SendInfo.pMdlLink) = pNewMdl;
            pTracker->SendInfo.pMdlLink = &pNewMdl->Next;

            //
            // Add the MDL to the run list. As an optimization, if the
            // last run in the list was "from memory", we can just
            // append the MDL to the last run.
            //

            if (runCount == 0 ||
                IS_FILE_BUFFER_IN_USE(&(pTracker->SendInfo.MdlRuns[runCount-1].FileBuffer)))
            {
                //
                // Create a new run.
                //

                pTracker->SendInfo.MdlRuns[runCount].pMdlTail = pNewMdl;
                pTracker->SendInfo.MdlRunCount++;

                pFileBuffer = &(pTracker->SendInfo.MdlRuns[runCount].FileBuffer);
                INITIALIZE_FILE_BUFFER(pFileBuffer);

                //
                // If we've not exhausted our static MDL run array,
                // then we'll need to initiate a flush.
                //

                if (pTracker->SendInfo.MdlRunCount == MAX_MDL_RUNS)
                {
                    ASSERT( status == STATUS_SUCCESS );
                    break;
                }
            }
            else
            {
                //
                // Append to the last run in the list.
                //

                pTracker->SendInfo.MdlRuns[runCount-1].pMdlTail->Next = pNewMdl;
                pTracker->SendInfo.MdlRuns[runCount-1].pMdlTail = pNewMdl;
            }

            //
            // If we've now exceeded the maximum number of bytes we
            // want to buffer, then initiate a flush.
            //

            if (pTracker->SendInfo.BytesBuffered >= MAX_BYTES_BUFFERED)
            {
                ASSERT( status == STATUS_SUCCESS );
                break;
            }
        }
        else
        {
            //
            // It's a filesystem MDL.
            //

            ASSERT( IS_FROM_FILE(pCurrentChunk) );

            pFileCacheEntry = pCurrentChunk->FromFile.pFileCacheEntry;
            ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileCacheEntry ) );

            pFileBuffer = &(pTracker->SendInfo.MdlRuns[runCount].FileBuffer);
            INITIALIZE_FILE_BUFFER(pFileBuffer);

            //
            // Initiate file read
            //

            if (pTracker->FileBytesRemaining.QuadPart > MAX_BYTES_PER_READ)
            {
                //
                // Don't read too much at once.
                //
                bytesToRead = MAX_BYTES_PER_READ;
            }
            else if (pTracker->FileBytesRemaining.QuadPart == 0)
            {
                //
                // Don't try to read zero bytes.
                //
                UlpIncrementChunkPointer( pTracker );
                
                continue;
            }
            else
            {
                //
                // Looks like a reasonable number of bytes. Go for it.
                //
                bytesToRead = (ULONG)pTracker->FileBytesRemaining.QuadPart;
            }

            //
            // Initialize the UL_FILE_BUFFER.
            //

            pFileBuffer->pFileCacheEntry = pFileCacheEntry;
            pFileBuffer->FileOffset = pTracker->FileOffset;
            pFileBuffer->Length = bytesToRead;

            pFileBuffer->pFileCacheEntry =
                pCurrentChunk->FromFile.pFileCacheEntry;

            pFileBuffer->pCompletionRoutine = UlpRestartMdlRead;
            pFileBuffer->pContext = pTracker;

            //
            // BumpUp the tracker refcount before starting the Read I/O. In case
            // Send operation later on will complete before the read, we still
            // want the tracker around until UlpRestartMdlRead finishes its
            // business. It will be released when UlpRestartMdlRead got called
            // back.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            //
            // issue the I/O
            //
            status = UlReadFileEntry(
                            pFileBuffer,
                            pTracker->pReadIrp
                            );

            //
            // If the read isn't pending, then deref the tracker since
            // UlpRestartMdlRead isn't going to get called.
            //
            if (status != STATUS_PENDING)
            {
                UL_DEREFERENCE_CHUNK_TRACKER( pTracker );
            }
            
            break;
        }
    }

    //
    // If we fell out of the above loop with status == STATUS_SUCCESS,
    // then the last send we issued was buffered and needs to be flushed.
    // Otherwise, if the status is anything but STATUS_PENDING, then we
    // hit an in-line failure and need to complete the original request.
    //

    if (status == STATUS_SUCCESS)
    {
        if (pTracker->SendInfo.BytesBuffered > 0)
        {
            BOOLEAN initiateDisconnect = FALSE;

            //
            // Flush the send. Since this the last (only?) send to be
            // issued for this response, we can ask UlSendData() to
            // initiate a disconnect on our behalf if appropriate.
            //

            if (IS_REQUEST_COMPLETE(pTracker) &&
                IS_DISCONNECT_TIME(pTracker))
            {
                initiateDisconnect = TRUE;
            }

            //
            // Increment the RefCount on Tracker for Send I/O.
            // UlpSendCompleteWorker will release it later.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            //
            // Adjust SendBufferedBytes.
            //

            InterlockedExchangeAdd(
                &pTracker->pHttpConnection->SendBufferedBytes,
                pTracker->pResponse->SendBufferedBytes
                );

            status = UlSendData(
                            pTracker->pConnection,
                            pTracker->SendInfo.pMdlHead,
                            pTracker->SendInfo.BytesBuffered,
                            &UlpRestartMdlSend,
                            pTracker,
                            pTracker->pSendIrp,
                            &pTracker->IrpContext,
                            initiateDisconnect
                            );
        }
        else
        if (IS_DISCONNECT_TIME(pTracker))
        {
            PUL_CONNECTION pConnection;

            //
            // Nothing to send, but we need to issue a disconnect.
            //

            pConnection = pTracker->pConnection;
            pTracker->pConnection = NULL;

            //
            // Increment up until connection close is complete
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            status = UlCloseConnection(
                                pConnection,
                                FALSE,
                                &UlpCloseConnectionComplete,
                                pTracker
                                );

            ASSERT( status == STATUS_PENDING );
        }
    }

    //
    // did everything complete?
    //

    if (status != STATUS_PENDING)
    {
        //
        // Nope, something went wrong !
        //

        UlpCompleteSendRequest( pTracker, status );
    }

    //
    // Release our grab on the tracker we are done with it.
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

}   // UlpSendHttpResponseWorker


/***************************************************************************++

Routine Description:

    Completion handler for UlCloseConnection().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. This is actually a
        PUL_CHUNK_TRACKER pointer.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred. This field is unused for UlCloseConnection().

--***************************************************************************/
VOID
UlpCloseConnectionComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_CHUNK_TRACKER pTracker;

    //
    // Snag the context.
    //

    pTracker = (PUL_CHUNK_TRACKER)pCompletionContext;

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpCloseConnectionComplete: tracker %p\n",
            pTracker
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( pTracker->pConnection == NULL );

    UlpCompleteSendRequest( pTracker, Status );

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

}   // UlpCloseConnectionComplete


/***************************************************************************++

Routine Description:

    Allocates a new send tracker. The newly created tracker must eventually
    be freed with UlpFreeChunkTracker().

Arguments:

    SendIrpStackSize - Supplies the stack size for the network send IRPs.

    ReadIrpStackSize - Supplies the stack size for the file system read
        IRPs.

Return Value:

    PUL_CHUNK_TRACKER - The new send tracker if successful, NULL otherwise.

--***************************************************************************/
PUL_CHUNK_TRACKER
UlpAllocateChunkTracker(
    IN UL_TRACKER_TYPE TrackerType,
    IN CCHAR SendIrpStackSize,
    IN CCHAR ReadIrpStackSize,
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PUL_CHUNK_TRACKER pTracker;
    CCHAR MaxIrpStackSize;

    ASSERT( TrackerType == UlTrackerTypeSend ||
            TrackerType == UlTrackerTypeBuildUriEntry
            );

    MaxIrpStackSize = MAX(SendIrpStackSize, ReadIrpStackSize);

    //
    // Try to allocate from the lookaside list if possible.
    //

    if (MaxIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        ULONG ChunkTrackerSize;
        USHORT ReadIrpSize;
        USHORT SendIrpSize;

        ReadIrpSize = (USHORT)ALIGN_UP(IoSizeOfIrp(ReadIrpStackSize), PVOID);
        SendIrpSize = (USHORT)ALIGN_UP(IoSizeOfIrp(SendIrpStackSize), PVOID);

        ChunkTrackerSize = ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID) +
                            ReadIrpSize +
                            SendIrpSize +
                            g_UlMaxVariableHeaderSize;

        pTracker = (PUL_CHUNK_TRACKER)UL_ALLOCATE_POOL(
                                        NonPagedPool,
                                        ChunkTrackerSize,
                                        UL_CHUNK_TRACKER_POOL_TAG
                                        );

        if (pTracker)
        {
            pTracker->Signature = UL_CHUNK_TRACKER_POOL_TAG;
            pTracker->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;
            pTracker->IsFromLookaside = FALSE;

            //
            // Set up the IRP.
            //

            pTracker->pReadIrp =
                (PIRP)((PCHAR)pTracker + ALIGN_UP(sizeof(UL_CHUNK_TRACKER), PVOID));

            IoInitializeIrp(
                pTracker->pReadIrp,
                ReadIrpSize,
                ReadIrpStackSize
                );

            pTracker->pSendIrp =
                (PIRP)((PCHAR)pTracker->pReadIrp + ReadIrpSize);

            IoInitializeIrp(
                pTracker->pSendIrp,
                SendIrpSize,
                SendIrpStackSize
                );

            //
            // Set up the variable header pointer.
            //

            pTracker->pVariableHeader =
                (PUCHAR)((PCHAR)pTracker->pSendIrp + SendIrpSize);
        }
    }
    else
    {
        pTracker = UlPplAllocateChunkTracker();

        if (pTracker)
        {
            ASSERT(pTracker->Signature == MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG));
            pTracker->Signature = UL_CHUNK_TRACKER_POOL_TAG;
        }
    }

    if (pTracker != NULL)
    {
        pTracker->Type = TrackerType;

        //
        // RefCounting is necessary since we might have two Aysnc (Read & Send)
        // Io Operation on the same tracker along the way.
        //

        pTracker->RefCount   = 1;
        pTracker->Terminated = 0;

        //
        // RefCounting for the pHttpConnection will be handled by our caller
        // "UlSendHttpresponse". Not to worry about it.
        //

        pTracker->pHttpConnection = pHttpConnection;
        pTracker->pConnection = pHttpConnection->pConnection;
        pTracker->Flags = Flags;

        //
        // Completion info.
        //

        pTracker->pCompletionRoutine = pCompletionRoutine;
        pTracker->pCompletionContext = pCompletionContext;

        //
        // Response and request info.
        //

        UL_REFERENCE_INTERNAL_RESPONSE( pResponse );
        pTracker->pResponse = pResponse;

        UL_REFERENCE_INTERNAL_REQUEST( pRequest );
        pTracker->pRequest = pRequest;

        //
        // Note that we set the current chunk to just *before* the first
        // chunk, then call the increment function. This allows us to go
        // through the common increment/update path.
        //

        pTracker->pCurrentChunk = pResponse->pDataChunks - 1;

        //
        // Do this prior to calling UlpIncrementChunkPointer because it
        // expects pLastChunk to be initialized.
        //

        pTracker->pLastChunk = (pTracker->pCurrentChunk + 1) + pResponse->ChunkCount;

        //
        // Zero the remaining fields.
        //

        RtlZeroMemory(
            (PUCHAR)pTracker + FIELD_OFFSET(UL_CHUNK_TRACKER, WorkItem),
            sizeof(*pTracker) - FIELD_OFFSET(UL_CHUNK_TRACKER, WorkItem)
            );

        UlpIncrementChunkPointer( pTracker );
    }

    if (TrackerType == UlTrackerTypeSend) {
        UlTrace(SEND_RESPONSE, (
            "Http!UlpAllocateChunkTracker: tracker %p (send)\n",
            pTracker
            ));
    } else {
        UlTrace(URI_CACHE, (
            "Http!UlpAllocateChunkTracker: tracker %p (build uri)\n",
            pTracker
            ));
    }

    return pTracker;

}   // UlpAllocateChunkTracker


/***************************************************************************++

Routine Description:

    Frees a send tracker allocated with UlpAllocateChunkTracker().

Arguments:

    pTracker - Supplies the send tracker to free.

--***************************************************************************/
VOID
UlpFreeChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    )
{
    ASSERT( pTracker );
    ASSERT( IS_VALID_CHUNK_TRACKER(pTracker) );
    ASSERT( pTracker->Type == UlTrackerTypeSend ||
            pTracker->Type == UlTrackerTypeBuildUriEntry
            );

    if (pTracker->Type == UlTrackerTypeSend) {
        UlTrace(SEND_RESPONSE, (
            "Http!UlpFreeChunkTracker: tracker %p (send)\n",
            pTracker
            ));
    } else {
        UlTrace(URI_CACHE, (
            "Http!UlpFreeChunkTracker: tracker %p (build uri)\n",
            pTracker
            ));
    }

    //
    // Release our ref to the response and request.
    //

    UL_DEREFERENCE_INTERNAL_RESPONSE( pTracker->pResponse );
    UL_DEREFERENCE_INTERNAL_REQUEST( pTracker->pRequest );

    pTracker->Signature = MAKE_FREE_TAG(UL_CHUNK_TRACKER_POOL_TAG);

    if (pTracker->IsFromLookaside)
    {
        UlPplFreeChunkTracker( pTracker );
    }
    else
    {
        UL_FREE_POOL_WITH_SIG( pTracker, UL_CHUNK_TRACKER_POOL_TAG );
    }

}   // UlpFreeChunkTracker

/***************************************************************************++

Routine Description:

    Increments the reference count on the chunk tracker.
    Used by Send & Read IRPs

Arguments:

    pTracker - Supplies the chunk trucker to the reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlReferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CHUNK_TRACKER(pTracker));

    //
    // Reference it.
    //

    RefCount = InterlockedIncrement(&pTracker->RefCount);
    ASSERT(RefCount > 1);

    //
    // Keep the logs updated
    //

    WRITE_REF_TRACE_LOG(
        g_pChunkTrackerTraceLog,
        REF_ACTION_REFERENCE_CHUNK_TRACKER,
        RefCount,
        pTracker,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE,(
            "Http!UlReferenceChunkTracker: tracker %p RefCount %ld\n",
            pTracker,
            RefCount
            ));

}   // UlReferenceChunkTracker

/***************************************************************************++

Routine Description:

    Decrements the reference count on the specified chunk tracker.

Arguments:

    pTracker - Supplies the chunk trucker to the reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlDereferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG RefCount;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CHUNK_TRACKER(pTracker));

    //
    // Dereference it.
    //

    RefCount = InterlockedDecrement(&pTracker->RefCount);
    ASSERT(RefCount >= 0);

    //
    // Keep the logs updated
    //

    WRITE_REF_TRACE_LOG(
        g_pChunkTrackerTraceLog,
        REF_ACTION_DEREFERENCE_CHUNK_TRACKER,
        RefCount,
        pTracker,
        pFileName,
        LineNumber
        );

    UlTrace(SEND_RESPONSE,(
            "Http!UlDereferenceChunkTracker: tracker %p RefCount %ld\n",
            pTracker,
            RefCount
            ));

    if (RefCount == 0)
    {
        //
        // The final reference to the chunk tracker has been removed
        // So It's time to FreeUp the ChunkTracker
        //

        UlpFreeChunkTracker(pTracker);
    }

}   // UlDereferenceChunkTracker

/***************************************************************************++

Routine Description:

    Completes a "send response" represented by a send tracker.

Arguments:

    pTracker - Supplies the tracker to complete.

    Status - Supplies the completion status.

--***************************************************************************/
VOID
UlpCompleteSendRequest(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    )
{
    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Although the chunk tracker will be around  until all the outstanding
    // Read/Send IRPs are complete. We should only complete the send request
    // once.
    //

    if (FALSE != InterlockedExchange(&pTracker->Terminated, TRUE))
        return;

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpCompleteSendRequest: tracker %p, status %08lx\n",
            pTracker,
            Status
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pTracker->IoStatus.Status = Status;

    UL_REFERENCE_CHUNK_TRACKER( pTracker );

    UL_CALL_PASSIVE(
        &pTracker->WorkItem,
        &UlpCompleteSendRequestWorker
        );
}


/***************************************************************************++

Routine Description:

    Closes the connection if neccessary, cleans up trackers, and completes
    the request.

Arguments:

    pWorkItem - embedded in our UL_CHUNK_TRACKER

--***************************************************************************/
VOID
UlpCompleteSendRequestWorker(
    PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;
    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;
    NTSTATUS Status;
    ULONGLONG BytesTransferred;
    KIRQL OldIrql;

    //
    // Sanity check
    //
    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST( pTracker->pRequest ) );

    //
    // Pull info from the tracker
    //
    pCompletionRoutine = pTracker->pCompletionRoutine;
    pCompletionContext = pTracker->pCompletionContext;

    Status = pTracker->IoStatus.Status;
    BytesTransferred = pTracker->BytesTransferred;

    //
    // do some tracing
    //
    TRACE_TIME(
        pTracker->pHttpConnection->ConnectionId,
        pTracker->pHttpConnection->pRequest->RequestId,
        TIME_ACTION_SEND_COMPLETE
        );

    //
    // Free the MDLs attached to the tracker.
    //

    UlpFreeMdlRuns( pTracker );

    //
    // Updates the BytesSent counter in the request. For a single request
    // we might receive multiple sendresponse ioctl calls, i.e. cgi requests.
    // Multiple internal responses will get allocated and as well as a new
    // chunk trucker for each response. Therefore the correct place to hold
    // the Bytes send information should be in request. On the other hand
    // keeping the request around until the send is done is yet another
    // concern here. An outstanding bug #189327 will solve that issue as well.
    //

    UlInterlockedAdd64(
        (PLONGLONG)&pTracker->pRequest->BytesSent,
        BytesTransferred
        );

    if ( (pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0 )
    {
        //
        // Stop MinKBSec timer and start Connection Idle timer
        //

        UlLockTimeoutInfo(
            &(pTracker->pHttpConnection->TimeoutInfo),
            &OldIrql
            );

        UlResetConnectionTimer(
            &(pTracker->pHttpConnection->TimeoutInfo),
            TimerMinKBSec
            );

        UlSetConnectionTimer(
            &(pTracker->pHttpConnection->TimeoutInfo),
            TimerConnectionIdle
            );

        UlUnlockTimeoutInfo(
            &(pTracker->pHttpConnection->TimeoutInfo),
            OldIrql
            );

        UlEvaluateTimerState(
            &(pTracker->pHttpConnection->TimeoutInfo)
            );

    }

    //
    // If this is the last response for this request and
    // there was a log data passed down by the user then now
    // its time to log.
    //

    if ( pTracker->pResponse && pTracker->pResponse->pLogData )
    {
        UlLogHttpHit( pTracker->pResponse->pLogData );
    }

    //
    // complete the request
    //

    if (pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            BytesTransferred > MAXULONG ? MAXULONG : (ULONG)BytesTransferred
            );
    }

    //
    // Kick the parser on the connection and release our hold.
    //

    if ( ((pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0)
        && ((pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) == 0)
        && (Status == STATUS_SUCCESS) )
    {
        UlResumeParsing( pTracker->pHttpConnection );
    }

    UL_DEREFERENCE_HTTP_CONNECTION( pTracker->pHttpConnection );

    //
    // DeRef the trucker that we have bumped up before queueing this worker
    // function.
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

}   // UlpCompleteSendRequestWorker


/***************************************************************************++

Routine Description:

    This function sends back a fake early completion to the caller, but
    doesn't clean up any response sending structures.

Arguments:

    pCompletionRoutine - the routine to call
    pCompletionContext - the context given by the caller
    Status             - the status code with which to complete
    BytesTransferred   - size of the transfer

--***************************************************************************/
VOID
UlpCompleteSendIrpEarly(
    PUL_COMPLETION_ROUTINE pCompletionRoutine,
    PVOID pCompletionContext,
    NTSTATUS Status,
    ULONGLONG BytesTransferred
    )
{
    UlTrace(SEND_RESPONSE, (
        "Http!UlpCompleteSendIrpEarly(\n"
        "    pCompletionRoutine = %p\n"
        "    pCompletionContext = %p\n"
        "    Status             = %08x\n"
        "    BytesTransferred   = %I64x)\n",
        pCompletionRoutine,
        pCompletionContext,
        Status,
        BytesTransferred
        ));

    if (pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            BytesTransferred > MAXULONG ? MAXULONG : (ULONG)BytesTransferred
            );
    }
}



/***************************************************************************++

Routine Description:

    Completion handler for MDL READ IRPs used for reading file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS status;
    PUL_CHUNK_TRACKER pTracker;
    ULONG bytesRead;
    PMDL pMdl;
    PMDL pMdlTail;
    BOOLEAN initiateDisconnect = FALSE;

    pTracker = (PUL_CHUNK_TRACKER)pContext;

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpRestartMdlRead: tracker %p\n",
            pTracker
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    status = pIrp->IoStatus.Status;

    if (NT_SUCCESS(status))
    {
        bytesRead = (ULONG)pIrp->IoStatus.Information;

        if (bytesRead)
        {
            PUL_FILE_BUFFER pFileBuffer;
            ULONG runCount;

            runCount = pTracker->SendInfo.MdlRunCount;
            pFileBuffer = &(pTracker->SendInfo.MdlRuns[runCount].FileBuffer);

            pMdl = pFileBuffer->pMdl;
            ASSERT(pMdl);

            //
            // Update the buffered byte count and append the new MDL onto
            // our MDL chain.
            //

            pMdlTail = UlFindLastMdlInChain( pMdl );

            pTracker->SendInfo.BytesBuffered += bytesRead;
            (*pTracker->SendInfo.pMdlLink) = pMdl;
            pTracker->SendInfo.pMdlLink = &pMdlTail->Next;

            pTracker->SendInfo.MdlRuns[runCount].pMdlTail = pMdlTail;
            pTracker->SendInfo.MdlRunCount++;

            //
            // Update the file offset & bytes remaining. If we've
            // finished this file chunk (bytes remaining is now zero)
            // then advance to the next chunk.
            //

            pTracker->FileOffset.QuadPart += (ULONGLONG)bytesRead;
            pTracker->FileBytesRemaining.QuadPart -= (ULONGLONG)bytesRead;
        }

        if (pTracker->FileBytesRemaining.QuadPart == 0 )
        {
            UlpIncrementChunkPointer( pTracker );

            //
            // If we're finished with the response (in other words, the
            // call to UlSendData() below will be the last send for this
            // response) and we are to initiate a disconnect, then ask
            // UlSendResponse() to initiate the disconnect for us.
            //

            if (IS_REQUEST_COMPLETE(pTracker) &&
                IS_DISCONNECT_TIME(pTracker))
            {
                initiateDisconnect = TRUE;
            }
        }

        //
        // If we've not exhausted our static MDL run array,
        // we've exceeded the maximum number of bytes we want to
        // buffer, then we'll need to initiate a flush.
        //

        if (IS_REQUEST_COMPLETE(pTracker) ||
            pTracker->SendInfo.MdlRunCount == MAX_MDL_RUNS ||
            pTracker->SendInfo.BytesBuffered >= MAX_BYTES_BUFFERED)
        {
            //
            // Increment the RefCount on Tracker for Send I/O.
            // UlpSendCompleteWorker will release it later.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            //
            // Adjust SendBufferedBytes.
            //

            InterlockedExchangeAdd(
                &pTracker->pHttpConnection->SendBufferedBytes,
                pTracker->pResponse->SendBufferedBytes
                );

            status = UlSendData(
                            pTracker->pConnection,
                            pTracker->SendInfo.pMdlHead,
                            pTracker->SendInfo.BytesBuffered,
                            &UlpRestartMdlSend,
                            pTracker,
                            pTracker->pSendIrp,
                            &pTracker->IrpContext,
                            initiateDisconnect
                            );
        }
        else
        {

            //
            // RefCount the chunk tracker up for the UlpSendHttpResponseWorker.
            // It will DeRef it when it's done with the chunk tracker itself.
            // Since this is a passive call we had to increment the refcount
            // for this guy to make sure that tracker is around until it wakes
            // up. Other places makes calls to UlpSendHttpResponseWorker has
            // also been updated as well.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            UL_CALL_PASSIVE(
                &pTracker->WorkItem,
                &UlpSendHttpResponseWorker
                );
        }
    }

    if (!NT_SUCCESS(status))
    {
        UlpCompleteSendRequest( pTracker, status );
    }

    //
    // Read I/O Has been completed release our refcount
    // on the chunk tracker.
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );


    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartMdlRead


/***************************************************************************++

Routine Description:

    Completion handler for MDL READ COMPLETE IRPs used for returning
    MDLs back to the file system.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PFILE_OBJECT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartMdlReadComplete(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_CHUNK_TRACKER pTracker = (PUL_CHUNK_TRACKER)pContext;

    ASSERT(IS_VALID_CHUNK_TRACKER(pTracker));
    UL_DEREFERENCE_CHUNK_TRACKER(pTracker);

    UlFreeIrp( pIrp );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartMdlReadComplete


/***************************************************************************++

Routine Description:

    Completion handler for UlSendData().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. This is actually a
        pointer to a UL_CHUNK_TRACKER structure.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred.

--***************************************************************************/
VOID
UlpRestartMdlSend(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_CHUNK_TRACKER pTracker;

    pTracker = (PUL_CHUNK_TRACKER)pCompletionContext;

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpRestartMdlSend: tracker %p\n",
            pTracker
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // Adjust SendBufferedBytes.
    //

    InterlockedExchangeAdd(
        &pTracker->pHttpConnection->SendBufferedBytes,
        - pTracker->pResponse->SendBufferedBytes
        );

    //
    // Disconnect if there was an error, and we didn't disconnect already.
    //

    if ((pTracker->pConnection != NULL) &&
        (!NT_SUCCESS(Status)) &&
        (!IS_DISCONNECT_TIME(pTracker)))
    {
        NTSTATUS TempStatus;
        PUL_CONNECTION pConnection;

        pConnection = pTracker->pConnection;
        pTracker->pConnection = NULL;

        TempStatus = UlCloseConnection(
                            pConnection,
                            TRUE,           // AbortiveDisconnect
                            NULL,           // pCompletionRoutine
                            NULL            // pCompletionContext
                            );
    }

    //
    // Handle the completion in a work item.
    // We need to get to passive level and
    // we also need to prevent a recursive
    // loop on filtered connections or any
    // other case where our sends might all
    // be completing in-line.
    //

    pTracker->IoStatus.Status = Status;
    pTracker->IoStatus.Information = Information;

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        &UlpSendCompleteWorker
        );


}   // UlpRestartMdlSend


/***************************************************************************++

Routine Description:

    Deferred handler for completed sends.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

--***************************************************************************/
VOID
UlpSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    IF_DEBUG( SEND_RESPONSE )
    {
        KdPrint((
            "UlpSendCompleteWorker: tracker %p\n",
            pTracker
            ));
    }

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    //
    // If the chunk completed successfully, then update the bytes
    // transferred and queue another work item for the next chunk if
    // there's more work to do. Otherwise, just complete the request now.
    //

    status = pTracker->IoStatus.Status;

    if (NT_SUCCESS(status))
    {
        pTracker->BytesTransferred += pTracker->IoStatus.Information;

        if (!IS_REQUEST_COMPLETE(pTracker))
        {
            //
            // Free the MDLs attached to the tracker.
            //

            UlpFreeMdlRuns( pTracker );

            //
            // RefCount the chunk tracker up for the UlpSendHttpResponseWorker.
            // It will DeRef it when it's done with the chunk tracker itself.
            //

            UL_REFERENCE_CHUNK_TRACKER( pTracker );

            UlpSendHttpResponseWorker(&pTracker->WorkItem);

            goto end;
        }

    }

    //
    // All done.
    //

    UlpCompleteSendRequest( pTracker, status );

end:
    //
    // Release our grab on the Tracker, Send I/O is done
    //

    UL_DEREFERENCE_CHUNK_TRACKER( pTracker );

}   // UlpSendCompleteWorker


/***************************************************************************++

Routine Description:

    Cleans the MDL_RUNs in the specified tracker and prepares the
    tracker for reuse.

Arguments:

    pTracker - Supplies the tracker to clean.

--***************************************************************************/
VOID
UlpFreeMdlRuns(
    IN OUT PUL_CHUNK_TRACKER pTracker
    )
{
    PMDL pMdlHead;
    PMDL pMdlNext;
    PMDL pMdlTmp;
    PMDL_RUN pMdlRun;
    ULONG runCount;
    NTSTATUS status;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUL_FILE_CACHE_ENTRY pFileCacheEntry;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pMdlHead = pTracker->SendInfo.pMdlHead;
    pMdlRun = &pTracker->SendInfo.MdlRuns[0];
    runCount = pTracker->SendInfo.MdlRunCount;

    while (runCount > 0)
    {
        ASSERT( pMdlHead != NULL );
        ASSERT( pMdlRun->pMdlTail != NULL );

        pMdlNext = pMdlRun->pMdlTail->Next;
        pMdlRun->pMdlTail->Next = NULL;

        pFileCacheEntry = pMdlRun->FileBuffer.pFileCacheEntry;

        if (pFileCacheEntry == NULL)
        {
            //
            // It's a memory run; just walk & free the MDL chain.
            //

            while (pMdlHead != NULL)
            {
                pMdlTmp = pMdlHead->Next;
                UlFreeMdl( pMdlHead );
                pMdlHead = pMdlTmp;
            }
        }
        else
        {
            //
            // It's a file run; try the fast path.
            //

            status = UlReadCompleteFileEntryFast(
                            &pMdlRun->FileBuffer
                            );

            if (!NT_SUCCESS(status))
            {
                //
                // Fast path failed, we'll need an IRP.
                //

                pIrp = UlAllocateIrp(
                            pFileCacheEntry->pDeviceObject->StackSize,
                            FALSE
                            );

                if (pIrp == NULL)
                {
                    ASSERT( !"HANDLE NULL IRP!" );
                }
                else
                {
                    pMdlRun->FileBuffer.pCompletionRoutine =
                        UlpRestartMdlReadComplete;
                        
                    pMdlRun->FileBuffer.pContext = pTracker;

                    UL_REFERENCE_CHUNK_TRACKER(pTracker);
                    
                    status = UlReadCompleteFileEntry(
                                    &pMdlRun->FileBuffer,
                                    pIrp
                                    );

                    if (!NT_SUCCESS(status))
                    {
                        UL_DEREFERENCE_CHUNK_TRACKER(pTracker);
                    }
                }
            }
        }

        pMdlHead = pMdlNext;
        pMdlRun++;
        runCount--;
    }

    UlpInitMdlRuns( pTracker );

}   // UlpFreeMdlRuns


/***************************************************************************++

Routine Description:

    Increments the current chunk pointer in the tracker and initializes
    some of the "from file" related tracker fields if necessary.

Arguments:

    pTracker - Supplies the UL_CHUNK_TRACKER to manipulate.

--***************************************************************************/
VOID
UlpIncrementChunkPointer(
    IN OUT PUL_CHUNK_TRACKER pTracker
    )
{
    //
    // Bump the pointer. If the request is still incomplete, then
    // check the new current chunk. If it's "from file", then
    // initialize the file offset & bytes remaining from the
    // supplied byte range.
    //
    ASSERT( pTracker->pCurrentChunk < pTracker->pLastChunk );

    pTracker->pCurrentChunk++;

    if (!IS_REQUEST_COMPLETE(pTracker) )
    {
        if (IS_FROM_FILE(pTracker->pCurrentChunk))
        {
            pTracker->FileOffset =
                pTracker->pCurrentChunk->FromFile.ByteRange.StartingOffset;
            pTracker->FileBytesRemaining =
                pTracker->pCurrentChunk->FromFile.ByteRange.Length;
        }
        else
        {
            ASSERT( IS_FROM_MEMORY(pTracker->pCurrentChunk) );
        }
    }

}   // UlpIncrementChunkPointer




/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////



/***************************************************************************++

Routine Description:

    Once we've parsed a request, we pass it in here to try and serve
    from the response cache. This function will either send the response,
    or do nothing at all.

Arguments:

    pHttpConn        - the connection with a req to be handled
    pServedFromCache - we set TRUE if we handled the request

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendCachedResponse(
    PUL_HTTP_CONNECTION pHttpConn,
    PBOOLEAN            pServedFromCache,
    PBOOLEAN            pConnectionRefused
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    ULONG               Flags;
    PUL_CONFIG_GROUP_OBJECT pMaxBandwidth = NULL;
    ULONG               RetCacheControl;
    LONGLONG            BytesToSend;
    KIRQL               OldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT( pHttpConn );
    ASSERT( pServedFromCache );

    *pConnectionRefused = FALSE;

    pUriCacheEntry = UlCheckoutUriCacheEntry(pHttpConn->pRequest);

    //
    // Enforce the connection limit
    //
    if (pUriCacheEntry &&
        UlCheckSiteConnectionLimit(pHttpConn, &pUriCacheEntry->ConfigInfo) == FALSE)
    {
        *pConnectionRefused = TRUE;
    }

    if (pUriCacheEntry && *pConnectionRefused == FALSE) {
        PUL_SITE_COUNTER_ENTRY pCtr;
        ULONG Connections;

        //
        // Perf Counters (cached)
        //
        ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
        ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(&pUriCacheEntry->ConfigInfo));

        pCtr = pUriCacheEntry->ConfigInfo.pSiteCounters;
        if (pCtr)
        {
            // NOTE: pCtr may be NULL if the SiteId was never set on the root-level
            // NOTE: Config Group for the site.  BVTs may need to be updated.

            ASSERT(IS_VALID_SITE_COUNTER_ENTRY(pCtr));

            if ( pUriCacheEntry->Verb == HttpVerbGET )
            {
                UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterGetReqs);
            }

            else if ( pUriCacheEntry->Verb == HttpVerbHEAD )
            {
                UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterHeadReqs);
            }

            UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterAllReqs);
            UlIncSiteNonCriticalCounterUlong(pCtr, HttpSiteCounterConnAttempts);

            if (pCtr != pHttpConn->pPrevSiteCounters)
            {
                if (pHttpConn->pPrevSiteCounters)
                {
                    // Decrement old site's counters & release ref count 
                    
                    UlDecSiteCounter(
                        pHttpConn->pPrevSiteCounters, 
                        HttpSiteCounterCurrentConns
                        );
                    DEREFERENCE_SITE_COUNTER_ENTRY(pHttpConn->pPrevSiteCounters);
                }
                
                Connections = (ULONG) UlIncSiteCounter(pCtr, HttpSiteCounterCurrentConns);
                UlMaxSiteCounter(
                        pCtr,
                        HttpSiteCounterMaxConnections,
                        Connections
                        );

                // add ref for new site counters
                REFERENCE_SITE_COUNTER_ENTRY(pCtr);
                pHttpConn->pPrevSiteCounters = pCtr;
                
            }
        }

        //
        // Check "Accept:" header.
        //
        

        if ( FALSE ==  pHttpConn->pRequest->AcceptWildcard)
        {
            if ( FALSE == UlpIsAcceptHeaderOk( pHttpConn->pRequest, pUriCacheEntry ) )
            {
                //
                // Cache entry did not match requested accept header; bounce up
                // to user-mode for response.
                //
                UlCheckinUriCacheEntry(pUriCacheEntry);

                *pServedFromCache = FALSE;

                goto end;
            }
        }

        //
        // Cache-Control: Check the If-* headers to see if we can/should skip
        // sending of the cached response.
        //

        RetCacheControl = UlpCheckCacheControlHeaders(
                                pHttpConn->pRequest,
                                pUriCacheEntry );
        if ( RetCacheControl )
        {
            // check-in cache entry, since completion won't run.
            UlCheckinUriCacheEntry(pUriCacheEntry);

            if ( 304 == RetCacheControl )
            {
                // Mark as "served from cache"
                *pServedFromCache = TRUE;
            }
            else
            {
                // We failed it.
                ASSERT(412 == RetCacheControl);

                //
                // Indicate that the parser should send error 412 (Precondition Failed)
                //

                pHttpConn->pRequest->ParseState = ParseErrorState;
                pHttpConn->pRequest->ErrorCode  = UlErrorPreconditionFailed;

                *pServedFromCache = FALSE;
                Status = STATUS_INVALID_DEVICE_STATE;
            }

            // return success.
            goto end;
        }

        // Try to get the corresponding cgroup for the bw settings
        if (pUriCacheEntry)
        {
            pMaxBandwidth = pUriCacheEntry->ConfigInfo.pMaxBandwidth;
        }

        //
        // Install a filter if BWT is enabled for this request's site.
        //
        if (pMaxBandwidth != NULL &&
            pMaxBandwidth->MaxBandwidth.Flags.Present != 0 &&
            pMaxBandwidth->MaxBandwidth.MaxBandwidth  != HTTP_LIMIT_INFINITE )
        {
            // Call TCI to do the filter addition
            UlTcAddFilter( pHttpConn, pMaxBandwidth );
        }
        else
        {
            // Attempt to add the filter to the global flow
            if (UlTcGlobalThrottlingEnabled())
            {
                UlTcAddFilter( pHttpConn, NULL );
            }
        }

        //
        // figure out correct flags
        //
        Flags = 0;

        if ( UlCheckDisconnectInfo(pHttpConn->pRequest) ) {
            Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
        }


        //
        // Start the MinKBSec timer, since the data length
        // is in the UL_URI_CACHE_ENTRY
        //

        BytesToSend = pUriCacheEntry->ContentLength + pUriCacheEntry->HeaderLength;

        UlSetMinKBSecTimer(
            &pHttpConn->TimeoutInfo,
            BytesToSend
            );

        // send from the cache
        Status = UlpSendCacheEntry(
                        pHttpConn,                      // connection
                        Flags,                          // send flags
                        pUriCacheEntry,                 // cache entry
                        NULL,                           // completion routine
                        NULL,                           // completion context
                        NULL
                        );

        *pServedFromCache = TRUE;

        // check in cache entry on failure since our completion
        // routine won't run.
        if ( !NT_SUCCESS(Status) ) {
            UlCheckinUriCacheEntry(pUriCacheEntry);
        }
    } else {
        if (*pConnectionRefused)
        {
            // check in the cache entry if connection is refused
            UlCheckinUriCacheEntry(pUriCacheEntry);
        }
        *pServedFromCache = FALSE;
    }

 end:
    UlTrace(URI_CACHE, (
                "Http!UlSendCachedResponse(httpconn = %p) ServedFromCache = %d, Status = %x\n",
                pHttpConn,
                *pServedFromCache,
                Status
                ));

    return Status;
} // UlSendCachedResponse


/***************************************************************************++

Routine Description:

    If the response is cacheable, then this routine starts building a
    cache entry for it. When the entry is complete it will be sent to
    the client and may be added to the hash table.

Arguments:

    pRequest            - the initiating request
    pResponse           - the generated response
    Flags               - UlSendHttpResponse flags
    pCompletionRoutine  - called after entry is sent
    pCompletionContext  - passed to pCompletionRoutine
    pServedFromCache    - always set. TRUE if we'll handle sending response.
                          FALSE indicates that the caller should send it.

--***************************************************************************/
NTSTATUS
UlCacheAndSendResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG Flags,
    IN HTTP_CACHE_POLICY Policy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    OUT PBOOLEAN pServedFromCache
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check
    //
    PAGED_CODE();
    ASSERT( pServedFromCache );

    //
    // should we close the connection ?
    //
    if ( UlCheckDisconnectInfo(pRequest) )
    {
        Flags |= HTTP_SEND_RESPONSE_FLAG_DISCONNECT;
    }

    //
    // do the real work
    //
    if (UlCheckCacheResponseConditions(pRequest, pResponse, Flags, Policy)) {
        Status = UlpBuildCacheEntry(
                        pRequest,
                        pResponse,
                        pProcess,
                        Flags,
                        Policy,
                        pCompletionRoutine,
                        pCompletionContext
                        );

        if (NT_SUCCESS(Status)) {
            *pServedFromCache = TRUE;
        } else {
            *pServedFromCache = FALSE;
        }
    } else {
        *pServedFromCache = FALSE;
    }

    UlTrace(URI_CACHE, (
                "Http!UlCacheAndSendResponse ServedFromCache = %d\n",
                *pServedFromCache
                ));

    return Status;
} // UlCacheAndSendResponse


/***************************************************************************++

Routine Description:

    Creates a cache entry for the given response. This routine actually
    allocates the entry and partly initializes it. Then it allocates
    a UL_CHUNK_TRACKER to keep track of filesystem reads.

Arguments:

    pRequest            - the initiating request
    pResponse           - the generated response
    Flags               - UlSendHttpResponse flags
    pCompletionRoutine  - called after entry is sent
    pCompletionContext  - passed to pCompletionRoutine

--***************************************************************************/
NTSTATUS
UlpBuildCacheEntry(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG Flags,
    IN HTTP_CACHE_POLICY CachePolicy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_URI_CACHE_ENTRY pEntry = NULL;
    PUL_CHUNK_TRACKER pTracker = NULL;
    ULONG SpaceLength = 0;
    USHORT LogDataLength = 0;
    ULONG ContentLength = (ULONG)(pResponse->ResponseLength - pResponse->HeaderLength);

    //
    // Sanity check
    //
    PAGED_CODE();

    //
    // See if we need to store any logging data. If we need calculate the
    // required cache space for the logging data per format
    //

    if ( pResponse->pLogData )
    {
        switch( pResponse->pLogData->Format )
        {
            case HttpLoggingTypeW3C:
            {
                // The fields until ServerPort will go to the cache entry. 
                // Reserved space for date & time will not be copied.
                LogDataLength = pResponse->pLogData->UsedOffset2
                                - pResponse->pLogData->UsedOffset1;
            }
            break;

            case HttpLoggingTypeNCSA:
            {
                // Only a small fragment of NCSA log line goes to the cache
                // entry. This fragment is located between offset2 and 1
                // excluding the space reserved for date & time fields
                LogDataLength = pResponse->pLogData->UsedOffset2
                                - pResponse->pLogData->UsedOffset1
                                - NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
            }
            break;

            case HttpLoggingTypeIIS:
            {
                // Only the fragments two and three go to the
                // cache entry
                LogDataLength = (USHORT)pResponse->pLogData->Used +
                                pResponse->pLogData->UsedOffset2;
            }
            break;

            default:
            ASSERT(!"Unknown Log Format.\n");
        }

    }

    //
    // allocate a cache entry
    //
    SpaceLength =
        pRequest->CookedUrl.Length + sizeof(WCHAR) +    // space for hash key
        pResponse->ETagLength +                         // space for ETag
        LogDataLength;                                  // space for logging

    UlTrace(URI_CACHE, (
        "Http!UlpBuildCacheEntry allocating UL_URI_CACHE_ENTRY, 0x%x bytes of data\n"
        "    Url.Length = 0x%x, aligned Length = 0x%x\n"
        "\n",
        SpaceLength,
        pRequest->CookedUrl.Length,
        ALIGN_UP(pRequest->CookedUrl.Length, WCHAR)
        ));

    UlTrace(URI_CACHE, (
        "    ContentLength=0x%x, %d\n", ContentLength, ContentLength));

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    UL_URI_CACHE_ENTRY,
                    SpaceLength,
                    UL_URI_CACHE_ENTRY_POOL_TAG
                    );

    if (pEntry) {
        //
        // init entry
        //
        UlInitCacheEntry(
            pEntry,
            pRequest->CookedUrl.Hash,
            pRequest->CookedUrl.Length,
            pRequest->CookedUrl.pUrl
            );

        //
        // Copy the ETag from the response (for If-* headers)
        //
        pEntry->pETag =
            (((PUCHAR) pEntry->UriKey.pUri) +          // start of URI
            pEntry->UriKey.Length + sizeof(WCHAR));    // + length of uri

        pEntry->ETagLength = pResponse->ETagLength;
        if ( pEntry->ETagLength )
        {
            RtlCopyMemory(
                pEntry->pETag,
                pResponse->pETag,
                pEntry->ETagLength
                );
        }

        //
        // Capture Content-Type so we can verify the Accept: header on requests.
        //
        RtlCopyMemory(
            &pEntry->ContentType,
            &pResponse->ContentType,
            sizeof(UL_CONTENT_TYPE)
            );

        //
        // Get the System Time of the Date: header (for If-* headers)
        //
        pEntry->CreationTime.QuadPart = pResponse->CreationTime.QuadPart;

        pEntry->ContentLengthSpecified = pResponse->ContentLengthSpecified;
        pEntry->StatusCode = pResponse->StatusCode;
        pEntry->Verb = pRequest->Verb;

        pEntry->CachePolicy = CachePolicy;

        if (CachePolicy.Policy == HttpCachePolicyTimeToLive)
        {
            KeQuerySystemTime(&pEntry->ExpirationTime);

            //
            // convert seconds to 100 nanosecond intervals (x * 10^7)
            //
            pEntry->ExpirationTime.QuadPart +=
                CachePolicy.SecondsToLive * C_NS_TICKS_PER_SEC;

        } else {
            pEntry->ExpirationTime.QuadPart = 0;
        }

        //
        // Capture the Config Info from the request
        //

        ASSERT(IS_VALID_URL_CONFIG_GROUP_INFO(&pRequest->ConfigInfo));
        UlpConfigGroupInfoDeepCopy(&pRequest->ConfigInfo, &pEntry->ConfigInfo);

        //
        // remember who created us
        //
        pEntry->pProcess = pProcess;

        //
        // generate the content and fixed headers
        //
        pEntry->pResponseMdl = UlLargeMemAllocate(
                                    ContentLength + pResponse->HeaderLength,
                                    &pEntry->LongTermCacheable
                                    );

        if (NULL == pEntry->pResponseMdl)
        {
            Status = STATUS_NO_MEMORY;
            goto cleanup;
        }

        pEntry->HeaderLength = pResponse->HeaderLength;

        if (FALSE == UlLargeMemSetData(
                        pEntry->pResponseMdl,       // Dest MDL
                        pResponse->pHeaders,        // Buffer to copy
                        pResponse->HeaderLength,    // Length to copy
                        ContentLength               // Offset in Dest MDL
                        ))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto cleanup;
        }

        //
        // generate the content body
        //
        pEntry->ContentLength = ContentLength;

        //
        // copy over the log data
        //
        if ( pResponse->pLogData == NULL )
        {
            pEntry->LoggingEnabled = FALSE;
            pEntry->LogDataLength  = 0;
            pEntry->MaxLength      = 0;
            pEntry->pLogData       = NULL;
            pEntry->UsedOffset1    = 0;
            pEntry->UsedOffset2    = 0;
        }
        else
        {
            //
            // There could be no field to save in the cache entry but the logging
            // might still be enabled for those fields we generate later i.e.
            // logging enabled with fields date & time.
            //

            pEntry->LoggingEnabled = TRUE;
            pEntry->MaxLength      = pResponse->pLogData->Length;

            //
            // Copy over the partially complete log line not including the date & time
            // fields to the cache entry. Also remember the length of the data.
            //

            if ( LogDataLength )
            {
                pEntry->LogDataLength = LogDataLength;
                pEntry->pLogData =
                    pEntry->pETag +
                    pEntry->ETagLength;

                switch( pResponse->pLogData->Format )
                {
                    case HttpLoggingTypeW3C:
                    {
                        // Discard the date,time,username fields at the beginning of
                        // the log line when storing the cache entry. 
                        
                        pEntry->UsedOffset1 = pResponse->pLogData->UsedOffset1;
                        pEntry->UsedOffset2 = pResponse->pLogData->UsedOffset2;

                        // Copy the middle fragment
                        
                        RtlCopyMemory(
                                pEntry->pLogData,
                               &pResponse->pLogData->Line[pEntry->UsedOffset1],
                                LogDataLength
                                );
                    }
                    break;

                    case HttpLoggingTypeNCSA:
                    {
                        // Calculate the start of the middle fragment.
                        
                        pEntry->UsedOffset1 = pResponse->pLogData->UsedOffset1
                                              + NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
                        pEntry->UsedOffset2 = 0;
                        
                        // Copy the middle fragment
                        
                        RtlCopyMemory(
                                pEntry->pLogData,
                               &pResponse->pLogData->Line[pEntry->UsedOffset1],
                                LogDataLength
                                );
                    }
                    break;

                    case HttpLoggingTypeIIS:
                    {
                        // UsedOffset1 specifies the second fragment's size.
                        // UsedOffset2 specifies the third's size.
                        
                        pEntry->UsedOffset1 = pResponse->pLogData->UsedOffset2;
                        pEntry->UsedOffset2 = LogDataLength - pEntry->UsedOffset1;
                        
                        // Copy over the fragments two and three
                        
                        RtlCopyMemory(
                                pEntry->pLogData,
                               &pResponse->pLogData->Line[IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET],
                                pEntry->UsedOffset1
                                );
                        RtlCopyMemory(
                               &pEntry->pLogData[pEntry->UsedOffset1],
                               &pResponse->pLogData->Line[IIS_LOG_LINE_THIRD_FRAGMENT_OFFSET],
                                pEntry->UsedOffset2
                                );
                    }
                    break;

                    default:
                    ASSERT(!"Unknown Log Format.\n");
                }

            }
            else
            {
                pEntry->LogDataLength = 0;
                pEntry->pLogData      = NULL;
                pEntry->UsedOffset1   = 0;
                pEntry->UsedOffset2   = 0;
            }

        }

        UlTrace(URI_CACHE, (
            "Http!UlpBuildCacheEntry\n"
            "    entry = %p\n"
            "    pUri = %p '%ls'\n"
            "    pResponseMdl = %p (%d bytes)\n"
            "    pETag = %p\n"
            "    pLogData = %p\n"
            "    end = %p\n",
            pEntry,
            pEntry->UriKey.pUri, pEntry->UriKey.pUri,
            pEntry->pResponseMdl, pEntry->ContentLength + pEntry->HeaderLength,
            pEntry->pETag,
            pEntry->pLogData,
            ((PUCHAR)pEntry->UriKey.pUri) + SpaceLength
            ));

        pTracker =
            UlpAllocateChunkTracker(
                UlTrackerTypeBuildUriEntry,         // tracker type
                0,                                  // send irp size
                pResponse->MaxFileSystemStackSize,  // read irp size
                pRequest->pHttpConn,
                Flags,
                pRequest,
                pResponse,
                pCompletionRoutine,
                pCompletionContext
                );

        if (pTracker) {
            ULONG i;

            //
            // init tracker BuildInfo
            //
            pTracker->BuildInfo.pUriEntry = pEntry;
            pTracker->BuildInfo.Offset = 0;
            UlTrace(LARGE_MEM, ("UlpBuildCacheEntry: init tracker BuildInfo\n"));

            INITIALIZE_FILE_BUFFER(&pTracker->BuildInfo.FileBuffer);

            //
            // skip over the header chunks because we already
            // got that stuff
            //

            for (i = 0; i < HEADER_CHUNK_COUNT; i++) {
                ASSERT( !IS_REQUEST_COMPLETE( pTracker ) );
                UlpIncrementChunkPointer( pTracker );
            }

            //
            // finish initialization on a system thread so that MDLs
            // will get charged to the System process instead of the
            // current process.
            //
            UlpBuildBuildTrackerWorker(&pTracker->WorkItem);

            Status = STATUS_PENDING;
        } else {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }


    } else {
        Status = STATUS_NO_MEMORY;
    }


  cleanup:
    UlTrace(URI_CACHE, (
                "Http!UlpBuildCacheEntry Status = %x, pEntry = %x\n",
                Status,
                pEntry
                ));

    if (!NT_SUCCESS(Status)) {
        if (pEntry) {
            if (pEntry->pResponseMdl) {
                UlLargeMemFree(pEntry->pResponseMdl);
            }
            UL_FREE_POOL_WITH_SIG(pEntry, UL_URI_CACHE_ENTRY_POOL_TAG);
        }

        if (pTracker) {
            UL_FREE_POOL_WITH_SIG(pTracker, UL_CHUNK_TRACKER_POOL_TAG);
        }
    }

    return Status;
} // UlpBuildCacheEntry


/***************************************************************************++

Routine Description:

    Worker Routine used to initialize the UL_CHUNK_TRACKER for
    UlpBuildCacheEntry. We need to have this function so that when
    we make a MDL inside the tracker, the page will be charged to the
    System process instead of the current process.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

--***************************************************************************/
VOID
UlpBuildBuildTrackerWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );
    //
    // init tracker BuildInfo
    //

    UlTrace(LARGE_MEM, ("UlpBuildBuildTrackerWorker\n"));

    //
    // add reference to connection for tracker
    //
    UL_REFERENCE_HTTP_CONNECTION( pTracker->pHttpConnection );

    //
    // Let the worker do the dirty work, no reason to queue off
    //
    // it will queue the first time it needs to do blocking i/o
    //

    UlpBuildCacheEntryWorker(&pTracker->WorkItem);

} // UlpBuildBuildTrackerWorker


/***************************************************************************++

Routine Description:

    Worker routine for managing an in-progress UlpBuildCacheEntry().
    This routine iterates through all the chunks in the response
    and copies the data into the cache entry.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

--***************************************************************************/
VOID
UlpBuildCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;
    NTSTATUS status;
    PUL_INTERNAL_DATA_CHUNK pCurrentChunk;
    PUL_FILE_CACHE_ENTRY pFileCacheEntry;
    PIRP pIrp;
    PIO_STACK_LOCATION pIrpSp;
    PUCHAR pBuffer;
    ULONG BufferLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    UlTrace(URI_CACHE, (
            "Http!UlpBuildCacheEntryWorker: tracker %p\n",
            pTracker
            ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    status = STATUS_SUCCESS;

    while( TRUE )
    {
        //
        // Capture the current chunk pointer, then check for end of
        // response.
        //

        pCurrentChunk = pTracker->pCurrentChunk;

        if (IS_REQUEST_COMPLETE(pTracker))
        {
            ASSERT( status == STATUS_SUCCESS );
            break;
        }

        //
        // Determine the chunk type.
        //

        if (IS_FROM_MEMORY(pCurrentChunk))
        {
            //
            // It's from a locked-down memory buffer. Since these
            // are always handled in-line (never pended) we can
            // go ahead and adjust the current chunk pointer in the
            // tracker.
            //

            UlpIncrementChunkPointer( pTracker );

            //
            // ignore empty buffers
            //

            if (pCurrentChunk->FromMemory.BufferLength == 0)
            {
                continue;
            }

            //
            // Copy the incoming memory.
            //

            ASSERT( pCurrentChunk->FromMemory.pMdl->Next == NULL );

            pBuffer = (PUCHAR) MmGetMdlVirtualAddress(
                pCurrentChunk->FromMemory.pMdl );
            BufferLength = MmGetMdlByteCount( pCurrentChunk->FromMemory.pMdl );

            UlTrace(LARGE_MEM, (
                        "Http!UlpBuildCacheEntryWorker: "
                        "copy range %u (%x) -> %u\n",
                        pTracker->BuildInfo.Offset,
                        BufferLength,
                        pTracker->BuildInfo.Offset
                            + BufferLength
                        ));

            if (FALSE == UlLargeMemSetData(
                            pTracker->BuildInfo.pUriEntry->pResponseMdl,
                            pBuffer,
                            BufferLength,
                            pTracker->BuildInfo.Offset
                            ))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            pTracker->BuildInfo.Offset += BufferLength;
            ASSERT(pTracker->BuildInfo.Offset <= pTracker->BuildInfo.pUriEntry->ContentLength);
        }
        else
        {
            //
            // It's a filesystem MDL.
            //

            ASSERT( IS_FROM_FILE(pCurrentChunk) );

            //
            // ignore empty file ranges
            //

            if (pCurrentChunk->FromFile.ByteRange.Length.QuadPart == 0)
            {
                UlpIncrementChunkPointer( pTracker );
                continue;
            }

            //
            // Do the read.
            //
            pTracker->BuildInfo.FileBuffer.pFileCacheEntry = 
                pCurrentChunk->FromFile.pFileCacheEntry;

            pTracker->BuildInfo.FileBuffer.FileOffset = pTracker->FileOffset;
            pTracker->BuildInfo.FileBuffer.Length =
                MIN(
                    (ULONG)pTracker->FileBytesRemaining.QuadPart,
                    MAX_BYTES_PER_READ
                    );

            pTracker->BuildInfo.FileBuffer.pCompletionRoutine =
                UlpRestartCacheMdlRead;
                
            pTracker->BuildInfo.FileBuffer.pContext = pTracker;

            status = UlReadFileEntry(
                            &pTracker->BuildInfo.FileBuffer,
                            pTracker->pReadIrp
                            );

            break;
        }
    }

    //
    // did everything complete?
    //

    if (status != STATUS_PENDING)
    {
        //
        // yep, complete the response
        //

        UlpCompleteCacheBuild( pTracker, status );
    }

}   // UlpBuildCacheEntryWorker


/***************************************************************************++

Routine Description:

    Completion handler for MDL READ IRPs used for reading file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartCacheMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS status;
    PUL_CHUNK_TRACKER pTracker;
    PMDL pMdl;
    PUCHAR pData;
    ULONG DataLen;

    pTracker = (PUL_CHUNK_TRACKER)pContext;

    UlTrace(URI_CACHE, (
            "Http!UlpRestartCacheMdlRead: tracker %p, status %x info %d\n",
            pTracker,
            pIrp->IoStatus.Status,
            (ULONG) pIrp->IoStatus.Information
            ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );


    status = pIrp->IoStatus.Status;

    if (NT_SUCCESS(status))
    {
        //
        // copy read data into cache buffer
        //
        pMdl = pTracker->BuildInfo.FileBuffer.pMdl;

        while (pMdl) {
            pData = (PUCHAR) MmGetMdlVirtualAddress(pMdl);
            DataLen = MmGetMdlByteCount(pMdl);

            UlTrace(LARGE_MEM, (
                        "Http!UlpRestartCacheMdlRead: "
                        "copy range %u (%x) -> %u\n",
                        pTracker->BuildInfo.Offset,
                        DataLen,
                        pTracker->BuildInfo.Offset
                            + DataLen
                        ));

            if (FALSE == UlLargeMemSetData(
                            pTracker->BuildInfo.pUriEntry->pResponseMdl,
                            pData,
                            DataLen,
                            pTracker->BuildInfo.Offset
                            ))
            {
                status = STATUS_INSUFFICIENT_RESOURCES;
                goto end;
            }

            pTracker->BuildInfo.Offset += DataLen;
            ASSERT(pTracker->BuildInfo.Offset <= pTracker->BuildInfo.pUriEntry->ContentLength);

            pMdl = pMdl->Next;
        }

        //
        // free the MDLs
        //

        pTracker->BuildInfo.FileBuffer.pCompletionRoutine =
            UlpRestartCacheMdlFree;

        pTracker->BuildInfo.FileBuffer.pContext = pTracker;

        status = UlReadCompleteFileEntry(
                        &pTracker->BuildInfo.FileBuffer,
                        pTracker->pReadIrp
                        );
    }

end:

    if (!NT_SUCCESS(status))
    {
        UlpCompleteCacheBuild( pTracker, status );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartCacheMdlRead


/***************************************************************************++

Routine Description:

    Completion handler for MDL free IRPs used after reading file data.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CHUNK_TRACKER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartCacheMdlFree(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS status;
    PUL_CHUNK_TRACKER pTracker;

    pTracker = (PUL_CHUNK_TRACKER)pContext;

    UlTrace(URI_CACHE, (
            "Http!UlpRestartCacheMdlFree: tracker %p, status %x info %d\n",
            pTracker,
            pIrp->IoStatus.Status,
            (ULONG) pIrp->IoStatus.Information
            ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    status = pIrp->IoStatus.Status;

    if (NT_SUCCESS(status))
    {
        //
        // Update the file offset & bytes remaining. If we've
        // finished this file chunk (bytes remaining is now zero)
        // then advance to the next chunk.
        //

        pTracker->FileOffset.QuadPart += pIrp->IoStatus.Information;
        pTracker->FileBytesRemaining.QuadPart -= pIrp->IoStatus.Information;

        if (pTracker->FileBytesRemaining.QuadPart == 0 )
        {
            UlpIncrementChunkPointer( pTracker );
        }

        //
        // Go back into the loop if there's more to read
        //

        if (IS_REQUEST_COMPLETE(pTracker)) {
            UlpCompleteCacheBuild( pTracker, status );
        } else {
            UL_CALL_PASSIVE(
                &pTracker->WorkItem,
                &UlpBuildCacheEntryWorker
                );
        }
    }

    if (!NT_SUCCESS(status))
    {
        UlpCompleteCacheBuild( pTracker, status );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartCacheMdlFree



/***************************************************************************++

Routine Description:

    This routine gets called when we finish building a cache entry.

Arguments:

    pTracker - Supplies the tracker to complete.
    Status - Supplies the completion status.

--***************************************************************************/
VOID
UlpCompleteCacheBuild(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    )
{
    UlTrace(URI_CACHE, (
            "Http!UlpCompleteCacheBuild: tracker %p, status %08lx\n",
            pTracker,
            Status
            ));

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    UL_CALL_PASSIVE(
        &pTracker->WorkItem,
        &UlpCompleteCacheBuildWorker
        );

}   // UlpCompleteCacheBuild

/***************************************************************************++

Routine Description:

    Called when we finish building a cache entry. If the entry was
    built successfully, we send the response down the wire.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CHUNK_TRACKER.

--***************************************************************************/
VOID
UlpCompleteCacheBuildWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CHUNK_TRACKER pTracker;
    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    PUL_HTTP_CONNECTION pHttpConnection;
    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;
    ULONG Flags;
    PUL_LOG_DATA_BUFFER pLogData;
    NTSTATUS Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_CHUNK_TRACKER,
                    WorkItem
                    );

    ASSERT( IS_VALID_CHUNK_TRACKER( pTracker ) );

    pUriCacheEntry = pTracker->BuildInfo.pUriEntry;
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    Flags = pTracker->Flags;
    pHttpConnection = pTracker->pHttpConnection;
    pCompletionRoutine = pTracker->pCompletionRoutine;
    pCompletionContext = pTracker->pCompletionContext;

    //
    // save the logging data pointer before
    // releasing the tracker and its response
    // pointer.
    //
    pLogData = pTracker->pResponse->pLogData;
    if (pLogData)
    {
        //
        // To prevent SendResponse to free our
        // log buffer
        //
        pTracker->pResponse->pLogData = NULL;

        //
        // give the sign that this log data buffer
        // is ready and later there's no need to
        // refresh its content from cache again.
        //
        pLogData->CacheAndSendResponse = TRUE;
    }

    //
    // free the read tracker
    //

    UlpFreeChunkTracker( pTracker );

    //
    // try to put the entry into the hash table
    //
    UlAddCacheEntry(pUriCacheEntry);

    //
    // grab the connection lock (because UlpSendCacheEntry
    // assumes you have it)
    //
    UlAcquireResourceExclusive(&(pHttpConnection->Resource), TRUE);

    //
    // Send the cache entry
    //
    Status = UlpSendCacheEntry(
                    pHttpConnection,                // connection
                    Flags,                          // flags
                    pUriCacheEntry,                 // cache entry
                    pCompletionRoutine,             // completion routine
                    pCompletionContext,             // completion context
                    pLogData                        // corresponding log data
                    );

    //
    // get rid of the entry if it didn't work
    //
    if ( !NT_SUCCESS(Status) )
    {
        UlCheckinUriCacheEntry(pUriCacheEntry);

        //
        // Free up the log data buffer (if we passed it
        // into UlpSendCacheEntry)
        //
        if ( pLogData )
        {
            UlDestroyLogDataBuffer(pLogData);
        }
    }

    //
    // done with the connection lock
    //
    UlReleaseResource(&(pHttpConnection->Resource));

    //
    // now that UL_FULL_TRACKER has a reference, we can release
    // our hold on the connection.
    //
    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);

    //
    // if it's not STATUS_PENDING for some reason, complete the request
    //

    if (Status != STATUS_PENDING && pCompletionRoutine != NULL)
    {
        (pCompletionRoutine)(
            pCompletionContext,
            Status,
            0
            );
    }

}  // UlpCompleteCacheBuildWorker

/***************************************************************************++

Routine Description:

    Sends a cache entry down the wire.

    The logging related part of this function below, surely depend on
    the fact that pCompletionContext will be null if this is called for
    pure cache hits (in other words from ULSendCachedResponse) otherwise
    pointer to Irp will be passed down as the pCompletionContext.

Arguments:

    All the time

--***************************************************************************/
NTSTATUS
UlpSendCacheEntry(
    PUL_HTTP_CONNECTION pHttpConnection,
    ULONG Flags,
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    PUL_COMPLETION_ROUTINE pCompletionRoutine,
    PVOID pCompletionContext,
    PUL_LOG_DATA_BUFFER pLogData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PUL_FULL_TRACKER pTracker;
    CCHAR SendIrpStackSize;
    UL_CONN_HDR ConnHeader;
    ULONG VarHeaderGenerated;
    ULONG TotalLength;
    ULONG contentLengthStringLength;
    UCHAR contentLength[MAX_ULONGLONG_STR];
    LARGE_INTEGER liCreationTime;

    //
    // Sanity check
    //
    PAGED_CODE();

    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConnection) );
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );
    ASSERT( UlDbgResourceOwnedExclusive(&pHttpConnection->Resource) );

    UlTrace(URI_CACHE, (
                "Http!UlpSendCacheEntry(httpconn %p, flags %x, uri %p, ...)\n",
                pHttpConnection,
                Flags,
                pUriCacheEntry
                ));

    //
    // init vars so we can cleanup correctly if we jump to the end
    //

    pTracker = NULL;

    //
    // make sure we're still connected
    //
    if (pHttpConnection->UlconnDestroyed) {
        Status = STATUS_CONNECTION_ABORTED;
        goto cleanup;
    }

    ASSERT( pHttpConnection->pRequest );

    //
    // figure out how much space we need for variable headers
    //

    if (!pUriCacheEntry->ContentLengthSpecified &&
        UlNeedToGenerateContentLength(
            pUriCacheEntry->Verb,
            pUriCacheEntry->StatusCode,
            Flags
            ))
    {
        //
        // Autogenerate a content-length header.
        //

        PCHAR pszEnd = UlStrPrintUlonglong(
                           (PCHAR) contentLength,
                           (ULONGLONG) pUriCacheEntry->ContentLength,
                           '\0');
        contentLengthStringLength = DIFF(pszEnd - (PCHAR) contentLength);
    }
    else
    {
        //
        // Either we cannot or do not need to autogenerate a
        // content-length header.
        //

        contentLength[0] = '\0';
        contentLengthStringLength = 0;
    }

    ConnHeader = UlChooseConnectionHeader(
                    pHttpConnection->pRequest->Version,
                    (BOOLEAN)(Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT)
                    );

    //
    // create tracker
    //

    SendIrpStackSize =
        pHttpConnection->pConnection->ConnectionObject.pDeviceObject->StackSize;

    if (SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE)
    {
        pTracker = UlpAllocateCacheTracker(SendIrpStackSize);
    }
    else
    {
        pTracker = pHttpConnection->pRequest->pTracker;
    }

    if (pTracker) {
        //
        // init tracker
        //
        pTracker->pUriEntry = pUriCacheEntry;

        UL_REFERENCE_HTTP_CONNECTION(pHttpConnection);
        pTracker->pHttpConnection = pHttpConnection;

        UL_REFERENCE_INTERNAL_REQUEST(pHttpConnection->pRequest);
        pTracker->pRequest = pHttpConnection->pRequest;

        pTracker->pCompletionRoutine = pCompletionRoutine;
        pTracker->pCompletionContext = pCompletionContext;
        pTracker->Flags = Flags;
        pTracker->pLogData = NULL;

        //
        // build MDLs for send
        //
        ASSERT(pUriCacheEntry->pResponseMdl != NULL);

        MmInitializeMdl(
            pTracker->pMdlFixedHeaders,
            (PCHAR) MmGetMdlVirtualAddress(pUriCacheEntry->pResponseMdl) + pUriCacheEntry->ContentLength,
            pUriCacheEntry->HeaderLength
            );

        IoBuildPartialMdl(
            pUriCacheEntry->pResponseMdl,
            pTracker->pMdlFixedHeaders,
            (PCHAR) MmGetMdlVirtualAddress(pUriCacheEntry->pResponseMdl) + pUriCacheEntry->ContentLength,
            pUriCacheEntry->HeaderLength
            );

        //
        // generate variable headers
        // and build a MDL for them
        //

        UlGenerateVariableHeaders(
            ConnHeader,
            contentLength,
            contentLengthStringLength,
            pTracker->pAuxiliaryBuffer,
            &VarHeaderGenerated,
            &liCreationTime
            );

        ASSERT( VarHeaderGenerated <= g_UlMaxVariableHeaderSize );
        ASSERT( VarHeaderGenerated <= pTracker->AuxilaryBufferLength );

        if (0 == pUriCacheEntry->CreationTime.QuadPart)
        {
            //
            // If we were unable to capture the Last-Modified time from the
            // original item, use the time we created this cache entry.
            //
            pUriCacheEntry->CreationTime.QuadPart = liCreationTime.QuadPart;
        }

        pTracker->pMdlVariableHeaders->ByteCount = VarHeaderGenerated;
        pTracker->pMdlFixedHeaders->Next = pTracker->pMdlVariableHeaders;

        //
        // build MDL for body
        //
        if (pUriCacheEntry->ContentLength)
        {
            MmInitializeMdl(
                pTracker->pMdlContent,
                MmGetMdlVirtualAddress(pUriCacheEntry->pResponseMdl),
                pUriCacheEntry->ContentLength
                );

            IoBuildPartialMdl(
                pUriCacheEntry->pResponseMdl,
                pTracker->pMdlContent,
                MmGetMdlVirtualAddress(pUriCacheEntry->pResponseMdl),
                pUriCacheEntry->ContentLength
                );

            pTracker->pMdlVariableHeaders->Next = pTracker->pMdlContent;
        }
        else
        {
            pTracker->pMdlVariableHeaders->Next = NULL;
        }

        //
        // We have to log this cache hit. time to allocate a log
        // data buffer and set its request pointer. But only if we
        // had the logging data cached before.
        //
        if (pUriCacheEntry->LoggingEnabled)
        {
            //
            // If this was a user call (UlCacheAndSendResponse) then
            // pCompletionContext will be the pIrp pointer otherwise
            // NULL. As for the build&send cache requests we already
            // allocated a log buffer let's use that one to prevent
            // unnecessary reallocation and copying. Also the pLogData
            // pointer will be NULL if this is a pure cache hit but not
            // CacheAndSend.
            //
            // REVIEW: AliTu mentioned that checking there might be a better
            // REVIEW: way to check and see if this is a "build cache entry"
            // REVIEW: case than checking if pCompletionContext is non-NULL.
            //

            if (pCompletionContext)
            {
                ASSERT(pLogData);
                pTracker->pLogData = pLogData;
            }
            else
            {
                PUL_INTERNAL_REQUEST pRequest = pHttpConnection->pRequest;

                //
                // Pure cache hit
                //

                ASSERT(pLogData==NULL);

                pTracker->pLogData = &pRequest->LogData;

                Status = UlAllocateLogDataBuffer(
                            pTracker->pLogData,
                            pRequest,
                            pUriCacheEntry->ConfigInfo.pLoggingConfig
                            );
                ASSERT(NT_SUCCESS(Status));
            }
        }

        //
        // go go go!
        //
        TotalLength = pUriCacheEntry->HeaderLength;
        TotalLength += pUriCacheEntry->ContentLength;
        TotalLength += VarHeaderGenerated;

        Status = UlSendData(
                        pTracker->pHttpConnection->pConnection,
                        pTracker->pMdlFixedHeaders,
                        TotalLength,
                        &UlpCompleteSendCacheEntry,
                        pTracker,
                        pTracker->pSendIrp,
                        &pTracker->IrpContext,
                        (BOOLEAN)((Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) != 0)
                        );
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

cleanup:

    //
    // clean up the tracker if we don't need it
    //
    if (!NT_SUCCESS(Status)) {
        if (pTracker) {
            if (pLogData == NULL && pTracker->pLogData)
            {
                //
                // if we allocated a Log Data Buffer, we need to free it;
                // Caller will free if it was passed in.
                //
                UlDestroyLogDataBuffer(pTracker->pLogData);
            }

            UlpFreeCacheTracker(pTracker);

            UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);
            UL_DEREFERENCE_INTERNAL_REQUEST(pHttpConnection->pRequest);
        }
    }

    UlTrace(URI_CACHE, (
                "Http!UlpSendCacheEntry status = %08x\n",
                Status
                ));

    return Status;
} // UlpSendCacheEntry


/***************************************************************************++

Routine Description:

    Called when we finish sending data to the client. Just queues to
    a worker that runs at passive level.

Arguments:

    pCompletionContext - pointer to UL_FULL_TRACKER
    Status             - status of send
    Information        - Bytes transferred.

--***************************************************************************/
VOID
UlpCompleteSendCacheEntry(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_FULL_TRACKER pTracker;

    pTracker = (PUL_FULL_TRACKER) pCompletionContext;

    pTracker->IoStatus.Status = Status;
    pTracker->IoStatus.Information = Information;

    UlTrace(URI_CACHE,
            ("UlpCompleteSendCacheEntry: "
             "tracker=%p, status = %x, transferred %d bytes\n",
             pTracker, Status, (int) Information));

    //
    // invoke completion routine
    //
    if (pTracker->pCompletionRoutine != NULL)
    {
        (pTracker->pCompletionRoutine)(
            pTracker->pCompletionContext,
            Status,
            Information
            );
    }

    UL_QUEUE_WORK_ITEM(
        &pTracker->WorkItem,
        &UlpCompleteSendCacheEntryWorker
        );
}


/***************************************************************************++

Routine Description:

    Called when we finish sending cached data to the client. This routine
    frees the UL_FULL_TRACKER, and calls the completion routine originally
    passed to UlCacheAndSendResponse.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_FULL_TRACKER.

--***************************************************************************/
VOID
UlpCompleteSendCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_FULL_TRACKER pTracker;
    PUL_HTTP_CONNECTION pHttpConnection;
    PUL_INTERNAL_REQUEST pRequest;
    ULONG Flags;
    PUL_URI_CACHE_ENTRY pUriCacheEntry;
    NTSTATUS Status;
    KIRQL OldIrql;

    //
    // Sanity check
    //
    PAGED_CODE();

    pTracker = CONTAINING_RECORD(
                    pWorkItem,
                    UL_FULL_TRACKER,
                    WorkItem
                    );

    UlTrace(URI_CACHE, (
                "Http!UlpCompleteSendCacheEntryWorker(pTracker %p)\n",
                pTracker
                ));


    //
    // pull context out of tracker
    //
    pHttpConnection = pTracker->pHttpConnection;
    ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConnection) );

    pRequest = pTracker->pRequest;
    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );

    Flags = pTracker->Flags;
    pUriCacheEntry = pTracker->pUriEntry;
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    Status = pTracker->IoStatus.Status;

    //
    // If the send failed and we did't ask UlSendData() to disconnect
    // the connection, then initiate an *abortive* disconnect.
    //
    if ((NT_SUCCESS(Status) == FALSE) &&
        ((pTracker->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) == 0))
    {
        UlTrace(URI_CACHE, (
                    "Http!UlpCompleteSendCacheEntryWorker(pTracker %p) Closing connection\n",
                    pTracker
                    ));

        UlCloseConnection(
            pHttpConnection->pConnection,
            TRUE,
            NULL,
            NULL
            );
    }

    //
    // Stop MinKBSec timer and start Connection Idle timer
    //

    UlLockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        &OldIrql
        );

    UlResetConnectionTimer(
        &pHttpConnection->TimeoutInfo,
        TimerMinKBSec
        );

    UlSetConnectionTimer(
        &pHttpConnection->TimeoutInfo,
        TimerConnectionIdle
        );

    UlUnlockTimeoutInfo(
        &pHttpConnection->TimeoutInfo,
        OldIrql
        );

    UlEvaluateTimerState(
        &pHttpConnection->TimeoutInfo
        );

    //
    // unmap the FixedHeaders and Content MDLs if necessary
    //
    if (pTracker->pMdlFixedHeaders->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
    {
        MmUnmapLockedPages(
            pTracker->pMdlFixedHeaders->MappedSystemVa,
            pTracker->pMdlFixedHeaders
            );
    }

    if (pTracker->pMdlContent->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA)
    {
        MmUnmapLockedPages(
            pTracker->pMdlContent->MappedSystemVa,
            pTracker->pMdlContent
            );
    }

    //
    // Do the logging before cleaning up the tracker.
    //
    if (pTracker->pLogData)
    {
        //
        // Call the cache logger. It will copy over the
        // cached logging data for us, and log it out.
        //

        UlLogHttpCacheHit( pTracker );
    }

    //
    // Kick the parser into action only if this cache response comes from
    // the UlpCompleteCacheBuildWorker path, in which case UlpSendCacheEntry
    // is called with a non-null pCompletionContext.
    //
    if (pTracker->pCompletionContext)
    {
        UlResumeParsing(pHttpConnection);
    }

    //
    // clean up tracker
    //
    UlpFreeCacheTracker(pTracker);

    //
    // deref cache entry
    //
    UlCheckinUriCacheEntry(pUriCacheEntry);

    //
    // deref the internal request
    //
    UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);

    //
    // deref http connection
    //
    UL_DEREFERENCE_HTTP_CONNECTION(pHttpConnection);

} // UlpCompleteSendCacheEntryWorker


/***************************************************************************++

Routine Description:

    Allocates a non-paged UL_FULL_TRACKER used as context for sending
    cached content to the client.

    CODEWORK: this routine should probably do all tracker init.

Arguments:

    SendIrpStackSize - Size of the stack for the send IRP

Return Values:

    Either a pointer to a UL_FULL_TRACKER, or NULL if it couldn't be made.

--***************************************************************************/
PUL_FULL_TRACKER
UlpAllocateCacheTracker(
    IN CCHAR SendIrpStackSize
    )
{
    PUL_FULL_TRACKER pTracker;
    USHORT SendIrpSize;
    ULONG CacheTrackerSize;

    //
    // Sanity check
    //

    PAGED_CODE();
    ASSERT(SendIrpStackSize > DEFAULT_MAX_IRP_STACK_SIZE);

    SendIrpSize = (USHORT)ALIGN_UP(IoSizeOfIrp(SendIrpStackSize), PVOID);

    //
    // No need to allocate space for the entire auxiliary buffer in this
    // case since this is one-time deal only.
    //

    CacheTrackerSize = ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID) +
                        SendIrpSize +
                        g_UlMaxVariableHeaderSize +
                        g_UlFixedHeadersMdlLength +
                        g_UlVariableHeadersMdlLength +
                        g_UlContentMdlLength;

    pTracker = (PUL_FULL_TRACKER)UL_ALLOCATE_POOL(
                                    NonPagedPool,
                                    CacheTrackerSize,
                                    UL_FULL_TRACKER_POOL_TAG
                                    );

    if (pTracker)
    {
        pTracker->Signature = UL_FULL_TRACKER_POOL_TAG;
        pTracker->IsFromLookaside = FALSE;
        pTracker->IsFromRequest = FALSE;
        pTracker->AuxilaryBufferLength = g_UlMaxVariableHeaderSize;

        UlInitializeFullTrackerPool(pTracker, SendIrpStackSize);
    }

    UlTrace( URI_CACHE, (
        "Http!UlpAllocateCacheTracker: tracker %p\n",
        pTracker
        ));

    return pTracker;

} // UlpAllocateCacheTracker


/***************************************************************************++

Routine Description:

    Frees a UL_FULL_TRACKER.

    CODEWORK: this routine should probably do all the destruction

Arguments:

    pTracker - Specifies the UL_FULL_TRACKER to free.

--***************************************************************************/
VOID
UlpFreeCacheTracker(
    IN PUL_FULL_TRACKER pTracker
    )
{
    UlTrace(URI_CACHE, (
            "Http!UlpFreeCacheTracker: tracker %p\n",
            pTracker
            ));

    ASSERT(pTracker);
    ASSERT(IS_VALID_FULL_TRACKER(pTracker));

    if (pTracker->IsFromRequest == FALSE)
    {
        if (pTracker->IsFromLookaside)
        {
            pTracker->Signature = MAKE_FREE_TAG(UL_FULL_TRACKER_POOL_TAG);
            UlPplFreeFullTracker( pTracker );
        }
        else
        {
            UL_FREE_POOL_WITH_SIG( pTracker, UL_FULL_TRACKER_POOL_TAG );
        }
    }
}


/***************************************************************************++

Routine Description:

    A helper function that allocates an MDL for a range of memory, and
    locks it down. UlpSendCacheEntry uses these MDLs to make sure the
    (normally paged) cache entries don't get paged out when TDI is
    sending them.

Arguments:

    VirtualAddress  - address of the memory
    Length          - length of the memory
    Operation       - either IoWriteAcess or IoReadAccess

--***************************************************************************/
PMDL
UlpAllocateLockedMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    )
{
    PMDL pMdl = NULL;
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Sanity check
    //
    PAGED_CODE();


    __try {

        pMdl = UlAllocateMdl(
                    VirtualAddress,     // VirtualAddress
                    Length,             // Length
                    FALSE,              // SecondaryBuffer
                    FALSE,              // ChargeQuota
                    NULL                // Irp
                    );

        if (pMdl) {

            MmProbeAndLockPages(
                pMdl,                   // MDL
                KernelMode,             // AccessMode
                Operation               // Operation
                );

        }
    }
    __except( UL_EXCEPTION_FILTER() )
    {
        //
        // Can this really happen?
        //
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());

        UlFreeMdl(pMdl);
        pMdl = NULL;
    }

    if (!pMdl || !NT_SUCCESS(Status)) {
        UlTrace(URI_CACHE, (
                    "Http!UlpAllocateLockedMdl failed %08x\n",
                    Status
                    ));
    }

    return pMdl;
}


/***************************************************************************++

Routine Description:

    Unlocks and frees an MDL allocated with UlpAllocateLockedMdl.

Arguments:

    pMdl - the MDL to free

--***************************************************************************/
VOID
UlpFreeLockedMdl(
    PMDL pMdl
    )
{
    //
    // Sanity check
    //
    ASSERT( IS_MDL_LOCKED(pMdl) );

    MmUnlockPages(pMdl);
    UlFreeMdl(pMdl);
}


/***************************************************************************++

Routine Description:

    A helper function that initializes an MDL for a range of memory, and
    locks it down. UlpSendCacheEntry uses these MDLs to make sure the
    (normally paged) cache entries don't get paged out when TDI is
    sending them.

Arguments:

    pMdl            - memory descriptor for the MDL to initialize
    VirtualAddress  - address of the memory
    Length          - length of the memory
    Operation       - either IoWriteAcess or IoReadAccess

--***************************************************************************/
NTSTATUS
UlpInitializeAndLockMdl(
    IN PMDL pMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    )
{
    NTSTATUS Status;

    //
    // Sanity check
    //
    PAGED_CODE();

    Status = STATUS_SUCCESS;

    __try {

        MmInitializeMdl(
            pMdl,
            VirtualAddress,
            Length
            );

        MmProbeAndLockPages(
            pMdl,                   // MDL
            KernelMode,             // AccessMode
            Operation               // Operation
            );

    }
    __except( UL_EXCEPTION_FILTER() )
    {
        //
        // Can this really happen?
        //
        Status = UL_CONVERT_EXCEPTION_CODE(GetExceptionCode());

        UlTrace(URI_CACHE, (
                    "UL!UlpInitializeAndLockMdl failed %08x\n",
                    Status
                    ));
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    Checks the request to see if it has any of the following headers:
      If-Modified-Since:
      If-Match:
      If-None-Match:

    If so, we see if we can skip the sending of the full item.  If we can skip,
    we send back the apropriate response of either 304 (not modified) or
    set the parser state to send back a 412 (precondition not met).

Arguments:

    pRequest - The request to check

    pUriCacheEntry - The cache entry being requested

Returns:

    0     Send cannot be skipped; continue with sending the cache entry.

    304   Send can be skipped.  304 response sent.  NOTE: pRequest may be
          invalid on return.

    412   Send can be skipped.  pRequest->ParseState set to ParseErrorState with
          pRequest->ErrorCode set to UlErrorPreconditionFailed (412)


--***************************************************************************/
ULONG
UlpCheckCacheControlHeaders(
        PUL_INTERNAL_REQUEST pRequest,
        PUL_URI_CACHE_ENTRY  pUriCacheEntry
        )
{
    ULONG RetStatus             = 0;    // Assume can't skip.
    BOOLEAN fIfNoneMatchPassed  = TRUE;
    BOOLEAN fSkipIfModifiedSince = FALSE;
    LARGE_INTEGER liModifiedSince;
    LARGE_INTEGER liUnmodifiedSince;
    LARGE_INTEGER liNow;
    ULONG         BytesSent     = 0;

    ASSERT( UL_IS_VALID_INTERNAL_REQUEST(pRequest) );
    ASSERT( IS_VALID_URI_CACHE_ENTRY(pUriCacheEntry) );

    //
    // 1. Check If-Match
    //
    if ( pRequest->HeaderValid[HttpHeaderIfMatch] )
    {
        if ( !FindInETagList( pUriCacheEntry->pETag,
                              pRequest->Headers[HttpHeaderIfMatch].pHeader,
                              FALSE) )
        {
            // Match failed.
            goto PreconditionFailed;
        }

    }

    //
    // 2. Check If-None-Match
    //
    if ( pRequest->HeaderValid[HttpHeaderIfNoneMatch] )
    {
        if ( FindInETagList( pUriCacheEntry->pETag,
                             pRequest->Headers[HttpHeaderIfNoneMatch].pHeader,
                             TRUE) )
        {
            // ETag found on list.
            fIfNoneMatchPassed = FALSE;
        }
        else
        {
            //
            // Header present and ETag not found on list.  This modifies
            // the semantic of the If-Modified-Since header; Namely,
            // If-None-Match takes precidence over If-Modified-Since.
            //
            fSkipIfModifiedSince = TRUE;
        }
    }

    //
    // 3. Check If-Modified-Since
    //
    if ( !fSkipIfModifiedSince &&
         pRequest->HeaderValid[HttpHeaderIfModifiedSince] )
    {
        if ( StringTimeToSystemTime(
                (const PSTR) pRequest->Headers[HttpHeaderIfModifiedSince].pHeader,
                &liModifiedSince) )
        {
            //
            // If the cache entry was created before the
            // time specified in the If-Modified-Since header, we
            // can return a 304 (Not Modified) status.
            //
            if ( pUriCacheEntry->CreationTime.QuadPart <= liModifiedSince.QuadPart )
            {
                //
                // Check if the time specified in the request is
                // greater than the current time (i.e., Invalid).  If it is,
                // ignore the If-Modified-Since header.
                //
                KeQuerySystemTime(&liNow);

                if ( liModifiedSince.QuadPart < liNow.QuadPart )
                {
                    // Valid time.
                    goto NotModified;
                }
            }
        }

        //
        // If-Modified-Since overrides If-None-Match.
        //
        fIfNoneMatchPassed = TRUE;

    }

    if ( !fIfNoneMatchPassed )
    {
        //
        // We could either skip the If-Modified-Since header, or it
        // was not present, AND we did not pass the If-None-Match
        // predicate.  Since this is a "GET" or "HEAD" request (because
        // that's all we cache, we should return 304.  If this were
        // any other verb, we should return 412.
        //
        ASSERT( (HttpVerbGET == pRequest->Verb) || (HttpVerbHEAD == pRequest->Verb) );
        goto NotModified;
    }

    //
    // 4. Check If-Unmodified-Since
    //
    if ( pRequest->HeaderValid[HttpHeaderIfUnmodifiedSince] )
    {
        if ( StringTimeToSystemTime(
                (const PSTR) pRequest->Headers[HttpHeaderIfUnmodifiedSince].pHeader,
                &liUnmodifiedSince) )
        {
            //
            // If the cache entry was created after the time
            // specified in the If-Unmodified-Since header, we
            // MUST return a 412 (Precondition Failed) status.
            //
            if ( pUriCacheEntry->CreationTime.QuadPart > liUnmodifiedSince.QuadPart )
            {
                goto PreconditionFailed;
            }
        }
    }


 Cleanup:

    return RetStatus;

 NotModified:

    RetStatus = 304;

    //
    // Send 304 (Not Modified) response
    //

    BytesSent =
        UlSendSimpleStatus(
            pRequest,
            UlStatusNotModified
            );

    //
    // Update the server to client bytes sent.
    // The logging & perf counters will use it.
    //

    pRequest->BytesSent += BytesSent;

    goto Cleanup;

 PreconditionFailed:

    RetStatus = 412;

    goto Cleanup;
}



/***************************************************************************++

Routine Description:

    Checks the cached response against the "Accept:" header in the request
    to see if it can satisfy the requested Content-Type(s).

    (Yes, I know this is really gross...I encourage anyone to find a better
     way to parse this! --EricSten)

Arguments:

    pRequest - The request to check.

    pUriCacheEntry - The cache entry that might possibly match.

Returns:

    TRUE    At least one of the possible formats matched the Content-Type
            of the cached entry.

    FALSE   None of the requested types matched the Content-Type of the
            cached entry.

--***************************************************************************/
BOOLEAN
UlpIsAcceptHeaderOk(
        PUL_INTERNAL_REQUEST pRequest,
        PUL_URI_CACHE_ENTRY  pUriCacheEntry
        )
{
    BOOLEAN     bRet = TRUE;
    ULONG       Len;
    PUCHAR      pHdr;
    PUCHAR      pSubType;
    PUCHAR      pTmp;
    PUL_CONTENT_TYPE pContentType;

    if ( pRequest->HeaderValid[HttpHeaderAccept] &&
         (pRequest->Headers[HttpHeaderAccept].HeaderLength > 0) )
    {
        Len  = pRequest->Headers[HttpHeaderAccept].HeaderLength;
        pHdr = pRequest->Headers[HttpHeaderAccept].pHeader;

        pContentType = &pUriCacheEntry->ContentType;

        //
        // First, do "fast-path" check; see if "*/*" is anywhere in the header.
        //
        pTmp = (PUCHAR) strstr( (const char*) pHdr, "*/*" );

        //
        // If we found "*/*" and its either at the beginning of the line,
        // the end of the line, or surrounded by either ' ' or ',', then
        // it's really a wildcard.
        //

        if ((pTmp != NULL) &&
                ((pTmp == pHdr) ||
                 IS_HTTP_LWS(pTmp[-1]) ||
                 (pTmp[-1] == ',')) &&

                ((pTmp[3] == '\0') ||
                 IS_HTTP_LWS(pTmp[3]) ||
                 (pTmp[3] == ',')))
        {
            goto end;
        }

        //
        // Wildcard not found; continue with slow path
        //

        while (Len)
        {
            if (pContentType->TypeLen > Len)
            {
                // Bad! No more string left...Bail out.
                bRet = FALSE;
                goto end;
            }

            if ( (pContentType->TypeLen == RtlCompareMemory(
                                            pHdr,
                                            pContentType->Type,
                                            pContentType->TypeLen
                                            )) &&
                 ( '/' == pHdr[pContentType->TypeLen] ) )
            {
                //
                // Found matching type; check subtype
                //

                pSubType = &pHdr[pContentType->TypeLen + 1];

                if ( '*' == *pSubType )
                {
                    // Subtype wildcard match!
                    goto end;
                }
                else
                {
                    if ( pContentType->SubTypeLen >
                         (Len - ( pContentType->TypeLen + 1 )) )
                    {
                        // Bad!  No more string left...Bail out.
                        bRet = FALSE;
                        goto end;
                    }

                    if ( pContentType->SubTypeLen == RtlCompareMemory(
                                                    pSubType,
                                                    pContentType->SubType,
                                                    pContentType->SubTypeLen
                                                    ) &&
                         !IS_HTTP_TOKEN(pSubType[pContentType->SubTypeLen]) )
                    {
                        // Subtype exact match!
                        goto end;
                    }
                }
            }

            //
            // Didn't match this one; advance to next Content-Type in the Accept field
            //

            pTmp = (PUCHAR) strchr( (const char *) pHdr, ',' );
            if (pTmp)
            {
                // Found a comma; step over it and any whitespace.

                ASSERT ( Len > DIFF(pTmp - pHdr));
                Len -= (DIFF(pTmp - pHdr) +1);
                pHdr = (pTmp+1);

                while( Len && IS_HTTP_LWS(*pHdr) )
                {
                    pHdr++;
                    Len--;
                }

            } else
            {
                // No more content-types; bail.
                bRet = FALSE;
                goto end;
            }

        } // walk list of things

        //
        // Walked all Accept items and didn't find a match.
        //
        bRet = FALSE;
    }

 end:

    return bRet;
} // UlpIsAcceptHeaderOk


/***************************************************************************++

Routine Description:

    parses a content-type into its type and subtype components.

Arguments:

    pStr            String containing valid content type

    StrLen          Length of string (in bytes)

    pContentType    pointer to user provided UL_CONTENT_TYPE structure


--***************************************************************************/

VOID
UlpGetTypeAndSubType(
    PSTR pStr,
    ULONG  StrLen,
    PUL_CONTENT_TYPE pContentType
    )
{
    PCHAR  pSlash;

    ASSERT(pStr && StrLen);
    ASSERT(pContentType);

    pSlash = strchr(pStr, '/');
    if (NULL == pSlash)
    {
        //
        // BAD!  content types should always have a slash!
        //
        ASSERT( NULL != pSlash );
        return;
    }

    pContentType->TypeLen = (ULONG) MIN( (pSlash - pStr), MAX_TYPE_LENGTH );

    RtlCopyMemory(
        pContentType->Type,
        pStr,
        pContentType->TypeLen
        );

    ASSERT( StrLen > (pContentType->TypeLen + 1) );
    pContentType->SubTypeLen = MIN( (StrLen - (pContentType->TypeLen + 1)), MAX_SUBTYPE_LENGTH );

    RtlCopyMemory(
        pContentType->SubType,
        pSlash+1,
        pContentType->SubTypeLen
        );
    
} // UlpGetTypeAndSubType
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\sendresponse.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    sendresponse.h

Abstract:

    This module contains declarations for manipulating HTTP responses.

Author:

    Keith Moore (keithmo)       07-Aug-1998

Revision History:

    Paul McDaniel (paulmcd)     15-Mar-1999     Modified SendResponse

--*/


#ifndef _SENDRESPONSE_H_
#define _SENDRESPONSE_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Forwarders.
//

typedef struct _UL_INTERNAL_DATA_CHUNK *PUL_INTERNAL_DATA_CHUNK;
typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_INTERNAL_RESPONSE *PUL_INTERNAL_RESPONSE;
typedef struct _UL_HTTP_CONNECTION *PUL_HTTP_CONNECTION;
typedef struct _UL_LOG_DATA_BUFFER *PUL_LOG_DATA_BUFFER;
typedef struct _UL_URI_CACHE_ENTRY *PUL_URI_CACHE_ENTRY;


NTSTATUS
UlSendHttpResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN ULONG Flags,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlSendCachedResponse(
    PUL_HTTP_CONNECTION pHttpConn,
    PBOOLEAN pServedFromCache,
    PBOOLEAN pConnectionRefused
    );

NTSTATUS
UlCacheAndSendResponse(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG Flags,
    IN HTTP_CACHE_POLICY Policy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    OUT PBOOLEAN pServedFromCache
    );


typedef enum _UL_CAPTURE_FLAGS
{
    UlCaptureNothing = 0x00,
    UlCaptureCopyData = 0x01,
    UlCaptureKernelMode = 0x02,
    UlCaptureCopyDataInKernelMode = UlCaptureCopyData | UlCaptureKernelMode,

} UL_CAPTURE_FLAGS;


typedef struct _UL_INTERNAL_DATA_CHUNK
{
    //
    // Chunk type.
    //

    HTTP_DATA_CHUNK_TYPE ChunkType;

    //
    // The data chunk structures, one per supported data chunk type.
    //

    union
    {
        //
        // From memory data chunk.
        //

        struct
        {
            PMDL pMdl;
            PVOID pCopiedBuffer;

            PVOID pUserBuffer;
            ULONG BufferLength;

        } FromMemory;

        //
        // From filename data chunk.
        //

        struct
        {
            HTTP_BYTE_RANGE ByteRange;
            union
            {
                UNICODE_STRING FileName;
                HANDLE FileHandle;
            };
            PUL_FILE_CACHE_ENTRY pFileCacheEntry;

        } FromFile;

    };

} UL_INTERNAL_DATA_CHUNK, *PUL_INTERNAL_DATA_CHUNK;


#define IS_FROM_MEMORY( pchunk )                                            \
    ( (pchunk)->ChunkType == HttpDataChunkFromMemory )

#define IS_FROM_FILE( pchunk )                                              \
    ( (pchunk)->ChunkType == HttpDataChunkFromFileName  ||                  \
      (pchunk)->ChunkType == HttpDataChunkFromFileHandle )

#define IS_FROM_FILE_NAME( pchunk )                                         \
    ( (pchunk)->ChunkType == HttpDataChunkFromFileName )

#define IS_FROM_FILE_HANDLE( pchunk )                                       \
    ( (pchunk)->ChunkType == HttpDataChunkFromFileHandle )

#define UL_IS_VALID_INTERNAL_RESPONSE(x)                                    \
    ( (x) != NULL && (x)->Signature == UL_INTERNAL_RESPONSE_POOL_TAG )


//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_INTERNAL_RESPONSE
{
    //
    // NonPagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY LookasideEntry;

    //
    // UL_INTERNAL_RESPONSE_POOL_TAG
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // SendBufferedBytes for this response.
    //

    LONG SendBufferedBytes;

    //
    // Is it ok to complete the IRP as soon as we capture
    // the response?
    //

    BOOLEAN CompleteIrpEarly;

    //
    // Was a Content-Length specified?
    //

    BOOLEAN ContentLengthSpecified;

    //
    // Was Transfer-Encoding "Chunked" specified?
    //

    BOOLEAN ChunkedSpecified;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN IsFromLookaside;

    //
    // Status code & verb.
    //

    USHORT StatusCode;
    HTTP_VERB Verb;

    //
    // The headers.
    //

    ULONG HeaderLength;
    PUCHAR pHeaders;

    //
    // System time of Date header
    //

    LARGE_INTEGER CreationTime;

    //
    // ETag from HTTP_RESPONSE
    //

    ULONG  ETagLength;
    PUCHAR pETag;

    //
    // Content-Type from HTTP_RESPONSE
    //

    UL_CONTENT_TYPE   ContentType;

    //
    // Optional pointer to the space containing all embedded
    // file names and copied data. This may be NULL for in-memory-only
    // responses that are strictly locked down.
    //

    ULONG AuxBufferLength;
    PVOID pAuxiliaryBuffer;

    //
    // The maximum IRP stack size of all file systems associated
    // with this response.
    //

    union
    {
        CCHAR MaxFileSystemStackSize;
        PVOID Alignment1;
    };

    //
    // Logging data passed down by the user
    //

    PUL_LOG_DATA_BUFFER pLogData;

    //
    // Length of the entire response
    //

    ULONGLONG ResponseLength;

    //
    // The total number of chunks in pDataChunks[].
    //

    ULONG ChunkCount;

    //
    // The data chunks describing the data for this response.
    //

    UL_INTERNAL_DATA_CHUNK pDataChunks[0];

} UL_INTERNAL_RESPONSE, *PUL_INTERNAL_RESPONSE;


//
// These parameters control the batching of MDLs queued for submission
// to the network stack.
//

#define MAX_MDL_RUNS        8
#define MAX_BYTES_BUFFERED  (64 * 1024)
#define MAX_BYTES_PER_READ  (64 * 1024)


//
// Types of trackers
//

typedef enum _UL_TRACKER_TYPE
{
    UlTrackerTypeSend,
    UlTrackerTypeBuildUriEntry,

    UlTrackerTypeMaximum

} UL_TRACKER_TYPE, *PUL_TRACKER_TYPE;


//
// A MDL_RUN is a set of MDLs that came from the same source (either
// a series of memory buffers, or data from a single file read) that
// can be released all at once with the same mechanism.
//
typedef struct _MDL_RUN
{
    PMDL pMdlTail;
    UL_FILE_BUFFER FileBuffer;
    
} MDL_RUN, *PMDL_RUN;


//
// The UL_CHUNK_TRACKER is for iterating through the chunks in
// a UL_INTERNAL_RESPONSE. It is used for sending responses
// and generating cache entries.
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_CHUNK_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY LookasideEntry;

    //
    // A signature.
    //

    ULONG Signature;

    //
    // Refcount on the tracker. We only use this refcount for the non-cache
    // case to sync various aynsc paths happening because of two outstanding
    // IRPs; Read and Send IRPs.
    //

    LONG  RefCount;

    //
    // Flag to understand whether we have completed the send request on
    // this tracker or not. To synch the multiple completion paths.
    //

    LONG Terminated;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN IsFromLookaside;

    //
    // type of tracker
    //

    UL_TRACKER_TYPE Type;

    //
    // this connection keeps our reference count on the UL_CONNECTION
    //

    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // the UL_CONNECTION
    //

    PUL_CONNECTION pConnection;

    //
    // Flags.
    //

    ULONG Flags;

    //
    // The original request.
    //

    PUL_INTERNAL_REQUEST pRequest;

    //
    // The actual response.
    //

    PUL_INTERNAL_RESPONSE pResponse;

    //
    // The current & last chunks in the response.
    //

    PUL_INTERNAL_DATA_CHUNK pCurrentChunk;
    PUL_INTERNAL_DATA_CHUNK pLastChunk;

    //
    // Completion routine & context.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // The variable header buffer
    //

    ULONG VariableHeaderLength;
    PUCHAR pVariableHeader;

    //
    // The precreated file read IRP.
    //

    PIRP pReadIrp;

    //
    // The precreated send IRP.
    //

    PIRP pSendIrp;

    //
    // The precreated IRP context for send.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // WARNING: RtlZeroMemory is only called for feilds below this line.
    // All fields above should be explicitly initialized.
    //

    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM WorkItem;

    //
    // Total number of bytes transferred for the entire
    // response. These are necessary to properly complete the IRP.
    //

    ULONGLONG BytesTransferred;

    //
    // Current file read offset and bytes remaining.
    //

    LARGE_INTEGER FileOffset;
    LARGE_INTEGER FileBytesRemaining;

    union {
        struct _SEND_TRACK_INFO {
            //
            // The head of the MDL chain buffered for this send.
            //

            PMDL pMdlHead;

            //
            // Pointer to the Next field of the last MDL on the chain.
            // This makes it very easy to append to the chain.
            //

            PMDL *pMdlLink;

            //
            // The number of bytes currently buffered in the MDL chain.
            //

            ULONG BytesBuffered;

            //
            // The number of active MDL runs.
            //

            ULONG MdlRunCount;

            //
            // The MDL runs.
            //

            MDL_RUN MdlRuns[MAX_MDL_RUNS];
        } SendInfo;

        struct _BUILD_TRACK_INFO {
            //
            // The cache entry
            //
            PUL_URI_CACHE_ENTRY pUriEntry;

            //
            // File buffer information for reading.
            //
            UL_FILE_BUFFER FileBuffer;

            //
            // Offset inside pUriEntry->pResponseMdl to copy the next buffer.
            //
            ULONG Offset;
        } BuildInfo;
    };

    IO_STATUS_BLOCK IoStatus;

} UL_CHUNK_TRACKER, *PUL_CHUNK_TRACKER;

#define IS_VALID_CHUNK_TRACKER( tracker )                                   \
    ( ((tracker)->Signature == UL_CHUNK_TRACKER_POOL_TAG)                   \
      && ((tracker)->Type < UlTrackerTypeMaximum) )

#define IS_REQUEST_COMPLETE( tracker )                                      \
    ( (tracker)->pCurrentChunk == (tracker)->pLastChunk )

#define IS_DISCONNECT_TIME( tracker )                                       \
    ( (((tracker)->Flags & HTTP_SEND_RESPONSE_FLAG_DISCONNECT) != 0) &&     \
      (((tracker)->Flags & HTTP_SEND_RESPONSE_FLAG_MORE_DATA) == 0) )

#define CONNECTION_FROM_TRACKER( tracker )                                  \
    ( (tracker)->pConnection )


//
// This structure is for tracking an autonomous send with one full response
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_FULL_TRACKER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY LookasideEntry;

    //
    // A signature.
    //

    ULONG Signature;

    //
    // Is this from a lookaside list?  Used to determine how to free.
    //

    BOOLEAN IsFromLookaside;

    //
    // Is this from the internal request?  Won't try to free if set.
    //

    BOOLEAN IsFromRequest;

    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM WorkItem;

    //
    // The cache entry.
    //

    PUL_URI_CACHE_ENTRY pUriEntry;

    //
    // Preallocated buffer for the fixed headers, variable headers and entity
    // body to be copied in the cache-miss case, or for the variable headers
    // only in the cache-hit case.
    //

    ULONG AuxilaryBufferLength;
    PUCHAR pAuxiliaryBuffer;

    //
    // MDL for the variable headers in the cache-hit case or for both the
    // fixed headers and variable headers plus the copied entity body in
    // the cache-miss case.
    //

    union
    {
        PMDL pMdlVariableHeaders;
        PMDL pMdlAuxiliary;
    };

    //
    // MDL for the fixed headers in the cache-hit case or for the user
    // buffer in the cache-miss case.
    //

    union
    {
        PMDL pMdlFixedHeaders;
        PMDL pMdlUserBuffer;
    };

    //
    // MDL for the content in the cache-hit case.
    //

    PMDL pMdlContent;

    //
    // The original request that is saved for logging purpose.
    //

    PUL_INTERNAL_REQUEST pRequest;

    //
    // This connection keeps our reference count on the UL_CONNECTION.
    //

    PUL_HTTP_CONNECTION pHttpConnection;

    //
    // The log data captured if any.
    //

    PUL_LOG_DATA_BUFFER pLogData;

    //
    // Completion routine & context.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Flags.
    //

    ULONG Flags;

    //
    // The precreated send IRP.
    //

    PIRP pSendIrp;

    //
    // The precreated IRP context for send.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // The orignal user send IRP if exists.
    //

    PIRP pUserIrp;

    //
    // SendBufferedBytes for this response.
    //

    LONG SendBufferedBytes;

    //
    // I/O status from the completion routine.
    //

    IO_STATUS_BLOCK IoStatus;

} UL_FULL_TRACKER, *PUL_FULL_TRACKER;

#define IS_VALID_FULL_TRACKER( tracker )                                    \
    ((tracker)->Signature == UL_FULL_TRACKER_POOL_TAG)                      \


//
// An inline function to initialize the full tracker.
//

__inline
VOID
FASTCALL
UlInitializeFullTrackerPool(
    IN PUL_FULL_TRACKER pTracker,
    IN CCHAR SendIrpStackSize
    )
{
    USHORT SendIrpSize;

    //
    // Set up the IRP.
    //

    SendIrpSize = IoSizeOfIrp(SendIrpStackSize);

    pTracker->pSendIrp =
        (PIRP)((PCHAR)pTracker +
            ALIGN_UP(sizeof(UL_FULL_TRACKER), PVOID));

    IoInitializeIrp(
        pTracker->pSendIrp,
        SendIrpSize,
        SendIrpStackSize
        );

    pTracker->pLogData = NULL;
    
    //
    // Set the Mdl's for the FixedHeaders/Variable pair and
    // the UserBuffer/AuxiliaryBuffer pair.
    //

    pTracker->pMdlFixedHeaders =
        (PMDL)((PCHAR)pTracker->pSendIrp + SendIrpSize);

    pTracker->pMdlVariableHeaders =
        (PMDL)((PCHAR)pTracker->pMdlFixedHeaders + g_UlFixedHeadersMdlLength);

    pTracker->pMdlContent =
        (PMDL)((PCHAR)pTracker->pMdlVariableHeaders + g_UlVariableHeadersMdlLength);

    //
    // Set up the auxiliary buffer pointer for the variable header plus
    // the fixed header and the entity body in the cache-miss case.
    //

    pTracker->pAuxiliaryBuffer =
        (PUCHAR)((PCHAR)pTracker->pMdlContent + g_UlContentMdlLength);

    //
    // Initialize the auxiliary MDL.
    //

    MmInitializeMdl(
        pTracker->pMdlAuxiliary,
        pTracker->pAuxiliaryBuffer,
        pTracker->AuxilaryBufferLength
        );

    MmBuildMdlForNonPagedPool( pTracker->pMdlAuxiliary );
}


NTSTATUS
UlpProbeHttpResponse(
    IN PHTTP_RESPONSE pUserResponse,
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN ULONG Flags,
    IN PHTTP_LOG_FIELDS_DATA pLogData
    );

NTSTATUS
UlCaptureHttpResponse(
    IN PHTTP_RESPONSE pUserResponse OPTIONAL,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN HTTP_VERSION Version,
    IN HTTP_VERB Verb,
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN UL_CAPTURE_FLAGS Flags,
    IN BOOLEAN CaptureCache,
    IN PHTTP_LOG_FIELDS_DATA pLogData OPTIONAL,
    OUT PUL_INTERNAL_RESPONSE *ppKernelResponse
    );

NTSTATUS
UlPrepareHttpResponse(
    IN HTTP_VERSION Version,
    IN PHTTP_RESPONSE pUserResponse,
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlCleanupHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlReferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceHttpResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_REFERENCE_INTERNAL_RESPONSE( presp )                             \
    UlReferenceHttpResponse(                                                \
        (presp)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_INTERNAL_RESPONSE( presp )                           \
    UlDereferenceHttpResponse(                                              \
        (presp)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

PMDL
UlpAllocateLockedMdl(
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    );

VOID
UlpFreeLockedMdl(
    PMDL pMdl
    );

NTSTATUS
UlpInitializeAndLockMdl(
    IN PMDL pMdl,
    IN PVOID VirtualAddress,
    IN ULONG Length,
    IN LOCK_OPERATION Operation
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _SENDRESPONSE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\rwlock.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    rwlock.h

Abstract:

    This module contains public declarations for a multiple-reader
    single-writer lock.

Author:

    Chun Ye (chunye)    20-Dec-2000

Revision History:

--*/


#ifndef _RWLOCK_H_
#define _RWLOCK_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// The R/W Lock implements the multiple-reader single-writer locking scheme.
//

typedef struct _UL_RW_LOCK
{
    UL_SPIN_LOCK SpinLock;
    LONG RefCount;

} UL_RW_LOCK, *PUL_RW_LOCK;


//
// R/W Lock functions.
//

__inline
VOID
FASTCALL
UlInitializeRWLock(
    OUT PUL_RW_LOCK pLock
    )
{
    pLock->RefCount = 0;

    UlInitializeSpinLock( &pLock->SpinLock, "RWLock" );

}

__inline
VOID
FASTCALL
UlAcquireRWLockForRead(
    IN OUT PUL_RW_LOCK pLock,
    IN OUT PKIRQL pIrql
    )
{
    UlAcquireSpinLock( &pLock->SpinLock, pIrql );

    InterlockedIncrement( &pLock->RefCount );

    UlReleaseSpinLockFromDpcLevel( &pLock->SpinLock );

}

__inline
VOID
FASTCALL
UlAcquireRWLockForWrite(
    IN OUT PUL_RW_LOCK pLock,
    IN OUT PKIRQL pIrql
    )
{
    UlAcquireSpinLock(&pLock->SpinLock, pIrql);

    while (*((volatile LONG *)&pLock->RefCount) != 0);

}

__inline
VOID
FASTCALL
UlReleaseRWLockFromRead(
    IN OUT PUL_RW_LOCK pLock,
    IN KIRQL Irql
    )
{
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    InterlockedDecrement( &pLock->RefCount );

    KeLowerIrql( Irql );

}

__inline
VOID
FASTCALL
UlReleaseRWLockFromWrite(
    IN OUT PUL_RW_LOCK pLock,
    IN KIRQL Irql
    )
{
    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    UlReleaseSpinLock( &pLock->SpinLock, Irql );

}


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _RWLOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\sendresponsep.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    sendresponsep.h

Abstract:

    The private definition of response sending interfaces.

Author:

    Michael Courage (mcourage)      15-Jun-1999

Revision History:

--*/


#ifndef _SENDRESPONSEP_H_
#define _SENDRESPONSEP_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Private constants.
//

//
// Convenience macro to test if a MDL describes locked memory.
//

#define IS_MDL_LOCKED(pmdl) (((pmdl)->MdlFlags & MDL_PAGES_LOCKED) != 0)

#define HEADER_CHUNK_COUNT  2


//
// Private prototypes.
//

ULONG
UlpComputeFixedHeaderSize(
    IN PHTTP_RESPONSE pUserResponse
    );

VOID
UlpComputeChunkBufferSizes(
    IN ULONG ChunkCount,
    IN PHTTP_DATA_CHUNK pDataChunks,
    IN ULONG Flags,
    OUT PULONG pAuxBufferSize,
    OUT PULONG pCopiedMemorySize,
    OUT PULONG pUncopiedMemorySize,
    OUT PULONGLONG pFromFileSize
    );

VOID
UlpDestroyCapturedResponse(
    IN PUL_INTERNAL_RESPONSE pResponse
    );

VOID
UlpSendHttpResponseWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCloseConnectionComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

PUL_CHUNK_TRACKER
UlpAllocateChunkTracker(
    IN UL_TRACKER_TYPE TrackerType,
    IN CCHAR SendIrpStackSize,
    IN CCHAR ReadIrpStackSize,
    IN PUL_HTTP_CONNECTION pHttpConnection,
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UlpFreeChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    );

VOID
UlpCompleteSendRequest(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    );

VOID
UlpCompleteSendRequestWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCompleteSendIrpEarly(
    PUL_COMPLETION_ROUTINE pCompletionRoutine,
    PVOID pCompletionContext,
    NTSTATUS Status,
    ULONGLONG BytesTransferred
    );

NTSTATUS
UlpRestartMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpRestartMdlSend(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpSendCompleteWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpFreeMdlRuns(
    IN OUT PUL_CHUNK_TRACKER pTracker
    );

VOID
UlpIncrementChunkPointer(
    IN OUT PUL_CHUNK_TRACKER pTracker
    );

__inline
VOID
FASTCALL
UlpInitMdlRuns(
    IN OUT PUL_CHUNK_TRACKER pTracker
    )
{
    pTracker->SendInfo.pMdlHead = NULL;
    pTracker->SendInfo.pMdlLink = &pTracker->SendInfo.pMdlHead;
    pTracker->SendInfo.MdlRunCount = 0;
    pTracker->SendInfo.BytesBuffered = 0;
}


//
// read stuff into the cache
//

NTSTATUS
UlpBuildCacheEntry(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_INTERNAL_RESPONSE pResponse,
    IN PUL_APP_POOL_PROCESS pProcess,
    IN ULONG Flags,
    IN HTTP_CACHE_POLICY CachePolicy,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

VOID
UlpBuildBuildTrackerWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpBuildCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpRestartCacheMdlRead(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpRestartCacheMdlFree(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpCompleteCacheBuild(
    IN PUL_CHUNK_TRACKER pTracker,
    IN NTSTATUS Status
    );

VOID
UlpCompleteCacheBuildWorker(
    IN PUL_WORK_ITEM pWorkItem
    );


//
// send cache entry across the wire
//

NTSTATUS
UlpSendCacheEntry(
    PUL_HTTP_CONNECTION pHttpConnection,
    ULONG Flags,
    PUL_URI_CACHE_ENTRY pUriCacheEntry,
    PUL_COMPLETION_ROUTINE pCompletionRoutine,
    PVOID pCompletionContext,
    PUL_LOG_DATA_BUFFER pLogData
    );

VOID
UlpCompleteSendCacheEntry(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCompleteSendCacheEntry(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

VOID
UlpCompleteSendCacheEntryWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

PUL_FULL_TRACKER
UlpAllocateCacheTracker(
    IN CCHAR SendIrpStackSize
    );

VOID
UlpFreeCacheTracker(
    IN PUL_FULL_TRACKER pTracker
    );

//
// utility
//

ULONG
UlpCheckCacheControlHeaders(
    IN PUL_INTERNAL_REQUEST pRequest,
    IN PUL_URI_CACHE_ENTRY  pUriCacheEntry
    );

BOOLEAN
UlpIsAcceptHeaderOk(
        PUL_INTERNAL_REQUEST pRequest,
        PUL_URI_CACHE_ENTRY  pUriCacheEntry
        );

VOID
UlpGetTypeAndSubType(
    PSTR pStr,
    ULONG  StrLen,
    PUL_CONTENT_TYPE pContentType
    );

VOID
UlReferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceChunkTracker(
    IN PUL_CHUNK_TRACKER pTracker
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_REFERENCE_CHUNK_TRACKER( pTracker )                              \
    UlReferenceChunkTracker(                                                \
        (pTracker)                                                          \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define UL_DEREFERENCE_CHUNK_TRACKER( pTracker )                            \
    UlDereferenceChunkTracker(                                              \
        (pTracker)                                                          \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // _SENDRESPONSEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\seutil.h ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    seutil.h

Abstract:

    This module contains general security utilities.

Author:

    Keith Moore (keithmo)       25-Mar-1999

Revision History:

--*/


#ifndef _SEUTIL_H_
#define _SEUTIL_H_

#ifdef __cplusplus
extern "C" {
#endif


NTSTATUS
UlAssignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    IN PACCESS_STATE pAccessState
    );

VOID
UlDeassignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    );

NTSTATUS
UlAccessCheck(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PWSTR pObjectName
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _SEUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\timeouts.h ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    timeouts.h

Abstract:

    Declaration for timeout monitoring primitives.

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

--*/

#ifndef __TIMEOUTS_H__
#define __TIMEOUTS_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Connection Timeout Monitor Functions
//

VOID
UlInitializeTimeoutMonitor(
    VOID
    );

VOID
UlTerminateTimeoutMonitor(
    VOID
    );

VOID
UlSetTimeoutMonitorInformation(
    IN PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT pInfo
    );

VOID
UlInitializeConnectionTimerInfo(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

VOID
UlTimeoutRemoveTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

VOID
UlSetPerSiteConnectionTimeoutValue(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG TimeoutValue
    );

#define UlLockTimeoutInfo(pInfo, pOldIrql) \
    UlAcquireSpinLock(&(pInfo)->Lock, pOldIrql)

#define UlUnlockTimeoutInfo(pInfo, OldIrql) \
    UlReleaseSpinLock(&(pInfo)->Lock, OldIrql)

VOID
UlSetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    );

VOID
UlResetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    );

VOID
UlSetMinKBSecTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG BytesToSend
    );

VOID
UlResetAllConnectionTimers(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

VOID
UlEvaluateTimerState(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __TIMEOUTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\timeouts.cxx ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    timeouts.cxx

Abstract:

    Implement connection timeout quality-of-service (QoS) functionality.

    The following timers must be monitored during the lifetime of
    a connection:

    * Connection Timeout
    * Header Wait Timeout
    * Entity Body Receive Timeout
    * Response Processing Timeout
    * Minimum Bandwidth (implemented as a Timeout)

    When any one of these timeout values expires, the connection should be
    terminated.

    The timer information is maintained in a timeout info block,
    UL_TIMEOUT_INFO_ENTRY, as part of the UL_HTTP_CONNECTION object.

    A timer can be Set or Reset.  Setting a timer calculates when the specific
    timer should expire, and updates the timeout info block. Resetting a timer
    turns a specific timer off.  Both Setting and Resettnig a timer will cause the
    timeout block to be re-evaluated to find the least valued expiry time.

    // TODO:
    The timeout manager uses a Timer Wheel(c) technology, as used
    by NT's TCP/IP stack for monitoring TCB timeouts.  We will reimplement
    and modify the logic they use.  The linkage for the Timer Wheel(c)
    queues is provided in the timeout info block.

    // TODO: CONVERT TO USING Timer Wheel Ticks instead of SystemTime.
    There are three separate units of time: SystemTime (100ns intervals), Timer
    Wheel Ticks (SystemTime / slot interval length), and Timer Wheel Slot 
    (Timer Wheel Ticks modulo the number of slots in the Timer Wheel).

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

    This was originally implemented as the Connection Timeout Monitor.

--*/

#include "precomp.h"
#include "timeoutsp.h"

//
// Private globals.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeTimeoutMonitor )
#pragma alloc_text( PAGE, UlTerminateTimeoutMonitor )
#pragma alloc_text( PAGE, UlSetTimeoutMonitorInformation )
#pragma alloc_text( PAGE, UlpTimeoutMonitorWorker )
#pragma alloc_text( PAGE, UlSetPerSiteConnectionTimeoutValue )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlpSetTimeoutMonitorTimer
NOT PAGEABLE -- UlpTimeoutMonitorDpcRoutine
NOT PAGEABLE -- UlpTimeoutCheckExpiry
NOT PAGEABLE -- UlpTimeoutInsertTimerWheelEntry
NOT PAGEABLE -- UlTimeoutRemoveTimerWheelEntry
NOT PAGEABLE -- UlInitializeConnectionTimerInfo
NOT PAGEABLE -- UlSetConnectionTimer
NOT PAGEABLE -- UlSetMinKBSecTimer
NOT PAGEABLE -- UlResetConnectionTimer
NOT PAGEABLE -- UlEvaluateTimerState
#endif // 0


//
// Connection Timeout Montior globals
//

LONG            g_TimeoutMonitorInitialized = FALSE;
KDPC            g_TimeoutMonitorDpc;
KTIMER          g_TimeoutMonitorTimer;
KEVENT          g_TimeoutMonitorTerminationEvent;
KEVENT          g_TimeoutMonitorAddListEvent;
UL_WORK_ITEM    g_TimeoutMonitorWorkItem;

//
// Timeout constants
//

ULONG           g_TM_MinKBSecDivisor;   // Bytes/Sec
LONGLONG        g_TM_ConnectionTimeout; // 100ns ticks  (Global...can be overriden)
LONGLONG        g_TM_HeaderWaitTimeout; // 100ns ticks

//
// NOTE: Must be in sync with the _CONNECTION_TIMEOUT_TIMERS enum
//
CHAR *g_aTimeoutTimerNames[] = {
    "ConnectionIdle",   // TimerConnectionIdle
    "HeaderWait",       // TimerHeaderWait
    "MinKBSec",         // TimerMinKBSec
    "EntityBody",       // TimerEntityBody
    "Response",         // TimerResponse
};

//
// Timer Wheel(c)
//

static LIST_ENTRY      g_TimerWheel[TIMER_WHEEL_SLOTS+1]; // TODO: alloc on its own page.
static UL_SPIN_LOCK    g_TimerWheelMutex;
static USHORT          g_TimerWheelCurrentSlot;


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes the Timeout Monitor and kicks off the first polling interval

Arguments:

    (none)


--***************************************************************************/
VOID
UlInitializeTimeoutMonitor(
    VOID
    )
{
    int i;
    LARGE_INTEGER   Now;

    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlInitializeTimeoutMonitor\n"
        ));

    ASSERT( FALSE == g_TimeoutMonitorInitialized );

    //
    // Set default configuration information.
    //
    g_TM_ConnectionTimeout = 15 * 60 * C_NS_TICKS_PER_SEC; // 15 min
    g_TM_HeaderWaitTimeout = 15 * 60 * C_NS_TICKS_PER_SEC; // 15 min
    g_TM_MinKBSecDivisor   = 0; // 0 == Disabled

    //
    // Init Timer Wheel(c) state
    //

    //
    // Set current slot
    //

    KeQuerySystemTime(&Now);
    g_TimerWheelCurrentSlot = UlpSystemTimeToTimerWheelSlot(Now.QuadPart);

    //
    // Init Timer Wheel(c) slots & mutex
    //

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);    // InitializeListHead requirement

    for ( i = 0; i < TIMER_WHEEL_SLOTS ; i++ )
    {
        InitializeListHead( &(g_TimerWheel[i]) );
    }

    InitializeListHead( &(g_TimerWheel[TIMER_OFF_SLOT]) );

    UlInitializeSpinLock( &(g_TimerWheelMutex), "TimeoutMonitor" );

    //
    // Init DPC object & set DPC routine
    //
    KeInitializeDpc(
        &g_TimeoutMonitorDpc,         // DPC object
        &UlpTimeoutMonitorDpcRoutine, // DPC routine
        NULL                          // context
        );

    KeInitializeTimer(
        &g_TimeoutMonitorTimer
        );

    //
    // Event to control rescheduling of the timeout monitor timer
    //
    KeInitializeEvent(
        &g_TimeoutMonitorAddListEvent,
        NotificationEvent,
        TRUE
        );

    //
    // Initialize the termination event.
    //
    KeInitializeEvent(
        &g_TimeoutMonitorTerminationEvent,
        NotificationEvent,
        FALSE
        );

    //
    // Init done!
    //
    InterlockedExchange( &g_TimeoutMonitorInitialized, TRUE );

    //
    // Kick-off the first monitor sleep period
    //
    UlpSetTimeoutMonitorTimer();
}


/***************************************************************************++

Routine Description:

    Terminate the Timeout Monitor, including any pending timer events.

Arguments:

    (none)


--***************************************************************************/
VOID
UlTerminateTimeoutMonitor(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlTerminateTimeoutMonitor\n"
        ));

    //
    // Clear the "initialized" flag. If the timeout monitor runs soon,
    // it will see this flag, set the termination event, and exit
    // quickly.
    //
    if ( TRUE == InterlockedCompareExchange(
        &g_TimeoutMonitorInitialized,
        FALSE,
        TRUE) )
    {
        //
        // Cancel the timeout monitor timer. If it fails, the monitor
        // is running.  Wait for it to complete.
        //
        if ( !KeCancelTimer( &g_TimeoutMonitorTimer ) )
        {
            KeWaitForSingleObject(
                (PVOID)&g_TimeoutMonitorTerminationEvent,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );
        }

    }

    UlTrace(TIMEOUTS, (
        "http!UlTerminateTimeoutMonitor: Done!\n"
        ));

} // UlpTerminateTimeoutMonitor


/***************************************************************************++

Routine Description:

    Sets the global Timeout Monitor configuration information

Arguments:

    pInfo       pointer to HTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT structure


--***************************************************************************/
VOID
UlSetTimeoutMonitorInformation(
    IN PHTTP_CONTROL_CHANNEL_TIMEOUT_LIMIT pInfo
    )
{
    LONGLONG localValue;
    LONGLONG newValue;
    LONGLONG originalValue;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pInfo );

    UlTrace(TIMEOUTS, (
        "http!UlSetTimeoutMonitorInformation:\n"
        "  ConnectionTimeout: %d\n"
        "  HeaderWaitTimeout: %d\n"
        "  MinFileKbSec: %d\n",
        pInfo->ConnectionTimeout,
        pInfo->HeaderWaitTimeout,
        pInfo->MinFileKbSec
        ));

    
    if ( pInfo->ConnectionTimeout )
    {
        UlInterlockedExchange64(
            &g_TM_ConnectionTimeout,
            (LONGLONG)(pInfo->ConnectionTimeout * C_NS_TICKS_PER_SEC)
            );
    }

    if ( pInfo->HeaderWaitTimeout )
    {
        UlInterlockedExchange64(
            &g_TM_HeaderWaitTimeout,
            (LONGLONG)(pInfo->HeaderWaitTimeout * C_NS_TICKS_PER_SEC)
            );
    }

    if ( pInfo->MinFileKbSec )
    {
        InterlockedExchange( (PLONG)&g_TM_MinKBSecDivisor, pInfo->MinFileKbSec );
    }


} // UlSetTimeoutMonitorInformation



/***************************************************************************++

Routine Description:

    Sets up a timer event to fire after the polling interval has expired.

Arguments:

    (none)


--***************************************************************************/
VOID
UlpSetTimeoutMonitorTimer(
    VOID
    )
{
    LARGE_INTEGER TimeoutMonitorInterval;

    ASSERT( TRUE == g_TimeoutMonitorInitialized );

    UlTrace(TIMEOUTS, (
        "http!UlpSetTimeoutMonitorTimer\n"
        ));

    //
    // Don't want to execute this more often than few seconds.
    // In particular, do not want to execute this every 0 seconds, as the
    // machine will become completely unresponsive.
    //

    //
    // negative numbers mean relative time
    //
    TimeoutMonitorInterval.QuadPart = -DEFAULT_POLLING_INTERVAL;

    KeSetTimer(
        &g_TimeoutMonitorTimer,
        TimeoutMonitorInterval,
        &g_TimeoutMonitorDpc
        );

}

/***************************************************************************++

Routine Description:

    Dispatch routine called by the timer event that queues up the Timeout
    Montior

Arguments:

    (all ignored)


--***************************************************************************/
VOID
UlpTimeoutMonitorDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
{

    if( g_TimeoutMonitorInitialized )
    {
        //
        // Do that timeout monitor thang.
        //

        UL_QUEUE_WORK_ITEM(
            &g_TimeoutMonitorWorkItem,
            &UlpTimeoutMonitorWorker
            );

    }

} // UlpTimeoutMonitorDpcRoutine


/***************************************************************************++

Routine Description:

    Timeout Monitor thread

Arguments:

    pWorkItem       (ignored)

--***************************************************************************/
VOID
UlpTimeoutMonitorWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    ULONG   TimeoutMonitorEntriesSeen;
    LARGE_INTEGER   Now;

    //
    // sanity check
    //
    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlpTimeoutMonitorWorker\n"
        ));

    //
    // Check for things to expire now.
    //
    UlpTimeoutCheckExpiry();

    UlTrace(TIMEOUTS, (
        "http!UlpTimeoutMonitorWorker: g_TimerWheelCurrentSlot is now %d\n",
        g_TimerWheelCurrentSlot
        ));

    if ( g_TimeoutMonitorInitialized )
    {
        //
        // Reschedule ourselves
        //
        UlpSetTimeoutMonitorTimer();
    }
    else
    {
        //
        // Signal shutdown event
        //
        KeSetEvent(
            &g_TimeoutMonitorTerminationEvent,
            0,
            FALSE
            );
    }

} // UlpTimeoutMonitor


/***************************************************************************++

Routine Description:

    Walks a given timeout watch list looking for items that should be expired

Returns:

    Count of connections remaining on list (after all expired connections removed)

Notes:

    Possible Issue:  Since we use the system time to check to see if something
    should be expired, it's possible we will mis-expire some connections if the
    system time is set forward.

    Similarly, if the clock is set backward, we may not expire connections as
    expected.

--***************************************************************************/
ULONG
UlpTimeoutCheckExpiry(
    VOID
    )
{
    LARGE_INTEGER           Now;
    KIRQL                   OldIrql;
    PLIST_ENTRY             pEntry;
    PLIST_ENTRY             pHead;
    PUL_HTTP_CONNECTION     pHttpConn;
    PUL_TIMEOUT_INFO_ENTRY  pInfo;
    LIST_ENTRY              ZombieList;
    ULONG                   Entries;
    USHORT                  Limit;
    USHORT                  CurrentSlot;


    PAGED_CODE();

    //
    // Init zombie list
    //
    InitializeListHead(&ZombieList);

    //
    // Get current time
    //
    KeQuerySystemTime(&Now);

    Limit = UlpSystemTimeToTimerWheelSlot( Now.QuadPart );
    ASSERT( TIMER_OFF_SLOT != Limit );

    //
    // Lock Timer Wheel(c)
    //
    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    CurrentSlot = g_TimerWheelCurrentSlot;

    //
    // Walk the slots up until Limit
    //
    Entries = 0;

    while ( CurrentSlot != Limit )
    {
        pHead  = &(g_TimerWheel[CurrentSlot]);
        pEntry = pHead->Flink;

        ASSERT( pEntry );

        //
        // Walk this slot's queue
        //

        while ( pEntry != pHead )
        {
            pInfo = CONTAINING_RECORD(
                pEntry,
                UL_TIMEOUT_INFO_ENTRY,
                QueueEntry
                );

            ASSERT( MmIsAddressValid(pInfo) );

            pHttpConn = CONTAINING_RECORD(
                pInfo,
                UL_HTTP_CONNECTION,
                TimeoutInfo
                );

            ASSERT( (pHttpConn != NULL) && \
                    (pHttpConn->Signature == UL_HTTP_CONNECTION_POOL_TAG) );

            //
            // go to next node (in case we remove the current one from the list)
            //
            pEntry = pEntry->Flink;
            Entries++;

            if (0 == pHttpConn->RefCount)
            {
                //
                // If the ref-count has gone to zero, the httpconn will be
                // cleaned up soon; ignore this item and let the cleanup
                // do its job.
                //
                Entries--;
                continue;   // inner while loop
            }

            //
            // See if we should move this entry to a different slot
            //
            if ( pInfo->SlotEntry != CurrentSlot )
            {
                ASSERT( IS_VALID_TIMER_WHEEL_SLOT(pInfo->SlotEntry) );
                ASSERT( pInfo->QueueEntry.Flink != NULL );

                //
                // Move to correct slot
                //

                RemoveEntryList(
                    &pInfo->QueueEntry
                    );

                InsertTailList(
                    &(g_TimerWheel[pInfo->SlotEntry]),
                    &pInfo->QueueEntry
                    );

                Entries--;

                continue;   // inner while loop
            }

            //
            // See if we should expire this connection
            //
            UlAcquireSpinLockAtDpcLevel( &pInfo->Lock );

            if ( pInfo->CurrentExpiry < Now.QuadPart )
            {
                UlTrace(TIMEOUTS, (
                    "http!UlpTimeoutCheckExpiry: pInfo %p expired because %s timer\n",
                    pInfo,
                    g_aTimeoutTimerNames[pInfo->CurrentTimer]
                    ));

                //
                // Expired.  Remove entry from list & move to Zombie list
                //
                RemoveEntryList(
                    &pInfo->QueueEntry
                    );

                pInfo->QueueEntry.Flink = NULL;

                InsertTailList(
                    &ZombieList,
                    &pInfo->ZombieEntry
                    );

                //
                // Add ref the pHttpConn to prevent it being killed before we
                // can kill it ourselves. (zombifying)
                //

                UL_REFERENCE_HTTP_CONNECTION(pHttpConn);
            }

            UlReleaseSpinLockFromDpcLevel( &pInfo->Lock );


        } // Walk slot queue

        CurrentSlot = ((CurrentSlot + 1) % TIMER_WHEEL_SLOTS);

    } // ( CurrentSlot != Limit )

    g_TimerWheelCurrentSlot = Limit;

    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

    //
    // remove entries on zombie list
    //
    if ( !IsListEmpty(&ZombieList) )
    {
        pEntry = ZombieList.Flink;
        while ( &ZombieList != pEntry )
        {

            pInfo = CONTAINING_RECORD(
                pEntry,
                UL_TIMEOUT_INFO_ENTRY,
                ZombieEntry
                );

            ASSERT( MmIsAddressValid(pInfo) );

            pHttpConn = CONTAINING_RECORD(
                pInfo,
                UL_HTTP_CONNECTION,
                TimeoutInfo
                );

            ASSERT( UL_IS_VALID_HTTP_CONNECTION(pHttpConn) );

            pEntry = pEntry->Flink;

            UlCloseConnection(pHttpConn->pConnection, TRUE, NULL, NULL);

            //
            // Remove the reference we added when zombifying
            //
            UL_DEREFERENCE_HTTP_CONNECTION(pHttpConn);

            Entries--;
        }
    }

    return Entries;

} // UlpTimeoutCheckExpiry


//
// New Timer Wheel(c) primatives
//

/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlInitializeConnectionTimerInfo(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    LARGE_INTEGER           Now;
    int                     i;

    ASSERT( TRUE == g_TimeoutMonitorInitialized );

    //
    // Get current time
    //

    KeQuerySystemTime(&Now);

    //
    // Init Lock
    //

    UlInitializeSpinLock( &pInfo->Lock, "TimeoutInfoLock" );

    //
    // Timer state
    //

    ASSERT( 0 == TimerConnectionIdle );

    pInfo->Timers[TimerConnectionIdle] = TIMER_WHEEL_TICKS(Now.QuadPart + g_TM_ConnectionTimeout);

    for ( i = 1; i < TimerMaximumTimer; i++ )
    {
        pInfo->Timers[i] = TIMER_OFF_TICK;
    }

    pInfo->CurrentTimer  = TimerConnectionIdle;
    pInfo->CurrentExpiry = TIMER_WHEEL_TICKS(Now.QuadPart + g_TM_ConnectionTimeout);
    pInfo->MinKBSecSystemTime = TIMER_OFF_SYSTIME;

    pInfo->ConnectionTimeoutValue = g_TM_ConnectionTimeout;

    //
    // Wheel state
    //

    pInfo->SlotEntry = UlpTimerWheelTicksToTimerWheelSlot( pInfo->CurrentExpiry );
    UlpTimeoutInsertTimerWheelEntry(pInfo);


} // UlInitializeConnectionTimerInfo


/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlpTimeoutInsertTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    KIRQL                   OldIrql;

    ASSERT( NULL != pInfo );
    ASSERT( TRUE == g_TimeoutMonitorInitialized );
    ASSERT( IS_VALID_TIMER_WHEEL_SLOT(pInfo->SlotEntry) );

    UlTrace(TIMEOUTS, (
        "http!UlTimeoutInsertTimerWheelEntry: pInfo %p Slot %d\n",
        pInfo,
        pInfo->SlotEntry
        ));

    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    InsertTailList(
        &(g_TimerWheel[pInfo->SlotEntry]),
        &pInfo->QueueEntry
        );


    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

} // UlTimeoutInsertTimerWheel


/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlTimeoutRemoveTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    KIRQL                   OldIrql;

    ASSERT( NULL != pInfo );
    ASSERT( !IsListEmpty(&pInfo->QueueEntry) );

    UlTrace(TIMEOUTS, (
        "http!UlTimeoutRemoveTimerWheelEntry: pInfo %p\n",
        pInfo
        ));

    UlAcquireSpinLock(
        &g_TimerWheelMutex,
        &OldIrql
        );

    if (pInfo->QueueEntry.Flink != NULL)
    {
        RemoveEntryList(
            &pInfo->QueueEntry
            );

        pInfo->QueueEntry.Flink = NULL;
    }

    UlReleaseSpinLock(
        &g_TimerWheelMutex,
        OldIrql
        );

} // UlTimeoutRemoveTimerWheelEntry


/***************************************************************************++

Routine Description:

    Set the per Site Connection Timeout Value override


Arguments:

    pInfo           Timeout info block

    TimeoutValue    Override value

--***************************************************************************/
VOID
UlSetPerSiteConnectionTimeoutValue(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG TimeoutValue
    )
{
    ASSERT( NULL != pInfo );
    ASSERT( 0L   != TimeoutValue );

    PAGED_CODE();

    UlTrace(TIMEOUTS, (
        "http!UlSetPerSiteConnectionTimeoutValue: pInfo %p TimeoutValue %I64X.\n",
        pInfo,
        TimeoutValue
        ));

    ExInterlockedCompareExchange64(
        &pInfo->ConnectionTimeoutValue, // Destination
        &TimeoutValue,                  // Exchange
        &pInfo->ConnectionTimeoutValue, // Comperand
        &pInfo->Lock.KSpinLock          // Lock
        );

} // UlSetPerSiteConnectionTimeoutValue



/***************************************************************************++

Routine Description:

    Starts a given timer in the timer info block.


Arguments:

    pInfo   Timer info block

    Timer   Timer to set

--***************************************************************************/
VOID
UlSetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    )
{
    LARGE_INTEGER           Now;

    ASSERT( NULL != pInfo );
    ASSERT( IS_VALID_TIMEOUT_TIMER(Timer) );
    ASSERT( UlDbgSpinLockOwned( &pInfo->Lock ) );

    UlTrace(TIMEOUTS, (
        "http!UlSetConnectionTimer: pInfo %p Timer %s\n",
        pInfo,
        g_aTimeoutTimerNames[Timer]
        ));

    //
    // Get current time
    //

    KeQuerySystemTime(&Now);

    //
    // Set timer to apropriate value
    //

    switch ( Timer )
    {
    case TimerConnectionIdle:
    case TimerEntityBody:
    case TimerResponse:
        // all can be handled with the same timeout value
        pInfo->Timers[Timer] = TIMER_WHEEL_TICKS(Now.QuadPart + pInfo->ConnectionTimeoutValue);
        break;

    case TimerHeaderWait:
        pInfo->Timers[TimerHeaderWait] = TIMER_WHEEL_TICKS(Now.QuadPart + g_TM_HeaderWaitTimeout);
        break;

        // NOTE: TimerMinKBSec is handled in UlSetMinKBSecTimer()

    default:
        UlTrace(TIMEOUTS, ( "http!UlSetConnectionTimer: Bad Timer! (%d)\n", Timer ));


        ASSERT( FALSE );

    }


} // UlSetConnectionTimer


/***************************************************************************++

Routine Description:

    Turns on the MinKBSec timer, adds the number of secs given the minimum
    bandwidth specified.

Arguments:

    pInfo         Timer info block

    BytesToSend   Bytes to be sent



--***************************************************************************/
VOID
UlSetMinKBSecTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    LONGLONG BytesToSend
    )
{
    LONGLONG    XmitTicks;
    KIRQL       OldIrql; 
    ULONG       NewTick;
    BOOLEAN     bCallEvaluate = FALSE;


    ASSERT( NULL != pInfo );

    UlTrace(TIMEOUTS, (
        "http!UlSetMinKBSecTimer: pInfo %p BytesToSend %ld\n",
        pInfo,
        BytesToSend
        ));


    if ( g_TM_MinKBSecDivisor )
    {
        if ( 0L != BytesToSend )
        {
            //
            // Calculate the estimated time required to send BytesToSend
            //

            XmitTicks = BytesToSend / g_TM_MinKBSecDivisor;

            if (0 == XmitTicks)
            {
                XmitTicks = C_NS_TICKS_PER_SEC;
            }
            else
            {
                XmitTicks *= C_NS_TICKS_PER_SEC;
            }

            UlAcquireSpinLock(
                &pInfo->Lock,
                &OldIrql
                );

            if ( TIMER_OFF_SYSTIME == pInfo->MinKBSecSystemTime )
            {
                LARGE_INTEGER Now;

                //
                // Get current time
                //
                KeQuerySystemTime(&Now);

                pInfo->MinKBSecSystemTime = (Now.QuadPart + XmitTicks);

            }
            else
            {
                pInfo->MinKBSecSystemTime += XmitTicks;
            }

            NewTick = TIMER_WHEEL_TICKS(pInfo->MinKBSecSystemTime);
            if ( NewTick != pInfo->Timers[TimerMinKBSec] )
            {
                bCallEvaluate = TRUE;
                pInfo->Timers[TimerMinKBSec] = NewTick;
            }

            UlReleaseSpinLock(
                &pInfo->Lock,
                OldIrql
                );

            if ( TRUE == bCallEvaluate )
            {
                UlEvaluateTimerState(pInfo);
            }

        }

    }

} // UlSetMinKBSecTimer


/***************************************************************************++

Routine Description:

    Turns off a given timer in the timer info block.

Arguments:

    pInfo   Timer info block

    Timer   Timer to reset

--***************************************************************************/
VOID
UlResetConnectionTimer(
    PUL_TIMEOUT_INFO_ENTRY pInfo,
    CONNECTION_TIMEOUT_TIMER Timer
    )
{
    ASSERT( NULL != pInfo );
    ASSERT( IS_VALID_TIMEOUT_TIMER(Timer) );
    ASSERT( UlDbgSpinLockOwned( &pInfo->Lock ) );

    UlTrace(TIMEOUTS, (
        "http!UlResetConnectionTimer: pInfo %p Timer %s\n",
        pInfo,
        g_aTimeoutTimerNames[Timer]
        ));

    //
    // Turn off timer
    //

    pInfo->Timers[Timer] = TIMER_OFF_TICK;

    if (TimerMinKBSec == Timer)
    {
        pInfo->MinKBSecSystemTime = TIMER_OFF_SYSTIME;
    }

} // UlResetConnectionTimer


/***************************************************************************++

Routine Description:

    Turns off all timers

Arguments:

    pInfo   Timer info block


--***************************************************************************/
VOID
UlResetAllConnectionTimers(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    int     i;

    ASSERT( NULL != pInfo );
    ASSERT( UlDbgSpinLockOwned( &pInfo->Lock ) );

    for ( i = 0; i < TimerMaximumTimer; i++ )
    {
        pInfo->Timers[i] = TIMER_OFF_TICK;
    }

    pInfo->CurrentTimer  = TimerConnectionIdle;
    pInfo->CurrentExpiry = TIMER_OFF_TICK;
    pInfo->MinKBSecSystemTime = TIMER_OFF_SYSTIME;
}


//
// Private functions
//

/***************************************************************************++

Routine Description:


Arguments:


--***************************************************************************/
VOID
UlEvaluateTimerState(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    )
{
    int         i;
    ULONG       MinTimeout = TIMER_OFF_TICK;
    CONNECTION_TIMEOUT_TIMER  MinTimeoutTimer = TimerConnectionIdle;

    ASSERT( NULL != pInfo );
    ASSERT( !UlDbgSpinLockOwned( &pInfo->Lock ) );

    for ( i = 0; i < TimerMaximumTimer; i++ )
    {
        if (pInfo->Timers[i] < MinTimeout)
        {
            MinTimeout = pInfo->Timers[i];
            MinTimeoutTimer = (CONNECTION_TIMEOUT_TIMER) i;
        }
    }

    //
    // If we've found a different expiry time, update expiry state.
    //
    
    if (pInfo->CurrentExpiry != MinTimeout)
    {
        KIRQL   OldIrql;

#if DBG
        LARGE_INTEGER Now;

        KeQuerySystemTime(&Now);
        ASSERT( MinTimeout >= TIMER_WHEEL_TICKS(Now.QuadPart) );
#endif // DBG
        
        //
        // Calculate new slot
        //

        InterlockedExchange(
            (LONG *) &pInfo->SlotEntry,
            UlpTimerWheelTicksToTimerWheelSlot(MinTimeout)
            );

        //
        // Move to new slot if necessary
        //

        if ( (pInfo->SlotEntry != TIMER_OFF_SLOT) && (MinTimeout < pInfo->CurrentExpiry) )
        {
            //
            // Only move if it's on the Wheel; If Flink is null, it's in
            // the process of being expired.
            //
            
            if ( NULL != pInfo->QueueEntry.Flink )
            {
                UlAcquireSpinLock(
                    &g_TimerWheelMutex,
                    &OldIrql
                    );

                UlTrace(TIMEOUTS, (
                    "http!UlEvaluateTimerInfo: pInfo %p: Moving to new slot %d\n",
                    pInfo,
                    pInfo->SlotEntry
                    ));
            
                RemoveEntryList(
                    &pInfo->QueueEntry
                    );

                InsertTailList(
                    &(g_TimerWheel[pInfo->SlotEntry]),
                    &pInfo->QueueEntry
                    );

                UlReleaseSpinLock(
                    &g_TimerWheelMutex,
                    OldIrql
                    );

            }

        }
 
        //
        // Update timer wheel state
        //

        pInfo->CurrentExpiry = MinTimeout;
        pInfo->CurrentTimer  = MinTimeoutTimer;

    }

} // UlpEvaluateTimerState
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\thrdpool.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    thrdpool.h

Abstract:

    This module contains public declarations for the thread pool package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _THRDPOOL_H_
#define _THRDPOOL_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Thread tracker object. One of these objects is created for each
// thread in the pool. These are useful for (among other things)
// debugging.
//

typedef struct _UL_THREAD_TRACKER
{
    //
    // Links onto the per-thread-pool list.
    //

    LIST_ENTRY ThreadListEntry;

    //
    // The thread.
    //

    PETHREAD pThread;


} UL_THREAD_TRACKER, *PUL_THREAD_TRACKER;


//
// The thread pool object.
//

typedef struct _UL_THREAD_POOL
{
    //
    // List of worker items on this thread pool.
    //

    SLIST_HEADER WorkQueueSList;

    //
    // An event used to wakeup the thread from blocking state.
    //

    KEVENT WorkQueueEvent;

    //
    // List of threads.
    //

    LIST_ENTRY ThreadListHead;

    //
    // Pointer to the special thread designated as the IRP thread. The
    // IRP thread is the first pool thread created and the last one to
    // die. It is also the target for all asynchronous IRPs.
    //

    PETHREAD pIrpThread;

    //
    // A very infrequently used spinlock.
    //

    UL_SPIN_LOCK ThreadSpinLock;

    //
    // The thread handle returned from PsCreateSystemThread.
    //

    HANDLE ThreadHandle;

    //
    // The number of threads we created for this pool.
    //

    UCHAR ThreadCount;

    //
    // Flag used to indicate that this pool has been successfully
    // initialized.
    //

    BOOLEAN Initialized;

    //
    // Target CPU for this pool. The worker threads use this to set
    // their hard affinity.
    //

    UCHAR ThreadCpu;

} UL_THREAD_POOL, *PUL_THREAD_POOL;


//
// Necessary to ensure our array of UL_THREAD_POOL structures is
// cache aligned.
//

typedef union _UL_ALIGNED_THREAD_POOL
{
    UL_THREAD_POOL ThreadPool;

    UCHAR CacheAlignment[(sizeof(UL_THREAD_POOL) + UL_CACHE_LINE - 1) & ~(UL_CACHE_LINE - 1)];

} UL_ALIGNED_THREAD_POOL;


//
// Pointer to a thread pool worker function.
//

typedef union _UL_WORK_ITEM *PUL_WORK_ITEM;

typedef
VOID
(*PUL_WORK_ROUTINE)(
    IN PUL_WORK_ITEM pWorkItem
    );


//
// A work item. A work item may only appear on the work queue once.
//

typedef union _UL_WORK_ITEM
{
    DECLSPEC_ALIGN(MEMORY_ALLOCATION_ALIGNMENT) ULONGLONG Alignment;

    struct
    {
        SINGLE_LIST_ENTRY QueueListEntry;
        PUL_WORK_ROUTINE  pWorkRoutine;
    };

} UL_WORK_ITEM, *PUL_WORK_ITEM;


//
//
// Macro to queue a preinitialized UL_WORK_ITEM.
//

__inline
VOID
FASTCALL
QUEUE_UL_WORK_ITEM(
    PUL_THREAD_POOL pThreadPool,
    IN PUL_WORK_ITEM pWorkItem
    )
{
    if (NULL == InterlockedPushEntrySList(
                    &pThreadPool->WorkQueueSList,
                    &pWorkItem->QueueListEntry
                    ))
    {
        KeSetEvent(
            &pThreadPool->WorkQueueEvent,
            0,
            FALSE
            );
    }

}


// Public functions.
//

NTSTATUS
UlInitializeThreadPool(
    IN USHORT ThreadsPerCpu
    );

VOID
UlTerminateThreadPool(
    VOID
    );

VOID
UlQueueWorkItem(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_QUEUE_WORK_ITEM( pWorkItem, pWorkRoutine )                   \
    UlQueueWorkItem(                                                    \
        pWorkItem,                                                      \
        pWorkRoutine                                                    \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                   \
        )

#ifdef _WIN64
#define UL_WORK_ITEM_FROM_IRP( _irp )                                  \
        (PUL_WORK_ITEM)&((_irp)->Tail.Overlay.DriverContext[1])

#define UL_WORK_ITEM_TO_IRP( _workItem )                               \
        CONTAINING_RECORD( (_workItem), IRP, Tail.Overlay.DriverContext[1])
#else
#define UL_WORK_ITEM_FROM_IRP( _irp )                                  \
        (PUL_WORK_ITEM)&((_irp)->Tail.Overlay.DriverContext[0])

#define UL_WORK_ITEM_TO_IRP( _workItem )                               \
        CONTAINING_RECORD( (_workItem), IRP, Tail.Overlay.DriverContext[0])
#endif

VOID
UlQueueBlockingItem(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_QUEUE_BLOCKING_ITEM( pWorkItem, pWorkRoutine )               \
    UlQueueBlockingItem(                                                \
        pWorkItem,                                                      \
        pWorkRoutine                                                    \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                   \
        )

VOID
UlCallPassive(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define UL_CALL_PASSIVE( pWorkItem, pWorkRoutine )                      \
    UlCallPassive(                                                      \
        pWorkItem,                                                      \
        pWorkRoutine                                                    \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                   \
        )

PETHREAD
UlQueryIrpThread(
    VOID
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _THRDPOOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\thrdpool.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    thrdpool.cxx

Abstract:

    This module implements the thread pool package.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include <precomp.h>

#ifdef __cplusplus

extern "C" {
#endif // __cplusplus

//
// Private prototypes.
//

NTSTATUS
UlpCreatePoolThread(
    IN PUL_THREAD_POOL pThreadPool
    );

VOID
UlpThreadPoolWorker(
    IN PVOID Context
    );

VOID
UlpInitThreadTracker(
    IN PUL_THREAD_POOL pThreadPool,
    IN PETHREAD pThread,
    IN PUL_THREAD_TRACKER pThreadTracker
    );

VOID
UlpDestroyThreadTracker(
    IN PUL_THREAD_TRACKER pThreadTracker
    );

PUL_THREAD_TRACKER
UlpPopThreadTracker(
    IN PUL_THREAD_POOL pThreadPool
    );

VOID
UlpKillThreadWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

#ifdef __cplusplus

}; // extern "C"
#endif // __cplusplus

//
// Private globals.
//

DECLSPEC_ALIGN(UL_CACHE_LINE)
UL_ALIGNED_THREAD_POOL g_UlThreadPool[MAXIMUM_PROCESSORS + 1];

#define CURRENT_THREAD_POOL()   \
    &g_UlThreadPool[KeGetCurrentProcessorNumber()].ThreadPool

#define WAIT_THREAD_POOL()      \
    &g_UlThreadPool[g_UlNumberOfProcessors].ThreadPool

PUL_WORK_ITEM g_pKillerWorkItems = NULL;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlInitializeThreadPool )
#pragma alloc_text( PAGE, UlTerminateThreadPool )
#pragma alloc_text( PAGE, UlpCreatePoolThread )
#pragma alloc_text( PAGE, UlpThreadPoolWorker )

#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpInitThreadTracker
NOT PAGEABLE -- UlpDestroyThreadTracker
NOT PAGEABLE -- UlpPopThreadTracker
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initialize the thread pool.

Arguments:

    ThreadsPerCpu - Supplies the number of threads to create per CPU.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeThreadPool(
    IN USHORT ThreadsPerCpu
    )
{
    NTSTATUS Status;
    PUL_THREAD_POOL pThreadPool;
    CLONG i;
    USHORT j;

    //
    // Sanity check.
    //

    PAGED_CODE();

    RtlZeroMemory( g_UlThreadPool, sizeof(g_UlThreadPool) );

    //
    // Preallocate the small array of special work items used by
    // UlTerminateThreadPool, so that we can safely shut down even
    // in low-memory conditions
    //

    g_pKillerWorkItems = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            UL_WORK_ITEM,
                            (g_UlNumberOfProcessors + 1) * ThreadsPerCpu,
                            UL_WORK_ITEM_POOL_TAG
                            );

    if (g_pKillerWorkItems == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (i = 0; i <= g_UlNumberOfProcessors; i++)
    {
        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        //
        // Initialize the kernel structures.
        //

        InitializeSListHead( &pThreadPool->WorkQueueSList );

        KeInitializeEvent(
            &pThreadPool->WorkQueueEvent,
            SynchronizationEvent,
            FALSE
            );

        UlInitializeSpinLock( &pThreadPool->ThreadSpinLock, "ThreadSpinLock" );

        //
        // Initialize the other fields.
        //

        pThreadPool->pIrpThread = NULL;
        pThreadPool->ThreadCount = 0;
        pThreadPool->ThreadCpu = (UCHAR)i;

        InitializeListHead( &pThreadPool->ThreadListHead );
    }

    for (i = 0; i <= g_UlNumberOfProcessors; i++)
    {
        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        //
        // Create the threads.
        //

        for (j = 0; j < ThreadsPerCpu; j++)
        {
            Status = UlpCreatePoolThread( pThreadPool );

            if (NT_SUCCESS(Status))
            {
                pThreadPool->Initialized = TRUE;
                pThreadPool->ThreadCount++;
            }
            else
            {
                break;
            }
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;

}   // UlInitializeThreadPool


/***************************************************************************++

Routine Description:

    Terminates the thread pool, waiting for all worker threads to exit.

--***************************************************************************/
VOID
UlTerminateThreadPool(
    VOID
    )
{
    PUL_THREAD_POOL pThreadPool;
    PUL_THREAD_TRACKER pThreadTracker;
    CLONG i, j;
    PUL_WORK_ITEM pKiller = g_pKillerWorkItems;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // If there is no killer, the thread pool has never been initialized.
    //

    if (pKiller == NULL)
    {
        return;
    }

    for (i = 0; i <= g_UlNumberOfProcessors; i++)
    {
        pThreadPool = &g_UlThreadPool[i].ThreadPool;

        if (pThreadPool->Initialized)
        {
            //
            // Queue a killer work item for each thread. Each
            // killer tells one thread to kill itself.
            //

            for (j = 0; j < pThreadPool->ThreadCount; j++)
            {
                //
                // Need a separate work item for each thread.
                // Worker threads will free the below memory
                // before termination. UlpKillThreadWorker is
                // a sign to a worker thread for self termination.
                //

                pKiller->pWorkRoutine = &UlpKillThreadWorker;

                QUEUE_UL_WORK_ITEM( pThreadPool, pKiller );

                pKiller++;
            }

            //
            // Wait for all threads to go away.
            //

            while (pThreadTracker = UlpPopThreadTracker(pThreadPool))
            {
                UlpDestroyThreadTracker(pThreadTracker);
            }

            //
            // Release the thread handle.
            //

            ZwClose( pThreadPool->ThreadHandle );
        }

        ASSERT( IsListEmpty( &pThreadPool->ThreadListHead ) );
    }

    UL_FREE_POOL(g_pKillerWorkItems, UL_WORK_ITEM_POOL_TAG);
    g_pKillerWorkItems = NULL;

}   // UlTerminateThreadPool


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Creates a new pool thread, setting pIrpThread if necessary.

Arguments:

    pThreadPool - Supplies the pool that is to receive the new thread.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCreatePoolThread(
    IN PUL_THREAD_POOL pThreadPool
    )
{
    NTSTATUS Status;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PUL_THREAD_TRACKER pThreadTracker;
    PETHREAD pThread;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Ensure we can allocate a thread tracker.
    //

    pThreadTracker = (PUL_THREAD_TRACKER) UL_ALLOCATE_POOL(
                            NonPagedPool,
                            sizeof(*pThreadTracker),
                            UL_THREAD_TRACKER_POOL_TAG
                            );

    if (pThreadTracker != NULL)
    {
        //
        // Create the thread.
        //

        InitializeObjectAttributes(
            &ObjectAttributes,                      // ObjectAttributes
            NULL,                                   // ObjectName
            UL_KERNEL_HANDLE,                       // Attributes
            NULL,                                   // RootDirectory
            NULL                                    // SecurityDescriptor
            );

        UlAttachToSystemProcess();

        Status = PsCreateSystemThread(
                     &pThreadPool->ThreadHandle,    // ThreadHandle
                     THREAD_ALL_ACCESS,             // DesiredAccess
                     &ObjectAttributes,             // ObjectAttributes
                     NULL,                          // ProcessHandle
                     NULL,                          // ClientId
                     UlpThreadPoolWorker,           // StartRoutine
                     pThreadPool                    // StartContext
                     );

        if (NT_SUCCESS(Status))
        {
            //
            // Get a pointer to the thread.
            //

            Status = ObReferenceObjectByHandle(
                        pThreadPool->ThreadHandle,  // ThreadHandle
                        0,                          // DesiredAccess
                        *PsThreadType,              // ObjectType
                        KernelMode,                 // AccessMode
                        (PVOID*) &pThread,          // Object
                        NULL                        // HandleInformation
                        );

            if (NT_SUCCESS(Status))
            {
                //
                // Set up the thread tracker.
                //

                UlpInitThreadTracker(pThreadPool, pThread, pThreadTracker);

                //
                // If this is the first thread created for this pool,
                // make it into the special IRP thread.
                //

                if (pThreadPool->pIrpThread == NULL)
                {
                    pThreadPool->pIrpThread = pThread;
                }
            }
            else
            {
                //
                // That call really should not fail.
                //

                ASSERT(NT_SUCCESS(Status));

                UL_FREE_POOL(
                    pThreadTracker,
                    UL_THREAD_TRACKER_POOL_TAG
                    );

                //
                // Preserve return val from ObReferenceObjectByHandle.
                //

                ZwClose( pThreadPool->ThreadHandle );
            }
        }
        else
        {
            //
            // Couldn't create the thread, kill the tracker.
            //

            UL_FREE_POOL(
                pThreadTracker,
                UL_THREAD_TRACKER_POOL_TAG
                );
        }

        UlDetachFromSystemProcess();
    }
    else
    {
        //
        // Couldn't create a thread tracker.
        //

        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return Status;

}   // UlpCreatePoolThread


/***************************************************************************++

Routine Description:

    This is the main worker for pool threads.

Arguments:

    pContext - Supplies a context value for the thread. This is actually
        a PUL_THREAD_POOL pointer.

--***************************************************************************/
VOID
UlpThreadPoolWorker(
    IN PVOID pContext
    )
{
    PSINGLE_LIST_ENTRY  pListEntry;
    PSINGLE_LIST_ENTRY  pNext;
    SINGLE_LIST_ENTRY   ListHead;
    PUL_WORK_ROUTINE    pWorkRoutine;
    PUL_THREAD_POOL     pThreadPool;
    PUL_THREAD_POOL     pThreadPoolNext;
    PUL_WORK_ITEM       pWorkItem;
    KAFFINITY           AffinityMask;
    NTSTATUS            Status;
    ULONG               Cpu;
    ULONG               NextCpu;
    ULONG               ThreadCpu;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize the ListHead to reverse order of items from FlushSList.
    //

    ListHead.Next = NULL;

    //
    // Snag the context.
    //

    pThreadPool = (PUL_THREAD_POOL) pContext;

    //
    // Set this thread's hard affinity if enabled plus ideal processor.
    //

    if ( pThreadPool->ThreadCpu != g_UlNumberOfProcessors )
    {
        if ( g_UlEnableThreadAffinity )
        {
            AffinityMask = 1 << pThreadPool->ThreadCpu;
        }
        else
        {
            AffinityMask = (KAFFINITY) g_UlThreadAffinityMask;
        }

        Status = ZwSetInformationThread(
                    pThreadPool->ThreadHandle,
                    ThreadAffinityMask,
                    &AffinityMask,
                    sizeof(AffinityMask)
                    );

        ASSERT( NT_SUCCESS( Status ) );

        //
        // Always set thread's ideal processor.
        //

        ThreadCpu = pThreadPool->ThreadCpu;

        Status = ZwSetInformationThread(
                    pThreadPool->ThreadHandle,
                    ThreadIdealProcessor,
                    &ThreadCpu,
                    sizeof(ThreadCpu)
                    );

        ASSERT( NT_SUCCESS( Status ) );
    }

    //
    // Disable hard error popups.
    //

    IoSetThreadHardErrorMode( FALSE );

    //
    // Loop forever, or at least until we're told to stop.
    //

    while ( TRUE )
    {
        //
        // Dqueue the next work item. If we get the special killer work
        // item, then break out of this loop & handle it.
        //

        pListEntry = InterlockedFlushSList( &pThreadPool->WorkQueueSList );

        if ( NULL == pListEntry )
        {
            //
            // Try to get a work from other queues.
            //

            NextCpu = pThreadPool->ThreadCpu + 1;

            for (Cpu = 0; Cpu < g_UlNumberOfProcessors; Cpu++, NextCpu++)
            {
                if (NextCpu >= g_UlNumberOfProcessors)
                {
                    NextCpu = 0;
                }

                pThreadPoolNext = &g_UlThreadPool[NextCpu].ThreadPool;

                if ( ExQueryDepthSList( &pThreadPoolNext->WorkQueueSList ) >=
                     g_UlMinWorkDequeueDepth )
                {
                    pListEntry = InterlockedPopEntrySList(
                                    &pThreadPoolNext->WorkQueueSList
                                    );

                    if ( NULL != pListEntry )
                    {
                        //
                        // Make sure we didn't pop up a killer. If so,
                        // push it back to where it is poped from.
                        //

                        pWorkItem = CONTAINING_RECORD(
                                        pListEntry,
                                        UL_WORK_ITEM,
                                        QueueListEntry
                                        );

                        if ( pWorkItem->pWorkRoutine != &UlpKillThreadWorker )
                        {
                            pListEntry->Next = NULL;
                        }
                        else
                        {
                            WRITE_REF_TRACE_LOG(
                                g_pWorkItemTraceLog,
                                REF_ACTION_PUSH_BACK_WORK_ITEM,
                                0,
                                pWorkItem,
                                __FILE__,
                                __LINE__
                                );

                            QUEUE_UL_WORK_ITEM( pThreadPoolNext, pWorkItem );

                            pListEntry = NULL;
                        }

                        break;
                    }
                }
            }
        }

        if ( NULL == pListEntry )
        {
            KeWaitForSingleObject(
                    &pThreadPool->WorkQueueEvent,
                    Executive,
                    KernelMode,
                    FALSE,
                    0
                    );

            continue;
        }

        ASSERT( NULL != pListEntry );

        //
        // Rebuild the list with reverse order of what we received.
        //

        while ( pListEntry != NULL )
        {
            WRITE_REF_TRACE_LOG(
                g_pWorkItemTraceLog,
                REF_ACTION_FLUSH_WORK_ITEM,
                0,
                pListEntry,
                __FILE__,
                __LINE__
                );

            pNext = pListEntry->Next;
            pListEntry->Next = ListHead.Next;
            ListHead.Next = pListEntry;

            pListEntry = pNext;
        }

        //
        // We can now process the work items in the order that was received.
        //

        while ( NULL != ( pListEntry = ListHead.Next ) )
        {
            ListHead.Next = pListEntry->Next;

            pWorkItem = CONTAINING_RECORD(
                            pListEntry,
                            UL_WORK_ITEM,
                            QueueListEntry
                            );

            WRITE_REF_TRACE_LOG(
                g_pWorkItemTraceLog,
                REF_ACTION_PROCESS_WORK_ITEM,
                0,
                pWorkItem,
                __FILE__,
                __LINE__
                );

            //
            // Call the actual work item routine.
            //

            ASSERT( pWorkItem->pWorkRoutine != NULL );

            if ( pWorkItem->pWorkRoutine == &UlpKillThreadWorker )
            {
                //
                // Received a special signal for self-termination.
                // Push all remaining work items back to the queue
                // before we exit the current thread.
                //

                while ( NULL != ( pListEntry = ListHead.Next ) )
                {
                    ListHead.Next = pListEntry->Next;

                    pWorkItem = CONTAINING_RECORD(
                                    pListEntry,
                                    UL_WORK_ITEM,
                                    QueueListEntry
                                    );

                    ASSERT( pWorkItem->pWorkRoutine == &UlpKillThreadWorker );

                    WRITE_REF_TRACE_LOG(
                        g_pWorkItemTraceLog,
                        REF_ACTION_PUSH_BACK_WORK_ITEM,
                        0,
                        pWorkItem,
                        __FILE__,
                        __LINE__
                        );

                    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );
                }

                goto exit;
            }

            UL_ENTER_DRIVER( "UlpThreadPoolWorker", NULL );

            //
            // Clear the pWorkRoutine member as an indication that this
            // has started processing. Must do it before calling the
            // routine, as the routine may destroy the work item.
            //

            pWorkRoutine = pWorkItem->pWorkRoutine;
            pWorkItem->pWorkRoutine = NULL;

            pWorkRoutine( pWorkItem );

            UL_LEAVE_DRIVER( "UlpThreadPoolWorker" );
        }
    }

exit:

    //
    // Suicide is painless.
    //

    PsTerminateSystemThread( STATUS_SUCCESS );

}   // UlpThreadPoolWorker


/***************************************************************************++

Routine Description:

    Initializes a new thread tracker and inserts it into the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool to own the new tracker.

    pThread - Supplies the thread for the tracker.

    pThreadTracker - Supplise the tracker to be initialized

--***************************************************************************/
VOID
UlpInitThreadTracker(
    IN PUL_THREAD_POOL pThreadPool,
    IN PETHREAD pThread,
    IN PUL_THREAD_TRACKER pThreadTracker
    )
{
    KIRQL oldIrql;

    ASSERT( pThreadPool != NULL );
    ASSERT( pThread != NULL );
    ASSERT( pThreadTracker != NULL );

    pThreadTracker->pThread = pThread;

    UlAcquireSpinLock( &pThreadPool->ThreadSpinLock, &oldIrql );
    InsertTailList(
        &pThreadPool->ThreadListHead,
        &pThreadTracker->ThreadListEntry
        );
    UlReleaseSpinLock( &pThreadPool->ThreadSpinLock, oldIrql );

}   // UlpInitThreadTracker


/***************************************************************************++

Routine Description:

    Removes the specified thread tracker from the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool that owns the tracker.

    pThreadTracker - Supplies the thread tracker to remove.

Return Value:

    None

--***************************************************************************/
VOID
UlpDestroyThreadTracker(
    IN PUL_THREAD_TRACKER pThreadTracker
    )
{
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    ASSERT( pThreadTracker != NULL );

    //
    // Wait for the thread to die.
    //

    KeWaitForSingleObject(
        (PVOID)pThreadTracker->pThread,     // Object
        UserRequest,                        // WaitReason
        KernelMode,                         // WaitMode
        FALSE,                              // Alertable
        NULL                                // Timeout
        );

    //
    // Cleanup.
    //

    ObDereferenceObject( pThreadTracker->pThread );

    //
    // Do it.
    //

    UL_FREE_POOL(
        pThreadTracker,
        UL_THREAD_TRACKER_POOL_TAG
        );

}   // UlpDestroyThreadTracker


/***************************************************************************++

Routine Description:

    Removes a thread tracker from the thread pool.

Arguments:

    pThreadPool - Supplies the thread pool that owns the tracker.

Return Value:

    A pointer to the tracker or NULL (if list is empty)

--***************************************************************************/
PUL_THREAD_TRACKER
UlpPopThreadTracker(
    IN PUL_THREAD_POOL pThreadPool
    )
{
    PLIST_ENTRY pEntry;
    PUL_THREAD_TRACKER pThreadTracker;
    KIRQL oldIrql;

    ASSERT( pThreadPool != NULL );
    ASSERT( pThreadPool->Initialized );

    UlAcquireSpinLock( &pThreadPool->ThreadSpinLock, &oldIrql );

    if (IsListEmpty(&pThreadPool->ThreadListHead))
    {
        pThreadTracker = NULL;
    }
    else
    {
        pEntry = RemoveHeadList(&pThreadPool->ThreadListHead);
        pThreadTracker = CONTAINING_RECORD(
                                pEntry,
                                UL_THREAD_TRACKER,
                                ThreadListEntry
                                );
    }

    UlReleaseSpinLock( &pThreadPool->ThreadSpinLock, oldIrql );
    return pThreadTracker;

}   // UlpPopThreadTracker


/***************************************************************************++

Routine Description:

    A dummy function to indicate that the thread should be terminated.

Arguments:

    pWorkItem - Supplies the dummy work item.

Return Value:

    None

--***************************************************************************/
VOID
UlpKillThreadWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    return;

}   // UlpKillThreadWorker


/***************************************************************************++

Routine Description:

    A function that queues a worker item to a thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueWorkItem(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_THREAD_POOL pThreadPool;
    CLONG Cpu, NextCpu;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_WORK_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the idle processor if possible.
    //

    NextCpu = KeGetCurrentProcessorNumber();

    for (Cpu = 0; Cpu < g_UlNumberOfProcessors; Cpu++, NextCpu++)
    {
        if (NextCpu >= g_UlNumberOfProcessors)
        {
            NextCpu = 0;
        }

        pThreadPool = &g_UlThreadPool[NextCpu].ThreadPool;

        if (ExQueryDepthSList(&pThreadPool->WorkQueueSList) <=
            g_UlMaxWorkQueueDepth)
        {
            QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );
            return;
        }
    }

    //
    // Queue the work item on the current thread pool.
    //

    pThreadPool = CURRENT_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

}   // UlQueueWorkItem


/***************************************************************************++

Routine Description:

    A function that queues a blocking worker item to a special thread pool.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlQueueBlockingItem(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_QUEUE_BLOCKING_ITEM,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    //
    // Save the pointer to the worker routine, then queue the item.
    //

    pWorkItem->pWorkRoutine = pWorkRoutine;

    //
    // Queue the work item on the special wait thread pool.
    //

    pThreadPool = WAIT_THREAD_POOL();
    QUEUE_UL_WORK_ITEM( pThreadPool, pWorkItem );

}   // UlQueueBlockingItem


/***************************************************************************++

Routine Description:

    A function that either queues a worker item to a thread pool if the
    caller is at DISPATCH_LEVEL/APC_LEVEL or it simply calls the work
    routine directly.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
VOID
UlCallPassive(
    IN PUL_WORK_ITEM pWorkItem,
    IN PUL_WORK_ROUTINE pWorkRoutine
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    //
    // Sanity check.
    //

    ASSERT( pWorkItem != NULL );
    ASSERT( pWorkRoutine != NULL );

    WRITE_REF_TRACE_LOG(
        g_pWorkItemTraceLog,
        REF_ACTION_CALL_PASSIVE,
        0,
        pWorkItem,
        pFileName,
        LineNumber
        );

    if (KeGetCurrentIrql() == PASSIVE_LEVEL)
    {
        //
        // Clear this for consistency with UlpThreadPoolWorker.
        //

        pWorkItem->pWorkRoutine = NULL;

        pWorkRoutine(pWorkItem);
    }
    else
    {
        UL_QUEUE_WORK_ITEM(pWorkItem, pWorkRoutine);
    }

}   // UlCallPassive


/***************************************************************************++

Routine Description:

    Queries the "IRP thread", the special worker thread used as the
    target for all asynchronous IRPs.

Arguments:

    pWorkItem - Supplies the work item.

    pWorkRoutine - Supplies the work routine.

Return Value:

    None

--***************************************************************************/
PETHREAD
UlQueryIrpThread(
    VOID
    )
{
    PUL_THREAD_POOL pThreadPool;

    //
    // Sanity check.
    //

    pThreadPool = CURRENT_THREAD_POOL();
    ASSERT( pThreadPool->Initialized );

    //
    // Return the IRP thread.
    //

    return pThreadPool->pIrpThread;

}   // UlQueryIrpThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\seutil.cxx ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    seutil.cxx

Abstract:

    This module implements general security utilities.

Author:

    Keith Moore (keithmo)       25-Mar-1999

Revision History:

--*/


#include "precomp.h"


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlAssignSecurity )
#pragma alloc_text( PAGE, UlDeassignSecurity )
#pragma alloc_text( PAGE, UlAccessCheck )
#endif  // ALLOC_PRAGMA
#if 0
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Assigns a new security descriptor.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the current security
        descriptor pointer. The current security descriptor pointer
        will be updated with the new security descriptor.

    pAccessState - Supplies the ACCESS_STATE structure containing
        the state of an access in progress.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAssignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor,
    IN PACCESS_STATE pAccessState
    )
{
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pAccessState != NULL );

    //
    // Assign the security descriptor.
    //

    SeLockSubjectContext( &pAccessState->SubjectSecurityContext );

    status = SeAssignSecurity(
                    NULL,                   // ParentDescriptor
                    pAccessState->SecurityDescriptor,
                    pSecurityDescriptor,
                    FALSE,                  // IsDirectoryObject
                    &pAccessState->SubjectSecurityContext,
                    IoGetFileObjectGenericMapping(),
                    PagedPool
                    );

    SeUnlockSubjectContext( &pAccessState->SubjectSecurityContext );

    return status;

}   // UlAssignSecurity


/***************************************************************************++

Routine Description:

    Deletes a security descriptor.

Arguments:

    pSecurityDescriptor - Supplies a pointer to the current security
        descriptor pointer. The current security descriptor pointer
        will be deleted.

--***************************************************************************/
VOID
UlDeassignSecurity(
    IN OUT PSECURITY_DESCRIPTOR *pSecurityDescriptor
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );

    //
    // If there's a security descriptor present, free it.
    //

    if (*pSecurityDescriptor != NULL)
    {
        SeDeassignSecurity( pSecurityDescriptor );
    }

}   // UlDeassignSecurity


/***************************************************************************++

Routine Description:

    Determines if a user has access to the specified resource.

Arguments:

    pSecurityDescriptor - Supplies the security descriptor protecting
        the resource.

    pAccessState - Supplies the ACCESS_STATE structure containing
        the state of an access in progress.

    DesiredAccess - Supplies an access mask describing the user's
        desired access to the resource. This mask is assumed to not
        contain generic access types.

    RequestorMode - Supplies the processor mode by which the access is
        being requested.

    pObjectName - Supplies the name of the object being referenced.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAccessCheck(
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor,
    IN PACCESS_STATE pAccessState,
    IN ACCESS_MASK DesiredAccess,
    IN KPROCESSOR_MODE RequestorMode,
    IN PWSTR pObjectName
    )
{
    NTSTATUS status;
    BOOLEAN accessGranted;
    PPRIVILEGE_SET pPrivileges = NULL;
    ACCESS_MASK grantedAccess;
    UNICODE_STRING objectName;
    UNICODE_STRING typeName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( pSecurityDescriptor != NULL );
    ASSERT( pAccessState != NULL );

    //
    // Perform the access check.
    //

    SeLockSubjectContext( &pAccessState->SubjectSecurityContext );

    accessGranted = SeAccessCheck(
                        pSecurityDescriptor,
                        &pAccessState->SubjectSecurityContext,
                        TRUE,               // SubjectContextLocked
                        DesiredAccess,
                        0,                  // PreviouslyGrantedAccess
                        &pPrivileges,
                        IoGetFileObjectGenericMapping(),
                        RequestorMode,
                        &grantedAccess,
                        &status
                        );

    if (pPrivileges != NULL)
    {
        SeAppendPrivileges( pAccessState, pPrivileges );
        SeFreePrivileges( pPrivileges );
    }

    if (accessGranted)
    {
        pAccessState->PreviouslyGrantedAccess |= grantedAccess;
        pAccessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
    }

    RtlInitUnicodeString( &typeName, L"Ul" );
    RtlInitUnicodeString( &objectName, pObjectName );

    SeOpenObjectAuditAlarm(
        &typeName,
        NULL,               // Object
        &objectName,
        pSecurityDescriptor,
        pAccessState,
        FALSE,              // ObjectCreated
        accessGranted,
        RequestorMode,
        &pAccessState->GenerateOnClose
        );

    SeUnlockSubjectContext( &pAccessState->SubjectSecurityContext );

    if (accessGranted)
    {
        status = STATUS_SUCCESS;
    }
    else
    {
        //
        // SeAccessCheck() should have set the completion status.
        //

        ASSERT( !NT_SUCCESS(status) );
    }

    return status;

}   // UlAccessCheck


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\timetrace.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    timetrace.cxx

Abstract:

    This module implements a request timing tracing facility.

Author:

    Michael Courage (mcourage)  8-Mar-2000

Revision History:

--*/


#include "precomp.h"


#if ENABLE_TIME_TRACE

#pragma warning( disable : 4035 )           // Warning : No return value
#pragma warning( disable : 4142 )           // Warning : benign redefinition of type
__inline ULONGLONG RDTSC( VOID )
{
#if defined(_X86_)
    __asm __emit 0x0F __asm __emit 0xA2     // CPUID (memory barrier)
    __asm __emit 0x0F __asm __emit 0x31     // RDTSC
#else
    return 0;
#endif
}
#pragma warning( default : 4035 )
#pragma warning( default : 4142 )


/***************************************************************************++

Routine Description:

    Creates a new (empty) time trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-
        specific data to the log.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    )
{
    return CreateTraceLog(
               TIME_TRACE_LOG_SIGNATURE,
               LogSize,
               ExtraBytesInHeader,
               sizeof(TIME_TRACE_LOG_ENTRY)
               );

}   // CreateTimeTraceLog


/***************************************************************************++

Routine Description:

    Destroys a time trace log buffer created with CreateTimeTraceLog().

Arguments:

    pLog - Supplies the time trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyTimeTraceLog(
    IN PTRACE_LOG pLog
    )
{
    DestroyTraceLog( pLog );

}   // DestroyTimeTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified time trace log.

Arguments:

    pLog - Supplies the log to write to.

    ConnectionId - the id of the connection we're tracing

    RequestId - the id of the request we're tracing

    Action - Supplies an action code for the new log entry.


--***************************************************************************/
VOID
WriteTimeTraceLog(
    IN PTRACE_LOG pLog,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN HTTP_REQUEST_ID RequestId,
    IN USHORT Action
    )
{
    TIME_TRACE_LOG_ENTRY entry;

    //
    // Initialize the entry.
    //
//    entry.TimeStamp = KeQueryInterruptTime();
    entry.TimeStamp = RDTSC();
    entry.ConnectionId = ConnectionId;
    entry.RequestId = RequestId;
    entry.Action = Action;
    entry.Processor = (USHORT)KeGetCurrentProcessorNumber();

    //
    // Write it to the logs.
    //

    WriteTraceLog( pLog, &entry );

}   // WriteTimeTraceLog


#endif  // ENABLE_TIME_TRACE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\timeoutsp.h ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    timeoutsp.h

Abstract:

    Declaration for timeout monitoring private declarations.

Author:

    Eric Stenson (EricSten)     24-Mar-2001

Revision History:

--*/

#ifndef __TIMEOUTSP_H__
#define __TIMEOUTSP_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Private macro definitions
// 

#define DEFAULT_POLLING_INTERVAL (30 * C_NS_TICKS_PER_SEC)
#define TIMER_WHEEL_SLOTS        509
#define TIMER_OFF_SYSTIME        (MAXLONGLONG)
#define TIMER_OFF_TICK           0xffffffff
#define TIMER_OFF_SLOT           TIMER_WHEEL_SLOTS

// NOTE: Slot number TIMER_WHEEL_SLOTS is reserved for TIMER_OFF_SYSTIME/TIMER_OFF_TICK
#define IS_VALID_TIMER_WHEEL_SLOT(x) ( (x) <= TIMER_WHEEL_SLOTS )

#define TIMER_WHEEL_TICKS(x) ((ULONG)( (x) / DEFAULT_POLLING_INTERVAL ))

//
// Connection Timeout Monitor Functions
//

VOID
UlpSetTimeoutMonitorTimer(
    VOID
    );

VOID
UlpTimeoutMonitorDpcRoutine(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
UlpTimeoutMonitorWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

ULONG
UlpTimeoutCheckExpiry(
    VOID
    );

VOID
UlpTimeoutInsertTimerWheelEntry(
    PUL_TIMEOUT_INFO_ENTRY pInfo
    );

/***************************************************************************++

Routine Description:

    Converts a system time/Timer Wheel Tick into a Timer Wheel(c) slot index.

Arguments:

    SystemTime      System Time to be converted

Returns:

    Slot index into g_TimerWheel.  TIMER_OFF is in TIMER_SLOT_OFF.

--***************************************************************************/
__inline
USHORT
UlpSystemTimeToTimerWheelSlot(
    LONGLONG    SystemTime
    )
{
    if ( TIMER_OFF_SYSTIME == SystemTime )
    {
        return TIMER_OFF_SLOT;
    }
    else
    {
        return (USHORT) (TIMER_WHEEL_TICKS(SystemTime) % TIMER_WHEEL_SLOTS);
    }
} // UlpSystemTimeToTimerWheelSlot

__inline
USHORT
UlpTimerWheelTicksToTimerWheelSlot(
    ULONG WheelTicks
    )
{
    if ( TIMER_OFF_TICK == WheelTicks )
    {
        return TIMER_OFF_SLOT;
    }
    else
    {
        return (USHORT) (WheelTicks % TIMER_WHEEL_SLOTS);
    }
} // UlpTimerWheelTicksToTimerWheelSlot

#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __TIMEOUTSP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\tracelog.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    tracelog.h

Abstract:

    This module contains public declarations and definitions for creating
    trace logs.

    A trace log is a fast, in-memory, threadsafe, circular activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

    Note that the creator of the log has the option of adding "extra"
    bytes to the log header. This can be useful if the creator wants to
    create a set of global logs, each on a linked list.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#ifndef _TRACELOG_H_
#define _TRACELOG_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


typedef struct _TRACE_LOG
{
    //
    // Signature: TRACE_LOG_SIGNATURE;
    //

    ULONG Signature;

    //
    // TypeSignature: Ref, FiltQ, Irp, etc
    //

    ULONG TypeSignature;

    //
    // The total number of entries available in the log.
    //

    ULONG LogSize;

    //
    // The index of the next entry to use. For long runs in a busy
    // tracelog, a 32-bit index will overflow in a few days. Consider
    // what would happen if we jumped from OxFFFFFFFF (4,294,967,295) to
    // 0 when LogSize = 10,000: the index would jump from 7295 to 0,
    // leaving a large gap of stale records at the end, and !ulkd.ref
    // would not be able to find the preceding ones with high indices.
    //

    LONGLONG NextEntry;

    //
    // The byte size of each entry.
    //

    ULONG EntrySize;

    //
    // Pointer to the start of the circular buffer.
    //

    PUCHAR pLogBuffer;

    //
    // The extra header bytes and actual log entries go here.
    //
    // BYTE ExtraHeaderBytes[ExtraBytesInHeader];
    // BYTE Entries[LogSize][EntrySize];
    //

} TRACE_LOG, *PTRACE_LOG;


//
// Log header signature.
//

#define TRACE_LOG_SIGNATURE   ((LONG)'gOlT')
#define TRACE_LOG_SIGNATURE_X MAKE_FREE_SIGNATURE(TRACE_LOG_SIGNATURE)


//
// This macro maps a TRACE_LOG pointer to a pointer to the 'extra'
// data associated with the log.
//

#define TRACE_LOG_TO_EXTRA_DATA(log)    (PVOID)( (log) + 1 )


//
// Manipulators.
//

// CODEWORK: think about adding alignment flags so that entries will always
// be pointer-aligned on the hardware

PTRACE_LOG
CreateTraceLog(
    IN ULONG TypeSignature,
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader,
    IN ULONG EntrySize
    );

VOID
DestroyTraceLog(
    IN PTRACE_LOG pLog
    );

LONGLONG
WriteTraceLog(
    IN PTRACE_LOG pLog,
    IN PVOID pEntry
    );

VOID
ResetTraceLog(
    IN PTRACE_LOG pLog
    );


#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TRACELOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\timetrace.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    timetrace.h

Abstract:

    This module contains public declarations and definitions for tracing
    and debugging the timing of request processing.

Author:

    Michael Courage (mcourage)  8-Mar-2000

Revision History:

--*/


#ifndef _TIMETRACE_H_
#define _TIMETRACE_H_


#if defined(__cplusplus)
extern "C" {
#endif  // __cplusplus


//
// This defines the entry written to the trace log.
//

typedef struct _TIME_TRACE_LOG_ENTRY
{
    ULONGLONG               TimeStamp;
    HTTP_CONNECTION_ID      ConnectionId;
    HTTP_REQUEST_ID         RequestId;
    USHORT                  Action;
    USHORT                  Processor;

} TIME_TRACE_LOG_ENTRY, *PTIME_TRACE_LOG_ENTRY;


//
// Action codes.
//
// N.B. These codes must be contiguous, starting at zero. If you update
//      this list, you must also update the corresponding array in
//      ul\ulkd\time.c.
//

#define TIME_ACTION_CREATE_CONNECTION               0
#define TIME_ACTION_CREATE_REQUEST                  1
#define TIME_ACTION_ROUTE_REQUEST                   2
#define TIME_ACTION_COPY_REQUEST                    3
#define TIME_ACTION_SEND_RESPONSE                   4
#define TIME_ACTION_SEND_COMPLETE                   5

#define TIME_ACTION_COUNT                           6

#define TIME_TRACE_LOG_SIGNATURE   ((LONG)'gLmT')

//
// Manipulators.
//

PTRACE_LOG
CreateTimeTraceLog(
    IN LONG LogSize,
    IN LONG ExtraBytesInHeader
    );

VOID
DestroyTimeTraceLog(
    IN PTRACE_LOG pLog
    );

VOID
WriteTimeTraceLog(
    IN PTRACE_LOG pLog,
    IN HTTP_CONNECTION_ID ConnectionId,
    IN HTTP_REQUEST_ID RequestId,
    IN USHORT Action
    );


#if ENABLE_TIME_TRACE

#define CREATE_TIME_TRACE_LOG( ptr, size, extra )                           \
    (ptr) = CreateTimeTraceLog( (size), (extra) )

#define DESTROY_TIME_TRACE_LOG( ptr )                                       \
    do                                                                      \
    {                                                                       \
        DestroyTimeTraceLog( ptr );                                         \
        (ptr) = NULL;                                                       \
    } while (FALSE)

#define WRITE_TIME_TRACE_LOG( plog, cid, rid, act )                         \
    WriteTimeTraceLog(                                                      \
        (plog),                                                             \
        (cid),                                                              \
        (rid),                                                              \
        (act)                                                               \
        )

#else   // !ENABLE_TIME_TRACE

#define CREATE_TIME_TRACE_LOG( ptr, size, extra )
#define DESTROY_TIME_TRACE_LOG( ptr )
#define WRITE_TIME_TRACE_LOG( plog, cid, rid, act )

#endif  // ENABLE_TIME_TRACE

#define TRACE_TIME( cid, rid, act )                                         \
    WRITE_TIME_TRACE_LOG(                                                   \
        g_pTimeTraceLog,                                                    \
        (cid),                                                              \
        (rid),                                                              \
        (act)                                                               \
        )

#if defined(__cplusplus)
}   // extern "C"
#endif  // __cplusplus


#endif  // _TIMETRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\tracelog.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    tracelog.cxx

Abstract:

    This module implements a trace log.

    A trace log is a fast, in-memory, thread safe activity log useful
    for debugging certain classes of problems. They are especially useful
    when debugging reference count bugs.

Author:

    Keith Moore (keithmo)       10-Jun-1998

Revision History:

--*/


#include "precomp.h"


#if REFERENCE_DEBUG


//
// Environmental stuff.
//

#define MY_ALLOC_MEM(cb)                                                    \
    (PVOID)UL_ALLOCATE_POOL(                                               \
        NonPagedPool,                                                       \
        (ULONG)(cb),                                                        \
        UL_DEBUG_POOL_TAG                                                  \
        )

#define MY_FREE_MEM(ptr)                                                    \
    UL_FREE_POOL(                                                          \
        (PVOID)(ptr),                                                       \
        UL_DEBUG_POOL_TAG                                                  \
        )

#define MY_ASSERT(expr) ASSERT(expr)


/***************************************************************************++

Routine Description:

    Creates a new (empty) trace log buffer.

Arguments:

    LogSize - Supplies the number of entries in the log.

    ExtraBytesInHeader - Supplies the number of extra bytes to include
        in the log header. This is useful for adding application-specific
        data to the log.

    EntrySize - Supplies the size (in bytes) of each entry.

Return Value:

    PTRACE_LOG - Pointer to the newly created log if successful,
        NULL otherwise.

--***************************************************************************/
PTRACE_LOG
CreateTraceLog(
    IN ULONG TypeSignature,
    IN ULONG LogSize,
    IN ULONG ExtraBytesInHeader,
    IN ULONG EntrySize
    )
{
    ULONG totalSize;
    PTRACE_LOG pLog;

    //
    // Sanity check the parameters.
    //

    MY_ASSERT( LogSize > 0 );
    MY_ASSERT( EntrySize > 0 );
    MY_ASSERT( ( EntrySize & 3 ) == 0 );

    //
    // Allocate & initialize the log structure.
    //

    totalSize = sizeof(*pLog) + ( LogSize * EntrySize ) + ExtraBytesInHeader;
    MY_ASSERT( totalSize > 0 );

    pLog = (PTRACE_LOG)MY_ALLOC_MEM( totalSize );

    //
    // Initialize it.
    //

    if (pLog != NULL)
    {
        RtlZeroMemory( pLog, totalSize );

        pLog->Signature = TRACE_LOG_SIGNATURE;
        pLog->TypeSignature = TypeSignature;
        pLog->LogSize = LogSize;
        pLog->NextEntry = -1;
        pLog->EntrySize = EntrySize;
        pLog->pLogBuffer = (PUCHAR)( pLog + 1 ) + ExtraBytesInHeader;
    }

    return pLog;

}   // CreateTraceLog


/***************************************************************************++

Routine Description:

    Destroys a trace log buffer created with CreateTraceLog().

Arguments:

    pLog - Supplies the trace log buffer to destroy.

--***************************************************************************/
VOID
DestroyTraceLog(
    IN PTRACE_LOG pLog
    )
{
    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );

        pLog->Signature = TRACE_LOG_SIGNATURE_X;
        MY_FREE_MEM( pLog );
    }

}   // DestroyTraceLog


/***************************************************************************++

Routine Description:

    Writes a new entry to the specified trace log.

Arguments:

    pLog - Supplies the log to write to.

    pEntry - Supplies a pointer to the data to write. This buffer is
        assumed to be pLog->EntrySize bytes long.

Return Value:

    LONGLONG - Index of the newly written entry within the tracelog
        (used by the OwnerRef tracelog).

--***************************************************************************/
LONGLONG
WriteTraceLog(
    IN PTRACE_LOG pLog,
    IN PVOID pEntry
    )
{
    PUCHAR pTarget;
    ULONGLONG index = -1;

    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );
        MY_ASSERT( pEntry != NULL );

        //
        // Find the next slot, copy the entry to the slot.
        //

        index = (ULONGLONG) UlInterlockedIncrement64( &pLog->NextEntry );

        pTarget = ( (index % pLog->LogSize) * pLog->EntrySize )
                        + pLog->pLogBuffer;

        RtlCopyMemory( pTarget, pEntry, pLog->EntrySize );
    }

    return index;
}   // WriteTraceLog


/***************************************************************************++

Routine Description:

    Resets the specified trace log such that the next entry written
    will be placed at the beginning of the log.

Arguments:

    pLog - Supplies the trace log to reset.

--***************************************************************************/
VOID
ResetTraceLog(
    IN PTRACE_LOG pLog
    )
{
    if (pLog != NULL)
    {
        MY_ASSERT( pLog->Signature == TRACE_LOG_SIGNATURE );

        RtlZeroMemory(
            ( pLog + 1 ),
            pLog->LogSize * pLog->EntrySize
            );

        pLog->NextEntry = -1;
    }

}   // ResetTraceLog


#endif  // REFERENCE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\type.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    type.h

Abstract:

    This module contains global type definitions.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#ifndef _TYPE_H_
#define _TYPE_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Routine invoked after asynchronous API completion.
//
// Arguments:
//
//      pCompletionContext - Supplies an uninterpreted context value
//          as passed to the asynchronous API.
//
//      Status - Supplies the final completion status of the
//          asynchronous API.
//
//      Information - Optionally supplies additional information about
//          the completed operation, such as the number of bytes
//          transferred.
//

typedef
VOID
(*PUL_COMPLETION_ROUTINE)(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// The following structure contains all UL data that must be
// nonpaged at all times.
//
// Note: if you modify this struct, please make the corresponding
// changes to ..\ulkd\glob.c
//

typedef struct _UL_NONPAGED_DATA
{
    //
    // Lookaside lists for speedy allocations.
    //

    HANDLE                  IrpContextLookaside;
    HANDLE                  ReceiveBufferLookaside;
    HANDLE                  ResourceLookaside;
    HANDLE                  RequestBufferLookaside;
    HANDLE                  InternalRequestLookaside;
    HANDLE                  ChunkTrackerLookaside;
    HANDLE                  FullTrackerLookaside;
    HANDLE                  ResponseBufferLookaside;
    HANDLE                  LogBufferLookaside;

    //
    // Non-paged resources for cgroup.c
    //

    //
    // we use 2 locks to prevent a very delicate deadlock situation with
    // HTTP_CONNECTION resources and the config group tree.  we need to
    // allow the http engine read only access to the tree during critical
    // times, like deleting sites, which requires deleting the http endpoint,
    // which needs to aquire the HTTP_CONNECTION resource, thus the deadlock.
    // this is most common during shutdown under load.
    //

    UL_ERESOURCE            ConfigGroupResource;    // Locks the tree, readers
                                                    // use this one.  writers
                                                    // also use it when it's
                                                    // unsafe for readers to
                                                    // access the tree
    //
    // Non-paged resources for apool.c
    //

    UL_ERESOURCE            AppPoolResource;        // Locks the global app
                                                    // pool list

    UL_ERESOURCE            DisconnectResource;     // Locks everything related
                                                    // to UlWaitForDisconnect
    //
    // Non-paged resources for cache.c
    //

    UL_ERESOURCE            UriZombieResource;      // Locks URI Zombie list

    //                                                //
    // Non-paged resources for filter.c
    //

    UL_SPIN_LOCK            FilterSpinLock;         // Locks the global
                                                    // filter list.

    //
    // Non-paged resources for ullog.c
    //

    UL_ERESOURCE            LogListResource;        // Locks the log
                                                    // file list
    //
    // Non-paged resources for ultci.c
    //

    UL_ERESOURCE            TciIfcResource;         // Locks the QoS
                                                    // Interface list
    //
    // Non-paged resources for parse.c
    //

    UL_ERESOURCE            DateHeaderResource;     // Date Cache Lock

} UL_NONPAGED_DATA, *PUL_NONPAGED_DATA;


#define CG_LOCK_READ() \
do { \
    UlAcquireResourceShared(&(g_pUlNonpagedData->ConfigGroupResource), TRUE); \
} while (0)

#define CG_UNLOCK_READ() \
do { \
    UlReleaseResource(&(g_pUlNonpagedData->ConfigGroupResource)); \
} while (0)

#define CG_LOCK_WRITE() \
do { \
    UlAcquireResourceExclusive(&(g_pUlNonpagedData->ConfigGroupResource), TRUE); \
} while (0)

#define CG_UNLOCK_WRITE() \
do { \
    UlReleaseResource(&(g_pUlNonpagedData->ConfigGroupResource)); \
} while (0)



//
// Structures for debug-specific statistics.
//

typedef struct _UL_DEBUG_STATISTICS_INFO
{
    //
    // Pool statistics.
    //

    LARGE_INTEGER TotalBytesAllocated;
    LARGE_INTEGER TotalBytesFreed;
    LONG TotalAllocations;
    LONG TotalFrees;

    //
    // Spinlock statistics.
    //

    LONG TotalSpinLocksInitialized;
    LONG TotalAcquisitions;
    LONG TotalReleases;
    LONG TotalAcquisitionsAtDpcLevel;
    LONG TotalReleasesFromDpcLevel;

} UL_DEBUG_STATISTICS_INFO, *PUL_DEBUG_STATISTICS_INFO;


//
// Structure used to simulate synchronous I/O when issueing IRPs directly.
//

typedef struct _UL_STATUS_BLOCK
{
    IO_STATUS_BLOCK IoStatus;
    KEVENT Event;

} UL_STATUS_BLOCK, *PUL_STATUS_BLOCK;

#define UlInitializeStatusBlock( pstatus )                                  \
    do                                                                      \
    {                                                                       \
        (pstatus)->IoStatus.Status = STATUS_PENDING;                        \
        (pstatus)->IoStatus.Information = 0;                                \
        KeInitializeEvent( &((pstatus)->Event), NotificationEvent, FALSE ); \
    } while (FALSE)

#define UlWaitForStatusBlockEvent( pstatus )                                \
    KeWaitForSingleObject(                                                  \
        (PVOID)&((pstatus)->Event),                                         \
        UserRequest,                                                        \
        KernelMode,                                                         \
        FALSE,                                                              \
        NULL                                                                \
        )

#define UlResetStatusBlockEvent( pstatus )                                  \
    KeResetEvent( &((pstatus)->Event) )

#define UlSignalStatusBlock( pstatus, status, info )                        \
    do                                                                      \
    {                                                                       \
        (pstatus)->IoStatus.Status = (status);                              \
        (pstatus)->IoStatus.Information = (info);                           \
        KeSetEvent( &((pstatus)->Event), 0, FALSE );                        \
    } while (FALSE)


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultci.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    ultci.cxx - UL TrafficControl Interface

Abstract:

    This module implements a wrapper for QoS TC (Traffic Control)
    Interface since the Kernel level API don't exist at this time.

    Any HTTP module can use this interface to invoke QoS calls.

Author:

    Ali Ediz Turkoglu (aliTu)       28-Jul-2000 Created a draft
                                                version

Revision History:

    Ali Ediz Turkoglu (aliTu)       03-11-2000  Modified to handle
                                                Flow & Filter (re)config
                                                as well as various other
                                                major changes. In other
                                                word i've put it into a
                                                shape to be a component
--*/

#include "precomp.h"

//
// A nonpaged resource - TciIfcResource - guards the interface list
// and its flows.
//

LIST_ENTRY      g_TciIfcListHead = {NULL,NULL};
//LIST_ENTRY      g_TcCGroupListHead = {NULL,NULL};
BOOLEAN         g_InitTciCalled  = FALSE;

//
// GPC handles to talk to
//

HANDLE          g_GpcFileHandle;   // result of CreateFile on GPC device
GPC_HANDLE      g_GpcClientHandle; // result of GPC client registration

//
// For querying the interface info like index & mtu size
//

HANDLE          g_TcpDeviceHandle = NULL;

//
// Shows if PSCHED is installed or not
//

LONG            g_PSchedInstalled = 0;

//
// Shows if Global Bandwidth Throttling is enabled or not
//

LONG            g_GlobalThrottling = 0;

//
// For interface notifications
//

PVOID           g_TcInterfaceUpNotificationObject = NULL;
PVOID           g_TcInterfaceDownNotificationObject = NULL;
PVOID           g_TcInterfaceChangeNotificationObject = NULL;


#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, UlTcInitialize)
#pragma alloc_text(PAGE, UlTcTerminate)
#pragma alloc_text(PAGE, UlpTcInitializeGpc)
#pragma alloc_text(PAGE, UlpTcRegisterGpcClient)
#pragma alloc_text(PAGE, UlpTcDeRegisterGpcClient)
#pragma alloc_text(PAGE, UlpTcGetFriendlyNames)
#pragma alloc_text(PAGE, UlpTcReleaseAll)
#pragma alloc_text(PAGE, UlpTcCloseInterface)
#pragma alloc_text(PAGE, UlpTcCloseAllInterfaces)
#pragma alloc_text(PAGE, UlpTcDeleteFlow)

#endif  // ALLOC_PRAGMA
#if 0

NOT PAGEABLE -- UlpRemoveFilterEntry
NOT PAGEABLE -- UlpInsertFilterEntry

#endif

//
// Init & Terminate stuff comes here.
//

/***************************************************************************++

Routine Description:

    UlTcInitialize :

        Will also initiate the Gpc client registration and make few WMI calls
        down to psched.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlTcInitialize (
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    ASSERT(!g_InitTciCalled);

    g_GlobalThrottling = 0;
    g_PSchedInstalled  = 0;

    if (!g_InitTciCalled)
    {
        InitializeListHead(&g_TciIfcListHead);

        //InitializeListHead(&g_TcCGroupListHead);

        Status = UlInitializeResource(
                        &g_pUlNonpagedData->TciIfcResource,
                        "TciIfcResource",
                        0,
                        UL_TCI_RESOURCE_TAG
                        );
        ASSERT(NT_SUCCESS(Status));

        Status = UlpTcInitializeGpc();
        if (!NT_SUCCESS(Status))
            goto cleanup;

        UlTrace( TC, ("Ul!UlTcInitialize: InitializeGpc Status %08lx \n", Status ));

        Status = UlpTcInitializeTcpDevice();
        if (!NT_SUCCESS(Status))
            goto cleanup;

        UlTrace( TC, ("Ul!UlTcInitialize: InitializeTcp Status %08lx \n", Status ));

        Status = UlpTcGetFriendlyNames();
        if (!NT_SUCCESS(Status))
            goto cleanup;

        UlTrace( TC, ("Ul!UlTcInitialize: GetFriendlyNames Status %08lx \n", Status ));

        Status = UlpTcRegisterForCallbacks();
        if (!NT_SUCCESS(Status))
            goto cleanup;

        UlTrace( TC, ("Ul!UlTcInitialize: UlpTcRegisterForCallbacks Status %08lx \n", Status ));

        //
        // Success !
        //

        g_InitTciCalled = TRUE;
    }

cleanup:

    if (!NT_SUCCESS(Status))
    {
        NTSTATUS TempStatus;

        UlTrace( TC, ("Ul!UlTcInitialize: FAILURE %08lx \n", Status ));

        TempStatus = UlDeleteResource( &g_pUlNonpagedData->TciIfcResource );
        ASSERT(NT_SUCCESS(TempStatus));

        //
        // Do not forget to DeRegister Gpc Client & Close Device Handle
        //

        if (g_GpcClientHandle != NULL)
        {
            UlpTcDeRegisterGpcClient();

            ASSERT(g_GpcFileHandle);
            ZwClose(g_GpcFileHandle);

            UlTrace( TC, ("Ul!UlTcInitialize: Gpc Device Handle Closed.\n" ));
        }

        if (g_TcpDeviceHandle != NULL)
        {
            ZwClose(g_TcpDeviceHandle);
            g_TcpDeviceHandle=NULL;

            UlTrace( TC, ("Ul!UlTcInitialize: Tcp Device Handle Closed.\n" ));
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcTerminate :

        Terminates the TCI module by releasing our TCI resource and
        cleaning up all the qos stuff.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

VOID
UlTcTerminate(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    UlTrace( TC, ("Ul!UlTcTerminate: ... \n" ));

    if (g_InitTciCalled)
    {
        //
        // No more Wmi callbacks for interface changes
        //

        if (g_TcInterfaceUpNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceUpNotificationObject);
            g_TcInterfaceUpNotificationObject=NULL;
        }
        if(g_TcInterfaceDownNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceDownNotificationObject);
            g_TcInterfaceDownNotificationObject = NULL;
        }

        if(g_TcInterfaceChangeNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceChangeNotificationObject);
            g_TcInterfaceChangeNotificationObject = NULL;
        }

        //
        // Make sure terminate all the QoS stuff
        //

        Status = UlpTcReleaseAll();
        ASSERT(NT_SUCCESS(Status));

        if (g_TcpDeviceHandle != NULL)
        {
            ZwClose(g_TcpDeviceHandle);
            g_TcpDeviceHandle = NULL;
        }

        Status = UlDeleteResource(
                    &g_pUlNonpagedData->TciIfcResource
                    );
        ASSERT(NT_SUCCESS(Status));

        g_InitTciCalled = FALSE;
    }

    UlTrace( TC, ("Ul!UlTcTerminate: Completed.\n" ));
}

/***************************************************************************++

Routine Description:

    UlpTcInitializeGpc :

        It will open the Gpc file handle and attempt to register as Gpc
        client.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcInitializeGpc(
    VOID
    )
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          GpcNameString;
    OBJECT_ATTRIBUTES       GpcObjAttribs;

    Status = STATUS_SUCCESS;

    //
    // Open Gpc Device Handle
    //

    RtlInitUnicodeString(&GpcNameString, DD_GPC_DEVICE_NAME);

    InitializeObjectAttributes(&GpcObjAttribs,
                               &GpcNameString,
                                OBJ_CASE_INSENSITIVE | UL_KERNEL_HANDLE,
                                NULL,
                                NULL
                                );

    Status = ZwCreateFile(&g_GpcFileHandle,
                           SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &GpcObjAttribs,
                          &IoStatusBlock,
                           NULL,
                           FILE_ATTRIBUTE_NORMAL,
                           FILE_SHARE_READ | FILE_SHARE_WRITE,
                           FILE_OPEN_IF,
                           0,
                           NULL,
                           0
                           );
    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    ASSERT( g_GpcFileHandle != NULL );

    UlTrace( TC, ("Ul!UlpTcInitializeGpc: Gpc Device Opened. %p\n",
                   g_GpcFileHandle ));

    //
    // Register as GPC_CF_QOS Gpc Client
    //

    Status = UlpTcRegisterGpcClient(GPC_CF_QOS);

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRegisterGpcClient :

        Will build up the necessary structures and make a register call down
        to Gpc

Arguments:

    CfInfoType - Should be GPC_CF_QOS for our purposes.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcRegisterGpcClient(
    IN  ULONG   CfInfoType
    )
{
    NTSTATUS                Status;
    GPC_REGISTER_CLIENT_REQ GpcReq;
    GPC_REGISTER_CLIENT_RES GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    IO_STATUS_BLOCK         IoStatBlock;

    Status = STATUS_SUCCESS;

    if ( g_GpcFileHandle == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    InBuffSize  = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    //
    // In HTTP we should only register for GPC_CF_QOS.
    //

    ASSERT(CfInfoType == GPC_CF_QOS);

    GpcReq.CfId  = CfInfoType;
    GpcReq.Flags = GPC_FLAGS_FRAGMENT;
    GpcReq.MaxPriorities = 1;
    GpcReq.ClientContext =  (GPC_CLIENT_HANDLE) 0;       // ???????? Possible BUGBUG ...
    //GpcReq.ClientContext = (GPC_CLIENT_HANDLE)GetCurrentProcessId(); // process id

    Status = UlpTcDeviceControl(g_GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                               &IoStatBlock,
                                IOCTL_GPC_REGISTER_CLIENT,
                               &GpcReq,
                                InBuffSize,
                               &GpcRes,
                                OutBuffSize
                                );
    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcRegisterGpcClient: FAILURE 1 %08lx \n", Status ));
        goto end;
    }

    Status = GpcRes.Status;

    if ( NT_SUCCESS(Status) )
    {
        g_GpcClientHandle = GpcRes.ClientHandle;

        UlTrace( TC, ("Ul!UlpTcRegisterGpcClient: Gpc Client %p Registered.\n",
                       g_GpcClientHandle
                       ));
    }
    else
    {
        g_GpcClientHandle = NULL;

        UlTrace( TC, ("Ul!UlpTcRegisterGpcClient: FAILURE 2 %08lx \n", Status ));
    }

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcDeRegisterGpcClient :

        Self explainatory.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeRegisterGpcClient(
    VOID
    )
{
    NTSTATUS                  Status;
    GPC_DEREGISTER_CLIENT_REQ GpcReq;
    GPC_DEREGISTER_CLIENT_RES GpcRes;
    ULONG                     InBuffSize;
    ULONG                     OutBuffSize;
    IO_STATUS_BLOCK           IoStatBlock;

    Status = STATUS_SUCCESS;

    if (g_GpcFileHandle == NULL && g_GpcClientHandle == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    InBuffSize  = sizeof(GPC_REGISTER_CLIENT_REQ);
    OutBuffSize = sizeof(GPC_REGISTER_CLIENT_RES);

    GpcReq.ClientHandle = g_GpcClientHandle;

    Status = UlpTcDeviceControl(g_GpcFileHandle,
                                NULL,
                                NULL,
                                NULL,
                               &IoStatBlock,
                                IOCTL_GPC_DEREGISTER_CLIENT,
                               &GpcReq,
                                InBuffSize,
                               &GpcRes,
                                OutBuffSize
                                );
    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    Status = GpcRes.Status;

    if ( NT_SUCCESS(Status) )
    {
        g_GpcClientHandle = NULL;

        UlTrace( TC, ("Ul!UlpTcDeRegisterGpcClient: Client DeRegistered.\n" ));
    }
    else
    {
        UlTrace( TC, ("Ul!UlpTcDeRegisterGpcClient: FAILURE %08lx \n", Status ));
    }

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcGetIpAddr :

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

BOOLEAN
UlpTcGetIpAddr(
    IN  PADDRESS_LIST_DESCRIPTOR    pAddressListDesc,
    OUT PULONG                      pIn_addr,
    OUT PULONG                      pSpecificLinkCtx
    )
{
    NETWORK_ADDRESS UNALIGNED64    *pAddr;
    NETWORK_ADDRESS_IP UNALIGNED64 *pIpNetAddr = NULL;
    NETWORK_ADDRESS_IP UNALIGNED64 *p2ndIpNetAddr = NULL;
    ULONG                           cAddr;
    ULONG                           index;

    cAddr = pAddressListDesc->AddressList.AddressCount;
    if (cAddr == 0)
    {
        return FALSE;
    }

    pAddr = (UNALIGNED64 NETWORK_ADDRESS *) &pAddressListDesc->AddressList.Address[0];

    for (index = 0; index < cAddr; index++)
    {
        if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
        {
            pIpNetAddr = (UNALIGNED64 NETWORK_ADDRESS_IP *)&pAddr->Address[0];
            break;
        }

        pAddr = (UNALIGNED64 NETWORK_ADDRESS *)(((PUCHAR)pAddr)
                                   + pAddr->AddressLength
                                   + FIELD_OFFSET(NETWORK_ADDRESS, Address));
    }

    // Findout the SpecificLinkCtx (Remote IP address) for WAN links

    if( pAddressListDesc->MediaType == NdisMediumWan &&
        index+1 < cAddr )
    {
        //
        // There is another address that contains
        // the remote client address
        // this should be used as the link ID
        //

        pAddr = (UNALIGNED64 NETWORK_ADDRESS *)(((PUCHAR)pAddr)
                                               + pAddr->AddressLength
                                               + FIELD_OFFSET(NETWORK_ADDRESS, Address));

        if (pAddr->AddressType == NDIS_PROTOCOL_ID_TCP_IP)
        {
            //
            // Parse the second IP address,
            // this would be the remote IP address for dialin WAN
            //

            p2ndIpNetAddr     = (UNALIGNED64 NETWORK_ADDRESS_IP *)&pAddr->Address[0];
            *pSpecificLinkCtx = p2ndIpNetAddr->in_addr;
        }
    }

    if ( pIpNetAddr )
    {
        (*pIn_addr) = pIpNetAddr->in_addr;

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


/***************************************************************************++

Routine Description:

    UlpTcInitializeTcpDevice :


Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcInitializeTcpDevice(
    VOID
    )
{
    NTSTATUS                Status;
    IO_STATUS_BLOCK         IoStatusBlock;
    UNICODE_STRING          TcpNameString;
    OBJECT_ATTRIBUTES       TcpObjAttribs;

    Status = STATUS_SUCCESS;

    //
    // Open Gpc Device
    //

    RtlInitUnicodeString(&TcpNameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&TcpObjAttribs,
                               &TcpNameString,
                                OBJ_CASE_INSENSITIVE | UL_KERNEL_HANDLE,
                                NULL,
                                NULL);

    Status = ZwCreateFile(   &g_TcpDeviceHandle,
                             GENERIC_EXECUTE,
                             &TcpObjAttribs,
                             &IoStatusBlock,
                             NULL,
                             FILE_ATTRIBUTE_NORMAL,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             FILE_OPEN_IF,
                             0,
                             NULL,
                             0);

    if ( !NT_SUCCESS(Status) )
    {
        goto end;
    }

    ASSERT( g_TcpDeviceHandle != NULL );

end:
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcUpdateInterfaceMTU :

        Helper function to get the interface MTU sizes by querrying the TCP.

        Acquire the TciIfcResource before callling this function.
        Make sure that the if_indexes are correct in the individual tc_flow
        structures.

        WORKITEM:
        Current approach is not really scalable in terms of interface count.
        But assuming the #of interfaces will be few simplify the code a lot.

--***************************************************************************/

NTSTATUS
UlpTcUpdateInterfaceMTU(
    VOID
    )
{
    NTSTATUS Status;
    IO_STATUS_BLOCK IoStatBlock;
    TDIObjectID *ID;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiInBuf;
    TDIEntityID *EntityTable;
    TDIEntityID *pEntity;
    IFEntry *pIFEntry;
    ULONG InBufLen;
    ULONG OutBufLen;
    ULONG NumEntities;
    ULONG NumInterfacesUpdated;
    ULONG index;
    PLIST_ENTRY pInterfaceEntry;
    PUL_TCI_INTERFACE pInterface;

    //
    // Initialize & Sanity check first
    //

    Status = STATUS_SUCCESS;

    ASSERT( g_TcpDeviceHandle != NULL );

    pIFEntry = NULL;
    NumInterfacesUpdated = 0;

    UlTrace(TC,("Ul!UlpTcUpdateInterfaceMTU ...\n" ));

    //
    // Enumerate the interfaces by querying the TCP. Get TDI entity count
    // search through entities to find out the IF_ENTITYs. The make yet
    // another query to get the full interface info including the MTU size
    //

    InBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
    OutBufLen = sizeof(TDIEntityID) * MAX_TDI_ENTITIES;

    EntityTable = (TDIEntityID *) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            OutBufLen,
                            UL_TCI_GENERIC_POOL_TAG
                            );
    if (EntityTable == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory(EntityTable,OutBufLen);
    RtlZeroMemory(&trqiInBuf,sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));

    ID = &(trqiInBuf.ID);

    ID->toi_entity.tei_entity   = GENERIC_ENTITY;
    ID->toi_entity.tei_instance = 0;
    ID->toi_class               = INFO_CLASS_GENERIC;
    ID->toi_type                = INFO_TYPE_PROVIDER;
    ID->toi_id                  = ENTITY_LIST_ID;

    Status = UlpTcDeviceControl(
                            g_TcpDeviceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_TCP_QUERY_INFORMATION_EX,
                            &trqiInBuf,
                            InBufLen,
                            EntityTable,
                            OutBufLen
                            );
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcUpdateInterfaceMTU: Get TDIEntityID failed\n"));
        goto end;
    }

    // Now we have all the TDI entities

    NumEntities = ((ULONG)(IoStatBlock.Information)) / sizeof(TDIEntityID);

    UlTrace(TC,("Ul!UlpTcUpdateInterfaceMTU: #Of TDI Entities %d\n", NumEntities));

    // Search through the interface entries

    for (index=0,pEntity=EntityTable; index < NumEntities; index++,pEntity++)
    {
        if (pEntity->tei_entity == IF_ENTITY)
        {
            // Allocate a buffer for the querry

            if (pIFEntry == NULL)
            {
                OutBufLen = sizeof(IFEntry) + MAX_IFDESCR_LEN;

                pIFEntry = (IFEntry *) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            OutBufLen,
                            UL_TCI_GENERIC_POOL_TAG
                            );
                if (pIFEntry == NULL)
                {
                    Status = STATUS_NO_MEMORY;
                    goto end;
                }
                RtlZeroMemory(pIFEntry,OutBufLen);
            }

            // Get the full IFEntry. It's a pitty that we only look at the
            // Mtu size after getting such a big structure.

            InBufLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);
            RtlZeroMemory(&trqiInBuf,sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));

            ID = &(trqiInBuf.ID);

            ID->toi_entity.tei_entity   = IF_ENTITY;
            ID->toi_entity.tei_instance = pEntity->tei_instance;
            ID->toi_class               = INFO_CLASS_PROTOCOL;
            ID->toi_type                = INFO_TYPE_PROVIDER;
            ID->toi_id                  = IF_MIB_STATS_ID;

            Status = UlpTcDeviceControl(
                            g_TcpDeviceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_TCP_QUERY_INFORMATION_EX,
                            &trqiInBuf,
                            InBufLen,
                            pIFEntry,
                            OutBufLen
                            );
            if (!NT_SUCCESS(Status))
            {
                UlTrace(TC,("Ul!UlpTcUpdateInterfaceMTU: Get_IF_MIB_STATS_ID failed\n" ));
                goto end;
            }

            // Now we have the interface info including the mtu size for this entity
            // Find the corresponding UL_TCI_INTERFACE by looking at the index

            pInterfaceEntry = g_TciIfcListHead.Flink;
            while ( pInterfaceEntry != &g_TciIfcListHead )
            {
                pInterface = CONTAINING_RECORD(
                             pInterfaceEntry,
                             UL_TCI_INTERFACE,
                             Linkage
                             );

                if (pIFEntry->if_index == pInterface->IfIndex)
                {
                    pInterface->MTUSize = pIFEntry->if_mtu;

                    UlTrace(TC,
                     ("Ul!UlpTcUpdateInterfaceMTU: if_index %d if_mtu %d if_speed %d\n",
                       pIFEntry->if_index,  pIFEntry->if_mtu, pIFEntry->if_speed ));

                    UL_DUMP_TC_INTERFACE(pInterface);

                    NumInterfacesUpdated++;
                }

                // search through next interface
                pInterfaceEntry = pInterfaceEntry->Flink;
            }
        }
    }

    UlTrace(TC,("Ul!UlpTcUpdateInterfaceMTU: %d interfaces updated.\n",
                 NumInterfacesUpdated ));

end:
    // Whine about the problems

    if (!NT_SUCCESS(Status))
    {
       UlTrace( TC,("Ul!UlpTcUpdateInterfaceMTU: FAILED Status %08lx\n",
                    Status ));
    }

    // Release the private buffers

    if ( pIFEntry != NULL )
    {
        UL_FREE_POOL( pIFEntry, UL_TCI_GENERIC_POOL_TAG );
    }

    if ( EntityTable != NULL )
    {
        UL_FREE_POOL( EntityTable, UL_TCI_GENERIC_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcGetInterfaceIndex :

        Helper function to get the interface index from TCP for our internal
        interface structure.

Arguments:

    PUL_TCI_INTERFACE  pIntfc - The interface we will find the index for.

--***************************************************************************/

NTSTATUS
UlpTcGetInterfaceIndex(
    IN  PUL_TCI_INTERFACE  pIntfc
    )
{
    NTSTATUS Status;
    IPAddrEntry *pIpAddrTbl;
    ULONG IpAddrTblSize;
    ULONG n,k;
    IO_STATUS_BLOCK IoStatBlock;
    TDIObjectID *ID;
    TCP_REQUEST_QUERY_INFORMATION_EX trqiInBuf;
    ULONG   InBuffLen;
    ULONG   NumEntries;

    //
    // Initialize & Sanity check first
    //

    Status = STATUS_SUCCESS;
    NumEntries = 0;
    pIpAddrTbl = NULL;

    //
    // BUGBUG should get ip address size and allocate enough buffer.
    // Or handle the STATUS_BUFFER_TOO_SMALL
    //

    IpAddrTblSize = sizeof(IPAddrEntry) * 1024;

    UlTrace(TC,("Ul!UlpTcGetInterfaceIndex: ....\n" ));

    ASSERT( g_TcpDeviceHandle != NULL );

    if (pIntfc->IpAddr)
    {
        // Allocate a private buffer to retrieve Ip Address table from TCP

        pIpAddrTbl = (IPAddrEntry *) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            IpAddrTblSize,
                            UL_TCI_GENERIC_POOL_TAG
                            );
        if (pIpAddrTbl == NULL)
        {
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        // Send down an Ioctl to Tcp to get the ip address table

        RtlZeroMemory(pIpAddrTbl,IpAddrTblSize);
        RtlZeroMemory(&trqiInBuf,sizeof(TCP_REQUEST_QUERY_INFORMATION_EX));
        InBuffLen  = sizeof(TCP_REQUEST_QUERY_INFORMATION_EX);

        ID = &(trqiInBuf.ID);

        ID->toi_entity.tei_entity   = CL_NL_ENTITY;
        ID->toi_entity.tei_instance = 0;
        ID->toi_class               = INFO_CLASS_PROTOCOL;
        ID->toi_type                = INFO_TYPE_PROVIDER;
        ID->toi_id                  = IP_MIB_ADDRTABLE_ENTRY_ID;

        Status = UlpTcDeviceControl(
                            g_TcpDeviceHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_TCP_QUERY_INFORMATION_EX,
                            &trqiInBuf,
                            InBuffLen,
                            pIpAddrTbl,
                            IpAddrTblSize
                            );
        if (!NT_SUCCESS(Status))
        {
            goto end;
        }

        // Look at how many entries were written to the output buffer (pIpAddrTbl)

        NumEntries = (((ULONG)IoStatBlock.Information)/sizeof(IPAddrEntry));

        UlTrace(TC,("Ul!UlpTcGetInterfaceIndex: NumEntries %d\n", NumEntries ));

        //
        // Search for the matching IP address to IpAddr
        // in the table we got back from the stack
        //

        for (k=0; k<NumEntries; k++)
        {
            if (pIpAddrTbl[k].iae_addr == pIntfc->IpAddr)
            {
                // Found it found it! Get the index baby.

                pIntfc->IfIndex = pIpAddrTbl[k].iae_index;

                UlTrace(TC,("Ul!UlpTcGetInterfaceIndex: got for index %d\n",
                             pIntfc->IfIndex ));
                break;
            }
        }
    }

end:
    if (!NT_SUCCESS(Status))
    {
       UlTrace(TC,("Ul!UlpTcGetInterfaceIndex: FAILED Status %08lx\n",
                    Status));
    }

    if ( pIpAddrTbl != NULL )
    {
        UL_FREE_POOL( pIpAddrTbl, UL_TCI_GENERIC_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcAllocateInterface :

        ... fairly straightforward ...

Argument:


Return Value:

    PUL_TCI_INTERFACE - Newly allocated interface structure

--***************************************************************************/

PUL_TCI_INTERFACE
UlpTcAllocateInterface(
    IN ULONG    DescSize,
    IN PADDRESS_LIST_DESCRIPTOR Desc,
    IN ULONG    NameLength,
    IN PUCHAR   Name,
    IN ULONG    InstanceIDLength,
    IN PUCHAR   InstanceID
    )
{
    PUL_TCI_INTERFACE pTcIfc;

    //
    // Sanity Checks
    //

    ASSERT(NameLength <= MAX_STRING_LENGTH);
    ASSERT(InstanceIDLength <= MAX_STRING_LENGTH);

    //
    // Allocate a new interface structure & initialize it
    //

    pTcIfc = UL_ALLOCATE_STRUCT(
                        PagedPool,
                        UL_TCI_INTERFACE,
                        UL_TCI_INTERFACE_POOL_TAG
                        );
    if ( pTcIfc == NULL )
    {
        return NULL;
    }

    RtlZeroMemory( pTcIfc, sizeof(UL_TCI_INTERFACE) );

    pTcIfc->Signature = UL_TCI_INTERFACE_POOL_TAG;

    InitializeListHead( &pTcIfc->FlowList );

    // Variable size addresslist

    pTcIfc->pAddressListDesc = (PADDRESS_LIST_DESCRIPTOR)
                    UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            DescSize,
                            UL_TCI_INTERFACE_POOL_TAG
                            );
    if ( pTcIfc->pAddressListDesc == NULL )
    {
        UL_FREE_POOL_WITH_SIG(pTcIfc, UL_TCI_INTERFACE_POOL_TAG);
        return NULL;
    }

    pTcIfc->AddrListBytesCount = DescSize;

    // Copy the instance name string data

    RtlCopyMemory(pTcIfc->Name,Name,NameLength);

    pTcIfc->NameLength = (USHORT)NameLength;
    pTcIfc->Name[NameLength/sizeof(WCHAR)] = UNICODE_NULL;

    // Copy the instance ID string data

    RtlCopyMemory(pTcIfc->InstanceID,InstanceID,InstanceIDLength);

    pTcIfc->InstanceIDLength = (USHORT)InstanceIDLength;
    pTcIfc->InstanceID[InstanceIDLength/sizeof(WCHAR)] = UNICODE_NULL;

    // Copy the Description data and extract the corresponding ip address

    RtlCopyMemory(pTcIfc->pAddressListDesc, Desc, DescSize);

    // IP Address of the interface is hidden in this desc data
    // we will find out and save it for faster lookup.

    pTcIfc->IsQoSEnabled =
        UlpTcGetIpAddr( pTcIfc->pAddressListDesc,
                       &pTcIfc->IpAddr,
                       &pTcIfc->SpecificLinkCtx
                        );
    return pTcIfc;
}

VOID
UlpTcFreeInterface(
    IN OUT PUL_TCI_INTERFACE  pTcIfc
    )
{
    // Clean up the interface & addreslist pointer

    if (pTcIfc)
    {
        if (pTcIfc->pAddressListDesc)
        {
            UL_FREE_POOL(pTcIfc->pAddressListDesc,
                         UL_TCI_INTERFACE_POOL_TAG
                         );
        }

        UL_FREE_POOL_WITH_SIG(pTcIfc, UL_TCI_INTERFACE_POOL_TAG);
    }
}

/***************************************************************************++

Routine Description:

    UlpTcGetFriendlyNames :

        Make a Wmi Querry to get the firendly names of all interfaces.
        Its basically replica of the tcdll enumerate interfaces call.

        This function also allocates the global interface list. If it's not
        successfull it doesn't though.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcGetFriendlyNames(
    VOID
    )
{
    NTSTATUS            Status;
    PVOID               WmiObject;
    ULONG               MyBufferSize;
    PWNODE_ALL_DATA     pWnode;
    PWNODE_ALL_DATA     pWnodeBuffer;
    PUL_TCI_INTERFACE   pTcIfc;
    GUID                QoSGuid;
    PLIST_ENTRY         pEntry;
    PUL_TCI_INTERFACE   pInterface;

    //
    // Initialize defaults
    //

    Status       = STATUS_SUCCESS;
    WmiObject    = NULL;
    pWnodeBuffer = NULL;
    pTcIfc       = NULL;
    MyBufferSize = UL_DEFAULT_WMI_QUERY_BUFFER_SIZE;
    QoSGuid      = GUID_QOS_TC_SUPPORTED;

    //
    // Get a WMI block handle to the GUID_QOS_SUPPORTED
    //

    Status = IoWMIOpenBlock( (GUID *) &QoSGuid, 0, &WmiObject );

    if (!NT_SUCCESS(Status))
    {
        if (Status == STATUS_WMI_GUID_NOT_FOUND)
        {
            // This means there is no TC data provider (which's Psched)

            UlTrace(TC,("Ul!UlpTcGetFriendlyNames: PSCHED hasn't been installed !\n"));
        }
        else
        {
            UlTrace(TC,("Ul!UlpTcGetFriendlyNames:IoWMIOpenBlock FAILED Status %08lx\n",
                         Status));
        }
        return Status;
    }

    //
    // Mark that PSched is installed
    //

    g_PSchedInstalled = 1;

    do
    {
        //
        // Allocate a private buffer to retrieve all wnodes
        //

        pWnodeBuffer = (PWNODE_ALL_DATA) UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            UCHAR,
                            MyBufferSize,
                            UL_TCI_WMI_POOL_TAG
                            );
        if (pWnodeBuffer == NULL)
        {
            ObDereferenceObject(WmiObject);
            return STATUS_NO_MEMORY;
        }

        __try
        {
            Status = IoWMIQueryAllData(WmiObject, &MyBufferSize, pWnodeBuffer);

            UlTrace( TC,
                ("Ul!UlpTcGetFriendlyNames: IoWMIQueryAllData Status %08lx\n",
                  Status
                  ));
        }
        __except ( UL_EXCEPTION_FILTER() )
        {
            Status = GetExceptionCode();
        }

        if (Status == STATUS_BUFFER_TOO_SMALL)
        {
            //
            // Failed since the buffer was too small.
            // Release the buffer and double the size.
            //

            MyBufferSize *= 2;
            UL_FREE_POOL( pWnodeBuffer, UL_TCI_WMI_POOL_TAG );
            pWnodeBuffer = NULL;
        }

    } while (Status == STATUS_BUFFER_TOO_SMALL);

    if (NT_SUCCESS(Status))
    {
        ULONG   dwInstanceNum;
        ULONG   InstanceSize;
        PULONG  lpdwNameOffsets;
        BOOLEAN bFixedSize = FALSE;
        USHORT  usNameLength;
        ULONG   DescSize;
        PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;

        pWnode = pWnodeBuffer;

        ASSERT(pWnode->WnodeHeader.Flags & WNODE_FLAG_ALL_DATA);

        do
        {
            //
            // Check for fixed instance size
            //

            if (pWnode->WnodeHeader.Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE)
            {

                InstanceSize  = pWnode->FixedInstanceSize;
                bFixedSize    = TRUE;
                pTcInfoBuffer =
                    (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(pWnode,
                                                           pWnode->DataBlockOffset);
            }

            //
            //  Get a pointer to the array of offsets to the instance names
            //

            lpdwNameOffsets = (PULONG) OffsetToPtr(pWnode,
                                                   pWnode->OffsetInstanceNameOffsets);

            for ( dwInstanceNum = 0;
                  dwInstanceNum < pWnode->InstanceCount;
                  dwInstanceNum++ )
            {
                usNameLength = *(PUSHORT)OffsetToPtr(pWnode,lpdwNameOffsets[dwInstanceNum]);

                //
                //  Length and offset for variable data
                //

                if ( !bFixedSize )
                {
                    InstanceSize =
                        pWnode->OffsetInstanceDataAndLength[dwInstanceNum].LengthInstanceData;

                    pTcInfoBuffer =
                        (PTC_SUPPORTED_INFO_BUFFER)OffsetToPtr(
                                           (PBYTE)pWnode,
                                           pWnode->OffsetInstanceDataAndLength[dwInstanceNum].OffsetInstanceData);
                }

                //
                // We have all that is needed.
                //

                ASSERT(usNameLength < MAX_STRING_LENGTH);

                DescSize = InstanceSize - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

                //
                // Allocate a new interface structure & initialize it with
                // the wmi data we have acquired.
                //

                pTcIfc = UlpTcAllocateInterface(
                            DescSize,
                            &pTcInfoBuffer->AddrListDesc,
                            usNameLength,
                            (PUCHAR) OffsetToPtr(pWnode,lpdwNameOffsets[dwInstanceNum] + sizeof(USHORT)),
                            pTcInfoBuffer->InstanceIDLength,
                            (PUCHAR) &pTcInfoBuffer->InstanceID[0]
                            );
                if ( pTcIfc == NULL )
                {
                    Status = STATUS_NO_MEMORY;
                    goto end;
                }

                //
                // Get the interface index from TCP
                //

                Status = UlpTcGetInterfaceIndex( pTcIfc );
                ASSERT(NT_SUCCESS(Status));

                //
                // Add this interface to the global interface list
                //

                UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

                InsertTailList(&g_TciIfcListHead, &pTcIfc->Linkage );

                UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

                //
                // Set to Null so we don't try to cleanup after we insert it
                // to the global list.
                //

                pTcIfc = NULL;
            }

            //
            //  Update Wnode to point to next node
            //

            if ( pWnode->WnodeHeader.Linkage != 0)
            {
                pWnode = (PWNODE_ALL_DATA) OffsetToPtr( pWnode,
                                                        pWnode->WnodeHeader.Linkage);
            }
            else
            {
                pWnode = NULL;
            }
        }
        while ( pWnode != NULL && NT_SUCCESS(Status) );

        //
        // Update the mtu sizes for all interfaces now.
        //

        UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

        UlpTcUpdateInterfaceMTU();

        UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

        UlTrace(TC,("Ul!UlpTcGetFriendlyNames: got all the names.\n"));
    }

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcGetFriendlyNames: FAILED Status %08lx\n",
                     Status
                     ));
        if (pTcIfc)
        {
            UlpTcFreeInterface( pTcIfc );
        }

        //
        // Cleanup the partially done interface list if not empty
        //

        while ( !IsListEmpty( &g_TciIfcListHead ) )
        {
            pEntry = g_TciIfcListHead.Flink;
            pInterface = CONTAINING_RECORD( pEntry,
                                            UL_TCI_INTERFACE,
                                            Linkage
                                            );
            RemoveEntryList( pEntry );
            UlpTcFreeInterface( pInterface );
        }
    }

    //
    // Release resources and close WMI handle
    //

    if (WmiObject != NULL)
    {
        ObDereferenceObject(WmiObject);
    }

    if (pWnodeBuffer)
    {
        UL_FREE_POOL(pWnodeBuffer, UL_TCI_WMI_POOL_TAG);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

  UlpTcReleaseAll :

    Close all interfaces, all flows and all filters.
    Also deregister GPC clients and release all TC ineterfaces.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcReleaseAll(
    VOID
    )
{
    NTSTATUS Status;

    //
    // Close all interfaces their flows & filters
    //

    UlpTcCloseAllInterfaces();

    //
    // DeRegister the QoS GpcClient
    //

    Status = UlpTcDeRegisterGpcClient();

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcReleaseAll: FAILURE %08lx \n", Status ));
    }

    //
    // Finally close our gpc file handle
    //

    ZwClose(g_GpcFileHandle);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcCloseAllInterfaces :

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcCloseAllInterfaces(
    VOID
    )
{
    NTSTATUS            Status;
    PLIST_ENTRY         pEntry;
    PUL_TCI_INTERFACE   pInterface;

    Status = STATUS_SUCCESS;

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    //
    // Close all interfaces in our global list
    //

    while ( !IsListEmpty( &g_TciIfcListHead ) )
    {
        pEntry = g_TciIfcListHead.Flink;

        pInterface = CONTAINING_RECORD( pEntry,
                                        UL_TCI_INTERFACE,
                                        Linkage
                                        );
        UlpTcCloseInterface( pInterface );

        RemoveEntryList( pEntry );

        UlpTcFreeInterface( pInterface );
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    return Status;
}

/***************************************************************************++

Routine Description:

    Cleans up all the flows on the interface.

Arguments:

    pInterface - to be closed

--***************************************************************************/

NTSTATUS
UlpTcCloseInterface(
    PUL_TCI_INTERFACE   pInterface
    )
{
    NTSTATUS        Status;
    PLIST_ENTRY     pEntry;
    PUL_TCI_FLOW    pFlow;

    ASSERT(IS_VALID_TCI_INTERFACE(pInterface));

    //
    // Go clean up all flows for the interface and remove itself as well
    //

    Status = STATUS_SUCCESS;

    while (!IsListEmpty(&pInterface->FlowList))
    {
        pEntry= pInterface->FlowList.Flink;

        pFlow = CONTAINING_RECORD(
                            pEntry,
                            UL_TCI_FLOW,
                            Linkage
                            );

        ASSERT(IS_VALID_TCI_FLOW(pFlow));

        //
        // Remove flow from the corresponding cg's flowlist
        // as well if it's not a global flow. We understand
        // that by looking at its config group pointer.
        //

        if (pFlow->pConfigGroup)
        {
            ASSERT(IS_VALID_CONFIG_GROUP(pFlow->pConfigGroup));

            RemoveEntryList(&pFlow->Siblings);
            pFlow->Siblings.Flink = pFlow->Siblings.Blink = NULL;
            pFlow->pConfigGroup = NULL;
        }

        //
        // Now remove from the interface.
        //

        Status = UlpTcDeleteFlow(pFlow);
        ASSERT(NT_SUCCESS(Status));

    }

    UlTrace(TC,("Ul!UlpTcCloseInterface: All flows deleted on Ifc @ %p\n",
                  pInterface ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcWalkWnode :


Arguments:

    ... the WMI provided data buffer ...

--***************************************************************************/

NTSTATUS
UlpTcWalkWnode(
   IN PWNODE_HEADER pWnodeHdr,
   IN PUL_TC_NOTIF_HANDLER pNotifHandler
   )
{
    NTSTATUS        Status;
    PWCHAR          NamePtr;
    USHORT          NameSize;
    PUCHAR          DataBuffer;
    ULONG           DataSize;
    ULONG           Flags;
    PULONG          NameOffset;

    //
    // Try to capture the data frm WMI Buffer
    //

    ASSERT(pNotifHandler);

    Status = STATUS_SUCCESS;
    Flags  = pWnodeHdr->Flags;

    if (Flags & WNODE_FLAG_ALL_DATA)
    {
        //
        // WNODE_ALL_DATA structure has multiple interfaces
        //

        PWNODE_ALL_DATA pWnode = (PWNODE_ALL_DATA)pWnodeHdr;
        ULONG   Instance;

        UlTrace(TC,("Ul!UlpTcWalkWnode: ALL_DATA ... \n" ));

        NameOffset = (PULONG) OffsetToPtr(pWnode,
                                          pWnode->OffsetInstanceNameOffsets );
        DataBuffer = (PUCHAR) OffsetToPtr(pWnode,
                                          pWnode->DataBlockOffset);

        for (Instance = 0;
             Instance < pWnode->InstanceCount;
             Instance++)
        {
            //  Instance Name

            NamePtr = (PWCHAR) OffsetToPtr(pWnode,NameOffset[Instance] + sizeof(USHORT));
            NameSize = * (PUSHORT) OffsetToPtr(pWnode,NameOffset[Instance]);

            //  Instance Data

            if ( Flags & WNODE_FLAG_FIXED_INSTANCE_SIZE )
            {
                DataSize = pWnode->FixedInstanceSize;
            }
            else
            {
                DataSize =
                    pWnode->OffsetInstanceDataAndLength[Instance].LengthInstanceData;
                DataBuffer =
                    (PUCHAR)OffsetToPtr(pWnode,
                                        pWnode->OffsetInstanceDataAndLength[Instance].OffsetInstanceData);
            }

            // Call the handler

            pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );
        }
    }
    else if (Flags & WNODE_FLAG_SINGLE_INSTANCE)
    {
        //
        // WNODE_SINGLE_INSTANCE structure has only one instance
        //

        PWNODE_SINGLE_INSTANCE  pWnode = (PWNODE_SINGLE_INSTANCE)pWnodeHdr;

        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            return STATUS_SUCCESS;
        }

        UlTrace(TC,("Ul!UlpTcWalkWnode: SINGLE_INSTANCE ... \n" ));

        NamePtr = (PWCHAR)OffsetToPtr(pWnode,pWnode->OffsetInstanceName + sizeof(USHORT));
        NameSize = * (USHORT *) OffsetToPtr(pWnode,pWnode->OffsetInstanceName);

        //  Instance Data

        DataSize   = pWnode->SizeDataBlock;
        DataBuffer = (PUCHAR)OffsetToPtr (pWnode, pWnode->DataBlockOffset);

        // Call the handler

        pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );

    }
    else if (Flags & WNODE_FLAG_SINGLE_ITEM)
    {
        //
        // WNODE_SINGLE_ITEM is almost identical to single_instance
        //

        PWNODE_SINGLE_ITEM  pWnode = (PWNODE_SINGLE_ITEM)pWnodeHdr;

        if (Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            return STATUS_SUCCESS;
        }

        UlTrace(TC,("Ul!UlpTcWalkWnode: SINGLE_ITEM ... \n" ));

        NamePtr = (PWCHAR)OffsetToPtr(pWnode,pWnode->OffsetInstanceName + sizeof(USHORT));
        NameSize = * (USHORT *) OffsetToPtr(pWnode, pWnode->OffsetInstanceName);

        //  Instance Data

        DataSize   = pWnode->SizeDataItem;
        DataBuffer = (PUCHAR)OffsetToPtr (pWnode, pWnode->DataBlockOffset);

        // Call the handler

        pNotifHandler( NamePtr, NameSize, (PTC_INDICATION_BUFFER) DataBuffer, DataSize );

    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcHandleIfcUp :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcUp(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    ULONG AddrListDescSize;
    PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;

    Status = STATUS_SUCCESS;

    UlTrace(TC,("Ul!UlpTcHandleIfcUp: Adding %ws %d\n", Name, BufferSize ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    //
    // Allocate a new interface structure for the newcoming interface
    //

    AddrListDescSize = BufferSize
                       - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer)
                       - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

    UlTrace(TC,("Ul!UlpTcHandleIfcUp: AddrListDescSize %d\n", AddrListDescSize ));

    pTcInfoBuffer = & pTcBuffer->InfoBuffer;

    pTcIfc = UlpTcAllocateInterface(
                            AddrListDescSize,
                            &pTcInfoBuffer->AddrListDesc,
                            NameSize,
                            (PUCHAR) Name,
                            pTcInfoBuffer->InstanceIDLength,
                            (PUCHAR) &pTcInfoBuffer->InstanceID[0]
                            );
    if ( pTcIfc == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    UL_DUMP_TC_INTERFACE( pTcIfc );

    //
    // If we are receiving a notification for an interface already exist then
    // drop this call. Prevent global interface list corruption if we receive
    // inconsistent notifications. But there may be multiple interfaces with
    // same zero IPs.
    //

    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if ((pTcIfc->IpAddr != 0 && pTcIfcTemp->IpAddr == pTcIfc->IpAddr) ||
            (wcsncmp(pTcIfcTemp->Name, pTcIfc->Name, NameSize/sizeof(WCHAR))==0))
        {
            ASSERT(!"Conflict in the global interface list !");
            Status = STATUS_CONFLICTING_ADDRESSES;
            goto end;
        }
        pEntry = pEntry->Flink;
    }

    //
    // Get the interface index from TCP.
    //

    Status = UlpTcGetInterfaceIndex( pTcIfc );
    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Insert to the global interface list
    //

    InsertTailList( &g_TciIfcListHead, &pTcIfc->Linkage );

    //
    // Update the MTU Size
    //

    UlpTcUpdateInterfaceMTU();

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcHandleIfcUp: FAILURE %08lx \n", Status ));

        if (pTcIfc != NULL)
        {
            UlpTcFreeInterface(pTcIfc);
        }
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    return;
}
/***************************************************************************++

Routine Description:

    UlpTcHandleIfcDown :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcDown(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    ULONG AddrListDescSize;
    PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;

    Status = STATUS_SUCCESS;

    UlTrace(TC,("Ul!UlpTcHandleIfcDown: Removing %ws\n", Name ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    //
    // Find the corresponding ifc structure we keep.
    //

    pTcIfc = NULL;
    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if ( wcsncmp(pTcIfcTemp->Name, Name, NameSize) == 0 )
        {
            pTcIfc = pTcIfcTemp;
            break;
        }
        pEntry = pEntry->Flink;
    }

    if (pTcIfc == NULL)
    {
        ASSERT(FALSE);
        Status = STATUS_NOT_FOUND;
        goto end;
    }

    //
    // Remove this interface and its flows etc ...
    //

    UlpTcCloseInterface( pTcIfc );

    RemoveEntryList( &pTcIfc->Linkage );

    UlpTcFreeInterface( pTcIfc );

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcHandleIfcDown: FAILURE %08lx \n", Status ));
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    return;
}

/***************************************************************************++

Routine Description:

    UlpTcHandleIfcChange :

        This functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlpTcHandleIfcChange(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    )
{
    NTSTATUS Status;
    ULONG AddrListDescSize;
    PTC_SUPPORTED_INFO_BUFFER pTcInfoBuffer;
    PUL_TCI_INTERFACE pTcIfc;
    PUL_TCI_INTERFACE pTcIfcTemp;
    PLIST_ENTRY       pEntry;
    PADDRESS_LIST_DESCRIPTOR pAddressListDesc;

    Status = STATUS_SUCCESS;

    UlTrace(TC,("Ul!UlpTcHandleIfcChange: Updating %ws\n", Name ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    AddrListDescSize = BufferSize
                       - FIELD_OFFSET(TC_INDICATION_BUFFER,InfoBuffer)
                       - FIELD_OFFSET(TC_SUPPORTED_INFO_BUFFER, AddrListDesc);

    pTcInfoBuffer = & pTcBuffer->InfoBuffer;

    // Find the corresponding ifc structure we keep.

    pTcIfc = NULL;
    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pTcIfcTemp = CONTAINING_RECORD( pEntry, UL_TCI_INTERFACE, Linkage );
        if ( wcsncmp(pTcIfcTemp->Name, Name, NameSize) == 0 )
        {
            pTcIfc = pTcIfcTemp;
            break;
        }
        pEntry = pEntry->Flink;
    }

    if (pTcIfc == NULL)
    {
        ASSERT(FALSE);
        Status = STATUS_NOT_FOUND;
        goto end;
    }

    // Instance id

    RtlCopyMemory(pTcIfc->InstanceID,
                  pTcInfoBuffer->InstanceID,
                  pTcInfoBuffer->InstanceIDLength
                  );
    pTcIfc->InstanceIDLength = pTcInfoBuffer->InstanceIDLength;
    pTcIfc->InstanceID[pTcIfc->InstanceIDLength/sizeof(WCHAR)] = UNICODE_NULL;

    // The Description data and extract the corresponding ip address
    // ReWrite the fresh data. Size of the description data might be changed
    // so wee need to dynamically allocate it everytime changes

    pAddressListDesc =
            (PADDRESS_LIST_DESCRIPTOR) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            AddrListDescSize,
                            UL_TCI_INTERFACE_POOL_TAG
                            );
    if ( pAddressListDesc == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    if (pTcIfc->pAddressListDesc)
    {
        UL_FREE_POOL(pTcIfc->pAddressListDesc,UL_TCI_INTERFACE_POOL_TAG);
    }

    pTcIfc->pAddressListDesc   = pAddressListDesc;
    pTcIfc->AddrListBytesCount = AddrListDescSize;

    RtlCopyMemory( pTcIfc->pAddressListDesc,
                  &pTcInfoBuffer->AddrListDesc,
                   AddrListDescSize
                   );

    // IP Address of the interface is hidden in this desc data

    pTcIfc->IsQoSEnabled =
        UlpTcGetIpAddr( pTcIfc->pAddressListDesc,
                       &pTcIfc->IpAddr,
                       &pTcIfc->SpecificLinkCtx
                        );

    // ReFresh the interface index from TCP.

    Status = UlpTcGetInterfaceIndex( pTcIfc );
    if (!NT_SUCCESS(Status))
        goto end;

    // Update the MTU Size

    UlpTcUpdateInterfaceMTU();

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcHandleIfcChange: FAILURE %08lx \n", Status ));
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    return;
}

/***************************************************************************++

Routine Description:

    UlTcNotifyCallback :

        This callback functions handles the interface change notifications.
        We register for the corresponding notifications during init.

Arguments:

    PVOID Wnode - PSched data provided with WMI way

--***************************************************************************/

VOID
UlTcNotifyCallback(
    IN PVOID pWnode,
    IN PVOID Context
    )
{
    GUID *pGuid;
    PWNODE_HEADER pWnodeHeader;

    UlTrace( TC, ("Ul!UlTcNotifyCallback: ... \n" ));

    pWnodeHeader = (PWNODE_HEADER) pWnode;
    pGuid = &pWnodeHeader->Guid;

    if (UL_COMPARE_QOS_NOTIFICATION(pGuid,&GUID_QOS_TC_INTERFACE_UP_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcUp );
    }
    else if
    (UL_COMPARE_QOS_NOTIFICATION(pGuid, &GUID_QOS_TC_INTERFACE_DOWN_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcDown );
    }
    else if
    (UL_COMPARE_QOS_NOTIFICATION(pGuid, &GUID_QOS_TC_INTERFACE_CHANGE_INDICATION))
    {
        UlpTcWalkWnode( pWnodeHeader, UlpTcHandleIfcChange );
    }

    UlTrace( TC, ("Ul!UlTcNotifyCallback: Handled.\n" ));
}

/***************************************************************************++

Routine Description:

    UlpTcRegisterForCallbacks :

        We will open Block object until termination for each type of
        notification. And we will deref each object upon termination

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcRegisterForCallbacks(
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    GUID     Guid;

    //
    // Get a WMI block handle register all the callback functions.
    //

    Guid   = GUID_QOS_TC_INTERFACE_UP_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceUpNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceUpNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

    Guid   = GUID_QOS_TC_INTERFACE_DOWN_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceDownNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceDownNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

    Guid   = GUID_QOS_TC_INTERFACE_CHANGE_INDICATION;
    Status = IoWMIOpenBlock(&Guid,
                            WMIGUID_NOTIFICATION,
                            &g_TcInterfaceChangeNotificationObject
                            );
    if (NT_SUCCESS(Status))
    {
        Status = IoWMISetNotificationCallback(
                     g_TcInterfaceChangeNotificationObject,
                     (WMI_NOTIFICATION_CALLBACK) UlTcNotifyCallback,
                     NULL
                     );
        if (!NT_SUCCESS(Status))
            goto end;
    }

end:
    // Cleanup if necessary

    if (!NT_SUCCESS(Status))
    {
        UlTrace(TC,("Ul!UlpTcRegisterForCallbacks: FAILED %08lx\n",Status));

        if(g_TcInterfaceUpNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceUpNotificationObject);
            g_TcInterfaceUpNotificationObject = NULL;
        }

        if(g_TcInterfaceDownNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceDownNotificationObject);
            g_TcInterfaceDownNotificationObject = NULL;
        }

        if(g_TcInterfaceChangeNotificationObject!=NULL)
        {
            ObDereferenceObject(g_TcInterfaceChangeNotificationObject);
            g_TcInterfaceChangeNotificationObject = NULL;
        }
    }

    return Status;
}

//
// Following functions provide public/private interfaces for flow & filter
// creation/removal/modification for site & global flows.
//

/***************************************************************************++

Routine Description:

    UlpTcDeleteFlow :

        you should own the TciIfcResource exclusively before calling
        this function

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeleteFlow(
    IN PUL_TCI_FLOW         pFlow
    )
{
    NTSTATUS                Status;
    PLIST_ENTRY             pEntry;
    PUL_TCI_FILTER          pFilter;
    HANDLE                  FlowHandle;
    PUL_TCI_INTERFACE       pInterface;

    //
    // Initialize
    //

    Status = STATUS_SUCCESS;

    ASSERT(g_InitTciCalled);

    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    //
    // First remove all the filters belong to us
    //

    while (!IsListEmpty(&pFlow->FilterList))
    {
        pEntry = pFlow->FilterList.Flink;

        pFilter = CONTAINING_RECORD(
                            pEntry,
                            UL_TCI_FILTER,
                            Linkage
                            );

        Status = UlpTcDeleteFilter( pFlow, pFilter );
        ASSERT(NT_SUCCESS(Status));
    }

    //
    // Now remove the flow itself from our flowlist on the interface
    //

    pInterface = pFlow->pInterface;
    ASSERT( pInterface != NULL );

    RemoveEntryList( &pFlow->Linkage );

    ASSERT(pInterface->FlowListSize > 0);
    pInterface->FlowListSize -= 1;

    pFlow->Linkage.Flink = pFlow->Linkage.Blink = NULL;

    FlowHandle = pFlow->FlowHandle;

    UlTrace( TC, ("Ul!UlpTcDeleteFlow: Flow deleted. %p\n", pFlow  ));

    UL_FREE_POOL_WITH_SIG( pFlow, UL_TCI_FLOW_POOL_TAG );

    //
    // Finally talk to TC
    //

    Status = UlpTcDeleteGpcFlow( FlowHandle );

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcDeleteFlow: FAILURE %08lx \n", Status ));
    }
    else
    {
        UlTrace( TC, ("Ul!UlpTcDeleteFlow: FlowHandle %d deleted in TC as well.\n",
                    FlowHandle
                    ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcDeleteFlow :

        remove a flow from existing QoS Enabled interface

Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeleteGpcFlow(
    IN HANDLE  FlowHandle
    )
{
    NTSTATUS                Status;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    GPC_REMOVE_CF_INFO_REQ  GpcReq;
    GPC_REMOVE_CF_INFO_RES  GpcRes;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Remove the flow frm psched
    //

    InBuffSize =  sizeof(GPC_REMOVE_CF_INFO_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_CF_INFO_RES);

    GpcReq.ClientHandle    = g_GpcClientHandle;
    GpcReq.GpcCfInfoHandle = FlowHandle;

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_REMOVE_CF_INFO,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );
    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcDeleteGpcFlow: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcAllocateFlow :

        Allocates a flow and setup the FlowSpec according the passed BWT
        parameter

Arguments:

    HTTP_BANDWIDTH_LIMIT - FlowSpec will be created using this BWT limit
                           in B/s

Return Value

    PUL_TCI_FLOW - The newly allocated flow
    NULL         - If memory allocation failed

--***************************************************************************/

PUL_TCI_FLOW
UlpTcAllocateFlow(
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth,
    IN ULONG                MtuSize
    )
{
    PUL_TCI_FLOW            pFlow;
    TC_GEN_FLOW             TcGenFlow;

    //
    // Setup the FlowSpec frm MaxBandwidth passed by the config handler
    //

    RtlZeroMemory(&TcGenFlow,sizeof(TcGenFlow));

    UL_SET_FLOWSPEC(TcGenFlow,MaxBandwidth,MtuSize);

    //
    // Since we hold a spinlock inside the flow structure allocating from
    // NonPagedPool. We will have this allocation only for bt enabled sites.
    //

    pFlow = UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_TCI_FLOW,
                UL_TCI_FLOW_POOL_TAG
                );
    if( pFlow == NULL )
    {
        return NULL;
    }

    // Initialize the rest

    RtlZeroMemory( pFlow, sizeof(UL_TCI_FLOW) );

    pFlow->Signature = UL_TCI_FLOW_POOL_TAG;

    pFlow->GenFlow   = TcGenFlow;

    UlInitializeSpinLock( &pFlow->FilterListSpinLock, "FilterListSpinLock" );
    InitializeListHead( &pFlow->FilterList );

    pFlow->pConfigGroup = NULL;

    return pFlow;
}

/***************************************************************************++

Routine Description:

    UlpModifyFlow :

        Modify an existing flow by sending an IOCTL down to GPC. Basically
        what this function does is to provide an updated TC_GEN_FLOW field
        to GPC for an existing flow.

Arguments:

    PUL_TCI_INTERFACE - Required to get the interfaces friendly name.

    PUL_TCI_FLOW      - To get the GPC flow handle as well as to be able to
                        update the new flow parameters.

--***************************************************************************/

NTSTATUS
UlpModifyFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pFlow
    )
{
    PCF_INFO_QOS            Kflow;
    PGPC_MODIFY_CF_INFO_REQ pGpcReq;
    GPC_MODIFY_CF_INFO_RES  GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;

    IO_STATUS_BLOCK         IoStatusBlock;
    NTSTATUS                Status;

    //
    // Sanity check
    //

    ASSERT(g_GpcClientHandle);
    ASSERT(IS_VALID_TCI_INTERFACE(pInterface));
    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    InBuffSize  = sizeof(GPC_MODIFY_CF_INFO_REQ) + sizeof(CF_INFO_QOS);
    OutBuffSize = sizeof(GPC_MODIFY_CF_INFO_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_MODIFY_CF_INFO_REQ,
                    sizeof(CF_INFO_QOS),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory(pGpcReq, InBuffSize);
    RtlZeroMemory(&GpcRes, OutBuffSize);

    pGpcReq->ClientHandle    = g_GpcClientHandle;
    pGpcReq->GpcCfInfoHandle = pFlow->FlowHandle;
    pGpcReq->CfInfoSize      = sizeof(CF_INFO_QOS);

    Kflow = (PCF_INFO_QOS)&pGpcReq->CfInfo;
    Kflow->InstanceNameLength = (USHORT) pInterface->NameLength;

    RtlCopyMemory(Kflow->InstanceName,
                  pInterface->Name,
                  pInterface->NameLength* sizeof(WCHAR));

    RtlCopyMemory(&Kflow->GenFlow,
                  &pFlow->GenFlow,
                  sizeof(TC_GEN_FLOW));

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_MODIFY_CF_INFO,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );
    if ( NT_SUCCESS(Status) )
    {
        UlTrace( TC, ("Ul!UlpModifyFlow: flow %p modified on interface %p \n",
            pFlow,
            pInterface
            ));
    }
    else
    {
        UlTrace( TC, ("Ul!UlpModifyFlow: FAILURE %08lx for GpcClient %u\n",
                        Status,
                        g_GpcClientHandle
                        ));
    }

    UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpAddFlow :

        Add a flow on existing QoS Enabled interface

Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpAddFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pGenericFlow,
    OUT PHANDLE             pHandle
    )
{
    NTSTATUS                Status;
    PCF_INFO_QOS            Kflow;
    PGPC_ADD_CF_INFO_REQ    pGpcReq;
    GPC_ADD_CF_INFO_RES     GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    IO_STATUS_BLOCK         IoStatusBlock;

    //
    // Find the interface from handle
    //

    ASSERT(g_GpcClientHandle);

    InBuffSize  = sizeof(GPC_ADD_CF_INFO_REQ) + sizeof(CF_INFO_QOS);
    OutBuffSize = sizeof(GPC_ADD_CF_INFO_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_ADD_CF_INFO_REQ,
                    sizeof(CF_INFO_QOS),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory( pGpcReq, InBuffSize);
    RtlZeroMemory( &GpcRes, OutBuffSize);

    pGpcReq->ClientHandle       = g_GpcClientHandle;
    //pGpcReq->ClientCfInfoContext= GPC_CF_QOS;         // ?? Not sure about this
    pGpcReq->CfInfoSize         = sizeof( CF_INFO_QOS);

    Kflow = (PCF_INFO_QOS)&pGpcReq->CfInfo;
    Kflow->InstanceNameLength = (USHORT) pInterface->NameLength;

    RtlCopyMemory(  Kflow->InstanceName,
                    pInterface->Name,
                    pInterface->NameLength* sizeof(WCHAR)
                    );

    RtlCopyMemory(  &Kflow->GenFlow,
                    &pGenericFlow->GenFlow,
                    sizeof(TC_GEN_FLOW)
                    );

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            IOCTL_GPC_ADD_CF_INFO,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (NT_SUCCESS(Status))
    {
        (*pHandle) = (HANDLE) GpcRes.GpcCfInfoHandle;

        UlTrace( TC, ("Ul!UlpAddFlow: a new flow added %p on interface %p \n",
            pGenericFlow,
            pInterface
            ));
    }
    else
    {
        UlTrace( TC, ("Ul!UlpAddFlow: FAILURE %08lx for GpcClient %u\n",
                        Status,
                        g_GpcClientHandle
                        ));
    }

    UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcAddFlowsForSite :

    Add a flow on existing QoS Enabled interface

Arguments:

    pConfigGroup    - The config group of the site
    MaxBandwidth    - The Max bandwidth we are going to enforce by a FlowSpec
                      in B/s

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlTcAddFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup,
    IN HTTP_BANDWIDTH_LIMIT     MaxBandwidth
    )
{
    NTSTATUS                    Status;
    PLIST_ENTRY                 pInterfaceEntry;
    PUL_TCI_INTERFACE           pInterface;
    PUL_TCI_FLOW                pFlow;

    //
    // Sanity check first
    //

    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    UlTrace(TC,("Ul!UlTcAddFlowsForSite: For cgroup %p BWT %d KB/s\n",
                 pConfigGroup,
                 MaxBandwidth
                 ));

    //
    // Visit each interface and add a flow for this site. Following lock also
    // protects the FlowListHead of the ConfigGroup object. We only change it
    // when we acquire this lock here. Or when removing the site's flows.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    // TODO: Remember this cgroup incase interface goes up/down later on,we can still
    // TODO: recover and reinstall the flows of the cgroup properly.

    // InsertTailList(&g_TcCGroupListHead, &pConfigGroup->Linkage );

    // Proceed and add the flows to the inetrfaces

    pInterfaceEntry = g_TciIfcListHead.Flink;
    while ( pInterfaceEntry != &g_TciIfcListHead )
    {
        pInterface = CONTAINING_RECORD(
                            pInterfaceEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );
        //
        // Allocate a flow sturcture
        //

        pFlow = UlpTcAllocateFlow( MaxBandwidth, pInterface->MTUSize );
        if ( pFlow == NULL )
        {
            UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

            return STATUS_NO_MEMORY;
        }

        //
        // Add the flow by making a TC call down to gpc
        //

        Status = UlpAddFlow( pInterface,
                             pFlow,
                            &pFlow->FlowHandle
                             );

        if (!NT_SUCCESS(Status))
        {
            UlTrace( TC, ("Ul!UlTcAddFlowsForSite: FAILURE %08lx \n", Status ));

            UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

            UL_FREE_POOL_WITH_SIG( pFlow, UL_TCI_FLOW_POOL_TAG );

            return Status;
        }

        //
        // Proceed with further initialization as we have successfully installed
        // the flow. First link the flow back to its owner interface.
        //

        pFlow->pInterface = pInterface;

        //
        // Add this to the interface's flowlist as well
        //

        InsertHeadList( &pInterface->FlowList, &pFlow->Linkage );
        pInterface->FlowListSize += 1;

        //
        // Also add this to the cgroup's flowlist. Set the cgroup pointer.
        // Do not bump up the cgroup refcount. Otherwise cgroup cannot be
        // cleaned up until Tc terminates. And flows cannot be removed un
        // till termination.
        //

        InsertHeadList( &pConfigGroup->FlowListHead, &pFlow->Siblings );
        pFlow->pConfigGroup = pConfigGroup;

        UlTrace( TC,
            ("Ul!UlTcAddFlowsForSite: Added the pFlow %p on pInterface %p\n",
              pFlow,
              pInterface
              ));

        UL_DUMP_TC_FLOW(pFlow);

        //
        // Proceed to the next interface
        //

        pInterfaceEntry = pInterfaceEntry->Flink;
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace( TC, ("Ul!UlTcAddFlowsForSite: SUCCESS \n" ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcModifyFlowsForSite :

        This function will be called when there's a cgroup change happening for
        the site's bandwidth throttling settings.

        Its caller responsiblity to remember the new settings in the cgroup.

        We will update the FlowSpec on the existing flows

Arguments:

    PUL_CONFIG_GROUP_OBJECT - Pointer to the cgroup of the site.

    HTTP_BANDWIDTH_LIMIT    - The new bandwidth throttling setting
                              in B/s

--***************************************************************************/

NTSTATUS
UlTcModifyFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup,
    IN HTTP_BANDWIDTH_LIMIT     NewBandwidth
    )
{
    NTSTATUS                    Status;
    PLIST_ENTRY                 pFlowEntry;
    PUL_TCI_FLOW                pFlow;
    HTTP_BANDWIDTH_LIMIT        OldBandwidth;

    //
    // Sanity check
    //

    Status = STATUS_SUCCESS;

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    //
    // We do not handle the remove case. it should be handled by cgroup
    //

    ASSERT(NewBandwidth != HTTP_LIMIT_INFINITE);

    UlTrace(TC,("Ul!UlTcModifyFlowsForSite: For cgroup %p.\n",pConfigGroup));

    //
    // Modify the flow list in the cgroup as it shows the flows of this site
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    pFlowEntry = pConfigGroup->FlowListHead.Flink;
    while ( pFlowEntry != &pConfigGroup->FlowListHead )
    {
        pFlow = CONTAINING_RECORD(
                            pFlowEntry,
                            UL_TCI_FLOW,
                            Siblings
                            );

        // Yet another sanity check

        ASSERT(IS_VALID_CONFIG_GROUP(pFlow->pConfigGroup));
        ASSERT(pConfigGroup == pFlow->pConfigGroup);

        // Overwrite the new bandwidth but remember the old

        OldBandwidth = UL_GET_BW_FRM_FLOWSPEC(pFlow->GenFlow);

        UL_SET_FLOWSPEC(pFlow->GenFlow,NewBandwidth,pFlow->pInterface->MTUSize);

        Status = UlpModifyFlow(pFlow->pInterface, pFlow);

        if (!NT_SUCCESS(Status))
        {
            // Whine about it, but still continue

            UlTrace( TC, ("Ul!UlTcModifyFlowsForSite: FAILURE %08lx \n", Status ));

            // Restore the original flowspec back

            UL_SET_FLOWSPEC(pFlow->GenFlow,OldBandwidth,pFlow->pInterface->MTUSize);
        }

        UL_DUMP_TC_FLOW(pFlow);

        // Proceed to the next flow

        pFlowEntry = pFlowEntry->Flink;
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace( TC, ("Ul!UlTcModifyFlowsForSite: Frm %d KB/s To %d KB/s done.\n",
                   OldBandwidth,
                   NewBandwidth
                   ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcRemoveFlowsForSite :

        Add a flow on existing QoS Enabled interface

Arguments:


Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlTcRemoveFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup
    )
{
    NTSTATUS                    Status;
    PLIST_ENTRY                 pFlowEntry;
    PUL_TCI_FLOW                pFlow;

    //
    // Sanity check first
    //

    Status = STATUS_SUCCESS;

    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    UlTrace(TC,("Ul!UlTcRemoveFlowsForSite: For cgroup %p\n", pConfigGroup));

    //
    // Remove frm the cgroup list and remove frm the interface list
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    while (!IsListEmpty(&pConfigGroup->FlowListHead))
    {
        pFlowEntry = pConfigGroup->FlowListHead.Flink;

        pFlow = CONTAINING_RECORD(
                            pFlowEntry,
                            UL_TCI_FLOW,
                            Siblings
                            );

        // Yet another sanity check

        ASSERT(pConfigGroup == pFlow->pConfigGroup);
        ASSERT(IS_VALID_CONFIG_GROUP(pFlow->pConfigGroup));

        // Remove frm cgroup's flowlist and release our reference

        RemoveEntryList(&pFlow->Siblings);
        pFlow->Siblings.Flink = pFlow->Siblings.Blink = NULL;

        pFlow->pConfigGroup = NULL;

        // Now frm interface list. This will also make the TC call

        Status = UlpTcDeleteFlow(pFlow);
        ASSERT(NT_SUCCESS(Status));
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace(TC,("Ul!UlTcRemoveFlowsForSite: The cgroup %p 's flows are removed.\n",
                 pConfigGroup
                 ));

    return Status;
}

/***************************************************************************++

Routine Description:

    To see whether packet scheduler is installed or not. We also bail
    out if we weren't able to initialize properly.
    TODO we might want to handle the change (PSched installed later) 
    on-the-fly w/o requiring driver to be restarted.

--***************************************************************************/

BOOLEAN
UlTcPSchedInstalled(
    VOID
    )
{
    return (g_InitTciCalled && g_PSchedInstalled);
}

/***************************************************************************++

Routine Description:

    UlTcGlobalThrottlingEnabled :

        Will return TRUE if global bandwidth throttling is enabled in TC.
        Its enabled when global flows are installed and TC is initialized
        otherwise disabled.

        Make sure that if !UlTcPSchedInstalled() then Global throttling is
        always disabled.

--***************************************************************************/

__inline BOOLEAN
UlTcGlobalThrottlingEnabled(
    VOID
    )
{
    return (UL_IS_GLOBAL_THROTTLING_ENABLED());
}

/***************************************************************************++

Routine Description:

    UlTcAddGlobalFlows :

        Visits and creates the global flow on each interface

Arguments:

    HTTP_BANDWIDTH_LIMIT - The bandwidth throttling limit in KB/s

--***************************************************************************/

NTSTATUS
UlTcAddGlobalFlows(
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth
    )
{
    NTSTATUS                Status;

    PLIST_ENTRY             pInterfaceEntry;
    PUL_TCI_INTERFACE       pInterface;

    PUL_TCI_FLOW            pFlow;
    TC_GEN_FLOW             TcGenFlow;

    //
    // Sanity Check
    //

    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    UlTrace(TC,("Ul!UlTcAddGlobalFlows: Installing for %d KB/s\n", MaxBandwidth));

    //
    // To ensure the new filters can get attached to the global flows
    //

    UL_ENABLE_GLOBAL_THROTTLING();

    //
    // Visit each interface and add a global flow for this site
    // Acquire Exclusive because we will add a flow to the list
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    pInterfaceEntry = g_TciIfcListHead.Flink;
    while ( pInterfaceEntry != &g_TciIfcListHead )
    {
        pInterface = CONTAINING_RECORD(
                            pInterfaceEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );

        //
        // Nobody should try to add a global flow when there's already one
        //

        ASSERT(pInterface->pGlobalFlow == NULL);

        //
        // Allocate a flow structure
        //

        pFlow = UlpTcAllocateFlow( MaxBandwidth, pInterface->MTUSize );
        if ( pFlow == NULL )
        {
            UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

            return STATUS_NO_MEMORY;
        }

        //
        // Add the flow by making a TC call down to gpc
        //

        Status = UlpAddFlow( pInterface,
                             pFlow,
                            &pFlow->FlowHandle
                             );

        if (!NT_SUCCESS(Status))
        {
            UlTrace( TC, ("Ul!UlTcAddGlobalFlows: FAILURE %08lx \n", Status ));

            UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

            UL_FREE_POOL_WITH_SIG( pFlow, UL_TCI_FLOW_POOL_TAG );

            return Status;
        }

        //
        // Proceed with further initialization as we have successfully installed
        // the flow. First link the flow back to its owner interface and remeber
        // this was a global flow for the interface. Make sure that the   config
        // group pointer is null for the global flows.
        //

        pFlow->pInterface = pInterface;
        pFlow->pConfigGroup = NULL;
        pInterface->pGlobalFlow = pFlow;

        //
        // Add this to the interface's flowlist as well
        //

        InsertHeadList( &pInterface->FlowList, &pFlow->Linkage );
        pInterface->FlowListSize += 1;

        UlTrace( TC,
            ("Ul!UlTcAddGlobalFlows: Added the pGlobalFlow %p on pInterface %p\n",
              pFlow,
              pInterface
              ));

        UL_DUMP_TC_FLOW(pFlow);

        //
        // search through next interface
        //

        pInterfaceEntry = pInterfaceEntry->Flink;
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace( TC, ("Ul!UlTcAddGlobalFlows: Installed.\n" ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcModifyGlobalFlows :

        This function will be called when there's a config channel change
        happening for the global bandwidth throttling setting.

        Its caller responsiblity to remember the new settings in the control
        channel.

        We will simply update the FlowSpec on the existing global flows.

Arguments:

    HTTP_BANDWIDTH_LIMIT    - The new bandwidth throttling setting
                              in B/s

--***************************************************************************/

NTSTATUS
UlTcModifyGlobalFlows(
    IN HTTP_BANDWIDTH_LIMIT     NewBandwidth
    )
{
    NTSTATUS                    Status;
    PLIST_ENTRY                 pInterfaceEntry;
    PUL_TCI_INTERFACE           pInterface;
    PUL_TCI_FLOW                pFlow;
    HTTP_BANDWIDTH_LIMIT        OldBandwidth;

    //
    // Sanity check
    //

    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    //
    // We do not handle the remove case.It should be handled by control channel
    //

    ASSERT(NewBandwidth != HTTP_LIMIT_INFINITE);

    UlTrace(TC,("Ul!UlTcModifyGlobalFlows: to %d KB/s \n",NewBandwidth));

    //
    // Modify the global flows of all the interfaces
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    pInterfaceEntry = g_TciIfcListHead.Flink;
    while ( pInterfaceEntry != &g_TciIfcListHead )
    {
        pInterface = CONTAINING_RECORD(
                            pInterfaceEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );

        ASSERT(pInterface->pGlobalFlow != NULL);

        pFlow = pInterface->pGlobalFlow;

        // Overwrite the old bandwidth limit but remember it

        OldBandwidth = UL_GET_BW_FRM_FLOWSPEC(pFlow->GenFlow);

        UL_SET_FLOWSPEC(pFlow->GenFlow, NewBandwidth,pFlow->pInterface->MTUSize);

        // Pass it down to low level modifier

        Status = UlpModifyFlow(pInterface, pFlow);

        if (!NT_SUCCESS(Status))
        {
            // Whine about it, but still continue

            UlTrace(TC,("Ul!UlTcModifyGlobalFlows: FAILURE %08lx \n",Status));

            // Restore the original flowspec back

            UL_SET_FLOWSPEC(pFlow->GenFlow,OldBandwidth,pFlow->pInterface->MTUSize);
        }

        UL_DUMP_TC_FLOW(pFlow);

        // Proceed to the next interface's global_flow

        pInterfaceEntry = pInterfaceEntry->Flink;
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace( TC, ("Ul!UlTcModifyGlobalFlows: Modified.\n" ));

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcRemoveGlobalFlows :

        Add a flow on existing QoS Enabled interface

--***************************************************************************/

NTSTATUS
UlTcRemoveGlobalFlows(
    VOID
    )
{
    NTSTATUS            Status;
    PLIST_ENTRY         pInterfaceEntry;
    PUL_TCI_INTERFACE   pInterface;
    PUL_TCI_FLOW        pFlow;

    //
    // Sanity check first
    //

    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    UlTrace(TC,("Ul!UlTcRemoveGlobalFlows: ...\n"));

    //
    // To ensure no new filters can get attached to the global flows
    //

    UL_DISABLE_GLOBAL_THROTTLING();

    //
    // Remove each interface's global flow
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->TciIfcResource, TRUE);

    pInterfaceEntry = g_TciIfcListHead.Flink;
    while ( pInterfaceEntry != &g_TciIfcListHead )
    {
        pInterface = CONTAINING_RECORD(
                            pInterfaceEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );

        pFlow = pInterface->pGlobalFlow;

        if (pFlow)
        {
            ASSERT(IS_VALID_TCI_FLOW(pFlow));

            // Remove from interface list and make the TC call down.

            Status = UlpTcDeleteFlow(pFlow);
            ASSERT(NT_SUCCESS(Status));

            // No more global flow

            pInterface->pGlobalFlow = NULL;
        }

        // Goto the next interface on the list

        pInterfaceEntry = pInterfaceEntry->Flink;
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    UlTrace(TC,("Ul!UlTcRemoveGlobalFlows: Flows are removed.\n" ));

    return Status;
}


/***************************************************************************++

Routine Description:

    UlTcAddFilter :

            //
            // There are two possibilities. The request  could be served frm
            // cache or can be routed to the user. In  either case we need a
            // flow installed if the BW is enabled for  this request's  site
            // and there's no filter installed for this  connection yet.  We
            // will remove the filter as soon as the connection dropped. But
            // yes there's always a but,if the client is attempting to  make
            // requests to different sites using the same connection then we
            // need to drop the  filter frm the old site and move it to  the
            // newly requested site. This is a rare case but lets handle  it
            // anyway.
            //

        It's callers responsibility to ensure proper removal of the filter,
        after it's done.

        Algorithm:

        1. Find the flow from the flow list of cgroup (or from global flows)
        2. Add filter to that flow

Arguments:

    pHttpConnection - required - Filter will be attached for this connection
    pCgroup         - optional - NULL means add to the global flow

Return Values:

    STATUS_INVALID_DEVICE_REQUEST- If TC not initialized
    STATUS_NOT_SUPPORTED         - For attempts on Local Loopback
    STATUS_OBJECT_NAME_NOT_FOUND - If flow has not been found for the cgroup
    STATUS_SUCCESS               - In other cases

--***************************************************************************/

NTSTATUS
UlTcAddFilter(
    IN  PUL_HTTP_CONNECTION pHttpConnection,
    IN  PUL_CONFIG_GROUP_OBJECT pCgroup OPTIONAL
    )
{
    NTSTATUS            Status;
    ULONG               IpAddress;
    ULONG               IpAddressTemp;
    TC_GEN_FILTER       TcGenericFilter;
    PUL_TCI_FLOW        pFlow;
    PUL_TCI_INTERFACE   pInterface;
    IP_PATTERN          Pattern;
    IP_PATTERN          Mask;

    PUL_TCI_FILTER      pFilter;
    PUL_CONFIG_GROUP_OBJECT pOldCgroup;

    //
    // A lot of sanity & early checks
    //

    Status = STATUS_SUCCESS;

    ASSERT(UL_IS_VALID_HTTP_CONNECTION(pHttpConnection));

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    //
    // If BWT or GBWT disabled then just bail out.
    //

    if ((pCgroup == NULL && !UlTcGlobalThrottlingEnabled()) ||
        (pCgroup != NULL && (pCgroup->MaxBandwidth.Flags.Present == 0 ||
         pCgroup->MaxBandwidth.MaxBandwidth == HTTP_LIMIT_INFINITE))
       )
    {
        return Status;
    }

    //
    // We need the local & remote IPs. Connection keeps the ip and port in
    // host order, but we need in network order here. To be competible with
    // the rest of the BWT code. Convert it back.
    //

    IpAddress = SWAP_LONG( pHttpConnection->pConnection->LocalAddress );

    IpAddressTemp = pHttpConnection->pConnection->LocalAddress;
    UlTrace(TC,("Ul!UlTcAddFilter: Local %d.%d.%d.%d:%d\n",
            (UCHAR)(IpAddressTemp >> 24),
            (UCHAR)(IpAddressTemp >> 16),
            (UCHAR)(IpAddressTemp >> 8),
            (UCHAR)(IpAddressTemp >> 0),
             pHttpConnection->pConnection->LocalPort
             ));

    IpAddressTemp = pHttpConnection->pConnection->RemoteAddress;
    UlTrace(TC,("Ul!UlTcAddFilter: Remote %d.%d.%d.%d:%d\n",
            (UCHAR)(IpAddressTemp >> 24),
            (UCHAR)(IpAddressTemp >> 16),
            (UCHAR)(IpAddressTemp >> 8),
            (UCHAR)(IpAddressTemp >> 0),
             pHttpConnection->pConnection->RemotePort
             ));

    if ( IpAddress == LOOPBACK_ADDR )
    {
        //
        // Make sure that new Filter is not trying to go the Local_loopback
        // if that is the case skip this. There's no qos on local_loopbacks
        // PSched doesn't receive any packets for local_loopback address.
        //

        UlTrace( TC,
            ("Ul!UlTcAddFilter: LocalLoopback not supported."
             "Not adding filter for pHttpConnection %p\n",
              pHttpConnection
              ));

        return STATUS_NOT_SUPPORTED;
    }

    //
    // At this point we will be refering to the flows & filters
    // in our list therefore we need to acquire the lock
    //

    UlAcquireResourceShared(&g_pUlNonpagedData->TciIfcResource, TRUE);

    // If connection already has a filter attached

    if (pHttpConnection->pFlow)
    {
        ASSERT(IS_VALID_TCI_FLOW(pHttpConnection->pFlow));
        ASSERT(IS_VALID_TCI_FILTER(pHttpConnection->pFilter));

        // To see if we have a new cgroup, if that's the case then
        // we have to go to a new flow. If pCgroup is null we will
        // still skip adding the same global filter again

        pOldCgroup = pHttpConnection->pFlow->pConfigGroup;
        if (pOldCgroup == pCgroup)
        {
           // No need to add a new filter we are done

           UlTrace( TC,
                ("Ul!UlTcAddFilter: Skipping same pFlow %p & pFilter %p already exist\n",
                  pHttpConnection->pFlow,
                  pHttpConnection->pFilter,
                  pHttpConnection
                ));
           goto end;
        }
        else
        {
            //
            // If there was another filter before and this newly coming  request
            // is being going to a different site/flow. Then move the filter frm
            // old one to the new flow.
            //

            UlpTcDeleteFilter(pHttpConnection->pFlow, pHttpConnection->pFilter);
        }
    }

    //
    // Search through the cgroup's flowlist to find the one we need. The one
    // on the interface we want.
    //

    pFlow = UlpFindFlow( pCgroup, IpAddress );
    if ( pFlow == NULL )
    {
        IpAddressTemp = SWAP_LONG(IpAddress);

        UlTrace( TC,
            ("Ul!UlTcAddFilter: Unable to find interface (%x) %d.%d.%d.%d \n",
            IpAddress,
            (UCHAR)(IpAddressTemp >> 24),
            (UCHAR)(IpAddressTemp >> 16),
            (UCHAR)(IpAddressTemp >> 8),
            (UCHAR)(IpAddressTemp >> 0)
            ));

        // It's possible that we might not find out a flow
        // after all the interfaces went down, even though
        // qos configured on the cgroup.

        // ASSERT(FALSE);

        Status = STATUS_OBJECT_NAME_NOT_FOUND;
        goto end;
    }

    // Some more initialization

    pFilter = NULL;
    pInterface = pFlow->pInterface;

    RtlZeroMemory( &Pattern, sizeof(IP_PATTERN) );
    RtlZeroMemory( &Mask,    sizeof(IP_PATTERN) );

    //
    // Everything is fine.
    // Now setup the filter with proper pattern & mask
    //

    Pattern.SrcAddr = SWAP_LONG(pHttpConnection->pConnection->LocalAddress);
    Pattern.S_un.S_un_ports.s_srcport = SWAP_SHORT(pHttpConnection->pConnection->LocalPort);

    Pattern.DstAddr = SWAP_LONG(pHttpConnection->pConnection->RemoteAddress);
    Pattern.S_un.S_un_ports.s_dstport = SWAP_SHORT(pHttpConnection->pConnection->RemotePort);

    Pattern.ProtocolId = IPPROTO_TCP;

    /* Mask */

    RtlFillMemory(&Mask, sizeof(IP_PATTERN), 0xff);

    //Mask.SrcAddr = 0x00000000;
    //Mask.S_un.S_un_ports.s_srcport = 0;                 // WHY ??
    //Mask.DstAddr = 0x00000000;
    //Mask.S_un.S_un_ports.s_dstport = 0;                 // WHY ??

    TcGenericFilter.AddressType = NDIS_PROTOCOL_ID_TCP_IP;
    TcGenericFilter.PatternSize = sizeof( IP_PATTERN );
    TcGenericFilter.Pattern     = &Pattern;
    TcGenericFilter.Mask        = &Mask;

    Status = UlpTcAddFilter(
                    pFlow,
                    &TcGenericFilter,
                    &pFilter
                    );
    if (!NT_SUCCESS(Status))
    {
       UlTrace( TC,
            ("Ul!UlTcAddFilter: Unable to add filter for;\n"
             "\t pInterface     : %p\n"
             "\t pFlow          : %p\n",
              pInterface,
              pFlow
              ));
        goto end;
    }

    //
    //  Update the connection's pointers here.
    //

    pHttpConnection->pFlow   = pFlow;
    pHttpConnection->pFilter = pFilter;

    pHttpConnection->BandwidthThrottlingEnabled = 1;

    //
    // Remember the connection for cleanup. If flow & filter get
    // removed aynscly when connection still pointing to them
    // we can go and null the connection's private pointers as
    // well
    //

    pFilter->pHttpConnection = pHttpConnection;

    //
    // Sweet smell of success !
    //

    UlTrace(TC,
            ("Ul!UlTcAddFilter: Success for;\n"
             "\t pInterface     : %p\n"
             "\t pFlow          : %p\n",
              pInterface,
              pFlow
              ));

    UL_DUMP_TC_FILTER(pFilter);

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlTcAddFilter: FAILURE %08lx \n", Status ));
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);
    return Status;
}



/***************************************************************************++

Routine Description:

    UlpTcAddFilter :

        Add a filter on existing flow

Arguments:



Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcAddFilter(
    IN   PUL_TCI_FLOW       pFlow,
    IN   PTC_GEN_FILTER     pGenericFilter,
    OUT  PUL_TCI_FILTER     *ppFilter
    )
{
    NTSTATUS                Status;
    PGPC_ADD_PATTERN_REQ    pGpcReq;
    GPC_ADD_PATTERN_RES     GpcRes;
    ULONG                   InBuffSize;
    ULONG                   OutBuffSize;
    ULONG                   PatternSize;

    IO_STATUS_BLOCK         IoStatBlock;
    ULONG                   IfIndex;
    PUCHAR                  pTemp;
    PIP_PATTERN             pIpPattern;

    HANDLE                  RetHandle;
    PUL_TCI_FILTER          pFilter;

    //
    // Sanity check
    //

    Status  = STATUS_SUCCESS;
    pGpcReq = NULL;

    if ( !pGenericFilter || !pFlow || !g_GpcClientHandle )
    {
        return STATUS_INVALID_PARAMETER;
    }

    // Allocate a space for the filter

    pFilter = UL_ALLOCATE_STRUCT(
                NonPagedPool,
                UL_TCI_FILTER,
                UL_TCI_FILTER_POOL_TAG
                );
    if ( pFilter == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }
    pFilter->Signature = UL_TCI_FILTER_POOL_TAG;

    // Buffer monkeying

    PatternSize = sizeof(IP_PATTERN);
    InBuffSize  = sizeof(GPC_ADD_PATTERN_REQ) + (2 * PatternSize);
    OutBuffSize = sizeof(GPC_ADD_PATTERN_RES);

    pGpcReq = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    PagedPool,
                    GPC_ADD_PATTERN_REQ,
                    (2 * PatternSize),
                    UL_TCI_GENERIC_POOL_TAG
                    );
    if (pGpcReq == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory( pGpcReq, InBuffSize);
    RtlZeroMemory( &GpcRes, OutBuffSize);

    pGpcReq->ClientHandle            =   g_GpcClientHandle;
    pGpcReq->GpcCfInfoHandle         =   pFlow->FlowHandle;
    pGpcReq->PatternSize             =   PatternSize;
    pGpcReq->ProtocolTemplate        =   GPC_PROTOCOL_TEMPLATE_IP;

    pTemp = (PUCHAR) &pGpcReq->PatternAndMask;

    // Fill in the IP Pattern first

    RtlCopyMemory( pTemp, pGenericFilter->Pattern, PatternSize );
    pIpPattern = (PIP_PATTERN) pTemp;

    //
    // According to QoS Tc.dll ;
    // This is a work around so that TCPIP wil not to find the index/link
    // for ICMP/IGMP packets
    //

    pIpPattern->Reserved1    = pFlow->pInterface->IfIndex;
    pIpPattern->Reserved2    = pFlow->pInterface->SpecificLinkCtx;
    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0;

    // Fill in the mask

    pTemp += PatternSize;

    RtlCopyMemory( pTemp, pGenericFilter->Mask, PatternSize );

    pIpPattern = (PIP_PATTERN) pTemp;

    pIpPattern->Reserved1 = pIpPattern->Reserved2 = 0xffffffff;
    pIpPattern->Reserved3[0] = pIpPattern->Reserved3[1] = pIpPattern->Reserved3[2] = 0xff;

    // Time to invoke Gpsy

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_ADD_PATTERN,
                            pGpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize);

    if (!NT_SUCCESS(Status))
        goto end;

    //
    // Insert the freshly created filter to flow
    //

    pFilter->FilterHandle = (HANDLE) GpcRes.GpcPatternHandle;

    UlpInsertFilterEntry( pFilter, pFlow );

    //
    // Success!
    //

    *ppFilter = pFilter;

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcAddFilter: FAILURE %08lx \n", Status ));

        // Cleanup filter only if we failed, otherwise it will go to
        // the filterlist of the flow.

        if (pFilter)
        {
            UL_FREE_POOL( pFilter, UL_TCI_FILTER_POOL_TAG );
        }
    }

    // Cleanup the temp Gpc buffer which we used to pass down filter info
    // to GPC. We don't need it anymore.

    if (pGpcReq)
    {
        UL_FREE_POOL( pGpcReq, UL_TCI_GENERIC_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlTcDeleteFilter :

        Connection only deletes the filter prior to deleting itself. Any
        operation initiated by the connection requires tc resource shared
        and none of those cause race condition.

        Anything other than this, such as flow & filter removal because of
        BW disabling on the site will acquire the lock exclusively. Hence
        the pFlow & pFilter are safe as long as we acquire the tc resource
        shared.

Arguments:

    connection object to get the flow & filter after we acquire the tc lock

--***************************************************************************/

NTSTATUS
UlTcDeleteFilter(
    IN  PUL_HTTP_CONNECTION pHttpConnection
    )
{
    NTSTATUS    Status;

    //
    // Sanity check
    //
    Status = STATUS_SUCCESS;

    //
    // If we have been called w/o being initialized
    //
    ASSERT(g_InitTciCalled);

    UlTrace(TC,("Ul!UlTcDeleteFilter: for connection %p\n", pHttpConnection));

    UlAcquireResourceShared(&g_pUlNonpagedData->TciIfcResource, TRUE);

    if (pHttpConnection->pFlow)
    {
        Status = UlpTcDeleteFilter(
                    pHttpConnection->pFlow,
                    pHttpConnection->pFilter
                    );
    }

    UlReleaseResource(&g_pUlNonpagedData->TciIfcResource);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRemoveFilter :

Arguments:

    flow & filter

--***************************************************************************/

NTSTATUS
UlpTcDeleteFilter(
    IN PUL_TCI_FLOW     pFlow,
    IN PUL_TCI_FILTER   pFilter
    )
{
    NTSTATUS            Status;
    HANDLE              FilterHandle;

    //
    // Sanity check
    //

    Status  = STATUS_SUCCESS;

    ASSERT(IS_VALID_TCI_FLOW(pFlow));
    ASSERT(IS_VALID_TCI_FILTER(pFilter));

    if (pFlow == NULL || pFilter == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    FilterHandle = pFilter->FilterHandle;

    pFilter->pHttpConnection->pFlow   = NULL;
    pFilter->pHttpConnection->pFilter = NULL;

    //
    // Now call the actual worker for us
    //

    UlpRemoveFilterEntry( pFilter, pFlow );

    Status = UlpTcDeleteGpcFilter( FilterHandle );

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcDeleteFilter: FAILURE %08lx \n", Status ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpTcRemoveFilter :

    This procedure builds up the structure necessary to delete a filter.
    It then calls a routine to pass this info to the GPC.

Arguments:

    FilterHandle - Handle of the filter to be deleted

--***************************************************************************/

NTSTATUS
UlpTcDeleteGpcFilter(
    IN  HANDLE                  FilterHandle
    )
{
    NTSTATUS                    Status;
    ULONG                       InBuffSize;
    ULONG                       OutBuffSize;
    GPC_REMOVE_PATTERN_REQ      GpcReq;
    GPC_REMOVE_PATTERN_RES      GpcRes;
    IO_STATUS_BLOCK             IoStatBlock;

    Status = STATUS_SUCCESS;

    ASSERT(FilterHandle != NULL);

    InBuffSize  = sizeof(GPC_REMOVE_PATTERN_REQ);
    OutBuffSize = sizeof(GPC_REMOVE_PATTERN_RES);

    GpcReq.ClientHandle     = g_GpcClientHandle;
    GpcReq.GpcPatternHandle = FilterHandle;

    ASSERT(g_GpcFileHandle);
    ASSERT(GpcReq.ClientHandle);
    ASSERT(GpcReq.GpcPatternHandle);

    Status = UlpTcDeviceControl( g_GpcFileHandle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatBlock,
                            IOCTL_GPC_REMOVE_PATTERN,
                            &GpcReq,
                            InBuffSize,
                            &GpcRes,
                            OutBuffSize
                            );

    if (!NT_SUCCESS(Status))
    {
        UlTrace( TC, ("Ul!UlpTcDeleteGpcFilter: FAILURE %08lx \n", Status ));
    }
    else
    {
        UlTrace( TC, ("Ul!UlpTcDeleteGpcFilter: FilterHandle %d deleted in TC as well.\n",
                   FilterHandle
                   ));
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    UlpInsertFilterEntry :

        Inserts a filter entry to the filter list of the flow.

Arguments:

    pEntry  - The filter entry to be added to the flow list

--***************************************************************************/

VOID
UlpInsertFilterEntry(
    IN      PUL_TCI_FILTER      pEntry,
    IN OUT  PUL_TCI_FLOW        pFlow
    )
{
    LONGLONG listSize;
    KIRQL    oldIrql;

    //
    // Sanity check.
    //

    ASSERT(pEntry);
    ASSERT(IS_VALID_TCI_FILTER(pEntry));
    ASSERT(pFlow);

    //
    // add to the list
    //

    UlAcquireSpinLock( &pFlow->FilterListSpinLock, &oldIrql );

    InsertHeadList( &pFlow->FilterList, &pEntry->Linkage );

    pFlow->FilterListSize += 1;

    listSize = pFlow->FilterListSize;

    UlReleaseSpinLock( &pFlow->FilterListSpinLock, oldIrql );

    ASSERT( listSize >= 1);
}

/***************************************************************************++

Routine Description:

    UlRemoveFilterEntry :

        Removes a filter entry frm the filter list of the flow.

Arguments:

    pEntry  - The filter entry to be removed from the flow list

--***************************************************************************/

VOID
UlpRemoveFilterEntry(
    IN      PUL_TCI_FILTER  pEntry,
    IN OUT  PUL_TCI_FLOW    pFlow
    )
{
    LONGLONG    listSize;
    KIRQL       oldIrql;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_TCI_FLOW(pFlow));
    ASSERT(IS_VALID_TCI_FILTER(pEntry));

    //
    // And the work
    //

    UlAcquireSpinLock( &pFlow->FilterListSpinLock, &oldIrql );

    RemoveEntryList( &pEntry->Linkage );

    pFlow->FilterListSize -= 1;
    listSize = pFlow->FilterListSize;

    pEntry->Linkage.Flink = pEntry->Linkage.Blink = NULL;

    UlReleaseSpinLock( &pFlow->FilterListSpinLock, oldIrql );

    ASSERT( listSize >= 0 );

    UlTrace( TC, ("Ul!UlpRemoveFilterEntry: FilterEntry %p removed/deleted.\n",
                    pEntry
                    ));

    UL_FREE_POOL_WITH_SIG( pEntry, UL_TCI_FILTER_POOL_TAG );
}

//
// Various helpful utilities for TCI module
//

/***************************************************************************++

Routine Description:

    UlpFindFlow :

        Find the flow in the cgroups flow list by looking at the IP address
        of each flows interface. The rule is cgroup will install one flow
        on each interface available.

        By having a flow list in each cgroup we are able to do a faster
        flow lookup. This is more scalable than doing a linear search for
        all the flows of the interface.

Arguments:

    pCGroup   - The config group of the site
    IpAddress - The address we are searching for

Return Value:

    NTSTATUS  - Completion status.

--***************************************************************************/

PUL_TCI_FLOW
UlpFindFlow(
    IN PUL_CONFIG_GROUP_OBJECT pCgroup OPTIONAL,
    IN ULONG IpAddress
    )
{
    PLIST_ENTRY         pFlowEntry;
    PUL_TCI_FLOW        pFlow;
    PLIST_ENTRY         pInterfaceEntry;
    PUL_TCI_INTERFACE   pInterface;

    //
    // Drop the lookup if the IP is zero. Basically by doing this
    // we are rejecting any filters attached to flows on interfaces
    // with zero IPs. The interface list may have interface(s)
    // with zero IPs. They are just idle until ip change notification
    // comes.
    //

    if (IpAddress == 0)
    {
        return NULL;
    }

    //
    // Otherwise proceed with the flow lookup on current interfaces.
    //

    if (pCgroup)
    {
        // Look in the cgroup's flows

        ASSERT(IS_VALID_CONFIG_GROUP(pCgroup));

        pFlowEntry = pCgroup->FlowListHead.Flink;
        while ( pFlowEntry != &pCgroup->FlowListHead )
        {
            pFlow = CONTAINING_RECORD(
                            pFlowEntry,
                            UL_TCI_FLOW,
                            Siblings
                            );

            if (pFlow->pInterface->IpAddr == IpAddress)
            {
                return pFlow;
            }

            pFlowEntry = pFlowEntry->Flink;
        }
    }
    else
    {
        // Or go through the interface list to find the global flow

        pInterfaceEntry = g_TciIfcListHead.Flink;
        while ( pInterfaceEntry != &g_TciIfcListHead )
        {
            pInterface = CONTAINING_RECORD(
                             pInterfaceEntry,
                             UL_TCI_INTERFACE,
                             Linkage
                             );

            if (pInterface->IpAddr == IpAddress)
            {
                return pInterface->pGlobalFlow;
            }

            pInterfaceEntry = pInterfaceEntry->Flink;
        }
    }

    return NULL;
}

/***************************************************************************++

Routine Description:

    UlpFindInterface :

        Find the interface in our global link list by looking at its IP

Arguments:

    IpAddr - The ip address to be find among the interfaces

Return Value:

    Pointer to interface if found or else null

--***************************************************************************/

PUL_TCI_INTERFACE
UlpFindInterface(
    IN ULONG  IpAddr
    )
{
    PLIST_ENTRY         pEntry;
    PUL_TCI_INTERFACE   pInterface;

    pEntry = g_TciIfcListHead.Flink;
    while ( pEntry != &g_TciIfcListHead )
    {
        pInterface = CONTAINING_RECORD(
                            pEntry,
                            UL_TCI_INTERFACE,
                            Linkage
                            );

        if ( pInterface->IpAddr == IpAddr )
        {
            return pInterface;
        }

        pEntry = pEntry->Flink;
    }

    return NULL;
}

/***************************************************************************++

Routine Description:

    UlpTcDeviceControl :


Arguments:

    As usual

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpTcDeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE                 ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK                pIoStatusBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           InBuffer,
    IN  ULONG                           InBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize
    )
{
    NTSTATUS    Status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    UlAttachToSystemProcess();

    Status = ZwDeviceIoControlFile(
                    FileHandle,                     // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    pIoStatusBlock,                 // IoStatusBlock
                    Ioctl,                          // IoControlCode
                    InBuffer,                       // InputBuffer
                    InBufferSize,                   // InputBufferLength
                    OutBuffer,                      // OutputBuffer
                    OutBufferSize                   // OutputBufferLength
                    );

    if (Status == STATUS_PENDING)
    {
        Status = ZwWaitForSingleObject(
                        FileHandle,                 // Handle
                        TRUE,                       // Alertable
                        NULL                        // Timeout
                        );

        Status = pIoStatusBlock->Status;
    }

    UlDetachFromSystemProcess();

    return Status;
}

/***************************************************************************++

Routine Description:

    UlDumpTCInterface :

        Helper utility to display interface content.

Arguments:

        PUL_TCI_INTERFACE   - TC Interface to be dumped

--***************************************************************************/

VOID
UlDumpTCInterface(
        IN PUL_TCI_INTERFACE   pTcIfc
        )
{
    ULONG  IpAddress;

    ASSERT(IS_VALID_TCI_INTERFACE(pTcIfc));

    IpAddress = SWAP_LONG(pTcIfc->IpAddr);

    UlTrace( TC,("Ul!UlDumpTCInterface: \n   pTcIfc @ %p\n"
                 "\t Signature           = %08lx \n",
                 pTcIfc, pTcIfc->Signature));

    UlTrace( TC,(
        "\t IsQoSEnabled:       = %u \n"
        "\t IpAddr:             = (%x) %d.%d.%d.%d \n"
        "\t IfIndex:            = %d \n"
        "\t SpecificLinkCtx:    = %d \n"
        "\t MTUSize:            = %d \n"
        "\t NameLength:         = %u \n"
        "\t Name:               = %ws \n"
        "\t InstanceIDLength:   = %u \n"
        "\t InstanceID:         = %ws \n"
        "\t pGlobalFlow         = %p \n"
        "\t FlowListSize:       = %d \n"
        "\t AddrListBytesCount: = %d \n"
        "\t pAddressListDesc:   = %p \n",
        pTcIfc->IsQoSEnabled,
        pTcIfc->IpAddr,
            (UCHAR)(IpAddress >> 24),
            (UCHAR)(IpAddress >> 16),
            (UCHAR)(IpAddress >> 8),
            (UCHAR)(IpAddress >> 0),
        pTcIfc->IfIndex,
        pTcIfc->SpecificLinkCtx,
        pTcIfc->MTUSize,
        pTcIfc->NameLength,
        pTcIfc->Name,
        pTcIfc->InstanceIDLength,
        pTcIfc->InstanceID,
        pTcIfc->pGlobalFlow,
        pTcIfc->FlowListSize,
        pTcIfc->AddrListBytesCount,
        pTcIfc->pAddressListDesc
        ));
}

/***************************************************************************++

Routine Description:

    UlDumpTCFlow :

        Helper utility to display interface content.

Arguments:

        PUL_TCI_FLOW   - TC Flow to be dumped

--***************************************************************************/

VOID
UlDumpTCFlow(
        IN PUL_TCI_FLOW   pFlow
        )
{
    ASSERT(IS_VALID_TCI_FLOW(pFlow));

    UlTrace( TC,
       ("Ul!UlDumpTCFlow: \n"
        "   pFlow @ %p\n"
        "\t Signature           = %08lx \n"
        "\t pInterface          @ %p \n"
        "\t FlowHandle          = %d \n"
        "\t GenFlow             @ %p \n"
        "\t FlowRate KB/s       = %d \n"
        "\t FilterListSize      = %I64d \n"
        "\t pConfigGroup        = %p \n"
        ,
        pFlow,
        pFlow->Signature,
        pFlow->pInterface,
        pFlow->FlowHandle,
        &pFlow->GenFlow,
        pFlow->GenFlow.SendingFlowspec.TokenRate / 1024,
        pFlow->FilterListSize,
        pFlow->pConfigGroup
        ));
}

/***************************************************************************++

Routine Description:

    UlDumpTCFilter :

        Helper utility to display filter structure content.

Arguments:

        PUL_TCI_FILTER   pFilter

--***************************************************************************/

VOID
UlDumpTCFilter(
        IN PUL_TCI_FILTER   pFilter
        )
{
    ASSERT(IS_VALID_TCI_FILTER(pFilter));

    UlTrace( TC,
       ("Ul!UlDumpTCFilter: \n"
        "   pFilter @ %p\n"
        "\t Signature           = %08lx \n"
        "\t pHttpConnection     = %p \n"
        "\t FilterHandle        = %d \n",
        pFilter,
        pFilter->Signature,
        pFilter->pHttpConnection,
        pFilter->FilterHandle
        ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ullog.cxx ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    ullog.cxx (UL IIS6 HIT Logging)

Abstract:

    This module implements the logging facilities
    for IIS6 including the NCSA, IIS and W3CE types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/


#include "precomp.h"
#include "iiscnfg.h"
#include "ullogp.h"

//
// Generic Private globals.
//

LIST_ENTRY      g_LogListHead       = {NULL,NULL};
LONG            g_LogListEntryCount = 0;
BOOLEAN         g_InitLogsCalled    = FALSE;
CHAR            g_GMTOffset[SIZE_OF_GMT_OFFSET+1];

BOOLEAN         g_UTF8Logging = FALSE;

//
// For Log Buffering
//
ULONG           g_AllocationGranularity = 0;
KTIMER          g_BufferTimer;
BOOLEAN         g_BufferTimerInitialized = FALSE;
UL_SPIN_LOCK    g_BufferTimerSpinLock;
KDPC            g_BufferTimerDpcObject;

//
// For Logging Date & Time caching
//
UL_LOG_DATE_AND_TIME_CACHE
                g_UlDateTimeCache[HttpLoggingTypeMaximum];
LARGE_INTEGER   g_UlLogSystemTime;
FAST_MUTEX      g_LogCacheFastMutex;

//
// For Log Cycling
//
KDPC            g_LogTimerDpcObject;
KTIMER          g_LogTimer;
BOOLEAN         g_LogTimerInitialized = FALSE;
BOOLEAN         g_LogTimerStarted     = FALSE;
BOOLEAN         g_BufferTimerStarted  = FALSE;

// This spinlock covers both g_BufferTimerStarted and
// g_LogTimerStarted variables

UL_SPIN_LOCK    g_LogTimerSpinLock;

//
// Used to wait for endpoints to close on shutdown
//

UL_SPIN_LOCK    g_BufferIoSpinLock;
BOOLEAN         g_BufferWaitingForIoComplete = FALSE;
KEVENT          g_BufferIoCompleteEvent;
ULONG           g_BufferIoCount = 0;

#ifdef ALLOC_PRAGMA

#pragma alloc_text( INIT, UlInitializeLogs )

#pragma alloc_text( PAGE, UlTerminateLogs )
#pragma alloc_text( PAGE, UlpGetGMTOffset )

#pragma alloc_text( PAGE, UlpRecycleLogFile )
#pragma alloc_text( PAGE, UlpGetLogFileLength )
#pragma alloc_text( PAGE, UlCreateLog )
#pragma alloc_text( PAGE, UlRemoveLogFileEntry )
#pragma alloc_text( PAGE, UlpConstructLogFileEntry )

#pragma alloc_text( PAGE, UlProbeLogData )
#pragma alloc_text( PAGE, UlAllocateLogDataBuffer )
#pragma alloc_text( PAGE, UlpConstructFileName )
#pragma alloc_text( PAGE, UlpUpdateLogFlags )
#pragma alloc_text( PAGE, UlpUpdateLogTruncateSize )
#pragma alloc_text( PAGE, UlpUpdatePeriod )
#pragma alloc_text( PAGE, UlpUpdateFormat )
#pragma alloc_text( PAGE, UlReConfigureLogEntry )
#pragma alloc_text( PAGE, UlpGrowLogEntry )

#pragma alloc_text( PAGE, UlLogTimerHandler )
#pragma alloc_text( PAGE, UlBufferTimerHandler )
#pragma alloc_text( PAGE, UlpCalculateTimeToExpire )
#pragma alloc_text( PAGE, UlpCreateSafeDirectory )
#pragma alloc_text( PAGE, UlpAppendW3CLogTitle )
#pragma alloc_text( PAGE, UlpWriteToLogFile )
#pragma alloc_text( PAGE, UlpFlushLogFile )
#pragma alloc_text( PAGE, UlCheckLogDirectory )
#pragma alloc_text( PAGE, UlSetUTF8Logging )

#pragma alloc_text( PAGE, UlCaptureLogFieldsW3C )
#pragma alloc_text( PAGE, UlCaptureLogFieldsNCSA )
#pragma alloc_text( PAGE, UlCaptureLogFieldsIIS )
#pragma alloc_text( PAGE, UlLogHttpCacheHit )
#pragma alloc_text( PAGE, UlLogHttpCacheHitWorker )
#pragma alloc_text( PAGE, UlLogHttpHit )

#pragma alloc_text( PAGE, UlpGenerateDateAndTimeFields )
#pragma alloc_text( PAGE, UlpGetDateTimeFields )

#pragma alloc_text( PAGE, UlpLogCloseHandle )
#pragma alloc_text( PAGE, UlpLogCloseHandleWorker )

#endif  // ALLOC_PRAGMA

#if 0

NOT PAGEABLE -- UlLogTimerDpcRoutine
NOT PAGEABLE -- UlpTerminateLogTimer
NOT PAGEABLE -- UlpInsertLogFileEntry
NOT PAGEABLE -- UlpSetLogTimer
NOT PAGEABLE -- UlpSetBufferTimer
NOT PAGEABLE -- UlBufferTimerDpcRoutine
NOT PAGEABLE -- UlpTerminateTimers
NOT PAGEABLE -- UlpInitializeTimers
NOT PAGEABLE -- UlWaitForBufferIoToComplete
NOT PAGEABLE -- UlpBufferFlushAPC
NOT PAGEABLE -- UlDestroyLogDataBuffer
NOT PAGEABLE -- UlDestroyLogDataBufferWorker

#endif

//
// Public functions.
//

/***************************************************************************++

Routine Description:

    UlInitializeLogs :

        Initialize the resource for log list synchronization

--***************************************************************************/

NTSTATUS
UlInitializeLogs (
    VOID
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    PAGED_CODE();

    ASSERT(!g_InitLogsCalled);

    if (!g_InitLogsCalled)
    {
        InitializeListHead(&g_LogListHead);

        Status = UlInitializeResource(
                        &g_pUlNonpagedData->LogListResource,
                        "LogListResource",
                        0,
                        UL_LOG_LIST_RESOURCE_TAG
                        );

        ASSERT(NT_SUCCESS(Status)); // the call always returns success

        if (!NT_SUCCESS(Status))
        {
            return Status;
        }

        g_InitLogsCalled = TRUE;

        UlpInitializeTimers();

        UlpInitializeLogCache();

        UlpGetGMTOffset();

        UlInitializeSpinLock( &g_BufferIoSpinLock, "g_BufferIoSpinLock" );

        //
        // Get the allocation granularity from the system
        // It will be used as log buffer size if there's no registry
        // overwrites.
        //

        UlpInitializeLogBufferGranularity();
        if (g_AllocationGranularity == 0)
        {
            g_AllocationGranularity =  DEFAULT_MAX_LOG_BUFFER_SIZE;
        }

        //
        // Overwrite the log buffer size with the above value
        // if registry parameter doesn't exist.
        //

        if (g_UlLogBufferSize == 0)
        {
            // No registry parameter available use the system granularity

            g_UlLogBufferSize = g_AllocationGranularity;
        }
        else
        {
            // Proceed with using the registry provided log buffer size

            UlTrace( LOGGING,
              ("Ul!UlInitializeLogs: Log buffer size %d from registry!\n",
                g_UlLogBufferSize
                ));
        }

    }

    return Status;
}


/***************************************************************************++

Routine Description:

    UlTerminateLogs :

        Deletes the resource for log list synchronization

--***************************************************************************/

VOID
UlTerminateLogs(
    VOID
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    if (g_InitLogsCalled)
    {
        ASSERT( IsListEmpty( &g_LogListHead )) ;

        //
        // Make sure terminate the log timer before
        // deleting the log list resource
        //

        UlpTerminateTimers();

        Status = UlDeleteResource(
                    &g_pUlNonpagedData->LogListResource
                    );

        ASSERT(NT_SUCCESS(Status));

        UlWaitForBufferIoToComplete();

        g_InitLogsCalled = FALSE;
    }
}


/***************************************************************************++

Routine Description:

    UlSetUTF8Logging :

        Sets the UTF8Logging on or off. Only once. Initially Utf8Logging is
        FALSE and it may only be set during the init once. Following possible
        changes won't be taken.

        ReConfiguration code is explicitly missing as WAS will anly call this
        only once (init) during the lifetime of the control channel.

--***************************************************************************/

NTSTATUS
UlSetUTF8Logging (
    IN BOOLEAN UTF8Logging
    )
{
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY pEntry;
    NTSTATUS Status;

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    //
    // Update & Reycle. Need to acquire the logging resource to prevent
    // further log hits to be written to file before we finish our
    // business. recycle is necessary because files will be renamed to
    // have prefix "u_" once we enabled the UTF8.
    //

    UlTrace(LOGGING,("Ul!UlSetUTF8Logging: UTF8Logging Old %d -> New %d\n",
                       g_UTF8Logging,UTF8Logging
                       ));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->LogListResource, TRUE);

    //
    // Drop the change if the setting is not changing.
    //

    if ( g_UTF8Logging == UTF8Logging )
    {
        goto end;
    }

    g_UTF8Logging = UTF8Logging;

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {
        pEntry = CONTAINING_RECORD(
                    pLink,
                    UL_LOG_FILE_ENTRY,
                    LogFileListEntry
                    );

        // TODO: Investigate whether we really need to acquire this or not.

        UlAcquireResourceExclusive(&pEntry->EntryResource, TRUE);

        SET_SEQUNCE_NUMBER_STALE(pEntry);

        Status = UlpRecycleLogFile(pEntry);
        ASSERT(NT_SUCCESS(Status));

        UlReleaseResource(&pEntry->EntryResource);
    }

end:
    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpGetLogFileLength :

        A utility to get the log file length, for a possible size check

Arguments:

    hFile - handle to file

Return Value:

    ULONG - the length of the file

--***************************************************************************/

ULONG
UlpGetLogFileLength(
   IN HANDLE                 hFile
   )
{
   NTSTATUS                  Status;
   FILE_STANDARD_INFORMATION StandardInformation;
   IO_STATUS_BLOCK           IoStatusBlock;
   ULONG                     Length;

   PAGED_CODE();

   Status = ZwQueryInformationFile(
                     hFile,
                     &IoStatusBlock,
                     &StandardInformation,
                     sizeof(StandardInformation),
                     FileStandardInformation
                     );
   ASSERT(NT_SUCCESS(Status));

   if (NT_SUCCESS(Status))
   {
      ASSERT(StandardInformation.EndOfFile.HighPart == 0);

      Length = StandardInformation.EndOfFile.LowPart;
   }
   else
   {
      Length = 0;
   }

   return Length;
}

/***************************************************************************++

Routine Description:

    Will allocate/fill up a new UNICODE_STRING to hold the directory name info
    based on the LocalDrive/UNC.

    It's caller's responsibility to cleanup the unicode buffer. If return code
    is SUCCESS otherwise no buffer get allocated at all.

Arguments:

    PWSTR - the directory name as it's received from the user.

--***************************************************************************/

NTSTATUS
UlpBuildLogDirectory(
    IN      PUNICODE_STRING pSrcDirName,
    IN OUT  PUNICODE_STRING pDstDirName
    )
{
    UNICODE_STRING  PathPrefix;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pSrcDirName);
    ASSERT(pDstDirName);

    UlTrace(LOGGING,(
             "Ul!UlpBuildLogDirectory: Directory %S,Length %d,MaxLength %d\n",
              pSrcDirName->Buffer,
              pSrcDirName->Length,
              pSrcDirName->MaximumLength
              ));

    // Allocate a buffer including the terminating NULL and the prefix.

    pDstDirName->Length = 0;
    pDstDirName->MaximumLength =
        pSrcDirName->Length + (UL_MAX_PATH_PREFIX_LENGTH+1) * sizeof(WCHAR);

    pDstDirName->Buffer =
        (PWSTR) UL_ALLOCATE_ARRAY(
            PagedPool,
            UCHAR,
            pDstDirName->MaximumLength,
            UL_CG_LOGDIR_POOL_TAG
            );
    if (pDstDirName->Buffer == NULL)
    {
        return  STATUS_NO_MEMORY;
    }

    ASSERT(pSrcDirName->Length > sizeof(WCHAR));

    // We store the dir name to cgroup as it is. But when we are constructing
    // the filename we skip the second backslash for the UNC shares and for
    // local dirs w/o the drive names.

    if (pSrcDirName->Buffer[0] == L'\\')
    {
        if (pSrcDirName->Buffer[1] == L'\\')
        {
            // UNC share: "\\alitudev\temp"
            RtlInitUnicodeString( &PathPrefix, UL_UNC_PATH_PREFIX );
        }
        else
        {
            // Local Directory name is missing the device i.e "\temp"
            // It should be fully qualified name.

            UL_FREE_POOL( pDstDirName->Buffer, UL_CG_LOGDIR_POOL_TAG );
            pDstDirName->Buffer = NULL;
            return STATUS_NOT_SUPPORTED;
        }

        RtlCopyUnicodeString( pDstDirName, &PathPrefix );
        RtlCopyMemory(
           &pDstDirName->Buffer[pDstDirName->Length/sizeof(WCHAR)],
           &pSrcDirName->Buffer[1],
            pSrcDirName->Length - sizeof(WCHAR)
        );
        pDstDirName->Length += (pSrcDirName->Length - sizeof(WCHAR));
        pDstDirName->Buffer[pDstDirName->Length/sizeof(WCHAR)] = UNICODE_NULL;

    }
    else
    {
        RtlInitUnicodeString( &PathPrefix, UL_LOCAL_PATH_PREFIX );
        RtlCopyUnicodeString( pDstDirName, &PathPrefix );
        RtlAppendUnicodeStringToString( pDstDirName, pSrcDirName );
    }

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    A utility to check to see if the directory name is correct or not.

Arguments:

    PWSTR - the directory name as it's received from the user.

--***************************************************************************/

NTSTATUS
UlCheckLogDirectory(
    IN  PUNICODE_STRING pDirName
    )
{
    NTSTATUS        Status;
    UNICODE_STRING  PathPrefix;
    UNICODE_STRING  DirectoryName;
    PWCHAR          pwsz;

    //
    // Sanity check.
    //

    PAGED_CODE();

    Status = UlpBuildLogDirectory( pDirName, &DirectoryName );
    if (!NT_SUCCESS(Status))
    {
        goto end;
    }

    //
    // Create/Open the director(ies) to see whether it's correct or not.
    //

    Status = UlpCreateSafeDirectory( &DirectoryName );

end:
    UlTrace(LOGGING,("Ul!UlCheckLogDirectory: [%S] -> [%S], Status %08lx\n",
             pDirName->Buffer,
             DirectoryName.Buffer,
             Status
             ));

    if (DirectoryName.Buffer)
    {
        UL_FREE_POOL( DirectoryName.Buffer, UL_CG_LOGDIR_POOL_TAG );
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Everytime Aynsc Write Io happens on Log Buffer This APC get called when
    completion happens and decrement the global Io Count. If shutting down
    we set the event.

    This is basically to prevent against shutting down before the Io Complete.

Arguments:

    None.

--***************************************************************************/

VOID
UlpBufferFlushAPC(
    IN PVOID            ApcContext,
    IN PIO_STATUS_BLOCK pIoStatusBlock,
    IN ULONG            Reserved
    )
{
    PUL_LOG_FILE_BUFFER pLogBuffer;
    ULONG               IoCount;
    KIRQL               OldIrql;

    UlTrace( LOGGING,("Ul!UlpBufferFlushAPC: entry %p and status %08lx Count %d\n",
             ApcContext,
             pIoStatusBlock->Status,
             (g_BufferIoCount - 1)
             ));

    //
    // Free the LogBuffer allocated for this write I/o.
    //

    pLogBuffer = (PUL_LOG_FILE_BUFFER) ApcContext;

    ASSERT(IS_VALID_LOG_FILE_BUFFER(pLogBuffer));

    UlPplFreeLogBuffer( pLogBuffer );

    //
    // Decrement the global outstanding i/o count.
    //

    IoCount = InterlockedDecrement((PLONG) &g_BufferIoCount);

    if ( IoCount == 0 )
    {
        UlAcquireSpinLock( &g_BufferIoSpinLock, &OldIrql );

        //
        // Set the event if we hit to zero and waiting for drain.
        //

        if ( g_BufferWaitingForIoComplete )
        {
            KeSetEvent( &g_BufferIoCompleteEvent, 0, FALSE );
        }

        UlReleaseSpinLock( &g_BufferIoSpinLock,  OldIrql );
    }
}


/***************************************************************************++

Routine Description:

    Waits for Io Completions to complete on Log Buffers before shutdown.

Arguments:

    None.

--***************************************************************************/
VOID
UlWaitForBufferIoToComplete(
    VOID
    )
{
    KIRQL   OldIrql;
    BOOLEAN Wait = FALSE;

    ASSERT( g_InitLogsCalled );

    if ( g_InitLogsCalled )
    {
        UlAcquireSpinLock( &g_BufferIoSpinLock, &OldIrql );

        if ( !g_BufferWaitingForIoComplete )
        {
            g_BufferWaitingForIoComplete = TRUE;

            KeInitializeEvent(
                &g_BufferIoCompleteEvent,
                NotificationEvent,
                FALSE
                );
        }

        //
        // If no more i/o operations are happening we are not going to
        // wait for them. It is not possible for global i/o counter to
        // increment at this time because the log file entry list is empty.
        // If there were outstanding i/o then we have to wait them to be
        // complete.
        //

        if ( g_BufferIoCount > 0 )
        {
            Wait = TRUE;
        }

        UlReleaseSpinLock( &g_BufferIoSpinLock, OldIrql );

        if (Wait)
        {
            KeWaitForSingleObject(
                (PVOID)&g_BufferIoCompleteEvent,
                UserRequest,
                KernelMode,
                FALSE,
                NULL
                );
        }
    }
}

/***************************************************************************++

Routine Description:

    UlpFlushLogFile :

       Assumes you are holding the FastMutex for the buffer & loglist resource

Arguments:

    pFile   - Handle to a log file entry

--***************************************************************************/

NTSTATUS
UlpFlushLogFile(
    IN PUL_LOG_FILE_ENTRY   pFile
    )
{
    NTSTATUS                Status;
    LARGE_INTEGER           EndOfFile;
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    PIO_STATUS_BLOCK        pIoStatusBlock;

    PAGED_CODE();

    ASSERT(pFile!=NULL);

    UlTrace( LOGGING, ("Ul!UlpFlushLogFile: pEntry %p\n", pFile ));

    pLogBuffer = pFile->LogBuffer;

    if ( pLogBuffer==NULL || pLogBuffer->BufferUsed==0 || pFile->hFile==NULL )
    {
        return STATUS_SUCCESS;
    }

    pFile->LogBuffer = NULL;
    pIoStatusBlock = &pLogBuffer->IoStatusBlock;

    EndOfFile.HighPart = -1;
    EndOfFile.LowPart = FILE_WRITE_TO_END_OF_FILE;

    Status = ZwWriteFile(
                  pFile->hFile,
                  NULL,
                  &UlpBufferFlushAPC,
                  pLogBuffer,
                  pIoStatusBlock,
                  pLogBuffer->Buffer,
                  pLogBuffer->BufferUsed,
                  &EndOfFile,
                  NULL
                  );

     if ( !NT_SUCCESS(Status) )
     {
        //
        // Status maybe STATUS_DISK_FULL,in that case Logging
        // will be ceased. Hence log hits stored in this buffer
        // are lost.
        //

        UlTrace( LOGGING,
                ("Ul!UlpFlushLogFile: ZwWriteFile Failure %08lx \n",
                  Status
                  ));

        UlPplFreeLogBuffer( pLogBuffer );

        return Status;
     }

     //
     // Properly keep the number of outstanding Io
     //

     InterlockedIncrement( (PLONG) &g_BufferIoCount );

     return Status;
}

/***************************************************************************++

Routine Description:

    UlpWriteToLogFile :

        Writes a record to a log file

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

NTSTATUS
UlpWriteToLogFile(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    ASSERT(pRecord!=NULL);
    ASSERT(RecordSize!=0);
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));

    UlTrace(LOGGING, ("Ul!UlpWriteToLogFile: pEntry %p\n", pFile));

    if ( pFile==NULL ||
         pRecord==NULL ||
         RecordSize==0 ||
         RecordSize>g_UlLogBufferSize
       )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // We are safe here by dealing only with entry  eresource  since  the
    // time based recycling, reconfiguration and periodic buffer flushing
    // always acquires the global list eresource exclusively and  we  are 
    // already holding it shared. But we should still  be  carefull about
    // file size based  recyling  and we should only  do  it while we are
    // holding the entries eresource exclusive.I.e. look at the exclusive
    // writer down below.
    //

    if (g_UlDebugLogBufferPeriod)
    {
        //
        // Above global variable is safe to look, it doesn't get changed
        // during the life-time of the driver. It's get initialized from
        // the registry and disables the log buffering.
        //
        
        UlAcquireResourceExclusive(&pFile->EntryResource, TRUE);

        Status = UlpWriteToLogFileDebug(
                    pFile,
                    RecordSize,
                    pRecord,
                    UsedOffset1,
                    UsedOffset2
                    );

        UlReleaseResource(&pFile->EntryResource);

        return Status;    
    }
    
    //
    // Try UlpWriteToLogFileShared first which merely moves the
    // BufferUsed forward and copy the record to LogBuffer->Buffer.
    //

    UlAcquireResourceShared(&pFile->EntryResource, TRUE);

    Status = UlpWriteToLogFileShared(
                pFile,
                RecordSize,
                pRecord,
                UsedOffset1,
                UsedOffset2
                );

    UlReleaseResource(&pFile->EntryResource);

    if (Status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // UlpWriteToLogFileShared returns STATUS_MORE_PROCESSING_REQUIRED,
        // we need to flush the buffer and try to log again. This time, we
        // need to take the entry eresource exclusive.
        //

        UlAcquireResourceExclusive(&pFile->EntryResource, TRUE);

        Status = UlpWriteToLogFileExclusive(
                    pFile,
                    RecordSize,
                    pRecord,
                    UsedOffset1,
                    UsedOffset2
                    );

        UlReleaseResource(&pFile->EntryResource);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

  UlpAppendToLogBuffer  :

        Append a record to a log file

        REQUIRES you to hold the loglist resource shared and entry mutex
        shared or exclusive

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

__inline
VOID
FASTCALL
UlpAppendToLogBuffer(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                BufferUsed,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer = pFile->LogBuffer;

    UlTrace( LOGGING, ("Ul!UlpAppendToLogBuffer: pEntry %p\n", pFile ));

    //
    // IIS format log line may be fragmented (identified by looking at the 
    // UsedOffset2), handle it wisely.
    //

    if (UsedOffset2)
    {
        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed,
            &pRecord[0],
            UsedOffset1
            );

        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed + UsedOffset1,
            &pRecord[512],
            UsedOffset2
            );

        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed + UsedOffset1 + UsedOffset2,
            &pRecord[1024],
            RecordSize - (UsedOffset1 + UsedOffset2)
            );
    }
    else
    {
        RtlCopyMemory(
            pLogBuffer->Buffer + BufferUsed,
            pRecord,
            RecordSize
            );
    }

    UlpIncrementBytesWritten(pFile, RecordSize);
}

/***************************************************************************++

Routine Description:

        REQUIRES LogListResource Shared & Entry eresource exclusive.

        Appends the W3C log file title to the existing buffer.

Arguments:

    pFile   - Pointer to the logfile entry
    pCurrentTimeFields - Current time fields

--***************************************************************************/

NTSTATUS
UlpAppendW3CLogTitle(
    IN     PUL_LOG_FILE_ENTRY   pEntry,
    OUT    PCHAR                pDestBuffer,
    IN OUT PULONG               pBytesCopied
    )
{
    NTSTATUS        Status = STATUS_SUCCESS;
    PCHAR           TitleBuffer;
    LONG            BytesCopied;
    ULONG           LogExtFileFlags;
    TIME_FIELDS     CurrentTimeFields;
    LARGE_INTEGER   CurrentTimeStamp;
    PUL_LOG_FILE_BUFFER pLogBuffer;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pEntry->Format == HttpLoggingTypeW3C);

    pLogBuffer = pEntry->LogBuffer;
    LogExtFileFlags = pEntry->LogExtFileFlags;
    
    KeQuerySystemTime(&CurrentTimeStamp);
    RtlTimeToTimeFields(&CurrentTimeStamp, &CurrentTimeFields);

    if (pDestBuffer)
    {
        // Append to the provided buffer

        ASSERT(pBytesCopied);
        ASSERT(*pBytesCopied >= UL_MAX_TITLE_BUFFER_SIZE);

        UlTrace(LOGGING,("Ul!UlpAppendW3CLogTitle: Copying to Provided Buffer %p\n", 
                           pDestBuffer));
        
        TitleBuffer = pDestBuffer;
    }
    else
    {
        // Append to the entry buffer        

        ASSERT(pLogBuffer);
        ASSERT(pLogBuffer->Buffer);

        UlTrace(LOGGING,("Ul!UlpAppendW3CLogTitle: Copying to Entry Buffer %p\n", 
                           pLogBuffer));

        TitleBuffer = (PCHAR) pLogBuffer->Buffer + pLogBuffer->BufferUsed;
    }
        
    BytesCopied = _snprintf(
        TitleBuffer,
        UL_MAX_TITLE_BUFFER_SIZE,

        // TODO: Make this maintainance friendly

        "#Software: Microsoft Internet Information Services 6.0\r\n"
        "#Version: 1.0\r\n"
        "#Date: %4d-%02d-%02d %02d:%02d:%02d\r\n"
        "#Fields:%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls%ls \r\n",

        CurrentTimeFields.Year,
        CurrentTimeFields.Month,
        CurrentTimeFields.Day,

        CurrentTimeFields.Hour,
        CurrentTimeFields.Minute,
        CurrentTimeFields.Second,

        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldDate,LogExtFileFlags,MD_EXTLOG_DATE),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldTime,LogExtFileFlags,MD_EXTLOG_TIME),       
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldSiteName,LogExtFileFlags,MD_EXTLOG_SITE_NAME),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerName,LogExtFileFlags,MD_EXTLOG_COMPUTER_NAME),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerIp,LogExtFileFlags,MD_EXTLOG_SERVER_IP),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldMethod,LogExtFileFlags,MD_EXTLOG_METHOD),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUriStem,LogExtFileFlags,MD_EXTLOG_URI_STEM),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUriQuery,LogExtFileFlags,MD_EXTLOG_URI_QUERY),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldProtocolStatus,LogExtFileFlags,MD_EXTLOG_HTTP_STATUS),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldWin32Status,LogExtFileFlags,MD_EXTLOG_WIN32_STATUS),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldServerPort,LogExtFileFlags,MD_EXTLOG_SERVER_PORT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUserName,LogExtFileFlags,MD_EXTLOG_USERNAME),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldClientIp,LogExtFileFlags,MD_EXTLOG_CLIENT_IP),        
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldProtocolVersion,LogExtFileFlags,MD_EXTLOG_PROTOCOL_VERSION),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldUserAgent,LogExtFileFlags,MD_EXTLOG_USER_AGENT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldCookie,LogExtFileFlags,MD_EXTLOG_COOKIE),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldReferrer,LogExtFileFlags,MD_EXTLOG_REFERER),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldHost,LogExtFileFlags,MD_EXTLOG_HOST),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldBytesSent,LogExtFileFlags,MD_EXTLOG_BYTES_SENT),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldBytesReceived,LogExtFileFlags,MD_EXTLOG_BYTES_RECV),
        UL_GET_LOG_TITLE_IF_PICKED(UlLogFieldTimeTaken,LogExtFileFlags,MD_EXTLOG_TIME_TAKEN)

        );

    if (BytesCopied < 0)
    {
        ASSERT(!"Default title buffer size is too small !");
        BytesCopied = UL_MAX_TITLE_BUFFER_SIZE;
    }

    if (pDestBuffer)
    {
        *pBytesCopied = BytesCopied;
    }
    else
    {
        pLogBuffer->BufferUsed += BytesCopied; 
        UlpIncrementBytesWritten(pEntry, BytesCopied);        
    }
        
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

        Writes a record to the log buffer and flushes.
        This func only get called when debug parameter 
        g_UlDebugLogBufferPeriod is set.

        REQUIRES you to hold the entry eresource EXCLUSIVE.

Arguments:

    pFile      - Handle to a log file entry
    RecordSize - Length of the record to be written.

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileDebug(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    ULONG                   RecordSizePlusTitle = RecordSize;    
    CHAR                    TitleBuffer[UL_MAX_TITLE_BUFFER_SIZE];
    ULONG                   TitleBufferSize = UL_MAX_TITLE_BUFFER_SIZE;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(UlDbgResourceOwnedExclusive(&pFile->EntryResource));
    ASSERT(g_UlDebugLogBufferPeriod!=0);
    
    UlTrace(LOGGING,("Ul!UlpWriteToLogFileDebug: pEntry %p\n", pFile ));

    if (!pFile->Flags.LogTitleWritten) 
    {
        // First append to the temp buffer to calculate the size
        UlpAppendW3CLogTitle(pFile, TitleBuffer, &TitleBufferSize);            
        RecordSizePlusTitle += TitleBufferSize;
    }

    if (UlpIsLogFileOverFlow(pFile,RecordSizePlusTitle))
    {
        Status = UlpRecycleLogFile(pFile);
    }

    if (pFile->hFile==NULL || !NT_SUCCESS(Status))
    {
        //
        // If we were unable to acquire a new file handle that means logging
        // is temporarly ceased because of either STATUS_DISK_FULL or the 
        // drive went down for some reason. We just bail out.
        //
        
        return Status;
    }

    if (!pFile->LogBuffer)
    {
        //
        // The buffer will be null for each log hit when log buffering 
        // is disabled.
        //
        
        pFile->LogBuffer = UlPplAllocateLogBuffer();
        if (!pFile->LogBuffer)
        {
            return STATUS_NO_MEMORY;
        }
    }

    pLogBuffer = pFile->LogBuffer;
    ASSERT(pLogBuffer->BufferUsed == 0); 

    if (!pFile->Flags.LogTitleWritten)
    {
        UlpAppendW3CLogTitle(pFile, NULL, NULL);
    }
    
    ASSERT(RecordSize + pLogBuffer->BufferUsed <= g_UlLogBufferSize);

    UlpAppendToLogBuffer(
        pFile,
        pLogBuffer->BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    pLogBuffer->BufferUsed += RecordSize;

    Status = UlpFlushLogFile(pFile);
    if (!NT_SUCCESS(Status))
    {        
        return Status;
    }

    pFile->Flags.LogTitleWritten = 1;
    
    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    UlpWriteToLogFileShared :

        Writes a record to a log file

        REQUIRES you to hold the loglist resource shared

Arguments:

    pFile   - Handle to a log file entry
    RecordSize - Length of the record to be written.
    pRecord - The log record to be written to the log buffer

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileShared(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    LONG                    BufferUsed;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(g_UlDebugLogBufferPeriod== 0);

    pLogBuffer = pFile->LogBuffer;

    UlTrace(LOGGING,("Ul!UlpWriteToLogFileShared: pEntry %p\n", pFile));

    //
    // Bail out and try the exclusive writer for cases;
    //
    // 1. No log buffer available.
    // 2. Logging ceased. (NULL handle)
    // 3. Title needs to be written.
    // 4. The actual log file itself has to be recycled.
    //
    // Otherwise proceed with appending to the current buffer
    // if there is enough space avialable for us. If not;
    // 
    // 5. Bail out to get a new buffer
    //

    if ( pLogBuffer==NULL ||
         pFile->hFile==NULL ||
         !pFile->Flags.LogTitleWritten ||
         UlpIsLogFileOverFlow(pFile,RecordSize)
       )
    {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    // Reserve space in pLogBuffer by InterlockedCompareExchange add
    // RecordSize. If we exceed the limit, bail out and take the
    // exclusive lock to flush the buffer.
    //

    do
    {
        BufferUsed = *((volatile LONG *) &pLogBuffer->BufferUsed);

        if ( RecordSize + BufferUsed > g_UlLogBufferSize )
        {
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

    } while (BufferUsed != InterlockedCompareExchange(
                                &pLogBuffer->BufferUsed,
                                RecordSize + BufferUsed,
                                BufferUsed
                                ));

    //
    // Keep buffering untill our buffer is full.
    //

    UlpAppendToLogBuffer(
        pFile,
        BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

        By assuming that it's holding the entrie's eresource exclusively
        this function does various functions;
            - It Writes a record to a log file

        REQUIRES you to hold the loglist resource shared

Arguments:

    pFile  - Handle to a log file entry
    RecordSize - Length of the record to be written.

--***************************************************************************/

NTSTATUS
UlpWriteToLogFileExclusive(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    )
{
    PUL_LOG_FILE_BUFFER     pLogBuffer;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   RecordSizePlusTitle = RecordSize;
    CHAR                    TitleBuffer[UL_MAX_TITLE_BUFFER_SIZE];
    ULONG                   TitleBufferSize = UL_MAX_TITLE_BUFFER_SIZE;

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pFile));
    ASSERT(g_UlDebugLogBufferPeriod== 0);
    ASSERT(UlDbgResourceOwnedExclusive(&pFile->EntryResource));

    UlTrace(LOGGING,("Ul!UlpWriteToLogFileExclusive: pEntry %p\n", pFile));

    //
    // First append title to the temp buffer to calculate the size of 
    // the title if we need to write the title as well.
    //
    
    if (!pFile->Flags.LogTitleWritten) 
    {
        UlpAppendW3CLogTitle(pFile, TitleBuffer, &TitleBufferSize);
        RecordSizePlusTitle += TitleBufferSize;
    }

    //
    // Now check log file overflow.
    //
    
    if (UlpIsLogFileOverFlow(pFile,RecordSizePlusTitle))
    {
        //
        // We already acquired the LogListResource Shared and the
        // entry eresource exclusive. Therefore ReCycle is fine. Look
        // at the comment in UlpWriteToLogFile.
        //

        Status = UlpRecycleLogFile(pFile);
    }

    if (pFile->hFile==NULL || !NT_SUCCESS(Status))
    {
        //
        // If somehow the logging ceased and handle released,it happens
        // when recycle isn't able to write to the log drive.
        //

        return Status;
    }

    pLogBuffer = pFile->LogBuffer;
    if (pLogBuffer)
    {
        //
        // There are two conditions we execute the following if block
        // 1. We were blocked on eresource exclusive and before us some 
        // other thread already take care of the buffer flush or recycling.
        // 2. Reconfiguration happened and log attempt needs to write the
        // title again.
        //
        
        if (RecordSizePlusTitle + pLogBuffer->BufferUsed <= g_UlLogBufferSize)
        {
            //
            // If this is the first log attempt after a reconfig, then we have
            // to write the title here. Reconfig doesn't immediately write the
            // title but rather depend on us by setting the LogTitleWritten flag
            // to false.
            //
            
            if (!pFile->Flags.LogTitleWritten)
            {
                ASSERT(RecordSizePlusTitle > RecordSize);
                UlpAppendW3CLogTitle(pFile, NULL, NULL);
                pFile->Flags.LogTitleWritten = 1;                
            }

            UlpAppendToLogBuffer(
                pFile,
                pLogBuffer->BufferUsed,
                RecordSize,
                pRecord,
                UsedOffset1,
                UsedOffset2
                );
            
            pLogBuffer->BufferUsed += RecordSize;

            return STATUS_SUCCESS;
        }

        //
        // Flush out the buffer first then proceed with allocating a new one.
        //

        Status = UlpFlushLogFile(pFile);
        if (!NT_SUCCESS(Status))
        {            
            return Status;
        }
    }

    ASSERT(pFile->LogBuffer == NULL);
    
    //
    // This can be the very first log attempt or the previous allocation
    // of LogBuffer failed, or the previous hit flushed and deallocated 
    // the old buffer. In either case, we allocate a new one,append the
    // (title plus) new record and return for more/shared processing.
    //

    pLogBuffer = pFile->LogBuffer = UlPplAllocateLogBuffer();
    if (pLogBuffer == NULL)
    {
        return STATUS_NO_MEMORY;
    }

    //
    // Very first attempt needs to write the title, as well as the attempt
    // which causes the log file recycling. Both cases comes down here
    //
    
    if (!pFile->Flags.LogTitleWritten)
    {
        UlpAppendW3CLogTitle(pFile, NULL, NULL);
        pFile->Flags.LogTitleWritten = 1;
    }

    UlpAppendToLogBuffer(
        pFile,
        pLogBuffer->BufferUsed,
        RecordSize,
        pRecord,
        UsedOffset1,
        UsedOffset2
        );

    pLogBuffer->BufferUsed += RecordSize;

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    UlpQueryDirectory:

  * What file should IIS write to when logging type is daily/weekly/monthly/
    hourly if there is already a log file there for that day?

      IIS should write to the current day/week/month/hour's log file.  For
      example, let's say there's an extended log file in my log directory
      called ex000727.log.  IIS should append new log entries to this log,
      as it is for today.

  * What file should IIS write to when logging type is MAXSIZE when there are
    already log files there for maxsize (like extend0.log, extend1.log, etc.)?

      IIS should write to the max extend#.log file, where max(extend#.log)
      is has the largest # in the #field for extend#.log. This is provided,
      of course, that the MAXSIZE in that file hasn't been exceeded.

  * This function quite similar to the implementation of the FindFirstFile
    Win32 API. Except that it has been shaped to our purposes.

Arguments:

    pEntry - The log file entry which freshly created.

--***************************************************************************/

NTSTATUS
UlpQueryDirectory(
    IN OUT PUL_LOG_FILE_ENTRY   pEntry
    )
{
#define GET_NEXT_FILE(pv, cb)   \
       (FILE_DIRECTORY_INFORMATION *) ((VOID *) (((UCHAR *) (pv)) + (cb)))

    NTSTATUS                    Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    IO_STATUS_BLOCK             IoStatusBlock;
    LONG                        WcharsCopied;
    HANDLE                      hDirectory;
    ULONG                       Sequence;
    ULONG                       LastSequence;
    UNICODE_STRING              Temp;
    PWCHAR                      pTemp;
    UNICODE_STRING              FileName;
    WCHAR                      _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH];

    FILE_DIRECTORY_INFORMATION *pFdi;
    PUCHAR                      FileInfoBuffer;
    ULARGE_INTEGER              FileSize;
    WCHAR                       OriginalWChar;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    hDirectory = NULL;
    FileInfoBuffer = NULL;

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    UlTrace(LOGGING,("Ul!UlpQueryDirectory: %S\n",pEntry->FileName.Buffer));

    ASSERT(pEntry->Period == HttpLoggingPeriodMaxSize);

    ASSERT(UL_DIRECTORY_SEARCH_BUFFER_SIZE >=
          (sizeof(FILE_DIRECTORY_INFORMATION)+UL_MAX_FILE_NAME_SUFFIX_LENGTH));

    //
    // Open the directory for the list access again. Use the filename in
    // pEntry. Where pShortName points to the "\inetsv1.log" portion  of
    // the  whole "\??\c:\whistler\system32\logfiles\w3svc1\inetsv1.log"
    // Overwrite the pShortName to get the  directory name. Once we  are
    // done with finding the last sequence we will restore it back later
    // on.
    //

    OriginalWChar = *((PWCHAR)pEntry->pShortName);
    *((PWCHAR)pEntry->pShortName) = UNICODE_NULL;
    pEntry->FileName.Length =
        wcslen(pEntry->FileName.Buffer) * sizeof(WCHAR);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &pEntry->FileName,
         OBJ_CASE_INSENSITIVE|UL_KERNEL_HANDLE,
         NULL,
         NULL
         );

    Status = ZwCreateFile(
                &hDirectory,
                SYNCHRONIZE|FILE_LIST_DIRECTORY,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT|FILE_DIRECTORY_FILE,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status))
    {
        //
        // This call should never fail since CreateLog   already created
        // the directory for us.
        //

        ASSERT(!"Directory Invalid!\n");
        goto end;
    }

    //
    // Before querrying we need to provide additional DOS-like  wildcard
    // matching semantics. In our case, only * to DOS_STAR conversion is
    // enough though. The following is the pattern we will use for query
    // Skipping the first slash character.
    //

    FileName.Buffer = &_FileName[1];
    WcharsCopied    =  _snwprintf( _FileName,
                        UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                        L"%s%c.%s",
                        UL_GET_LOG_FILE_NAME_PREFIX(pEntry->Format),
                        DOS_STAR,
                        DEFAULT_LOG_FILE_EXTENSION
                        );
    ASSERT(WcharsCopied > 0);

    FileName.Length = wcslen(FileName.Buffer) * sizeof(WCHAR);
    FileName.MaximumLength = FileName.Length;

    //
    // This non-paged buffer should be allocated to be  used for storing
    // query results.
    //

    FileInfoBuffer =
        UL_ALLOCATE_ARRAY(
                    NonPagedPool,
                    UCHAR,
                    UL_DIRECTORY_SEARCH_BUFFER_SIZE + sizeof(WCHAR),
                    UL_LOG_GENERIC_POOL_TAG
                    );
    if (FileInfoBuffer == NULL)
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    //
    // The  very first call may also fail if there is no log file in the
    // current directory.
    //

    Status = ZwQueryDirectoryFile (
        hDirectory,
        NULL,
        NULL,
        NULL,
       &IoStatusBlock,
        FileInfoBuffer,
        UL_DIRECTORY_SEARCH_BUFFER_SIZE,
        FileDirectoryInformation,
        FALSE,
       &FileName,
        TRUE
        );

    if(!NT_SUCCESS(Status))
    {
        //
        // This should never fail with STATUS_BUFFER_OVERFLOW unless the
        // buffer size is ridiculously small  i.e. 50 bytes or something
        //

        UlTrace( LOGGING,
            ("Ul!UlpQueryDirectory: Status %08lx for %S & %S\n",
              Status,
              pEntry->FileName.Buffer,
              FileName.Buffer
              ));

        ASSERT(Status == STATUS_NO_SUCH_FILE);

        Status = STATUS_SUCCESS;
        goto end;
    }

    //
    // Look into the buffer and get the sequence number from filename.
    //

    pFdi = (FILE_DIRECTORY_INFORMATION *) FileInfoBuffer;
    Sequence = LastSequence = 1;
    FileSize.QuadPart = 0;

    while (TRUE)
    {
        //
        // Get the latest Sequence Number from the filename
        //

        if (pTemp = wcsstr(pFdi->FileName,DEFAULT_LOG_FILE_EXTENSION_PLUS_DOT))
        {
           *pTemp = UNICODE_NULL;
            pTemp = pFdi->FileName;

            while ( *pTemp != UNICODE_NULL )
            {
                if ( isdigit((CHAR) (*pTemp)) )
                {
                    Temp.Length        = wcslen(pTemp) * sizeof(WCHAR);
                    Temp.MaximumLength = Temp.Length;
                    Temp.Buffer        = pTemp;

                    RtlUnicodeStringToInteger( &Temp, 10, &LastSequence );

                    break;
                }
                pTemp++;
            }
        }
        else
        {
            ASSERT(FALSE);
        }

        if (LastSequence >= Sequence)
        {
            //
            // Bingo ! We have two things to remember though; the file  size
            // and the sequence number. Cryptic it's that we are getting the
            // file size from EOF. Its greater than or equal because we want
            // to initialize the FileSize properly even if there's only  one
            // match.
            //

            Sequence = LastSequence;

            //
            // BUGBUG: The HighPart is zero unless the file size is  greater
            // than the MAXDWORD. If so the  file size  calculated as in the
            // formula; ((HighPart * (MAXDWORD+1)) + LowPart)
            //

            FileSize.LowPart = pFdi->EndOfFile.LowPart;
        }

        //
        // Keep going until we see no more files
        //

        if (pFdi->NextEntryOffset != 0)
        {
            //
            // Search through the buffer as long as there is  still something
            // in there.
            //

            pFdi = GET_NEXT_FILE(pFdi, pFdi->NextEntryOffset);
        }
        else
        {
            //
            // Otherwise query again for any other possible log file(s)
            //

            Status = ZwQueryDirectoryFile (
                hDirectory,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                FileInfoBuffer,
                UL_DIRECTORY_SEARCH_BUFFER_SIZE,
                FileDirectoryInformation,
                FALSE,
                NULL,
                FALSE
                );

            if (Status == STATUS_NO_MORE_FILES)
            {
                Status  = STATUS_SUCCESS;
                break;
            }

            if (!NT_SUCCESS(Status))
            {
                goto end;
            }

            pFdi = (FILE_DIRECTORY_INFORMATION *) FileInfoBuffer;
        }
    }

    //
    // Construct the log file name properly from the sequence number so  that
    // our caller can create the log file later on.
    //

    WcharsCopied = _snwprintf( pEntry->pShortName,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    L"%s%d.%s",
                    UL_GET_LOG_FILE_NAME_PREFIX(pEntry->Format),
                    Sequence,
                    DEFAULT_LOG_FILE_EXTENSION
                    );
    ASSERT(WcharsCopied > 0);

    pEntry->FileName.Length =
        wcslen(pEntry->FileName.Buffer) * sizeof(WCHAR);

    //
    // Set the next sequence number according to last log file
    //

    pEntry->SequenceNumber = Sequence + 1;

    //
    // Update the log file size accordingly in the entry.Otherwise truncation
    // will not work properly.
    //

    pEntry->TotalWritten.QuadPart = FileSize.QuadPart;

    UlTrace( LOGGING,
        ("Ul!UlpQueryDirectory: %S has been found with size %d.\n",
          pEntry->FileName.Buffer,
          pEntry->TotalWritten.QuadPart
          ));

end:
    if (*((PWCHAR)pEntry->pShortName) == UNICODE_NULL )
    {
        //
        // We have failed for some reason before reconstructing the filename
        // Perhaps because the directory was empty. Do not forget to restore
        // the pShortName in the pEntry then.
        //

        *((PWCHAR)pEntry->pShortName) = OriginalWChar;
        pEntry->FileName.Length =
            wcslen(pEntry->FileName.Buffer) * sizeof(WCHAR);
    }

    if (FileInfoBuffer)
    {
        UL_FREE_POOL( FileInfoBuffer, UL_LOG_GENERIC_POOL_TAG );
    }

    if (!NT_SUCCESS(Status))
    {
        UlTrace( LOGGING,
            ("Ul!UlpQueryDirectory: failure %08lx for %S\n",
              Status,
              pEntry->FileName.Buffer
              ));
    }

    if (hDirectory != NULL)
    {
        ZwClose(hDirectory);
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlCreateLog:

    Creates a new Logging file and insert a corresponding entry
    to the global LoggingList.

    Each log file belongs to a single ConfigGroup and can be
    created by one. Although we keep a list of already created log files
    for convenience, each config group has a pointer to its log file.

    If this function fails for any reason, file entry pointer of the
    config group will set to NULL.

Arguments:

    pConfigGroup - Supplies the necessary information for opening the
                   log file and gets the result entry pointer.

                   LogListResource also implicitly protects this pointer
                   since only possible places which are going to update
                   it use the resource exclusively.

--***************************************************************************/

NTSTATUS
UlCreateLog(
    IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup
    )
{
    NTSTATUS            Status;
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    PUL_LOG_FILE_ENTRY  pNewEntry;
    TIME_FIELDS         CurrentTimeFields;
    LARGE_INTEGER       CurrentTimeStamp;
    HANDLE              hDirectory;
    UNICODE_STRING      DirectoryName;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pConfigGroup != NULL);

    UlTrace(LOGGING, ("Ul!UlCreateLog: pConfigGroup %p Truncate %d\n", 
                        pConfigGroup,  pConfigGroup->LoggingConfig.LogFileTruncateSize
                        ));

    //
    // An important check to ensure that no infinite loop occurs because of
    // ridiculusly small truncatesizes. Means smaller than maximum
    // allowed log record line (10*1024)
    //

    if ( pConfigGroup->LoggingConfig.LogPeriod == HttpLoggingPeriodMaxSize &&
         pConfigGroup->LoggingConfig.LogFileTruncateSize != HTTP_LIMIT_INFINITE &&
         pConfigGroup->LoggingConfig.LogFileTruncateSize < UL_MIN_ALLOWED_TRUNCATESIZE
        )
    {
        UlTrace(LOGGING,
          ("Ul!UlCreateLog: Truncate size too small pConfigGroup %p : %d\n",
            pConfigGroup,
            pConfigGroup->LoggingConfig.LogFileTruncateSize
            ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // We have two criteria for the log file name: its LogFormat and its LogPeriod
    //

    if ( pConfigGroup->LoggingConfig.LogFormat >= HttpLoggingTypeMaximum ||
         pConfigGroup->LoggingConfig.LogPeriod >= HttpLoggingPeriodMaximum )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    Status = STATUS_SUCCESS;
    pNewEntry = NULL;

    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime( &CurrentTimeStamp );
    RtlTimeToTimeFields( &CurrentTimeStamp, &CurrentTimeFields );

    //
    // Allocate a temp buffer to hold the full path name including the
    // device prefix and the filename at the end.
    //

    Status = UlpBuildLogDirectory(
                &pConfigGroup->LoggingConfig.LogFileDir,
                &DirectoryName
                 );
    if (!NT_SUCCESS(Status))
    {
        return Status;
    }

    //
    // We have to acquire the LogListresource exclusively, prior to
    // the operations Create/Remove/ReConfig. Whenever we acquire the
    // LogListResource exclusively we don't need to have the entry mutex
    // acquired.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->LogListResource, TRUE);

    pConfigGroup->pLogFileEntry = NULL;

    Status = UlpConstructLogFileEntry (
                 &pConfigGroup->LoggingConfig,
                 &pNewEntry,
                 &DirectoryName,
                 &CurrentTimeFields
                 );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Create/Open the directory(ies) first.
    //

    Status = UlpCreateSafeDirectory( &DirectoryName );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // If the logformat is max_size with truncation we need to scan the
    // directory and find the correct last log file to append. Otherwise
    // just picking the FILE_OPEN_IF when opening the log file will ensure
    // the functionality.
    //

    if (pNewEntry->Period == HttpLoggingPeriodMaxSize)
    {
        //
        // This call will update the filename and the file size
        //

        Status = UlpQueryDirectory(pNewEntry);
        if (!NT_SUCCESS(Status))
            goto end;
    }

    //
    // Create/Open the file.
    //

    InitializeObjectAttributes(
            &ObjectAttributes,
            &pNewEntry->FileName,      // Full path name
            OBJ_CASE_INSENSITIVE |     // Attributes
                UL_KERNEL_HANDLE,
            NULL,                      // RootDirectory
            NULL                       // SecurityDescriptor
            );

    //
    // Make the created file Aysnc by not picking the sync flag.
    //

    Status = ZwCreateFile(
            &pNewEntry->hFile,
            FILE_GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_NON_DIRECTORY_FILE,    // |FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0);

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Get the file size, etc from the file.
    //

    Status = ZwQueryInformationFile(
                    pNewEntry->hFile,
                    &IoStatusBlock,
                    &pNewEntry->FileInfo,
                    sizeof(pNewEntry->FileInfo),
                    FileStandardInformation
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Add it to our global log list.
    //

    UlpInsertLogFileEntry( pNewEntry, &CurrentTimeFields );

    //
    // Success!
    //

    pConfigGroup->pLogFileEntry = pNewEntry;

    UlTrace( LOGGING,
        ( "Ul!UlCreateLog: entry %p, file %S, handle %lx created\n",
           pNewEntry,
           pNewEntry->FileName.Buffer,
           pNewEntry->hFile )
           );

end:
    if ( !NT_SUCCESS(Status) )
    {
        //
        // If we made it to this point, then the create/open has failed.
        //

        UlTrace( LOGGING,
                ("Ul!UlCreateLog: dirname %S, file %S failure %08lx\n",
                    pConfigGroup->LoggingConfig.LogFileDir.Buffer,
                    pNewEntry->FileName.Buffer,
                    Status
                    ));

        if (pNewEntry)
        {
            NTSTATUS    TempStatus;

            //
            // Now release the entry's resources.
            //

            if (pNewEntry->hFile != NULL)
            {
                ZwClose( pNewEntry->hFile );
                pNewEntry->hFile = NULL;
            }

            if ( pNewEntry->LogBuffer )
            {
                UlPplFreeLogBuffer( pNewEntry->LogBuffer );
            }

            // Delete the entry eresource
            TempStatus = UlDeleteResource( &pNewEntry->EntryResource );
            ASSERT(NT_SUCCESS(TempStatus));

            UL_FREE_POOL_WITH_SIG(pNewEntry,UL_LOG_FILE_ENTRY_POOL_TAG);
        }

        pConfigGroup->pLogFileEntry = NULL;

    }
    else
    {
        ASSERT(pConfigGroup->pLogFileEntry != NULL);
    }

    // Cleanup temp dir name buffer
    if (DirectoryName.Buffer)
    {
        UL_FREE_POOL(DirectoryName.Buffer, UL_CG_LOGDIR_POOL_TAG);
    }

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpInsertLogFileEntry :

        Inserts a log file entry to our global log entry list.

        REQUIRES caller to have LogListresource EXCLUSIVELY.

Arguments:

    pEntry      - The log file entry to be added to the global list
    pTimeFields - The current time fields.

--***************************************************************************/

VOID
UlpInsertLogFileEntry(
    PUL_LOG_FILE_ENTRY  pEntry,
    PTIME_FIELDS        pTimeFields
    )
{
    LONG listSize;
    HTTP_LOGGING_PERIOD period;
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pTimeFields);

    //
    // add to the list
    //

    InsertHeadList(&g_LogListHead, &pEntry->LogFileListEntry);

    period = pEntry->Period;

    listSize = InterlockedIncrement( &g_LogListEntryCount );

    ASSERT(listSize >= 1);

    //
    // Time to start the Log Timer if we haven't done it yet.
    // Once we start this timer it keeps working until
    // terminaton of the driver. CODEWORK we may start and stop it
    // more intelligently, i.e. if no log requires it stop it
    //

    UlAcquireSpinLock( &g_LogTimerSpinLock, &oldIrql );

    if ( g_LogTimerStarted == FALSE )
    {
        // Only if we are running on time dependent
        // format

        if ( period != HttpLoggingPeriodMaxSize )
        {
            UlpSetLogTimer( pTimeFields );
            g_LogTimerStarted = TRUE;
        }
    }

    // Go ahead start the buffer timer
    // as soon as we have a log file

    if ( g_BufferTimerStarted == FALSE )
    {
        UlpSetBufferTimer();
        g_BufferTimerStarted = TRUE;
    }

    UlReleaseSpinLock( &g_LogTimerSpinLock, oldIrql );
}

/***************************************************************************++

Routine Description:

    Simple utility to close the log file handle on a system thread and set the
    event to notify the caller that it's done.

Arguments:

    pEntry  -  Acquired from passed-in pWorkItem

--***************************************************************************/

VOID
UlpLogCloseHandleWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_LOG_FILE_ENTRY  pEntry;

    PAGED_CODE();

    // For this function to not to cause any threats to the safety of the log
    // entry. The entry should already been acquired exclusively by our caller.

    ASSERT(!UlDbgResourceUnownedExclusive(
                    &g_pUlNonpagedData->LogListResource));

    // Get the log entry

    pEntry = CONTAINING_RECORD(
                pWorkItem,
                UL_LOG_FILE_ENTRY,
                WorkItem
                );
    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pEntry->hFile);

    UlTrace(LOGGING,("Ul!UlpLogCloseHandleWorker: pEntry %p hFile %p\n",
                      pEntry, pEntry->hFile ));

    // Close the handle and set the event for the original caller

    ZwClose(pEntry->hFile);

    pEntry->hFile = NULL;

    KeSetEvent(&pEntry->CloseEvent, 0, FALSE);

}

/***************************************************************************++

Routine Description:

    Simple utility to close the log file handle on a system thread and set the
    event to notify the caller that it's done.

Arguments:

    pEntry  -  Acquired from passed-in pWorkItem

--***************************************************************************/

VOID
UlpLogCloseHandle(
    IN PUL_LOG_FILE_ENTRY  pEntry
    )
{
    // Sanity check

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    //ASSERT(UlDbgResourceOwnedExclusive(&pEntry->EntryResource));
    ASSERT(g_pUlSystemProcess);

    // Close the handle on the system thread and wait until it's done

    if (g_pUlSystemProcess == (PKPROCESS)PsGetCurrentProcess())
    {
        ZwClose(pEntry->hFile);
        pEntry->hFile = NULL;
    }
    else
    {
        KeAttachProcess(g_pUlSystemProcess);

        ZwClose(pEntry->hFile);
        pEntry->hFile = NULL;

        // Following will bugcheck in the checked kernel if there's
        // any user or kernel APCs attached to the thread.

        KeDetachProcess();

        // TODO: Find a better solution

        /*
        UL_QUEUE_WORK_ITEM(
            &pEntry->WorkItem,
            &UlpLogCloseHandleWorker
            );
        KeWaitForSingleObject(
            (PVOID)&pEntry->CloseEvent,
            UserRequest,
            KernelMode,
            FALSE,
            NULL
            );
        KeClearEvent(&pEntry->CloseEvent);
        */

    }

}

/***************************************************************************++

Routine Description:

    UlRemoveLogFileEntry :

        Removes a log file entry from our global log entry list.

Arguments:

    pEntry  - The log file entry to be removed from the global list

--***************************************************************************/

VOID
UlRemoveLogFileEntry(
    PUL_LOG_FILE_ENTRY  pEntry
    )
{
    NTSTATUS Status;
    LONG     listSize;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->LogListResource, TRUE);

    RemoveEntryList(&pEntry->LogFileListEntry);

    pEntry->LogFileListEntry.Flink =
        pEntry->LogFileListEntry.Blink = NULL;

    if (pEntry->hFile != NULL)
    {
        //
        // Make sure that buffer get flushed out before closing the file
        // handle. But flush will cause an APC to be queued to the user
        // thread, therefore we have to close the handle on one of our
        // system threads to avoid the possible bugcheck
        // INVALID_PROCESS_DETACH_ATTEMPT condition.
        //

        UlpFlushLogFile(pEntry);

        UlpLogCloseHandle(pEntry);
    }

    //
    // Delete the entry eresource
    //

    Status = UlDeleteResource( &pEntry->EntryResource );
    ASSERT(NT_SUCCESS(Status));

    listSize = InterlockedDecrement( &g_LogListEntryCount );

    ASSERT(listSize >= 0);

    UlTrace( LOGGING,
            ("Ul!UlRemoveLogFileEntry: entry %p has been removed\n",
             pEntry
             ));

    if ( pEntry->LogBuffer )
    {
        UlPplFreeLogBuffer( pEntry->LogBuffer );
    }

    UL_FREE_POOL_WITH_SIG(pEntry,UL_LOG_FILE_ENTRY_POOL_TAG);

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);
}

/***************************************************************************++

Routine Description:

    UlpCreateSafeDirectory :

        Creates all of the necessary directories in a given UNICODE directory
        pathname.

            E.g.  For given \??\C:\temp\w3svc1

                -> Directories "C:\temp" & "C:\temp\w3svc1" will be created.

        This function assumes that directory string starts with "\\??\\"

Arguments:

    pDirectoryName  - directroy path name string, WARNING this function makes
                      some inplace modification to the passed directory string
                      but it restores the original before returning.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpCreateSafeDirectory(
    IN PUNICODE_STRING  pDirectoryName
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    IO_STATUS_BLOCK     IoStatusBlock;
    NTSTATUS            Status;
    HANDLE              hDirectory;
    PWCHAR              pw;
    USHORT              i;

    //
    // Sanity check
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    ASSERT( pDirectoryName );
    ASSERT( pDirectoryName->Buffer );
    ASSERT( pDirectoryName->Length );
    ASSERT( pDirectoryName->MaximumLength > pDirectoryName->Length );

    pw = pDirectoryName->Buffer;
    pw[pDirectoryName->Length/sizeof(WCHAR)]=UNICODE_NULL;

    // TODO: Handle network mapped drives. Redirector.

    if (0 == wcsncmp(pw, UL_UNC_PATH_PREFIX, UL_UNC_PATH_PREFIX_LENGTH))
    {
        // UNC share
        pw += UL_UNC_PATH_PREFIX_LENGTH;

        // Bypass "\\machine\share"

        i = 0; // Skip two backslashes before reaching to share name

        while( *pw != UNICODE_NULL )
        {
            if ( *pw == L'\\' ) i++;
            if ( i == 2 ) break;
            pw++;
        }
    }
    else if (0 == wcsncmp(pw, UL_LOCAL_PATH_PREFIX, UL_LOCAL_PATH_PREFIX_LENGTH))
    {
        // Local Drive
        pw += UL_LOCAL_PATH_PREFIX_LENGTH;

        // Bypass "C:"

        while( *pw != L'\\' && *pw != UNICODE_NULL )
        {
            pw++;
        }
    }
    else
    {
        ASSERT(!"Incorrect logging directory name or type !");
        return STATUS_INVALID_PARAMETER;
    }

    if ( *pw == UNICODE_NULL )
    {
        // Dir. Name cannot be only "\??\C:" or "\dosdevices\UNC\machine
        // It should at least be pointing to the root directory.

        ASSERT(!"Incomplete logging directory name !");
        return STATUS_INVALID_PARAMETER;
    }

    //
    //            \??\C:\temp\w3svc1 OR \\dosdevices\UNC\machine\share\w3svc1
    //                  ^                                       ^
    // pw now points to |            OR                         |
    //
    //

    ASSERT( *pw == L'\\' );

    do
    {
        pw++;

        if ( *pw == L'\\' || *pw == UNICODE_NULL )
        {
            //
            // Remember the original character
            //

            WCHAR  wcOriginal = *pw;
            UNICODE_STRING DirectoryName;

            //
            // Time to create the directory so far
            //

            *pw = UNICODE_NULL;

            RtlInitUnicodeString( &DirectoryName, pDirectoryName->Buffer );

            InitializeObjectAttributes(
                &ObjectAttributes,
                &DirectoryName,
                OBJ_CASE_INSENSITIVE |
                    UL_KERNEL_HANDLE,
                NULL,
                NULL
                );

            Status = ZwCreateFile(
                &hDirectory,
                FILE_LIST_DIRECTORY|FILE_TRAVERSE,
                &ObjectAttributes,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN_IF,
                FILE_DIRECTORY_FILE,
                NULL,
                0
                );

            //
            // Restore the original character
            //

            *pw = wcOriginal;

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }

            Status = ZwClose(hDirectory);

            if (NT_SUCCESS(Status) == FALSE)
            {
                goto end;
            }
        }
    }
    while( *pw != UNICODE_NULL );

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,
            ("Ul!UlpCreateSafeDirectory: directory %S, failure %08lx\n",
              pDirectoryName->Buffer,
              Status
              ));
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpCalculateTimeToExpire :

        Shamelessly stolen from IIS 5.1 Logging code and adapted here.
        This routine returns the time-to-expire in hours. 1 means the log
        will expire in the next timer-fire and so ...

Arguments:

    PTIME_FIELDS        - Current Time Fields
    HTTP_LOGGING_PERIOD - Logging Period
    PULONG              - Pointer to a buffer to receive result

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpCalculateTimeToExpire(
     PTIME_FIELDS           pDueTime,
     HTTP_LOGGING_PERIOD    LogPeriod,
     PULONG                 pTimeRemaining
     )
{
    NTSTATUS    Status;
    ULONG       NumDays;

    PAGED_CODE();

    ASSERT(pDueTime!=NULL);
    ASSERT(pTimeRemaining!=NULL);

    Status = STATUS_SUCCESS;

    switch (LogPeriod)
    {
        case HttpLoggingPeriodMaxSize:
             return Status;

        case HttpLoggingPeriodHourly:
             *pTimeRemaining = 1;
             break;

        case HttpLoggingPeriodDaily:
             *pTimeRemaining = 24 - pDueTime->Hour;
             break;

        case HttpLoggingPeriodWeekly:
        {
            ULONG TimeRemainingInTheMonth;
            NumDays = UlpGetMonthDays(pDueTime);

            TimeRemainingInTheMonth =
                NumDays*24 - ((pDueTime->Day-1)*24 + pDueTime->Hour);

            // Time Remaining in the week
            // Sunday = 0, Monday = 1 ... Saturday = 6

            *pTimeRemaining =
                7*24 - (pDueTime->Weekday*24 + pDueTime->Hour);

             //
             // If the time remaining in the month less than time remaining in
             // the week then we have to recycle at the end of the month.
             // Otherwise we have to recycle at the end of the week. (next sunday)
             //

             if (TimeRemainingInTheMonth < *pTimeRemaining)
             {
                *pTimeRemaining = TimeRemainingInTheMonth;
             }
        }
            break;

        case HttpLoggingPeriodMonthly:
        {
            NumDays = UlpGetMonthDays(pDueTime);

            //
            // Lets not forget that the day starts from 1 .. 31
            // Therefore we have to subtract one from the day value.
            //

            *pTimeRemaining =
                NumDays*24 - ((pDueTime->Day-1)*24 + pDueTime->Hour);
        }
            break;

        default:
            ASSERT(FALSE);
            return STATUS_INVALID_PARAMETER;
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    Initializes the Log & buffering Timers

--***************************************************************************/
VOID
UlpInitializeTimers(
    VOID
    )
{
    /* Log timer */

    g_LogTimerInitialized = TRUE;

    UlInitializeSpinLock( &g_LogTimerSpinLock, "g_LogTimerSpinLock" );

    KeInitializeDpc(
        &g_LogTimerDpcObject,         // DPC object
        &UlLogTimerDpcRoutine,        // DPC routine
        NULL                          // context
        );

    KeInitializeTimer( &g_LogTimer );

    /* Buffer timer */

    g_BufferTimerInitialized = TRUE;

    UlInitializeSpinLock( &g_BufferTimerSpinLock, "g_BufferTimerSpinLock" );

    KeInitializeDpc(
        &g_BufferTimerDpcObject,         // DPC object
        &UlBufferTimerDpcRoutine,        // DPC routine
        NULL                             // context
        );

    KeInitializeTimer( &g_BufferTimer );
}

/***************************************************************************++

Routine Description:

    Terminates the Log & buffering Timers

--***************************************************************************/

VOID
UlpTerminateTimers(
    VOID
    )
{
    KIRQL oldIrql;

    /* Log timer */

    if ( g_LogTimerInitialized )
    {
        UlAcquireSpinLock( &g_LogTimerSpinLock, &oldIrql );

        g_LogTimerInitialized = FALSE;

        UlReleaseSpinLock( &g_LogTimerSpinLock,  oldIrql );

        KeCancelTimer( &g_LogTimer );
    }

    /* Buffer timer */

    if ( g_BufferTimerInitialized )
    {
        UlAcquireSpinLock( &g_BufferTimerSpinLock, &oldIrql );

        g_BufferTimerInitialized = FALSE;

        UlReleaseSpinLock( &g_BufferTimerSpinLock,  oldIrql );

        KeCancelTimer( &g_BufferTimer );
    }
}

/***************************************************************************++

Routine Description:

    UlpSetTimer :

        This routine provides the initial due time for the upcoming
        periodic hourly timer. We have to align the timer so that it
        get signaled at the beginning of each hour. Then it goes with
        an hour period until stops.

        We keep ONLY one timer for all log periods. A DPC routine will
        get called every hour, and it will traverse the log list and
        do the cycling properly.

Arguments:

    PTIME_FIELDS  - Current Time

Return Value:

    NTSTATUS    - Completion status.

--***************************************************************************/

VOID
UlpSetLogTimer(
     PTIME_FIELDS   pFields
     )
{
    LONGLONG      InitialDueTime100Ns;
    LARGE_INTEGER InitialDueTime;

    ASSERT(pFields!=NULL);

    //
    // Remaining time to next hour tick. In seconds
    //

    InitialDueTime100Ns =
        1*60*60 - ( pFields->Minute*60 + pFields->Second );

    //
    //  Also convert it to 100-ns
    //

    InitialDueTime100Ns =
        (InitialDueTime100Ns*1000 - pFields->Milliseconds ) * 1000 * 10;

    //
    // Negative time for relative value.
    //

    InitialDueTime.QuadPart = -InitialDueTime100Ns;

    KeSetTimerEx(
            &g_LogTimer,
            InitialDueTime,
            1*60*60*1000,                   // Period of 1 Hours in millisec
            &g_LogTimerDpcObject
            );
}

/***************************************************************************++

Routine Description:

    UlpSetBufferTimer :

        We have to introduce a new timer for the log buffering mechanism.
        Each log file keeps a system default (64K) buffer do not flush this
        out unless it's full or this timer get fired every MINUTE.

        The hourly timer get aligned for the beginning of each hour. Therefore
        using that existing timer would introduce alot of complexity.

Arguments:

    PTIME_FIELDS  - Current Time

--***************************************************************************/

VOID
UlpSetBufferTimer(
    VOID
    )
{
    LONGLONG        BufferPeriodTime100Ns;
    LONG            BufferPeriodTimeMs;
    LARGE_INTEGER   BufferPeriodTime;

    //
    // Remaining time to next tick. DEFAULT_BUFFER_TIMER_PERIOD is in minutes
    //

    BufferPeriodTimeMs    = DEFAULT_BUFFER_TIMER_PERIOD * 60 * 1000;
    BufferPeriodTime100Ns = (LONGLONG) BufferPeriodTimeMs * 10 * 1000;

    UlTrace(LOGGING,
        ("Ul!UlpSetBufferTimer: %d seconds\n",
          BufferPeriodTimeMs / 1000
          ));

    //
    // Negative time for relative value.
    //

    BufferPeriodTime.QuadPart = -BufferPeriodTime100Ns;

    KeSetTimerEx(
            &g_BufferTimer,
            BufferPeriodTime,           // Must be in nanosec
            BufferPeriodTimeMs,         // Must be in millisec
            &g_BufferTimerDpcObject
            );
}

/***************************************************************************++

Routine Description:

    UlLogTimerHandler :

        Work item for the threadpool that goes thru the log list and
        cycle the necessary logs.

Arguments:

    PUL_WORK_ITEM   -  Ignored

Return Value:

    None

--***************************************************************************/

VOID
UlLogTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY  pEntry;

    PAGED_CODE();

    UlTrace(LOGGING,("Ul!UlLogTimerHandler: Scanning the log entries\n"));

    UlAcquireResourceExclusive(&g_pUlNonpagedData->LogListResource, TRUE);

    // Attempt to reinit the GMT offset every hour, to pickup the changes
    // because of the day light changes. Synced by the logging eresource.

    UlpGetGMTOffset();

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {
        pEntry = CONTAINING_RECORD(
                            pLink,
                            UL_LOG_FILE_ENTRY,
                            LogFileListEntry
                            );
        //
        // We should not recycle this entry if it's period
        // is not time based but size based.
        //

        UlAcquireResourceExclusive(&pEntry->EntryResource, TRUE);

        if (pEntry->Period != HttpLoggingPeriodMaxSize)
        {
            if (pEntry->TimeToExpire==1)
            {
                // TODO: Don't recycle if the entries logging is disabled.

                SET_TIME_TO_EXPIRE_STALE(pEntry);

                Status = UlpRecycleLogFile(pEntry);
            }
            else
            {
                //
                // Just decrement the hourly counter
                // for this time.
                //

                pEntry->TimeToExpire -= 1;
            }
        }

        UlReleaseResource(&pEntry->EntryResource);
    }

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    //
    // Free the memory allocated (ByDpcRoutine below) to
    // this work item.
    //

    UL_FREE_POOL( pWorkItem, UL_WORK_ITEM_POOL_TAG );

}

/***************************************************************************++

Routine Description:

    UlLogTimerDpcRoutine :

Arguments:

    Ignored

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

VOID
UlLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_WORK_ITEM pWorkItem;

    UlAcquireSpinLockAtDpcLevel(
        &g_LogTimerSpinLock
        );

    if( g_LogTimerInitialized )
    {
        //
        // It's not possible to acquire the resource which protects
        // the log list at DISPATCH_LEVEL therefore we will queue a
        // work item for this.
        //

        pWorkItem = (PUL_WORK_ITEM) UL_ALLOCATE_POOL(
            NonPagedPool,
            sizeof(*pWorkItem),
            UL_WORK_ITEM_POOL_TAG
            );
        if ( pWorkItem )
        {
            UL_QUEUE_WORK_ITEM(
                pWorkItem,
                &UlLogTimerHandler
                );
        }
        else
        {
            UlTrace(LOGGING,("Ul!UlLogTimerDpcRoutine: Not enough memory.\n"));
        }
    }

    UlReleaseSpinLockFromDpcLevel(
        &g_LogTimerSpinLock
        );
}

/***************************************************************************++

Routine Description:

    UlBufferTimerDpcRoutine :

Arguments:

    Ignored

--***************************************************************************/

VOID
UlBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    )
{
    PUL_WORK_ITEM pWorkItem;

    UlAcquireSpinLockAtDpcLevel( &g_BufferTimerSpinLock );

    if( g_BufferTimerInitialized )
    {
        //
        // It's not possible to acquire the resource which protects
        // the log list at DISPATCH_LEVEL therefore we will queue a
        // work item for this.
        //

        pWorkItem = (PUL_WORK_ITEM) UL_ALLOCATE_POOL(
            NonPagedPool,
            sizeof(*pWorkItem),
            UL_WORK_ITEM_POOL_TAG
            );
        if ( pWorkItem )
        {
            UL_QUEUE_WORK_ITEM(
                pWorkItem,
                &UlBufferTimerHandler
                );
        }
        else
        {
            UlTrace(LOGGING,("Ul!UlBufferTimerDpcRoutine: Not enough memory.\n"));
        }
    }

    UlReleaseSpinLockFromDpcLevel( &g_BufferTimerSpinLock );
}

/***************************************************************************++

Routine Description:

    UlLogBufferTimerHandler :

        Work item for the threadpool that goes thru the log list and
        flush the log's file buffers.

Arguments:

    PUL_WORK_ITEM   -  Ignored but cleaned up at the end

--***************************************************************************/

VOID
UlBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    NTSTATUS Status;
    PLIST_ENTRY pLink;
    PUL_LOG_FILE_ENTRY  pEntry;

    PAGED_CODE();

    UlTrace(LOGGING,("Ul!UlBufferTimerHandler: scanning the log entries ...\n"));

    UlAcquireResourceShared(&g_pUlNonpagedData->LogListResource, TRUE);

    for (pLink  = g_LogListHead.Flink;
         pLink != &g_LogListHead;
         pLink  = pLink->Flink
         )
    {
        pEntry = CONTAINING_RECORD(
                            pLink,
                            UL_LOG_FILE_ENTRY,
                            LogFileListEntry
                            );

        UlAcquireResourceExclusive(&pEntry->EntryResource, TRUE);

        Status = UlpFlushLogFile( pEntry );

        // TODO: Handle STATUS_DISK_FULL

        UlReleaseResource(&pEntry->EntryResource);
    }

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    //
    // Free the memory allocated (ByDpcRoutine below) to
    // this work item.
    //

    UL_FREE_POOL( pWorkItem, UL_WORK_ITEM_POOL_TAG );

}

/***************************************************************************++

Routine Description:

    UlpGrowLogEntry:

        All it does is to grow the log file entry in the log list. So that
        recycle function later on can successfully updates the new log file
        name. This function get called only when Dir Name is changed. Because
        only that case causes us to enlarge the already allocated name buffer.
        Name changes originated from timer based or size based recycling
        does not require us to enlarge as we initially allocates more than enough
        buffer for those changes.

        You should HAVE the log list resource exclusively before calling
        this function.

Arguments:

        too many

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpGrowLogEntry(
    IN PUL_CONFIG_GROUP_OBJECT    pConfigGroup,
    IN PUL_LOG_FILE_ENTRY         pOldEntry
    )
{
    NTSTATUS            Status;
    USHORT              FullPathFileNameLength;
    UNICODE_STRING      JunkFileName;
    PUL_LOG_FILE_ENTRY  pEntry;
    UNICODE_STRING      DosDevice;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pConfigGroup != NULL);
    ASSERT(pOldEntry != NULL);

    Status = STATUS_SUCCESS;
    pEntry = NULL;

    // TODO: Get rid of this function by making sure that log entry never grows.
    // TODO: It means Allocating the Log Dir Name separately not inline.

    UlTrace( LOGGING, ("Ul!UlpGrowLogEntry: old_entry %p\n", pOldEntry ));

    RtlInitUnicodeString( &JunkFileName, L"\\none.log" );


    FullPathFileNameLength= UL_MAX_PATH_PREFIX_LENGTH +
                            pConfigGroup->LoggingConfig.LogFileDir.Length +
                            (UL_MAX_FILE_NAME_SUFFIX_LENGTH+1) * sizeof(WCHAR);

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_LOG_FILE_ENTRY,
                    FullPathFileNameLength,
                    UL_LOG_FILE_ENTRY_POOL_TAG
                    );

    if ( pEntry == NULL )
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto end;
    }

    RtlZeroMemory( pEntry, sizeof(*pEntry) );
    pEntry->Signature = UL_LOG_FILE_ENTRY_POOL_TAG;

    *pEntry = *pOldEntry;

    //
    // Construct a default dir_name. Don't worry about the
    // L"none.log", it will be overwritten by the recycler
    // later on, as long as there's MAX_LOG_FILE_NAME_SIZE
    // space for the time/type dependent part of the file
    // name ( aka short file name ), it's all right.
    //

    pEntry->FileName.Length        = 0;
    pEntry->FileName.MaximumLength = FullPathFileNameLength;
    pEntry->FileName.Buffer        = (PWSTR) ( pEntry + 1 );

    if (pConfigGroup->LoggingConfig.LogFileDir.Buffer[0] == L'\\')
    {
        if (pConfigGroup->LoggingConfig.LogFileDir.Buffer[1] == L'\\')
        {
            // UNC share: "\\alitudev\temp"
            RtlInitUnicodeString( &DosDevice, UL_UNC_PATH_PREFIX );
        }
        else
        {
            // Local Directory name is missing the device i.e "\temp"
            // It should be fully qualified name.
            Status = STATUS_NOT_SUPPORTED;
            goto end;
        }

        // Skip second backslash for the UNC path
        RtlCopyUnicodeString( &pEntry->FileName, &DosDevice );
        RtlCopyMemory(
           &(pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)]),
           &(pConfigGroup->LoggingConfig.LogFileDir.Buffer[1]),
            pConfigGroup->LoggingConfig.LogFileDir.Length - sizeof(WCHAR)
        );
        pEntry->FileName.Length +=
            (pConfigGroup->LoggingConfig.LogFileDir.Length - sizeof(WCHAR));
    }
    else
    {
        RtlInitUnicodeString( &DosDevice, UL_LOCAL_PATH_PREFIX );
        RtlCopyUnicodeString( &pEntry->FileName, &DosDevice );
        RtlAppendUnicodeStringToString(
                &pEntry->FileName,
                &(pConfigGroup->LoggingConfig.LogFileDir)
                );
    }

    pEntry->pShortName =
        (PWSTR) &pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)];

    Status = RtlAppendUnicodeStringToString(
                &pEntry->FileName,
                &JunkFileName
                );
    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Do the replacement here
    //

    RemoveEntryList(&pOldEntry->LogFileListEntry);

    pOldEntry->LogFileListEntry.Flink =
        pOldEntry->LogFileListEntry.Blink = NULL;

    //
    // Restore/Carry the buffer from the old entry
    //

    pEntry->Flags.LogTitleWritten = pOldEntry->Flags.LogTitleWritten;
    
    pEntry->LogBuffer = pOldEntry->LogBuffer;

    KeInitializeEvent(&pEntry->CloseEvent, NotificationEvent, FALSE);

    // Create the new entries eresource
    Status = UlInitializeResource(&pEntry->EntryResource,"EntryResource",0,
                                  UL_LOG_FILE_ENTRY_POOL_TAG);
    ASSERT(NT_SUCCESS(Status));

    // Delete old entry eresource
    Status = UlDeleteResource( &pOldEntry->EntryResource );
    ASSERT(NT_SUCCESS(Status));

    UL_FREE_POOL_WITH_SIG(pOldEntry,UL_LOG_FILE_ENTRY_POOL_TAG);

    InsertHeadList(&g_LogListHead, &pEntry->LogFileListEntry);

    pConfigGroup->pLogFileEntry = pEntry;

    //
    // Lets return happily
    //

end:
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,
                 ("Ul!UlpGrowLogEntry: old_entry %p, file %S, failure %08lx\n",
                        pOldEntry,
                        pOldEntry->FileName.Buffer,
                        Status
                        ));
        if (pEntry)
        {
            NTSTATUS TempStatus;

            // Delete the entry eresource
            TempStatus = UlDeleteResource( &pEntry->EntryResource );
            ASSERT(NT_SUCCESS(TempStatus));

            UL_FREE_POOL_WITH_SIG(pEntry,UL_LOG_FILE_ENTRY_POOL_TAG);
        }
    }
    return Status;
}


/***************************************************************************++

Routine Description:

    UlReconfigureLogEntry :

        This function implements the logging reconfiguration per attribute.
        Everytime config changes happens we try to update the existing logging
        parameters here.

Arguments:

    pConfig         - corresponding cgroup object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlReConfigureLogEntry(
    IN  PUL_CONFIG_GROUP_OBJECT     pConfigGroup,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    )
{
    NTSTATUS            Status ;
    BOOLEAN             HaveToReCycle;

    //
    // Sanity check first
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;
    HaveToReCycle = FALSE;

    UlTrace( LOGGING, ("Ul!UlReConfigureLogEntry: entry %p\n",
                        pConfigGroup->pLogFileEntry ));

    if ( pCfgOld->LoggingEnabled==FALSE && pCfgNew->LoggingEnabled==FALSE )
    {
        //
        // Do Nothing. Not Even update the fields
        // as soon as we get enable request,
        // field update will take place anyway.
        //

        return Status;
    }

    if ( pCfgOld->LoggingEnabled==TRUE  && pCfgNew->LoggingEnabled==FALSE )
    {
        //
        // Stop logging but keep the entry in the
        // list. CODEWORK do we have to keep this info
        // in the entry itself and when we recycle the
        // logs based on timer, we do not recycle the
        // ones with logging disabled ??
        //

        pCfgOld->LoggingEnabled = FALSE;
        return Status;
    }
    else
    {
        pCfgOld->LoggingEnabled = TRUE;
    }

    if ( pCfgNew->LogFormat >= HttpLoggingTypeMaximum ||
         pCfgNew->LogPeriod >= HttpLoggingPeriodMaximum )
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // An important check to ensure that no infinite loop occurs because of
    // ridiculusly small truncatesizes. Means smaller than maximum
    // allowed log record line (10*1024)
    //

    if ( pCfgNew->LogPeriod           == HttpLoggingPeriodMaxSize  &&
         pCfgNew->LogFileTruncateSize != HTTP_LIMIT_INFINITE &&
         pCfgNew->LogFileTruncateSize <  UL_MIN_ALLOWED_TRUNCATESIZE
        )
    {
        UlTrace( LOGGING,
          ("Ul!UlReConfigureLogEntry: Truncate size too small %d !\n",
            pCfgNew->LogFileTruncateSize
            ));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // No matter what ReConfiguration should acquire the LogListResource
    // exclusively.
    //

    UlAcquireResourceExclusive(&g_pUlNonpagedData->LogListResource, TRUE);

    //
    // Proceed down to see if anything else changed
    // as well ...
    //

    if ( RtlCompareUnicodeString(
           &pCfgNew->LogFileDir, &pCfgOld->LogFileDir, TRUE ) != 0
       )
    {
        //
        // Always force ReGrow otherwise dir name won't be updated
        // Update the cgroup to hold the new log_dir name
        //

        if (pCfgOld->LogFileDir.Buffer != NULL)
        {
                UL_FREE_POOL(
                    pCfgOld->LogFileDir.Buffer,
                    UL_CG_LOGDIR_POOL_TAG
                    );
                pCfgOld->LogFileDir.Buffer = NULL;
        }

        pCfgOld->LogFileDir.Buffer =
                (PWSTR) UL_ALLOCATE_ARRAY(
                            PagedPool,
                            UCHAR,
                            pCfgNew->LogFileDir.MaximumLength,
                            UL_CG_LOGDIR_POOL_TAG
                            );
        if (pCfgOld->LogFileDir.Buffer == NULL)
        {
            pCfgOld->LogFileDir.Length = 0;
            pCfgOld->LogFileDir.MaximumLength = 0;
            Status = STATUS_NO_MEMORY;
            goto end;
        }

        RtlCopyMemory(
                pCfgOld->LogFileDir.Buffer,
                pCfgNew->LogFileDir.Buffer,
                pCfgNew->LogFileDir.MaximumLength
                );

        pCfgOld->LogFileDir.Length = pCfgNew->LogFileDir.Length;
        pCfgOld->LogFileDir.MaximumLength = pCfgNew->LogFileDir.MaximumLength;

        UlpGrowLogEntry( pConfigGroup, pConfigGroup->pLogFileEntry );

        // Need to find the proper sequence number after scanning the new
        // log directory.

        SET_SEQUNCE_NUMBER_STALE(pConfigGroup->pLogFileEntry);

        HaveToReCycle = TRUE;

    }

    if ( pCfgNew->LogFormat != pCfgOld->LogFormat )
    {
        Status = UlpUpdateFormat(
                    pConfigGroup->pLogFileEntry,
                    pCfgOld,
                    pCfgNew
                    );
        goto end;
    }

    if ( pCfgNew->LogPeriod != pCfgOld->LogPeriod )
    {
        Status = UlpUpdatePeriod(
                    pConfigGroup->pLogFileEntry,
                    pCfgOld,
                    pCfgNew
                    );
        goto end;
    }

    //
    // Both LogFormat and LogPeriod always trigger the recycle and they also
    // handle changes to the LogFileTruncateSize and LogExtFileFlags before
    // triggering the recycle. Therefore we can bail out safely.
    //

    if ( pCfgNew->LogFileTruncateSize != pCfgOld->LogFileTruncateSize )
    {
        Status = UlpUpdateLogTruncateSize(
                    pConfigGroup->pLogFileEntry,
                    pCfgOld,
                    pCfgNew,
                    &HaveToReCycle
                    );
    }

    if ( pCfgNew->LogExtFileFlags != pCfgOld->LogExtFileFlags )
    {
        //
        // Just a change in the flags should not cause us to recyle.
        // Unless something else is also changed. If that's the case
        // then it's either handled above us, or will be handled down
        //

        Status = UlpUpdateLogFlags(
                    pConfigGroup->pLogFileEntry,
                    pCfgOld,
                    pCfgNew
                    );
    }

    if ( HaveToReCycle )
    {
        //
        // If we are here that means directory name has been changed
        // and nobody has recycled the log file yet. So time to go
        //

        Status = UlpRecycleLogFile(pConfigGroup->pLogFileEntry);
    }

  end:

    if (NT_SUCCESS(Status) == FALSE)
    {
        UlTrace( LOGGING,
                 ("Ul!UlReConfigureLogEntry: entry %p, failure %08lx\n",
                        pConfigGroup->pLogFileEntry,
                        Status
                        ));
    }

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    return Status;
} // UlReConfigureLogEntry

/***************************************************************************++

Routine Description:

    UlpUpdateFormat :

Arguments:

    pConfig - corresponding cgroup object

--***************************************************************************/

NTSTATUS
UlpUpdateFormat(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    )
{
    NTSTATUS            Status ;
    TIME_FIELDS         CurrentTimeFields;
    LARGE_INTEGER       CurrentTimeStamp;

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    if ( pEntry == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pCfgOld->LogFormat==pEntry->Format);

    pCfgOld->LogFormat          = pCfgNew->LogFormat;
    pEntry->Format              = pCfgNew->LogFormat;

    pCfgOld->LogPeriod          = pCfgNew->LogPeriod;
    pEntry->Period              = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;

    pEntry->TruncateSize        = pCfgNew->LogFileTruncateSize;
    pCfgOld->LogFileTruncateSize= pCfgNew->LogFileTruncateSize;

    pEntry->LogExtFileFlags     = pCfgNew->LogExtFileFlags;
    pCfgOld->LogExtFileFlags    = pCfgNew->LogExtFileFlags;

    KeQuerySystemTime( &CurrentTimeStamp );
    RtlTimeToTimeFields( &CurrentTimeStamp, &CurrentTimeFields );

    if ( pEntry->Period != HttpLoggingPeriodMaxSize )
    {
        Status = UlpCalculateTimeToExpire(
                        &CurrentTimeFields,
                        pEntry->Period,
                        &pEntry->TimeToExpire
                        );

        ASSERT(NT_SUCCESS(Status)==TRUE);
    }

    ASSERT(NT_SUCCESS(Status)==TRUE);

    SET_SEQUNCE_NUMBER_STALE(pEntry);

    Status = UlpRecycleLogFile( pEntry );

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpUpdatePeriod :

Arguments:

    pConfig  - corresponding cgroup object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpUpdatePeriod(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    )
{
    NTSTATUS            Status ;
    TIME_FIELDS         CurrentTimeFields;
    LARGE_INTEGER       CurrentTimeStamp;

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    if ( pEntry == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pCfgOld->LogPeriod==(ULONG)pEntry->Period);

    pCfgOld->LogPeriod          = pCfgNew->LogPeriod;
    pEntry->Period              = (HTTP_LOGGING_PERIOD) pCfgNew->LogPeriod;

    pEntry->TruncateSize        = pCfgNew->LogFileTruncateSize;
    pCfgOld->LogFileTruncateSize= pCfgNew->LogFileTruncateSize;

    pEntry->LogExtFileFlags     = pCfgNew->LogExtFileFlags;
    pCfgOld->LogExtFileFlags    = pCfgNew->LogExtFileFlags;

    KeQuerySystemTime( &CurrentTimeStamp );
    RtlTimeToTimeFields( &CurrentTimeStamp, &CurrentTimeFields );

    if ( pEntry->Period != HttpLoggingPeriodMaxSize )
    {
        Status = UlpCalculateTimeToExpire(
                        &CurrentTimeFields,
                        pEntry->Period,
                        &pEntry->TimeToExpire
                        );

        ASSERT(NT_SUCCESS(Status)==TRUE);
    }

    SET_SEQUNCE_NUMBER_STALE(pEntry);

    Status = UlpRecycleLogFile( pEntry );

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpUpdateLogTruncateSize :

Arguments:

    pConfig  - corresponding cgroup object

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpUpdateLogTruncateSize(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew,
    OUT BOOLEAN *                   pHaveToReCycle
    )
{
    NTSTATUS            Status ;

    //
    // Sanity check first
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    //
    // For MAX_SIZE period type we should check if
    //  limited => unlimited:
    //      we can still use the last log file
    //  unlimited => limited:
    //      we should open a new one if old size is larger than
    //      the new limitation
    //

    if ( pEntry == NULL )
    {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pCfgOld->LogFileTruncateSize==pEntry->TruncateSize);

    if ( pCfgOld->LogPeriod == HttpLoggingPeriodMaxSize )
    {
            if ( pCfgOld->LogFileTruncateSize == HTTP_LIMIT_INFINITE )
            {
                //
                // Unlimited to Limited
                //

                if ( pEntry->TotalWritten.QuadPart >
                    (ULONGLONG)pCfgNew->LogFileTruncateSize )
                {
                    // In case flags get changed lets take it too
                    pEntry->LogExtFileFlags     = pCfgNew->LogExtFileFlags;
                    pCfgOld->LogExtFileFlags    = pCfgNew->LogExtFileFlags;

                    UlpRecycleLogFile( pEntry );

                    *pHaveToReCycle = FALSE;
                }
            }
            else
            {
                //
                // Limited to Unlimited
                // Nothing special to do
                //
            }
    }

    pEntry->TruncateSize  = pCfgNew->LogFileTruncateSize;
    pCfgOld->LogFileTruncateSize = pCfgNew->LogFileTruncateSize;

    return Status;
}

/***************************************************************************++

Routine Description:

    UlpUpdateLogFlags :

    REQUIRES caller to have loglist resource exclusively.

Arguments:

    pEntry  - corresponding logfile entry

    old & new configuration

--***************************************************************************/

NTSTATUS
UlpUpdateLogFlags(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    )
{
    NTSTATUS            Status ;
    TIME_FIELDS         CurrentTimeFields;
    LARGE_INTEGER       CurrentTimeStamp;

    //
    // No need to do anything else, we will
    // just display a new title with the
    // new fields.
    //

    PAGED_CODE();
    Status = STATUS_SUCCESS;

    if (pEntry == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));
    ASSERT(pCfgOld->LogExtFileFlags==pEntry->LogExtFileFlags);

    pCfgOld->LogExtFileFlags = pCfgNew->LogExtFileFlags;
    pEntry->LogExtFileFlags  = pCfgNew->LogExtFileFlags;

    if (pEntry->Format == HttpLoggingTypeW3C)
    {
        pEntry->Flags.LogTitleWritten = 0;
    }

    return Status;
}


/***************************************************************************++

Routine Description:

    UlpConstructLogFileEntry :

        Finds out the correct file name for the newly created log file
        from our - current time dependent- time-to-name converters. Also
        allocates the necessary file entry from paged pool. This entry get
        removed from the list when the corresponding config group object
        has been destroyed. At that time RemoveLogFile entry called and
        it frees this memory.

Arguments:

    pConfig         - corresponding cgroup object
    ppEntry         - will point to newly created entry
    pDirectoryName  - the directory name to store newcoming log file

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/

NTSTATUS
UlpConstructLogFileEntry(
    IN  PHTTP_CONFIG_GROUP_LOGGING pConfig,
    OUT PUL_LOG_FILE_ENTRY       * ppEntry,
    OUT PUNICODE_STRING            pDirectoryName,
    IN  PTIME_FIELDS               pCurrentTimeFields
    )
{
    NTSTATUS            Status,TmpStatus;
    USHORT              FullPathFileNameLength;
    ULONG               SequenceNumber;
    PUL_LOG_FILE_ENTRY  pEntry;
    WCHAR              _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH+1];
    UNICODE_STRING      FileName =
        { 0, (UL_MAX_FILE_NAME_SUFFIX_LENGTH+1)*sizeof(WCHAR), _FileName };

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pConfig != NULL);
    ASSERT(ppEntry != NULL);

    Status = STATUS_SUCCESS;
    SequenceNumber = 1;
    pEntry = NULL;

    FullPathFileNameLength = pDirectoryName->Length;

    UlpConstructFileName(
            (HTTP_LOGGING_PERIOD) pConfig->LogPeriod,
            UL_GET_LOG_FILE_NAME_PREFIX(pConfig->LogFormat),
            &FileName,
            pCurrentTimeFields,
            &SequenceNumber
            );

    FullPathFileNameLength += FileName.Length;

    //
    // Allocate a memory for our new logfile entry in the list.
    // To avoid the frequent reallocs for the log entry - E.g.
    // we receive a timer update and filename changes according to
    // new time - , We will try to allocate a fixed amount here
    // for all the possible file_names ( this doesn't include
    // the log_dir changes may happen from WAS through cgroup
    // in that case we will realloc a new entry ). It has to
    // be nonpaged because it holds a eresource.
    //

    pEntry = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_LOG_FILE_ENTRY,
                    (UL_MAX_FILE_NAME_SUFFIX_LENGTH + 1) * sizeof(WCHAR) +
                    pDirectoryName->Length,
                    UL_LOG_FILE_ENTRY_POOL_TAG
                    );

    if ( pEntry == NULL )
    {
        Status = STATUS_NO_MEMORY;
        goto end;
    }

    RtlZeroMemory( pEntry, sizeof(*pEntry) );
    pEntry->Signature = UL_LOG_FILE_ENTRY_POOL_TAG;

    //
    // Concat the directory & file name properly.
    //

    pEntry->FileName.Length       = FullPathFileNameLength;
    pEntry->FileName.MaximumLength= (UL_MAX_FILE_NAME_SUFFIX_LENGTH+1) * sizeof(WCHAR) +
                                        pDirectoryName->Length;

    pEntry->FileName.Buffer       = (PWSTR) ( pEntry + 1 );

    RtlCopyUnicodeString( &(pEntry->FileName), pDirectoryName );
    Status = RtlAppendUnicodeStringToString( &(pEntry->FileName), &FileName );
    ASSERT(NT_SUCCESS(Status));

    pEntry->FileName.Buffer[FullPathFileNameLength/sizeof(WCHAR)] = UNICODE_NULL;
    pEntry->pShortName = (PWSTR)
        &(pEntry->FileName.Buffer[pDirectoryName->Length/sizeof(WCHAR)]);

    //
    // Create a log entry buffer of system dependent size
    // typically 64K
    //

    Status = UlInitializeResource(&pEntry->EntryResource,"EntryResource",0,
                                  UL_LOG_FILE_ENTRY_POOL_TAG);
    ASSERT(NT_SUCCESS(Status));

    //
    // Initialize the file handle
    //

    pEntry->hFile = NULL;

    KeInitializeEvent(&pEntry->CloseEvent, NotificationEvent, FALSE);

    //
    // Set the logging information from config group
    // easier for other routines to use this values
    // w/o reaching to the config-group
    //

    pEntry->Format = pConfig->LogFormat;
    pEntry->Period = (HTTP_LOGGING_PERIOD) pConfig->LogPeriod;
    pEntry->TruncateSize = pConfig->LogFileTruncateSize;
    pEntry->LogExtFileFlags = pConfig->LogExtFileFlags;

    //
    // Time to initialize our Log Cycling parameter
    //

    pEntry->TimeToExpire = 0;
    pEntry->SequenceNumber = SequenceNumber;
    pEntry->TotalWritten.QuadPart = (ULONGLONG)0;

    pEntry->Flags.Value = 0;

    if (pEntry->Format == HttpLoggingTypeW3C)
    {
        pEntry->Flags.LogTitleWritten = 0;
    }
    else
    {
        pEntry->Flags.LogTitleWritten = 1;
    }
        
    pEntry->LogBuffer = NULL;

    Status = UlpCalculateTimeToExpire(
                        pCurrentTimeFields,
                        pEntry->Period,
                        &pEntry->TimeToExpire
                        );
    if ( !NT_SUCCESS(Status) )
    {
        goto end;
    }

    //
    // Lets happily return our entry
    //

    *ppEntry = pEntry;

end:
    if ( !NT_SUCCESS(Status) )
    {
        if ( pEntry )
        {
            NTSTATUS TempStatus;

            if ( pEntry->LogBuffer )
            {
               UlPplFreeLogBuffer( pEntry->LogBuffer );
            }
            // Delete the entry eresource
            TempStatus = UlDeleteResource( &pEntry->EntryResource );
            ASSERT(NT_SUCCESS(TempStatus));

            UL_FREE_POOL_WITH_SIG( pEntry, UL_LOG_FILE_ENTRY_POOL_TAG );
        }
    }
    return Status;
}

/***************************************************************************++

Routine Description:

    UlpConstructFileName:

        A bunch of current_time TO file_name conversions comes here ...

Arguments:

    period      - period type of the log
    prefix      - any prefix to be added to the file name
    filename    - result file name
    fields      - time fields

Return Value:

    VOID - No return value.

--***************************************************************************/

VOID
UlpConstructFileName(
    IN      HTTP_LOGGING_PERIOD period,
    IN      PCWSTR              prefix,
    OUT     PUNICODE_STRING     filename,
    IN      PTIME_FIELDS        fields,
    IN OUT  PULONG              sequenceNu  //OPTIONAL
    )
{
    WCHAR           _tmp[UL_MAX_FILE_NAME_SUFFIX_LENGTH+1];
    UNICODE_STRING  tmp = { 0, 0, _tmp };
    CSHORT          Year;
    LONG            WcharsCopied = 0L;

    PAGED_CODE();

    //
    // Retain just last 2 digits of the Year
    //

    tmp.MaximumLength = (UL_MAX_FILE_NAME_SUFFIX_LENGTH+1) * sizeof(WCHAR);

    if (fields)
    {
        Year = fields->Year % 100;
    }

    switch ( period )
    {
        case HttpLoggingPeriodHourly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (UTF8_LOGGING_ENABLED() ?
                        L"%.5s%02.2d%02d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    fields->Day,
                    fields->Hour,
                    DEFAULT_LOG_FILE_EXTENSION
                    );
        }
        break;

        case HttpLoggingPeriodDaily:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (UTF8_LOGGING_ENABLED() ?
                        L"%.5s%02.2d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    fields->Day,
                    DEFAULT_LOG_FILE_EXTENSION
                    );
        }
        break;

        case HttpLoggingPeriodWeekly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (UTF8_LOGGING_ENABLED() ?
                        L"%.5s%02.2d%02d%02d.%s" :
                        L"%.3s%02.2d%02d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    UlpWeekOfMonth(fields),
                    DEFAULT_LOG_FILE_EXTENSION
                    );
        }
        break;

        case HttpLoggingPeriodMonthly:
        {
            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (UTF8_LOGGING_ENABLED() ?
                        L"%.5s%02.2d%02d.%s" :
                        L"%.3s%02.2d%02d.%s"),
                    prefix,
                    Year,
                    fields->Month,
                    DEFAULT_LOG_FILE_EXTENSION
                    );
        }
        break;

        case HttpLoggingPeriodMaxSize:
        {
            if ( sequenceNu != NULL )
            {
                WcharsCopied =
                 _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    (UTF8_LOGGING_ENABLED() ?
                        L"%.9s%d.%s" :
                        L"%.7s%d.%s"),
                    prefix,
                    (*sequenceNu),
                    DEFAULT_LOG_FILE_EXTENSION
                    );

               (*sequenceNu) += 1;
            }
            else
            {
                ASSERT(!"Improper sequence number !");
            }
        }
        break;

        default:
        {
            //
            // This should never happen ...
            //

            ASSERT(!"Unknown Log Format !");

            WcharsCopied =
                _snwprintf( _tmp,
                    UL_MAX_FILE_NAME_SUFFIX_LENGTH,
                    L"%.7s?.%s",
                    prefix,
                    DEFAULT_LOG_FILE_EXTENSION
                    );
        }
    }

    //
    // As long as we allocate an enough space for a possible
    // log filename we should never hit to this assert here.
    //

    ASSERT(WcharsCopied >0 );

    if ( WcharsCopied < 0 )
    {
        //
        // This should never happen but lets cover it
        // anyway.
        //

        WcharsCopied = UL_MAX_FILE_NAME_SUFFIX_LENGTH*sizeof(WCHAR);
        tmp.Buffer[UL_MAX_FILE_NAME_SUFFIX_LENGTH] = UNICODE_NULL;
    }

    tmp.Length        = (USHORT) WcharsCopied*sizeof(WCHAR);
    tmp.MaximumLength = (UL_MAX_FILE_NAME_SUFFIX_LENGTH+1)*sizeof(WCHAR);

    RtlCopyUnicodeString( filename, &tmp );
}

/***************************************************************************++

Routine Description:

    UlpRecycleLogFile :

        This function requires to have the loglist resource shared,as well as
        the logfile entry mutex to be acquired.

        We do not want anybody to Create/Remove/ReConfig to the entry while
        we are working on it, therefore shared access to the loglist.

        We do not want anybody to Hit/Flush to the entry, therefore
        entry's mutex should be acquired.

        Or otherwise caller might have the loglist resource exclusively and
        this will automatically ensure the safety as well. As it is not
        possible for anybody else to acquire entry mutex first w/o having
        the loglist resource shared at least, according to the current
        design.

        Sometimes it may be necessary to scan the new directory to figure out
        the correct sequence numbe rand the file name. Especially after dir
        name reconfig and/or the period becomes MaskPeriod.

Arguments:

    pEntry  - Points to the existing entry.
    NeedToReCalculate - shows if we have to recalculate the time-to-expire.

--***************************************************************************/

NTSTATUS
UlpRecycleLogFile(
    IN  PUL_LOG_FILE_ENTRY  pEntry
    )
{
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    IO_STATUS_BLOCK         IoStatusBlock;
    TIME_FIELDS             CurrentTimeFields;
    LARGE_INTEGER           CurrentTimeStamp;
    PWCHAR                  pSrc;
    PWCHAR                  pDst;
    USHORT                  Index;
    USHORT                  OldFileNameLength;

    WCHAR _FileName[UL_MAX_FILE_NAME_SUFFIX_LENGTH];
    UNICODE_STRING FileName =
        { 0, UL_MAX_FILE_NAME_SUFFIX_LENGTH*sizeof(WCHAR), _FileName };

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

    Status = STATUS_SUCCESS;

    //
    // We have two criterions for the log file name
    // its LogFormat and its LogPeriod
    //

    ASSERT(pEntry->Format < HttpLoggingTypeMaximum);
    ASSERT(pEntry->Period < HttpLoggingPeriodMaximum);
    ASSERT(pEntry->FileName.Length!=0);

    UlTrace( LOGGING, ("Ul!UlpRecycleLogFile: pEntry %p \n", pEntry ));

    //
    // This value is computed for the GMT time zone.
    //

    KeQuerySystemTime( &CurrentTimeStamp );
    RtlTimeToTimeFields( &CurrentTimeStamp, &CurrentTimeFields );

    // Init total written to zero. It may get updated if we scan
    // the directory down below.

    pEntry->TotalWritten.QuadPart = (ULONGLONG)0;

    // If we need to scan the directory. Sequence number should start
    // from 1 again. Set this before constructing the log file name.

    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        // Init otherwise if QueryDirectory doesn't find any it
        // will not update this values
        pEntry->SequenceNumber = 1;
    }

    //
    // Now construct the filename using the lookup table
    // And the current time
    //

    UlpConstructFileName(
            pEntry->Period,
            UL_GET_LOG_FILE_NAME_PREFIX(pEntry->Format),
            &FileName,
            &CurrentTimeFields,
            &pEntry->SequenceNumber
            );

    if ( pEntry->FileName.MaximumLength <= FileName.Length )
    {
        ASSERT(FALSE);
        Status = STATUS_INVALID_PARAMETER;
        goto end;
    }

    //
    // Do the magic and renew the filename. Replace the old file
    // name with the new one.
    //

    ASSERT( pEntry->pShortName != NULL );
    if ( pEntry->pShortName != NULL )
    {
        //
        // Get rid of the old filename before flushing the
        // directories and reconcataneting the new file name
        // to the end again.
        //

        *((PWCHAR)pEntry->pShortName) = UNICODE_NULL;
        pEntry->FileName.Length =
            wcslen( pEntry->FileName.Buffer ) * sizeof(WCHAR);

        //
        // Create/Open the director(ies) first. This might be
        // necessary if we get called after an entry reconfiguration
        // and directory name change.
        //

        Status = UlpCreateSafeDirectory( &pEntry->FileName );
        if (!NT_SUCCESS(Status))
            goto end;

        //
        // Now Restore the short file name pointer back
        //

        pEntry->pShortName = (PWSTR)
            &(pEntry->FileName.Buffer[pEntry->FileName.Length/sizeof(WCHAR)]);

        //
        // Append the new file name ( based on updated current time )
        // to the end.
        //

        Status = RtlAppendUnicodeStringToString( &pEntry->FileName, &FileName );
        if (!NT_SUCCESS(Status))
            goto end;
    }

    //
    // If the sequence is stale because of the nature of the recycle.
    // And if our preiod is size based then rescan the new directory
    // to figure out the proper file to open.
    //

    if (pEntry->Flags.StaleSequenceNumber &&
        pEntry->Period==HttpLoggingPeriodMaxSize)
    {
        // This call may update the filename, the file size and the
        // sequence number if there is an old file in the new dir.

        Status = UlpQueryDirectory(pEntry);
        if (!NT_SUCCESS(Status))
            goto end;
    }

    //
    // Time to close the old file and reopen a new one
    //

    if (pEntry->hFile != NULL)
    {
        //
        // Before closing the old one we need to flush the buffer
        //

        UlpFlushLogFile(pEntry);

        UlpLogCloseHandle(pEntry);
    }

    InitializeObjectAttributes(
            &ObjectAttributes,
            &pEntry->FileName,      // Full path name
            OBJ_CASE_INSENSITIVE |  // Attributes
                UL_KERNEL_HANDLE,
            NULL,                   // RootDirectory
            NULL                    // SecurityDescriptor
            );

    //
    // Make the created file Aysnc by not picking the sync flag.
    //

    Status = ZwCreateFile(
            &pEntry->hFile,
            FILE_GENERIC_WRITE,
            &ObjectAttributes,
            &IoStatusBlock,
            NULL,
            FILE_ATTRIBUTE_NORMAL,
            FILE_SHARE_READ,
            FILE_OPEN_IF,
            FILE_NON_DIRECTORY_FILE,    // | FILE_SYNCHRONOUS_IO_NONALERT,
            NULL,
            0);

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Get the file size, etc from the file.
    //

    Status = ZwQueryInformationFile(
                    pEntry->hFile,
                    &IoStatusBlock,
                    &pEntry->FileInfo,
                    sizeof(pEntry->FileInfo),
                    FileStandardInformation
                    );

    if (NT_SUCCESS(Status) == FALSE)
        goto end;

    //
    // Recalculate the time to expire.
    //
    if (pEntry->Flags.StaleTimeToExpire &&
        pEntry->Period != HttpLoggingPeriodMaxSize)
    {
        UlpCalculateTimeToExpire(
                    &CurrentTimeFields,
                    pEntry->Period,
                    &pEntry->TimeToExpire
                    );
    }

    //
    // By setting the flag to zero, we mark that we need to write title with the
    // next incoming request  But this only applies to W3C format.Otherwise the flag
    // stays as set all the time, and the LogWriter doesn't attempt to write the
    // title for NCSA and IIS log formats with the next incoming request.
    //

    if (pEntry->Format == HttpLoggingTypeW3C)
    {
        pEntry->Flags.LogTitleWritten = 0;
    }
    else
    {
        pEntry->Flags.LogTitleWritten = 1;
    }

    UlTrace( LOGGING, ("Ul!UlpRecycleLogFile: entry %p, file %S, handle %lx\n",
                        pEntry,
                        pEntry->FileName.Buffer,
                        pEntry->hFile
                        ));
end:
    // Mark fields non-stale again;

    RESET_SEQUNCE_NUMBER_STALE(pEntry);
    RESET_TIME_TO_EXPIRE_STALE(pEntry);

    // TODO: Handle STATUS_DISK_FULL case gracefully.

    if ( Status == STATUS_DISK_FULL )
    {
        UlTrace(LOGGING,("UlpRecycleLogFile: DISK FULL entry %p, failure %08lx\n",
             pEntry,
             Status
            ));

        if (pEntry->hFile != NULL)
        {
            ZwClose( pEntry->hFile );
            pEntry->hFile = NULL;
        }

        // TODO: pEntry->Flags.RecyclePending = 1;
        // TODO: UlpFireDiskFullTimer();
    }

    if ( !NT_SUCCESS(Status) && Status != STATUS_DISK_FULL)
    {
        //
        // If we made it to this point, then the create/open has failed.
        //

        UlTrace( LOGGING,("Ul!UlpRecycleLogFile: entry %p, failure %08lx\n",
                        pEntry,
                        Status
                        ));

        if (pEntry->hFile != NULL)
        {
            ZwClose( pEntry->hFile );
            pEntry->hFile = NULL;
        }
    }

    return Status;
}

/***************************************************************************++

Routine Description:

    IsLogFileOverFlow:

Arguments:

--***************************************************************************/

__inline
BOOLEAN
UlpIsLogFileOverFlow(
        IN  PUL_LOG_FILE_ENTRY  pEntry,
        IN  ULONG               ReqdBytes
        )
{
    if (pEntry->Period != HttpLoggingPeriodMaxSize ||
        pEntry->TruncateSize == HTTP_LIMIT_INFINITE)
    {
        return FALSE;
    }
    else
    {
        return((pEntry->TotalWritten.QuadPart + (ULONGLONG)ReqdBytes)
                >=
                (ULONGLONG)pEntry->TruncateSize
              );
    }
}

/***************************************************************************++

Routine Description:

    UlpIncrementBytesWritten:

Arguments:

--***************************************************************************/

__inline
VOID
UlpIncrementBytesWritten(
    IN PUL_LOG_FILE_ENTRY  pEntry,
    IN ULONG               BytesWritten
    )
{
    UlInterlockedAdd64((PLONGLONG) &(pEntry->TotalWritten.QuadPart), 
            (ULONGLONG)BytesWritten);
};

/***************************************************************************++

Routine Description:

  UlpWeekOfMonth :  Ordinal Number of the week of the current month

  Stolen from IIS 5.1 code base.

  Example

  July 2000 ... :

     S   M   T   W   T   F   S      WeekOfMonth
                             1          1
     2   3   4   5   6   7   8          2
     9  10  11  12  13  14  15          3
    16  17  18  19  20  21  22          4
    23  24  25  26  27  28  29          5
    30  31                              6

  Finds the ordinal number of the week of current month.
  The numbering of weeks starts from 1 and run through 6 per month (max).
  The week number changes only on sundays.

  The calculation to be use is:

     1 + (dayOfMonth - 1)/7  + ((dayOfMonth - 1) % 7 > dayOfWeek);
     (a)     (b)                       (c)                (d)

     (a) to set the week numbers to begin from week numbered "1"
     (b) used to calculate the rough number of the week on which a given
        day falls based on the date.
     (c) calculates what is the offset from the start of week for a given
        day based on the fact that a week had 7 days.
     (d) is the raw day of week given to us.
     (c) > (d) indicates that the week is rolling forward and hence
        the week count should be offset by 1 more.

Arguments:

   PTIME_FIELDS    -   system time fields

Return Value:

   ULONG           -   This func magically returns the week of the month


--***************************************************************************/

__inline
ULONG UlpWeekOfMonth(
    IN  PTIME_FIELDS    fields
    )
{
    ULONG Tmp;

    Tmp = (fields->Day - 1);
    Tmp = ( 1 + Tmp/7 + (((Tmp % 7) > ((ULONG) fields->Weekday)) ? 1 : 0));

    return Tmp;
}

/***************************************************************************++

Routine Description:

    UlpInitializeGMTOffset :

        Calculates and builds the time difference string.
        Get called during the initialization.
        And every hour after that.

--***************************************************************************/

VOID
UlpGetGMTOffset()
{
    RTL_TIME_ZONE_INFORMATION Tzi;
    NTSTATUS Status;

    CHAR  Sign;
    LONG  Bias;
    ULONG Hour;
    ULONG Minute;
    ULONG DT = UL_TIME_ZONE_ID_UNKNOWN;
    LONG  BiasN = 0;
        
    PAGED_CODE();

    //
    // get the timezone data from the system
    //

    Status = NtQuerySystemInformation(
                SystemCurrentTimeZoneInformation,
                (PVOID)&Tzi,
                sizeof(Tzi),
                NULL
                );
                
    if (!NT_SUCCESS(Status)) 
    {
        UlTrace(LOGGING,("Ul!UlpGetGMTOffset: failure %08lx\n", Status));
    }
    else
    {
        DT = UlCalcTimeZoneIdAndBias(&Tzi, &BiasN);   
    }

    if ( BiasN > 0 )
    {
        //
        // UTC = local time + bias
        //
        Bias = BiasN;
        Sign = '-';
    }
    else
    {
        Bias = -1 * BiasN;
        Sign = '+';
    }

    Minute = Bias % 60;
    Hour   = (Bias - Minute) / 60;
        
    UlTrace( LOGGING, 
            ("Ul!UlpGetGMTOffset: %c%02d:%02d (h:m) D/S %d BiasN %d\n", 
                Sign, 
                Hour,
                Minute,
                DT,
                BiasN
                ) );

    _snprintf( g_GMTOffset,
               SIZE_OF_GMT_OFFSET,
               "%c%02d%02d",
               Sign,
               Hour,
               Minute
               );

}

/***************************************************************************++

Routine Description:

    UlpInitializeLogBufferGranularity :

        This will determine the (MAX) size of the buffer we will be using
        for the eac log file entry.

--***************************************************************************/

NTSTATUS
UlpInitializeLogBufferGranularity()
{
    SYSTEM_BASIC_INFORMATION sbi;
    NTSTATUS Status;

    Status = STATUS_SUCCESS;

    //
    // Get the granularity from the system
    //

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                (PVOID)&sbi,
                sizeof(sbi),
                NULL
                );

    if ( !NT_SUCCESS(Status) )
    {
        UlTrace( LOGGING,
            ("Ul!UlpInitializeLogBufferGranularity: failure %08lx\n",
              Status) );

        return Status;
    }

    g_AllocationGranularity = sbi.AllocationGranularity;

    UlTrace( LOGGING,
            ("Ul!UlpInitializeLogBufferGranularity: %d\n",
                g_AllocationGranularity
                ) );

    return Status;
}

/***************************************************************************++

Routine Description:

    UlProbeLogField :

        Probes the content of a user log field, including the terminating
        null.

Arguments:

        - the log field to be probed

--***************************************************************************/

__inline
VOID
UlpProbeLogField(
    IN PVOID  pField,
    IN SIZE_T FieldLength,
    IN ULONG  Alignment
    )
{
    if ( pField )
    {
        ProbeTestForRead(
            pField,
            FieldLength + Alignment,
            Alignment
            );
    }
}

/***************************************************************************++

Routine Description:

    UlProbeLogData :

        Probes the content of the user buffer of Log Data

        Note: pUserLogData holds untrusted data sent down from user mode.
        The caller MUST have a __try/__except block to catch any exceptions
        or access violations that occur while probing this data.

Arguments:

    PHTTP_LOG_FIELDS_DATA - The log data ( from WP ) to be probed and verified.

--***************************************************************************/

NTSTATUS
UlProbeLogData(
    IN PHTTP_LOG_FIELDS_DATA    pUserLogData
    )
{
    NTSTATUS Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    if (pUserLogData)
    {
        UlTrace( LOGGING, ("Ul!UlProbeLogData: pUserLogData %p\n",
                           pUserLogData ));

        //
        // Check for the log fields data structure
        //

        ProbeTestForRead(
            pUserLogData,
            sizeof(HTTP_LOG_FIELDS_DATA),
            sizeof(USHORT)
            );

        //
        // Now check for the individual strings
        //

        UlpProbeLogField(pUserLogData->ClientIp,
                         pUserLogData->ClientIpLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->ServiceName,
                         pUserLogData->ServiceNameLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->ServerName,
                         pUserLogData->ServerNameLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->ServerIp,
                         pUserLogData->ServerIpLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->UriQuery,
                         pUserLogData->UriQueryLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->Host,
                         pUserLogData->HostLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->UserAgent,
                         pUserLogData->UserAgentLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->Cookie,
                         pUserLogData->CookieLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->Referrer,
                         pUserLogData->ReferrerLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->Method,
                         pUserLogData->MethodLength,
                         sizeof(CHAR));
        UlpProbeLogField(pUserLogData->UserName,
                         pUserLogData->UserNameLength,
                         sizeof(WCHAR));
        UlpProbeLogField(pUserLogData->UriStem,
                         pUserLogData->UriStemLength,
                         sizeof(WCHAR));

#if DBG

        // CODEWORK: should we do this all the time? Remember, this is
        // untrusted user-mode data

        //
        // Few more controls for chk bits
        //

        if ((pUserLogData->ClientIp &&
             pUserLogData->ClientIpLength != strlen(pUserLogData->ClientIp))
            ||
            (pUserLogData->ServiceName &&
             pUserLogData->ServiceNameLength != strlen(pUserLogData->ServiceName))
            ||
            (pUserLogData->ServerName &&
             pUserLogData->ServerNameLength != strlen(pUserLogData->ServerName))
            ||
            (pUserLogData->ServerIp &&
             pUserLogData->ServerIpLength != strlen(pUserLogData->ServerIp))
            ||
            (pUserLogData->Method &&
             pUserLogData->MethodLength != strlen(pUserLogData->Method))
            ||
            (pUserLogData->UriQuery &&
             pUserLogData->UriQueryLength != strlen(pUserLogData->UriQuery))
            ||
            (pUserLogData->Host &&
             pUserLogData->HostLength != strlen(pUserLogData->Host))
            ||
            (pUserLogData->UserAgent &&
             pUserLogData->UserAgentLength != strlen(pUserLogData->UserAgent))
            ||
            (pUserLogData->Cookie &&
             pUserLogData->CookieLength != strlen(pUserLogData->Cookie))
            ||
            (pUserLogData->Referrer &&
             pUserLogData->ReferrerLength != strlen(pUserLogData->Referrer))
            ||
            (pUserLogData->UserName &&
             pUserLogData->UserNameLength != wcslen(pUserLogData->UserName)*sizeof(WCHAR))
             //
             // Disabled because UriSTem may not be null terminated.
             // ||
             // (pUserLogData->UriStem &&
             //  pUserLogData->UriStemLength != wcslen(pUserLogData->UriStem)*sizeof(WCHAR))
            )
        {
            //
            // Invalid log field has been pushed down by the WP.
            // Complain and reject the request.
            //

            UlTrace(LOGGING,(
                "Ul!UlProbeLogData: INVALID field rcvd from WP in pLogFields %p \n",
                pUserLogData
                ));

            Status = STATUS_INVALID_PARAMETER;
        }

#endif  // DBG

    }

    return Status;
}

/***************************************************************************++

Routine Description:

    UlAllocateLogDataBuffer :

        We capture the log fields from user ( WP ) buffer to our internal
        buffer that we allocate here.

        Also we set our pointer to pRequest here.

Arguments:

    pLogData  - The internal buffer to hold logging info. We will keep this
                around until we are done with logging.

    pRequest   - Pointer to the currently logged request.

--***************************************************************************/

NTSTATUS
UlAllocateLogDataBuffer(
    OUT PUL_LOG_DATA_BUFFER     pLogData,
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_CONFIG_GROUP_OBJECT pConfigGroup  // CG from cache or request
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pLogData);
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    UlTrace(LOGGING, ("Ul!UlAllocateLogDataBuffer: pLogData %p \n",
                        pLogData
                        ));
    //
    // Initialize Log Fields in the Log Buffer
    //

    UL_REFERENCE_INTERNAL_REQUEST(pRequest);
    pLogData->pRequest = pRequest;

    pLogData->CacheAndSendResponse= FALSE;
    pLogData->BytesTransferred= 0;
    pLogData->pConfigGroup= NULL;
    pLogData->Line = pLogData->Buffer;

    //
    // Capture Format & Flags from the Request's Config Group. Or
    // from the cache entries.
    // There's a possiblity that the values inside the log entry
    // maybe stale but that's acceptable. We do not want to acquire
    // the log resource so that we can avoid the contention.
    //

    pLogData->Format= pConfigGroup->LoggingConfig.LogFormat;
    pLogData->Flags = UL_GET_LOG_TYPE_MASK(
                            pConfigGroup->LoggingConfig.LogFormat,
                            pConfigGroup->LoggingConfig.LogExtFileFlags
                            );

    pLogData->Used= 0;        // For NCSA & W3C this is size of the line.
    pLogData->Length= 0;      // Allocation length,the default is 4k
    pLogData->UsedOffset1= 0; // Used by all formats.
    pLogData->UsedOffset2= 0; // This SHOULD only be nonzero if format is IIS

    return STATUS_SUCCESS;
}

/***************************************************************************++

Routine Description:

    UlDestroyLogDataBuffer :

        After we are done with writing this record we have to clean up
        the internal log buffer here.

Arguments:

    pLogData   -   The buffer to be destroyed

--***************************************************************************/

VOID
UlDestroyLogDataBufferWorker(
    IN PUL_WORK_ITEM    pWorkItem
    )
{
    PUL_LOG_DATA_BUFFER pLogData;

    //
    // Sanity check
    //

    ASSERT(pWorkItem);

    pLogData = CONTAINING_RECORD(
                    pWorkItem,
                    UL_LOG_DATA_BUFFER,
                    WorkItem
                    );

    //
    // If we are keeping a private pointer to the cgroup release it
    // as well
    //

    if (pLogData->pConfigGroup)
    {
        DEREFERENCE_CONFIG_GROUP(pLogData->pConfigGroup);
        pLogData->pConfigGroup = NULL;
    }

    //
    // Now release the possibly allocated large log line buffer
    //

    if (pLogData->Length > UL_LOG_LINE_BUFFER_SIZE)
    {
        // Large log line get allocated from paged pool
        // we better be running on lowered IRQL for this case.

        PAGED_CODE();

        UL_FREE_POOL(pLogData->Line, UL_LOG_DATA_BUFFER_POOL_TAG);
    }

    //
    // Last release our pointer to request structure here.
    //

    if (pLogData->pRequest)
    {
        PUL_INTERNAL_REQUEST pRequest;

        pRequest = pLogData->pRequest;
        pLogData->pRequest = NULL;

        UL_DEREFERENCE_INTERNAL_REQUEST(pRequest);
    }

    UlTrace(LOGGING,("Ul!UlpDestroyLogDataBufferWorker: pLogData %p \n",
                       pLogData
                       ));

}

/***************************************************************************++

Routine Description:

    Captures and writes the log fields from user (WP) buffer to the log line.
    Captures only those necessary fields according to the picked Flags.
    Does UTF8 and LocalCode Page conversion for UserName and URI Stem.
    Leaves enough space for Date & Time fields for late generation.
    Does SpaceToPlus conversion for UserAgent, Cookie, Referrer & Host.

Arguments:

    pLogData    : User Buffer which holds the fields and their lengths
    Version     : Version information from Request
    pLogBuffer  : Structure which holds final log line and additional
                  information.

--***************************************************************************/

NTSTATUS
UlCaptureLogFieldsW3C(
    IN  PHTTP_LOG_FIELDS_DATA   pLogData,
    IN  HTTP_VERSION            Version,
    OUT PUL_LOG_DATA_BUFFER     pLogBuffer
    )
{
    NTSTATUS Status;
    ULONG    Flags;
    PCHAR    psz;
    PCHAR    pBuffer;
    ULONG    BytesConverted;
    ULONG    FastLength;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pLogBuffer);

    Status = STATUS_SUCCESS;
    Flags  = pLogBuffer->Flags;
    BytesConverted = 0;

    //
    // Try fast length calculation for the the default case. If this fails
    // Recalc function will precisely calculate the required length by
    // paying attention to the picked flags.
    //

    FastLength = pLogData->ClientIpLength
                 + pLogData->UserNameLength
                 + pLogData->ServiceNameLength
                 + pLogData->ServerNameLength
                 + pLogData->ServerIpLength
                 + pLogData->MethodLength
                 + pLogData->UriStemLength
                 + pLogData->UriQueryLength
                 + pLogData->UserAgentLength
                 + pLogData->CookieLength
                 + pLogData->ReferrerLength
                 + pLogData->HostLength
                 + MAX_W3C_FIX_FIELD_OVERHEAD
                 ;
    if (UTF8_LOGGING_ENABLED() || (FastLength > UL_LOG_LINE_BUFFER_SIZE))
    {
        FastLength = UlpCalcLogLineLengthW3C(
                        pLogData,
                        Flags,
                        (UTF8_LOGGING_ENABLED() ? 2 : 1)
                        );            
        if (FastLength > UL_LOG_LINE_BUFFER_SIZE)
        {
            Status = UlpReallocLogLine(pLogBuffer, FastLength);
            if (!NT_SUCCESS(Status))
            {
                return Status;        
            }
        }
    }
    
    //  
    // Leave enough space for the date & time fields: "2000-01-31 00:12:23 "
    // For W3C format the field "Used" shows the size of the log line we have filled. 
    // UsedOffset1 shows how much space we have saved for date and/or time logfields.
    // UsedOffset2 shows the size of the log line which will be stored in the cache
    // entry, not including reserved space for date & time and the logfields after 
    // ServerPort. Therefore we only store the fragment which starts from logfield 
    // UserName to ServerPort. Others will be generated per cache hit.
    //

    psz = pBuffer = &pLogBuffer->Line[0];
    
    if ( Flags & MD_EXTLOG_DATE ) psz += 11;
    if ( Flags & MD_EXTLOG_TIME ) psz += 9;

    // Generate all the fields except BytesSend, BytesReceived & TimeTaken
    // They will be added when the send is complete and if they are picked    
    // We will only copy the fields after this point to the cache entry.
    // Lets set and remember the size of the fields we are discarding.
    
    pLogBuffer->UsedOffset1 = (USHORT) DIFF(psz - pBuffer);
    
    if ( Flags & MD_EXTLOG_SITE_NAME ) 
    {    
        if (pLogData->ServiceNameLength)
        {
            psz = UlStrPrintStr(psz, pLogData->ServiceName,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_COMPUTER_NAME )
    {
        if (pLogData->ServerNameLength)
        {
            psz = UlStrPrintStr(psz, pLogData->ServerName,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_SERVER_IP )
    {
        if (pLogData->ServerIpLength)
        {
            psz = UlStrPrintStr(psz, pLogData->ServerIp,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_METHOD )
    {
        if (pLogData->MethodLength)
        {
            psz = UlStrPrintStr(psz, pLogData->Method,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_URI_STEM )
    {
        BytesConverted = 0;
        if (pLogData->UriStemLength)
        {
            PCHAR pszT = psz;

            if (UTF8_LOGGING_ENABLED())
            {
                BytesConverted =
                    HttpUnicodeToUTF8(
                        pLogData->UriStem,
                        pLogData->UriStemLength/sizeof(WCHAR),
                        psz,
                        pLogData->UriStemLength * 2
                        );
                ASSERT(BytesConverted);
            }
            else
            {
                RtlUnicodeToMultiByteN(
                    psz,
                    pLogData->UriStemLength,
                   &BytesConverted,
                    pLogData->UriStem,
                    pLogData->UriStemLength
                    );
            }
            psz += BytesConverted;

            // Do SpeaceToPlus conversion before writting out
            // the terminator space.

            while (pszT != psz)
            {
                if (*pszT == ' ') *pszT = '+';
                pszT++;
            }

            *psz++ = ' ';

        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }

    }

    if ( Flags & MD_EXTLOG_URI_QUERY )
    {
        if (pLogData->UriQueryLength)
        {
            psz = UlStrPrintStr(psz, pLogData->UriQuery,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_HTTP_STATUS ) 
    {  
        psz = UlStrPrintProtocolStatus(psz,(USHORT)pLogData->ProtocolStatus,' ');
    }

    if ( Flags & MD_EXTLOG_WIN32_STATUS ) 
    { 
        psz = UlStrPrintUlong(psz, pLogData->Win32Status,' ');
    }

    if ( Flags & MD_EXTLOG_SERVER_PORT ) 
    {   
        psz = UlStrPrintUlong(psz, pLogData->ServerPort,' ');
    }

    //
    // Cache builder won't be storing the fields after this line. 
    // They have to be generated per hit for cache hits.
    //
    
    pLogBuffer->UsedOffset2 = (USHORT) DIFF(psz - pBuffer);

    if ( Flags & MD_EXTLOG_USERNAME ) 
    {     
        BytesConverted = 0;
        if (pLogData->UserNameLength)
        {
            // Do either UTF8 or LocalCodePage Conversion 
            // not including the terminating null.

            PCHAR pszT = psz;
        
            if (UTF8_LOGGING_ENABLED())
            {          
                // UTF8 Conversion may require upto two times because of a 
                // possible 2 byte to 4 byte conversion.
            
                BytesConverted = 
                    HttpUnicodeToUTF8(
                        pLogData->UserName,
                        pLogData->UserNameLength/sizeof(WCHAR),
                        psz,
                        pLogData->UserNameLength * 2
                        );
                ASSERT(BytesConverted);
            }
            else
            {
                // Local codepage is normally closer to the half the length,
                // but due to the possibility of pre-composed characters, 
                // the upperbound of the ANSI length is the UNICODE length 
                // in bytes
            
                RtlUnicodeToMultiByteN( 
                    psz, 
                    pLogData->UserNameLength,
                   &BytesConverted,
                    pLogData->UserName,
                    pLogData->UserNameLength
                    );
            }

            // Forward the psz by BytesConverted
            psz += BytesConverted; 

            // Do SpaceToPlus conversion
            while (pszT != psz)
            {
                if (*pszT == ' ') *pszT = '+';    
                pszT++;
            }
            
            *psz++ = ' ';
            
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }

    }
    
    if ( Flags & MD_EXTLOG_CLIENT_IP ) 
    { 
        if (pLogData->ClientIpLength)
        {        
            psz = UlStrPrintStr(psz, pLogData->ClientIp,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }
    
    if ( Flags & MD_EXTLOG_PROTOCOL_VERSION ) 
    {    
        psz = UlStrPrintStr(psz, UL_GET_NAME_FOR_HTTP_VERSION(Version),' ');
    }

    if ( Flags & MD_EXTLOG_USER_AGENT )
    {
        if (pLogData->UserAgentLength)
        {
            psz = UlStrPrintStrC(psz, pLogData->UserAgent,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_COOKIE )
    {
        if (pLogData->CookieLength)
        {
            psz = UlStrPrintStrC(psz, pLogData->Cookie,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_REFERER )
    {
        if (pLogData->ReferrerLength)
        {
            psz = UlStrPrintStrC(psz, pLogData->Referrer,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    if ( Flags & MD_EXTLOG_HOST )
    {
        if (pLogData->HostLength)
        {
            psz = UlStrPrintStrC(psz, pLogData->Host,' ');
        }
        else
        {
            *psz++ = '-'; *psz++ = ' ';
        }
    }

    // Finally calculate the used space

    pLogBuffer->Used = (ULONG) DIFF(psz - pBuffer);
    
    // Date & Time fields will be filled in when the LogHit completes.
    // As well as the fields BytesSent,BytesReceived and TimeTaken will
    // be added to the end of the log line, then.

    UlTrace(LOGGING, ("Ul!UlCaptureLogFields: user %p kernel %p\n",
                        pLogData,pLogBuffer
                        ));
    return Status;

}

NTSTATUS 
UlCaptureLogFieldsNCSA(
    IN  PHTTP_LOG_FIELDS_DATA   pLogData,
    IN  HTTP_VERSION            Version,
    OUT PUL_LOG_DATA_BUFFER     pLogBuffer
    )
{
    NTSTATUS Status;
    ULONG    BytesConverted;
    PCHAR    psz;
    PCHAR    pBuffer;
    ULONG    Utf8Multiplier;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT(pLogBuffer);

    Status = STATUS_SUCCESS;
    Utf8Multiplier = (UTF8_LOGGING_ENABLED() ? 2 : 1);

    // Estimate the length and reallocate the log data buffer line
    // if necessary

    pLogBuffer->Length =
        2 + pLogData->ClientIpLength +
        2 +                                                     // For remote user log name
        2 + pLogData->UserNameLength * Utf8Multiplier +
        29 +                                                    // Fixed Date & Time Space
        2 + pLogData->MethodLength +                          // "MTHD U-STEM?U-QUERY P-VER"
        2 + pLogData->UriStemLength * Utf8Multiplier +
        2 + pLogData->UriQueryLength +
        2 + UL_HTTP_VERSION_LENGTH +                            // Version plus Quotes ""
        2 + MAX_ULONG_STR +                                     // ProtocolStatus
        2 + MAX_ULONGLONG_STR +                                 // BytesSend
        3                                                       // \r\n\0
        ;

    if ( pLogBuffer->Length > UL_LOG_LINE_BUFFER_SIZE )
    {
        Status = UlpReallocLogLine(pLogBuffer, pLogBuffer->Length);
        if (!NT_SUCCESS(Status))
        {
            return Status;        
        }
    }

    //
    // UCIP - username [date:time offset] "MTHD U-STEM?U-QUERY P-VER" Status BSent
    //

    // Set and remember the beginning
    psz = pBuffer = &pLogBuffer->Line[0];

    // Client IP
    if (pLogData->ClientIpLength)
    {
        psz = UlStrPrintStr(psz, pLogData->ClientIp,' ');
    }
    else
    {
        *psz++ = '-'; *psz++ = ' ';
    }

    // Fixed dash
    *psz++ = '-'; *psz++ = ' ';

    // UserName
    if (pLogData->UserNameLength)
    {
        BytesConverted = 0;
        if (UTF8_LOGGING_ENABLED())
        {
            BytesConverted =
                HttpUnicodeToUTF8(
                    pLogData->UserName,
                    pLogData->UserNameLength/sizeof(WCHAR),
                    psz,
                    pLogData->UserNameLength * 2
                    );
            ASSERT(BytesConverted);
        }
        else
        {
            RtlUnicodeToMultiByteN(
                psz,
                pLogData->UserNameLength,
               &BytesConverted,
                pLogData->UserName,
                pLogData->UserNameLength
                );
        }
        psz += BytesConverted; *psz++ = ' ';

    }
    else
    {
        *psz++ = '-'; *psz++ = ' ';
    }

    // [Date:Time GmtOffset] -> "[07/Jan/2000:00:02:23 -0800] "
    // Just leave the space for the time being. But remember the
    // offset of the beginning of the reserved space of 29 bytes.

    pLogBuffer->UsedOffset1 = (USHORT) DIFF(psz - pBuffer);
     
    // Forward psz to bypass the reserved space
    psz += NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
        
    // "MTHD U-STEM?U-QUERY P-VER"

    *psz++  = '\"';
    if (pLogData->MethodLength)
    {
        psz = UlStrPrintStr(psz, pLogData->Method,' ');
    }
    else
    {
        *psz++ = '-'; *psz++ = ' ';
    }

    if (pLogData->UriStemLength)
    {
        BytesConverted = 0;
        if (UTF8_LOGGING_ENABLED())
        {
            BytesConverted =
                HttpUnicodeToUTF8(
                    pLogData->UriStem,
                    pLogData->UriStemLength/sizeof(WCHAR),
                    psz,
                    pLogData->UriStemLength * 2
                    );
            ASSERT(BytesConverted);
        }
        else
        {
            RtlUnicodeToMultiByteN(
                psz,
                pLogData->UriStemLength,
               &BytesConverted,
                pLogData->UriStem,
                pLogData->UriStemLength
                );
        }
        psz += BytesConverted;

    }
    else
    {
        *psz++ = '-';
    }

    if (pLogData->UriQueryLength)
    {
        *psz++ = '?';
        psz = UlStrPrintStr(psz, pLogData->UriQuery,' ');
    }
    else
    {
        *psz++ = ' ';
    }
    
    pLogBuffer->UsedOffset2 = (USHORT) DIFF(psz - pBuffer);

    psz = UlStrPrintStr(psz, UL_GET_NAME_FOR_HTTP_VERSION(Version),'\"');
    *psz++ = ' ';

    // ProtocolStatus
    psz = UlStrPrintProtocolStatus(psz, (USHORT)pLogData->ProtocolStatus,' ');

    // Calculate the length upto now
    pLogBuffer->Used += (ULONG) DIFF(psz - pBuffer);

    // BytesSend will be filled later on during hit processing

    return Status;

}

NTSTATUS
UlCaptureLogFieldsIIS(
    IN  PHTTP_LOG_FIELDS_DATA   pLogData,
    IN  HTTP_VERSION            Version,
    OUT PUL_LOG_DATA_BUFFER     pLogBuffer
    )
{
    NTSTATUS Status;
    ULONG    BytesConverted;
    PCHAR    psz;
    PCHAR    pBuffer;
    ULONG    Utf8Multiplier;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pLogBuffer);

    Status = STATUS_SUCCESS;
    Utf8Multiplier = (UTF8_LOGGING_ENABLED() ? 2 : 1);

    // Estimate the length and reallocate the log data buffer line
    // if necessary

    pLogBuffer->Length =
        2 + pLogData->ClientIpLength +
        2 + pLogData->UserNameLength * Utf8Multiplier +
       22 +                                                     // Fixed Date & Time Space
        2 + pLogData->ServiceNameLength +
        2 + pLogData->ServerNameLength +
        2 + pLogData->ServerIpLength +
        2 + MAX_ULONGLONG_STR +                                 // TimeTaken
        2 + MAX_ULONGLONG_STR +                                 // BytesReceived
        2 + MAX_ULONGLONG_STR +                                 // BytesSend
        2 + MAX_ULONG_STR +                                     // ProtocolStatus
        2 + MAX_ULONG_STR +                                     // Win32 Status
        2 + pLogData->MethodLength +
        2 + pLogData->UriStemLength * Utf8Multiplier +
        2 + pLogData->UriQueryLength +
        3                                                       // \r\n\0
        ;

    if ( pLogBuffer->Length > UL_LOG_LINE_BUFFER_SIZE )
    {        
        // TODO: Fix this and do the limit checks per field
        
        if (pLogBuffer->Length > UL_MAX_LOG_LINE_BUFFER_SIZE)
        {
            return STATUS_INVALID_PARAMETER;
        }

        Status = UlpReallocLogLine(pLogBuffer, UL_MAX_LOG_LINE_BUFFER_SIZE);
        if (!NT_SUCCESS(Status))
        {
            return Status;
        }
    }

    //
    // UIP,user,D,T,site,Server,SIP,Ttaken,BR,BS,PS,WS,M,URI,URIQUERY,
    //

    // We will store the fragmented IIS log line as follows. If captured fields
    // won't fit to the default 4k buffer the fragments will be increased by mul
    // tiplier of 2 until they fit. But this calculation happened earlier and now
    // we know the actual size of each fragment. All the available fields will be
    // written to the beginning of their corresponding fragments and unavailable ones
    // for the first two fragments ( i.e. date and time for 1 and timetaken
    // bytesreceived and bytessent for 2, none for the three ) will be appended later
    // when the hit happens. To be able to do that we will remember used_offsets for
    // fragments one and two, both in the log_data and in the cache entry. But for this
    // schema we need a special LogWriter which expects and handles 3 fragments rather
    // than one complete line.

    // <- upto time -> <- from siteName to BytesSent -> <- From p status to query ->
    // 0           511 512                         1023 1024                    4096

    // FRAGMENT ONE
    // -----------------------------------------------------
    // Cache entry will not store this fragment, the fields in
    // here have to be regenerated for the (pure) cache hits.
    
    psz = pBuffer = &pLogBuffer->Line[0];

    // Client IP
    if (pLogData->ClientIpLength)
    {
        psz = UlStrPrintStr(psz, pLogData->ClientIp,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // UserName
    if (pLogData->UserNameLength)
    {
        BytesConverted = 0;
        if (UTF8_LOGGING_ENABLED())
        {
            BytesConverted =
                HttpUnicodeToUTF8(
                    pLogData->UserName,
                    pLogData->UserNameLength/sizeof(WCHAR),
                    psz,
                    pLogData->UserNameLength * 2
                    );
            ASSERT(BytesConverted);
        }
        else
        {
            RtlUnicodeToMultiByteN(
                psz,
                pLogData->UserNameLength,
               &BytesConverted,
                pLogData->UserName,
                pLogData->UserNameLength
                );
        }
        psz += BytesConverted; *psz++ = ',';

    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // Date and Time will be added later to the end of this fragment.

    pLogBuffer->UsedOffset1 = (USHORT) DIFF(psz - pBuffer);


    // FRAGMENT TWO
    // -----------------------------------------------------

    pBuffer = psz = &pLogBuffer->Line[512];

    // SiteName
    if (pLogData->ServiceNameLength)
    {
        psz = UlStrPrintStr(psz, pLogData->ServiceName,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // ServerName
    if (pLogData->ServerNameLength)
    {
        psz = UlStrPrintStr(psz, pLogData->ServerName,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // ServerIp
    if (pLogData->ServerIpLength)
    {
        psz = UlStrPrintStr(psz, pLogData->ServerIp,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // TimeTaken BytesSent and BytesReceived will be added later
    // to the end of this fragment

    pLogBuffer->UsedOffset2 = (USHORT) DIFF(psz - pBuffer);


    // FRAGMENT THREE
    // -----------------------------------------------------

    pBuffer = psz = &pLogBuffer->Line[1024];
    
    // ProtocolStatus    
    psz = UlStrPrintProtocolStatus(psz, (USHORT)pLogData->ProtocolStatus,','); 
    *psz++ = ' ';

    // Win32 Status
    psz = UlStrPrintUlong(psz, pLogData->Win32Status,','); 
    *psz++ = ' ';

    // Method
    if (pLogData->MethodLength)
    {
        psz = UlStrPrintStr(psz, pLogData->Method,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // URI Stem
    if (pLogData->UriStemLength)
    {
        BytesConverted = 0;
        if (UTF8_LOGGING_ENABLED())
        {
            BytesConverted =
                HttpUnicodeToUTF8(
                    pLogData->UriStem,
                    pLogData->UriStemLength/sizeof(WCHAR),
                    psz,
                    pLogData->UriStemLength * 2
                    );
            ASSERT(BytesConverted);
        }
        else
        {
            RtlUnicodeToMultiByteN(
                psz,
                pLogData->UriStemLength,
               &BytesConverted,
                pLogData->UriStem,
                pLogData->UriStemLength
                );
        }
        psz += BytesConverted; *psz++ = ',';

    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = ' ';

    // URI Query
    if (pLogData->UriQueryLength)
    {
        psz = UlStrPrintStr(psz, pLogData->UriQuery,',');
    }
    else
    {
        *psz++ = '-'; *psz++ = ',';
    }
    *psz++ = '\r'; *psz++ = '\n';

    // The size of the fragment 3 goes to Used
    pLogBuffer->Used += (ULONG) DIFF(psz - pBuffer);

    *psz++ = ANSI_NULL;

    return Status;
}

/***************************************************************************++

Routine Description:

    UlLogHttpHit :

       This function ( or its cache pair ) gets called everytime a log hit
       happens. Just before completing the SendResponse request to the user.

       The most likely places for calling this API or its pair for cache
       is just before the send completion when we were about the destroy
       send trackers.

       Means:

        1.  UlpCompleteSendRequestWorker for ORDINARY hits; before destroying
            the PUL_CHUNK_TRACKER for send operation.

        2.  UlpCompleteSendCacheEntryWorker for both types of CACHE hits
            (cache build&send or just pure cache hit) before destroying the
            the PUL_FULL_TRACKER for cache send operation.

       This function requires Request & Response structures ( whereas its
       cache pair only requires the Request ) to successfully generate the
       the log fields and even for referencing to the right log configuration
       settings for this  site ( thru pRequest's pConfigInfo  pointer ).

       Unfortunately the major concern is untimely resetting of the connection
       (when client terminates the connection before we get a chance to reach
       to the -above- mentioned places) In that case UlConnectionDestroyedWorker
       will asynchrously destroy our pRequest pointer ( in the pHttpConnection
       structure ) and cause us to miss log hits. So we cannot trust on
       HttpConnection for pRequest pointer. To solve this issue we keeep our
       own pointer to Request. No need to worry about pResponse as it's going
       to be preserved by chunk_trucker until its own destruction.

Arguments:

    pResponse - pointer to the internal response structure, surely
                passed down by the chunk tracker. We will grap our Log Data
                buffer from this structure which originaly allocated when
                capturing the Response from the user.
                See UlCaptureHttpResponse.

--***************************************************************************/

NTSTATUS
UlLogHttpHit(
    IN PUL_LOG_DATA_BUFFER  pLogBuffer
    )
{
    NTSTATUS                Status;
    PUL_CONFIG_GROUP_OBJECT pConfigGroup;
    PUL_INTERNAL_REQUEST    pRequest;
    PCHAR                   psz;
    PCHAR                   pBuffer;
    ULONG                   BytesWritten;
    LONGLONG                LifeTime;
    LARGE_INTEGER           CurrentTimeStamp;
    PUL_LOG_FILE_ENTRY      pEntry;

    //
    // A LOT of sanity checks.
    //

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    UlTrace( LOGGING, ("Ul!UlLogHttpHit: pLogData %p\n", pLogBuffer ));

    ASSERT(pLogBuffer);

    pRequest = pLogBuffer->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    if (pRequest->ConfigInfo.pLoggingConfig == NULL ||
        IS_LOGGING_DISABLED(pRequest->ConfigInfo.pLoggingConfig)
        )
    {
        //
        // If logging is disabled or log settings don't
        // exist then do not proceed. Just exit out.
        //
        return STATUS_SUCCESS;
    }

    pConfigGroup = pRequest->ConfigInfo.pLoggingConfig;
    ASSERT(IS_VALID_CONFIG_GROUP(pConfigGroup));

    //
    // Construct the remaining log fields
    //

    switch(pLogBuffer->Format)
    {
        case HttpLoggingTypeW3C:
        {
            // First write the date & time fields to the beginning reserved
            // space. Do not increment the used counter for date & time, b/c
            // CaptureLogFields already did this when reserving the space.

            psz = &pLogBuffer->Line[0];
            if ( pLogBuffer->Flags & MD_EXTLOG_DATE )
            {
                UlpGetDateTimeFields(
                                       HttpLoggingTypeW3C,
                                       psz,
                                      &BytesWritten,
                                       NULL,
                                       NULL
                                       );
                psz += BytesWritten; *psz++ = ' ';
                ASSERT(BytesWritten == 10);
            }

            if ( pLogBuffer->Flags & MD_EXTLOG_TIME )
            {
                UlpGetDateTimeFields(
                                       HttpLoggingTypeW3C,
                                       NULL,
                                       NULL,
                                       psz,
                                      &BytesWritten
                                       );
                psz += BytesWritten; *psz++ = ' ';
                ASSERT(BytesWritten == 8);
            }

            // Set and remember where we started
            pBuffer = psz = &pLogBuffer->Line[pLogBuffer->Used];

            // Now proceed with the remaining fields, but add them to the end.

            if ( pLogBuffer->Flags & MD_EXTLOG_BYTES_SENT )
            {
                psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,' ');
            }
            if ( pLogBuffer->Flags & MD_EXTLOG_BYTES_RECV )
            {
                psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,' ');
            }
            if ( pLogBuffer->Flags & MD_EXTLOG_TIME_TAKEN )
            {
                KeQuerySystemTime( &CurrentTimeStamp );
                LifeTime = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;

                if (LifeTime < 0)
                {
                    LifeTime = 0;
                    UlTrace(LOGGING, ("CopyTimeStampField failure.\n"));
                }
                LifeTime /= (10*1000); // Conversion from 100-nanosecond to millisecs.

                psz = UlStrPrintUlonglong(psz, (ULONGLONG)LifeTime,' ');
            }

            // Now calculate the space we have used

            pLogBuffer->Used += (ULONG) DIFF(psz - pBuffer);

            // Eat the last space and write the \r\n to the end.
            // Only if we have any fields picked and written

            if (pLogBuffer->Used)
            {
                psz = &pLogBuffer->Line[pLogBuffer->Used-1];     // Eat the last space
                *psz++ = '\r'; *psz++ = '\n'; *psz++ = ANSI_NULL;

                pLogBuffer->Used += 1;
            }
            else
            {
                return STATUS_SUCCESS; // No log fields nothing to log
            }

            // Cleanup the UsedOffsets otherwise length calculation will
            // fail down below.
            
            pLogBuffer->UsedOffset1 = pLogBuffer->UsedOffset2 = 0;            
        }
        break;

        case HttpLoggingTypeNCSA:
        {
            // [date:time GmtOffset] -> "[07/Jan/2000:00:02:23 -0800] "
            // Restore the pointer to the reserved space first.

            psz = &pLogBuffer->Line[pLogBuffer->UsedOffset1];
            *psz++ = '[';

            UlpGetDateTimeFields(
                                   HttpLoggingTypeNCSA,
                                   psz,
                                  &BytesWritten,
                                   NULL,
                                   NULL
                                   );
            psz += BytesWritten; *psz++ = ':';
            ASSERT(BytesWritten == 11);

            UlpGetDateTimeFields(
                                   HttpLoggingTypeNCSA,
                                   NULL,
                                   NULL,
                                   psz,
                                  &BytesWritten
                                   );
            psz += BytesWritten; *psz++ = ' ';
            ASSERT(BytesWritten == 8);

            UlAcquireResourceShared(&g_pUlNonpagedData->LogListResource, TRUE);
            psz = UlStrPrintStr(psz, g_GMTOffset,']');
            UlReleaseResource(&g_pUlNonpagedData->LogListResource);
            *psz++ = ' ';

            ASSERT(((ULONG) DIFF(psz - &pLogBuffer->Line[pLogBuffer->UsedOffset1])) == 29);

            // BytesSent

            pBuffer = psz = &pLogBuffer->Line[pLogBuffer->Used];
            psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,'\r');
            pLogBuffer->Used += (ULONG) DIFF(psz - pBuffer);

            // \n\0

            *psz++ = '\n'; *psz++ = ANSI_NULL;
            pLogBuffer->Used += 1;

            // Cleanup the UsedOffsets otherwise length calculation will
            // fail down below.
            
            pLogBuffer->UsedOffset1 = pLogBuffer->UsedOffset2 = 0;
        }
        break;

        case HttpLoggingTypeIIS:
        {
            // At this time to construct the IIS log line is slightly
            // different than the cache completion case. We can either
            // use memmoves to get rid of the gaps between the three
            // fragments. Or we provide a special log writer to actually
            // handle three fragments when writting to the final log buffer
            // I have picked the latter.

            // Complete Fragment 1

            pBuffer = psz = &pLogBuffer->Line[pLogBuffer->UsedOffset1];

            UlpGetDateTimeFields(
                                   HttpLoggingTypeIIS,
                                   psz,
                                  &BytesWritten,
                                   NULL,
                                   NULL
                                   );
            psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

            UlpGetDateTimeFields(
                                   HttpLoggingTypeIIS,
                                   NULL,
                                   NULL,
                                   psz,
                                  &BytesWritten
                                   );
            psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

            pLogBuffer->UsedOffset1 += (USHORT) DIFF(psz - pBuffer);


            // Complete Fragment 2

            pBuffer = psz = &pLogBuffer->Line[512 + pLogBuffer->UsedOffset2];

            KeQuerySystemTime( &CurrentTimeStamp );
            LifeTime = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;
            if (LifeTime < 0)
            {
                LifeTime = 0;
                UlTrace(LOGGING, ("CopyTimeStampField: failure.\n"));
            }
            LifeTime /= (10*1000); // Conversion from 100-nanosecond to millisecs.

            psz = UlStrPrintUlonglong(psz, (ULONGLONG)LifeTime,',');
            *psz++ = ' ';

            psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,',');
            *psz++ = ' ';

            psz = UlStrPrintUlonglong(psz, pRequest->BytesSent,',');
            *psz++ = ' ';

            pLogBuffer->UsedOffset2 += (USHORT) DIFF(psz - pBuffer);

            // Size of the final log line should be
            // pLogBuffer->UsedOffset1 + pLogBuffer->UsedOffset2 + pLogBuffer->Used
            // for IIS log format down below.
        }
        break;

        default:
        {
            ASSERT(!"Unknown Log Format Type\n");
            return STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Finally this log line is ready to rock. Lets write it out.
    //

    UlAcquireResourceShared(&g_pUlNonpagedData->LogListResource, TRUE);

    //
    // Unless otherwise there's a problem in the set config group Ioctl
    // we should never come here with having a null entry pointer. Even
    // in the case of log reconfiguration, cgroup should acquire the log
    // list resource to update its entry pointer.
    //

    pEntry = pConfigGroup->pLogFileEntry;

    if (pEntry)
    {
        ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

        Status =
            UlpWriteToLogFile (
                pEntry,
                pLogBuffer->UsedOffset1 + pLogBuffer->UsedOffset2 + pLogBuffer->Used,
               &pLogBuffer->Line[0],
                pLogBuffer->UsedOffset1,
                pLogBuffer->UsedOffset2
                );
    }
    #if DBG
    else
    {
        //
        // Practically every time we leak a url_cache entry we will not close
        // the corresponding cgroup and the corresponding log entry. In that
        // case next time we try to run http.sys we might see this assertion
        // going on. Not usefull at this time because it's too late to cacth
        // the original leak. Also if we run out of system resources when
        // allocation the log file entry we will come here as well.
        //

        UlTrace(LOGGING,("Ul!UlLogHttpHit:null logfile entry !\n"));

        Status = STATUS_INVALID_PARAMETER;
    }

    if (!NT_SUCCESS(Status))
    {
        UlTrace( LOGGING, ("Ul!UlLogHttpHit: entry %p, failure %08lx \n",
                            pEntry,
                            Status
                            ));
    }
    #endif // DBG

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

    return Status;

}

/***************************************************************************++

Routine Description:

    Queues a work item for the actual log hit function.

Arguments:

    pTracker - Supplies the tracker to complete.

--***************************************************************************/

NTSTATUS
UlLogHttpCacheHit(
    PUL_FULL_TRACKER            pTracker
    )
{
    NTSTATUS              Status;
    PUL_LOG_DATA_BUFFER   pLogData;
    ULONG                 NewLength;
    PUL_INTERNAL_REQUEST  pRequest;

    //
    // A Lot of sanity checks.
    //

    PAGED_CODE();

    ASSERT(pTracker);
    ASSERT(IS_VALID_FULL_TRACKER(pTracker));
    ASSERT(pTracker->pLogData);

    Status = STATUS_SUCCESS;

    pLogData = pTracker->pLogData;
    pLogData->BytesTransferred = pTracker->IoStatus.Information;

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    UlTrace(LOGGING,("Ul!UlLogHttpCacheHit: pLogData %p\n",pTracker->pLogData));
    
    //
    // Restore the logging data from cache. If this hasn't been done  by
    // the BuildCacheEntry for cache&send responses.
    //

    if ( pLogData->CacheAndSendResponse == FALSE )
    {
        ASSERT(pTracker->pUriEntry);

        // Make sure that internal buffer is big enough
        // before proceeding.

        // pLogData->Length = pTracker->pUriEntry->MaxLength;

        switch( pLogData->Format )
        {
            case HttpLoggingTypeW3C: 
            {                
                // Recalculate the log line size to see if need to realloc
                
                NewLength = UlpRecalcLogLineLengthW3C(
                                pLogData->Flags,
                                pLogData->pRequest,
                                pTracker->pUriEntry->LogDataLength
                                );
                
                if ( NewLength > UL_LOG_LINE_BUFFER_SIZE )
                {
                    Status = UlpReallocLogLine(pLogData, NewLength);
                    if (!NT_SUCCESS(Status))
                    {
                        // Worker won't get called. Cleanup immediately
                        UlDestroyLogDataBuffer(pLogData);                        
                        return Status;        
                    }
                }
                
                if ( pTracker->pUriEntry->LogDataLength )
                {
                    RtlCopyMemory( &pLogData->Line[pTracker->pUriEntry->UsedOffset1],
                                    pTracker->pUriEntry->pLogData,
                                    pTracker->pUriEntry->LogDataLength
                                    );
                }

                // Cache data plus the reserved space for date and time
                
                pLogData->Used = pTracker->pUriEntry->LogDataLength + 
                                 pTracker->pUriEntry->UsedOffset1;                
            }
            break;

            case HttpLoggingTypeNCSA:
            {
                PCHAR psz,pBuffer;
                
                ASSERT( pTracker->pUriEntry->LogDataLength );
                ASSERT( pTracker->pUriEntry->pLogData );

                NewLength = MAX_NCSA_CACHE_FIELD_OVERHEAD
                            + pTracker->pUriEntry->LogDataLength;

                if ( NewLength > UL_LOG_LINE_BUFFER_SIZE )
                {
                    Status = UlpReallocLogLine(pLogData, NewLength);
                    if (!NT_SUCCESS(Status))
                    {
                        // Worker won't get called. Cleanup immediately
                        UlDestroyLogDataBuffer(pLogData);                        
                        return Status;        
                    }                                        
                }                    

                psz = pBuffer = &pLogData->Line[0];
                
                // Client IP       
                psz = UlStrPrintIP(
                        psz,
                        pRequest->pHttpConn->pConnection->RemoteAddress,
                        ' '
                        );

                // Fixed dash        
                *psz++ = '-'; *psz++ = ' ';

                // Authenticated users cannot be served from cache.
                *psz++ = '-'; *psz++ = ' ';

                // Mark the beginning of the date & time fields
                pLogData->UsedOffset1 = (USHORT) DIFF(psz - pBuffer);
                
                // Forward psz to bypass the reserved space
                psz += NCSA_FIX_DATE_AND_TIME_FIELD_SIZE;
                
                RtlCopyMemory( psz, 
                               pTracker->pUriEntry->pLogData, 
                               pTracker->pUriEntry->LogDataLength
                               );
                psz += pTracker->pUriEntry->LogDataLength;

                // Protocol Version
                psz = UlStrPrintStr(
                        psz, 
                        UL_GET_NAME_FOR_HTTP_VERSION(pRequest->Version),
                        '\"'
                        );
                *psz++ = ' ';
                
                // ProtocolStatus
                psz = UlStrPrintProtocolStatus(
                        psz, 
                        pTracker->pUriEntry->StatusCode,
                        ' '
                        );

                // Calculate the length until now
                pLogData->Used += (ULONG) DIFF(psz - pBuffer);
            }
            break;

            case HttpLoggingTypeIIS:
            {
                PCHAR psz;
                ULONG BytesWritten;                
                LONGLONG LifeTime;
                LARGE_INTEGER CurrentTimeStamp;

                ASSERT( pTracker->pUriEntry->LogDataLength );
                ASSERT( pTracker->pUriEntry->pLogData );

                NewLength = MAX_IIS_CACHE_FIELD_OVERHEAD
                            + pTracker->pUriEntry->LogDataLength;

                if ( NewLength > UL_LOG_LINE_BUFFER_SIZE )
                {
                    Status = UlpReallocLogLine(pLogData, NewLength);
                    if (!NT_SUCCESS(Status))
                    {
                        // Worker won't get called. Cleanup immediately
                        UlDestroyLogDataBuffer(pLogData);                        
                        return Status;        
                    }                                        
                }                    

                BytesWritten = 0;
                
                // Followings specify the size of iis log line fragments
                // two and three. We are constructing the fragment one
                // completely from scratch for pure cache hits.
                
                pLogData->UsedOffset1 = pTracker->pUriEntry->UsedOffset1;
                pLogData->UsedOffset2 = pTracker->pUriEntry->UsedOffset2;

                ASSERT(pLogData->UsedOffset1 + pLogData->UsedOffset2 
                                == pTracker->pUriEntry->LogDataLength );
                
                psz = &pLogData->Line[0];

                // Client IP       
                psz = UlStrPrintIP(
                        psz,
                        pRequest->pHttpConn->pConnection->RemoteAddress,
                        ','
                        );
                *psz++ = ' ';
                
                // Authenticated users cannot be served from cache.
                *psz++ = '-'; *psz++ = ','; *psz++ = ' ';

                // Date & Time fields
                UlpGetDateTimeFields(
                                       HttpLoggingTypeIIS,
                                       psz,
                                      &BytesWritten,
                                       NULL,
                                       NULL
                                       );
                psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

                UlpGetDateTimeFields(
                                       HttpLoggingTypeIIS,
                                       NULL,
                                       NULL,
                                       psz,
                                      &BytesWritten
                                       );
                psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

                // Fragment two
                RtlCopyMemory( psz,
                               pTracker->pUriEntry->pLogData,
                               pLogData->UsedOffset1
                               );
                psz += pLogData->UsedOffset1;
                
                KeQuerySystemTime( &CurrentTimeStamp );
                LifeTime = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;
                if (LifeTime < 0)
                {
                    LifeTime = 0;
                    UlTrace(LOGGING, ("CopyTimeStampField: failure.\n"));
                }
                LifeTime /= (10*1000); // Conversion from 100-nanosecond to millisecs.

                psz = UlStrPrintUlonglong(psz, (ULONGLONG)LifeTime,',');
                *psz++ = ' ';

                psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,',');
                *psz++ = ' ';

                psz = UlStrPrintUlonglong(psz, pLogData->BytesTransferred,',');
                *psz++ = ' ';

                // Fragment three
                RtlCopyMemory( psz,
                              &pTracker->pUriEntry->pLogData[pLogData->UsedOffset1],
                               pLogData->UsedOffset2
                               );                
                psz += pLogData->UsedOffset2;
                    
                // Calculate the full size of the final log line

                pLogData->Used += (ULONG) DIFF(psz - &pLogData->Line[0]);

                // Reset the UsedOffset1 & 2 to zero to tell that the log line
                // is not fragmented anymore but a complete line.
                
                pLogData->UsedOffset1 = pLogData->UsedOffset2 = 0;
            }
            break;

            default:
            ASSERT(!"Unknown Log Format.\n");

        }

    }

    //
    // For cache hits we can get the corresponding cgroup from uri_cache
    // entry to avoid the costly cgroup lookup. And also not to keep the
    // entry around during the logging process we will have a direct ref
    // to the actual cgroup. DestroyLogBuffer will release this refcount
    //

    if ( pTracker->pUriEntry->ConfigInfo.pLoggingConfig != NULL )
    {
        REFERENCE_CONFIG_GROUP(pTracker->pUriEntry->ConfigInfo.pLoggingConfig);
        pLogData->pConfigGroup = pTracker->pUriEntry->ConfigInfo.pLoggingConfig;
    }

    pTracker->pLogData = NULL;

    //
    // We cannot allow send-response to resume parsing otherwise request buffers
    // will be freed up. Therefore complete inline for the time being.
    //
    
    // UL_QUEUE_WORK_ITEM( &pLogData->WorkItem, &UlLogHttpCacheHitWorker);

    UlLogHttpCacheHitWorker( &pLogData->WorkItem );  

    return Status;
}

/***************************************************************************++

Routine Description:

    UlLogHttpCacheHitWorker :

        Please read the description of UlLogHttpHit first.

        Here where we log the cache hits. We use cache entry itself -
        acquired from tracker - . Some fields are generated at this
        time; i.e. timetaken,date,time...

Arguments:

        PUL_WORK_ITEM : Will point us to the right pLogData

--***************************************************************************/

VOID
UlLogHttpCacheHitWorker(
    IN PUL_WORK_ITEM        pWorkItem
    )
{
    NTSTATUS                Status;
    PUL_INTERNAL_REQUEST    pRequest;
    PUL_LOG_DATA_BUFFER     pLogData;
    PCHAR                   psz;
    PCHAR                   pBuffer;
    LONGLONG                LifeTime;
    LARGE_INTEGER           CurrentTimeStamp;
    ULONG                   BytesWritten;
    PUL_LOG_FILE_ENTRY      pEntry;
    ULONG                   Flags;

    //
    // A Lot of sanity checks.
    //

    PAGED_CODE();

    pLogData = CONTAINING_RECORD(
                    pWorkItem,
                    UL_LOG_DATA_BUFFER,
                    WorkItem
                    );

    ASSERT(pLogData);

    UlTrace(LOGGING,("Ul!UlLogHttpCacheHitWorker: pLogData %p\n", pLogData));

    pRequest = pLogData->pRequest;
    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    //
    // Unlike the LogHttpHit function for non-cache hits we do not require
    // the pResponse here.  Tracker & pRequest  already provides the  info
    // about how much data we sent & the time taken.
    //

    if (pLogData->pConfigGroup == NULL ||
        IS_LOGGING_DISABLED(pLogData->pConfigGroup))
    {
        ASSERT(pLogData->pConfigGroup != NULL);

        UlTrace( LOGGING,
            ("Http!UlLogHttpCacheHitWorker: Skipping pLogData->pConfigGroup %p\n",
              pLogData->pConfigGroup
              ));
        //
        // If logging is disabled or log settings don't exist then do not
        // proceed. Just exit out. But not before cleanup still goto end.
        //

        Status = STATUS_SUCCESS;
        goto end;
    }

    ASSERT(IS_VALID_CONFIG_GROUP(pLogData->pConfigGroup));

    //
    // Construct the remaining fields before logging out this hit.
    //

    switch(pLogData->Format)
    {
        case HttpLoggingTypeW3C:
        {      
            Flags = pLogData->Flags;
            
            // First write the date & time fields to the beginning reserved
            // space. Do not increment the used counter for date & time, b/c
            // CaptureLogFields already did this when reserving the space.

            psz = &pLogData->Line[0];
            
            if ( Flags & MD_EXTLOG_DATE )
            {   
                BytesWritten = 0;
                UlpGetDateTimeFields(
                                       HttpLoggingTypeW3C,
                                       psz,
                                      &BytesWritten,
                                       NULL,
                                       NULL
                                       );
                psz += BytesWritten; *psz++ = ' ';
                ASSERT(BytesWritten == 10);
            }

            if ( Flags & MD_EXTLOG_TIME )
            {   
                BytesWritten = 0;
                UlpGetDateTimeFields(
                                       HttpLoggingTypeW3C,
                                       NULL,
                                       NULL,
                                       psz,
                                      &BytesWritten
                                       );
                psz += BytesWritten; *psz++ = ' ';
                ASSERT(BytesWritten == 8);
            }

            pBuffer = psz = &pLogData->Line[pLogData->Used];

            // For pure cache hits we have to generate the few more fields

            if ( pLogData->CacheAndSendResponse == FALSE )
            {
                // Capture log fields from Request alive

                if ( Flags & MD_EXTLOG_USERNAME ) 
                { 
                    *psz++ = '-'; *psz++ = ' ';
                }

                if ( Flags & MD_EXTLOG_CLIENT_IP ) 
                { 
                    psz = UlStrPrintIP(
                            psz,
                            pRequest->pHttpConn->pConnection->RemoteAddress,
                            ' '
                            );
                }

                if ( Flags & MD_EXTLOG_PROTOCOL_VERSION ) 
                {    
                    psz = UlStrPrintStr(
                            psz, 
                            UL_GET_NAME_FOR_HTTP_VERSION(pRequest->Version),
                            ' '
                            );
                }

                if ( Flags & MD_EXTLOG_USER_AGENT ) 
                {  
                    if (pRequest->HeaderValid[HttpHeaderUserAgent] &&
                        pRequest->Headers[HttpHeaderUserAgent].HeaderLength)
                    {
                        psz = UlStrPrintStrC(
                                psz, 
                                (const CHAR *)pRequest->Headers[HttpHeaderUserAgent].pHeader,
                                ' '
                                );                        
                    }
                    else
                    {
                        *psz++ = '-'; *psz++ = ' ';
                    }
                }
                
                if ( Flags & MD_EXTLOG_COOKIE ) 
                {   
                    if (pRequest->HeaderValid[HttpHeaderCookie] &&
                        pRequest->Headers[HttpHeaderCookie].HeaderLength)
                    {
                        psz = UlStrPrintStrC(
                                psz, 
                                (const CHAR *)pRequest->Headers[HttpHeaderCookie].pHeader,
                                ' '
                                );
                    }
                    else
                    {
                        *psz++ = '-'; *psz++ = ' ';
                    }                
                }

                if ( Flags & MD_EXTLOG_REFERER ) 
                {  
                    if (pRequest->HeaderValid[HttpHeaderReferer] &&
                        pRequest->Headers[HttpHeaderReferer].HeaderLength)
                    {
                        psz = UlStrPrintStrC(
                                psz, 
                                (const CHAR *)pRequest->Headers[HttpHeaderReferer].pHeader,
                                ' '
                                );
                    }
                    else
                    {
                        *psz++ = '-'; *psz++ = ' ';
                    }                
                }

                if ( Flags & MD_EXTLOG_HOST ) 
                {  
                    if (pRequest->HeaderValid[HttpHeaderHost] &&
                        pRequest->Headers[HttpHeaderHost].HeaderLength)
                    {
                        psz = UlStrPrintStrC(
                                psz, 
                                (const CHAR *)pRequest->Headers[HttpHeaderHost].pHeader,
                                ' '
                                );
                    }
                    else
                    {
                        *psz++ = '-'; *psz++ = ' ';
                    }
                }

            }
            
            // Now proceed with the remaining fields, but add them to the end.

            if ( pLogData->Flags & MD_EXTLOG_BYTES_SENT )
            {
                psz = UlStrPrintUlonglong(psz, pLogData->BytesTransferred,' ');
            }
            if ( pLogData->Flags & MD_EXTLOG_BYTES_RECV )
            {
                psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,' ');
            }
            if ( pLogData->Flags & MD_EXTLOG_TIME_TAKEN )
            {
                KeQuerySystemTime( &CurrentTimeStamp );
                LifeTime = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;

                if (LifeTime < 0)
                {
                    LifeTime = 0;
                    UlTrace( LOGGING, ("CopyTimeStampField failure.\n"));
                }
                LifeTime /= (10*1000); // Conversion from 100-nanosecond to millisecs.

                psz = UlStrPrintUlonglong(psz, (ULONGLONG)LifeTime,' ');
            }

            // Calculate the used space

            pLogData->Used += (ULONG) DIFF(psz - pBuffer);

            // Eat the last space and write the \r\n to the end.
            // Only if we have any fields picked and written

            if ( pLogData->Used )
            {
                psz = &pLogData->Line[pLogData->Used-1];     // Eat the last space
                *psz++ = '\r'; *psz++ = '\n'; *psz++ = ANSI_NULL;

                pLogData->Used += 1;

                if ( pLogData->Length == 0 )
                {
                    ASSERT( pLogData->Used <= UL_LOG_LINE_BUFFER_SIZE );
                }
                else
                {
                    ASSERT( pLogData->Used <= pLogData->Length );   
                }
            }
            else
            {
                goto end; // No log fields nothing to log
            }
            
            // Cleanup the UsedOffsets            
            pLogData->UsedOffset1 = pLogData->UsedOffset2 = 0;
        }
        break;

        case HttpLoggingTypeNCSA:
        {
            // [date:time GmtOffset] -> "[07/Jan/2000:00:02:23 -0800] "
            // Restore the pointer to the reserved space first.

            psz = &pLogData->Line[pLogData->UsedOffset1];
            *psz++ = '[';

            BytesWritten = 0;
            UlpGetDateTimeFields(
                                   HttpLoggingTypeNCSA,
                                   psz,
                                  &BytesWritten,
                                   NULL,
                                   NULL
                                   );
            psz += BytesWritten; *psz++ = ':';
            ASSERT(BytesWritten == 11);

            BytesWritten = 0;
            UlpGetDateTimeFields(
                                   HttpLoggingTypeNCSA,
                                   NULL,
                                   NULL,
                                   psz,
                                  &BytesWritten
                                   );
            psz += BytesWritten; *psz++ = ' ';
            ASSERT(BytesWritten == 8);

            UlAcquireResourceShared(&g_pUlNonpagedData->LogListResource, TRUE);
            psz = UlStrPrintStr(psz, g_GMTOffset,']');
            UlReleaseResource(&g_pUlNonpagedData->LogListResource);
            *psz++ = ' ';

            ASSERT(((ULONG) DIFF(psz - &pLogData->Line[pLogData->UsedOffset1]) == 29));

            // BytesSent

            pBuffer = psz = &pLogData->Line[pLogData->Used];
            psz = UlStrPrintUlonglong(psz, pLogData->BytesTransferred,'\r');
            pLogData->Used += (ULONG) DIFF(psz - pBuffer);

            // \n\0

            *psz++ = '\n'; *psz++ = ANSI_NULL;
            pLogData->Used += 1;

            // Cleanup the UsedOffsets            
            pLogData->UsedOffset1 = pLogData->UsedOffset2 = 0;
        }
        break;

        case HttpLoggingTypeIIS:
        {
            if ( pLogData->CacheAndSendResponse == TRUE )
            {
                // We need to work on the fragmented log line
                // which is coming from the originaly allocated
                // line but not from cache.

                // Complete Fragment 1

                pBuffer = psz = &pLogData->Line[pLogData->UsedOffset1];
                UlpGetDateTimeFields(
                                       HttpLoggingTypeIIS,
                                       psz,
                                      &BytesWritten,
                                       NULL,
                                       NULL
                                       );
                psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

                UlpGetDateTimeFields(
                                       HttpLoggingTypeIIS,
                                       NULL,
                                       NULL,
                                       psz,
                                      &BytesWritten
                                       );
                psz += BytesWritten; *psz++ = ','; *psz++ = ' ';

                pLogData->UsedOffset1 += (USHORT) DIFF(psz - pBuffer);


                // Complete Fragment 2

                pBuffer = psz = &pLogData->Line[512 + pLogData->UsedOffset2];

                KeQuerySystemTime( &CurrentTimeStamp );
                LifeTime = CurrentTimeStamp.QuadPart - pRequest->TimeStamp.QuadPart;
                if (LifeTime < 0)
                {
                    LifeTime = 0;
                    UlTrace(LOGGING, ("CopyTimeStampField: failure.\n"));
                }
                LifeTime /= (10*1000); // Conversion from 100-nanosecond to millisecs.

                psz = UlStrPrintUlonglong(psz, (ULONGLONG)LifeTime,',');
                *psz++ = ' ';

                psz = UlStrPrintUlonglong(psz, pRequest->BytesReceived,',');
                *psz++ = ' ';

                psz = UlStrPrintUlonglong(psz, pLogData->BytesTransferred,',');
                *psz++ = ' ';

                pLogData->UsedOffset2 += (USHORT) DIFF(psz - pBuffer);

                // Size of the final log line is
                // pLogData->UsedOffset1 + pLogData->UsedOffset2 + pLogData->Used                
            
            }

            // Or else IIS log line is already done. We have completed it before
            // relasing the cache entry.
        }
        break;

        default:
        {
            ASSERT(!"Unknown Log Format Type\n");
            Status = STATUS_INVALID_PARAMETER;
            goto end;
        }
    }

    //
    // Finally this log line is ready to rock. Lets write it out.
    //

    UlAcquireResourceShared(&g_pUlNonpagedData->LogListResource, TRUE);

    pEntry = pLogData->pConfigGroup->pLogFileEntry;

    if (pEntry)
    {
        ASSERT(IS_VALID_LOG_FILE_ENTRY(pEntry));

        Status =
            UlpWriteToLogFile(
                pEntry,
                pLogData->UsedOffset1 + pLogData->UsedOffset2 + pLogData->Used,
               &pLogData->Line[0],
                pLogData->UsedOffset1,
                pLogData->UsedOffset2
                );
    }

    UlReleaseResource(&g_pUlNonpagedData->LogListResource);

end:
    if (pLogData)
    {
        //
        // Cleanup the references & the log buffer
        //

        UlDestroyLogDataBuffer(pLogData);
    }

    #if DBG
    if (!NT_SUCCESS(Status))
    {
        UlTrace(LOGGING,("Http!UlLogHttpcacheHitWorker: failure 0x%08lx \n",
                           Status
                           ));
    }
    #endif

    return;

}

/***************************************************************************++

Routine Description:

    Initializes the Log Date & Time Cache

--***************************************************************************/
VOID
UlpInitializeLogCache(
    VOID
    )
{
    LARGE_INTEGER SystemTime;
    ULONG         LogType;

    ExInitializeFastMutex( &g_LogCacheFastMutex);

    KeQuerySystemTime(&SystemTime);

    for ( LogType=0; LogType<HttpLoggingTypeMaximum; LogType++ )
    {
        UlpGenerateDateAndTimeFields( (HTTP_LOGGING_TYPE) LogType,
                                      SystemTime,
                                      g_UlDateTimeCache[LogType].Date,
                                     &g_UlDateTimeCache[LogType].DateLength,
                                      g_UlDateTimeCache[LogType].Time,
                                     &g_UlDateTimeCache[LogType].TimeLength
                                      );

        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart = SystemTime.QuadPart;
    }
}

/***************************************************************************++

Routine Description:

    Generates all possible types of date/time fields from a LARGE_INTEGER.

Arguments:

    CurrentTime: A 64 bit Time value to be converted.

--***************************************************************************/

VOID
UlpGenerateDateAndTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    IN  LARGE_INTEGER       CurrentTime,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    )
{
    TIME_FIELDS   CurrentTimeFields;
    LARGE_INTEGER CurrentTimeLoc;
    TIME_FIELDS   CurrentTimeFieldsLoc;
    PCHAR         psz;
    LONG          Length;

    // This routine does touch to pageable memory if the default log buffer
    // wasn't sufficent enough to hold log fields and get reallocated from
    // paged pool. For this reason the date&time cache can not use SpinLocks.

    PAGED_CODE();

    ASSERT(LogType < HttpLoggingTypeMaximum);

    RtlTimeToTimeFields( &CurrentTime, &CurrentTimeFields );

    switch(LogType)
    {
    case HttpLoggingTypeW3C:
        //
        // Uses GMT with format as follows;
        //
        // 2000-01-31 00:12:23
        //

        if (pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Year, 4, '-' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Month,2, '-' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Day,  2, '\0');
            *pDateLength = (ULONG) DIFF(psz - pDate);
        }

        if (pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Hour,  2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFields.Second,2, '\0');
            *pTimeLength = (ULONG) DIFF(psz - pTime);
        }
    break;

    case HttpLoggingTypeNCSA:
        //
        // Uses GMT Time with format as follows;
        //
        // 07/Jan/2000 00:02:23
        //

        ExSystemTimeToLocalTime( &CurrentTime, &CurrentTimeLoc );
        RtlTimeToTimeFields( &CurrentTimeLoc, &CurrentTimeFieldsLoc );

        if(pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Day, 2, '/' );
            psz = UlStrPrintStr(psz, UL_GET_MONTH_AS_STR(CurrentTimeFieldsLoc.Month),'/');
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Year,4, '\0');
            *pDateLength = (ULONG) DIFF(psz - pDate);
        }

        if(pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Hour,  2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Second,2, '\0');
            *pTimeLength = (ULONG) DIFF(psz - pTime);
        }
    break;

    case HttpLoggingTypeIIS:
        //
        // Uses LOCAL Time with format as follows;
        // This should be localised if we can solve the problem.
        //
        // 1/31/2000 0:02:03
        //

        ExSystemTimeToLocalTime( &CurrentTime, &CurrentTimeLoc );
        RtlTimeToTimeFields( &CurrentTimeLoc, &CurrentTimeFieldsLoc );

        if (pDate)
        {
            psz = pDate;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Month, 0, '/' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Day,   0, '/' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Year,  0, '\0');
            *pDateLength = (ULONG) DIFF(psz - pDate);
        }

        if(pTime)
        {
            psz = pTime;
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Hour,  0, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Minute,2, ':' );
            psz = UlStrPrintUlongPad(psz, CurrentTimeFieldsLoc.Second,2, '\0');
            *pTimeLength = (ULONG) DIFF(psz - pTime);
        }
    break;

    }

    return;
}

/***************************************************************************++

Routine Description:

    Generates a date header and updates cached value if required.

    Caller should overwrite the terminating null by a space or comma.

Arguments:

    Date and Time are optional. But one of them should be provided.

--***************************************************************************/

VOID
UlpGetDateTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    )
{
    LARGE_INTEGER SystemTime;
    LARGE_INTEGER CacheTime;
    LONG          Length;
    LONGLONG      Timediff;

    PAGED_CODE();

    ASSERT(LogType < HttpLoggingTypeMaximum);
    ASSERT(pDate || pTime);

    //
    // Get the current time.
    //
    KeQuerySystemTime( &SystemTime );

    CacheTime.QuadPart =
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart;

    //
    // Check the difference between the current time, and
    // the cached time.
    //
    Timediff = SystemTime.QuadPart - CacheTime.QuadPart;

    if (Timediff < ONE_SECOND)
    {
        //
        // The cached date&time hasn't gone stale yet.We can copy.
        // Force a barrier around reading the string into memory.
        //

        UL_READMOSTLY_READ_BARRIER();
        if (pDate)
        {
            RtlCopyMemory( pDate,
                           g_UlDateTimeCache[LogType].Date,
                           g_UlDateTimeCache[LogType].DateLength
                           );
            *pDateLength = g_UlDateTimeCache[LogType].DateLength;
        }
        if (pTime)
        {
            RtlCopyMemory( pTime,
                           g_UlDateTimeCache[LogType].Time,
                           g_UlDateTimeCache[LogType].TimeLength
                           );
            *pTimeLength = g_UlDateTimeCache[LogType].TimeLength;
        }
        UL_READMOSTLY_READ_BARRIER();

        //
        // Get grab the cached time value again in case it has been changed.
        // As you notice we do not have a lock around this part of the code.
        //

        if (CacheTime.QuadPart ==
                g_UlDateTimeCache[LogType].LastSystemTime.QuadPart)
        {
            //
            // Value hasn't changed. We are all set.
            //
            return;
        }
        //
        // Otherwise fall down and flush the cache, and then recopy.
        //

    }

    //
    // The cached date & time is stale. We need to update it.
    //

    ExAcquireFastMutex( &g_LogCacheFastMutex );

    //
    // Has someone else updated the time while we were blocked?
    //

    CacheTime.QuadPart =
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart;

    Timediff = SystemTime.QuadPart - CacheTime.QuadPart;

    if (Timediff >= ONE_SECOND)
    {
        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart = 0;
        KeQuerySystemTime( &SystemTime );

        UL_READMOSTLY_WRITE_BARRIER();
        UlpGenerateDateAndTimeFields(
                  LogType,
                  SystemTime,
                  g_UlDateTimeCache[LogType].Date,
                 &g_UlDateTimeCache[LogType].DateLength,
                  g_UlDateTimeCache[LogType].Time,
                 &g_UlDateTimeCache[LogType].TimeLength
                 );
        UL_READMOSTLY_WRITE_BARRIER();

        g_UlDateTimeCache[LogType].LastSystemTime.QuadPart =
            SystemTime.QuadPart;
    }

    //
    // The time has been updated. Copy the new string into
    // the caller's buffer.
    //
    if (pDate)
    {
        RtlCopyMemory( pDate,
                       g_UlDateTimeCache[LogType].Date,
                       g_UlDateTimeCache[LogType].DateLength
                       );
        *pDateLength = g_UlDateTimeCache[LogType].DateLength;
    }

    if (pTime)
    {
        RtlCopyMemory( pTime,
                       g_UlDateTimeCache[LogType].Time,
                       g_UlDateTimeCache[LogType].TimeLength
                       );
        *pTimeLength = g_UlDateTimeCache[LogType].TimeLength;
    }

    ExReleaseFastMutex( &g_LogCacheFastMutex );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ullog.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    ullog.c (UL IIS+ HIT Logging)

Abstract:

    This module implements the logging facilities
    for IIS+ including the NCSA, IIS and W3CE types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/

#ifndef _ULLOG_H_
#define _ULLOG_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Forwarders.
//

typedef struct _UL_FULL_TRACKER *PUL_FULL_TRACKER;
typedef struct _UL_INTERNAL_REQUEST *PUL_INTERNAL_REQUEST;
typedef struct _UL_CONFIG_GROUP_OBJECT *PUL_CONFIG_GROUP_OBJECT;

//
// Brief information about how logging locks works; Whole link list is controlled
// by a global EResource g_pUlNonpagedData->LogListResource. Functions that require
// read access to this list are Hit(),CacheHit() & BufferFlush() and the ReCycle().
// Whereas functions that requires write access are Create(),Remove() and ReConfig().
// Also the log entry eresource (EntryResource) controls the per entry buffer.
// This eresource is acquired shared for the log hits.
//

//
// Structure to hold a log file buffer
//

typedef struct _UL_LOG_FILE_BUFFER
{
    //
    // PagedPool
    //

    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY   LookasideEntry;

    //
    // Signature is UL_LOG_FILE_BUFFER_POOL_TAG.
    //

    ULONG               Signature;

    //
    // I/O status block for UlpBufferFlushAPC.
    //

    IO_STATUS_BLOCK     IoStatusBlock;

    //
    // Bytes used in the allocated buffered space.
    //

    LONG                BufferUsed;

    //
    // The real buffered space for log records.
    //

    PUCHAR              Buffer;

} UL_LOG_FILE_BUFFER, *PUL_LOG_FILE_BUFFER;

#define IS_VALID_LOG_FILE_BUFFER( entry )                             \
    ( (entry != NULL) && ((entry)->Signature == UL_LOG_FILE_BUFFER_POOL_TAG) )

//
// Structure to hold info for a log file
//

typedef struct _UL_LOG_FILE_ENTRY
{
    //
    // Signature is UL_LOG_FILE_ENTRY_POOL_TAG.
    //

    ULONG               Signature;

    //
    // This lock protects the whole entry. The ZwWrite operation
    // that's called after the lock acquired cannot run at APC_LEVEL
    // therefore we have to go back to eresource to prevent a bugcheck
    //

    UL_ERESOURCE          EntryResource;

    //
    // The name of the file. Full path including the directory.
    //

    UNICODE_STRING      FileName;
    PWSTR               pShortName;

    //
    // The open file handle. Note that this handle is only valid
    // in the context of the system process.
    //

    HANDLE              hFile;

    //
    // File-specific information gleaned from the file system.
    //

    FILE_STANDARD_INFORMATION FileInfo;

    //
    // links all log file entries
    //

    LIST_ENTRY          LogFileListEntry;

    HTTP_LOGGING_TYPE   Format;
    HTTP_LOGGING_PERIOD Period;
    ULONG               TruncateSize;
    ULONG               LogExtFileFlags;

    //
    // Time to expire field in terms of Hours.
    // This could be at most 24 * 31, that's for monthly
    // log cycling. Basically we keep a single periodic hourly
    // timer and every time it expires we traverse the
    // log list to figure out which log files are expired
    // at that time by looking at this fields. And then we
    // recylcle the log if necessary.
    //

    ULONG               TimeToExpire;

    //
    // If this entry has MAX_SIZE or UNLIMITED
    // log period
    //

    ULONG               SequenceNumber;
    ULARGE_INTEGER      TotalWritten;

    //
    // To be able to close the file handle on threadpool.
    //

    UL_WORK_ITEM        WorkItem;
    KEVENT              CloseEvent;

    // TODO: Usage for RecyclePending Flag
    // TODO: If disk was full during the last recycle of this entry.
    // TODO: This value get set. And later (every 1 minute) it might be
    // TODO: (if there's any space then) reset by DISKFULL_TIMER
    // TODO: if none of the entries in the list is pending anymore
    // TODO: then timer get destroyed until when we hit to disk full
    // TODO: again.

    union
    {
        // Flags to show the field states mostly. Used by
        // recycling.

        LONG Value;
        struct
        {
            ULONG StaleSequenceNumber:1;
            ULONG StaleTimeToExpire:1;
            ULONG RecyclePending:1;
            ULONG LogTitleWritten:1;
        };

    } Flags;

    //
    // Each log file entry keeps a fixed amount of log buffer.
    // The buffer size is g_AllocationGranularity comes from
    // the system's allocation granularity.
    //

    PUL_LOG_FILE_BUFFER LogBuffer;

} UL_LOG_FILE_ENTRY, *PUL_LOG_FILE_ENTRY;

#define IS_VALID_LOG_FILE_ENTRY( pEntry )   \
    ( (pEntry != NULL) && ((pEntry)->Signature == UL_LOG_FILE_ENTRY_POOL_TAG) )

#define SET_SEQUNCE_NUMBER_STALE(pEntry) do{    \
        pEntry->Flags.StaleSequenceNumber = 1;      \
        }while(FALSE)
#define RESET_SEQUNCE_NUMBER_STALE(pEntry) do{  \
        pEntry->Flags.StaleSequenceNumber = 0;      \
        }while(FALSE)

#define SET_TIME_TO_EXPIRE_STALE(pEntry) do{    \
        pEntry->Flags.StaleTimeToExpire = 1;        \
        }while(FALSE)
#define RESET_TIME_TO_EXPIRE_STALE(pEntry) do{  \
        pEntry->Flags.StaleTimeToExpire = 0;        \
        }while(FALSE)

//
// Some directory name related Macros
//

// Device Prefix
#define UL_LOCAL_PATH_PREFIX         (L"\\??\\")
#define UL_LOCAL_PATH_PREFIX_LENGTH   (4)
#define UL_UNC_PATH_PREFIX           (L"\\dosdevices\\UNC")
#define UL_UNC_PATH_PREFIX_LENGTH     (15)

#define UL_MAX_PATH_PREFIX_LENGTH     (15)

// Put some Limit to the length of the Log Directory name will
// be passed down by WAS. In Bytes.
#define UL_MAX_FULL_PATH_DIR_NAME_SIZE (10*1024)

#define IS_VALID_DIR_NAME(s)                                                          \
            (((s)!=NULL) &&                                                             \
             ((s)->MaximumLength > (s)->Length) &&                                      \
             ((s)->Length != 0) &&                                                      \
             ((s)->Buffer != NULL) &&                                                   \
             ((s)->Buffer[(s)->Length/sizeof(WCHAR)] == UNICODE_NULL) &&                \
             ((s)->MaximumLength <= UL_MAX_FULL_PATH_DIR_NAME_SIZE)                     \
            )

//
// Followings are all parts of our internal buffer to hold
// the Logging information. We copy over this info from WP
// buffer upon SendResponse request. Yet few of this fields
// are calculated directly by us and filled.
//

typedef enum _UL_LOG_FIELD_TYPE
{
    UlLogFieldDate = 0,         // 0
    UlLogFieldTime,    
    UlLogFieldSiteName,
    UlLogFieldServerName,
    UlLogFieldServerIp,         
    UlLogFieldMethod,           // 5
    UlLogFieldUriStem,
    UlLogFieldUriQuery,
    UlLogFieldProtocolStatus,    
    UlLogFieldWin32Status,      
    UlLogFieldServerPort,       // 10
    UlLogFieldUserName,
    UlLogFieldClientIp,    
    UlLogFieldProtocolVersion,
    UlLogFieldUserAgent,        
    UlLogFieldCookie,           // 15
    UlLogFieldReferrer,
    UlLogFieldHost,
    UlLogFieldBytesSent,
    UlLogFieldBytesReceived,
    UlLogFieldTimeTaken,        // 20

    UlLogFieldMaximum

} UL_LOG_FIELD_TYPE, *PUL_LOG_FIELD_TYPE;

//
// Size of the pre-allocated log line buffer inside the request structure.
//

#define UL_LOG_LINE_BUFFER_SIZE                (4*1024)

#define UL_MAX_LOG_LINE_BUFFER_SIZE            (10*1024)

#define UL_MAX_TITLE_BUFFER_SIZE                (512)

//
// To avoid the infinite loop situation we have  to set  the  minimum
// allowable log file size to something bigger than maximum allowable
// log record line;
//

#define UL_MIN_ALLOWED_TRUNCATESIZE            (16*1024)

C_ASSERT(UL_MIN_ALLOWED_TRUNCATESIZE > 
               (UL_MAX_TITLE_BUFFER_SIZE + UL_MAX_LOG_LINE_BUFFER_SIZE));

//
// If somebody overwrites the default log buffering size which
// is system granularity size of 64K. We have to make sure the
// buffer size is not smaller then miminum allowed. Which   is
// MaximumAlowed Logrecord size of 10K. Also it  should be  4k
// aligned therefore makes it 12k at least.
//

#define MINIMUM_ALLOWED_LOG_BUFFER_SIZE         (12*1024)

C_ASSERT(MINIMUM_ALLOWED_LOG_BUFFER_SIZE > 
               (UL_MAX_TITLE_BUFFER_SIZE + UL_MAX_LOG_LINE_BUFFER_SIZE));

#define MAXIMUM_ALLOWED_LOG_BUFFER_SIZE         (64*1024)

//
// Following is the definition of the Internal Log Data Buffer.
// It also holds the required pointer to pRequest.
//

typedef struct _UL_LOG_DATA_BUFFER
{
    //
    // A work item, used for queuing to a worker thread.
    //

    UL_WORK_ITEM            WorkItem;

    //
    // Our private pointer to the Internal Request structure
    // to be ensure to have the request around until we are done
    // with logging. Even if connection get reset by client, before
    // we get a chance to log. See the definition of UlLogHttpHit
    // for further complicated comments.
    //

    PUL_INTERNAL_REQUEST    pRequest;

    //
    // For Cache&Send Responses we won't be copying and allocating
    // a new internal buffer again and again but instead will keep
    // the original we have allocated during the capturing the res-
    // ponse. This flag shows that the buffer is ready as it is and
    // no need to copy over log data from cache again.
    //

    BOOLEAN                 CacheAndSendResponse;

    //
    // The total amount of send_response bytes
    //

    ULONGLONG               BytesTransferred;

    //
    // For cache hits we can get the corresponding cgroup frm uri_cache
    // entry to avoid the costly cgroup lookup.
    //

    PUL_CONFIG_GROUP_OBJECT pConfigGroup;

    //
    // Capture the log format/flags when the sendresponse happens. And
    // discard the changes to it during the hit processing.
    //

    HTTP_LOGGING_TYPE       Format;

    ULONG                   Flags;

    //
    // Total length of the required fields in the final output buffer
    // according to the Log Type & Syntax and included fields.
    // It's in WideChars
    //

    ULONG                   Length;

    ULONG                   Used;

    //
    // Individual log fields are captured in the following
    // line. For NCSA and IIS formats two additional ushort
    // fields keep private offsets that represents either
    // the beginning of a certain field ( date for NCSA )
    // or the used amount from the each fragment ( for IIS )
    // Refer to UlpBuildCacheEntry for their usage.
    //

    USHORT                  UsedOffset1;
    USHORT                  UsedOffset2;

    //
    // The actual log line for W3C & NCSA formats. IIS reformat and allocate
    // a new buffer.
    //

    PCHAR                   Line;
    CHAR                    Buffer[UL_LOG_LINE_BUFFER_SIZE];

} UL_LOG_DATA_BUFFER, *PUL_LOG_DATA_BUFFER;


#define NCSA_FIX_DATE_AND_TIME_FIELD_SIZE       (29)

//
// IIS Log line is fragmented at the capture time the offsets
// are as follows and never get changed even if buffer get re
// allocated.
//

#define IIS_LOG_LINE_FIRST_FRAGMENT_OFFSET      (0)

#define IIS_LOG_LINE_SECOND_FRAGMENT_OFFSET     (512)

#define IIS_LOG_LINE_THIRD_FRAGMENT_OFFSET      (1024)


//
// The HTTP Hit Logging functions which we expose in this module.
//

NTSTATUS
UlInitializeLogs(
    VOID
    );

VOID
UlTerminateLogs(
    VOID
    );

NTSTATUS
UlSetUTF8Logging (
    IN BOOLEAN UTF8Logging
    );

NTSTATUS
UlCreateLog(
    IN OUT PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

VOID
UlRemoveLogFileEntry(
    PUL_LOG_FILE_ENTRY  pEntry
    );

VOID
UlLogTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlLogTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

VOID
UlBufferTimerHandler(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlBufferTimerDpcRoutine(
    PKDPC Dpc,
    PVOID DeferredContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
    );

NTSTATUS
UlReConfigureLogEntry(
    IN  PUL_CONFIG_GROUP_OBJECT     pConfigGroup,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    );

NTSTATUS
UlProbeLogData(
    IN PHTTP_LOG_FIELDS_DATA pLogData
    );

NTSTATUS
UlCaptureLogFieldsW3C(
    IN  PHTTP_LOG_FIELDS_DATA pLogData,
    IN  HTTP_VERSION          Version,
    OUT PUL_LOG_DATA_BUFFER   pLogBuffer
    );

NTSTATUS
UlCaptureLogFieldsNCSA(
    IN  PHTTP_LOG_FIELDS_DATA pLogData,
    IN  HTTP_VERSION          Version,
    OUT PUL_LOG_DATA_BUFFER   pLogBuffer
    );

NTSTATUS
UlCaptureLogFieldsIIS(
    IN  PHTTP_LOG_FIELDS_DATA   pLogData,
    IN  HTTP_VERSION            Version,
    OUT PUL_LOG_DATA_BUFFER     pLogBuffer
    );

__inline
NTSTATUS
FASTCALL
UlCaptureLogFields(
    IN  PHTTP_LOG_FIELDS_DATA   pLogData,
    IN  HTTP_VERSION            Version,
    OUT PUL_LOG_DATA_BUFFER     pLogBuffer
    )
{
    switch( pLogBuffer->Format )
    {
        case HttpLoggingTypeW3C:
            return UlCaptureLogFieldsW3C( pLogData, Version, pLogBuffer );
        break;

        case HttpLoggingTypeNCSA:
            return UlCaptureLogFieldsNCSA( pLogData, Version, pLogBuffer );
        break;

        case HttpLoggingTypeIIS:
            return UlCaptureLogFieldsIIS( pLogData, Version, pLogBuffer );
        break;

        default:
        ASSERT(!"Unknown Log Format.\n");
        return STATUS_INVALID_PARAMETER;
    }

}

NTSTATUS
UlAllocateLogDataBuffer(
    OUT PUL_LOG_DATA_BUFFER     pLogData,
    IN  PUL_INTERNAL_REQUEST    pRequest,
    IN  PUL_CONFIG_GROUP_OBJECT pConfigGroup
    );

VOID
UlDestroyLogDataBufferWorker(
    IN PUL_WORK_ITEM    pWorkItem
    );

/***************************************************************************++

Routine Description:

    Wrapper function to ensure we are not touching to paged-pool allocated
    large log buffer on elevated IRQL. It's important that this function has
    been written with the assumption of Request doesn't go away until we
    properly execute the possible passive worker. This is indeed the case
    because request(with the embedded logdata) has been refcounted up by the
    logdata.

Arguments:

    pLogData   -   The buffer to be destroyed

--***************************************************************************/

__inline
VOID
FASTCALL
UlDestroyLogDataBuffer(
    IN PUL_LOG_DATA_BUFFER  pLogData
    )
{
    //
    // Sanity check
    //

    ASSERT(pLogData);

    //
    // If we are running on elevated IRQL and large log line allocated
    // then queue a passive worker otherwise complete inline.
    //

    if (pLogData->Length > UL_LOG_LINE_BUFFER_SIZE)
    {
        UL_CALL_PASSIVE( &pLogData->WorkItem,
                           &UlDestroyLogDataBufferWorker );
    }
    else
    {
        UlDestroyLogDataBufferWorker( &pLogData->WorkItem );
    }

}

NTSTATUS
UlLogHttpHit(
    IN PUL_LOG_DATA_BUFFER  pLogBuffer
    );

NTSTATUS
UlLogHttpCacheHit(
        IN PUL_FULL_TRACKER pTracker
        );

NTSTATUS
UlCheckLogDirectory(
    IN  PUNICODE_STRING pDirName
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _ULLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ullogp.h ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    ullog.c (UL IIS+ HIT Logging)

Abstract:

    This module implements the logging facilities
    for IIS+ including the NCSA, IIS and W3CE types
    of logging.

Author:

    Ali E. Turkoglu (aliTu)       10-May-2000

Revision History:

--*/


#ifndef _ULLOGP_H_
#define _ULLOGP_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Private definitions for the Ul Logging Module
//

#define UTF8_LOGGING_ENABLED()           (g_UTF8Logging)

#define _UL_GET_LOG_FILE_NAME_PREFIX(x)                             \
    (   (x) == HttpLoggingTypeW3C   ? L"\\extend" :                 \
        (x) == HttpLoggingTypeIIS   ? L"\\inetsv" :                 \
        (x) == HttpLoggingTypeNCSA  ? L"\\ncsa"   : L"\\unknwn"     \
        )

#define _UL_GET_LOG_FILE_NAME_PREFIX_UTF8(x)                        \
    (   (x) == HttpLoggingTypeW3C   ? L"\\u_extend" :               \
        (x) == HttpLoggingTypeIIS   ? L"\\u_inetsv" :               \
        (x) == HttpLoggingTypeNCSA  ? L"\\u_ncsa"   : L"\\u_unknwn" \
        )

#define UL_GET_LOG_FILE_NAME_PREFIX(x) \
    (UTF8_LOGGING_ENABLED() ? _UL_GET_LOG_FILE_NAME_PREFIX_UTF8(x) :\
                              _UL_GET_LOG_FILE_NAME_PREFIX(x))

#define SPACE_TO_PLUS_CONVERSION_REQUIRED(x)            \
    (   (x) == UlLogFieldCookie                 ||      \
        (x) == UlLogFieldReferrer               ||      \
        (x) == UlLogFieldUserAgent              ||      \
        (x) == UlLogFieldHost )

//
// Obsolete - Only used by Old Hit
// Replace this with a switch statement inside a inline function
// which is  more efficient, if u start using it again
//

#define UL_GET_NAME_FOR_HTTP_VERB(v)                            \
    (   (v) == HttpVerbUnparsed  ? L"UNPARSED" :                \
        (v) == HttpVerbUnknown   ? L"UNKNOWN" :                 \
        (v) == HttpVerbInvalid   ? L"INVALID" :                 \
        (v) == HttpVerbOPTIONS   ? L"OPTIONS" :                 \
        (v) == HttpVerbGET       ? L"GET" :                     \
        (v) == HttpVerbHEAD      ? L"HEAD" :                    \
        (v) == HttpVerbPOST      ? L"POST" :                    \
        (v) == HttpVerbPUT       ? L"PUT" :                     \
        (v) == HttpVerbDELETE    ? L"DELETE" :                  \
        (v) == HttpVerbTRACE     ? L"TRACE" :                   \
        (v) == HttpVerbCONNECT   ? L"CONNECT" :                 \
        (v) == HttpVerbTRACK     ? L"TRACK" :                   \
        (v) == HttpVerbMOVE      ? L"MOVE" :                    \
        (v) == HttpVerbCOPY      ? L"COPY" :                    \
        (v) == HttpVerbPROPFIND  ? L"PROPFIND" :                \
        (v) == HttpVerbPROPPATCH ? L"PROPPATCH" :               \
        (v) == HttpVerbMKCOL     ? L"MKCOL" :                   \
        (v) == HttpVerbLOCK      ? L"LOCK" :                    \
        (v) == HttpVerbUNLOCK    ? L"UNLOCK" :                  \
        (v) == HttpVerbSEARCH    ? L"SEARCH" :                  \
        L"???"                                                  \
        )

#define UL_SET_BITMASKS_FOR_LOG_FIELDS(table)                                   \
    do {                                                                        \
                                                                                \
        table[UlLogFieldDate].FieldMask           = MD_EXTLOG_DATE;             \
        table[UlLogFieldTime].FieldMask           = MD_EXTLOG_TIME;             \
        table[UlLogFieldClientIp].FieldMask       = MD_EXTLOG_CLIENT_IP;        \
        table[UlLogFieldUserName].FieldMask       = MD_EXTLOG_USERNAME;         \
        table[UlLogFieldSiteName].FieldMask       = MD_EXTLOG_SITE_NAME;        \
        table[UlLogFieldServerName].FieldMask     = MD_EXTLOG_COMPUTER_NAME;    \
        table[UlLogFieldServerIp].FieldMask       = MD_EXTLOG_SERVER_IP;        \
        table[UlLogFieldMethod].FieldMask         = MD_EXTLOG_METHOD;           \
        table[UlLogFieldUriStem].FieldMask        = MD_EXTLOG_URI_STEM;         \
        table[UlLogFieldUriQuery].FieldMask       = MD_EXTLOG_URI_QUERY;        \
        table[UlLogFieldProtocolStatus].FieldMask = MD_EXTLOG_HTTP_STATUS;      \
        table[UlLogFieldWin32Status].FieldMask    = MD_EXTLOG_WIN32_STATUS;     \
        table[UlLogFieldBytesSent].FieldMask      = MD_EXTLOG_BYTES_SENT;       \
        table[UlLogFieldBytesReceived].FieldMask  = MD_EXTLOG_BYTES_RECV;       \
        table[UlLogFieldTimeTaken].FieldMask      = MD_EXTLOG_TIME_TAKEN;       \
        table[UlLogFieldServerPort].FieldMask     = MD_EXTLOG_SERVER_PORT;      \
        table[UlLogFieldUserAgent].FieldMask      = MD_EXTLOG_USER_AGENT;       \
        table[UlLogFieldCookie].FieldMask         = MD_EXTLOG_COOKIE;           \
        table[UlLogFieldReferrer].FieldMask       = MD_EXTLOG_REFERER;          \
        table[UlLogFieldProtocolVersion].FieldMask= MD_EXTLOG_PROTOCOL_VERSION; \
        table[UlLogFieldHost].FieldMask           = MD_EXTLOG_HOST;             \
                                                                                \
    } while(FALSE)


#define UL_DEFAULT_NCSA_FIELDS          (MD_EXTLOG_CLIENT_IP                | \
                                         MD_EXTLOG_USERNAME                 | \
                                         MD_EXTLOG_DATE                     | \
                                         MD_EXTLOG_TIME                     | \
                                         MD_EXTLOG_METHOD                   | \
                                         MD_EXTLOG_URI_STEM                 | \
                                         MD_EXTLOG_URI_QUERY                | \
                                         MD_EXTLOG_PROTOCOL_VERSION         | \
                                         MD_EXTLOG_HTTP_STATUS              | \
                                         MD_EXTLOG_BYTES_SENT)

#define UL_DEFAULT_IIS_FIELDS           (MD_EXTLOG_CLIENT_IP                | \
                                         MD_EXTLOG_USERNAME                 | \
                                         MD_EXTLOG_DATE                     | \
                                         MD_EXTLOG_TIME                     | \
                                         MD_EXTLOG_SITE_NAME                | \
                                         MD_EXTLOG_COMPUTER_NAME            | \
                                         MD_EXTLOG_SERVER_IP                | \
                                         MD_EXTLOG_TIME_TAKEN               | \
                                         MD_EXTLOG_BYTES_RECV               | \
                                         MD_EXTLOG_BYTES_SENT               | \
                                         MD_EXTLOG_HTTP_STATUS              | \
                                         MD_EXTLOG_WIN32_STATUS             | \
                                         MD_EXTLOG_METHOD                   | \
                                         MD_EXTLOG_URI_STEM)

#define UL_GET_LOG_TYPE_MASK(x,y)                                     \
    (   (x) == HttpLoggingTypeW3C   ? (y) :                           \
        (x) == HttpLoggingTypeIIS   ? UL_DEFAULT_IIS_FIELDS  :        \
        (x) == HttpLoggingTypeNCSA  ? UL_DEFAULT_NCSA_FIELDS : 0      \
        )

//
// The order of the following should match with
// UL_LOG_FIELD_TYPE type definition.
//

PWSTR UlFieldTitleLookupTable[] =
    {
        L" date",
        L" time",        
        L" s-sitename",
        L" s-computername",
        L" s-ip",
        L" cs-method",
        L" cs-uri-stem",
        L" cs-uri-query", 
        L" sc-status",
        L" sc-win32-status",
        L" s-port",
        L" cs-username",        
        L" c-ip",        
        L" cs-version",
        L" cs(User-Agent)",
        L" cs(Cookie)",
        L" cs(Referer)",
        L" cs-host",
        L" sc-bytes",
        L" cs-bytes",
        L" time-taken"
    };

#define UL_GET_LOG_FIELD_TITLE(x)      \
        ((x)>=UlLogFieldMaximum ? L"Unknown" : UlFieldTitleLookupTable[(x)])

#define UL_GET_LOG_TITLE_IF_PICKED(x,y,z)  \
        ((y)&(z) ? UL_GET_LOG_FIELD_TITLE((x)) : L"")

//
// Maximum possible log file name length
//
// \u_extend12345678901234567890.log  => 33 chars -> 66 bytes
//

// Generic Full Path File Name Length. Same as MAX_PATH
// should be greater than above number.

#define UL_MAX_FILE_NAME_SUFFIX_LENGTH        (260)

#define DEFAULT_LOG_FILE_EXTENSION          L"log"
#define DEFAULT_LOG_FILE_EXTENSION_PLUS_DOT L".log"

#define SIZE_OF_GMT_OFFSET              (6)

#define UL_GET_NAME_FOR_HTTP_VERSION(v)                            \
    (   HTTP_EQUAL_VERSION((v), 0, 9)   ? "HTTP/0.9" :             \
        HTTP_EQUAL_VERSION((v), 1, 0)   ? "HTTP/1.0" :             \
        HTTP_EQUAL_VERSION((v), 1, 1)   ? "HTTP/1.1" :             \
        "HTTP/?.?"                                                 \
        )
#define UL_HTTP_VERSION_LENGTH          (8)

#define IS_LOGGING_DISABLED(g)                                      \
    ((g) == NULL ||                                                 \
     (g)->LoggingConfig.Flags.Present == 0 ||                       \
     (g)->LoggingConfig.LoggingEnabled == FALSE)

//
// Little utility to make life happier
//

const PSTR _Months[] =
{
    "Jan", "Feb", "Mar", "Apr", "May", "Jun",
    "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
};

#define UL_GET_MONTH_AS_STR(m)                                     \
    ( ((m)>=1) && ((m)<=12) ? _Months[(m)-1] : "Unk" )


//
// Following is used when storing logging data to UL Cache.
//

typedef struct _UL_CACHE_LOG_FIELD
{
    UL_LOG_FIELD_TYPE   Type;          // Field Type
    ULONG               Length;        // Field length in Bytes

    PWSTR               FieldValue;    // The Log Field Itself

} UL_CACHE_LOG_FIELD, *PUL_CACHE_LOG_FIELD;


#define DEFAULT_MAX_LOG_BUFFER_SIZE  (0x00010000)


//
// Cached Date header string.
//

#define ONE_SECOND              (10000000)

#define DATE_LOG_FIELD_LENGTH   (15)
#define TIME_LOG_FIELD_LENGTH   (8)

typedef struct _UL_LOG_DATE_AND_TIME_CACHE
{

    CHAR           Date[DATE_LOG_FIELD_LENGTH+1];
    ULONG          DateLength;
    CHAR           Time[TIME_LOG_FIELD_LENGTH+1];
    ULONG          TimeLength;

    LARGE_INTEGER  LastSystemTime;

} UL_LOG_DATE_AND_TIME_CACHE, *PUL_LOG_DATE_AND_TIME_CACHE;

//
// Buffer flush out period in minutes.
//

#define DEFAULT_BUFFER_TIMER_PERIOD         (1)

//
// The amount of buffer allocated for directory search  query during
// initialization. Pick this big enough to avoid too  many  querries
// 4K provides enough size for 40 something filenames.  Increase  it
// for faster startups with too many sites and/or too many log files
//

#define UL_DIRECTORY_SEARCH_BUFFER_SIZE     (4*1024)

//
// UlpWriteW3CLogRecord attempts to use a buffer size upto this
//

#define UL_DEFAULT_WRITE_BUFFER_LEN         (512)

// For W3C log format, max overhead for the fix length fields 
// which will be generated per hit (non-cache) is as follows;

// Date & Time  : 20
// PStatus      : MAX_ULONG_STR + 1 (11)
// Win32Status  : MAX_ULONG_STR + 1 
// ServerPort   : MAX_ULONG_STR + 1 
// PVersion     : UL_HTTP_VERSION_LENGTH + 1
// BSent        : MAX_ULONGLONG_STR + 1 (21)
// TTaken       : MAX_ULONGLONG_STR + 1
// BReceived    : MAX_ULONGLONG_STR + 1
// \r\n\0       : 3
// TOTAL        : 128

#define MAX_W3C_FIX_FIELD_OVERHEAD          (128)

// For NCSA log format, max overhead for the fix length fields 
// which will be generated per cache hit is as follows;

// Date & Time  : NCSA_FIX_DATE_AND_TIME_FIELD_SIZE
// Fixed dash   : 2
// ClientIp     : MAX_IPV4_STRING_LENGTH + 1 (16)
// UserName     : 2
// PStatus      : MAX_ULONG_STR + 1 (11)
// PVersion     : UL_HTTP_VERSION_LENGTH + 1 + 1    
// BSent        : MAX_ULONGLONG_STR + 1 (21)
// \n\0         : 2
// TOTAL        : 93

#define MAX_NCSA_CACHE_FIELD_OVERHEAD       (96)

// For IIS log format, max overhead for the fix length fields 
// which will be generated per cache hit is as follows;

// Date & Time  : 22
// ClientIp     : MAX_IPV4_STRING_LENGTH + 2 (17)
// UserName     : 3
// PStatus      : MAX_ULONG_STR + 2 (12)
// PVersion     : UL_HTTP_VERSION_LENGTH + 2
// BSent        : MAX_ULONGLONG_STR + 2 (22)
// TTaken       : MAX_ULONGLONG_STR + 2
// BReceived    : MAX_ULONGLONG_STR + 2
// TOTAL        : 124

#define MAX_IIS_CACHE_FIELD_OVERHEAD        (128)

// For W3C log format see the inline function 
// UlpRecalcLogLineLengthW3C.

//
// Private function calls
//

NTSTATUS
UlpConstructLogFileEntry(
    IN  PHTTP_CONFIG_GROUP_LOGGING pConfig,
    OUT PUL_LOG_FILE_ENTRY       * ppEntry,
    OUT PUNICODE_STRING            pDirectoryName,
    IN  PTIME_FIELDS               pCurrentTimeFields
    );

VOID
UlpInsertLogFileEntry(
    PUL_LOG_FILE_ENTRY  pEntry,
    PTIME_FIELDS        pFields
    );

ULONG
UlpGetLogFileLength(
   IN HANDLE hFile
   );

NTSTATUS
UlpAppendW3CLogTitle(
    IN     PUL_LOG_FILE_ENTRY   pEntry,
    OUT    PCHAR                pDestBuffer,
    IN OUT PULONG               pBytesCopied
    );

NTSTATUS
UlpCreateSafeDirectory(
    IN PUNICODE_STRING   pDirectoryName
    );

__inline
ULONG
UlpGetMonthDays(
    IN  PTIME_FIELDS    pDueTime
    )
{
    ULONG   NumDays = 31;

    if ( (4  == pDueTime->Month) ||     // April
         (6  == pDueTime->Month) ||     // June
         (9  == pDueTime->Month) ||     // September
         (11 == pDueTime->Month)        // November
       )
    {
        NumDays = 30;
    }

    if (2 == pDueTime->Month)           // February
    {
        if ((pDueTime->Year % 4 == 0 &&
             pDueTime->Year % 100 != 0) ||
             pDueTime->Year % 400 == 0 )
        {
            //
            // Leap year
            //
            NumDays = 29;
        }
        else
        {
            NumDays = 28;
        }
    }
    return NumDays;
}

NTSTATUS
UlpCalculateTimeToExpire(
     PTIME_FIELDS           pFields,
     HTTP_LOGGING_PERIOD    LogPeriod,
     PULONG                 pTimeRemaining
     );

VOID
UlpInitializeTimers(
    VOID
    );

VOID
UlpTerminateTimers(
    VOID
    );

VOID
UlpSetLogTimer(
     IN PTIME_FIELDS   pFields
     );

VOID
UlpSetBufferTimer(
    VOID
    );

NTSTATUS
UlpRecycleLogFile(
    IN  PUL_LOG_FILE_ENTRY  pEntry
    );

__inline
ULONG UlpWeekOfMonth(
    IN  PTIME_FIELDS    fields
    );

VOID
UlpConstructFileName(
    IN      HTTP_LOGGING_PERIOD period,
    IN      PCWSTR              prefix,
    OUT     PUNICODE_STRING     filename,
    IN      PTIME_FIELDS        fields,
    IN OUT  PULONG              sequenceNu  OPTIONAL
    );

__inline
BOOLEAN
UlpIsLogFileOverFlow(
        IN  PUL_LOG_FILE_ENTRY  pEntry,
        IN  ULONG               ReqdBytes
        );

__inline
VOID
UlpIncrementBytesWritten(
    IN PUL_LOG_FILE_ENTRY  pEntry,
    IN ULONG               BytesWritten
    );

NTSTATUS
UlpUpdateLogFlags(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    );

NTSTATUS
UlpUpdateLogTruncateSize(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew,
    OUT BOOLEAN *                   pHaveToReCycle
    );

NTSTATUS
UlpUpdatePeriod(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    );

NTSTATUS
UlpUpdateFormat(
    OUT PUL_LOG_FILE_ENTRY          pEntry,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgOld,
    IN  PHTTP_CONFIG_GROUP_LOGGING  pCfgNew
    );

NTSTATUS
UlpGrowLogEntry(
    IN PUL_CONFIG_GROUP_OBJECT    pConfigGroup,
    IN PUL_LOG_FILE_ENTRY         pOldEntry
    );

NTSTATUS
UlpDebugCalculateTimeToExpire(
     PTIME_FIELDS           pDueTime,
     HTTP_LOGGING_PERIOD    LogPeriod,
     PULONG                 pTimeRemaining
     );

VOID
UlpGetGMTOffset();

NTSTATUS
UlpInitializeLogBufferGranularity();

NTSTATUS
UlpFlushLogFile(
    IN PUL_LOG_FILE_ENTRY   pFile
    );

VOID
UlLogHttpCacheHitWorker(
        IN PUL_WORK_ITEM        pWorkItem
        );

NTSTATUS
UlpWriteToLogFile(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileShared(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileExclusive(
    IN PUL_LOG_FILE_ENTRY  pFile,
    IN ULONG               RecordSize,
    IN PCHAR               pRecord,
    IN ULONG               UsedOffset1,
    IN ULONG               UsedOffset2
    );

NTSTATUS
UlpWriteToLogFileDebug(
    IN PUL_LOG_FILE_ENTRY   pFile,
    IN ULONG                RecordSize,
    IN PCHAR                pRecord,
    IN ULONG                UsedOffset1,
    IN ULONG                UsedOffset2
    );

VOID
UlpInitializeLogCache(
    VOID
    );

VOID
UlpGenerateDateAndTimeFields(
    IN  HTTP_LOGGING_TYPE   LogType,
    IN  LARGE_INTEGER       CurrentTime,
    OUT PCHAR               pDate,
    OUT PULONG              pDateLength,
    OUT PCHAR               pTime,
    OUT PULONG              pTimeLength
    );

VOID
UlpGetDateTimeFields(
    IN  HTTP_LOGGING_TYPE LogType,
    OUT PCHAR  pDate,
    OUT PULONG pDateLength,
    OUT PCHAR  pTime,
    OUT PULONG pTimeLength
    );

NTSTATUS
UlpQueryDirectory(
    IN OUT PUL_LOG_FILE_ENTRY   pEntry
    );

VOID
UlWaitForBufferIoToComplete(
    VOID
    );

VOID
UlpBufferFlushAPC(
    IN PVOID ApcContext,
    IN PIO_STATUS_BLOCK pIoStatusBlock,
    IN ULONG Reserved
    );

VOID
UlpLogCloseHandleWorker(
    IN PUL_WORK_ITEM    pWorkItem
    );

VOID
UlpLogCloseHandle(
    IN PUL_LOG_FILE_ENTRY  pEntry
    );

__inline
NTSTATUS
FASTCALL
UlpReallocLogLine(
    IN PUL_LOG_DATA_BUFFER pLogData,
    IN ULONG               NewSize
    )
{
    ULONG BytesNeeded = ALIGN_UP(NewSize, PVOID);

    ASSERT(NewSize > UL_LOG_LINE_BUFFER_SIZE);
    
    pLogData->Line = 
        (PCHAR) UL_ALLOCATE_ARRAY(
                    PagedPool,
                    CHAR,
                    BytesNeeded,
                    UL_LOG_DATA_BUFFER_POOL_TAG
                    );                            
    if (pLogData->Line == NULL)
    {
        pLogData->Length = 0;
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pLogData->Length = BytesNeeded;

    return STATUS_SUCCESS;    
    
}

__inline
ULONG
FASTCALL
UlpCalcLogLineLengthW3C(
    IN PHTTP_LOG_FIELDS_DATA pLogData,
    IN ULONG Flags,
    IN ULONG Utf8Multiplier
    )
{
    ULONG   Length = 0;

    // Now see precisely how much we may need:
    // Format specific maximum possible required length calculation for 
    // the incoming log line. The numbers generated here are considerably 
    // greater than the actual number. As we add maximum size for number 
    // fields and Utf8 and Codepage conversions  also double the amount 
    // for UserName & URI Stem fields. Since we do not use temporary buffer
    // to hold fields until send completion, we have to make an early estimation
    // but we have to make sure it's safe as well.
    // 

    Length = (ULONG)(
        ((Flags & MD_EXTLOG_DATE)           ? 11 : 0) +
        ((Flags & MD_EXTLOG_TIME)           ? 9  : 0) +
        ((Flags & MD_EXTLOG_CLIENT_IP)      ? 2 + pLogData->ClientIpLength : 0) +
        ((Flags & MD_EXTLOG_USERNAME)       ? 2 + pLogData->UserNameLength * Utf8Multiplier : 0) +
        ((Flags & MD_EXTLOG_SITE_NAME)      ? 2 + pLogData->ServiceNameLength : 0) +
        ((Flags & MD_EXTLOG_COMPUTER_NAME)  ? 2 + pLogData->ServerNameLength : 0) +
        ((Flags & MD_EXTLOG_SERVER_IP)      ? 2 + pLogData->ServerIpLength : 0) +
        ((Flags & MD_EXTLOG_METHOD)         ? 2 + pLogData->MethodLength : 0) +
        ((Flags & MD_EXTLOG_URI_STEM)       ? 2 + pLogData->UriStemLength * Utf8Multiplier : 0) +
        ((Flags & MD_EXTLOG_URI_QUERY)      ? 2 + pLogData->UriQueryLength : 0) +
        ((Flags & MD_EXTLOG_HTTP_STATUS)    ? 2 + MAX_ULONG_STR : 0) +              // ProtocolStatus
        ((Flags & MD_EXTLOG_WIN32_STATUS)   ? 2 + MAX_ULONG_STR : 0) +              // Win32 Status
        ((Flags & MD_EXTLOG_SERVER_PORT)    ? 2 + MAX_ULONG_STR : 0) +              // ServerPort
        ((Flags & MD_EXTLOG_PROTOCOL_VERSION) ? 2 + UL_HTTP_VERSION_LENGTH : 0) +   // Version
        ((Flags & MD_EXTLOG_USER_AGENT)     ? 2 + pLogData->UserAgentLength : 0) +
        ((Flags & MD_EXTLOG_COOKIE)         ? 2 + pLogData->CookieLength : 0) +
        ((Flags & MD_EXTLOG_REFERER)        ? 2 + pLogData->ReferrerLength : 0) +
        ((Flags & MD_EXTLOG_HOST)           ? 2 + pLogData->HostLength : 0) +
        ((Flags & MD_EXTLOG_BYTES_SENT)     ? 2 + MAX_ULONGLONG_STR : 0) +          // BytesSent
        ((Flags & MD_EXTLOG_BYTES_RECV)     ? 2 + MAX_ULONGLONG_STR : 0) +          // BytesReceived
        ((Flags & MD_EXTLOG_TIME_TAKEN)     ? 2 + MAX_ULONGLONG_STR : 0) +          // TimeTaken
        (3)                                                                         // \r\n\0
        )
        ;
    
    return Length;
    
}

__inline
ULONG
FASTCALL
UlpRecalcLogLineLengthW3C(
    IN ULONG Flags,
    IN PUL_INTERNAL_REQUEST pRequest,
    IN ULONG LengthOfFieldsFrmCache
    )
{
    ULONG NewLength = LengthOfFieldsFrmCache;

    ASSERT(UL_IS_VALID_INTERNAL_REQUEST(pRequest));

    // Max Overhead for the fix length fields which will be appended 
    // post-cache-hit;

    // Date & Time  : 11 + 9
    // UserName     : 2
    // ClientIp     : MAX_IPV4_STRING_LENGTH + 1 (16)
    // PStatus      : MAX_ULONG_STR + 1 (11)
    // PVersion     : UL_HTTP_VERSION_LENGTH + 1
    // BSent        : MAX_ULONGLONG_STR + 1 (21)
    // TTaken       : MAX_ULONGLONG_STR + 1
    // BReceived    : MAX_ULONGLONG_STR + 1
    // \r\n\0       : 3
    // TOTAL        : 124

    NewLength += 128;

    // And now add the variable length fields

    if ((Flags & MD_EXTLOG_USER_AGENT) && 
         pRequest->HeaderValid[HttpHeaderUserAgent])
    {
        ASSERT( pRequest->Headers[HttpHeaderUserAgent].HeaderLength ==
           strlen((const CHAR *)pRequest->Headers[HttpHeaderUserAgent].pHeader));
    
        NewLength += 2 + pRequest->Headers[HttpHeaderUserAgent].HeaderLength;
    }

    if ((Flags & MD_EXTLOG_COOKIE) && 
         pRequest->HeaderValid[HttpHeaderCookie])
    {
        ASSERT( pRequest->Headers[HttpHeaderCookie].HeaderLength ==
           strlen((const CHAR *)pRequest->Headers[HttpHeaderCookie].pHeader));
    
        NewLength += 2 + pRequest->Headers[HttpHeaderCookie].HeaderLength;
    }

    if ((Flags & MD_EXTLOG_REFERER) && 
         pRequest->HeaderValid[HttpHeaderReferer])
    {
        ASSERT( pRequest->Headers[HttpHeaderReferer].HeaderLength ==
           strlen((const CHAR *)pRequest->Headers[HttpHeaderReferer].pHeader));
    
        NewLength += 2 + pRequest->Headers[HttpHeaderReferer].HeaderLength;
    }

    if ((Flags & MD_EXTLOG_HOST) && 
         pRequest->HeaderValid[HttpHeaderHost])
    {
        ASSERT( pRequest->Headers[HttpHeaderHost].HeaderLength ==
           strlen((const CHAR *)pRequest->Headers[HttpHeaderHost].pHeader));
    
        NewLength += 2 + pRequest->Headers[HttpHeaderHost].HeaderLength;
    }

    return NewLength;
    
}

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _ULLOGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultcip.h ===
/*++

   Copyright (c) 2000-2001 Microsoft Corporation

   Module  Name :
       Ultcip.h

   Abstract:
        Private definitions comes here

   Author:
       Ali Ediz Turkoglu      (aliTu)     28-Jul-2000

   Project:
       Internet Information Server 6.0 - HTTP.SYS

   Revision History:

        -
--*/

#ifndef __ULTCIP_H__
#define __ULTCIP_H__


#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char BYTE;
typedef unsigned char *PBYTE;

#define OffsetToPtr(Base, Offset)     ((PUCHAR) ((PUCHAR)Base + Offset))

#define IPPROTO_TCP     (6)

//
// Set and Get macros for the QoS FlowSpec for the flows.
// Nt QoS team recommends following FlowSpec for limiting the
// maximum bandwidth;
//
//    ServiceType    = Best Effort
//    TokenRate      = Throttling rate
//    PeakRate       = Throttling Rate
//    MinPolicedSize = 40
//    MaxSduSize     = MTU size obtained from the IP address table
//    BucketSize     = TokenRate (bucket to hold upto 1 sec worth of data)
//

#define UL_SET_FLOWSPEC(Flow,BW,MTU)    do {                                            \
                                                                                        \
    (Flow).SendingFlowspec.ServiceType       = SERVICETYPE_BESTEFFORT;                  \
    (Flow).SendingFlowspec.TokenRate         = (BW);        /* In Bytes/sec */           \
    (Flow).SendingFlowspec.PeakBandwidth     = (BW);        /* In Bytes/sec */           \
    (Flow).SendingFlowspec.MinimumPolicedSize= 40;          /* In Bytes. perhaps 128*/   \
    (Flow).SendingFlowspec.MaxSduSize        = (MTU);       /* In Bytes */               \
    (Flow).SendingFlowspec.TokenBucketSize   = (BW);        /* In Bytes */               \
    (Flow).SendingFlowspec.Latency           = 0;           /* In microseconds */        \
    (Flow).SendingFlowspec.DelayVariation    = 0;           /* In microseconds */        \
                                                                                        \
    } while(FALSE)

#define UL_GET_BW_FRM_FLOWSPEC(Flow)                                                    \
    ((HTTP_BANDWIDTH_LIMIT) (Flow.SendingFlowspec.TokenRate))

#define UL_DEFAULT_WMI_QUERY_BUFFER_SIZE     (2*1024);

//
// To see if GBWT is enabled
//

#define UL_ENABLE_GLOBAL_THROTTLING()                       \
    InterlockedExchange(&g_GlobalThrottling, 1)

#define UL_DISABLE_GLOBAL_THROTTLING()                      \
    InterlockedExchange(&g_GlobalThrottling, 0)

#define UL_IS_GLOBAL_THROTTLING_ENABLED()                   \
    (g_GlobalThrottling != 0)

//
// For Interface Change Notifications
//

typedef
VOID
(*PUL_TC_NOTIF_HANDLER)(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );

//
// Macro to compare QoS GUIDs
//

#define UL_COMPARE_QOS_NOTIFICATION(rguid1, rguid2)  \
    (RtlCompareMemory((PVOID)rguid1,(PVOID)rguid2,sizeof(GUID)) == sizeof(GUID))

//
// Private function prototypes
//

NTSTATUS
UlpTcInitializeGpc(
    VOID
    );
NTSTATUS
UlpTcRegisterGpcClient(
    IN  ULONG   CfInfoType
    );
NTSTATUS
UlpTcDeRegisterGpcClient(
    VOID
    );
NTSTATUS
UlpTcInitializeTcpDevice(
    VOID
    );

NTSTATUS
UlpTcUpdateInterfaceMTU(
    VOID
    );

PUL_TCI_INTERFACE
UlpTcAllocateInterface(
    IN ULONG    DescSize,
    IN PADDRESS_LIST_DESCRIPTOR Desc,
    IN ULONG    NameLength,
    IN PUCHAR   Name,
    IN ULONG    InstanceIDLength,
    IN PUCHAR   InstanceID
    );

BOOLEAN
UlpTcGetIpAddr(
    IN  PADDRESS_LIST_DESCRIPTOR pAddressListDesc,
    OUT PULONG                   pIn_addr,
    OUT PULONG                   pSpecificLinkCtx
    );
NTSTATUS
UlpTcGetInterfaceIndex(
    IN  PUL_TCI_INTERFACE  pIntfc
    );
NTSTATUS
UlpTcGetFriendlyNames(
    VOID
    );

NTSTATUS
UlpTcReleaseAll(
    VOID
    );
NTSTATUS
UlpTcCloseInterface(
    PUL_TCI_INTERFACE  pInterface
    );
NTSTATUS
UlpTcCloseAllInterfaces(
    VOID
    );

NTSTATUS
UlpTcWalkWnode(
   IN PWNODE_HEADER pWnodeHdr,
   IN PUL_TC_NOTIF_HANDLER pNotifHandler
   );

VOID
UlpTcHandleIfcUp(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );
VOID
UlpTcHandleIfcDown(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );
VOID
UlpTcHandleIfcChange(
    IN PWSTR Name,
    IN ULONG NameSize,
    IN PTC_INDICATION_BUFFER pTcBuffer,
    IN ULONG BufferSize
    );

NTSTATUS
UlpTcRegisterForCallbacks(
    VOID
    );

NTSTATUS
UlpTcDeleteFlow(
    IN PUL_TCI_FLOW        pFlow
    );
NTSTATUS
UlpTcDeleteGpcFlow(
    HANDLE  FlowHandle
    );

PUL_TCI_FLOW
UlpTcAllocateFlow(
    IN HTTP_BANDWIDTH_LIMIT MaxBandwidth,
    IN ULONG                MtuSize
    );

NTSTATUS
UlpModifyFlow(
    IN  PUL_TCI_INTERFACE   pInterface,
    IN  PUL_TCI_FLOW        pFlow
    );
NTSTATUS
UlpAddFlow(
    IN  PUL_TCI_INTERFACE  pInterface,
    IN  PUL_TCI_FLOW       pGenericFlow,
    OUT PHANDLE            pHandle
    );

NTSTATUS
UlpTcAddFilter(
    IN   PUL_TCI_FLOW       pFlow,
    IN   PTC_GEN_FILTER     pGenericFilter,
    OUT  PUL_TCI_FILTER     *ppFilter
    );

NTSTATUS
UlpTcDeleteFilter(
    IN PUL_TCI_FLOW     pFlow,
    IN PUL_TCI_FILTER   pFilter
    );
NTSTATUS
UlpTcDeleteGpcFilter(
    IN  HANDLE          FilterHandle
    );

VOID
UlpInsertFilterEntry(
    IN      PUL_TCI_FILTER      pEntry,
    IN OUT  PUL_TCI_FLOW        pFlow
    );

VOID
UlpRemoveFilterEntry(
    IN      PUL_TCI_FILTER  pEntry,
    IN OUT  PUL_TCI_FLOW    pFlow
    );

PUL_TCI_FLOW
UlpFindFlow(
    IN PUL_CONFIG_GROUP_OBJECT pCgroup,
    IN ULONG   IpAddress
    );

PUL_TCI_INTERFACE
UlpFindInterface(
    IN ULONG  IpAddr
    );

NTSTATUS
UlpTcDeviceControl(
    IN  HANDLE                          FileHandle,
    IN  HANDLE                          EventHandle,
    IN  PIO_APC_ROUTINE                 ApcRoutine,
    IN  PVOID                           ApcContext,
    OUT PIO_STATUS_BLOCK                pIoStatBlock,
    IN  ULONG                           Ioctl,
    IN  PVOID                           InBuffer,
    IN  ULONG                           InBufferSize,
    IN  PVOID                           OutBuffer,
    IN  ULONG                           OutBufferSize
    );

VOID
UlDumpTCInterface(
        PUL_TCI_INTERFACE pTcIfc
        );
VOID
UlDumpTCFlow(
        PUL_TCI_FLOW pFlow
        );
VOID
UlDumpTCFilter(
        PUL_TCI_FILTER pFilter
        );

// Some helper dumpers

#ifdef DBG

#define UL_DUMP_TC_INTERFACE( pTcIfc )          \
    UlDumpTCInterface(                          \
        (pTcIfc)                                \
        )
#define UL_DUMP_TC_FLOW( pFlow )                \
    UlDumpTCFlow(                               \
        (pFlow)                                 \
        )
#define UL_DUMP_TC_FILTER( pFilter )            \
    UlDumpTCFilter(                             \
        (pFilter)                               \
        )

#else  // DBG

#define UL_DUMP_TC_INTERFACE( pTcIfc )
#define UL_DUMP_TC_FLOW( pFlow )
#define UL_DUMP_TC_FILTER( pFilter )

#endif // DBG


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __ULTCIP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultci.h ===
/*++

   Copyright (c) 2000-2001 Microsoft Corporation

   Module  Name :
       Ultci.h

   Abstract:
       This module implements a wrapper for QoS TC ( Traffic Control )
       Interface since the Kernel level API don't exist at this time.

       Any HTTP module might use this interface to make QoS calls.

   Author:
       Ali Ediz Turkoglu      (aliTu)     28-Jul-2000

   Project:
       Internet Information Server 6.0 - HTTP.SYS

   Revision History:

        -
--*/

#ifndef __ULTCI_H__
#define __ULTCI_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// UL does not use GPC_CF_CLASS_MAP client, all of the interfaces
// assumed to be using GPC_CF_QOS client type. And it's registered
// for all interfaces.
//

// #define MAX_STRING_LENGTH    (256) from traffic.h

//
// The interface objects get allocated during initialization.
// They hold the necessary information to create other
// QoS structures like flow & filter
//

typedef struct _UL_TCI_INTERFACE
{
    ULONG               Signature;                  // UL_TC_INTERFACE_POOL_TAG

    LIST_ENTRY          Linkage;                    // Linkage for the list of interfaces

    BOOLEAN             IsQoSEnabled;               // To see if QoS enabled or not for this interface

    ULONG               IpAddr;                     // Interface IP address - although exist inside
                                                    // the addrList, copied here for fast lookup

    ULONG               IfIndex;                    // Interface Index from TCPIP
    ULONG               SpecificLinkCtx;

    ULONG               MTUSize;                    // Need to get this from TCPIP

    USHORT              NameLength;                 // Friendly name of the interface
    WCHAR               Name[MAX_STRING_LENGTH];
    USHORT              InstanceIDLength;           // ID from our WMI provider the beloved PSched
    WCHAR               InstanceID[MAX_STRING_LENGTH];

    PUL_TCI_FLOW        pGlobalFlow;                // The flow for the global bandwidth throttling

    LIST_ENTRY          FlowList;                   // List of site flows on this interface
    ULONG               FlowListSize;

    ULONG               AddrListBytesCount;         // Address list acquired from tc with Wmi call
    PADDRESS_LIST_DESCRIPTOR    pAddressListDesc;   // Points just after us

} UL_TCI_INTERFACE, *PUL_TCI_INTERFACE;

#define IS_VALID_TCI_INTERFACE( entry )     \
    ( (entry != NULL) && ((entry)->Signature == UL_TCI_INTERFACE_POOL_TAG) )


//
// The structure to hold the all of the flow related info.
// Each site may have one flow on each interface plus one
// extra global flow on each interface.
//

typedef struct _UL_TCI_FLOW
{
    ULONG               Signature;                  // UL_TC_FLOW_POOL_TAG

    HANDLE              FlowHandle;                 // Flow handle from TC

    LIST_ENTRY          Linkage;                    // Links us to flow list of "the interface"
                                                    // we have installed on

    PUL_TCI_INTERFACE   pInterface;                 // Back ptr to interface struc. Necessary to gather
                                                    // some information occasionally

    LIST_ENTRY          Siblings;                   // Links us to flow list of "the cgroup"
                                                    // In other words all the flows of the site. This
                                                    // is to prevent the side lookup.

    PUL_CONFIG_GROUP_OBJECT pConfigGroup;           // The refcounted cgroup back pointer for cleanup

    TC_GEN_FLOW         GenFlow;                    // The details of the flowspec is stored in here

    UL_SPIN_LOCK        FilterListSpinLock;         // To LOCK the filterlist & its counter
    LIST_ENTRY          FilterList;                 // The list of filters on this flow
    ULONGLONG           FilterListSize;             // The number filters installed

} UL_TCI_FLOW, *PUL_TCI_FLOW;

#define IS_VALID_TCI_FLOW( entry )      \
    ( (entry != NULL) && ((entry)->Signature == UL_TCI_FLOW_POOL_TAG) )


//
// The structure to hold the filter information.
// Each connection can only have one filter at a time.
//

typedef struct _UL_TCI_FILTER
{
    ULONG               Signature;                  // UL_TC_FILTER_POOL_TAG

    HANDLE              FilterHandle;               // GPC handle

    PUL_HTTP_CONNECTION pHttpConnection;            // For proper cleanup and
                                                    // to avoid the race conditions

    LIST_ENTRY          Linkage;                    // Next filter on the flow

} UL_TCI_FILTER, *PUL_TCI_FILTER;

#define IS_VALID_TCI_FILTER( entry )    \
    ( (entry != NULL) && ((entry)->Signature == UL_TCI_FILTER_POOL_TAG) )

//
// To identify the local_loopbacks. This is a translation of
// 127.0.0.1.
//

#define LOOPBACK_ADDR       (0x0100007f)

//
// The functionality we expose
//

/* Generic */

BOOLEAN
UlTcPSchedInstalled(
    VOID
    );

/* Filters */

NTSTATUS
UlTcAddFilter(
    IN  PUL_HTTP_CONNECTION     pHttpConnection,
    IN  PUL_CONFIG_GROUP_OBJECT pCgroup
    );

NTSTATUS
UlTcDeleteFilter(
    IN  PUL_HTTP_CONNECTION     pHttpConnection
    );

/* Global Flows */

__inline BOOLEAN
UlTcGlobalThrottlingEnabled(
    VOID
    );

NTSTATUS
UlTcAddGlobalFlows(
    IN HTTP_BANDWIDTH_LIMIT     MaxBandwidth
    );

NTSTATUS
UlTcModifyGlobalFlows(
    IN HTTP_BANDWIDTH_LIMIT     NewBandwidth
    );

NTSTATUS
UlTcRemoveGlobalFlows(
    VOID
    );

/* Site Flows */

NTSTATUS
UlTcAddFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup,
    IN HTTP_BANDWIDTH_LIMIT     MaxBandwidth
    );

NTSTATUS
UlTcModifyFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup,
    IN HTTP_BANDWIDTH_LIMIT     NewBandwidth
    );

NTSTATUS
UlTcRemoveFlowsForSite(
    IN PUL_CONFIG_GROUP_OBJECT  pConfigGroup
    );

/* Init & Terminate */

NTSTATUS
UlTcInitialize(
    VOID
    );

VOID
UlTcTerminate(
    VOID
    );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif // __ULTCI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\connid.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    connid.c

Abstract:

    This module implements the UL_HTTP_CONNECTION_ID table. The ID table is
    implemented as a two-level array.

    The first level is an array of pointers to the second-level arrays.
    This first-level array is growable, but this should happen very
    infrequently.

    The second level is an array of CONN_ID_TABLE_ENTRY structures.
    These structures contain a cyclic (to detect stale IDs) and a
    pointer to an HTTP_CONNECTION structure.

    The data structures may be diagramed as follows:

        g_FirstLevelTable
               |
               |   +-----+
               |   |     |      +-----+-----+-----+-----+-----+-----+
               |   |     |      | CONN_ID_  | CONN_ID_  | CONN_ID_  |
               +-->|  *-------->| TABLE_    | TABLE_    | TABLE_    |
                   |     |      | ENTRY     | ENTRY     | ENTRY     |
                   |     |      +-----+-----+-----+-----+-----+-----+
                   +-----+
                   |     |      +-----+-----+-----+-----+-----+-----+
                   |     |      | CONN_ID_  | CONN_ID_  | CONN_ID_  |
                   |  *-------->| TABLE_    | TABLE_    | TABLE_    |
                   |     |      | ENTRY     | ENTRY     | ENTRY     |
                   |     |      +-----+-----+-----+-----+-----+-----+
                   +-----+
                   |     .
                   |     .
                   .     .
                   .     |
                   .     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+

    Note that all free CONN_ID_TABLE_ENTRY structures are kept on a
    single (global) free list. Whenever a new ID needs to be allocated,
    the free list is consulted. If it's not empty, an item is popped
    from the list and used. If the list is empty, then new space
    must be allocated. Best case, this will involve the allocation
    of a new second-level array. Worst case, this will also involve
    a reallocation of the first-level array. Reallocation of the first-
    level array should be relatively rare.

    An UL_HTTP_CONNECTION_ID is opaque at user-mode. Internally, it consists
    of three fields:

        1) An index into the first-level array.
        2) An index into the second-level array referenced by the
           first-level index.
        3) A cyclic, used to detect stale IDs.

    See the CONN_ID_INTERNAL structure definition (below) for details.

    Note that most of the routines in this module assume they are called
    at DISPATCH_LEVEL.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define FIRST_LEVEL_TABLE_GROWTH    32  // entries
#define SECOND_LEVEL_TABLE_SIZE     256 // entries

#if 0   // use RW lock
#define DECLARE_LOCK(l)             UL_RW_LOCK l
#define INITIALIZE_LOCK(l)          UlInitializeRWLock( l )
#define ACQUIRE_READ_LOCK(l)        UlAcquireRWLockForRead( l )
#define ACQUIRE_WRITE_LOCK(l)       UlAcquireRWLockForWrite( l )
#define RELEASE_READ_LOCK(l)        UlReleaseRWLockFromRead( l )
#define RELEASE_WRITE_LOCK(l)       UlReleaseRWLockFromWrite( l )
#else   // use spin lock
#define DECLARE_LOCK(l)             UL_SPIN_LOCK l
#define INITIALIZE_LOCK(l)          UlInitializeSpinLock( l )
#define ACQUIRE_READ_LOCK(l)        UlAcquireSpinLockAtDpcLevel( l )
#define ACQUIRE_WRITE_LOCK(l)       UlAcquireSpinLockAtDpcLevel( l )
#define RELEASE_READ_LOCK(l)        UlReleaseSpinLockFromDpcLevel( l )
#define RELEASE_WRITE_LOCK(l)       UlReleaseSpinLockFromDpcLevel( l )
#endif

//
// Private types.
//

//
// Our cyclic type. Just a 32-bit value.
//

typedef ULONG CYCLIC;

//
// The internal structure of an UL_HTTP_CONNECTION_ID.
//
// N.B. This structure must be EXACTLY the same size as an
// UL_HTTP_CONNECTION_ID!
//

#define FIRST_INDEX_BIT_WIDTH   24
#define SECOND_INDEX_BIT_WIDTH  8

typedef union _CONN_ID_INTERNAL
{
    UL_HTTP_CONNECTION_ID OpaqueID;

    struct
    {
        CYCLIC Cyclic;
        ULONG FirstIndex:FIRST_INDEX_BIT_WIDTH;
        ULONG SecondIndex:SECOND_INDEX_BIT_WIDTH;
    };

} CONN_ID_INTERNAL, *PCONN_ID_INTERNAL;

C_ASSERT( sizeof(UL_HTTP_CONNECTION_ID) == sizeof(CONN_ID_INTERNAL) );
C_ASSERT( (FIRST_INDEX_BIT_WIDTH + SECOND_INDEX_BIT_WIDTH) ==
    (sizeof(CYCLIC) * 8) );

//
// A second-level table entry.
//
// Note that FreeListEntry and pHttpConnection are in an anonymous
// union to save space; an entry is either on the free list or in use,
// so only one of these fields will be used at a time.
//
// Also note that Cyclic is in a second anonymous union. It's overlayed
// with FirstLevelIndex (which is basically the second-level table's
// index in the first-level table) and EntryType (used to distinguish
// free entries from in-use entries). The GetNextCyclic() function (below)
// is careful to always return cyclics with EntryType set to
// ENTRY_TYPE_IN_USE.
//

typedef struct _CONN_ID_TABLE_ENTRY
{
    union
    {
        SINGLE_LIST_ENTRY FreeListEntry;
        PHTTP_CONNECTION pHttpConnection;
    };

    union
    {
        CYCLIC Cyclic;

        struct
        {
            ULONG FirstLevelIndex:FIRST_INDEX_BIT_WIDTH;
            ULONG EntryType:SECOND_INDEX_BIT_WIDTH;
        };
    };

} CONN_ID_TABLE_ENTRY, *PCONN_ID_TABLE_ENTRY;

#define ENTRY_TYPE_FREE     0xFF
#define ENTRY_TYPE_IN_USE   0x00


//
// Private prototypes.
//

PCONN_ID_TABLE_ENTRY
MapConnIdToTableEntry(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    );

NTSTATUS
ReallocConnIdTables(
    IN ULONG CapturedFirstTableSize,
    IN ULONG CapturedFirstTableInUse
    );


//
// Private globals.
//

DECLARE_LOCK( g_ConnIdTableLock );
SLIST_HEADER g_FreeConnIdSListHead;
KSPIN_LOCK g_FreeConnIdSListLock;
PCONN_ID_TABLE_ENTRY *g_FirstLevelTable;
ULONG g_FirstLevelTableSize;
ULONG g_FirstLevelTableInUse;
LONG g_ConnIdCyclic;


__inline
CYCLIC
GetNextCyclic(
    VOID
    )
{
    CONN_ID_TABLE_ENTRY entry;

    entry.Cyclic = (CYCLIC)InterlockedIncrement( &g_ConnIdCyclic );
    entry.EntryType = ENTRY_TYPE_IN_USE;

    return entry.Cyclic;

}   // GetNextCyclic


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, InitializeConnIdTable )
#pragma alloc_text( PAGE, TerminateConnIdTable )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlAllocateHttpConnectionID
NOT PAGEABLE -- UlFreeHttpConnectionID
NOT PAGEABLE -- UlGetHttpConnectionFromID
NOT PAGEABLE -- MapConnIdToTableEntry
NOT PAGEABLE -- ReallocConnIdTables
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the HTTP connection object package.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
InitializeConnIdTable(
    VOID
    )
{
    LARGE_INTEGER timeNow;

    INITIALIZE_LOCK( &g_ConnIdTableLock );
    KeInitializeSpinLock( &g_FreeConnIdSListLock );
    ExInitializeSListHead( &g_FreeConnIdSListHead );

    KeQuerySystemTime( &timeNow );
    g_ConnIdCyclic = (LONG)( timeNow.HighPart + timeNow.LowPart );

    g_FirstLevelTableInUse = 0;
    g_FirstLevelTableSize = FIRST_LEVEL_TABLE_GROWTH;

    //
    // Go ahead and allocate the first-level table now. This makes the
    // normal runtime path a little cleaner because it doesn't have to
    // deal with the "first time" case.
    //

    g_FirstLevelTable = UL_ALLOCATE_POOL(
                            NonPagedPool,
                            g_FirstLevelTableSize * sizeof(PCONN_ID_TABLE_ENTRY),
                            UL_CONN_ID_TABLE_POOL_TAG
                            );

    if (g_FirstLevelTable == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        g_FirstLevelTable,
        g_FirstLevelTableSize * sizeof(PCONN_ID_TABLE_ENTRY)
        );

    return STATUS_SUCCESS;

}   // InitializeConnIdTable


/***************************************************************************++

Routine Description:

    Performs global termination of the HTTP connection object package.

--***************************************************************************/
VOID
TerminateConnIdTable(
    VOID
    )
{
    ULONG i;

    if (g_FirstLevelTable != NULL)
    {
        //
        // Free the second-level tables.
        //

        for (i = 0 ; i < g_FirstLevelTableInUse ; i++)
        {
            if (g_FirstLevelTable[i] != NULL)
            {
                UL_FREE_POOL(
                    g_FirstLevelTable[i],
                    UL_CONN_ID_TABLE_POOL_TAG
                    );
            }

            g_FirstLevelTable[i] = NULL;
        }

        //
        // Free the first-level table.
        //

        UL_FREE_POOL(
            g_FirstLevelTable,
            UL_CONN_ID_TABLE_POOL_TAG
            );

        g_FirstLevelTable = NULL;
    }

    ExInitializeSListHead( &g_FreeConnIdSListHead );

    g_ConnIdCyclic = 0;
    g_FirstLevelTableSize = 0;
    g_FirstLevelTableInUse = 0;

}   // TerminateConnIdTable


/***************************************************************************++

Routine Description:

    Allocates a new connection ID for the specified connection.

Arguments:

    pHttpConnection - Supplies the HTTP_CONNECTION that is to receive the
        new connection ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAllocateHttpConnectionID(
    IN PHTTP_CONNECTION pHttpConnection
    )
{
    NTSTATUS status;
    CYCLIC cyclic;
    ULONG firstIndex;
    ULONG secondIndex;
    PSINGLE_LIST_ENTRY listEntry;
    CONN_ID_INTERNAL internal;
    PCONN_ID_TABLE_ENTRY tableEntry;
    ULONG capturedFirstTableSize;
    ULONG capturedFirstTableInUse;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a new cyclic while we're outside the lock.
    //

    cyclic = GetNextCyclic();

    //
    // Loop, trying to allocate an item from the table.
    //

    do
    {
        ACQUIRE_READ_LOCK( &g_ConnIdTableLock );

        listEntry = ExInterlockedPopEntrySList(
                        &g_FreeConnIdSListHead,
                        &g_FreeConnIdSListLock
                        );

        if (listEntry != NULL)
        {
            //
            // The free list isn't empty, so we can just use this
            // entry. We'll calculate the indices for this entry,
            // initialize the entry, then release the table lock.
            //

            tableEntry = CONTAINING_RECORD(
                             listEntry,
                             CONN_ID_TABLE_ENTRY,
                             FreeListEntry
                             );

            firstIndex = tableEntry->FirstLevelIndex;
            secondIndex = (ULONG)(tableEntry - g_FirstLevelTable[firstIndex]);

            tableEntry->pHttpConnection = pHttpConnection;
            tableEntry->Cyclic = cyclic;

            RELEASE_READ_LOCK( &g_ConnIdTableLock );

            //
            // Pack the cyclic & indices into the opaque ID and set
            // it in the connection.
            //

            internal.Cyclic = cyclic;
            internal.FirstIndex = firstIndex;
            internal.SecondIndex = secondIndex;

            pHttpConnection->ConnectionID = internal.OpaqueID;

            return STATUS_SUCCESS;
        }

        //
        // We only make it to this point if the free list is empty,
        // meaning we need to do some memory allocations before
        // we can continue. We'll put this off into a separate routine
        // to keep this one small (to avoid cache thrash). The realloc
        // routine returns STATUS_SUCCESS if it (or another thread)
        // managed to successfully reallocate the tables. Otherwise, it
        // returns a failure code.
        //

        capturedFirstTableSize = g_FirstLevelTableSize;
        capturedFirstTableInUse = g_FirstLevelTableInUse;
        RELEASE_READ_LOCK( &g_ConnIdTableLock );

        status = ReallocConnIdTables(
                        capturedFirstTableSize,
                        capturedFirstTableInUse
                        );

    } while( status == STATUS_SUCCESS );

    return status;

}   // UlAllocateHttpConnectionID


/***************************************************************************++

Routine Description:

    Frees the specified connection ID.

Arguments:

    ConnectionID - Supplies the connection ID to free.

Return Value:

    PHTTP_CONNECTION - Returns the HTTP_CONNECTION associated with the
        connection ID if successful, NULL otherwise.

--***************************************************************************/
PHTTP_CONNECTION
UlFreeHttpConnectionID(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    )
{
    PCONN_ID_TABLE_ENTRY tableEntry;
    PHTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Try to map the connection ID to a table entry.
    //

    tableEntry = MapConnIdToTableEntry( ConnectionID );

    if (tableEntry != NULL)
    {
        CONN_ID_INTERNAL internal;

        //
        // Got a match. Snag the connection pointer, free the table
        // entry, then unlock the table.
        //

        pHttpConnection = tableEntry->pHttpConnection;

        internal.OpaqueID = ConnectionID;
        tableEntry->FirstLevelIndex = internal.FirstIndex;
        tableEntry->EntryType = ENTRY_TYPE_FREE;

        ExInterlockedPushEntrySList(
            &g_FreeConnIdSListHead,
            &tableEntry->FreeListEntry,
            &g_FreeConnIdSListLock
            );

        RELEASE_READ_LOCK( &g_ConnIdTableLock );
        return pHttpConnection;
    }

    return NULL;

}   // UlFreeHttpConnectionID


/***************************************************************************++

Routine Description:

    Maps the specified connection ID to the corresponding PHTTP_CONNECTION.

Arguments:

    ConnectionID - Supplies the connection ID to map.

Return Value:

    PHTTP_CONNECTION - Returns the HTTP_CONNECTION associated with the
        connection ID if successful, NULL otherwise.

--***************************************************************************/
PHTTP_CONNECTION
UlGetHttpConnectionFromID(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    )
{
    PCONN_ID_TABLE_ENTRY tableEntry;
    PHTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Try to map the connection ID to a table entry.
    //

    tableEntry = MapConnIdToTableEntry( ConnectionID );

    if (tableEntry != NULL)
    {
        //
        // Got a match. Retrieve the connection pointer, then unlock
        // the table. Note that we cannot touch the table entry once
        // we unlock the table.
        //

        pHttpConnection = tableEntry->pHttpConnection;

        RELEASE_READ_LOCK( &g_ConnIdTableLock );
        return pHttpConnection;
    }

    return NULL;

}   // UlGetHttpConnectionFromID


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Maps the specified UL_HTTP_CONNECTION_ID to the corresponding
    PHTTP_CONNECTION pointer.

Arguments:

    ConnectionID - Supplies the connection ID to map.

Return Value:

    PCONN_ID_TABLE_ENTRY - Pointer to the table entry corresponding to the
        connection ID if successful, NULL otherwise.

    N.B. If this function is successful, it returns with the table lock
        held for read access!

--***************************************************************************/
PCONN_ID_TABLE_ENTRY
MapConnIdToTableEntry(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    )
{
    PCONN_ID_TABLE_ENTRY secondTable;
    PCONN_ID_TABLE_ENTRY tableEntry;
    CONN_ID_INTERNAL internal;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Unpack the ID.
    //

    internal.OpaqueID = ConnectionID;

    //
    // Lock the table.
    //

    ACQUIRE_READ_LOCK( &g_ConnIdTableLock );

    //
    // Validate the index.
    //

    if (internal.FirstIndex >= 0 &&
        internal.FirstIndex < g_FirstLevelTableInUse)
    {
        secondTable = g_FirstLevelTable[internal.FirstIndex];
        ASSERT( secondTable != NULL );
        ASSERT( internal.SecondIndex >= 0 );
        ASSERT( internal.SecondIndex <= SECOND_LEVEL_TABLE_SIZE );

        tableEntry = secondTable + internal.SecondIndex;

        //
        // The connection index is within legal range. Ensure it's
        // in use and the cyclic matches.
        //

        if (tableEntry->Cyclic == internal.Cyclic &&
            tableEntry->EntryType == ENTRY_TYPE_IN_USE)
        {
            return tableEntry;
        }
    }

    //
    // Invalid connection ID. Fail it.
    //

    RELEASE_READ_LOCK( &g_ConnIdTableLock );
    return NULL;

}   // MapConnIdToTableEntry


/***************************************************************************++

Routine Description:

    Allocates a new second-level table, and (optionally) reallocates the
    first-level table if necessary.

Arguments:

    CapturedFirstTableSize - The size of the first-level table as captured
        with the table lock held.

    CapturedFirstTableInUse - The number of entries currently used in the
        first-level table as captured with the table lock held.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
ReallocConnIdTables(
    IN ULONG CapturedFirstTableSize,
    IN ULONG CapturedFirstTableInUse
    )
{
    ULONG firstIndex;
    ULONG secondIndex;
    PCONN_ID_TABLE_ENTRY tableEntry;
    PCONN_ID_TABLE_ENTRY newSecondTable;
    PCONN_ID_TABLE_ENTRY *newFirstTable;
    ULONG newFirstTableSize;
    ULONG i;
    PLIST_ENTRY listEntry;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( ExQueryDepthSList( &g_FreeConnIdSListHead ) == 0 );

    //
    // Assume we won't actually allocate anything.
    //

    newFirstTable = NULL;
    newSecondTable = NULL;

    //
    // Allocate a new second-level table.
    //

    newSecondTable = UL_ALLOCATE_POOL(
                            NonPagedPool,
                            SECOND_LEVEL_TABLE_SIZE *
                                sizeof(CONN_ID_TABLE_ENTRY),
                            UL_CONN_ID_TABLE_POOL_TAG
                            );

    if (newSecondTable == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (CapturedFirstTableInUse == CapturedFirstTableSize)
    {
        //
        // We need a new first-level table.
        //

        newFirstTableSize =
            CapturedFirstTableSize + FIRST_LEVEL_TABLE_GROWTH;

        newFirstTable = UL_ALLOCATE_POOL(
                            NonPagedPool,
                            newFirstTableSize * sizeof(PCONN_ID_TABLE_ENTRY),
                            UL_CONN_ID_TABLE_POOL_TAG
                            );

        if (newFirstTable == NULL)
        {
            UL_FREE_POOL( newSecondTable, UL_CONN_ID_TABLE_POOL_TAG );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(
            newFirstTable + CapturedFirstTableSize,
            FIRST_LEVEL_TABLE_GROWTH * sizeof(PCONN_ID_TABLE_ENTRY)
            );
    }

    //
    // OK, we've got the new table(s). Acquire the lock for write access
    // and see if another thread has already done the work for us.
    //

    ACQUIRE_WRITE_LOCK( &g_ConnIdTableLock );

    if (ExQueryDepthSList( &g_FreeConnIdSListHead ) == 0)
    {
        //
        // The free list is still empty. This could potentially
        // mean that another thread has already performed the
        // realloc and all of *those* new entries are now in use.
        // We can detect this by comparing the current table size
        // with the size we captured previously with the lock held.
        //

        if (CapturedFirstTableSize != g_FirstLevelTableSize)
        {
            goto cleanup;
        }

        //
        // OK, we're the one performing the realloc.
        //

        if (newFirstTable != NULL)
        {
            PCONN_ID_TABLE_ENTRY *tmp;

            //
            // Copy the old table into the new table.
            //

            RtlCopyMemory(
                newFirstTable,
                g_FirstLevelTable,
                g_FirstLevelTableSize * sizeof(PCONN_ID_TABLE_ENTRY)
                );

            //
            // Swap the new & old table pointers so we can keep the
            // original pointer & free it later (after we've released
            // the table lock).
            //

            tmp = g_FirstLevelTable;
            g_FirstLevelTable = newFirstTable;
            newFirstTable = tmp;

            g_FirstLevelTableSize = newFirstTableSize;
        }

        //
        // Attach the second-level table to the first-level table,
        //

        ASSERT( g_FirstLevelTable[g_FirstLevelTableInUse] == NULL );
        g_FirstLevelTable[g_FirstLevelTableInUse++] = newSecondTable;
        ASSERT( g_FirstLevelTableInUse <= g_FirstLevelTableSize );

        //
        // Link it onto the global free list.
        //

        for (i = 0 ; i < SECOND_LEVEL_TABLE_SIZE ; i++)
        {
            newSecondTable[i].FirstLevelIndex = CapturedFirstTableInUse;
            newSecondTable[i].EntryType = ENTRY_TYPE_FREE;

            ExInterlockedPushEntrySList(
                &g_FreeConnIdSListHead,
                &newSecondTable[i].FreeListEntry,
                &g_FreeConnIdSListLock
                );
        }

        //
        // Remember that we don't need to free the second-level table.
        //

        newSecondTable = NULL;
    }
    else
    {
        //
        // The free list was not empty after we reacquired the lock,
        // indicating that another thread has already performed the
        // realloc. This is cool; we'll just free the pool we allocated
        // and return.
        //
    }

    //
    // Cleanup.
    //

cleanup:

    RELEASE_WRITE_LOCK( &g_ConnIdTableLock );

    if (newSecondTable != NULL)
    {
        UL_FREE_POOL( newSecondTable, UL_CONN_ID_TABLE_POOL_TAG );
    }

    if (newFirstTable != NULL)
    {
        UL_FREE_POOL( newFirstTable, UL_CONN_ID_TABLE_POOL_TAG );
    }

    return STATUS_SUCCESS;

}   // ReallocConnIdTables
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultdi.cxx ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ultdi.cxx

Abstract:

    This module implements the TDI/MUX/SSL component.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#include "precomp.h"

#include "repltrace.h"

//
// Private globals.
//

//
// Global lists of all active and all waiting-to-be-deleted endpoints.
//

LIST_ENTRY g_TdiEndpointListHead;
LIST_ENTRY g_TdiDeletedEndpointListHead;    // for debugging
ULONG      g_TdiEndpointCount;   // #elements in active endpoint list

//
// Global lists of all connections, active or idle
//

LIST_ENTRY g_TdiConnectionListHead;
ULONG      g_TdiConnectionCount;   // #elements in connection list

//
// Spinlock protecting the above lists.
//

UL_SPIN_LOCK g_TdiSpinLock;

//
// Global initialization flag.
//

BOOLEAN g_TdiInitialized;

//
// Used to wait for endpoints and connections to close on shutdown
//

BOOLEAN g_TdiWaitingForEndpointDrain;
KEVENT  g_TdiEndpointDrainEvent;
KEVENT  g_TdiConnectionDrainEvent;


//
// TCP Send routine if Fast Send is possible.
//

PUL_TCPSEND_DISPATCH g_TcpFastSend = NULL;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeTdi )
#pragma alloc_text( INIT, UlpQueryTcpFastSend )
#pragma alloc_text( PAGE, UlTerminateTdi )
#pragma alloc_text( PAGE, UlCloseListeningEndpoint )
#pragma alloc_text( PAGE, UlpEndpointCleanupWorker )
#pragma alloc_text( PAGE, UlpConnectionCleanupWorker )
#pragma alloc_text( PAGE, UlpAssociateConnection )
#pragma alloc_text( PAGE, UlpDisassociateConnection )
#pragma alloc_text( PAGE, UlpReplenishEndpoint )
#pragma alloc_text( PAGE, UlpReplenishEndpointWorker )
#pragma alloc_text( PAGE, UlpInitializeConnection )
#pragma alloc_text( PAGE, UlpUrlToAddress )
#pragma alloc_text( PAGE, UlpSetNagling )
#endif  // ALLOC_PRAGMA

#if 0
NOT PAGEABLE -- UlWaitForEndpointDrain
NOT PAGEABLE -- UlCreateListeningEndpoint
NOT PAGEABLE -- UlCloseConnection
NOT PAGEABLE -- UlReceiveData
NOT PAGEABLE -- UlSendData
NOT PAGEABLE -- UlAddSiteToEndpointList
NOT PAGEABLE -- UlRemoveSiteFromEndpointList
NOT PAGEABLE -- UlpDestroyEndpoint
NOT PAGEABLE -- UlpDestroyConnection
NOT PAGEABLE -- UlpDequeueIdleConnection
NOT PAGEABLE -- UlpEnqueueIdleConnection
NOT PAGEABLE -- UlpEnqueueActiveConnection
NOT PAGEABLE -- UlpConnectHandler
NOT PAGEABLE -- UlpDisconnectHandler
NOT PAGEABLE -- UlpCloseRawConnection
NOT PAGEABLE -- UlpSendRawData
NOT PAGEABLE -- UlpReceiveRawData
NOT PAGEABLE -- UlpReceiveHandler
NOT PAGEABLE -- UlpDummyReceiveHandler
NOT PAGEABLE -- UlpReceiveExpeditedHandler
NOT PAGEABLE -- UlpRestartAccept
NOT PAGEABLE -- UlpRestartSendData
NOT PAGEABLE -- UlpReferenceEndpoint
NOT PAGEABLE -- UlpDereferenceEndpoint
NOT PAGEABLE -- UlReferenceConnection
NOT PAGEABLE -- UlDereferenceConnection
NOT PAGEABLE -- UlpCleanupConnectionId
NOT PAGEABLE -- UlpDecrementIdleConnections
NOT PAGEABLE -- UlpIncrementIdleConnections
NOT PAGEABLE -- UlpClearReplenishScheduledFlag
NOT PAGEABLE -- UlpCreateConnection
NOT PAGEABLE -- UlpSetConnectionFlag
NOT PAGEABLE -- UlpBeginDisconnect
NOT PAGEABLE -- UlpRestartDisconnect
NOT PAGEABLE -- UlpBeginAbort
NOT PAGEABLE -- UlpRestartAbort
NOT PAGEABLE -- UlpRemoveFinalReference
NOT PAGEABLE -- UlpRestartReceive
NOT PAGEABLE -- UlpRestartClientReceive
NOT PAGEABLE -- UlpDisconnectAllActiveConnections
NOT PAGEABLE -- UlpUnbindConnectionFromEndpoint
NOT PAGEABLE -- UlpSynchronousIoComplete
NOT PAGEABLE -- UlpFindEndpointForAddress
NOT PAGEABLE -- UlpRestartQueryAddress
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeTdi(
    VOID
    )
{
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_TdiInitialized );

    //
    // Initialize global data.
    //

    InitializeListHead( &g_TdiEndpointListHead );
    InitializeListHead( &g_TdiDeletedEndpointListHead );
    InitializeListHead( &g_TdiConnectionListHead );
    UlInitializeSpinLock( &g_TdiSpinLock, "g_TdiSpinLock" );

    g_TdiEndpointCount = 0;
    g_TdiConnectionCount = 0;

    KeInitializeEvent(
        &g_TdiEndpointDrainEvent,
        NotificationEvent,
        FALSE
        );

    KeInitializeEvent(
        &g_TdiConnectionDrainEvent,
        NotificationEvent,
        FALSE
        );

    status = UlpQueryTcpFastSend();

    if (NT_SUCCESS(status))
    {
        g_TdiInitialized = TRUE;
    }

    return status;

}   // UlInitializeTdi


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UlTerminateTdi(
    VOID
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_TdiInitialized)
    {

        ASSERT( IsListEmpty( &g_TdiEndpointListHead )) ;
        ASSERT( IsListEmpty( &g_TdiDeletedEndpointListHead )) ;
        ASSERT( IsListEmpty( &g_TdiConnectionListHead )) ;
        ASSERT( g_TdiEndpointCount == 0 );
        ASSERT( g_TdiConnectionCount == 0 );
        g_TdiInitialized = FALSE;
    }

}   // UlTerminateTdi


/***************************************************************************++

Routine Description:

    This function blocks until the endpoint list is empty. It also prevents
    new endpoints from being created.

Arguments:

    None.

--***************************************************************************/
VOID
UlWaitForEndpointDrain(
    VOID
    )
{
    KIRQL oldIrql;
    BOOLEAN Wait = FALSE;

    if (g_TdiInitialized)
    {
        UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );

        if (!g_TdiWaitingForEndpointDrain)
        {
            g_TdiWaitingForEndpointDrain = TRUE;
        }

        if (g_TdiEndpointCount > 0  ||  g_TdiConnectionCount > 0)
        {
            Wait = TRUE;
        }

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

        if (Wait)
        {
            PVOID Events[2] = {
                &g_TdiEndpointDrainEvent,
                &g_TdiConnectionDrainEvent
            };

            KeWaitForMultipleObjects(
                2,
                Events,
                WaitAll,
                UserRequest,
                KernelMode,
                FALSE,
                NULL,
                NULL
                );
        }
    }
} // UlWaitForEndpointDrain


/***************************************************************************++

Routine Description:

    Creates a new listening endpoint bound to the specified address.

Arguments:

    pLocalAddress - Supplies the local address to bind the endpoint to.

    LocalAddressLength - Supplies the length of pLocalAddress.

    InitialBacklog - Supplies the initial number of idle connections
        to add to the endpoint.

    pConnectionRequestHandler - Supplies a pointer to an indication
        handler to invoke when incoming connections arrive.

    pConnectionCompleteHandler - Supplies a pointer to an indication
        handler to invoke when either a) the incoming connection is
        fully accepted, or b) the incoming connection could not be
        accepted due to a fatal error.

    pConnectionDisconnectHandler - Supplies a pointer to an indication
        handler to invoke when connections are disconnected by the
        remote (client) side.

    pConnectionDestroyedHandler - Supplies a pointer to an indication
        handle to invoke after a connection has been fully destroyed.
        This is typically the TDI client's opportunity to cleanup
        any allocated resources.

    pDataReceiveHandler - Supplies a pointer to an indication handler to
        invoke when incoming data arrives.

    pListeningContext - Supplies an uninterpreted context value to
        associate with the new listening endpoint.

    ppListeningEndpoint - Receives a pointer to the new listening
        endpoint if successful.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCreateListeningEndpoint(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    IN BOOLEAN Secure,
    IN ULONG InitialBacklog,
    IN PUL_CONNECTION_REQUEST pConnectionRequestHandler,
    IN PUL_CONNECTION_COMPLETE pConnectionCompleteHandler,
    IN PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler,
    IN PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler,
    IN PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler,
    IN PUL_DATA_RECEIVE pDataReceiveHandler,
    IN PVOID pListeningContext,
    OUT PUL_ENDPOINT *ppListeningEndpoint
    )
{
    NTSTATUS status;
    PUL_ENDPOINT pEndpoint;
    UNICODE_STRING deviceName;
    LONG i;

    //
    // Sanity check.
    //

    ASSERT( LocalAddressLength == sizeof(TA_IP_ADDRESS) );
    ASSERT( InitialBacklog < 0x7FFFFFFF );

    //
    // Setup locals so we know how to cleanup on a fatal exit.
    //

    pEndpoint = NULL;

    //
    // Allocate enough pool for the endpoint structure and the
    // local address.
    //

    pEndpoint = UL_ALLOCATE_STRUCT_WITH_SPACE(
                    NonPagedPool,
                    UL_ENDPOINT,
                    LocalAddressLength,
                    UL_ENDPOINT_POOL_TAG
                    );

    if (pEndpoint == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    InterlockedIncrement((PLONG) &g_TdiEndpointCount);

    //
    // Initialize the easy parts.
    //

    pEndpoint->Signature = UL_ENDPOINT_SIGNATURE;
    pEndpoint->ReferenceCount = 0;
    pEndpoint->UsageCount = 1;

#if ENABLE_OWNER_REF_TRACE
    pEndpoint->pEndpointRefOwner = NULL;
    CREATE_OWNER_REF_TRACE_LOG( pEndpoint->pOwnerRefTraceLog, 8000, 0 );
#endif // ENABLE_OWNER_REF_TRACE

    REFERENCE_ENDPOINT_SELF(pEndpoint, REF_ACTION_INIT);

    ExInitializeSListHead( &pEndpoint->IdleConnectionSListHead );

    for (i = 0; i < DEFAULT_MAX_CONNECTION_ACTIVE_LISTS; i++)
    {
        InitializeListHead( &pEndpoint->ActiveConnectionListHead[i] );
        UlInitializeSpinLock(
            &pEndpoint->ActiveConnectionSpinLock[i],
            "ActiveConnectionSpinLock"
            );
    }

    pEndpoint->ActiveConnectionIndex = 0;

    UlInitializeSpinLock( &pEndpoint->IdleConnectionSpinLock, "IdleConnectionSpinLock" );
    UlInitializeSpinLock( &pEndpoint->EndpointSpinLock, "EndpointSpinLock" );

    pEndpoint->AddressObject.Handle = NULL;
    pEndpoint->AddressObject.pFileObject = NULL;
    pEndpoint->AddressObject.pDeviceObject = NULL;

    pEndpoint->pConnectionRequestHandler = pConnectionRequestHandler;
    pEndpoint->pConnectionCompleteHandler = pConnectionCompleteHandler;
    pEndpoint->pConnectionDisconnectHandler = pConnectionDisconnectHandler;
    pEndpoint->pConnectionDisconnectCompleteHandler = pConnectionDisconnectCompleteHandler;
    pEndpoint->pConnectionDestroyedHandler = pConnectionDestroyedHandler;
    pEndpoint->pDataReceiveHandler = pDataReceiveHandler;
    pEndpoint->pListeningContext = pListeningContext;

    pEndpoint->pLocalAddress = (PTRANSPORT_ADDRESS)(pEndpoint + 1);
    pEndpoint->LocalAddressLength = LocalAddressLength;

    RtlCopyMemory(
        pEndpoint->pLocalAddress,
        pLocalAddress,
        LocalAddressLength
        );

    pEndpoint->Secure = Secure;
    pEndpoint->Deleted = FALSE;
    pEndpoint->GlobalEndpointListEntry.Flink = NULL;

    pEndpoint->EndpointSynch.ReplenishScheduled = TRUE;
    pEndpoint->EndpointSynch.IdleConnections = 0;

    RtlZeroMemory(
        &pEndpoint->CleanupIrpContext,
        sizeof(UL_IRP_CONTEXT)
        );

    pEndpoint->CleanupIrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;


    //
    // Open the TDI address object for this endpoint.
    //

    status = UxOpenTdiAddressObject(
                    pLocalAddress,
                    LocalAddressLength,
                    &pEndpoint->AddressObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Set the TDI event handlers.
    //

    status = UxSetEventHandler(
                    &pEndpoint->AddressObject,
                    TDI_EVENT_CONNECT,
                    &UlpConnectHandler,
                    pEndpoint
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UxSetEventHandler(
                    &pEndpoint->AddressObject,
                    TDI_EVENT_DISCONNECT,
                    &UlpDisconnectHandler,
                    pEndpoint
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UxSetEventHandler(
                    &pEndpoint->AddressObject,
                    TDI_EVENT_RECEIVE,
                    &UlpReceiveHandler,
                    pEndpoint
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    status = UxSetEventHandler(
                    &pEndpoint->AddressObject,
                    TDI_EVENT_RECEIVE_EXPEDITED,
                    &UlpReceiveExpeditedHandler,
                    pEndpoint
                    );

    //
    // Put the endpoint onto the global list.
    //

    ExInterlockedInsertTailList(
        &g_TdiEndpointListHead,
        &pEndpoint->GlobalEndpointListEntry,
        KSPIN_LOCK_FROM_UL_SPIN_LOCK(&g_TdiSpinLock)
        );

    //
    // Replenish the idle connection pool.
    //

    UlpReplenishEndpoint( pEndpoint );

    //
    // Success!
    //

    UlTrace(TDI, (
        "UlCreateListeningEndpoint: endpoint %p, addrobj %p\n",
        pEndpoint,
        pEndpoint->AddressObject.Handle
        ));

    *ppListeningEndpoint = pEndpoint;
    return STATUS_SUCCESS;

fatal:

    ASSERT( !NT_SUCCESS(status) );

    if (pEndpoint != NULL)
    {
        //
        // Release the one-and-only reference on the endpoint, which
        // will cause it to destroy itself. Done this way to keep
        // the ownerref tracelogging happy, as it will complain if
        // the refcount doesn't drop to zero.
        //

        ASSERT(1 == pEndpoint->ReferenceCount);
        DEREFERENCE_ENDPOINT_SELF(pEndpoint, REF_ACTION_FINAL_DEREF);
    }

    return status;

}   // UlCreateListeningEndpoint


/***************************************************************************++

Routine Description:

    Closes an existing listening endpoint.

Arguments:

    pListeningEndpoint - Supplies a pointer to a listening endpoint
        previously created with UlCreateListeningEndpoint().

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCloseListeningEndpoint(
    IN PUL_ENDPOINT pListeningEndpoint,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_ENDPOINT( pListeningEndpoint ) );
    ASSERT( pCompletionRoutine != NULL );

    UlTrace(TDI, (
        "UlCloseListeningEndpoint: endpoint %p, completion %p, ctx %p\n",
        pListeningEndpoint,
        pCompletionRoutine,
        pCompletionContext
        ));

    pIrpContext = &pListeningEndpoint->CleanupIrpContext;

    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->pOwnIrp            = NULL;

    //
    // Let UlpDisconnectAllActiveConnections do the dirty work.
    //

    status = UlpDisconnectAllActiveConnections( pListeningEndpoint );

    return status;

}   // UlCloseListeningEndpoint


/***************************************************************************++

Routine Description:

    Closes a previously accepted connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    AbortiveDisconnect - Supplies TRUE if the connection is to be abortively
        disconnected, FALSE if it should be gracefully disconnected.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlCloseConnection(
    IN PVOID pObject,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;
    PUL_CONNECTION pConnection = (PUL_CONNECTION) pObject;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlCloseConnection: connection %p, abort %lu\n",
        pConnection,
        (ULONG)AbortiveDisconnect
        ));

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pTraceLog,
        (AbortiveDisconnect ?
            REF_ACTION_CLOSE_UL_CONNECTION_ABORTIVE :
            REF_ACTION_CLOSE_UL_CONNECTION_GRACEFUL),
        pConnection->ReferenceCount,
        pConnection,
        __FILE__,
        __LINE__
        );

    //
    // We only send graceful disconnects through the filter
    // process. There's also no point in going through the
    // filter if the connection is already being closed or
    // aborted.
    //

    if (pConnection->FilterInfo.pFilterChannel &&
        !pConnection->ConnectionFlags.CleanupBegun &&
        !pConnection->ConnectionFlags.DisconnectIndicated &&
        !pConnection->ConnectionFlags.AbortIndicated &&
        !AbortiveDisconnect)
    {
        //
        // Send graceful disconnect through the filter process.
        //
        status = UlFilterCloseHandler(
                        &pConnection->FilterInfo,
                        pCompletionRoutine,
                        pCompletionContext
                        );

    }
    else
    {
        //
        // Really close the connection.
        //

        status = UlpCloseRawConnection(
                        pConnection,
                        AbortiveDisconnect,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }

    return status;

}   // UlCloseConnection


/***************************************************************************++

Routine Description:

    Sends a block of data on the specified connection. If the connection
    is filtered, the data will be sent to the filter first.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pMdlChain - Supplies a pointer to a MDL chain describing the
        data buffers to send.

    Length - Supplies the length of the data referenced by the MDL
        chain.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the data is sent.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

    InitiateDisconnect - Supplies TRUE if a graceful disconnect should
        be initiated immediately after initiating the send (i.e. before
        the send actually completes).

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlSendData(
    IN PUL_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    IN PIRP pOwnIrp,
    IN PUL_IRP_CONTEXT pOwnIrpContext,
    IN BOOLEAN InitiateDisconnect
    )
{
    NTSTATUS status;
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    ASSERT( pMdlChain != NULL );
    ASSERT( Length > 0 );
    ASSERT( pCompletionRoutine != NULL );

    UlTrace(TDI, (
        "UlSendData: connection %p, mdl %p, length %lu\n",
        pConnection,
        pMdlChain,
        Length
        ));

    //
    // Connection should be around until we make a call
    // to close connection. See below.
    //

    REFERENCE_CONNECTION( pConnection );

    //
    // Allocate & initialize a context structure if necessary.
    //

    if (pOwnIrpContext == NULL)
    {
        pIrpContext = UlPplAllocateIrpContext();
    }
    else
    {
        ASSERT( pOwnIrp != NULL );
        pIrpContext = pOwnIrpContext;
    }

    if (pIrpContext == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;
    pIrpContext->pOwnIrp            = pOwnIrp;

    //
    // Try to send the data.  This send operation may complete inline
    // fast, if the connection has already been aborted by the client
    // In that case connection may gone away. To prevent this we
    // keep additional refcount until we make a call to close connection
    // below.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // First go through the filter.
        //
        status = UlFilterSendHandler(
                        &pConnection->FilterInfo,
                        pMdlChain,
                        Length,
                        pIrpContext
                        );

        UlTrace(TDI, (
            "UlSendData: sent filtered data, status = 0x%x\n",
            status
            ));

        ASSERT(status == STATUS_PENDING);

        if (pIrpContext != NULL && pIrpContext != pOwnIrpContext)
        {
            UlPplFreeIrpContext( pIrpContext );
        }
    }
    else
    {
        //
        // Just send it directly to the network.
        //

        status = UlpSendRawData(
                        pConnection,
                        pMdlChain,
                        Length,
                        pIrpContext
                        );

        UlTrace(TDI, (
            "UlSendData: sent raw data, status = 0x%x\n",
            status
            ));
    }

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    //
    // Now that the send is "in flight", initiate a disconnect if
    // so requested.
    //
    // CODEWORK: Investigate the new-for-NT5 TDI_SEND_AND_DISCONNECT flag.
    //

    if (InitiateDisconnect)
    {
        WRITE_REF_TRACE_LOG2(
                g_pTdiTraceLog,
                pConnection->pTraceLog,
                REF_ACTION_CLOSE_UL_CONNECTION_GRACEFUL,
                pConnection->ReferenceCount,
                pConnection,
                __FILE__,
                __LINE__
                );

        (VOID)UlCloseConnection(
                pConnection,
                FALSE,          // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

        UlTrace(TDI, (
                "UlSendData: closed conn\n"
                ));
    }

    DEREFERENCE_CONNECTION( pConnection );

    return STATUS_PENDING;

fatal:

    ASSERT( !NT_SUCCESS(status) );

    if (pIrpContext != NULL && pIrpContext != pOwnIrpContext)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    (VOID)UlpCloseRawConnection(
                pConnection,
                TRUE,           // AbortiveDisconnect
                NULL,           // pCompletionRoutine
                NULL            // pCompletionContext
                );

    UlTrace(TDI, (
        "UlSendData: error occurred; closed raw conn\n"
        ));

    status = UlInvokeCompletionRoutine(
                    status,
                    0,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    UlTrace(TDI, (
        "UlSendData: finished completion routine: status = 0x%x\n",
        status
        ));

    DEREFERENCE_CONNECTION( pConnection );

    return status;

}   // UlSendData

/***************************************************************************++

Routine Description:

    Receives data from the specified connection. This function is
    typically used after a receive indication handler has failed to
    consume all of the indicated data.

    If the connection is filtered the data will be read from the
    filter channel.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pBuffer - Supplies a pointer to the target buffer for the received
        data.

    BufferLength - Supplies the length of pBuffer.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlReceiveData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    NTSTATUS status;
    PUL_CONNECTION pConnection = (PUL_CONNECTION)pConnectionContext;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONNECTION(pConnection));

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // This is a filtered connection, get the data from the
        // filter.
        //
        status = UlFilterReadHandler(
                        &pConnection->FilterInfo,
                        (PBYTE)pBuffer,
                        BufferLength,
                        pCompletionRoutine,
                        pCompletionContext
                        );

    }
    else
    {
        //
        // This is not a filtered connection. Get the data from
        // TDI.
        //

        status = UlpReceiveRawData(
                        pConnectionContext,
                        pBuffer,
                        BufferLength,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }

    return status;

}   // UlReceiveData


/***************************************************************************++

Routine Description:

    Either create a new endpoint for the specified address or, if one
    already exists, reference it.

Arguments:

    pSiteUrl - Supplies the URL specifying the site to add.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAddSiteToEndpointList(
    IN PWSTR pSiteUrl
    )
{
    NTSTATUS status;
    TA_IP_ADDRESS address;
    BOOLEAN secure;
    PUL_ENDPOINT pEndpoint;
    KIRQL oldIrql;

    //
    // N.B. pSiteUrl is paged and cannot be manipulated with the
    // spinlock held. Even though this routine cannot be pageable
    // (due to the spinlock aquisition), it must be called at
    // low IRQL.
    //

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    UlTrace(SITE, (
        "UlAddSiteToEndpointList: URL = %ws\n",
        pSiteUrl
        ));

    //
    // Convert the string into an address.
    //

    status = UlpUrlToAddress(pSiteUrl, &address, &secure);

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );

    //
    // make sure we're not shutting down
    //
    if (g_TdiWaitingForEndpointDrain) {
        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

        status = STATUS_DEVICE_BUSY;
        goto cleanup;
    }

    //
    // Find an existing endpoint for this address.
    //

    pEndpoint = UlpFindEndpointForAddress(
                    (PTRANSPORT_ADDRESS)&address,
                    sizeof(address)
                    );

    //
    // Did we find one?
    //

    if (pEndpoint == NULL)
    {
        //
        // Didn't find it. Try to create one. Since we must release
        // the TDI spinlock before we can create a new listening endpoint,
        // there is the opportunity for a race condition with other
        // threads creating endpoints.
        //

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

        UlTrace(SITE, (
            "UlAddSiteToEndpointList: no site for %ws, creating\n",
            pSiteUrl
            ));

        status = UlCreateListeningEndpoint(
                        (PTRANSPORT_ADDRESS)&address,   // pLocalAddress
                        sizeof(address),                // LocalAddressLength
                        secure,                         // Secure (SSL) endpoint?
                        g_UlMinIdleConnections,         // InitialBacklog
                        &UlConnectionRequest,           // callback functions
                        &UlConnectionComplete,
                        &UlConnectionDisconnect,
                        &UlConnectionDisconnectComplete,
                        &UlConnectionDestroyed,
                        &UlHttpReceive,
                        NULL,                           // pListeningContext
                        &pEndpoint
                        );

        if (!NT_SUCCESS(status))
        {
            //
            // Maybe another thread has already created it?
            //

            UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );

            pEndpoint = UlpFindEndpointForAddress(
                            (PTRANSPORT_ADDRESS)&address,
                            sizeof(address)
                            );

            if (pEndpoint != NULL)
            {
                //
                // Adjust the usage count.
                //

                pEndpoint->UsageCount++;
                ASSERT( pEndpoint->UsageCount > 0 );

                status = STATUS_SUCCESS;
            }

            //
            // The endpoint doesn't exist. This is a "real" failure.
            //

            UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );
        }
    }
    else
    {
        //
        // Adjust the usage count.
        //

        pEndpoint->UsageCount++;
        ASSERT( pEndpoint->UsageCount > 0 );

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );
    }

    UlTrace(SITE, (
        "UlAddSiteToEndpointList: using endpoint %p for URL %ws\n",
        pEndpoint,
        pSiteUrl
        ));

cleanup:

    RETURN(status);

}   // UlAddSiteToEndpointList


/***************************************************************************++

Routine Description:

    Dereference the endpoint corresponding to the specified address.

Arguments:

    pSiteUrl - Supplies the URL specifying the site to remove.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlRemoveSiteFromEndpointList(
    IN PWSTR pSiteUrl
    )
{
    NTSTATUS status;
    TA_IP_ADDRESS address;
    BOOLEAN secure;
    PUL_ENDPOINT pEndpoint;
    KIRQL oldIrql;
    BOOLEAN spinlockHeld = FALSE;
    UL_STATUS_BLOCK ulStatus;

    //
    // N.B. pSiteUrl is paged and cannot be manipulated with the
    // spinlock held. Even though this routine cannot be pageable
    // (due to the spinlock aquisition), it must be called at
    // low IRQL.
    //

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    UlTrace(SITE, (
        "UlRemoveSiteFromEndpointList: URL = %ws\n",
        pSiteUrl
        ));

    //
    // Convert the string into an address.
    //

    status = UlpUrlToAddress(pSiteUrl, &address, &secure);

    if (!NT_SUCCESS(status))
    {
        goto cleanup;
    }

    //
    // Find an existing endpoint for this address.
    //

    UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );
    spinlockHeld = TRUE;

    pEndpoint = UlpFindEndpointForAddress(
                    (PTRANSPORT_ADDRESS)&address,
                    sizeof(address)
                    );

    //
    // Did we find one?
    //

    if (pEndpoint == NULL)
    {
        //
        // Ideally, this should never happen.
        //

        status = STATUS_NOT_FOUND;
        goto cleanup;
    }

    //
    // Adjust the usage count. If it drops to zero, blow away the
    // endpoint.
    //

    ASSERT( pEndpoint->UsageCount > 0 );
    pEndpoint->UsageCount--;

    if (pEndpoint->UsageCount == 0)
    {
        //
        // We can't call UlCloseListeningEndpoint() with the TDI spinlock
        // held. If the endpoint is still on the global list, then go
        // ahead and remove it now, release the TDI spinlock, and then
        // close the endpoint.
        //

        if (! pEndpoint->Deleted)
        {
            ASSERT(NULL != pEndpoint->GlobalEndpointListEntry.Flink);

            RemoveEntryList( &pEndpoint->GlobalEndpointListEntry );

            InsertTailList(
                    &g_TdiDeletedEndpointListHead,
                    &pEndpoint->GlobalEndpointListEntry
                    );
            pEndpoint->Deleted = TRUE;
        }

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );
        spinlockHeld = FALSE;

        UlTrace(SITE, (
            "UlRemoveSiteFromEndpointList: closing endpoint %p for URL %ws\n",
            pEndpoint,
            pSiteUrl
            ));

        //
        // Initialize a status block. We'll pass a pointer to this as
        // the completion context to UlCloseListeningEndpoint(). The
        // completion routine will update the status block and signal
        // the event.
        //

        UlInitializeStatusBlock( &ulStatus );

        status = UlCloseListeningEndpoint(
                        pEndpoint,
                        &UlpSynchronousIoComplete,
                        &ulStatus
                        );

        if (status == STATUS_PENDING)
        {
            //
            // Wait for it to finish.
            //

            UlWaitForStatusBlockEvent( &ulStatus );

            //
            // Retrieve the updated status.
            //

            status = ulStatus.IoStatus.Status;
        }

    }

cleanup:

    if (spinlockHeld)
    {
        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );
    }

#if DBG
    if (status == STATUS_NOT_FOUND)
    {
        UlTrace(SITE, (
            "UlRemoveSiteFromEndpointList: cannot find endpoint for URL %ws\n",
            pSiteUrl
            ));
    }
#endif

    RETURN(status);

}   // UlRemoveSiteFromEndpointList


//
// Private functions.
//


/***************************************************************************++

Routine Description:

    Destroys all resources allocated to an endpoint, including the
    endpoint structure itself.

Arguments:

    pEndpoint - Supplies the endpoint to destroy.

--***************************************************************************/
VOID
UlpDestroyEndpoint(
    IN PUL_ENDPOINT pEndpoint
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    PUL_CONNECTION pConnection;
    ULONG EndpointCount;
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    ASSERT(0 == pEndpoint->ReferenceCount);

    UlTrace(TDI, (
        "UlpDestroyEndpoint: endpoint %p\n",
        pEndpoint
        ));

    //
    // Purge the idle queue.
    //

    for (;;)
    {
        pConnection = UlpDequeueIdleConnection( pEndpoint, FALSE );

        if (pConnection == NULL )
        {
            break;
        }

        ASSERT( IS_VALID_CONNECTION( pConnection ) );

        if (pConnection->FilterInfo.pFilterChannel)
        {
            HTTP_RAW_CONNECTION_ID ConnectionId;

            ConnectionId = pConnection->FilterInfo.ConnectionId;
            HTTP_SET_NULL_ID( &pConnection->FilterInfo.ConnectionId );

            if (! HTTP_IS_NULL_ID( &ConnectionId ))
            {
                UlFreeOpaqueId(ConnectionId, UlOpaqueIdTypeRawConnection);
                ASSERT( pConnection->ReferenceCount >= 2 );
                DEREFERENCE_CONNECTION(pConnection);
            }
        }

        UlpDestroyConnection( pConnection );
    }

    //
    // Invoke the completion routine in the IRP context if specified.
    //

    pIrpContext = &pEndpoint->CleanupIrpContext;

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    if (pIrpContext->pCompletionRoutine != NULL)
    {
        (pIrpContext->pCompletionRoutine)(
            pIrpContext->pCompletionContext,
            STATUS_SUCCESS,
            0
            );
    }

    //
    // Close the TDI object.
    //

    UxCloseTdiObject( &pEndpoint->AddressObject );

    //
    // Remove the endpoint from g_TdiDeletedEndpointListHead
    //

    ASSERT( pEndpoint->Deleted );
    ASSERT( NULL != pEndpoint->GlobalEndpointListEntry.Flink );

    UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );
    RemoveEntryList( &pEndpoint->GlobalEndpointListEntry );
    UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

    //
    // Zap the owner ref trace log
    //

    DESTROY_OWNER_REF_TRACE_LOG(pEndpoint->pOwnerRefTraceLog);

    //
    // Free the endpoint structure.
    //

    pEndpoint->Signature = UL_ENDPOINT_SIGNATURE_X;
    UL_FREE_POOL( pEndpoint, UL_ENDPOINT_POOL_TAG );

    //
    // Decrement the global endpoint count.
    //

    EndpointCount = InterlockedDecrement((PLONG) &g_TdiEndpointCount);

    if (g_TdiWaitingForEndpointDrain && (EndpointCount == 0))
    {
        KeSetEvent(&g_TdiEndpointDrainEvent, 0, FALSE);
    }


}   // UlpDestroyEndpoint


/***************************************************************************++

Routine Description:

    Destroys all resources allocated to an connection, including the
    connection structure itself.

Arguments:

    pConnection - Supplies the connection to destroy.

--***************************************************************************/
VOID
UlpDestroyConnection(
    IN PUL_CONNECTION pConnection
    )
{
    KIRQL OldIrql;
    LONG  ConnectionCount;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->ActiveListEntry.Flink == NULL );
    ASSERT( pConnection->IdleSListEntry.Next == NULL );

    UlTrace(TDI, (
        "UlpDestroyConnection: connection %p\n",
        pConnection
        ));

    //
    // Release the filter channel if we still have a ref.
    // This only happens when we destroy idle connections.
    //
    if (pConnection->FilterInfo.pFilterChannel)
    {
        ASSERT(pConnection->FilterInfo.ConnState == UlFilterConnStateInactive);

        DEREFERENCE_FILTER_CHANNEL(pConnection->FilterInfo.pFilterChannel);
        pConnection->FilterInfo.pFilterChannel = NULL;
    }

    // If OpaqueId is non-zero, then refCount should not be zero
    ASSERT(HTTP_IS_NULL_ID(&pConnection->FilterInfo.ConnectionId));

#if INVESTIGATE_LATER

    //
    // Free the filter connection ID
    //
    UlFreeOpaqueId(
        pConnection->FilterInfo.ConnectionId,
        UlOpaqueIdTypeRawConnection);
#endif

    DESTROY_REF_TRACE_LOG( pConnection->pTraceLog );
    DESTROY_REF_TRACE_LOG( pConnection->HttpConnection.pTraceLog );

    //
    // Close the TDI object.
    //

    UxCloseTdiObject( &pConnection->ConnectionObject );

    //
    // Free the accept IRP.
    //

    if (pConnection->pIrp != NULL)
    {
        UlFreeIrp( pConnection->pIrp );
    }

    //
    // Remove from global list of connections
    //

    UlAcquireSpinLock( &g_TdiSpinLock, &OldIrql );
    RemoveEntryList( &pConnection->GlobalConnectionListEntry );
    UlReleaseSpinLock( &g_TdiSpinLock, OldIrql );

    ConnectionCount = InterlockedDecrement((PLONG) &g_TdiConnectionCount);

    //
    // Free the connection structure.
    //

    pConnection->Signature = UL_CONNECTION_SIGNATURE_X;
    UL_FREE_POOL( pConnection, UL_CONNECTION_POOL_TAG );

    // allow us to shut down

    if (g_TdiWaitingForEndpointDrain && (ConnectionCount == 0))
    {
        KeSetEvent(&g_TdiConnectionDrainEvent, 0, FALSE);
    }

}   // UlpDestroyConnection



/***************************************************************************++

Routine Description:

    Dequeues an idle connection from the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint to dequeue from.

    ScheduleReplenish - Supplies TRUE if a replenishment of the
        idle connection list should be scheduled.

Return Value:

    PUL_CONNECTION - Pointer to an idle connection is successful,
        NULL otherwise.

--***************************************************************************/
PUL_CONNECTION
UlpDequeueIdleConnection(
    IN PUL_ENDPOINT pEndpoint,
    IN BOOLEAN ScheduleReplenish
    )
{
    PSINGLE_LIST_ENTRY pSListEntry;
    PUL_CONNECTION pConnection;
    BOOLEAN ReplenishNeeded;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Pop an entry off the list.
    //

    pSListEntry = ExInterlockedPopEntrySList(
                        &pEndpoint->IdleConnectionSListHead,
                        KSPIN_LOCK_FROM_UL_SPIN_LOCK(&pEndpoint->IdleConnectionSpinLock)
                        );

    if (pSListEntry != NULL)
    {
        pConnection = CONTAINING_RECORD(
                            pSListEntry,
                            UL_CONNECTION,
                            IdleSListEntry
                            );

        pConnection->IdleSListEntry.Next = NULL;

        ASSERT( IS_VALID_CONNECTION( pConnection ) );

        ASSERT(pConnection->ConnectionFlags.Value == 0);

        if ( pConnection->FilterInfo.pFilterChannel )
        {
            //
            // If the idle connection has filter attached on it, it will have
            // an additional refcount because of the opaque id assigned to the
            // ul_connection, filter API uses this id to communicate with the
            // filter app through various IOCTLs.
            //
            ASSERT( 2 == pConnection->ReferenceCount );
        }
        else
        {
            //
            // As long as the connection doesn get destroyed it will sit
            // in the idle list with one refcount on it.
            //
            ASSERT( 1 == pConnection->ReferenceCount );
        }

        SET_OWNER_REF_TRACE_LOG_MONOTONIC_ID(
            pConnection->MonotonicId,
            pConnection->pOwningEndpoint->pOwnerRefTraceLog);

        //
        // See if we need to generate more connections.
        //

        ReplenishNeeded = UlpDecrementIdleConnections(pEndpoint);
    }
    else
    {
        //
        // The idle list is empty. However, we should not schedule
        // a replenish at this time. The driver's init code ensures
        // that the min idle connections for an endpoint is always
        // at least two, so the thread that decremented the counter
        // to one will have scheduled a replenish by now anyway,
        // and the replenish will continue adding connections until
        // there are at least the min number of connections.
        //

        ReplenishNeeded = FALSE;
        pConnection = NULL;
    }


    //
    // Schedule a replenish if necessary.
    //

    if (ReplenishNeeded && ScheduleReplenish)
    {
        TRACE_REPLENISH(
            pEndpoint,
            DummySynch,
            pEndpoint->EndpointSynch,
            REPLENISH_ACTION_QUEUE_REPLENISH
            );

        //
        // Add a reference to the endpoint to ensure that it doesn't
        // disappear from under us. UlpReplenishEndpointWorker will
        // remove the reference once it's finished.
        //

        REFERENCE_ENDPOINT_SELF(pEndpoint, REF_ACTION_REPLENISH);

        UL_QUEUE_WORK_ITEM(
            &pEndpoint->WorkItem,
            &UlpReplenishEndpointWorker
            );
    }


    return pConnection;

}   // UlpDequeueIdleConnection


/***************************************************************************++

Routine Description:

    Enqueues an idle connection onto the specified endpoint.

Arguments:

    pConnection - Supplies the connection to enqueue.
    Replinishing - TRUE if the connection is being added as part
        of a replenish.

Return values:

    Returns TRUE if the number of connections on the queue is still less
    than the minimum required.

--***************************************************************************/
BOOLEAN
UlpEnqueueIdleConnection(
    IN PUL_CONNECTION pConnection,
    IN BOOLEAN Replenishing
    )
{
    PUL_ENDPOINT pEndpoint;
    BOOLEAN ContinueReplenish;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    ASSERT(pConnection->ConnectionFlags.Value == 0);
    ASSERT(pConnection->ActiveListEntry.Flink == NULL);

    // The idle list holds a reference; the filter channel (if it exists)
    // holds another reference.
    ASSERT(pConnection->ReferenceCount ==
                1 + (pConnection->FilterInfo.pFilterChannel != NULL));

    //
    // Increment the count of connections and see if we need
    // to continue the replenish. We need to increment before
    // we actually put the item on the list because otherwise
    // someone else might pull the entry off and decrement the
    // count below zero before we increment. There is no harm
    // in the count being temporarily higher than the actual
    // size of the list.
    //

    ContinueReplenish = UlpIncrementIdleConnections(
                            pEndpoint,
                            Replenishing
                            );

    //
    // Push it onto the list.
    //

    ExInterlockedPushEntrySList(
        &pEndpoint->IdleConnectionSListHead,
        &pConnection->IdleSListEntry,
        KSPIN_LOCK_FROM_UL_SPIN_LOCK(&pEndpoint->IdleConnectionSpinLock)
        );

    return ContinueReplenish;

}   // UlpEnqueueIdleConnection


/***************************************************************************++

Routine Description:

    Enqueues an active connection onto the specified endpoint.

Arguments:

    pConnection - Supplies the connection to enqueue.

--***************************************************************************/
VOID
UlpEnqueueActiveConnection(
    IN PUL_CONNECTION pConnection
    )
{
    PUL_ENDPOINT pEndpoint;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    ASSERT(pConnection->IdleSListEntry.Next == NULL);

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Append it to the list.
    //

    REFERENCE_CONNECTION(pConnection);

    ExInterlockedInsertHeadList(
        &pEndpoint->ActiveConnectionListHead[pConnection->ActiveListIndex],
        &pConnection->ActiveListEntry,
        KSPIN_LOCK_FROM_UL_SPIN_LOCK(&pEndpoint->ActiveConnectionSpinLock[pConnection->ActiveListIndex])
        );

}   // UlpEnqueueActiveConnection


/***************************************************************************++

Routine Description:

    Handler for incoming connections.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    RemoteAddressLength - Supplies the length of the remote (client-
        side) address.

    pRemoteAddress - Supplies a pointer to the remote address as
        stored in a TRANSPORT_ADDRESS structure.

    UserDataLength - Optionally supplies the length of any connect
        data associated with the connection request.

    pUserData - Optionally supplies a pointer to any connect data
        associated with the connection request.

    OptionsLength - Optionally supplies the length of any connect
        options associated with the connection request.

    pOptions - Optionally supplies a pointer to any connect options
        associated with the connection request.

    pConnectionContext - Receives the context to associate with this
        connection. We'll always use a PUL_CONNECTION as the context.

    pAcceptIrp - Receives an IRP that will be completed by the transport
        when the incoming connection is fully accepted.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpConnectHandler(
    IN PVOID pTdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID pRemoteAddress,
    IN LONG UserDataLength,
    IN PVOID pUserData,
    IN LONG OptionsLength,
    IN PVOID pOptions,
    OUT CONNECTION_CONTEXT *pConnectionContext,
    OUT PIRP *pAcceptIrp
    )
{
    NTSTATUS                        status;
    BOOLEAN                         result;
    PUL_ENDPOINT                    pEndpoint;
    PUL_CONNECTION                  pConnection;
    PUX_TDI_OBJECT                  pTdiObject;
    PIRP                            pIrp;
    BOOLEAN                         handlerCalled;
    TRANSPORT_ADDRESS UNALIGNED     *TAList;
    PTA_ADDRESS                     TA;

    UL_ENTER_DRIVER("UlpConnectHandler", NULL);

    //
    // Sanity check.
    //

    pEndpoint = (PUL_ENDPOINT)pTdiEventContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    UlTrace(TDI,("UlpConnectHandler: endpoint %p\n", pTdiEventContext));

    //
    // Setup locals so we know how to cleanup on fatal exit.
    //

    pConnection = NULL;
    handlerCalled = FALSE;

    //
    // make sure that we are not in the process of destroying this
    // endpoint.  UlRemoveSiteFromEndpointList will do that and
    // start the cleanup process when UsageCount hits 0.
    //

    if (pEndpoint->UsageCount == 0)
    {
        status = STATUS_CONNECTION_REFUSED;
        goto fatal;
    }

    //
    // Try to pull an idle connection from the endpoint.
    //

    for (;;)
    {
        pConnection = UlpDequeueIdleConnection( pEndpoint, TRUE );

        if (pConnection == NULL )
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto fatal;
        }

        ASSERT( IS_VALID_CONNECTION( pConnection ) );

        //
        // Establish a referenced pointer from the connection back
        // to the endpoint.
        //

        ASSERT( pConnection->pOwningEndpoint == pEndpoint );

        REFERENCE_ENDPOINT_CONNECTION(
            pEndpoint,
            REF_ACTION_CONNECT,
            pConnection
            );

        //
        // Make sure the filter settings are up to date.
        //
        if (UlValidateFilterChannel(
                pConnection->FilterInfo.pFilterChannel,
                pConnection->FilterInfo.SecureConnection
                ))
        {
            //
            // We found a good connection.
            // Break out of the loop and go on.
            //
            break;
        }

        //
        // This connection doesn't have up to date filter
        // settings. Destroy it and get a new connection.
        //

        // Grab a reference. Worker will deref it.
        REFERENCE_CONNECTION( pConnection );

        UL_CALL_PASSIVE(
             &pConnection->WorkItem,
             &UlpCleanupEarlyConnection
             );        
    }

    //
    // We should have a good connection now.
    //
    
    ASSERT(IS_VALID_CONNECTION(pConnection));

    pTdiObject = &pConnection->ConnectionObject;

    //
    // Store the remote address in the connection.
    //


    TAList = (TRANSPORT_ADDRESS UNALIGNED *) pRemoteAddress;
    TA = (PTA_ADDRESS) TAList->Address;

    if (TDI_ADDRESS_TYPE_IP == TA->AddressType) {

        if (TA->AddressLength >= TDI_ADDRESS_LENGTH_IP) {

            TDI_ADDRESS_IP UNALIGNED * ValidAddr = (TDI_ADDRESS_IP UNALIGNED *) TA->Address;

            pConnection->RemoteAddress = SWAP_LONG(ValidAddr->in_addr);
            pConnection->RemotePort    = SWAP_SHORT(ValidAddr->sin_port);
        }

    } else {

        // Add support for IP6 here
    }

    //
    // Invoke the client's handler to see if they can accept
    // this connection. If they refuse it, bail.
    //

    result = (pEndpoint->pConnectionRequestHandler)(
                    pEndpoint->pListeningContext,
                    pConnection,
                    (PTRANSPORT_ADDRESS)(pRemoteAddress),
                    RemoteAddressLength,
                    &pConnection->pConnectionContext
                    );

    if (!result)
    {
        status = STATUS_CONNECTION_REFUSED;
        goto fatal;
    }

    //
    // Remember that we've called the handler. If we hit a fatal
    // condition (say, out of memory) after this point, we'll
    // fake a "failed connection complete" indication to the client
    // so they can cleanup their state.
    //

    handlerCalled = TRUE;

    pConnection->pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pConnection->pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;


    TdiBuildAccept(
        pConnection->pIrp,                          // Irp
        pTdiObject->pDeviceObject,                  // DeviceObject
        pTdiObject->pFileObject,                    // FileObject
        &UlpRestartAccept,                          // CompletionRoutine
        pConnection,                                // Context
        &(pConnection->TdiConnectionInformation),   // RequestConnectionInfo
        NULL                                        // ReturnConnectionInfo
        );

    //
    // We must trace the IRP before we set the next stack location
    // so the trace code can pull goodies from the IRP correctly.
    //

    TRACE_IRP( IRP_ACTION_CALL_DRIVER, pConnection->pIrp );

    //
    // Make the next stack location current. Normally, UlCallDriver would
    // do this for us, but since we're bypassing UlCallDriver, we must do
    // it ourselves.
    //

    IoSetNextIrpStackLocation( pConnection->pIrp );

    //
    // Return the IRP to the transport.
    //

    *pAcceptIrp = pConnection->pIrp;

    //
    // Establish the connection context.
    //

    *pConnectionContext = (CONNECTION_CONTEXT)pConnection;
    pConnection->ConnectionFlags.AcceptPending = TRUE;

    //
    // Reference the connection so it doesn't go away before
    // the accept IRP completes.
    //
    REFERENCE_CONNECTION( pConnection );

    UL_LEAVE_DRIVER("UlpConnectHandler");

    //
    // Tell TDI that we gave it an IRP to complete.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;


    //
    // Cleanup for fatal error conditions.
    //

fatal:

    UlTrace(TDI, (
        "UlpConnectHandler: endpoint %p, failure %08lx\n",
        pTdiEventContext,
        status
        ));

    if (handlerCalled)
    {
        //
        // Fake a "failed connection complete" indication.
        //

        (pEndpoint->pConnectionCompleteHandler)(
            pEndpoint->pListeningContext,
            pConnection->pConnectionContext,
            status
            );
    }

    //
    // If we managed to pull a connection off the idle list, then
    // put it back and remove the endpoint reference we added.
    //

    if (pConnection != NULL)
    {
       // Fake refcount up. Worker will deref it.
       REFERENCE_CONNECTION( pConnection );

       UL_CALL_PASSIVE(
            &pConnection->WorkItem,
            &UlpCleanupEarlyConnection
            );
    }

    UL_LEAVE_DRIVER("UlpConnectHandler");

    return status;

}   // UlpConnectHandler


/***************************************************************************++

Routine Description:

    Handler for disconnect requests.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUL_CONNECTION.

    DisconnectDataLength - Optionally supplies the length of any
        disconnect data associated with the disconnect request.

    pDisconnectData - Optionally supplies a pointer to any disconnect
        data associated with the disconnect request.

    DisconnectInformationLength - Optionally supplies the length of any
        disconnect information associated with the disconnect request.

    pDisconnectInformation - Optionally supplies a pointer to any
        disconnect information associated with the disconnect request.

    DisconnectFlags - Supplies the disconnect flags. This will be zero
        or more TDI_DISCONNECT_* flags.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpDisconnectHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID pDisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID pDisconnectInformation,
    IN ULONG DisconnectFlags
    )
{
    PUL_ENDPOINT        pEndpoint;
    PUL_CONNECTION      pConnection;
    PVOID               pListeningContext;
    PVOID               pConnectionContext;
    NTSTATUS            status;
    UL_CONNECTION_FLAGS newFlags;


    UL_ENTER_DRIVER("UlpDisconnectHandler", NULL);

    //
    // Sanity check.
    //

    pEndpoint = (PUL_ENDPOINT)pTdiEventContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    pConnection = (PUL_CONNECTION)ConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->pOwningEndpoint == pEndpoint );

    UlTrace(TDI, (
        "UlpDisconnectHandler: endpoint %p, connection %p, flags %08lx\n",
        pTdiEventContext,
        (PVOID)ConnectionContext,
        DisconnectFlags
        ));

    //
    // If it's a filtered connection, make sure we stop passing
    // on AppWrite data.
    //
    if (pConnection->FilterInfo.pFilterChannel)
    {
        UlDestroyFilterConnection(&pConnection->FilterInfo);
    }

    //
    // Update the connection state based on the type of disconnect.
    //

    if (DisconnectFlags & TDI_DISCONNECT_ABORT)
    {
        status = STATUS_CONNECTION_ABORTED;
    }
    else
    {
        status = STATUS_SUCCESS;
    }

    //
    // Capture the endpoint and connection context values here so we can
    // invoke the client's handler *after* dereferencing the connection.
    //

    pListeningContext = pEndpoint->pListeningContext;
    pConnectionContext = pConnection->pConnectionContext;

    //
    // Tell the client, but only if the accept IRP has already completed.
    //

    newFlags.Value =
            *((volatile LONG *)&pConnection->ConnectionFlags.Value);

    if (newFlags.AcceptComplete)
    {
        //
        // Silently close the connection. No need to go httprcv
        // disconnect handler. It's just going to callback us anyway.
        //

        UlpCloseRawConnection( pConnection,
                               FALSE,
                               NULL,
                               NULL
                               );
    }

    //
    // Done with the disconnect mark the flag, before attempting
    // to remove the final reference.
    //

    if (DisconnectFlags & TDI_DISCONNECT_ABORT)
    {
        newFlags = UlpSetConnectionFlag(
                        pConnection,
                        MakeAbortIndicatedFlag()
                        );
    }
    else
    {
        newFlags = UlpSetConnectionFlag(
                        pConnection,
                        MakeDisconnectIndicatedFlag()
                        );
    }

    //
    // If cleanup has begun on the connection, remove the final reference.
    //

    UlpRemoveFinalReference( pConnection, newFlags );

    UL_LEAVE_DRIVER("UlpDisconnectHandler");

    return STATUS_SUCCESS;

}   // UlpDisconnectHandler


/***************************************************************************++

Routine Description:

    Closes a previously accepted connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    AbortiveDisconnect - Supplies TRUE if the connection is to be abortively
        disconnected, FALSE if it should be gracefully disconnected.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpCloseRawConnection(
    IN PVOID pConn,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;
    PUL_CONNECTION pConnection = (PUL_CONNECTION)pConn;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlpCloseRawConnection: connection %p, abort %lu\n",
        pConnection,
        (ULONG)AbortiveDisconnect
        ));

    //
    // This is the final close handler for all types of connections
    // filter, non filter. We should not go through this path twice
    //

    if (FALSE != InterlockedExchange(&pConnection->Terminated, TRUE))
    {
        //
        // we've already done it. don't do it twice.
        //

        status = UlInvokeCompletionRoutine(
                        STATUS_SUCCESS,
                        0,
                        pCompletionRoutine,
                        pCompletionContext
                        );

        return status;
    }

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pTraceLog,
        REF_ACTION_CLOSE_UL_CONNECTION_RAW_CLOSE,
        pConnection->ReferenceCount,
        pConnection,
        __FILE__,
        __LINE__
        );

    //
    // Get rid of our opaque id if we're a filtered connection.
    // Also make sure we stop delivering AppWrite data to the parser.
    //
    if (pConnection->FilterInfo.pFilterChannel)
    {
        UL_CALL_PASSIVE(
            &pConnection->WorkItem,
            &UlpCleanupConnectionId
            );

        UlDestroyFilterConnection(&pConnection->FilterInfo);
    }

    //
    // Begin a disconnect and let the completion routine do the
    // dirty work.
    //

    if (AbortiveDisconnect)
    {
        status = UlpBeginAbort(
                     pConnection,
                     pCompletionRoutine,
                     pCompletionContext
                     );
    }
    else
    {
        status = UlpBeginDisconnect(
                     pConnection,
                     pCompletionRoutine,
                     pCompletionContext
                     );
    }

    return status;

}   // UlpCloseRawConnection


/***************************************************************************++

Routine Description:

    Sends a block of data on the specified connection.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pMdlChain - Supplies a pointer to a MDL chain describing the
        data buffers to send.

    Length - Supplies the length of the data referenced by the MDL
        chain.

    pIrpContext - used to indicate completion to the caller.

    InitiateDisconnect - Supplies TRUE if a graceful disconnect should
        be initiated immediately after initiating the send (i.e. before
        the send actually completes).

--***************************************************************************/
NTSTATUS
UlpSendRawData(
    IN PVOID pObject,
    IN PMDL pMdlChain,
    IN ULONG Length,
    PUL_IRP_CONTEXT pIrpContext
    )
{
    NTSTATUS status;
    PIRP pIrp;
    PUX_TDI_OBJECT pTdiObject;
    PUL_CONNECTION pConnection = (PUL_CONNECTION) pObject;
    BOOLEAN OwnIrpContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pTdiObject = &pConnection->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    ASSERT( pMdlChain != NULL );
    ASSERT( Length > 0 );
    ASSERT( pIrpContext != NULL );

    //
    // Allocate an IRP.
    //

    if (pIrpContext->pOwnIrp)
    {
        OwnIrpContext = TRUE;
        pIrp = pIrpContext->pOwnIrp;
    }
    else
    {
        OwnIrpContext = FALSE;
        pIrp = UlAllocateIrp(
                    pTdiObject->pDeviceObject->StackSize,   // StackSize
                    FALSE                                   // ChargeQuota
                    );

        if (pIrp == NULL)
        {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto fatal;
        }
    }

    //
    // Build the send IRP, call the transport.
    //

    pIrp->RequestorMode = KernelMode;
    pIrp->Tail.Overlay.Thread = PsGetCurrentThread();
    pIrp->Tail.Overlay.OriginalFileObject = pTdiObject->pFileObject;

    TdiBuildSend(
        pIrp,                                   // Irp
        pTdiObject->pDeviceObject,              // DeviceObject
        pTdiObject->pFileObject,                // FileObject
        &UlpRestartSendData,                    // CompletionRoutine
        pIrpContext,                            // Context
        pMdlChain,                              // MdlAddress
        0,                                      // Flags
        Length                                  // SendLength
        );

    UlTrace(TDI, (
            "UlpSendRawData: allocated irp %p for connection %p\n",
            pIrp,
            pConnection
            ));

    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
        REF_ACTION_SEND_MDL,
        PtrToLong(pMdlChain->Next),     // bugbug64
        pMdlChain,
        __FILE__,
        __LINE__
        );

#ifdef SPECIAL_MDL_FLAG
    {
        PMDL scan = pMdlChain;

        while (scan != NULL)
        {
            ASSERT( (scan->MdlFlags & SPECIAL_MDL_FLAG) == 0 );
            scan->MdlFlags |= SPECIAL_MDL_FLAG;
            scan = scan->Next;
        }
    }
#endif

    IF_DEBUG2(TDI, VERBOSE)
    {
        PMDL  pMdl;
        ULONG i, NumMdls = 0;

        for (pMdl = pMdlChain;  pMdl != NULL;  pMdl = pMdl->Next)
        {
            ++NumMdls;
        }

        UlTrace(TDI, (
            "UlpSendRawData: irp %p, %d MDLs, %d bytes, [[[[.\n",
            pIrp, NumMdls, Length
            ));

        for (pMdl = pMdlChain, i = 1;  pMdl != NULL;  pMdl = pMdl->Next, ++i)
        {
            PVOID pBuffer;

            UlTrace(TDI, (
                "UlpSendRawData: irp %p, MDL[%d of %d], %d bytes.\n",
                pIrp, i, NumMdls, pMdl->ByteCount
                ));

            pBuffer = MmGetSystemAddressForMdlSafe(pMdl, NormalPagePriority);

            if (pBuffer != NULL)
                UlDbgPrettyPrintBuffer((UCHAR*) pBuffer, pMdl->ByteCount);
        }

        UlTrace(TDI, (
            "UlpSendRawData: irp %p ]]]].\n",
            pIrp
            ));
    }

    //
    // Add a reference to the connection, then call the driver to initiate
    // the send.
    //

    REFERENCE_CONNECTION( pConnection );

    ASSERT( g_TcpFastSend != NULL );

    IoSetNextIrpStackLocation(pIrp);

    (*g_TcpFastSend)(
        pIrp,
        IoGetCurrentIrpStackLocation(pIrp)
        );

    UlTrace(TDI, (
        "UlpSendRawData: called driver for irp %p; "
        "returning STATUS_PENDING\n",
        pIrp
        ));

    return STATUS_PENDING;

fatal:

    ASSERT( !NT_SUCCESS(status) );

    if (pIrp != NULL && OwnIrpContext == FALSE)
    {
        UlFreeIrp( pIrp );
    }

    (VOID)UlpCloseRawConnection(
                pConnection,
                TRUE,
                NULL,
                NULL
                );

    return status;

} // UlpSendRawData


/***************************************************************************++

Routine Description:

    Receives data from the specified connection. This function is
    typically used after a receive indication handler has failed to
    consume all of the indicated data.

Arguments:

    pConnection - Supplies a pointer to a connection as previously
        indicated to the PUL_CONNECTION_REQUEST handler.

    pBuffer - Supplies a pointer to the target buffer for the received
        data.

    BufferLength - Supplies the length of pBuffer.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the listening endpoint is fully closed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpReceiveRawData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    )
{
    NTSTATUS           status;
    PUX_TDI_OBJECT     pTdiObject;
    PUL_IRP_CONTEXT    pIrpContext;
    PIRP               pIrp;
    PMDL               pMdl;
    KIRQL              oldIrql;
    PUL_CONNECTION     pConnection = (PUL_CONNECTION) pConnectionContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pTdiObject = &pConnection->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    ASSERT( pCompletionRoutine != NULL );

    UlTrace(TDI, (
        "UlpReceiveRawData: connection %p, buffer %p, length %lu\n",
        pConnection,
        pBuffer,
        BufferLength
        ));

    //
    // Setup locals so we know how to cleanup on failure.
    //

    pIrpContext = NULL;
    pIrp = NULL;
    pMdl = NULL;

    //
    // Create & initialize a receive IRP.
    //

    pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pIrp != NULL)
    {
        //
        // Snag an IRP context.
        //

        pIrpContext = UlPplAllocateIrpContext();

        if (pIrpContext != NULL)
        {
            ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

            pIrpContext->pConnectionContext = (PVOID)pConnection;
            pIrpContext->pCompletionRoutine = pCompletionRoutine;
            pIrpContext->pCompletionContext = pCompletionContext;
            pIrpContext->pOwnIrp            = NULL;

            //
            // Create an MDL describing the client's buffer.
            //

            pMdl = UlAllocateMdl(
                        pBuffer,                // VirtualAddress
                        BufferLength,           // Length
                        FALSE,                  // SecondaryBuffer
                        FALSE,                  // ChargeQuota
                        NULL                    // Irp
                        );

            if (pMdl != NULL)
            {
                //
                // Adjust the MDL for our non-paged buffer.
                //

                MmBuildMdlForNonPagedPool( pMdl );

                //
                // Reference the connection, finish building the IRP.
                //

                REFERENCE_CONNECTION( pConnection );

                TdiBuildReceive(
                    pIrp,                       // Irp
                    pTdiObject->pDeviceObject,  // DeviceObject
                    pTdiObject->pFileObject,    // FileObject
                    &UlpRestartClientReceive,   // CompletionRoutine
                    pIrpContext,                // CompletionContext
                    pMdl,                       // Mdl
                    TDI_RECEIVE_NORMAL,         // Flags
                    BufferLength                // Length
                    );

                UlTrace(TDI, (
                    "UlpReceiveRawData: allocated irp %p for connection %p\n",
                    pIrp,
                    pConnection
                    ));

                //
                // Let the transport do the rest.
                //

                UlCallDriver( pTdiObject->pDeviceObject, pIrp );
                return STATUS_PENDING;
            }
        }
    }

    //
    // We only make it this point if we hit an allocation failure.
    //

    if (pMdl != NULL)
    {
        UlFreeMdl( pMdl );
    }

    if (pIrpContext != NULL)
    {
        UlPplFreeIrpContext( pIrpContext );
    }

    if (pIrp != NULL)
    {
        UlFreeIrp( pIrp );
    }

    status = UlInvokeCompletionRoutine(
                    STATUS_INSUFFICIENT_RESOURCES,
                    0,
                    pCompletionRoutine,
                    pCompletionContext
                    );

    return status;

}   // UlpReceiveRawData

/***************************************************************************++

Routine Description:

    A Dummy handler that is called by the filter code. This just calls
    back into UlHttpReceive.

Arguments:

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpDummyReceiveHandler(
    IN PVOID pTdiEventContext,
    IN PVOID ConnectionContext,
    IN PVOID pTsdu,
    IN ULONG BytesIndicated,
    IN ULONG BytesUnreceived,
    OUT ULONG *pBytesTaken
    )
{
    PUL_ENDPOINT        pEndpoint;
    PUL_CONNECTION      pConnection;

    //
    // Sanity check.
    //

    ASSERT(pTdiEventContext == NULL);
    ASSERT(BytesUnreceived == 0);

    pConnection = (PUL_CONNECTION)ConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    return (pEndpoint->pDataReceiveHandler)(
                   pEndpoint->pListeningContext,
                   pConnection->pConnectionContext,
                   pTsdu,
                   BytesIndicated,
                   BytesUnreceived,
                   pBytesTaken
                   );
} // UlpDummyReceiveHandler


/***************************************************************************++

Routine Description:

    Handler for normal receive data.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUL_CONNECTION.

    ReceiveFlags - Supplies the receive flags. This will be zero or more
        TDI_RECEIVE_* flags.

    BytesIndicated - Supplies the number of bytes indicated in pTsdu.

    BytesAvailable - Supplies the number of bytes available in this
        TSDU.

    pBytesTaken - Receives the number of bytes consumed by this handler.

    pTsdu - Supplies a pointer to the indicated data.

    pIrp - Receives an IRP if the handler needs more data than indicated.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpReceiveHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    )
{
    NTSTATUS            status;
    PUL_ENDPOINT        pEndpoint;
    PUL_CONNECTION      pConnection;
    PUX_TDI_OBJECT      pTdiObject;
    UL_CONNECTION_FLAGS ConnectionFlags;


    UL_ENTER_DRIVER("UlpReceiveHandler", NULL);

    //
    // Sanity check.
    //

    pEndpoint = (PUL_ENDPOINT)pTdiEventContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    pConnection = (PUL_CONNECTION)ConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->pOwningEndpoint == pEndpoint );

    pTdiObject = &pConnection->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    UlTrace(TDI, (
        "UlpReceiveHandler: endpoint %p, connection %p, length %lu,%lu\n",
        pTdiEventContext,
        (PVOID)ConnectionContext,
        BytesIndicated,
        BytesAvailable
        ));

    //
    // Clear the bytes taken output var
    //

    *pBytesTaken = 0;

    //
    // Wait for the local address to be set just in case the receive happens
    // before accept.  This is possible (but rare) on MP machines even when
    // using TDI_ACCEPT.  We set the ReceivePending flag and reject
    // the data if this ever happens.  When accept is completed, we will build
    // a receive IRP to flush the data if ReceivePending is set.
    //

    ConnectionFlags.Value = *((volatile LONG *)&pConnection->ConnectionFlags.Value);

    if (0 == ConnectionFlags.LocalAddressValid)
    {
        pConnection->ConnectionFlags.ReceivePending = 1;
        status = STATUS_DATA_NOT_ACCEPTED;
        goto end;
    }

    //
    // Give the client a crack at the data.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // Needs to go through a filter.
        //

        status = UlFilterReceiveHandler(
                        &pConnection->FilterInfo,
                        pTsdu,
                        BytesIndicated,
                        BytesAvailable - BytesIndicated,
                        pBytesTaken
                        );
    }
    else
    {
        //
        // Go directly to client.
        //

        status = (pEndpoint->pDataReceiveHandler)(
                        pEndpoint->pListeningContext,
                        pConnection->pConnectionContext,
                        pTsdu,
                        BytesIndicated,
                        BytesAvailable - BytesIndicated,
                        pBytesTaken
                        );
    }

    ASSERT( *pBytesTaken <= BytesIndicated );

    if (status == STATUS_SUCCESS)
    {
        goto end;
    }
    else if (status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        ASSERT(!"How could this ever happen?");

        //
        // The client consumed part of the indicated data.
        //
        // A subsequent receive indication will be made to the client when
        // additional data is available. This subsequent indication will
        // include the unconsumed data from the current indication plus
        // any additional data received.
        //
        // We need to allocate a receive buffer so we can pass an IRP back
        // to the transport.
        //

        status = UlpBuildTdiReceiveBuffer(pTdiObject, pConnection, pIrp);

        if (status == STATUS_MORE_PROCESSING_REQUIRED)
        {
            //
            // Make the next stack location current. Normally, UlCallDriver
            // would do this for us, but since we're bypassing UlCallDriver,
            // we must do it ourselves.
            //

            IoSetNextIrpStackLocation( *pIrp );
            goto end;
        }
    }

    //
    // If we made it this far, then we've hit a fatal condition. Either the
    // client returned a status code other than STATUS_SUCCESS or
    // STATUS_MORE_PROCESSING_REQUIRED, or we failed to allocation the
    // receive IRP to pass back to the transport. In either case, we need
    // to abort the connection.
    //

    UlpCloseRawConnection(
         pConnection,
         TRUE,          // AbortiveDisconnect
         NULL,          // pCompletionRoutine
         NULL           // pCompletionContext
         );

end:

    UlTrace(TDI, (
        "UlpReceiveHandler: endpoint %p, connection %p, length %lu,%lu, taken %lu, status %x\n",
        pTdiEventContext,
        (PVOID)ConnectionContext,
        BytesIndicated,
        BytesAvailable,
        *pBytesTaken,
        status
        ));

    UL_LEAVE_DRIVER("UlpReceiveHandler");
    return status;

}   // UlpReceiveHandler


/***************************************************************************++

Routine Description:

    Handler for expedited receive data.

Arguments:

    pTdiEventContext - Supplies the context associated with the address
        object. This should be a PUL_ENDPOINT.

    ConnectionContext - Supplies the context associated with the
        connection object. This should be a PUL_CONNECTION.

    ReceiveFlags - Supplies the receive flags. This will be zero or more
        TDI_RECEIVE_* flags.

    BytesIndiated - Supplies the number of bytes indicated in pTsdu.

    BytesAvailable - Supplies the number of bytes available in this
        TSDU.

    pBytesTaken - Receives the number of bytes consumed by this handler.

    pTsdu - Supplies a pointer to the indicated data.

    pIrp - Receives an IRP if the handler needs more data than indicated.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpReceiveExpeditedHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    )
{
    PUL_ENDPOINT pEndpoint;
    PUL_CONNECTION pConnection;
    PUX_TDI_OBJECT pTdiObject;


    UL_ENTER_DRIVER("UlpReceiveExpeditedHandler", NULL);

    //
    // Sanity check.
    //

    pEndpoint = (PUL_ENDPOINT)pTdiEventContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    pConnection = (PUL_CONNECTION)ConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->pOwningEndpoint == pEndpoint );

    pTdiObject = &pConnection->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    UlTrace(TDI, (
        "UlpReceiveExpeditedHandler: endpoint %p, connection %p, length %lu,%lu\n",
        pTdiEventContext,
        (PVOID)ConnectionContext,
        BytesIndicated,
        BytesAvailable
        ));

    //
    // We don't support expedited data, so just consume it all.
    //

    *pBytesTaken = BytesAvailable;

    UL_LEAVE_DRIVER("UlpReceiveExpeditedHandler");

    return STATUS_SUCCESS;

}   // UlpReceiveExpeditedHandler


/***************************************************************************++

Routine Description:

    Completion handler for accept IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_CONNECTION.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_CONNECTION                  pConnection;
    PUL_ENDPOINT                    pEndpoint;
    BOOLEAN                         needDisconnect;
    NTSTATUS                        queryStatus;
    NTSTATUS                        irpStatus;
    UL_CONNECTION_FLAGS             newFlags;
    PTA_IP_ADDRESS                  pIpAddress;

    //
    // Sanity check.
    //

    pConnection = (PUL_CONNECTION)pContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->ConnectionFlags.AcceptPending );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    UlTrace(TDI, (
        "UlpRestartAccept: irp %p, endpoint %p, connection %p, status %08lx\n",
        pIrp,
        pEndpoint,
        pConnection,
        pIrp->IoStatus.Status
        ));

    //
    // Assume for now that we don't need to issue a disconnect.
    //

    needDisconnect = FALSE;

    //
    // Capture the status from the IRP then free it.
    //

    irpStatus = pIrp->IoStatus.Status;

    //
    // If the connection was fully accepted (successfully), then
    // move it to the endpoint's active list.
    //

    if (NT_SUCCESS(irpStatus))
    {
        UlpEnqueueActiveConnection( pConnection );

        //
        // Get the Local Address Info
        //

        pIpAddress = &(pConnection->IpAddress);

        if (TDI_ADDRESS_TYPE_IP == pIpAddress->Address[0].AddressType)
        {
            if (pIpAddress->Address[0].AddressLength >= TDI_ADDRESS_LENGTH_IP)
            {
                pConnection->LocalAddress = SWAP_LONG(pIpAddress->Address[0].Address[0].in_addr);
                pConnection->LocalPort    = SWAP_SHORT(pIpAddress->Address[0].Address[0].sin_port);

                pConnection->ConnectionFlags.LocalAddressValid = TRUE;
            }
        }
        else
        {
            // Sabama: Add support for IP6 here
        }

        //
        // Set the AcceptComplete flag. If an abort or disconnect has
        // already been indicated, then remember this fact so we can
        // fake a call to the client's connection disconnect handler
        // after we invoke the connection complete handler.
        //

        newFlags.Value =
            *((volatile LONG *)&pConnection->ConnectionFlags.Value);

        if (newFlags.AbortIndicated || newFlags.DisconnectIndicated)
        {
            needDisconnect = TRUE;
        }

        if (needDisconnect == FALSE && newFlags.ReceivePending)
        {
            PIRP pReceiveIrp;
            NTSTATUS status;

            //
            // We may have pending receives that we rejected early on
            // inside the receive handler.  Build an IRP to flush the
            // data now.
            //

            status = UlpBuildTdiReceiveBuffer(
                        &pConnection->ConnectionObject,
                        pConnection,
                        &pReceiveIrp
                        );

            if (status != STATUS_MORE_PROCESSING_REQUIRED)
            {
                needDisconnect = TRUE;
            }
            else
            {
                UlCallDriver(
                    pConnection->ConnectionObject.pDeviceObject,
                    pReceiveIrp
                    );
            }
        }
    }

    //
    // Tell the client that the connection is complete. If necessary, also
    // tell them that the connection has been disconnected.
    //

    (pEndpoint->pConnectionCompleteHandler)(
        pEndpoint->pListeningContext,
        pConnection->pConnectionContext,
        irpStatus
        );

    if (needDisconnect)
    {
        //
        // Silently close the connection. No need to go httprcv
        // disconnect handler. It's just going to callback us anyway.
        //

        UlpCloseRawConnection( pConnection,
                               FALSE,
                               NULL,
                               NULL
                               );
    }

    //
    // If the accept failed, then mark the connection so we know there is
    // no longer an accept pending, enqueue the connection back onto the
    // endpoint's idle list, and then remove the endpoint reference added
    // in the connect handler,
    //

    if (!NT_SUCCESS(irpStatus))
    {
        pConnection->ConnectionFlags.AcceptPending = FALSE;

        //
        // Need to get rid of our opaque id if we're a filtered connection.
        //

        UL_CALL_PASSIVE(
            &pConnection->WorkItem,
            &UlpCleanupEarlyConnection
            );
    }
    else
    {
        //
        // Mark we are done with the accept. And try to disconnect
        // if necessary.
        //

        newFlags = UlpSetConnectionFlag(
                        pConnection,
                        MakeAcceptCompleteFlag()
                        );

        if (needDisconnect)
        {
            //
            // We now may be able to remove the final reference since
            // we have now set the AcceptComplete flag.
            //

            UlpRemoveFinalReference(pConnection, newFlags);
        }

        //
        // Drop the reference added in UlpConnectHandler.
        //

        DEREFERENCE_CONNECTION( pConnection );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartAccept


/***************************************************************************++

Routine Description:

    Completion handler for send IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartSendData(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PIO_STACK_LOCATION pIrpSp;
    PUL_CONNECTION pConnection;
    PUL_IRP_CONTEXT pIrpContext;
    BOOLEAN OwnIrpContext;

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT)pContext;
    OwnIrpContext = (pIrpContext->pOwnIrp != NULL);
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );
    ASSERT( pIrpContext->pCompletionRoutine != NULL );

    pConnection = (PUL_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( IS_VALID_ENDPOINT( pConnection->pOwningEndpoint ) );

    UlTrace(TDI, (
        "UlpRestartSendData: irp %p, connection %p, status %08lx, info %lx\n",
        pIrp,
        pConnection,
        pIrp->IoStatus.Status,
        (ULONG)pIrp->IoStatus.Information
        ));

    WRITE_REF_TRACE_LOG(
        g_pMdlTraceLog,
        REF_ACTION_SEND_MDL_COMPLETE,
        PtrToLong(pIrp->MdlAddress->Next),  // bugbug64
        pIrp->MdlAddress,
        __FILE__,
        __LINE__
        );

#ifdef SPECIAL_MDL_FLAG
    {
        PMDL scan = pIrp->MdlAddress;

        while (scan != NULL)
        {
            ASSERT( (scan->MdlFlags & SPECIAL_MDL_FLAG) != 0 );
            scan->MdlFlags &= ~SPECIAL_MDL_FLAG;
            scan = scan->Next;
        }
    }
#endif

    //
    // Tell the client that the send is complete.
    //

    (pIrpContext->pCompletionRoutine)(
        pIrpContext->pCompletionContext,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    //
    // Remove the reference we added in UlSendData().
    //

    DEREFERENCE_CONNECTION( pConnection );

    //
    // Free the context & the IRP since we're done with them, then
    // tell IO to stop processing the IRP.
    //

    if (OwnIrpContext == FALSE)
    {
        UlFreeIrp( pIrp );
        UlPplFreeIrpContext( pIrpContext );
    }

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartSendData


/***************************************************************************++

Routine Description:

    Increments the reference count on the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint to reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlpReferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint
    OWNER_REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Reference it.
    //

    refCount = InterlockedIncrement( &pEndpoint->ReferenceCount );
    ASSERT( refCount > 0 );

    WRITE_REF_TRACE_LOG(
        g_pTdiTraceLog,
        REF_ACTION_REFERENCE_ENDPOINT,
        refCount,
        pEndpoint,
        pFileName,
        LineNumber
        );

    WRITE_OWNER_REF_TRACE_LOG(
        pEndpoint->pOwnerRefTraceLog,
        pOwner,
        ppRefOwner,
        OwnerSignature,
        Action,
        refCount,   // absolute refcount
        MonotonicId,
        +1,         // increment relative refcount
        pFileName,
        LineNumber
        );

    UlTrace(TDI, (
        "UlpReferenceEndpoint: endpoint %p, refcount %ld\n",
        pEndpoint,
        refCount
        ));

}   // UlpReferenceEndpoint


/***************************************************************************++

Routine Description:

    Decrements the reference count on the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint to dereference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlpDereferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint
    OWNER_REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    LONG refCount;
    KIRQL oldIrql;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Dereference it.
    //

    refCount = InterlockedDecrement( &pEndpoint->ReferenceCount );
    ASSERT( refCount >= 0 );

    WRITE_REF_TRACE_LOG(
        g_pTdiTraceLog,
        REF_ACTION_DEREFERENCE_ENDPOINT,
        refCount,
        pEndpoint,
        pFileName,
        LineNumber
        );

    WRITE_OWNER_REF_TRACE_LOG(
        pEndpoint->pOwnerRefTraceLog,
        pOwner,
        ppRefOwner,
        OwnerSignature,
        Action,
        refCount,   // absolute refcount
        MonotonicId,
        -1,         // decrement relative refcount
        pFileName,
        LineNumber
        );

    UlTrace(TDI, (
        "UlpDereferenceEndpoint: endpoint %p, refcount %ld\n",
        pEndpoint,
        refCount
        ));

    if (refCount == 0)
    {
        //
        // The final reference to the endpoint has been removed, so
        // it's time to destroy the endpoint. We'll remove the
        // endpoint from the global list and move it to the deleted
        // list (if necessary), release the TDI spinlock,
        // then destroy the connection.
        //

        UlAcquireSpinLock( &g_TdiSpinLock, &oldIrql );

        if (! pEndpoint->Deleted)
        {
            // If this routine was called by the `fatal' section of
            // UlCreateListeningEndpoint, then the endpoint was never
            // added to g_TdiEndpointListHead.
            if (NULL != pEndpoint->GlobalEndpointListEntry.Flink)
                RemoveEntryList( &pEndpoint->GlobalEndpointListEntry );

            InsertTailList(
                    &g_TdiDeletedEndpointListHead,
                    &pEndpoint->GlobalEndpointListEntry
                    );
            pEndpoint->Deleted = TRUE;
        }
        else
        {
            ASSERT(NULL != pEndpoint->GlobalEndpointListEntry.Flink);
        }

        UlReleaseSpinLock( &g_TdiSpinLock, oldIrql );

        //
        // The endpoint is going away. Do final cleanup & resource
        // release at passive IRQL.
        //

        UL_CALL_PASSIVE(
            &pEndpoint->WorkItem,
            &UlpEndpointCleanupWorker
            );

    }

}   // UlpDereferenceEndpoint


/***************************************************************************++

Routine Description:

    Increments the reference count on the specified connection.

Arguments:

    pConnection - Supplies the connection to reference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_ENDPOINT pEndpoint;
    LONG refCount;

    PUL_CONNECTION pConnection = (PUL_CONNECTION) pObject;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Reference it.
    //

    refCount = InterlockedIncrement( &pConnection->ReferenceCount );
    ASSERT( refCount > 1 );

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pTraceLog,
        REF_ACTION_REFERENCE_CONNECTION,
        refCount,
        pConnection,
        pFileName,
        LineNumber
        );

    UlTrace(TDI, (
        "UlReferenceConnection: connection %p, refcount %ld\n",
        pConnection,
        refCount
        ));

}   // UlReferenceConnection

/***************************************************************************++

Routine Description:

    Decrements the reference count on the specified connection.

Arguments:

    pConnection - Supplies the connection to dereference.

    pFileName (REFERENCE_DEBUG only) - Supplies the name of the file
        containing the calling function.

    LineNumber (REFERENCE_DEBUG only) - Supplies the line number of
        the calling function.

--***************************************************************************/
VOID
UlDereferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    )
{
    PUL_ENDPOINT pEndpoint;
    LONG refCount;
    PUL_CONNECTION pConnection = (PUL_CONNECTION) pObject;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Dereference it.
    //

    refCount = InterlockedDecrement( &pConnection->ReferenceCount );
    ASSERT( refCount >= 0 );

    WRITE_REF_TRACE_LOG2(
        g_pTdiTraceLog,
        pConnection->pTraceLog,
        REF_ACTION_DEREFERENCE_CONNECTION,
        refCount,
        pConnection,
        pFileName,
        LineNumber
        );

    UlTrace(TDI, (
        "UlDereferenceConnection: connection %p, refcount %ld\n",
        pConnection,
        refCount
        ));

    if (refCount == 0)
    {
        //
        // The final reference to the connection has been removed, so
        // it's time to destroy the connection. We'll release the
        // endpoint spinlock, dereference the endpoint, then destroy
        // the connection.
        //

        ASSERT(pConnection->ActiveListEntry.Flink == NULL);

        //
        // Do final cleanup & resource release at passive IRQL. Also
        // cleanupworker requires to be running under system process.
        //

        UL_QUEUE_WORK_ITEM(
            &pConnection->WorkItem,
            &UlpConnectionCleanupWorker
            );
    }

}   // UlDereferenceConnection


/***************************************************************************++

Routine Description:

    Deferred cleanup routine for dead endpoints.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_ENDPOINT.

--***************************************************************************/
VOID
UlpEndpointCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_ENDPOINT pEndpoint;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pEndpoint = CONTAINING_RECORD(
                    pWorkItem,
                    UL_ENDPOINT,
                    WorkItem
                    );

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Nuke it.
    //

    UlpDestroyEndpoint( pEndpoint );

}   // UlpEndpointCleanupWorker


/***************************************************************************++

Routine Description:

    Removes the opaque id from a connection. This has to happen at passive
    level because the opaque id table can't handle high IRQL.

Arguments:

    pWorkItem - embedded in the connection object.

--***************************************************************************/
VOID
UlpCleanupConnectionId(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    KIRQL oldIrql;
    PUL_CONNECTION pConnection;
    HTTP_RAW_CONNECTION_ID ConnectionId;

    //
    // Sanity check.
    //
    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Grab the connection.
    //
    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_CONNECTION,
                        WorkItem
                        );

    ASSERT( IS_VALID_CONNECTION(pConnection) );

    //
    // Pull the id off the connection.
    //
    UlAcquireSpinLock( &pConnection->FilterInfo.FilterConnLock, &oldIrql );

    ConnectionId = pConnection->FilterInfo.ConnectionId;
    HTTP_SET_NULL_ID( &pConnection->FilterInfo.ConnectionId );

    UlReleaseSpinLock( &pConnection->FilterInfo.FilterConnLock, oldIrql );

    //
    // Actually get rid of it at low IRQL.
    //
    if (!HTTP_IS_NULL_ID( &ConnectionId ))
    {
        UlTrace(TDI, (
            "UlpCleanupConnectionId: conn=%p id=%I64x\n",
            pConnection, ConnectionId
            ));

        UlFreeOpaqueId(ConnectionId, UlOpaqueIdTypeRawConnection);
        DEREFERENCE_CONNECTION(pConnection);
    }

} // UlpCleanupConnectionId

/***************************************************************************++

Routine Description:

    This function gets called if RestartAccept fails and we cannot establish
    a connection on a secure endpoint, or if something goes wrong in
    UlpConnectHandler.

    The connections over secure endpoints keep an extra refcount to
    the UL_CONNECTION because of their opaqueid. They normally
    get removed after the CloseRawConnection happens but in the above case
    close won't happen and we have to explicitly cleanup the id. This has
    to happen at passive level because the opaque id table can't handle high
    IRQL.

Arguments:

    pWorkItem - embedded in the connection object.

--***************************************************************************/
VOID
UlpCleanupEarlyConnection(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CONNECTION      pConnection;
    UL_CONNECTION_FLAGS Flags;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Grab the connection.
    //

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_CONNECTION,
                        WorkItem
                        );

    ASSERT( IS_VALID_CONNECTION(pConnection) );

    //
    // If we are failing early we should never have been to
    // FinalReferenceRemoved in the first place.
    //

    Flags.Value =  *((volatile LONG *)&pConnection->ConnectionFlags.Value);

    ASSERT( !Flags.FinalReferenceRemoved );

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // Cleanup opaque id. And release the final refcount
        //

        UlpCleanupConnectionId( pWorkItem );
    }

    //
    // Drop the reference added in UlpConnectHandler.
    //

    DEREFERENCE_CONNECTION( pConnection );

    //
    // Remove the final reference.
    //

    DEREFERENCE_CONNECTION( pConnection );

} // UlpCleanupEarlyConnection


/***************************************************************************++

Routine Description:

    Deferred cleanup routine for dead connections. We have to be queued as a
    work item and should be running on the passive IRQL. See below comment.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_CONNECTION.

--***************************************************************************/
VOID
UlpConnectionCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    NTSTATUS status;

    //
    // Sanity check.
    //

    PAGED_CODE();

    //
    // Initialize locals.
    //

    status = STATUS_SUCCESS;

    pConnection = CONTAINING_RECORD(
                        pWorkItem,
                        UL_CONNECTION,
                        WorkItem
                        );

    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( IS_VALID_ENDPOINT( pConnection->pOwningEndpoint ) );

    ASSERT( pConnection->ReferenceCount == 0 );
    ASSERT( pConnection->HttpConnection.RefCount == 0 );

    //
    // Grab the endpoint.
    //
    pEndpoint = pConnection->pOwningEndpoint;

    //
    // Get rid of any buffers we allocated for
    // certificate information.
    //
    if (pConnection->FilterInfo.SslInfo.pServerCertData)
    {
        UL_FREE_POOL(
            pConnection->FilterInfo.SslInfo.pServerCertData,
            UL_SSL_CERT_DATA_POOL_TAG
            );

        pConnection->FilterInfo.SslInfo.pServerCertData = NULL;
    }

    if (pConnection->FilterInfo.SslInfo.pCertEncoded)
    {
        UL_FREE_POOL(
            pConnection->FilterInfo.SslInfo.pCertEncoded,
            UL_SSL_CERT_DATA_POOL_TAG
            );

        pConnection->FilterInfo.SslInfo.pCertEncoded = NULL;
    }

    if (pConnection->FilterInfo.SslInfo.Token)
    {
        HANDLE Token;

        Token = (HANDLE) pConnection->FilterInfo.SslInfo.Token;

        //
        // If we are not running under the system process. And if the
        // thread we are running under has some APCs queued currently
        // KeAttachProcess won't allow us to attach to another process
        // and will bugcheck 5. We have to be queued as a work item and
        // should be running on the passive IRQL.
        //

        ASSERT( PsGetCurrentProcess() == (PEPROCESS) g_pUlSystemProcess );

        ZwClose(Token);
    }

    //
    // Release the filter channel.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        DEREFERENCE_FILTER_CHANNEL(pConnection->FilterInfo.pFilterChannel);
        pConnection->FilterInfo.pFilterChannel = NULL;
    }

    //
    // Check if g_UlEnableConnectionReuse is enabled or we are about to
    // exceed g_UlMaxIdleConnections.
    //

    if (ExQueryDepthSList(&pEndpoint->IdleConnectionSListHead) >=
        g_UlMaxIdleConnections)
    {
        status = STATUS_ALLOTTED_SPACE_EXCEEDED;
    }

    if (g_UlEnableConnectionReuse == FALSE)
    {
        status = STATUS_NOT_SUPPORTED;
    }

    //
    // If the connection is still ok and we're reusing
    // connection objects, throw it back on the idle list.
    //

    if (NT_SUCCESS(status))
    {
        //
        // Initialize the connection for reuse.
        //

        status = UlpInitializeConnection(pConnection);

        if (NT_SUCCESS(status))
        {
            //
            // Stick the connection back on the idle list.
            //

            UlpEnqueueIdleConnection(pConnection, FALSE);
        }
    }

    //
    // Active connections hold a reference to the ENDPOINT. Release
    // that reference. See the comment on UlpCreateConnection.
    //
    DEREFERENCE_ENDPOINT_CONNECTION(
        pEndpoint,
        REF_ACTION_CONN_CLEANUP,
        pConnection);

    //
    // If anything went amiss, blow away the connection.
    //

    if (!NT_SUCCESS(status))
    {
        UlpDestroyConnection( pConnection );
    }

}   // UlpConnectionCleanupWorker


/***************************************************************************++

Routine Description:

    Associates the TDI connection object contained in the specified
    connection to the TDI address object contained in the specified
    endpoint.

Arguments:

    pConnection - Supplies the connection to associate with the endpoint.

    pEndpoint - Supplies the endpoint to associated with the connection.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpAssociateConnection(
    IN PUL_CONNECTION pConnection,
    IN PUL_ENDPOINT pEndpoint
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE handle;
    TDI_REQUEST_USER_ASSOCIATE associateInfo;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    ASSERT( pConnection->pOwningEndpoint == NULL );

    //
    // Associate the connection with the address object.
    //

    associateInfo.AddressHandle = pEndpoint->AddressObject.Handle;
    ASSERT( associateInfo.AddressHandle != NULL );

    handle = pConnection->ConnectionObject.Handle;
    ASSERT( handle != NULL );

    UlAttachToSystemProcess();

    status = ZwDeviceIoControlFile(
                    handle,                         // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &ioStatusBlock,                 // IoStatusBlock
                    IOCTL_TDI_ASSOCIATE_ADDRESS,    // IoControlCode
                    &associateInfo,                 // InputBuffer
                    sizeof(associateInfo),          // InputBufferLength
                    NULL,                           // OutputBuffer
                    0                               // OutputBufferLength
                    );

    if (status == STATUS_PENDING)
    {
        status = ZwWaitForSingleObject(
                        handle,                     // Handle
                        TRUE,                       // Alertable
                        NULL                        // Timeout
                        );

        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    UlDetachFromSystemProcess();

    if (NT_SUCCESS(status))
    {
        pConnection->pOwningEndpoint = pEndpoint;
        pConnection->pConnectionDestroyedHandler = pEndpoint->pConnectionDestroyedHandler;
        pConnection->pListeningContext = pEndpoint->pListeningContext;
    }
    else
    {
        UlTrace(TDI, (
            "UlpAssociateConnection conn=%p, endp=%p, status = %08lx\n",
            pConnection,
            pEndpoint,
            status
            ));
    }

    return status;

}   // UlpAssociateConnection


/***************************************************************************++

Routine Description:

    Disassociates the TDI connection object contained in the specified
    connection from its TDI address object.

Arguments:

    pConnection - Supplies the connection to disassociate.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpDisassociateConnection(
    IN PUL_CONNECTION pConnection
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    HANDLE handle;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( IS_VALID_ENDPOINT( pConnection->pOwningEndpoint ) );

    //
    // Disassociate the connection from the address object.
    //

    handle = pConnection->ConnectionObject.Handle;

    UlAttachToSystemProcess();

    status = ZwDeviceIoControlFile(
                    handle,                         // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &ioStatusBlock,                 // IoStatusBlock
                    IOCTL_TDI_DISASSOCIATE_ADDRESS, // IoControlCode
                    NULL,                           // InputBuffer
                    0,                              // InputBufferLength
                    NULL,                           // OutputBuffer
                    0                               // OutputBufferLength
                    );

    if (status == STATUS_PENDING)
    {
        status = ZwWaitForSingleObject(
                        handle,                     // Handle
                        TRUE,                       // Alertable
                        NULL                        // Timeout
                        );

        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    UlDetachFromSystemProcess();

    //
    // Proceed with the disassociate even if the IOCTL failed.
    //

    pConnection->pOwningEndpoint = NULL;

    return status;

}   // UlpDisassociateConnection


/***************************************************************************++

Routine Description:

    Replenishes the idle connection pool in the specified endpoint.

Arguments:

    pEndpoint - Supplies the endpoint to replenish.

--***************************************************************************/
VOID
UlpReplenishEndpoint(
    IN PUL_ENDPOINT pEndpoint
    )
{
    NTSTATUS status;
    PUL_CONNECTION pConnection;
    BOOLEAN ContinueReplenish;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    UlTrace(TDI, (
        "UlpReplenishEndpoint: endpoint %p\n",
        pEndpoint
        ));

    TRACE_REPLENISH(
        pEndpoint,
        DummySynch,
        pEndpoint->EndpointSynch,
        REPLENISH_ACTION_START_REPLENISH
        );

    //
    // Loop, creating connections until we're fully replenished.
    //

    do
    {
        //
        // Create a new connection.
        //

        status = UlpCreateConnection(
                    pEndpoint,                      // pEndpoint
                    pEndpoint->LocalAddressLength,  // AddressLength
                    &pConnection                    // ppConnection
                    );

        if (!NT_SUCCESS(status))
        {
            break;
        }

        status = UlpInitializeConnection(
                        pConnection
                        );


        if (!NT_SUCCESS(status))
        {
            UlpDestroyConnection(pConnection);
            break;
        }

        //
        // Enqueue the connection onto the endpoint.
        //

        ContinueReplenish = UlpEnqueueIdleConnection( pConnection, TRUE );

    } while (ContinueReplenish);

    TRACE_REPLENISH(
        pEndpoint,
        DummySynch,
        pEndpoint->EndpointSynch,
        REPLENISH_ACTION_END_REPLENISH
        );

    //
    // We are done with creating new connections for now. Clear
    // the "replenish scheduled" flag so future replenish attempts
    // will queue the work.
    //


    UlpClearReplenishScheduledFlag( pEndpoint );

}   // UlpReplenishEndpoint


/***************************************************************************++

Routine Description:

    Deferred endpoint replenish routine.

Arguments:

    pWorkItem - Supplies a pointer to the work item queued. This should
        point to the WORK_ITEM structure embedded in a UL_ENDPOINT.

--***************************************************************************/
VOID
UlpReplenishEndpointWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PUL_ENDPOINT pEndpoint;

    //
    // Sanity check.
    //

    PAGED_CODE();

    pEndpoint = CONTAINING_RECORD(
                    pWorkItem,
                    UL_ENDPOINT,
                    WorkItem
                    );

    UlTrace(TDI, (
        "UlpReplenishEndpointWorker: endpoint %p\n",
        pEndpoint
        ));

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // Let UlpReplenishEndpoint() do the dirty work.
    //

    UlpReplenishEndpoint( pEndpoint );

    //
    // Remove the reference that UlpDequeueIdleConnection added for
    // this call.
    //

    DEREFERENCE_ENDPOINT_SELF(pEndpoint, REF_ACTION_REPLENISH);

}   // UlpReplenishEndpointWorker


/***************************************************************************++

Routine Description:

    Decrements the number of idle connections availabe on the specified
    endpoint and determines if a replenish should be scheduled.

Arguments:

    pEndpoint - Supplies the endpoint to increment.

Return Value:

    BOOLEAN - TRUE if a replenish should be rescheduled, FALSE otherwise.

--***************************************************************************/
BOOLEAN
UlpDecrementIdleConnections(
    IN PUL_ENDPOINT pEndpoint
    )
{
    ENDPOINT_SYNCH oldState;
    ENDPOINT_SYNCH newState;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    do
    {
        //
        // Capture the current count and initialize the proposed
        // new value.
        //

        newState.Value = oldState.Value =
            *((volatile LONG *)&pEndpoint->EndpointSynch.Value);

        newState.IdleConnections--;
        ASSERT( newState.IdleConnections >= 0 );

        if (newState.IdleConnections < g_UlMinIdleConnections)
        {
            newState.ReplenishScheduled = TRUE;
        }

        if (UlInterlockedCompareExchange(
                &pEndpoint->EndpointSynch.Value,
                newState.Value,
                oldState.Value
                ) == oldState.Value)
        {
            break;
        }

    } while (TRUE);

    UlTrace(TDI, (
        "ul!UlpDecrementIdleConnections(pEndpoint = %p)\n"
        "    idle = %d, replenish = %s, returning %s\n",
        pEndpoint,
        newState.IdleConnections,
        newState.ReplenishScheduled ? "TRUE" : "FALSE",
        (newState.ReplenishScheduled && !oldState.ReplenishScheduled) ? "TRUE" : "FALSE"
        ));

    TRACE_REPLENISH(
        pEndpoint,
        oldState,
        newState,
        REPLENISH_ACTION_DECREMENT
        );

    //
    // If the "ReplenishScheduled" flag transitioned from FALSE to TRUE,
    // then we need to schedule a replenish.
    //

    return (newState.ReplenishScheduled && !oldState.ReplenishScheduled);

}   // UlpDecrementIdleConnections


/***************************************************************************++

Routine Description:

    Increments the number of idle connections available on the specified
    endpoint.

Arguments:

    pEndpoint - Supplies the endpoint to decrement.
    Replenishing - TRUE if the connection was added as part of
        a replenish operation.

Return Value:

    BOOLEAN - TRUE if the count has not reached the minimum number
        of idle connections for the endpoint.

--***************************************************************************/
BOOLEAN
UlpIncrementIdleConnections(
    IN PUL_ENDPOINT pEndpoint,
    IN BOOLEAN Replenishing
    )
{
    ENDPOINT_SYNCH oldState;
    ENDPOINT_SYNCH newState;
    BOOLEAN ContinueReplenish;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    ContinueReplenish = TRUE;

    do
    {
        //
        // Capture the current count and initialize the proposed
        // new value.
        //

        newState.Value = oldState.Value =
            *((volatile LONG *)&pEndpoint->EndpointSynch.Value);

        newState.IdleConnections++;
        ASSERT( newState.IdleConnections >= 0 );

        if (newState.IdleConnections >= g_UlMinIdleConnections)
        {
            ContinueReplenish = FALSE;
        }

        if (UlInterlockedCompareExchange(
                &pEndpoint->EndpointSynch.Value,
                newState.Value,
                oldState.Value
                ) == oldState.Value)
        {
            break;
        }

    } while (TRUE);

    UlTrace(TDI, (
        "ul!UlpIncrementIdleConnections(pEndpoint = %p)\n"
        "    idle = %d, replenish = %s\n",
        pEndpoint,
        newState.IdleConnections,
        newState.ReplenishScheduled ? "TRUE" : "FALSE"
        ));

    TRACE_REPLENISH(
        pEndpoint,
        oldState,
        newState,
        REPLENISH_ACTION_INCREMENT
        );

    //
    // If we still don't have enough connections we must
    // continue the replenish.
    //

    return ContinueReplenish;

}   // UlpIncrementIdleConnections


/***************************************************************************++

Routine Description:

    Clears the "replenish scheduled" flag on the endpoint. This is only
    called after a replenish failure. The flag is cleared so that future
    attempts to replenish will schedule properly.

Arguments:

    pEndpoint - Supplies the endpoint to manipulate.

Return Value:

    None.

--***************************************************************************/
VOID
UlpClearReplenishScheduledFlag(
    IN PUL_ENDPOINT pEndpoint
    )
{
    ENDPOINT_SYNCH oldState;
    ENDPOINT_SYNCH newState;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    do
    {
        //
        // Capture the current count and initialize the proposed
        // new value.
        //

        newState.Value = oldState.Value =
            *((volatile LONG *)&pEndpoint->EndpointSynch.Value);

        newState.ReplenishScheduled = FALSE;

        if (UlInterlockedCompareExchange(
                &pEndpoint->EndpointSynch.Value,
                newState.Value,
                oldState.Value
                ) == oldState.Value)
        {
            break;
        }

    } while (TRUE);

}   // UlpClearReplenishScheduledFlag


/***************************************************************************++

Routine Description:

    Creates a new UL_CONNECTION object and opens the corresponding
    TDI connection object.

    Note: The connection returned from this function will contain
    an unreferenced pointer to the owning endpoint. Only active
    connections have references to the endpoint because the refcount
    is used to decide when to clean up the list of idle connections.

Arguments:

    AddressLength - Supplies the length of the TDI addresses used
        by the transport associated with this connection.

    ppConnection - Receives the pointer to a new UL_CONNECTION if
        successful.

Return Value:

    NTSTATUS - Completion status. *ppConnection is undefined if the
        return value is not STATUS_SUCCESS.

--***************************************************************************/
NTSTATUS
UlpCreateConnection(
    IN PUL_ENDPOINT pEndpoint,
    IN ULONG AddressLength,
    OUT PUL_CONNECTION *ppConnection
    )
{
    NTSTATUS                        status;
    PUL_CONNECTION                  pConnection;
    PSINGLE_LIST_ENTRY              pSListEntry;
    BOOLEAN                         FilterOnlySsl;
    PUX_TDI_OBJECT                  pTdiObject;

    ASSERT(NULL != ppConnection);

    //
    // Allocate the pool for the connection structure.
    //

    pConnection = UL_ALLOCATE_STRUCT(
                        NonPagedPool,
                        UL_CONNECTION,
                        UL_CONNECTION_POOL_TAG
                        );

    if (pConnection == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    //
    // One time field initialization.
    //

    pConnection->Signature = UL_CONNECTION_SIGNATURE;

    ExInterlockedInsertTailList(
        &g_TdiConnectionListHead,
        &pConnection->GlobalConnectionListEntry,
        KSPIN_LOCK_FROM_UL_SPIN_LOCK(&g_TdiSpinLock)
        );
    InterlockedIncrement((PLONG) &g_TdiConnectionCount);

    pConnection->pConnectionContext = NULL;
    pConnection->pOwningEndpoint = NULL;
#if ENABLE_OWNER_REF_TRACE
    pConnection->pConnRefOwner = NULL;
    pConnection->MonotonicId = 0;
#endif // ENABLE_OWNER_REF_TRACE
    pConnection->FilterInfo.pFilterChannel = NULL;
    HTTP_SET_NULL_ID( &pConnection->FilterInfo.ConnectionId );
    pConnection->pIrp = NULL;
    pConnection->ActiveListEntry.Flink = NULL;
    pConnection->IdleSListEntry.Next = NULL;

    //
    // Initialize a private trace log.
    //

    CREATE_REF_TRACE_LOG( pConnection->pTraceLog,
                          96 - REF_TRACE_OVERHEAD, 0 );
    CREATE_REF_TRACE_LOG( pConnection->HttpConnection.pTraceLog,
                          32 - REF_TRACE_OVERHEAD, 0 );

    //
    // Open the TDI connection object for this connection.
    //

    status = UxOpenTdiConnectionObject(
                    (CONNECTION_CONTEXT)pConnection,
                    &pConnection->ConnectionObject
                    );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    ASSERT( IS_VALID_TDI_OBJECT( &pConnection->ConnectionObject ) );

    //
    // Associate the connection with the endpoint.
    //

    status = UlpAssociateConnection( pConnection, pEndpoint );

    if (!NT_SUCCESS(status))
    {
        goto fatal;
    }

    pTdiObject = &pConnection->ConnectionObject;

    pConnection->pIrp = UlAllocateIrp(
                pTdiObject->pDeviceObject->StackSize,   // StackSize
                FALSE                                   // ChargeQuota
                );

    if (pConnection->pIrp == NULL)
    {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto fatal;
    }

    pConnection->pIrp->RequestorMode = KernelMode;

    //
    // Success!
    //

    UlTrace(TDI, (
        "UlpCreateConnecton: created %p\n",
        pConnection
        ));

    *ppConnection = pConnection;
    return STATUS_SUCCESS;

fatal:

    UlTrace(TDI, (
        "UlpCreateConnecton: failure %08lx\n",
        status
        ));

    ASSERT( !NT_SUCCESS(status) );

    if (pConnection != NULL)
    {
        UlpDestroyConnection( pConnection );
    }

    *ppConnection = NULL;
    return status;

}   // UlpCreateConnection


/***************************************************************************++

Routine Description:

    Initializes a UL_CONNECTION for use.
    Note: inactive connections do not have a reference to the endpoint,
    so the caller to this function *must* have a reference.

Arguments:

    pConnection - Pointer to the UL_CONNECTION to initialize.

    SecureConnection - TRUE if this connection is for a secure endpoint.

--***************************************************************************/
NTSTATUS
UlpInitializeConnection(
    IN PUL_CONNECTION pConnection
    )
{
    NTSTATUS status;
    BOOLEAN SecureConnection;
    PUL_FILTER_CHANNEL pChannel;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pConnection);
    ASSERT(IS_VALID_ENDPOINT(pConnection->pOwningEndpoint));

    //
    // Initialize locals.
    //

    status = STATUS_SUCCESS;
    SecureConnection = pConnection->pOwningEndpoint->Secure;

    //
    // Initialize the easy parts.
    //

    pConnection->ReferenceCount = 1;
    pConnection->ConnectionFlags.Value = 0;
    pConnection->ActiveListEntry.Flink = NULL;

    pConnection->Terminated = FALSE;

    //
    // Setup the Tdi Connection Information space to be filled with Local Address
    // Information at the completion of the Accept Irp.
    //

    pConnection->TdiConnectionInformation.UserDataLength      = 0;
    pConnection->TdiConnectionInformation.UserData            = NULL;
    pConnection->TdiConnectionInformation.OptionsLength       = 0;
    pConnection->TdiConnectionInformation.Options             = NULL;
    pConnection->TdiConnectionInformation.RemoteAddressLength = sizeof(TA_IP_ADDRESS);
    pConnection->TdiConnectionInformation.RemoteAddress       = &(pConnection->IpAddress);

    //
    // Init the index to the ActiveConnectionLists.
    //

    if (g_UlNumberOfProcessors == 1)
    {
        pConnection->ActiveListIndex = 0;
    }
    else
    {
        pConnection->ActiveListIndex =
            pConnection->pOwningEndpoint->ActiveConnectionIndex %
            DEFAULT_MAX_CONNECTION_ACTIVE_LISTS;
        pConnection->pOwningEndpoint->ActiveConnectionIndex += 1;
    }

    //
    // Init the IrpContext.
    //

    pConnection->IrpContext.Signature = UL_IRP_CONTEXT_SIGNATURE;

    //
    // Init the HTTP_CONNECTION.
    //

    pConnection->HttpConnection.RefCount = 0;

    pChannel = UlQueryFilterChannel(SecureConnection);

    status = UxInitializeFilterConnection(
                    &pConnection->FilterInfo,
                    pChannel,
                    SecureConnection,
                    &UlReferenceConnection,
                    &UlDereferenceConnection,
                    &UlpCloseRawConnection,
                    &UlpSendRawData,
                    &UlpReceiveRawData,
                    &UlpDummyReceiveHandler,
                    &UlpComputeHttpRawConnectionLength,
                    &UlpGenerateHttpRawConnectionInfo,
                    NULL,
                    pConnection->pOwningEndpoint,
                    pConnection
                    );

    return status;

} // UlpInitializeConnection


/***************************************************************************++

Routine Description:

    This function sets a new flag in the connection's flag set. The setting
    of the flag is synchronized such that only one flag is set at a time.

Arguments:

    pConnection - Supplies the connection whose flags are to be set.

    NewFlag - Supplies a 32-bit value to be or-ed into the current flag set.

Return Value:

    UL_CONNECTION_FLAGS - The new set of connection flags after the update.

--***************************************************************************/
UL_CONNECTION_FLAGS
UlpSetConnectionFlag(
    IN OUT PUL_CONNECTION pConnection,
    IN LONG NewFlag
    )
{
    UL_CONNECTION_FLAGS oldFlags;
    UL_CONNECTION_FLAGS newFlags;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    do
    {
        //
        // Capture the current value and initialize the new value.
        //

        newFlags.Value = oldFlags.Value =
            *((volatile LONG *)&pConnection->ConnectionFlags.Value);

        newFlags.Value |= NewFlag;

        if (UlInterlockedCompareExchange(
                &pConnection->ConnectionFlags.Value,
                newFlags.Value,
                oldFlags.Value
                ) == oldFlags.Value)
        {
            break;
        }

    } while (TRUE);

    return newFlags;

}   // UlpSetConnectionFlag


/***************************************************************************++

Routine Description:

    Initiates a graceful disconnect on the specified connection.

Arguments:

    pConnection - Supplies the connection to disconnect.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is disconnected.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

    CleaningUp - TRUE if we're cleaning up the connection.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpBeginDisconnect(
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PIRP pIrp;
    UL_CONNECTION_FLAGS newFlags;
    LONG flagsToSet;
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlpBeginDisconnect: connection %p\n",
        pConnection
        ));

    //
    // Allocate and initialize an IRP context for this request.
    //

    pIrpContext = &pConnection->IrpContext;

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;

    //
    // Allocate and initialize an IRP for the disconnect. Note that we do
    // this *before* manipulating the connection state so that we don't have
    // to back out the state changes after an IRP allocation failure.
    //

    pIrp = pConnection->pIrp;

    UxInitializeDisconnectIrp(
        pIrp,
        &pConnection->ConnectionObject,
        TDI_DISCONNECT_RELEASE,
        &UlpRestartDisconnect,
        pIrpContext
        );

    //
    // Add a reference to the connection
    //

    REFERENCE_CONNECTION( pConnection );

    //
    // Set the flag indicating that a disconnect is pending &
    // we're cleaning up.
    //

    flagsToSet = MakeDisconnectPendingFlag();
    flagsToSet |= MakeCleanupBegunFlag();

    newFlags = UlpSetConnectionFlag( pConnection, flagsToSet );

    //
    // Then call the driver to initiate
    // the disconnect.
    //

    UlCallDriver( pConnection->ConnectionObject.pDeviceObject, pIrp );

    return STATUS_PENDING;

}   // UlpBeginDisconnect


/***************************************************************************++

Routine Description:

    Completion handler for graceful disconnect IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    PUL_CONNECTION pConnection;
    UL_CONNECTION_FLAGS newFlags;
    PUL_ENDPOINT pEndpoint;

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT)pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUL_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->ConnectionFlags.DisconnectPending );

    UlTrace(TDI, (
        "UlpRestartDisconnect: connection %p\n",
        pConnection
        ));

    pEndpoint = pConnection->pOwningEndpoint;

    newFlags.Value =
         *((volatile LONG *)&pConnection->ConnectionFlags.Value);

    if (!newFlags.DisconnectIndicated &&
        !newFlags.AbortIndicated &&
         pConnection->FilterInfo.pFilterChannel == NULL
        )
    {
        // Only try to drain if its non-filter connection. Also it's not
        // necessary to drain if the connection has already been aborted.
        // CODEWORK: Filter code should also be updated to introduce the
        // same drain functionality.

        (pEndpoint->pConnectionDisconnectCompleteHandler)(
            pEndpoint->pListeningContext,
            pConnection->pConnectionContext
            );
    }

    //
    // Set the flag indicating that a disconnect has completed. If we're
    // in the midst of cleaning up this endpoint and we've already received
    // a disconnect (graceful or abortive) from the client, then remove the
    // final reference to the connection.
    //

    newFlags = UlpSetConnectionFlag(
                    pConnection,
                    MakeDisconnectCompleteFlag()
                    );

    UlpRemoveFinalReference( pConnection, newFlags );

    //
    // Invoke the user's completion routine, then free the IRP context.
    //

    if (pIrpContext->pCompletionRoutine)
    {
        (pIrpContext->pCompletionRoutine)(
            pIrpContext->pCompletionContext,
            pIrp->IoStatus.Status,
            pIrp->IoStatus.Information
            );
    }

    DEREFERENCE_CONNECTION( pConnection );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartDisconnect


/***************************************************************************++

Routine Description:

    Initiates an abortive disconnect on the specified connection.

Arguments:

    pConnection - Supplies the connection to disconnect.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the connection is disconnected.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpBeginAbort(
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    PIRP pIrp;
    UL_CONNECTION_FLAGS newFlags;
    LONG flagsToSet;
    PUL_IRP_CONTEXT pIrpContext;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlpBeginAbort: connection %p\n",
        pConnection
        ));

    //
    // Allocate and initialize an IRP context for this request.
    //

    pIrpContext = &pConnection->IrpContext;

    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pIrpContext->pConnectionContext = (PVOID)pConnection;
    pIrpContext->pCompletionRoutine = pCompletionRoutine;
    pIrpContext->pCompletionContext = pCompletionContext;

    //
    // Allocate and initialize an IRP for the disconnect. Note that we do
    // this *before* manipulating the connection state so that we don't have
    // to back out the state changes after an IRP allocation failure.
    //

    pIrp = pConnection->pIrp;

    UxInitializeDisconnectIrp(
        pIrp,
        &pConnection->ConnectionObject,
        TDI_DISCONNECT_ABORT,
        &UlpRestartAbort,
        pIrpContext
        );

    //
    // Add a reference to the connection,
    //

    REFERENCE_CONNECTION( pConnection );

    //
    // Set the flag indicating that a disconnect is pending &
    // we're cleaning up.
    //

    flagsToSet = MakeAbortPendingFlag();
    flagsToSet |= MakeCleanupBegunFlag();

    newFlags = UlpSetConnectionFlag( pConnection, flagsToSet );

    //
    // Then call the driver to initiate the disconnect.
    //

    UlCallDriver( pConnection->ConnectionObject.pDeviceObject, pIrp );

    return STATUS_PENDING;

}   // UlpBeginAbort


/***************************************************************************++

Routine Description:

    Completion handler for abortive disconnect IRPs.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartAbort(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    PUL_CONNECTION pConnection;
    UL_CONNECTION_FLAGS newFlags;

    //
    // Sanity check.
    //

    pIrpContext = (PUL_IRP_CONTEXT)pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUL_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );
    ASSERT( pConnection->ConnectionFlags.AbortPending );

    UlTrace(TDI, (
        "UlpRestartAbort: connection %p\n",
        pConnection
        ));

    //
    // Set the flag indicating that an abort has completed. If we're in the
    // midst of cleaning up this endpoint and we've already received a
    // disconnect (graceful or abortive) from the client, then remove the
    // final reference to the connection.
    //

    newFlags = UlpSetConnectionFlag(
                    pConnection,
                    MakeAbortCompleteFlag()
                    );

    UlpRemoveFinalReference( pConnection, newFlags );

    //
    // Invoke the user's completion routine, then free the IRP context.
    //

    if (pIrpContext->pCompletionRoutine)
    {
        (pIrpContext->pCompletionRoutine)(
            pIrpContext->pCompletionContext,
            pIrp->IoStatus.Status,
            pIrp->IoStatus.Information
            );
    }

    DEREFERENCE_CONNECTION( pConnection );

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartAbort


/***************************************************************************++

Routine Description:

    Removes the final reference from a connection if the conditions are
    right. See comments within this function for details on the conditions
    required.

Arguments:

    pConnection - Supplies the connection to dereference.

    Flags - Supplies the connection flags from the most recent update.

Note:

    It is very important that the caller of this routine has established
    its own reference to the connection. If necessary, this reference
    can be immediately removed after calling this routine, but not before.

--***************************************************************************/
VOID
UlpRemoveFinalReference(
    IN PUL_CONNECTION pConnection,
    IN UL_CONNECTION_FLAGS Flags
    )
{
    UL_CONNECTION_FLAGS oldFlags;
    UL_CONNECTION_FLAGS newFlags;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    //
    // We can only remove the final reference if:
    //
    //     We've begun connection cleanup.
    //
    //     We've completed an accept.
    //
    //     We've received a disconnect or abort indication or we've
    //         issued & completed an abort.
    //
    //     We don't have a disconnect or abort pending.
    //
    //     We haven't already removed it.
    //

    if (Flags.CleanupBegun &&
        Flags.AcceptComplete &&
        (Flags.DisconnectIndicated || Flags.AbortIndicated || Flags.AbortComplete) &&
        (!Flags.DisconnectPending || Flags.DisconnectComplete) &&
        (!Flags.AbortPending || Flags.AbortComplete) &&
        !Flags.FinalReferenceRemoved)
    {
        //
        // It looks like we may be able to remove the final reference.
        // Attempt to set the "FinalReferenceRemoved" flag and determine
        // if this thread is the one that actually needs to remove it.
        //

        do
        {
            //
            // Capture the current flags and initialize the proposed
            // new value.
            //

            newFlags.Value = oldFlags.Value =
                *((volatile LONG *)&pConnection->ConnectionFlags.Value);

            newFlags.Value |= MakeFinalReferenceRemovedFlag();

            if (UlInterlockedCompareExchange(
                    &pConnection->ConnectionFlags.Value,
                    newFlags.Value,
                    oldFlags.Value
                    ) == oldFlags.Value)
            {
                break;
            }

        } while (TRUE);

        //
        // See if WE actually set the flag.
        //

        if (!oldFlags.FinalReferenceRemoved)
        {
            UlTrace(TDI, (
                "UlpRemoveFinalReference: connection %p\n",
                pConnection
                ));

            //
            // Tell the client that the connection is now fully destroyed.
            //

            (pConnection->pConnectionDestroyedHandler)(
                pConnection->pListeningContext,
                pConnection->pConnectionContext
                );

            //
            // Unbind from the endpoint if we're still attached.
            // This allows it to release any refs it has on the connection.
            //
            UlpUnbindConnectionFromEndpoint(pConnection);

            //
            // Release the filter channel.
            // This allows it to release any refs it has on the connection.
            //
            if (pConnection->FilterInfo.pFilterChannel)
            {
                UlUnbindConnectionFromFilter(&pConnection->FilterInfo);
            }

            //
            // Remove the final reference.
            //

            DEREFERENCE_CONNECTION( pConnection );

            WRITE_OWNER_REF_TRACE_LOG(
                pConnection->pOwningEndpoint->pOwnerRefTraceLog,
                pConnection,
                &pConnection->pConnRefOwner,
                UL_CONNECTION_SIGNATURE,
                REF_ACTION_FINAL_DEREF,
                -1, // newrefct: ignored
                pConnection->MonotonicId,
                0,  // don't adjust local ref count
                __FILE__,
                __LINE__
                );

        }
    }
    else
    {
        UlTrace(TDI, (
            "UlpRemoveFinalReference: cannot remove %p, flags = %08lx:\n",
            pConnection,
            Flags.Value
            ));
    }

}   // UlpRemoveFinalReference


/***************************************************************************++

Routine Description:

    Completion handler for receive IRPs passed back to the transport from
    our receive indication handler.

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_RECEIVE_BUFFER.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    NTSTATUS status;
    PUL_RECEIVE_BUFFER pBuffer;
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    PUX_TDI_OBJECT pTdiObject;
    ULONG bytesAvailable;
    ULONG bytesTaken;
    ULONG bytesRemaining;

    //
    // Sanity check.
    //

    pBuffer = (PUL_RECEIVE_BUFFER) pContext;
    ASSERT( IS_VALID_RECEIVE_BUFFER( pBuffer ) );

    pConnection = (PUL_CONNECTION) pBuffer->pConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pTdiObject = &pConnection->ConnectionObject;
    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );

    //
    // The connection could be destroyed before we get a chance to
    // receive the completion for the receive IRP. In that case the
    // irp status won't be success but STATUS_CONNECTION_RESET or similar.
    // We should not attempt to pass this case to the client.
    //

    status = pBuffer->pIrp->IoStatus.Status;
    if ( status != STATUS_SUCCESS )
    {
        //
        // The HttpConnection has already been destroyed
        // or receive completion failed for some reason.
        // No need to go to client.
        //

        goto end;
    }

    //
    // Fake a receive indication to the client.
    //

    pBuffer->UnreadDataLength += (ULONG)pBuffer->pIrp->IoStatus.Information;

    bytesTaken = 0;

    UlTrace(TDI, (
        "UlpRestartReceive: endpoint %p, connection %p, length %lu\n",
        pEndpoint,
        pConnection,
        pBuffer->UnreadDataLength
        ));

    //
    // Pass the data on.
    //

    if (pConnection->FilterInfo.pFilterChannel)
    {
        //
        // Needs to go through a filter.
        //

        status = UlFilterReceiveHandler(
                        &pConnection->FilterInfo,
                        pBuffer->pDataArea,
                        pBuffer->UnreadDataLength,
                        0,
                        &bytesTaken
                        );
    }
    else
    {
        //
        // Go directly to client.
        //

        status = (pEndpoint->pDataReceiveHandler)(
                        pEndpoint->pListeningContext,
                        pConnection->pConnectionContext,
                        pBuffer->pDataArea,
                        pBuffer->UnreadDataLength,
                        0,
                        &bytesTaken
                        );
    }

    ASSERT( bytesTaken <= pBuffer->UnreadDataLength );

    //
    // Note that this basically duplicates the logic that's currently in
    // UlpReceiveHandler.
    //

    if (status == STATUS_MORE_PROCESSING_REQUIRED)
    {
        //
        // The client consumed part of the indicated data.
        //
        // We'll need to copy the untaken data forward within the receive
        // buffer, build an MDL describing the remaining part of the buffer,
        // then repost the receive IRP.
        //

        bytesRemaining = pBuffer->UnreadDataLength - bytesTaken;

        //
        // Do we have enough buffer space for more?
        //

        if (bytesRemaining < g_UlReceiveBufferSize)
        {
            //
            // Move the unread portion of the buffer to the beginning.
            //

            RtlMoveMemory(
                pBuffer->pDataArea,
                (PUCHAR)pBuffer->pDataArea + bytesTaken,
                bytesRemaining
                );

            pBuffer->UnreadDataLength = bytesRemaining;

            //
            // Build a partial mdl representing the remainder of the
            // buffer.
            //

            IoBuildPartialMdl(
                pBuffer->pMdl,                              // SourceMdl
                pBuffer->pPartialMdl,                       // TargetMdl
                (PUCHAR)pBuffer->pDataArea + bytesRemaining,// VirtualAddress
                g_UlReceiveBufferSize - bytesRemaining      // Length
                );

            //
            // Finish initializing the IRP.
            //

            TdiBuildReceive(
                pBuffer->pIrp,                          // Irp
                pTdiObject->pDeviceObject,              // DeviceObject
                pTdiObject->pFileObject,                // FileObject
                &UlpRestartReceive,                     // CompletionRoutine
                pBuffer,                                // CompletionContext
                pBuffer->pPartialMdl,                   // MdlAddress
                TDI_RECEIVE_NORMAL,                     // Flags
                g_UlReceiveBufferSize - bytesRemaining  // Length
                );

            UlTrace(TDI, (
                "UlpRestartReceive: connection %p, reusing irp %p to grab more data\n",
                pConnection,
                pBuffer->pIrp
                ));

            //
            // Call the driver.
            //

            UlCallDriver( pTdiObject->pDeviceObject, pIrp );

            //
            // Tell IO to stop processing this request.
            //

            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        status = STATUS_BUFFER_OVERFLOW;
    }

end:
    if (status != STATUS_SUCCESS)
    {
        //
        // The client failed the indication. Abort the connection.
        //

        //
        // BUGBUG need to add code to return a response
        //

        UlpCloseRawConnection(
             pConnection,
             TRUE,          // AbortiveDisconnect
             NULL,          // pCompletionRoutine
             NULL           // pCompletionContext
             );
    }

    //
    // Remove the connection we added in the receive indication handler,
    // free the receive buffer, then tell IO to stop processing the IRP.
    //

    DEREFERENCE_CONNECTION( pConnection );
    UlPplFreeReceiveBuffer( pBuffer );

    UlTrace(TDI, (
        "UlpRestartReceive: endpoint %p, connection %p, length %lu, taken %lu, status %x\n",
        pEndpoint,
        pConnection,
        pBuffer->UnreadDataLength,
        bytesTaken,
        status
        ));

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartReceive


/***************************************************************************++

Routine Description:

    Completion handler for receive IRPs initiated from UlReceiveData().

Arguments:

    pDeviceObject - Supplies the device object for the IRP being
        completed.

    pIrp - Supplies the IRP being completed.

    pContext - Supplies the context associated with this request.
        This is actually a PUL_IRP_CONTEXT.

Return Value:

    NTSTATUS - STATUS_SUCCESS if IO should continue processing this
        IRP, STATUS_MORE_PROCESSING_REQUIRED if IO should stop processing
        this IRP.

--***************************************************************************/
NTSTATUS
UlpRestartClientReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    )
{
    PUL_IRP_CONTEXT pIrpContext;
    PUL_CONNECTION pConnection;

    //
    // Sanity check.
    //

    pIrpContext= (PUL_IRP_CONTEXT)pContext;
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    pConnection = (PUL_CONNECTION)pIrpContext->pConnectionContext;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    UlTrace(TDI, (
        "UlpRestartClientReceive: irp %p, connection %p, status %08lx\n",
        pIrp,
        pConnection,
        pIrp->IoStatus.Status
        ));

    //
    // Invoke the client's completion handler.
    //

    (pIrpContext->pCompletionRoutine)(
        pIrpContext->pCompletionContext,
        pIrp->IoStatus.Status,
        pIrp->IoStatus.Information
        );

    //
    // Free the IRP context we allocated.
    //
    UlPplFreeIrpContext(pIrpContext);

    //
    // IO can't handle completing an IRP with a non-paged MDL attached
    // to it, so we'll free the MDL here.
    //

    ASSERT( pIrp->MdlAddress != NULL );
    UlFreeMdl( pIrp->MdlAddress );
    pIrp->MdlAddress = NULL;

    //
    // Remove the connection we added in UlReceiveData()
    //

    DEREFERENCE_CONNECTION( pConnection );

    //
    // Free the IRP since we're done with it, then tell IO to
    // stop processing the IRP.
    //

    UlFreeIrp(pIrp);

    return STATUS_MORE_PROCESSING_REQUIRED;

}   // UlpRestartClientReceive


/***************************************************************************++

Routine Description:

    Removes all active connections from the specified endpoint and initiates
    abortive disconnects.

Arguments:

    pEndpoint - Supplies the endpoint to purge.

Return Value:

    NTSTATUS - completion status

--***************************************************************************/
NTSTATUS
UlpDisconnectAllActiveConnections(
    IN PUL_ENDPOINT pEndpoint
    )
{
    KIRQL oldIrql;
    PLIST_ENTRY pListEntry;
    PUL_CONNECTION pConnection;
    PUL_IRP_CONTEXT pIrpContext = &pEndpoint->CleanupIrpContext;
    NTSTATUS Status;
    UL_STATUS_BLOCK ulStatus;
    LONG i;

    //
    // Sanity check.
    //

    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    ASSERT( IS_VALID_IRP_CONTEXT( pIrpContext ) );

    UlTrace(TDI, (
        "UlpDisconnectAllActiveConnections: endpoint %p\n",
        pEndpoint
        ));

    //
    // This routine is not pageable because it must acquire a spinlock.
    // However, it must be called at passive IRQL because it must
    // block on an event object.
    //

    ASSERT( KeGetCurrentIrql() == PASSIVE_LEVEL );

    //
    // Initialize a status block. We'll pass a pointer to this as
    // the completion context to UlpCloseRawConnection(). The
    // completion routine will update the status block and signal
    // the event.
    //

    UlInitializeStatusBlock( &ulStatus );

    //
    // Loop through all of the active connections.
    //

    for (i = 0; i < DEFAULT_MAX_CONNECTION_ACTIVE_LISTS; i++)
    {
        for (;;)
        {
            //
            // Remove an active connection.
            //

            UlAcquireSpinLock(
                &pEndpoint->ActiveConnectionSpinLock[i],
                &oldIrql
                );

            pListEntry = RemoveHeadList( &pEndpoint->ActiveConnectionListHead[i] );

            if (pListEntry == &pEndpoint->ActiveConnectionListHead[i])
            {
                UlReleaseSpinLock(
                    &pEndpoint->ActiveConnectionSpinLock[i],
                    oldIrql
                    );

                break;
            }

            //
            // Validate the connection.
            //

            pConnection = CONTAINING_RECORD(
                                pListEntry,
                                UL_CONNECTION,
                                ActiveListEntry
                                );

            ASSERT( IS_VALID_CONNECTION( pConnection ) );
            ASSERT( pConnection->pOwningEndpoint == pEndpoint );

            pConnection->ActiveListEntry.Flink = NULL;

            WRITE_OWNER_REF_TRACE_LOG(
                pEndpoint->pOwnerRefTraceLog,
                pConnection,
                &pConnection->pConnRefOwner,
                UL_CONNECTION_SIGNATURE,
                REF_ACTION_DISCONN_ALL,
                -1, // newrefct: ignored
                pConnection->MonotonicId,
                0,  // don't adjust local ref count
                __FILE__,
                __LINE__
                );

            UlReleaseSpinLock(
                &pEndpoint->ActiveConnectionSpinLock[i],
                oldIrql
                );

            //
            // Abort it.
            //

            UlResetStatusBlockEvent( &ulStatus );

            Status = UlpCloseRawConnection(
                        pConnection,
                        TRUE,
                        &UlpSynchronousIoComplete,
                        &ulStatus
                        );

            ASSERT( Status == STATUS_PENDING );

            //
            // Wait for it to complete.
            //

            UlWaitForStatusBlockEvent( &ulStatus );

            //
            // Remove the active list's reference.
            //

            DEREFERENCE_CONNECTION(pConnection);
        }
    }

    //
    // No active connections, nuke the endpoint.
    //
    // We must set the IRP context in the endpoint so that the
    // completion will be invoked when the endpoint's reference
    // count drops to zero. Since the completion routine may be
    // invoked at a later time, we always return STATUS_PENDING.
    //

    pIrpContext->pConnectionContext = (PVOID)pEndpoint;

    DEREFERENCE_ENDPOINT_SELF(pEndpoint, REF_ACTION_DISCONN_ACTIVE);

    return STATUS_PENDING;

}   // UlpDisconnectAllActiveConnections


/***************************************************************************++

Routine Description:

    Unbinds an active connection from the endpoint. If the connection
    is on the active list this routine removes it and drops the
    list's reference to the connection.

Arguments:

    pConnection - the connection to unbind

--***************************************************************************/
VOID
UlpUnbindConnectionFromEndpoint(
    IN PUL_CONNECTION pConnection
    )
{
    KIRQL oldIrql;
    PUL_ENDPOINT pEndpoint;
    BOOLEAN Dereference;

    //
    // Sanity check.
    //

    ASSERT(IS_VALID_CONNECTION(pConnection));

    pEndpoint = pConnection->pOwningEndpoint;
    ASSERT(IS_VALID_ENDPOINT(pEndpoint));

    //
    // Init locals.
    //
    Dereference = FALSE;

    //
    // Unbind.
    //

    UlAcquireSpinLock(
        &pEndpoint->ActiveConnectionSpinLock[pConnection->ActiveListIndex],
        &oldIrql
        );

    if (pConnection->ActiveListEntry.Flink != NULL)
    {
        RemoveEntryList(&pConnection->ActiveListEntry);
        pConnection->ActiveListEntry.Flink = NULL;

        WRITE_OWNER_REF_TRACE_LOG(
            pConnection->pOwningEndpoint->pOwnerRefTraceLog,
            pConnection,
            &pConnection->pConnRefOwner,
            UL_CONNECTION_SIGNATURE,
            REF_ACTION_UNBIND_CONN,
            -1, // newrefct: ignored
            pConnection->MonotonicId,
            0,  // don't adjust local ref count
            __FILE__,
            __LINE__
            );

        Dereference = TRUE;
    }

    UlReleaseSpinLock(
        &pEndpoint->ActiveConnectionSpinLock[pConnection->ActiveListIndex],
        oldIrql
        );

    //
    // If the list had a reference, remove it.
    //

    if (Dereference)
    {
        DEREFERENCE_CONNECTION(pConnection);
    }

} // UlpUnbindConnectionFromEndpoint


/***************************************************************************++

Routine Description:

    Convert the input url to a TA_IP_ADDRESS.

Arguments:

    pUrl - Supplies the URL to convert.

    pAddress - Receives the address.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpUrlToAddress(
    IN PWSTR pSiteUrl,
    OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pSecure
    )
{
    NTSTATUS status;
    PWSTR pToken;
    PWSTR pHost;
    PWSTR pPort;
    ULONG port;
    UNICODE_STRING portString;
    BOOLEAN secure;

    //
    // Sanity check.
    //

    PAGED_CODE();
    ASSERT(pAddress);
    ASSERT(pSecure);

    //
    // Find the first '/'.
    //

    pToken = wcschr(pSiteUrl, '/');

    if (pToken == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Is this valid http url?
    //

    if (DIFF(pToken - pSiteUrl) == (sizeof(L"https:")-1)/sizeof(WCHAR))
    {
        if (_wcsnicmp(pSiteUrl, L"https:", (sizeof(L"https:")-1)/sizeof(WCHAR)) != 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        secure = TRUE;
    }
    else if (DIFF(pToken - pSiteUrl) == (sizeof(L"http:")-1)/sizeof(WCHAR))
    {
        if (_wcsnicmp(pSiteUrl, L"http:", (sizeof(L"http:")-1)/sizeof(WCHAR)) != 0)
        {
            return STATUS_INVALID_PARAMETER;
        }

        secure = FALSE;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Parse out the host name.
    //

    //
    // Skip the second '/'.
    //

    if (pToken[1] != '/')
    {
        return STATUS_INVALID_PARAMETER;
    }

    pToken += 2;
    pHost = pToken;

    //
    // Find the ':'.
    //

    pToken = wcschr(pToken, ':');

    if (pToken == NULL)
    {
        return STATUS_INVALID_PARAMETER;
    }

    pToken += 1;
    pPort = pToken;

    //
    // Find the end of the string (either UNICODE_NULL or '/' terminated).
    //

    while (pToken[0] != UNICODE_NULL && pToken[0] != L'/')
    {
        pToken += 1;
    }

    //
    // Compute the port #.
    //

    portString.Buffer = pPort;
    portString.Length = DIFF(pToken - pPort) * sizeof(WCHAR);

    status = RtlUnicodeStringToInteger(&portString, 10, &port);

    if (NT_SUCCESS(status) == FALSE)
    {
        return status;
    }

    if (port > 0xffff)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Is this an IP address or hostname?
    //

    //
    // CODEWORK: crack the ip address out
    //

    UlInitializeIpTransportAddress(pAddress, 0, (USHORT)port);
    *pSecure = secure;

    return STATUS_SUCCESS;

}   // UlpUrlToAddress


/***************************************************************************++

Routine Description:

    Scan the endpoint list looking for one corresponding to the supplied
    address.

    Note: This routine assumes the TDI spinlock is held.

Arguments:

    pAddress - Supplies the address to search for.

    AddressLength - Supplies the length of the address structure.

Return Value:

    PUL_ENDPOINT - The corresponding endpoint if successful, NULL otherwise.

--***************************************************************************/
PUL_ENDPOINT
UlpFindEndpointForAddress(
    IN PTRANSPORT_ADDRESS pAddress,
    IN ULONG AddressLength
    )
{
    PUL_ENDPOINT pEndpoint;
    PLIST_ENTRY pListEntry;

    //
    // Sanity check.
    //

    ASSERT( UlDbgSpinLockOwned( &g_TdiSpinLock ) );
    ASSERT( AddressLength == sizeof(TA_IP_ADDRESS) );

    //
    // Scan the endpoint list.
    //
    // CODEWORK: linear searches are BAD, if the list grows long.
    // May need to augment this with a hash table or something.
    //

    for (pListEntry = g_TdiEndpointListHead.Flink ;
         pListEntry != &g_TdiEndpointListHead ;
         pListEntry = pListEntry->Flink)
    {
        pEndpoint = CONTAINING_RECORD(
                        pListEntry,
                        UL_ENDPOINT,
                        GlobalEndpointListEntry
                        );

        if (pEndpoint->LocalAddressLength == AddressLength &&
            RtlEqualMemory(pEndpoint->pLocalAddress, pAddress, AddressLength))
        {
            //
            // Found the address; return it.
            //

            return pEndpoint;
        }
    }

    //
    // If we made it this far, then we did not find the address.
    //

    return NULL;

}   // UlpFindEndpointForAddress


/***************************************************************************++

Routine Description:

    Completion handler for synthetic synchronous IRPs.

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. In this case, this is
        a pointer to a UL_STATUS_BLOCK structure.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred. This field is unused for UlCloseListeningEndpoint().

--***************************************************************************/
VOID
UlpSynchronousIoComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PUL_STATUS_BLOCK pStatus;

    //
    // Snag the status block pointer.
    //

    pStatus = (PUL_STATUS_BLOCK)pCompletionContext;

    //
    // Update the completion status and signal the event.
    //

    UlSignalStatusBlock( pStatus, Status, Information );

}   // UlpSynchronousIoComplete


/***************************************************************************++

Routine Description:

    Enable/disable Nagle's Algorithm on the specified TDI connection object.

Arguments:

    pTdiObject - Supplies the TDI connection object to manipulate.

    Flag - Supplies TRUE to enable Nagling, FALSE to disable it.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpSetNagling(
    IN PUX_TDI_OBJECT pTdiObject,
    IN BOOLEAN Flag
    )
{
    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    PTCP_REQUEST_SET_INFORMATION_EX pSetInfoEx;
    ULONG value;
    UCHAR buffer[sizeof(*pSetInfoEx) - sizeof(pSetInfoEx->Buffer) + sizeof(value)];

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_TDI_OBJECT( pTdiObject ) );

    //
    // Note: NODELAY semantics are inverted from the usual enable/disable
    // semantics.
    //

    value = (ULONG)!Flag;

    //
    // Setup the buffer.
    //

    pSetInfoEx = (PTCP_REQUEST_SET_INFORMATION_EX)buffer;

    pSetInfoEx->ID.toi_entity.tei_entity = CO_TL_ENTITY;
    pSetInfoEx->ID.toi_entity.tei_instance = TL_INSTANCE;
    pSetInfoEx->ID.toi_class = INFO_CLASS_PROTOCOL;
    pSetInfoEx->ID.toi_type = INFO_TYPE_CONNECTION;
    pSetInfoEx->ID.toi_id = TCP_SOCKET_NODELAY;
    pSetInfoEx->BufferSize = sizeof(value);
    RtlCopyMemory( pSetInfoEx->Buffer, &value, sizeof(value) );

    UlAttachToSystemProcess();

    status = ZwDeviceIoControlFile(
                    pTdiObject->Handle,             // FileHandle
                    NULL,                           // Event
                    NULL,                           // ApcRoutine
                    NULL,                           // ApcContext
                    &ioStatusBlock,                 // IoStatusBlock
                    IOCTL_TCP_SET_INFORMATION_EX,   // IoControlCode
                    pSetInfoEx,                     // InputBuffer
                    sizeof(buffer),                 // InputBufferLength
                    NULL,                           // OutputBuffer
                    0                               // OutputBufferLength
                    );

    if (status == STATUS_PENDING)
    {
        status = ZwWaitForSingleObject(
                        pTdiObject->Handle,         // Handle
                        TRUE,                       // Alertable
                        NULL                        // Timeout
                        );

        ASSERT( NT_SUCCESS(status) );
        status = ioStatusBlock.Status;
    }

    UlDetachFromSystemProcess();

    return status;

}   // UlpSetNagling


/***************************************************************************++

Routine Description:

    Query the TCP fast send routine if fast send is possible.

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
UlpQueryTcpFastSend()
{
    UNICODE_STRING TCPDeviceName;
    PFILE_OBJECT pTCPFileObject;
    PDEVICE_OBJECT pTCPDeviceObject;
    PIRP Irp;
    IO_STATUS_BLOCK StatusBlock;
    KEVENT Event;
    NTSTATUS status;

    RtlInitUnicodeString(&TCPDeviceName, DD_TCP_DEVICE_NAME);

    status = IoGetDeviceObjectPointer(
                &TCPDeviceName,
                FILE_ALL_ACCESS,
                &pTCPFileObject,
                &pTCPDeviceObject
                );

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(
            IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER,
            pTCPDeviceObject,
            &g_TcpFastSend,
            sizeof(g_TcpFastSend),
            NULL,
            0,
            FALSE,
            &Event,
            &StatusBlock);

    if (Irp)
    {
        status = UlCallDriver(pTCPDeviceObject, Irp);

        if (status == STATUS_PENDING)
        {
            KeWaitForSingleObject(
                &Event,
                Executive,
                KernelMode,
                FALSE,
                NULL
                );

            status = StatusBlock.Status;
        }
    }
    else
    {
        status = STATUS_NO_MEMORY;
    }

    ObDereferenceObject(pTCPFileObject);

    return status;
} // UlpQueryTcpFastSend


/***************************************************************************++

Routine Description:

    Build a receive buffer and IRP to TDI to get any pending data.

Arguments:

    pTdiObject - Supplies the TDI connection object to manipulate.

    pConnection - Supplies the UL_CONNECTION object.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpBuildTdiReceiveBuffer(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PUL_CONNECTION pConnection,
    OUT PIRP *pIrp
    )
{
    PUL_RECEIVE_BUFFER  pBuffer;

    pBuffer = UlPplAllocateReceiveBuffer();

    if (pBuffer != NULL)
    {
        //
        // Finish initializing the buffer and the IRP.
        //

        REFERENCE_CONNECTION( pConnection );
        pBuffer->pConnectionContext = pConnection;
        pBuffer->UnreadDataLength = 0;

        TdiBuildReceive(
            pBuffer->pIrp,                  // Irp
            pTdiObject->pDeviceObject,      // DeviceObject
            pTdiObject->pFileObject,        // FileObject
            &UlpRestartReceive,             // CompletionRoutine
            pBuffer,                        // CompletionContext
            pBuffer->pMdl,                  // MdlAddress
            TDI_RECEIVE_NORMAL,             // Flags
            g_UlReceiveBufferSize           // Length
            );


        UlTrace(TDI, (
            "UlpBuildTdiReceiveBuffer: connection %p, "
            "allocated irp %p to grab more data\n",
            (PVOID)pConnection,
            pBuffer->pIrp
            ));

        //
        // We must trace the IRP before we set the next stack
        // location so the trace code can pull goodies from the
        // IRP correctly.
        //

        TRACE_IRP( IRP_ACTION_CALL_DRIVER, pBuffer->pIrp );

        //
        // Pass the IRP back to the transport.
        //

        *pIrp = pBuffer->pIrp;

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    return STATUS_INSUFFICIENT_RESOURCES;
} // UlpBuildTdiReceiveBuffer


/***************************************************************************++

Routine Description:

    Returns the length required for HTTP_RAW_CONNECTION

Arguments:

    pConnectionContext - Pointer to the UL_CONNECTION

--***************************************************************************/
ULONG
UlpComputeHttpRawConnectionLength(
    IN PVOID pConnectionContext
    )
{
    return (sizeof(HTTP_RAW_CONNECTION_INFO) +
            sizeof(HTTP_NETWORK_ADDRESS_IPV4) * 2
            );
}

/***************************************************************************++

Routine Description:

    Builds the HTTP_RAW_CONNECTION structure

Arguments:

    pContext           - Pointer to the UL_CONNECTION
    pKernelBuffer      - Pointer to kernel buffer
    pUserBuffer        - Pointer to user buffer
    OutputBufferLength - Length of output buffer
    pBuffer            - Buffer for holding any data
    InitialLength      - Size of input data.

--***************************************************************************/
ULONG
UlpGenerateHttpRawConnectionInfo(
    IN  PVOID   pContext,
    IN  PUCHAR  pKernelBuffer,
    IN  PVOID   pUserBuffer,
    IN  ULONG   OutputBufferLength,
    IN  PUCHAR  pBuffer,
    IN  ULONG   InitialLength
    )
{
    PHTTP_RAW_CONNECTION_INFO   pConnInfo;
    PHTTP_NETWORK_ADDRESS_IPV4  pLocalAddress;
    PHTTP_NETWORK_ADDRESS_IPV4  pRemoteAddress;
    PHTTP_TRANSPORT_ADDRESS     pAddress;
    ULONG                       BytesCopied = 0;
    PUCHAR                      pInitialData;
    PUL_CONNECTION pConnection = (PUL_CONNECTION) pContext;

    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    pConnInfo = (PHTTP_RAW_CONNECTION_INFO) pKernelBuffer;

    pLocalAddress = (PHTTP_NETWORK_ADDRESS_IPV4)( pConnInfo + 1 );
    pRemoteAddress = pLocalAddress + 1;

    pInitialData = (PUCHAR) (pRemoteAddress + 1);

    //
    // Now fill in the raw connection data structure.
    // BUGBUG: handle other address types.
    //
    pConnInfo->ConnectionId = pConnection->FilterInfo.ConnectionId;

    pAddress = &pConnInfo->Address;

    pAddress->RemoteAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pAddress->RemoteAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pAddress->pRemoteAddress = FIXUP_PTR(
                                    PVOID,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pRemoteAddress,
                                    OutputBufferLength
                                    );

    pAddress->LocalAddressLength = sizeof(HTTP_NETWORK_ADDRESS_IPV4);
    pAddress->LocalAddressType = HTTP_NETWORK_ADDRESS_TYPE_IPV4;
    pAddress->pLocalAddress = FIXUP_PTR(
                                    PVOID,
                                    pUserBuffer,
                                    pKernelBuffer,
                                    pLocalAddress,
                                    OutputBufferLength
                                    );

    pRemoteAddress->IpAddress = pConnection->RemoteAddress;
    pRemoteAddress->Port      = pConnection->RemotePort;
    pLocalAddress->IpAddress  = pConnection->LocalAddress;
    pLocalAddress->Port       = pConnection->LocalPort;


    //
    // Copy any initial data.
    //
    if (InitialLength)
    {
        ASSERT(pBuffer);

        pConnInfo->InitialDataSize = InitialLength;

        pConnInfo->pInitialData = FIXUP_PTR(
                                        PVOID,              // Type
                                        pUserBuffer,        // pUserPtr
                                        pKernelBuffer,      // pKernelPtr
                                        pInitialData,       // pOffsetPtr
                                        OutputBufferLength  // BufferLength
                                        );

        RtlCopyMemory(
            pInitialData,
            pBuffer,
            InitialLength
            );

        BytesCopied += InitialLength;
    }

    return BytesCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultdi.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ultdi.h

Abstract:

    This module defines the interface to the TDI/MUX/SSL component.

Author:

    Keith Moore (keithmo)       12-Jun-1998

Revision History:

--*/


#ifndef _ULTDI_H_
#define _ULTDI_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Opaque structure pointers. These are defined (privately) in ULTDIP.H.
//

typedef struct _UL_ENDPOINT *PUL_ENDPOINT;
typedef struct _UL_CONNECTION *PUL_CONNECTION;


//
// Routine invoked after an incoming TCP/MUX connection has been
// received (but not yet accepted).
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnection - Supplies the connection being established.
//
//      pRemoteAddress - Supplies the remote (client-side) address
//          requesting the connection.
//
//      RemoteAddressLength - Supplies the total byte length of the
//          pRemoteAddress structure.
//
//      ppConnectionContext - Receives a pointer to an uninterpreted
//          context value to be associated with the new connection if
//          accepted. If the new connection is not accepted, this
//          parameter is ignored.
//
// Return Value:
//
//      BOOLEAN - TRUE if the connection was accepted, FALSE if not.
//

typedef
BOOLEAN
(*PUL_CONNECTION_REQUEST)(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    );


//
// Routine invoked after an incoming TCP/MUX connection has been fully
// accepted.
//
// This routine is also invoked if an incoming connection was not accepted
// *after* PUL_CONNECTION_REQUEST returned TRUE. In other words, if
// PUL_CONNECTION_REQUEST indicated that the connection should be accepted
// but a fatal error occurred later, then PUL_CONNECTION_COMPLETE is
// invoked.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies the uninterpreted context value
//          as returned by PUL_CONNECTION_REQUEST.
//
//      Status - Supplie the completion status. If this value is
//          STATUS_SUCCESS, then the connection is now fully accepted.
//          Otherwise, the connection has been aborted.
//

typedef
VOID
(*PUL_CONNECTION_COMPLETE)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );


//
// Routine invoked after an established TCP/MUX connection has been
// disconnected by the remote (client) side.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//
//      Status - Supplies the termination status.
//
// CODEWORK:
//
//      This indication is not currently invoked when the local
//      machine initiates an abortive disconnect. Faking an indication
//      during a local abort would probably be a Good Thing.
//

typedef
VOID
(*PUL_CONNECTION_DISCONNECT)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

//
// Routine invoked when a graceful disconnect requested by the client
// is complete. The client may want to drain the indicated data on the
// tdi connection to get the above indication.
//

typedef
VOID
(*PUL_CONNECTION_DISCONNECT_COMPLETE)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

//
// Routine invoked just before the internal state for a connection
// is destroyed. This is the last chance to cleanup before the
// connection fully disappears.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//

typedef
VOID
(*PUL_CONNECTION_DESTROYED)(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );


//
// Routine invoked after data has been received on an established
// TCP/MUX connection.
//
// Arguments:
//
//      pListeningContext - Supplies an uninterpreted context value
//          as passed to the UlCreateListeningEndpoint() API.
//
//      pConnectionContext - Supplies an uninterpreted context value
//          as returned from the PUL_CONNECTION_REQUEST callback.
//
//      pBuffer - Supplies a pointer to the received data.
//
//      IndicatedLength - Supplies the length of the received data
//          available in pBuffer.
//
//      pTakenLength - Receives the number of bytes consumed by
//          the receive handler.
//
// Return Value:
//
//      NTSTATUS - The status of the consumed data. The behavior of
//          the TDI/MUX component is dependent on the return value
//          and the value set in *pTakenLength, and is defined as
//          follows:
//
//              STATUS_SUCCESS, *pTakenLength == IndicatedLength -
//                  All indicated data was consumed by the receive
//                  handler. Additional incoming data will cause
//                  subsequent receive indications.
//
//              STATUS_SUCCESS, *pTakenLength < IndicatedLength -
//                  Part of the indicated data was consumed by the
//                  receive handler. The network transport will
//                  buffer data and no further indications will be
//                  made until UlReceiveData() is called.
//
//              STATUS_MORE_PROCESSING_REQUIRED - Part of the
//                  indicated data was consumed by the receive handler.
//                  A subsequent receive indication will be made
//                  when additional data is available. The subsequent
//                  indication will include the unconsumed data from
//                  the current indication plus any additional data
//                  received.
//
//              Any other status - Indicates a fatal error in the
//                  receive handler. The connection will be aborted.
//
//              *pTakenLength > IndicatedLength - This is an error
//                  condition and should never occur.
//



//
// Public (within UL.SYS) entrypoints.
//

NTSTATUS
UlInitializeTdi(
    VOID
    );

VOID
UlTerminateTdi(
    VOID
    );


VOID
UlWaitForEndpointDrain(
    VOID
    );

ULONG
UlpComputeHttpRawConnectionLength(
    IN PVOID pConnectionContext
    );

ULONG
UlpGenerateHttpRawConnectionInfo(
    IN  PVOID   pContext,
    IN  PUCHAR  pKernelBuffer,
    IN  PVOID   pUserBuffer,
    IN  ULONG   OutputBufferLength,
    IN  PUCHAR  pBuffer,
    IN  ULONG   InitialLength
    );

NTSTATUS
UlCreateListeningEndpoint(
    IN PTRANSPORT_ADDRESS pLocalAddress,
    IN ULONG LocalAddressLength,
    IN BOOLEAN Secure,
    IN ULONG InitialBacklog,
    IN PUL_CONNECTION_REQUEST pConnectionRequestHandler,
    IN PUL_CONNECTION_COMPLETE pConnectionCompleteHandler,
    IN PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler,
    IN PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler,
    IN PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler,
    IN PUL_DATA_RECEIVE pDataReceiveHandler,
    IN PVOID pListeningContext,
    OUT PUL_ENDPOINT *ppListeningEndpoint
    );

NTSTATUS
UlCloseListeningEndpoint(
    IN PUL_ENDPOINT pListeningEndpoint,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlCloseConnection(
    IN PVOID pObject,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlSendData(
    IN PUL_CONNECTION pConnection,
    IN PMDL pMdlChain,
    IN ULONG Length,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext,
    IN PIRP pOwnIrp,
    IN PUL_IRP_CONTEXT pOwnIrpContext,
    IN BOOLEAN InitiateDisconnect
    );

NTSTATUS
UlReceiveData(
    IN PVOID          pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlAddSiteToEndpointList(
    IN PWSTR pSiteUrl
    );

NTSTATUS
UlRemoveSiteFromEndpointList(
    IN PWSTR pSiteUrl
    );

VOID
UlReferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlDereferenceConnection(
    IN PVOID pObject
    REFERENCE_DEBUG_FORMAL_PARAMS
    );

#define REFERENCE_CONNECTION( pconn )                                       \
    UlReferenceConnection(                                                  \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

#define DEREFERENCE_CONNECTION( pconn )                                     \
    UlDereferenceConnection(                                                \
        (pconn)                                                             \
        REFERENCE_DEBUG_ACTUAL_PARAMS                                       \
        )

//
// Prototype for TCP Send routine if Fast Send is possible.
//

typedef
NTSTATUS
(*PUL_TCPSEND_DISPATCH) (
   IN PIRP Irp,
   IN PIO_STACK_LOCATION IrpSp
   );


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _ULTDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\ultdip.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ultdip.h

Abstract:

    This module contains declarations private to the TDI component. These
    declarations are placed in a separate .H file to make it easier to access
    them from within the kernel debugger extension DLL.

    The TDI package manages two major object types: UL_ENDPOINT and
    UL_CONNECTION.

    A UL_ENDPOINT is basically a wrapper around a TDI address object. Each
    endpoint has two lists of associated UL_CONNECTION objects: one for
    idle (non-connected) connections and one for active (connected)
    connections. The active connections list is actually a 64-entry array
    for better multiprocessor partitioning.

    A UL_CONNECTION is basically a wrapper around a TDI connection object.
    Its main purpose is to manage TDI connection state. See the description
    of UL_CONNECTION_FLAGS below for the gory details.

    The relationship between these two objects is illustrated in the
    following diagram:

        +-----------+
        |           |
        |UL_ENDPOINT|
        |           |
        +---+----+--+
            |    |
            |    |
            |    |  Idle Connections
            |    |  +-------------+   +-------------+   +-------------+
            |    |  |             |   |             |   |             |
            |    +->|UL_CONNECTION|<->|UL_CONNECTION|<->|UL_CONNECTION|<-...
            |       |             |   |             |   |             |
            |       +-------------+   +-------------+   +-------------+
            |
            |
            |       Active Connections[0]
            |       +-------------+   +-------------+   +-------------+
            |       |             |   |             |   |             |
            +------>|UL_CONNECTION|<->|UL_CONNECTION|<->|UL_CONNECTION|<-...
            |       |             |   |             |   |             |
            |       +-------------+   +-------------+   +-------------+
            |
            :
            :
            |       Active Connections[DEFAULT_MAX_CONNECTION_ACTIVE_LISTS-1]
            |       +-------------+   +-------------+   +-------------+
            |       |             |   |             |   |             |
            +------>|UL_CONNECTION|<->|UL_CONNECTION|<->|UL_CONNECTION|<-...
                    |             |   |             |   |             |
                    +-------------+   +-------------+   +-------------+

    Note: Idle connections do not hold references to their owning endpoint,
    but active connections do. When a listening endpoint is shutdown, all
    idle connections are simply purged, but active connections must be
    forcibly disconnected first.

Author:

    Keith Moore (keithmo)       15-Jun-1998

Revision History:

--*/


#ifndef _ULTDIP_H_
#define _ULTDIP_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Forward references.
//

typedef union _ENDPOINT_SYNCH *PENDPOINT_SYNCH;
typedef struct _UL_ENDPOINT *PUL_ENDPOINT;
typedef union _UL_CONNECTION_FLAGS *PUL_CONNECTION_FLAGS;
typedef struct _UL_CONNECTION *PUL_CONNECTION;
typedef struct _UL_RECEIVE_BUFFER *PUL_RECEIVE_BUFFER;

//
// Private constants.
//

#define MAX_ADDRESS_EA_BUFFER_LENGTH                                        \
    sizeof(FILE_FULL_EA_INFORMATION) - 1 +                                  \
    TDI_TRANSPORT_ADDRESS_LENGTH + 1 +                                      \
    sizeof(TA_IP_ADDRESS)

#define MAX_CONNECTION_EA_BUFFER_LENGTH                                     \
    sizeof(FILE_FULL_EA_INFORMATION) - 1 +                                  \
    TDI_CONNECTION_CONTEXT_LENGTH + 1 +                                     \
    sizeof(CONNECTION_CONTEXT)

#define TCP_DEVICE_NAME L"\\Device\\Tcp"

#define TL_INSTANCE 0

//
// Private types.
//


//
// A generic IRP context. This is useful for storing additional completion
// information associated with a pending IRP.
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_IRP_CONTEXT
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY LookasideEntry;

    //
    // Structure signature.
    //

    ULONG Signature;

    //
    // Either the endpoint or endpoint associated with the IRP.
    //

    PVOID pConnectionContext;

    //
    // Completion information.
    //

    PUL_COMPLETION_ROUTINE pCompletionRoutine;
    PVOID pCompletionContext;

    //
    // Our own allocated IRP if set.
    //

    PIRP pOwnIrp;

} UL_IRP_CONTEXT, *PUL_IRP_CONTEXT;

#define UL_IRP_CONTEXT_SIGNATURE    ((ULONG)'CPRI')
#define UL_IRP_CONTEXT_SIGNATURE_X  MAKE_FREE_SIGNATURE(UL_IRP_CONTEXT_SIGNATURE)

#define IS_VALID_IRP_CONTEXT(pIrpContext)                                   \
    ( ((pIrpContext) != NULL) &&                                            \
      ((pIrpContext)->Signature == UL_IRP_CONTEXT_SIGNATURE) )


//
// The following union allows us to perform some spinlock-free synchronization
// magic using UlInterlockedCompareExchange(). In this case, we can update
// the number of idle connections that need to be added to an endpoint, *and*
// update the "replenish scheduled" flag atomically.
//

typedef union _ENDPOINT_SYNCH
{
    struct
    {
        LONG ReplenishScheduled:1;
        LONG IdleConnections:31;
    };

    LONG Value;

} ENDPOINT_SYNCH;

C_ASSERT( sizeof(ENDPOINT_SYNCH) == sizeof(LONG) );


//
// An endpoint is basically our wrapper around a TDI address object.
//

typedef struct _UL_ENDPOINT
{
    //
    // Structure signature: UL_ENDPOINT_SIGNATURE
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Usage count. This is used by the "URL-site-to-endpoint" thingie.
    //

    LONG UsageCount;

    //
    // Links onto the global endpoint list.
    //
    // GlobalEndpointListEntry.Flink is NULL if the endpoint is not
    // on the global list, g_TdiEndpointListHead, or the
    // to-be-deleted-soon list, g_TdiDeletedEndpointListHead.
    //

    LIST_ENTRY GlobalEndpointListEntry;

    //
    // Heads of the per-endpoint connection lists.
    // Idle connections have a weak reference to 'this', the owning endpoint
    //

    SLIST_HEADER IdleConnectionSListHead;

    //
    // Use an array of active connections to improve partitioning on MP systems
    //

    LIST_ENTRY ActiveConnectionListHead[DEFAULT_MAX_CONNECTION_ACTIVE_LISTS];

    //
    // Index assigned to the next active connection.
    //

    LONG ActiveConnectionIndex;

    //
    // Spinlock protecting the IdleConnectionSLists.
    //

    UL_SPIN_LOCK IdleConnectionSpinLock;

    //
    // Spinlocks protecting the ActiveConnectionLists array.
    //

    UL_SPIN_LOCK ActiveConnectionSpinLock[DEFAULT_MAX_CONNECTION_ACTIVE_LISTS];

    //
    // Spinlock protecting the endpoint. Use sparingly.
    //

    UL_SPIN_LOCK EndpointSpinLock;

    //
    // The TDI address object.
    //

    UX_TDI_OBJECT AddressObject;

    //
    // Indication handlers & user context.
    //

    PUL_CONNECTION_REQUEST pConnectionRequestHandler;
    PUL_CONNECTION_COMPLETE pConnectionCompleteHandler;
    PUL_CONNECTION_DISCONNECT pConnectionDisconnectHandler;
    PUL_CONNECTION_DISCONNECT_COMPLETE pConnectionDisconnectCompleteHandler;
    PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler;
    PUL_DATA_RECEIVE pDataReceiveHandler;
    PVOID pListeningContext;

    //
    // The local address we're bound to.
    //

    PTRANSPORT_ADDRESS pLocalAddress;
    ULONG LocalAddressLength;

    //
    // Is this a secure endpoint?
    //

    BOOLEAN Secure;

    //
    // Thread work item for deferred actions.
    //

    UL_WORK_ITEM WorkItem;

    //
    // Synchronizer for idle connection replenishment.
    //

    ENDPOINT_SYNCH EndpointSynch;

    //
    // An IRP context containing completion information necessary
    // while shutting down a listening endpoint.
    //

    UL_IRP_CONTEXT CleanupIrpContext;

#if ENABLE_OWNER_REF_TRACE
    //
    // Track owners of the endpoint reference count
    //

    POWNER_REF_TRACELOG pOwnerRefTraceLog;
    PREF_OWNER          pEndpointRefOwner;
#endif // ENABLE_OWNER_REF_TRACE

    //
    // Has this endpoint been moved to the deleted list,
    // g_TdiDeletedEndpointListHead?
    //

    BOOLEAN Deleted;

} UL_ENDPOINT;

#define UL_ENDPOINT_SIGNATURE   ((ULONG)'PDNE')
#define UL_ENDPOINT_SIGNATURE_X MAKE_FREE_SIGNATURE(UL_ENDPOINT_SIGNATURE)

#define IS_VALID_ENDPOINT(pEndpoint)                                        \
    ( ((pEndpoint) != NULL) &&                                              \
      ((pEndpoint)->Signature == UL_ENDPOINT_SIGNATURE) )


//
// Connection flags/state. These flags indicate the current state of a
// connection.
//
// Some of these flags may be simply updated directly. Others require
// UlInterlockedCompareExchange() to avoid race conditions.
//
// The following flags may be updated directly:
//
//     AcceptPending - SET in the TDI connection handler, just before the
//         accept IRP is returned to the transport. RESET only if the accept
//         IRP fails.
//
// The following flags must be updated using UlInterlockedCompareExchange():
//
//     AcceptComplete - SET in the accept IRP completion handler if the IRP
//         completed successfully. Once this flag is set, the connection must
//         be either gracefully disconnected or aborted before the connection
//         can be closed or reused.
//
//     DisconnectPending - SET just before a graceful disconnect IRP is
//         issued.
//
//     DisconnectComplete - SET in the graceful disconnect IRP completion
//         handler.
//
//     AbortPending - SET just before an abortive disconnect IRP is issued.
//
//     AbortComplete - SET in the abortive disconnect IRP completion handler.
//
//     DisconnectIndicated - SET in the TDI disconnect handler for graceful
//         disconnects issued by the remote client.
//
//     AbortIndicated - SET in the TDI disconnect handler for abortive
//         disconnects issued by the remote client.
//
//     CleanupPending - SET when cleanup is begun for a connection. This
//         is necessary to know when the final reference to the connection
//         can be removed.
//
//         CODEWORK: We can get rid of the CleanupPending flag. It is
//         only set when either a graceful or abortive disconnect is
//         issued, and only tested in UlpRemoveFinalReference(). The
//         test in UlpRemoveFinalReference() can just test for either
//         (DisconnectPending | AbortPending) instead.
//
//     FinalReferenceRemoved - SET when the final (i.e. "connected")
//         reference is removed from the connection.
//
// Note that the flags requiring UlInterlockedCompareExchange() are only SET,
// never RESET. This makes the implementation a bit simpler.
//
// And now a few words about connection management, TDI, and other mysteries.
//
// Some of the more annoying "features" of TDI are related to connection
// management and lifetime. Two of the most onerous issues are:
//
//     1. Knowing when a connection object handle can be closed without
//        causing an unwanted connection reset.
//
//     2. Knowing when TDI has given its last indication on a connection
//        so that resources can be released, reused, recycled, whatever.
//
// And, of course, this is further complicated by the inherent asynchronous
// nature of the NT I/O architecture and the parallelism of SMP systems.
//
// There are a few points worth keeping in mind while reading/modifying this
// source code or writing clients of this code:
//
//     1. As soon as an accept IRP is returned from the TDI connection
//        handler to the transport, the TDI client must be prepared for
//        any incoming indications, including data receive and disconnect.
//        In other words, incoming data & disconnect may occur *before* the
//        accept IRP actually completes.
//
//     2. A connection is considered "in use" until either both sides have
//        gracefully disconnected OR either side has aborted the connection.
//        Closing an "in use" connection will usually result in an abortive
//        disconnect.
//
//     3. The various flavors of disconnect (initiated by the local server,
//        initiated by the remote client, graceful, abortive, etc) may occur
//        in any order.
//

typedef union _UL_CONNECTION_FLAGS
{
    //
    // This field overlays all of the settable flags. This allows us to
    // update all flags in a thread-safe manner using the
    // UlInterlockedCompareExchange() API.
    //

    LONG Value;

    struct
    {
        ULONG AcceptPending:1;          // 00000001
        ULONG AcceptComplete:1;         // 00000002
        ULONG :2;
        ULONG DisconnectPending:1;      // 00000010
        ULONG DisconnectComplete:1;     // 00000020
        ULONG :2;
        ULONG AbortPending:1;           // 00000100
        ULONG AbortComplete:1;          // 00000200
        ULONG :2;
        ULONG DisconnectIndicated:1;    // 00001000
        ULONG AbortIndicated:1;         // 00002000
        ULONG :2;
        ULONG CleanupBegun:1;           // 00010000
        ULONG FinalReferenceRemoved:1;  // 00020000
        ULONG :2;
        ULONG LocalAddressValid:1;      // 00100000
        ULONG ReceivePending:1;         // 00200000
    };

} UL_CONNECTION_FLAGS;

C_ASSERT( sizeof(UL_CONNECTION_FLAGS) == sizeof(LONG) );

#define MAKE_CONNECTION_FLAG_ROUTINE(name)                                  \
    __inline LONG Make##name##Flag()                                        \
    {                                                                       \
        UL_CONNECTION_FLAGS flags = { 0 };                                  \
        flags.name = 1;                                                     \
        return flags.Value;                                                 \
    }

MAKE_CONNECTION_FLAG_ROUTINE( AcceptPending );
MAKE_CONNECTION_FLAG_ROUTINE( AcceptComplete );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectPending );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectComplete );
MAKE_CONNECTION_FLAG_ROUTINE( AbortPending );
MAKE_CONNECTION_FLAG_ROUTINE( AbortComplete );
MAKE_CONNECTION_FLAG_ROUTINE( DisconnectIndicated );
MAKE_CONNECTION_FLAG_ROUTINE( AbortIndicated );
MAKE_CONNECTION_FLAG_ROUTINE( CleanupBegun );
MAKE_CONNECTION_FLAG_ROUTINE( FinalReferenceRemoved );


//
// A connection is basically our wrapper around a TDI connection object.
//

typedef struct _UL_CONNECTION
{
    //
    // Link onto the per-endpoint idle connection list.
    //

    SINGLE_LIST_ENTRY IdleSListEntry;

    //
    // Structure signature: UL_CONNECTION_SIGNATURE
    //

    ULONG Signature;

    //
    // Reference count.
    //

    LONG ReferenceCount;

    //
    // Connection flags.
    //

    UL_CONNECTION_FLAGS ConnectionFlags;

    //
    // Cached Irp
    //

    PIRP pIrp;

    //
    // Addresses and ports. These are in host order.
    // CODEWORK: Make these transport independent for IPv6.
    //

    IPAddr  RemoteAddress;
    USHORT  RemotePort;
    USHORT  LocalPort;
    IPAddr  LocalAddress;

    //
    // Structure to get LocalAddress when Accept completes
    //

    TDI_CONNECTION_INFORMATION  TdiConnectionInformation;
    TA_IP_ADDRESS               IpAddress;

    //
    // Link onto the per-endpoint active connection list.
    //

    LIST_ENTRY ActiveListEntry;

    //
    // Index to the ActiveConnectionLists (a random number for better partition
    // on MP machines). Always zero on UP machines.
    //

    ULONG ActiveListIndex;

    //
    // The TDI connection object.
    //

    UX_TDI_OBJECT ConnectionObject;

    //
    // User context.
    //

    PVOID pConnectionContext;

    //
    // The endpoint associated with this connection. Note that this
    // ALWAYS points to a valid endpoint. For idle connections, it's
    // a weak (non referenced) pointer. For active connections, it's
    // a strong (referenced) pointer.
    //

    PUL_ENDPOINT pOwningEndpoint;

    //
    // Thread work item for deferred actions.
    //

    UL_WORK_ITEM WorkItem;

    //
    // Data captured from the listening endpoint at the time the
    // connection is created. This is captured to reduce references
    // to the listening endpoint.
    //

    PUL_CONNECTION_DESTROYED pConnectionDestroyedHandler;
    PVOID                    pListeningContext;

    //
    // To synchronize the RawCloseHandler
    //

    LONG    Terminated;

    //
    // Pre-allocated IrpContext for disconnect.
    //

    UL_IRP_CONTEXT IrpContext;

    //
    // HTTP connection.
    //

    UL_HTTP_CONNECTION HttpConnection;

    //
    // Filter related info.
    //

    UX_FILTER_CONNECTION FilterInfo;

    //
    // We've had too many problems with orphaned UL_CONNECTIONs.
    // Let's make it easy to find them all in the debugger.
    //

    LIST_ENTRY  GlobalConnectionListEntry;

#if REFERENCE_DEBUG
    //
    // Private Reference trace log.
    //

    PTRACE_LOG  pTraceLog;
#endif // REFERENCE_DEBUG

#if ENABLE_OWNER_REF_TRACE
    // For ownerref and connection recycling
    PREF_OWNER  pConnRefOwner;
    LONG        MonotonicId;
#endif // ENABLE_OWNER_REF_TRACE

} UL_CONNECTION, *PUL_CONNECTION;

#define UL_CONNECTION_SIGNATURE     ((ULONG)'NNOC')
#define UL_CONNECTION_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_CONNECTION_SIGNATURE)

#define IS_VALID_CONNECTION(pConnection)                                    \
    ( ((pConnection) != NULL) &&                                            \
      ((pConnection)->Signature == UL_CONNECTION_SIGNATURE) )


//
// A buffer, containing a precreated receive IRP, a precreated MDL, and
// sufficient space for a partial MDL. These buffers are typically used
// when passing a receive IRP back to the transport from within our receive
// indication handler.
//
// The buffer structure, IRP, MDLs, and data area are all allocated in a
// single pool block. The layout of the block is:
//
//      +-------------------+
//      |                   |
//      | UL_RECEIVE_BUFFER |
//      |                   |
//      +-------------------+
//      |                   |
//      |        IRP        |
//      |                   |
//      +-------------------+
//      |                   |
//      |        MDL        |
//      |                   |
//      +-------------------+
//      |                   |
//      |    Partial MDL    |
//      |                   |
//      +-------------------+
//      |                   |
//      |     Data Area     |
//      |                   |
//      +-------------------+
//
// WARNING!  All fields of this structure must be explicitly initialized.
//

typedef struct _UL_RECEIVE_BUFFER
{
    //
    // This MUST be the first field in the structure. This is the linkage
    // used by the lookaside package for storing entries in the lookaside
    // list.
    //

    SINGLE_LIST_ENTRY LookasideEntry;

    //
    // Structure signature: UL_RECEIVE_BUFFER_SIGNATURE
    //

    ULONG Signature;

    //
    // Amount of unread data in the data area.
    //

    ULONG UnreadDataLength;

    //
    // The pre-built receive IRP.
    //

    PIRP pIrp;

    //
    // The pre-built MDL describing the entire data area.
    //

    PMDL pMdl;

    //
    // A secondary MDL describing part of the data area.
    //

    PMDL pPartialMdl;

    //
    // Pointer to the data area for this buffer.
    //

    PVOID pDataArea;

    //
    // Pointer to the connection referencing this buffer.
    //

    PVOID pConnectionContext;

} UL_RECEIVE_BUFFER;

#define UL_RECEIVE_BUFFER_SIGNATURE     ((ULONG)'FUBR')
#define UL_RECEIVE_BUFFER_SIGNATURE_X   MAKE_FREE_SIGNATURE(UL_RECEIVE_BUFFER_SIGNATURE)

#define IS_VALID_RECEIVE_BUFFER(pBuffer)                                    \
    ( ((pBuffer) != NULL) &&                                                \
      ((pBuffer)->Signature == UL_RECEIVE_BUFFER_SIGNATURE) )





//
// Private prototypes.
//

VOID
UlpDestroyEndpoint(
    IN PUL_ENDPOINT pEndpoint
    );

VOID
UlpDestroyConnection(
    IN PUL_CONNECTION pConnection
    );

PUL_CONNECTION
UlpDequeueIdleConnection(
    IN PUL_ENDPOINT pEndpoint,
    IN BOOLEAN ScheduleReplenish
    );

BOOLEAN
UlpEnqueueIdleConnection(
    IN PUL_CONNECTION pConnection,
    IN BOOLEAN Replenishing
    );

VOID
UlpEnqueueActiveConnection(
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlpConnectHandler(
    IN PVOID pTdiEventContext,
    IN LONG RemoteAddressLength,
    IN PVOID pRemoteAddress,
    IN LONG UserDataLength,
    IN PVOID pUserData,
    IN LONG OptionsLength,
    IN PVOID pOptions,
    OUT CONNECTION_CONTEXT *pConnectionContext,
    OUT PIRP *pAcceptIrp
    );

NTSTATUS
UlpDisconnectHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN LONG DisconnectDataLength,
    IN PVOID pDisconnectData,
    IN LONG DisconnectInformationLength,
    IN PVOID pDisconnectInformation,
    IN ULONG DisconnectFlags
    );

NTSTATUS
UlpCloseRawConnection(
    IN PVOID pConnection,
    IN BOOLEAN AbortiveDisconnect,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpSendRawData(
    IN PVOID pObject,
    IN PMDL pMdlChain,
    IN ULONG Length,
    PUL_IRP_CONTEXT pIrpContext
    );

NTSTATUS
UlpReceiveRawData(
    IN PVOID                  pConnectionContext,
    IN PVOID                  pBuffer,
    IN ULONG                  BufferLength,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID                  pCompletionContext
    );

NTSTATUS
UlpDummyReceiveHandler(
    IN PVOID pTdiEventContext,
    IN PVOID ConnectionContext,
    IN PVOID pTsdu,
    IN ULONG BytesIndicated,
    IN ULONG BytesUnreceived,
    OUT ULONG *pBytesTaken
    );

NTSTATUS
UlpReceiveHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    );

NTSTATUS
UlpReceiveExpeditedHandler(
    IN PVOID pTdiEventContext,
    IN CONNECTION_CONTEXT ConnectionContext,
    IN ULONG ReceiveFlags,
    IN ULONG BytesIndicated,
    IN ULONG BytesAvailable,
    OUT ULONG *pBytesTaken,
    IN PVOID pTsdu,
    OUT PIRP *pIrp
    );

NTSTATUS
UlpRestartAccept(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpRestartSendData(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpReferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint
    OWNER_REFERENCE_DEBUG_FORMAL_PARAMS
    );

VOID
UlpDereferenceEndpoint(
    IN PUL_ENDPOINT pEndpoint
    OWNER_REFERENCE_DEBUG_FORMAL_PARAMS
    );

#if REFERENCE_DEBUG
# define REFERENCE_ENDPOINT(endp, action, sig, powner, pprefowner, monoid)  \
    UlpReferenceEndpoint( (endp), (powner), (pprefowner), (sig),            \
                          action, monoid, (PSTR)__FILE__,(USHORT)__LINE__)

# define DEREFERENCE_ENDPOINT(endp, action, sig, powner, pprefowner, monoid)\
    UlpDereferenceEndpoint( (endp), (powner), (pprefowner), (sig),          \
                            action, monoid, (PSTR)__FILE__,(USHORT)__LINE__)
#else // !REFERENCE_DEBUG
# define REFERENCE_ENDPOINT(endp, action, sig, powner, pprefowner, monoid)   \
    UlpReferenceEndpoint( (endp) )

# define DEREFERENCE_ENDPOINT(endp, action, sig, powner, pprefowner, monoid) \
    UlpDereferenceEndpoint( (endp) )
#endif // !REFERENCE_DEBUG

#define REFERENCE_ENDPOINT_SELF(endp, action)               \
    REFERENCE_ENDPOINT(                                     \
        (endp),                                             \
        (action),                                           \
        UL_ENDPOINT_SIGNATURE,                              \
        (endp),                                             \
        &(endp)->pEndpointRefOwner,                         \
        -1)

#define DEREFERENCE_ENDPOINT_SELF(endp, action)             \
    DEREFERENCE_ENDPOINT(                                   \
        (endp),                                             \
        (action),                                           \
        UL_ENDPOINT_SIGNATURE,                              \
        (endp),                                             \
        &(endp)->pEndpointRefOwner,                         \
        -1)

#define REFERENCE_ENDPOINT_CONNECTION(endp, action, pconn)  \
    REFERENCE_ENDPOINT(                                     \
        (endp),                                             \
        (action),                                           \
        UL_CONNECTION_SIGNATURE,                            \
        (pconn),                                            \
        &(pconn)->pConnRefOwner,                            \
        (pconn)->MonotonicId)

#define DEREFERENCE_ENDPOINT_CONNECTION(endp, action, pconn)\
    DEREFERENCE_ENDPOINT(                                   \
        (endp),                                             \
        (action),                                           \
        UL_CONNECTION_SIGNATURE,                            \
        (pconn),                                            \
        &(pconn)->pConnRefOwner,                            \
        (pconn)->MonotonicId)

VOID
UlpEndpointCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpCleanupConnectionId(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
UlpConnectionCleanupWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpAssociateConnection(
    IN PUL_CONNECTION pConnection,
    IN PUL_ENDPOINT pEndpoint
    );

NTSTATUS
UlpDisassociateConnection(
    IN PUL_CONNECTION pConnection
    );

VOID
UlpReplenishEndpoint(
    IN PUL_ENDPOINT pEndpoint
    );

VOID
UlpReplenishEndpointWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

BOOLEAN
UlpDecrementIdleConnections(
    IN PUL_ENDPOINT pEndpoint
    );

BOOLEAN
UlpIncrementIdleConnections(
    IN PUL_ENDPOINT pEndpoint,
    IN BOOLEAN Replenishing
    );

VOID
UlpClearReplenishScheduledFlag(
    IN PUL_ENDPOINT pEndpoint
    );

NTSTATUS
UlpCreateConnection(
    IN PUL_ENDPOINT pEndpoint,
    IN ULONG AddressLength,
    OUT PUL_CONNECTION *ppConnection
    );

NTSTATUS
UlpInitializeConnection(
    IN PUL_CONNECTION pConnection
    );

UL_CONNECTION_FLAGS
UlpSetConnectionFlag(
    IN OUT PUL_CONNECTION pConnection,
    IN LONG NewFlag
    );

NTSTATUS
UlpBeginDisconnect(
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpRestartDisconnect(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpBeginAbort(
    IN PUL_CONNECTION pConnection,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlpRestartAbort(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpRemoveFinalReference(
    IN PUL_CONNECTION pConnection,
    IN UL_CONNECTION_FLAGS Flags
    );

NTSTATUS
UlpRestartReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpRestartClientReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

NTSTATUS
UlpDisconnectAllActiveConnections(
    IN PUL_ENDPOINT pEndpoint
    );

VOID
UlpUnbindConnectionFromEndpoint(
    IN PUL_CONNECTION pConnection
    );

VOID
UlpSynchronousIoComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );

NTSTATUS
UlpUrlToAddress(
    IN PWSTR pSiteUrl,
    OUT PTA_IP_ADDRESS pAddress,
    OUT PBOOLEAN pSecure
    );

PUL_ENDPOINT
UlpFindEndpointForAddress(
    IN PTRANSPORT_ADDRESS pAddress,
    IN ULONG AddressLength
    );

NTSTATUS
UlpSetNagling(
    IN PUX_TDI_OBJECT pTdiObject,
    IN BOOLEAN Flag
    );

NTSTATUS
UlpRestartQueryAddress(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID pContext
    );

VOID
UlpCleanupEarlyConnection(
    IN PUL_WORK_ITEM pWorkItem
    );

NTSTATUS
UlpQueryTcpFastSend();

NTSTATUS
UlpBuildTdiReceiveBuffer(
    IN PUX_TDI_OBJECT pTdiObject,
    IN PUL_CONNECTION pConnection,
    OUT PIRP *pIrp
    );

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _ULTDIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\connid.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    connid.h

Abstract:

    This module contains declarations for manipulating
    UL_HTTP_CONNECTION_IDs.

Author:

    Keith Moore (keithmo)       05-Aug-1998

Revision History:

--*/


#ifndef _CONNID_H_
#define _CONNID_H_


NTSTATUS
InitializeConnIdTable(
    VOID
    );

VOID
TerminateConnIdTable(
    VOID
    );

NTSTATUS
UlAllocateHttpConnectionID(
    IN PHTTP_CONNECTION pHttpConnection
    );

PHTTP_CONNECTION
UlFreeHttpConnectionID(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    );

PHTTP_CONNECTION
UlGetHttpConnectionFromID(
    IN UL_HTTP_CONNECTION_ID ConnectionID
    );


#endif  // _CONNID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\nsgo.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    nsgo.h

Abstract:

    Contains public name space group object declarations.

Author:

    Henry Sanders (henrysa)       22-Jun-1998

Revision History:

--*/

#ifndef _NSGO_H_
#define _NSGO_H_

typedef struct _NAME_SPACE_URL_ENTRY    // NSUE
{
    LIST_ENTRY              List;
    SIZE_T                  URLLength;
    UCHAR                   URL[ANYSIZE_ARRAY];

} NAME_SPACE_URL_ENTRY, *PNAME_SPACE_URL_ENTRY;


NTSTATUS
DeliverRequestToProcess(
    IN  PHTTP_CONNECTION        pHttpConn,
    IN  PHTTP_URL_MAP_ENTRY     pMapEntry,
    IN  PUCHAR                  pBuffer,
    IN  SIZE_T                  BufferLength,
    OUT SIZE_T                  *pBytesTaken
    );


NTSTATUS
UlCreateNameSpaceGroupObject(
    IN  PWCHAR                  pName,
    IN  SIZE_T                  NameLength
    );

NTSTATUS
UlAddURLToNameSpaceGroup(
    IN  PWCHAR                  pName,
    IN  SIZE_T                  NameLength,
    IN  PTRANSPORT_ADDRESS      pAddress,
    IN  PUCHAR                  pHostName,
    IN  SIZE_T                  HostNameLength,
    IN  PUCHAR                  pURL,
    IN  SIZE_T                  URLLength
    );

NTSTATUS
UlBindToNameSpaceGroup(
    IN  PWCHAR                  pName,
    IN  SIZE_T                  NameLength,
    OUT PVOID                   *pFileContext
    );

NTSTATUS
UlUnbindFromNameSpaceGroup(
    IN PVOID pFileContext
    );

NTSTATUS
UlReceiveHttpRequest(
    IN  PVOID                   pFileContext,
    IN  PIRP                    pIRP
    );

NTSTATUS
InitializeNSGO(
    VOID
    );

VOID
TerminateNSGO(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\nsgop.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    nsgop.h

Abstract:

    Contains private name space group object declarations.

Author:

    Henry Sanders (henrysa)       22-Jun-1998

Revision History:

--*/

#if !defined(_NSGOP_H_) && 0
#define _NSGOP_H_


//
// The structure of a name space virtual host entry.
//
typedef struct _NAME_SPACE_HOST_ENTRY       // NSHE
{
    LIST_ENTRY          List;               // Linkage
    VIRTUAL_HOST_ID     HostID;             // Identifier of virtual host.
    LIST_ENTRY          URLList;            // List of URLs on this VH.

} NAME_SPACE_HOST_ENTRY, *PNAME_SPACE_HOST_ENTRY;

//
// The structure of a name space group object.
//
typedef struct _NAME_SPACE_GROUP_OBJECT     // NSGO
{
    ERESOURCE           Resource;           // Resource which protects this
                                            // NSGO. It protects the fields
                                            // that are not accessed at DPC
                                            // time, except for the
                                            // NameSpaceLinkage field, which
                                            // is protected by the global
                                            // name space table resource.
                                            //
    SIZE_T              RefCount;           // Reference count for this NSGO.
                                            //
    SIZE_T              ProcessCount;       // Number of name space processes
                                            // bound to this NSGO.
    LIST_ENTRY          ProcessList;        // List of processes on this NSGO.
                                            //
    LIST_ENTRY          VirtHostList;       // List of virtual hosts in this
                                            // name space group.
                                            //
    PHTTP_URL_MAP_ENTRY pURLMapEntries;     // List of URL map entries.

    LIST_ENTRY          NameSpaceLinkage;   // Linkage on name space list.

    UL_SPIN_LOCK        SpinLock;           // Lock for this NSGO. This lock
                                            // protects the fields which follow
                                            // it (except for the name and name
                                            // length).
    SIZE_T              NameSpaceValid:1;   // Set to TRUE as long as this name
                                            // NSGO is valid.
    LIST_ENTRY          PendingRequestList; // List of pending requests.

    SIZE_T              NameLength;         // Length of name.
    WCHAR               Name[ANYSIZE_ARRAY]; // Name of this NSGO.

} NAME_SPACE_GROUP_OBJECT, *PNAME_SPACE_GROUP_OBJECT;

//
// The structure representing a process bound to a name space group.
//
typedef struct _NAME_SPACE_PROCESS              // NSP
{
    PNAME_SPACE_GROUP_OBJECT    pParentNSGO;    // NSGO of which this process
                                                // is a member.
    LIST_ENTRY                  List;           // Entry on process list.
    LIST_ENTRY                  PendingIRPs;    // List of pending IRPs.

} NAME_SPACE_PROCESS, *PNAME_SPACE_PROCESS;

//
// Structure of a pending request.
//
typedef struct _PENDING_HTTP_REQUEST        // PendReq
{
    LIST_ENTRY          List;               // Linkage.
    ULONG               RequestSize;        // Total size of request.
    UL_HTTP_REQUEST     Request;            // The request itself. This must
                                            // be the last thing in the
                                            // structure.

} PENDING_HTTP_REQUEST, *PPENDING_HTTP_REQUEST;

VOID
CopyRequestToBuffer(
    PHTTP_CONNECTION            pHttpConn,
    PUCHAR                      pBuffer,
    SIZE_T                      BufferLength,
    PUCHAR                      pEntityBody,
    SIZE_T                      EntityBodyLength
    );

PIRP
FindIRPOnNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNSGO
    );

NTSTATUS
AddNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNSGO
    );

PNAME_SPACE_GROUP_OBJECT
FindAndReferenceNSGO(
    PWCHAR                      pName,
    SIZE_T                      NameLength)
    ;

VOID
DereferenceNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNSGO
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\sendbuffer.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sendbuffer.c

Abstract:

    This module implements the buffered send package.

Author:

    Keith Moore (keithmo)       14-Aug-1998

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//


//
// Private prototypes.
//


//
// Private globals.
//


#ifdef ALLOC_PRAGMA
#pragma alloc_text( PAGE, UlBufferedSendFile )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlInitializeSendBuffer
NOT PAGEABLE -- UlBufferedSendData
NOT PAGEABLE -- UlFlushSendBuffer
NOT PAGEABLE -- UlCleanupSendBuffer
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Initializes a send buffer.

Arguments:

    pSendBuffer - Supplies the MDL_SEND_BUFFER to initialize.

    pConnection - Supplies the UL_CONNECTION to associate with the
        send buffer.

--***************************************************************************/
VOID
UlInitializeSendBuffer(
    OUT PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_CONNECTION pConnection
    )
{
    pSendBuffer->pConnection = pConnection;
    pSendBuffer->pMdlChain = NULL;
    pSendBuffer->pMdlLink = &pSendBuffer->pMdlChain;
    pSendBuffer->BytesBuffered = 0;

}   // UlInitializeSendBuffer


/***************************************************************************++

Routine Description:

    Initiates a send on the specified send buffer. If possible, new MDLs
    are created and linked onto the buffer's MDL chain and the send is
    deferred.

Arguments:

    pSendBuffer - Supplies the MDL_SEND_BUFFER to send.

    pMdlChain - Supplies a pointer to a MDL chain describing the
        data buffers to send.

    ForceFlush - Supplies TRUE if the buffer should be always be
        flushed. In other words, a send will always be initiated
        regardless of the amount of data buffered. Supplies FALSE
        if the incoming MDL should be linked onto the MDL chain
        for a deferred send, if possible.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the send is complete.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status. Will be STATUS_SUCCESS if the buffer
        was simply linked onto the MDL chain for a deferred send. In this
        case, the completion routine will NOT be called.

--***************************************************************************/
NTSTATUS
UlBufferedSendData(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PMDL pMdl,
    IN BOOLEAN ForceFlush,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;
    ULONG mdlLength;
    PMDL pMdlClone;
    PVOID pMdlAddress;

    //
    // Determine the size of the incoming MDL and update the number
    // of bytes we've buffered so far.
    //

    mdlLength = UlGetMdlChainByteCount( pMdl );
    pSendBuffer->BytesBuffered += mdlLength;

    //
    // If we've exceeded the max buffer threshold, or if the caller
    // is forcing a flush, then chain the incoming MDL onto the MDL
    // chain and initiate a send.
    //
    // CODEWORK: To make life easier, I'll also flush if the incoming
    // MDL is actually the head of a MDL chain. As an optimization,
    // it may be worth the effort to clone & attach the chain.
    //

    if (pSendBuffer->BytesBuffered >= MAX_SEND_BUFFER ||
        ForceFlush ||
        pMdl->Next != NULL)
    {
        (*pSendBuffer->pMdlLink) = pMdl;

        status = UlFlushSendBuffer(
                        pSendBuffer,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }
    else
    {
        //
        // Clone the incoming MDL, then link it onto the chain.
        //

        ASSERT( pMdl->Next == NULL );
        pMdlClone = UlCloneMdl( pMdl );

        if (pMdlClone != NULL)
        {
            IF_DEBUG( SEND_BUFFER )
            {
                KdPrint((
                    "UlBufferedSendData: buffering MDL %p [%lu] on %p\n",
                    pMdlClone,
                    mdlLength,
                    pSendBuffer
                    ));
            }

            (*pSendBuffer->pMdlLink) = pMdlClone;
            pSendBuffer->pMdlLink = &pMdlClone->Next;
            status = STATUS_SUCCESS;
        }
        else
        {
            //
            // Couldn't allocate a new MDL.
            //

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return status;

}   // UlBufferedSendData


/***************************************************************************++

Routine Description:

    Initiates a send on the specified file cache entry. If possible, new
    MDLs are created and linked onto the buffer's MDL chain and the send is
    deferred.

Arguments:

    pSendBuffer - Supplies the MDL_SEND_BUFFER to send.

    pFileCacheEntry - Supplies the UL_FILE_CACHE_ENTRY describing the
        file to send.

    pByteRange - Supplies the byte range within the file to send.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the send is complete.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status. Will be STATUS_SUCCESS if the buffer
        was simply linked onto the MDL chain for a deferred send. In this
        case, the completion routine will NOT be called.

--***************************************************************************/
NTSTATUS
UlBufferedSendFile(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry,
    IN PUL_BYTE_RANGE pByteRange,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( IS_VALID_FILE_CACHE_ENTRY( pFileCacheEntry ) );

    return STATUS_NOT_SUPPORTED;    // NYI

}   // UlBufferedSendFile


/***************************************************************************++

Routine Description:

    Flushes any pending MDLs attached to the send buffer.

Arguments:

    pSendBuffer - Supplies the MDL_SEND_BUFFER to flush.

    pCompletionRoutine - Supplies a pointer to a completion routine to
        invoke after the buffer is flushed.

    pCompletionContext - Supplies an uninterpreted context value for the
        completion routine.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlFlushSendBuffer(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    )
{
    NTSTATUS status;
    ULONG bytesBuffered;

    bytesBuffered = pSendBuffer->BytesBuffered;
    pSendBuffer->BytesBuffered = 0;

    IF_DEBUG( SEND_BUFFER )
    {
        KdPrint((
            "UlFlushSendBuffer: flushing %p [%lu]\n",
            pSendBuffer,
            bytesBuffered
            ));
    }

    if (bytesBuffered > 0)
    {
        status = UlSendData(
                        pSendBuffer->pConnection,
                        pSendBuffer->pMdlChain,
                        bytesBuffered,
                        pCompletionRoutine,
                        pCompletionContext,
                        FALSE
                        );
    }
    else
    {
        status = UlInvokeCompletionRoutine(
                        STATUS_SUCCESS,
                        0,
                        pCompletionRoutine,
                        pCompletionContext
                        );
    }

    return status;

}   // UlFlushSendBuffer


/***************************************************************************++

Routine Description:

    Cleans up any MDLs allocated & attached to the send buffer.

Arguments:

    pSendBuffer - Supplies the MDL_SEND_BUFFER to cleanup.

Return Value:

    PMDL - Returns a pointer to the last MDL on the chain, NULL
        if the chain is empty.

--***************************************************************************/
PMDL
UlCleanupSendBuffer(
    IN OUT PMDL_SEND_BUFFER pSendBuffer
    )
{
    PMDL pMdl;
    PMDL pNextMdl;

    IF_DEBUG( SEND_BUFFER )
    {
        KdPrint((
            "UlCleanupSendBuffer: cleaning %p\n",
            pSendBuffer
            ));
    }

    //
    // Walk the MDL chain and free all *except* the last one.
    // (The last MDL attached to the chain was not one of the clones
    // we allocated, it's a 'client' MDL. It's the client code's
    // responsibility to free it appropriately.)
    //

    pMdl = pSendBuffer->pMdlChain;

    while (TRUE)
    {
        pNextMdl = pMdl->Next;

        if (pNextMdl == NULL)
        {
            break;
        }

        IoFreeMdl( pMdl );
        pMdl = pNextMdl;
    }

    return pMdl;

}   // UlCleanupSendBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\sendbuffer.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    sendbuffer.h

Abstract:

    This module contains declarations for buffering deferred send MDLs.

Author:

    Keith Moore (keithmo)       14-Aug-1998

Revision History:

--*/


#ifndef _SENDBUFFER_H_
#define _SENDBUFFER_H_


//
// This structure contains the data necessary to buffer deferred sends.
// As sends are initiated, the MDLs are linked onto an internal MDL
// chain. Once the number of buffer bytes exceeds a threshold, a
// "real" send is initiated.
//

typedef struct _MDL_SEND_BUFFER
{
    //
    // The connection we're buffering the sends for.
    //

    PUL_CONNECTION pConnection;

    //
    // The head of the MDL chain.
    //

    PMDL pMdlChain;

    //
    // The target for the next MDL to be linked onto the chain.
    //

    PMDL *pMdlLink;

    //
    // The number of bytes buffered so far.
    //

    ULONG BytesBuffered;

} MDL_SEND_BUFFER, *PMDL_SEND_BUFFER;


//
// The maximum number of bytes we'll buffer at a time.
//

#define MAX_SEND_BUFFER (32 * 1024)


VOID
UlInitializeSendBuffer(
    OUT PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_CONNECTION pConnection
    );

NTSTATUS
UlBufferedSendData(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PMDL pMdl,
    IN BOOLEAN ForceFlush,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlBufferedSendFile(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_FILE_CACHE_ENTRY pFileCacheEntry,
    IN PUL_BYTE_RANGE pByteRange,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

NTSTATUS
UlFlushSendBuffer(
    IN PMDL_SEND_BUFFER pSendBuffer,
    IN PUL_COMPLETION_ROUTINE pCompletionRoutine,
    IN PVOID pCompletionContext
    );

PMDL
UlCleanupSendBuffer(
    IN OUT PMDL_SEND_BUFFER pSendBuffer
    );


#endif  // _SENDBUFFER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\tditest.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tditest.h

Abstract:

    This module defines the interface to the (temporary) TDI test module.

Author:

    Keith Moore (keithmo)       19-Jun-1998

Revision History:

--*/


#ifndef _TDITEST_H_
#define _TDITEST_H_


NTSTATUS
UlInitializeTdiTest(
    VOID
    );

VOID
UlTerminateTdiTest(
    VOID
    );


#endif  // _TDITEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\urlmap.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    urlmap.c

Abstract:

    Contains the URL map code.

Author:

    Henry Sanders (henrysa)       21-Jun-1998

Revision History:

--*/

#include    "precomp.h"
#include    "urlmapp.h"

#if 0

/******************************************************************************

Routine Description:

    The URL map lookup routine. This routine is called with the URL map header
    referenced, so the URL map can be examined without locks.

    The current algorithm is a linear search. This is temporary until we get
    something running, at which point we'll move to a more sophisticated
    algorithm, probably some variation on an alphabetic trie.

Arguments:

    pHttpConn       - Pointer to HTTP connection on which data was received.
    pMapHeader      - Pointer to the URL map header to be searched.

Return Value:

    A pointer to the map entry if we find one, or NULL if we don't.

******************************************************************************/

PHTTP_URL_MAP_ENTRY
FindURLMapEntry(
    PHTTP_CONNECTION        pHttpConn,
    PHTTP_URL_MAP_HEADER    pMapHeader
    )
{
    PHTTP_URL_MAP_ENTRY     pCurrentMapEntry;
    PUCHAR                  pURL;
    SIZE_T                  URLLength;

    pURL = pHttpConn->pURL;
    URLLength = pHttpConn->URLLength;

    for (pCurrentMapEntry = pMapHeader->Table.pFirstMapEntry;
         pCurrentMapEntry != NULL;
         pCurrentMapEntry = pCurrentMapEntry->pNextMapEntry
         )
    {
        if (URLLength >= pCurrentMapEntry->URLPrefixLength)
        {
            if (_strnicmp(pURL,
                          pCurrentMapEntry->URLPrefix,
                          pCurrentMapEntry->URLPrefixLength) == 0
               )
            {
                // We have a match, so return it.
                return pCurrentMapEntry;
            }
        }
    }

    return NULL;
}

/******************************************************************************

Routine Description:

    Dereference a URL map. If the reference count goes to 0, we're done with
    this one, so schedule a worker thread to free it.

Arguments:

    pMapHeader      - Pointer to the URL map header to be dereferenced.

Return Value:


******************************************************************************/
VOID
DelayedDereferenceURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    )
{
    if (InterlockedDecrement(&pMapHeader->RefCount) == 0)
    {
        UlQueueWorkItem( &g_UlThreadPool,
                         &pMapHeader->WorkItem,
                         &CleanupURLMapWorker);
    }
}

/******************************************************************************

Routine Description:

    Dereference a URL map. If the reference count goes to 0, we're done with
    this one.

Arguments:

    pMapHeader      - Pointer to the URL map header to be dereferenced.

Return Value:


******************************************************************************/
VOID
DereferenceURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    )
{
    if (InterlockedDecrement(&pMapHeader->RefCount) == 0)
    {
        DeleteURLMapHeader(pMapHeader);
    }
}

/******************************************************************************

Routine Description:

    Cleanup a URL map in thread context. All we do is call delete URL
    map routine.

Arguments:

   pWorkItem    - Supplies a pointer to the work item queued. This should point
                    to the WORK_ITEM structure embedded in a URL map header.

Return Value:


******************************************************************************/
VOID
CleanupURLMapWorker(
    IN PUL_WORK_ITEM pWorkItem
    )
{
    PHTTP_URL_MAP_HEADER    pMapHeader;

    pMapHeader = CONTAINING_RECORD(
                    pWorkItem,
                    HTTP_URL_MAP_HEADER,
                    WorkItem
                    );

    DeleteURLMapHeader(pMapHeader);
}

/******************************************************************************

Routine Description:

    Delete a URL map header.

Arguments:

    pMapHeader      - Pointer to the URL map header to be deleted.

Return Value:


******************************************************************************/
VOID
DeleteURLMapHeader(
    PHTTP_URL_MAP_HEADER    pMapHeader
    )

{
    ASSERT(pMapHeader->RefCount == 0);

    // BUGBUG Not done yet! Need to walk the map, dereferenceing the NSGO
    // we're pointing at.
    KdPrint(("DeleteURLMapHeader: Not really deleting, leaking memory instead.\n"));

}

/******************************************************************************

Routine Description:

    Create a URL map header.

Arguments:



Return Value:

    Pointer to the newly created URL map header, or NULL if we couldn't create
    one.


******************************************************************************/
PHTTP_URL_MAP_HEADER
CreateURLMapHeader(
    VOID
    )
{
    PHTTP_URL_MAP_HEADER        pMapHeader;

    pMapHeader = UL_ALLOCATE_POOL(NonPagedPool,
                                  sizeof(HTTP_URL_MAP_HEADER),
                                  UL_URLMAP_POOL_TAG
                                  );

    if (pMapHeader == NULL)
    {
        return NULL;
    }

    pMapHeader->RefCount = 1;
    pMapHeader->EntryCount = 0;
    pMapHeader->Table.pFirstMapEntry = NULL;

    return pMapHeader;
}

/******************************************************************************

Routine Description:

    Add an entry to a URL map. We copy the existing map, add our entry to
    the copy, then swap the new copy in.

Arguments:

    pVirtHostID             - Pointer to virtual host ID identifying the virtual
                                host on which to set the URL map.
    pNewURL                 - Pointer to new name space URL entry to be added.
    pNSGO                   - Pointer to NSGO of which the new entry is a member.
    pStatus                 - Where to return the status of the attempt.



Return Value:

    The number of entries in the newly created map table, or 0 if the set failed.
    Also, *pStatus is set with the status of the attempt.

******************************************************************************/
SIZE_T
AddURLMapEntry(
    PVIRTUAL_HOST_ID            pVirtHostID,
    PNAME_SPACE_URL_ENTRY       pNewURL,
    PNAME_SPACE_GROUP_OBJECT    pNSGO,
    NTSTATUS                    *pStatus
    )
{
    PHTTP_URL_MAP_HEADER    pMapHeader;
    PHTTP_URL_MAP_HEADER    pNewMapHeader;
    PHTTP_URL_MAP_ENTRY     pNewMapEntry;
    PHTTP_URL_MAP_ENTRY     pPrevMapEntry;
    PVIRTUAL_HOST           pVirtHost;
    SIZE_T                  URLMapCount;

    // Allocate a new map entry now and fill it in.
    pNewMapEntry = UL_ALLOCATE_POOL( NonPagedPool,
                                     FIELD_OFFSET(HTTP_URL_MAP_ENTRY,
                                                    URLPrefix) +
                                     pNewURL->URLLength,
                                     UL_URLMAP_POOL_TAG
                                     );

    if (pNewMapEntry == NULL)
    {
        *pStatus = STATUS_INSUFFICIENT_RESOURCES;
        return 0;

    }

    pNewMapEntry->pNSGO = pNSGO;
    pNewMapEntry->URLPrefixLength = pNewURL->URLLength;
    RtlCopyMemory(pNewMapEntry->URLPrefix, pNewURL->URL, pNewURL->URLLength);

    //
    // Now lock the virtual host from other updates.
    //
    pVirtHost = AcquireVirtualHostUpdateResource(pVirtHostID);

    if (pVirtHost == NULL)
    {
        // Virtual host must have gone away, somehow.

        UL_FREE_POOL( pNewMapEntry, UL_URLMAP_POOL_TAG);

        *pStatus = STATUS_INVALID_DEVICE_REQUEST;
        return 0;
    }

    //
    // Copy the existing map. No need to interlock this specially, no one else
    // can modify it while we've got the update resource.
    //

    pMapHeader = GetURLMapFromVirtualHost(pVirtHost);

    if (pMapHeader != NULL)
    {
        pNewMapHeader = CopyURLMap(pMapHeader);

        // If we managed to copy it, add our new map entry.
        if (pNewMapHeader != NULL)
        {
            pPrevMapEntry = CONTAINING_RECORD(
                                &pNewMapHeader->Table.pFirstMapEntry,
                                HTTP_URL_MAP_ENTRY,
                                pNextMapEntry
                                );

            // Loop through until we find an entry with a shorter prefix
            // then ours, or the next entry is NULL, and insert ourselves
            // before that.

            while (pPrevMapEntry->pNextMapEntry != NULL)
            {
                if (pPrevMapEntry->pNextMapEntry->URLPrefixLength <
                    pNewURL->URLLength)
                {
                    break;
                }

                pPrevMapEntry = pPrevMapEntry->pNextMapEntry;
            }

            pNewMapEntry->pNextMapEntry = pPrevMapEntry->pNextMapEntry;
            pPrevMapEntry->pNextMapEntry = pNewMapEntry;

            // Update the count.
            pNewMapHeader->EntryCount++;

            URLMapCount = pNewMapHeader->EntryCount;

        }
        else
        {
            // Couldn't copy it.

            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
            URLMapCount =  0;
        }
    }
    else
    {
        pNewMapHeader = CreateURLMapHeader();
        if (pNewMapHeader == NULL)
        {
            // Couldn't create it.
            *pStatus = STATUS_INSUFFICIENT_RESOURCES;
            URLMapCount =  0;
        }

        pNewMapEntry->pNextMapEntry = NULL;
        pNewMapHeader->Table.pFirstMapEntry = pNewMapEntry;
        pNewMapHeader->EntryCount = 1;
        URLMapCount = 1;
    }

    if (URLMapCount != 0)
    {
        UpdateURLMapTable(pVirtHost, pVirtHostID, pNewMapHeader);
        *pStatus = STATUS_SUCCESS;
    }


    ReleaseVirtualHostUpdateResource(pVirtHost, pVirtHostID);

    if (URLMapCount == 0)
    {
        UL_FREE_POOL( pNewMapEntry, UL_URLMAP_POOL_TAG);
    }

    return URLMapCount;

}

/******************************************************************************

Routine Description:

    Copy a URL map.

Arguments:

    pMapHeader              - Pointer to URL map header for URL map to be
                                copied.


Return Value:

    A pointer to the newly created URL map, or NULL if we couldn't copy
    it.

******************************************************************************/
PHTTP_URL_MAP_HEADER
CopyURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    )
{
    PHTTP_URL_MAP_HEADER    pNewMapHeader;
    PHTTP_URL_MAP_ENTRY     pPreviousMapEntry;
    PHTTP_URL_MAP_ENTRY     pCurrentMapEntry;
    PHTTP_URL_MAP_ENTRY     pNewMapEntry;

    pNewMapHeader = CreateURLMapHeader();

    if (pNewMapHeader == NULL)
    {
        return NULL;
    }

    // Walk down the passed in table. For each element in the table, allocate
    // a new one and stick it on.

    pPreviousMapEntry = CONTAINING_RECORD( &pNewMapHeader->Table.pFirstMapEntry,
                                            HTTP_URL_MAP_ENTRY,
                                            pNextMapEntry
                                            );

    pCurrentMapEntry = pMapHeader->Table.pFirstMapEntry;

    while (pCurrentMapEntry != NULL)
    {
        SIZE_T          CurrentMapEntrySize;

        CurrentMapEntrySize = FIELD_OFFSET(HTTP_URL_MAP_ENTRY, URLPrefix) +
                                pCurrentMapEntry->URLPrefixLength;

        pNewMapEntry = UL_ALLOCATE_POOL(
                        NonPagedPool,
                        CurrentMapEntrySize,
                        UL_URLMAP_POOL_TAG
                        );

        if (pNewMapEntry == NULL)
        {
            PHTTP_URL_MAP_ENTRY     pNextMapEntry;
            // Ran out of resources. Free what we've allocated to far.
            //
            pCurrentMapEntry = pNewMapHeader->Table.pFirstMapEntry;

            while (pCurrentMapEntry != NULL)
            {
                pNextMapEntry = pCurrentMapEntry->pNextMapEntry;
                UL_FREE_POOL(pCurrentMapEntry, UL_URLMAP_POOL_TAG);
                pCurrentMapEntry = pNextMapEntry;
            }
            UL_FREE_POOL(pNewMapHeader, UL_URLMAP_POOL_TAG);
            return NULL;

        }

        // Allocated the memory, copy the old stuff over and link the new
        // entry on.
        //
        RtlCopyMemory(pNewMapEntry, pCurrentMapEntry, CurrentMapEntrySize);

        pPreviousMapEntry->pNextMapEntry = pNewMapEntry;
        pNewMapEntry->pNextMapEntry = NULL;
        pNewMapHeader->EntryCount++;

        pPreviousMapEntry = pNewMapEntry;

        pCurrentMapEntry = pCurrentMapEntry->pNextMapEntry;


    }

    return pNewMapHeader;


}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\nsgo.c ===
/******************************************************************************

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    nsgo.c

Abstract:

    Contains the name space group object code.

Author:

    Henry Sanders (henrysa)       22-Jun-1998

Revision History:

******************************************************************************/


#include "precomp.h"
#include "nsgop.h"

#if 0   // obsolete

ERESOURCE       NameSpaceListResource;

LIST_ENTRY      NameSpaceList;

/******************************************************************************

Routine Description:

    Copy an HTTP request to a buffer.

Arguments:

    pHttpConn           - Pointer to connection for this request.
    pBuffer             - Pointer to buffer where we'll copy.
    BufferLength        - Length of pBuffer.
    pEntityBody         - Pointer to entity body of request.
    EntityBodyLength    - Length of entity body.

Return Value:


******************************************************************************/

VOID
CopyRequestToBuffer(
    PHTTP_CONNECTION        pHttpConn,
    PUCHAR                  pBuffer,
    SIZE_T                  BufferLength,
    PUCHAR                  pEntityBody,
    SIZE_T                  EntityBodyLength
    )
{
    PUL_HTTP_REQUEST            pHttpRequest;
    PUL_HTTP_HEADER             pCurrentHeader;
    PUL_UNKNOWN_HTTP_HEADER     pUserCurrentUnknownHeader;
    PUCHAR                      pCurrentBufferPtr;
    ULONG                       i;
    ULONG                       unknownHeaderCount;

    //
    // Set up our pointers to the UL_HTTP_REQUEST structure, the
    // header arrays we're going to fill in, and the pointer to
    // where we're going to start filling them in.
    //
    pHttpRequest = (PUL_HTTP_REQUEST)pBuffer;

    pCurrentHeader = (PUL_HTTP_HEADER)(pHttpRequest + 1);
    pUserCurrentUnknownHeader =
        (PUL_UNKNOWN_HTTP_HEADER)(pCurrentHeader + pHttpConn->KnownHeaderCount);

    pCurrentBufferPtr =
        (PUCHAR)(pUserCurrentUnknownHeader + pHttpConn->UnknownHeaderCount);

    // Now fill in the HTTP request structute.
    //

    pHttpRequest->ReceiveSequenceNumber = pHttpConn->NextRecvNumber;

    pHttpRequest->ConnectionID = pHttpConn->ConnectionID;

    // Set the verb, including copying the raw verb if needed.

    pHttpRequest->Verb = pHttpConn->Verb;

    //
    // Set the entity body length to 0, for now.
    //
    // BUGBUG: Copy entity body if possible!
    //

    pHttpRequest->EntityBodyLength = 0;

    if (pHttpConn->Verb == UnknownVerb)
    {
        // Need to copy in the raw verb for the client.

        pHttpRequest->VerbLength = pHttpConn->RawVerbLength;
        pHttpRequest->VerbOffset = pCurrentBufferPtr - pBuffer;

        memcpy(pCurrentBufferPtr, pHttpConn->pRawVerb, pHttpConn->RawVerbLength);

        pCurrentBufferPtr += pHttpConn->RawVerbLength;
    }

    // Copy the raw and canonicalized URLs.

    pHttpRequest->RawURLLength = pHttpConn->RawURLLength;
    pHttpRequest->RawURLOffset = pCurrentBufferPtr - pBuffer;

    memcpy(pCurrentBufferPtr, pHttpConn->pRawURL, pHttpConn->RawURLLength);

    pCurrentBufferPtr += pHttpConn->RawURLLength;

    pHttpRequest->URLLength = pHttpConn->URLLength;
    pHttpRequest->URLOffset = pCurrentBufferPtr - pBuffer;

    memcpy(pCurrentBufferPtr, pHttpConn->pURL, pHttpConn->URLLength);

    pCurrentBufferPtr += pHttpConn->URLLength;

    // Copy in the known headers.

    pHttpRequest->KnownHeaderCount = pHttpConn->KnownHeaderCount;
    pHttpRequest->KnownHeaderOffset = (PCHAR)pCurrentHeader - pBuffer;

    // Loop through the known header array in the HTTP connection,
    // and copy any that we have.

    for (i = 0; i < MaxHeaderID; i++)
    {
        if (pHttpConn->Headers[i].Valid)
        {
            // Have a header here we need to copy in.

            pCurrentHeader->HeaderID = (HTTP_HEADER_ID)i;
            pCurrentHeader->HeaderLength = pHttpConn->Headers[i].HeaderLength;
            pCurrentHeader->HeaderOffset = pCurrentBufferPtr - pBuffer;

            memcpy(pCurrentBufferPtr,
                    pHttpConn->Headers[i].pHeader,
                    pHttpConn->Headers[i].HeaderLength);

            // Update the current buffer pointer and current header
            // pointer.
            pCurrentBufferPtr += pHttpConn->Headers[i].HeaderLength;

            pCurrentHeader++;

            // Free the header value buffer if needed, and set the
            // header ID back to unknown.
            //
            if (pHttpConn->Headers[i].OurBuffer)
            {
                UL_FREE_POOL( pHttpConn->Headers[i].pHeader,
                                UL_REGISTRY_DATA_POOL_TAG );

                pHttpConn->Headers[i].OurBuffer = FALSE;
                pHttpConn->HeaderBufferOwnedCount--;
            }

            pHttpConn->Headers[i].Valid = FALSE;

        }
    }

    ASSERT((PUCHAR)pCurrentHeader == (PUCHAR)pUserCurrentUnknownHeader);

    //
    // Now loop through the unknown headers, and copy them in.
    //

    unknownHeaderCount = 0;
    pHttpRequest->UnknownHeaderOffset = (PCHAR)pUserCurrentUnknownHeader - pBuffer;

    while (!IsListEmpty(&pHttpConn->UnknownHeaderList))
    {
        PHTTP_UNKNOWN_HEADER        pUnknownHeader;
        PLIST_ENTRY                 pListEntry;

        unknownHeaderCount++;
        pListEntry = RemoveHeadList(&pHttpConn->UnknownHeaderList);

        pUnknownHeader = CONTAINING_RECORD(
                            pListEntry,
                            HTTP_UNKNOWN_HEADER,
                            List
                            );

        // First copy in the header name.
        //
        pUserCurrentUnknownHeader->HeaderNameLength =
            pUnknownHeader->HeaderNameLength;
        pUserCurrentUnknownHeader->HeaderNameOffset =
            pCurrentBufferPtr - pBuffer;

        memcpy(pCurrentBufferPtr,
                pUnknownHeader->pHeaderName,
                pUnknownHeader->HeaderNameLength);

        pCurrentBufferPtr += pUnknownHeader->HeaderNameLength;

        //
        // Now copy in the header value.

        pUserCurrentUnknownHeader->HeaderLength =
            pUnknownHeader->HeaderValue.HeaderLength;

        pUserCurrentUnknownHeader->HeaderOffset =
            pCurrentBufferPtr - pBuffer;

        memcpy(pCurrentBufferPtr,
                pUnknownHeader->HeaderValue.pHeader,
                pUnknownHeader->HeaderValue.HeaderLength);

        pCurrentBufferPtr += pUnknownHeader->HeaderValue.HeaderLength;

        pUserCurrentUnknownHeader++;

        // Free the unknown header structure now, as well as the pointer
        // (if needed).
        //
        if (pUnknownHeader->HeaderValue.OurBuffer)
        {
            UL_FREE_POOL( pUnknownHeader->HeaderValue.pHeader,
                            UL_REGISTRY_DATA_POOL_TAG );

            pUnknownHeader->HeaderValue.OurBuffer = FALSE;
        }

        UL_FREE_POOL( pUnknownHeader, UL_REGISTRY_DATA_POOL_TAG );
    }

    pHttpRequest->UnknownHeaderCount = unknownHeaderCount;

}

/******************************************************************************

Routine Description:

    Find a pending IRP to deliver a request to. This routine must
    be called with the lock on the NSGO held.

Arguments:

    pNSGO               - Name space group object to be searched for
                            an IRP.

Return Value:

    A pointer to an IRP if we've found one, or NULL if we didn't.


******************************************************************************/
PIRP
FindIRPOnNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNSGO
    )
{
    PLIST_ENTRY                 pListEntry;
    PNAME_SPACE_PROCESS         pDeliverNSP;
    PIRP                        pIRP;

    //
    // There's a couple steps to find the IRP. First thing is to select an
    // NSP that might have an IRP, and once we've done that see if it has
    // an IRP. Special case the common scenario where there's only one NSP.
    //

    if (IsListEmpty(&pNSGO->ProcessList))
    {
        return NULL;

    }

    pDeliverNSP = CONTAINING_RECORD(
                    pNSGO->ProcessList.Flink,
                    NAME_SPACE_PROCESS,
                    List
                    );

    if (pNSGO->ProcessCount > 1)
    {

        // Have more than one NSP. Look at the first one.
        // If it has an IRP attached to it, use that NSP, otherwise search for
        // one that has an IRP. We tend to always go to the first one to try
        // and prevent process thrashing.

        // Loop while we haven't found an IRP.

        while (IsListEmpty(&pDeliverNSP->PendingIRPs))
        {

            // Move to the next one.

            pListEntry = pDeliverNSP->List.Flink;

            if (pListEntry == &pNSGO->ProcessList)
            {
                // Got all the way around without finding one, so we're
                // done.
                break;

            }
            //
            // Otherwise should have a valid NSP.

            //
            pDeliverNSP = CONTAINING_RECORD(
                                pListEntry,
                                NAME_SPACE_PROCESS,
                                List
                                );
        }


    }

    // We've got the 'correct' NSP, pull an IRP from it if it has one.

    if (!IsListEmpty(&pDeliverNSP->PendingIRPs))
    {
        // It has one. Pull it off the list and return a pointer to the
        // IRP. Set Flink to NULL so the cancel routine knows this IRP
        // is no longer on the pending list.

        pListEntry = RemoveHeadList(&pDeliverNSP->PendingIRPs);
        pListEntry->Flink = NULL;
        pIRP = CONTAINING_RECORD( pListEntry, IRP, Tail.Overlay.ListEntry );
        return pIRP;
    }
    else
    {
        // No IRPs available, return NULL.

        return NULL;
    }

}


/******************************************************************************

Routine Description:

    Deliver an HTTP request to a user mode process. We take the lock on
    the appropriate NSGO, find a usable name space process, and complete
    an IRP. If there are no pending IRPs we buffer the request to wait
    for one.

    This routine must be called at DPC level.

Arguments:

    pHttpConn           - Pointer to connection on which request was received.
    pMapEntry           - Pointer to URL map table entry which is handling the
                            request.
    pBuffer             - Pointer to any entity body for the request.
    BufferLength        - Length of pBuffer
    BytesTaken          - Returns how many bytes we took.

Return Value:

    Status of attempt to deliver request.

******************************************************************************/

NTSTATUS
DeliverRequestToProcess(
    PHTTP_CONNECTION        pHttpConn,
    PHTTP_URL_MAP_ENTRY     pMapEntry,
    PUCHAR                  pBuffer,
    SIZE_T                  BufferLength,
    SIZE_T                  *pBytesTaken
    )
{
    PNAME_SPACE_GROUP_OBJECT    pNSGO;
    PIRP                        pDeliverIRP;
    ULONG                       UserBufferLength;
    PUCHAR                      pUserBuffer;
    PIO_STACK_LOCATION          pCurrentIRPStack;
    ULONG                       HeaderArraySize;
    ULONG                       SizeNeeded;
    KIRQL                       oldIrql;

    pNSGO = (PNAME_SPACE_GROUP_OBJECT)pMapEntry->pNSGO;

    *pBytesTaken = 0;   // until proven otherwise...

    //
    // BUGBUG: do we always want to reference the connection here?
    // What about failure cases in the code below?
    //

    UlReferenceHttpConnection( pHttpConn );

    //
    // Calculate the size needed for the request, we'll need it below.
    //
    HeaderArraySize = (pHttpConn->KnownHeaderCount * sizeof(UL_HTTP_HEADER)) +
                      (pHttpConn->UnknownHeaderCount *
                        sizeof(UL_UNKNOWN_HTTP_HEADER));

    SizeNeeded = pHttpConn->TotalRequestSize +
                    sizeof(UL_HTTP_REQUEST) +
                    HeaderArraySize;

    // Initialize the IRP to NULL, in case we've already got pending requests.

    pDeliverIRP = NULL;

    UlAcquireSpinLockAtDpcLevel(&pNSGO->SpinLock);


    // If we don't have a list of pending requests queued, see if we can get
    // an IRP to deliver this request.

    if (IsListEmpty(&pNSGO->PendingRequestList))
    {
        // Try and get an IRP from this NSGO.

        pDeliverIRP = FindIRPOnNSGO(pNSGO);

        if (pDeliverIRP != NULL)
        {
            //
            // At this point, we'll do our best to complete the IRP,
            // so we can remove the cancel routine.
            //

            if (IoSetCancelRoutine( pDeliverIRP, NULL ) == NULL)
            {
                //
                // The cancel routine may be running or about to run.
                //

                IoAcquireCancelSpinLock( &oldIrql );
                ASSERT( pDeliverIRP->Cancel );
                IoReleaseCancelSpinLock( oldIrql );
            }
        }
    }

    UlReleaseSpinLockFromDpcLevel(&pNSGO->SpinLock);

    //
    // If we have an IRP, complete it. Otherwise buffer the request.
    //
    if (pDeliverIRP != NULL)
    {
        ASSERT( pDeliverIRP->MdlAddress != NULL );

        pCurrentIRPStack = IoGetCurrentIrpStackLocation(pDeliverIRP);

        // Make sure we've got enough space to handle the whole request.
        //

        UserBufferLength =
            pCurrentIRPStack->Parameters.DeviceIoControl.OutputBufferLength;


        if (UserBufferLength >= SizeNeeded)
        {
            //
            // We've got enough room to copy it, so call our routine
            // to do so.
            //

            ASSERT(pDeliverIRP->MdlAddress->MdlFlags & MDL_PAGES_LOCKED);

            pUserBuffer =
                (PUCHAR)MmGetSystemAddressForMdl(pDeliverIRP->MdlAddress);

            CopyRequestToBuffer(pHttpConn,
                                pUserBuffer,
                                UserBufferLength,
                                pBuffer,
                                BufferLength
                                );
            //
            // Now complete the IRP.
            //

            pDeliverIRP->IoStatus.Status = STATUS_SUCCESS;
            pDeliverIRP->IoStatus.Information = SizeNeeded;

            IoCompleteRequest(pDeliverIRP, IO_NO_INCREMENT);
        }
        else
        {
            // Not enough buffer space for this.
            ASSERT(FALSE);
        }
    }
    else
    {
        PPENDING_HTTP_REQUEST       pPendingRequest;

        // No IRP, need to allocate a buffer and save this request.
        pPendingRequest = UL_ALLOCATE_POOL(NonPagedPool,
                                            SizeNeeded +
                                            sizeof(PENDING_HTTP_REQUEST) -
                                            FIELD_OFFSET(PENDING_HTTP_REQUEST,
                                                Request),
                                            UL_NONPAGED_DATA_POOL_TAG
                                            );

        if (pPendingRequest == NULL)
        {
            //
            // Couldn't allocate pending request, fail.
            //
            ASSERT(FALSE);
        }

        // Got the request, now copy the data in.
        pPendingRequest->RequestSize = SizeNeeded;
        CopyRequestToBuffer(pHttpConn,
                            (PUCHAR)&pPendingRequest->Request,
                            SizeNeeded,
                            pBuffer,
                            BufferLength
                            );

        //
        // OK, now we need to double check and see if an IRP has come in
        // while we were doing this.
        //
        UlAcquireSpinLockAtDpcLevel(&pNSGO->SpinLock);

        if (IsListEmpty(&pNSGO->PendingRequestList))
        {
            pDeliverIRP = FindIRPOnNSGO(pNSGO);

            if (pDeliverIRP != NULL)
            {
                // Yowza, found an IRP. Complete it if we can.

                UlReleaseSpinLockFromDpcLevel(&pNSGO->SpinLock);
                pCurrentIRPStack = IoGetCurrentIrpStackLocation(pDeliverIRP);
                UserBufferLength =
                    pCurrentIRPStack->Parameters.DeviceIoControl.OutputBufferLength;


                if (UserBufferLength >= SizeNeeded)
                {
                    //
                    // We've got enough room to copy it,just blast it in there.

                    ASSERT(pDeliverIRP->MdlAddress->MdlFlags &
                        (MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));

                    pUserBuffer =
                        (PUCHAR)MmGetSystemAddressForMdl(pDeliverIRP->MdlAddress);

                    memcpy(pUserBuffer,
                            (PUCHAR)&pPendingRequest->Request,
                            SizeNeeded);

                    // Complete the IRP.
                    //

                    pDeliverIRP->IoStatus.Status = STATUS_SUCCESS;
                    pDeliverIRP->IoStatus.Information = SizeNeeded;

                    IoCompleteRequest(pDeliverIRP, IO_NO_INCREMENT);

                    UL_FREE_POOL(pPendingRequest, UL_NONPAGED_DATA_POOL_TAG);
                }
                else
                {
                    // Not enough buffer space for this.
                    ASSERT(FALSE);
                }

                return STATUS_SUCCESS;
            }
        }

        // Either didn't find an IRP or there's stuff on the pending request
        // list, so queue this pending request.
        //

        InsertTailList(&pNSGO->PendingRequestList, &pPendingRequest->List);
        UlReleaseSpinLockFromDpcLevel(&pNSGO->SpinLock);

    }

    return STATUS_SUCCESS;

}

/******************************************************************************

Routine Description:

    Add an NSGO to our global list. Fail if one already exists with that name.

    This routine must be called in thread context!

Arguments:

    pNewNSGO                - NSGO to be added.

Return Value:

    Status of the attempt to add the NSGO.

******************************************************************************/

NTSTATUS
AddNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNewNSGO
    )
{
    PLIST_ENTRY                 pCurrentListEntry;
    PNAME_SPACE_GROUP_OBJECT    pNSGO;

    ExAcquireResourceExclusive(&NameSpaceListResource, TRUE);

    pCurrentListEntry = NameSpaceList.Flink;

    while (pCurrentListEntry != &NameSpaceList)
    {
        pNSGO = CONTAINING_RECORD( pCurrentListEntry,
                                   NAME_SPACE_GROUP_OBJECT,
                                   NameSpaceLinkage
                                   );

        if (_wcsnicmp(pNSGO->Name, pNewNSGO->Name, pNSGO->NameLength/sizeof(WCHAR)) == 0)
        {
            // Have a duplicate.
            ExReleaseResource(&NameSpaceListResource);
            return STATUS_DUPLICATE_NAME;
        }

        pCurrentListEntry = pNSGO->NameSpaceLinkage.Flink;
    }

    InsertTailList(&NameSpaceList, &pNewNSGO->NameSpaceLinkage);
    ExReleaseResource(&NameSpaceListResource);

    return STATUS_SUCCESS;
}

/******************************************************************************

Routine Description:

    Create a namespace group object. The name space group object is identified
    by a name. After creating the object itself, we add it to our list.

Arguments:

    pName               - Name of the name space group object.
    NameLength          - Length of the name.

Return Value:

    Status of the attempt to create the NSGO.

******************************************************************************/

NTSTATUS
UlCreateNameSpaceGroupObject(
    PWCHAR                  pName,
    SIZE_T                  NameLength
    )
{
    PNAME_SPACE_GROUP_OBJECT    pNSGO;
    NTSTATUS                    Status;

    pNSGO = UL_ALLOCATE_POOL( NonPagedPool,
                              FIELD_OFFSET(NAME_SPACE_GROUP_OBJECT, Name) +
                                NameLength,
                              UL_NSGO_POOL_TAG
                              );

    if (pNSGO == NULL)
    {
        // Couldn't allocate the memory for it.
        return STATUS_INSUFFICIENT_RESOURCES;
    }


    //
    // Now initialize it.
    UlInitializeSpinLock(&pNSGO->SpinLock);
    pNSGO->RefCount = 1;
    pNSGO->ProcessCount = 0;
    pNSGO->NameSpaceValid = TRUE;
    InitializeListHead(&pNSGO->PendingRequestList);
    InitializeListHead(&pNSGO->ProcessList);
    InitializeListHead(&pNSGO->VirtHostList);
    ExInitializeResource(&pNSGO->Resource);

    pNSGO->pURLMapEntries = NULL;

    pNSGO->NameLength = NameLength;
    RtlCopyMemory(pNSGO->Name, pName, NameLength);

    Status = AddNSGO(pNSGO);

    if (Status != STATUS_SUCCESS)
    {
        UL_FREE_POOL(pNSGO, UL_NSGO_POOL_TAG);
    }


    return Status;
}

/******************************************************************************

Routine Description:

    Add a URL to a name space group. This is complicated, because we also
    have to add it to the URL mapping table at the same time.

Arguments:

    pName               - Name of the name space group object.
    NameLength          - Length of the name.
    pAddress            - Address of virtual host of URL
    pHostName           - Pointer to virtual host name
    HostNameLength      - Length of pHostName
    pURL                - URL to be added
    URLLength           - Length pointed to by pURL

Return Value:

    Status of the attempt to add the URL.

******************************************************************************/

NTSTATUS
UlAddURLToNameSpaceGroup(
    PWCHAR                  pName,
    SIZE_T                  NameLength,
    PTRANSPORT_ADDRESS      pAddress,
    PUCHAR                  pHostName,
    SIZE_T                  HostNameLength,
    PUCHAR                  pURL,
    SIZE_T                  URLLength
    )
{
    PNAME_SPACE_GROUP_OBJECT    pNSGO;
    PNAME_SPACE_URL_ENTRY       pNSUE;
    VIRTUAL_HOST_ID             VirtHostID;
    PLIST_ENTRY                 pList;
    PNAME_SPACE_HOST_ENTRY      pMatchingNSHE;
    NTSTATUS                    Status;
    SIZE_T                      MapCount;

    // Find the correct NSGO, and reference it so it can't go away on us.
    //
    pNSGO = FindAndReferenceNSGO(pName, NameLength);

    if (pNSGO == NULL)
    {
        // No such NSGO. Fail.
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // We have a valid NSGO. Allocate a new URL tracking structure, and link
    // it to the NSGO.
    //
    pNSUE = UL_ALLOCATE_POOL( PagedPool,
                              FIELD_OFFSET(NAME_SPACE_URL_ENTRY, URL),
                              UL_NSGO_POOL_TAG
                              );

    if (pNSUE == NULL)
    {
        //
        // Couldn't allocate memory for it.
        //
        DereferenceNSGO(pNSGO);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    pNSUE->URLLength = URLLength;
    RtlCopyMemory(pNSUE->URL, pURL, URLLength);

    //
    // Get the virtual host ID, and see if we already have a name spave virtual
    // host entry for this virtual host. If not, we'll need to create one.
    //

    FindVirtualHostID(&VirtHostID, pAddress, pHostName, HostNameLength);

    if (!VALID_HOST_ID(VirtHostID))
    {
        // No such virtual host exists.
        //
        UL_FREE_POOL(pNSUE, UL_NSGO_POOL_TAG);
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Walk the list of virtual host entries and see if we have a matching one.

    ExAcquireResourceExclusive(&pNSGO->Resource, TRUE);

    pList = pNSGO->VirtHostList.Flink;

    pMatchingNSHE = NULL;

    while (pList != &pNSGO->VirtHostList)
    {

        pMatchingNSHE = CONTAINING_RECORD( pList,
                                          NAME_SPACE_HOST_ENTRY,
                                          List
                                          );

        if (HOST_ID_EQUAL(pMatchingNSHE->HostID, VirtHostID))
        {
            // We found a match.
            break;
        }

        // No match, look at the next one.
        pList = pMatchingNSHE->List.Flink;
        pMatchingNSHE = NULL;
    }

    // If we found one, good. Otherwise we need to allocate one.

    if (pMatchingNSHE == NULL)
    {
        // Didn't find one. Allocate one and link it on.

        pMatchingNSHE = UL_ALLOCATE_POOL( PagedPool,
                                          sizeof(NAME_SPACE_HOST_ENTRY),
                                          UL_NSGO_POOL_TAG
                                          );
        if (pMatchingNSHE == NULL)
        {
            // Couldn't allocate the needed memory.
            ExReleaseResource(&pNSGO->Resource);
            DereferenceNSGO(pNSGO);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        pMatchingNSHE->HostID = VirtHostID;
        InitializeListHead(&pMatchingNSHE->URLList);
        InsertTailList(&pNSGO->VirtHostList, &pMatchingNSHE->List);
    }

    // Now insert this URL entry on the host entry list.
    InsertTailList(&pMatchingNSHE->URLList, &pNSUE->List);

    MapCount = AddURLMapEntry(&VirtHostID, pNSUE, pNSGO, &Status);

    if (Status != STATUS_SUCCESS)
    {
        // Uh-oh. Couldn't set the URL map. Remove the newly created URL
        // list entry and free it.
        RemoveEntryList(&pNSUE->List);
        UL_FREE_POOL(pNSUE, UL_NSGO_POOL_TAG);
    }
    else
    {
        pNSGO->RefCount += MapCount;
    }

    ExReleaseResource(&pNSGO->Resource);

    return Status;


}

/******************************************************************************

Routine Description:

    Find an NSGO in our global list, reference it, and return a pointer to it.

Arguments:

    pName               - Name of the name space group object.
    NameLength          - Length of the name.

Return Value:

    A pointer to the NSGO if we find one, NULL if we don't

******************************************************************************/


PNAME_SPACE_GROUP_OBJECT
FindAndReferenceNSGO(
    PWCHAR                      pName,
    SIZE_T                      NameLength
    )
{
    PLIST_ENTRY                 pList;
    PNAME_SPACE_GROUP_OBJECT    pReturnNSGO;

    pReturnNSGO = NULL;

    ExAcquireResourceExclusive(&NameSpaceListResource, TRUE);

    pList = NameSpaceList.Flink;

    while (pList != &NameSpaceList)
    {
        PNAME_SPACE_GROUP_OBJECT    pCurrentNSGO;

        pCurrentNSGO = CONTAINING_RECORD( pList,
                                          NAME_SPACE_GROUP_OBJECT,
                                          NameSpaceLinkage
                                          );

        // See if this is the right one.

        if (pCurrentNSGO->NameLength == NameLength &&
            _wcsnicmp(pCurrentNSGO->Name, pName, NameLength/sizeof(WCHAR)) == 0)
        {

            // This is a match. See if he's going away.
            ExAcquireResourceExclusive(&pCurrentNSGO->Resource, TRUE);

            if (pCurrentNSGO->RefCount != 0)
            {
                pCurrentNSGO->RefCount++;
                pReturnNSGO = pCurrentNSGO;
            }

            ExReleaseResource(&pCurrentNSGO->Resource);

            break;

        }

        // Not a match, check the next one.

        pList = pCurrentNSGO->NameSpaceLinkage.Flink;

    }

    ExReleaseResource(&NameSpaceListResource);

    return pReturnNSGO;

}

/******************************************************************************

Routine Description:

    Dereference an NSGO. If the reference count goes to 0, we're done with it.

Arguments:

    pNSGO               - Pointer to the name space group object to dereference.


Return Value:


******************************************************************************/

VOID
DereferenceNSGO(
    PNAME_SPACE_GROUP_OBJECT    pNSGO
    )
{
    // Acquire the NSGO resource, then deference him. If the ref count goes to
    // 0 then we'll have to remove this NSGO from the global list and free him.
    //

    ASSERT(pNSGO->RefCount > 0);

    ExAcquireResourceExclusive(&pNSGO->Resource, TRUE);

    pNSGO->RefCount--;

    if (pNSGO->RefCount == 0)
    {
        ExReleaseResource(&pNSGO->Resource);
        ExAcquireResourceExclusive(&NameSpaceListResource, TRUE);

        RemoveEntryList(&pNSGO->NameSpaceLinkage);
        ExReleaseResource(&NameSpaceListResource);

        // Clean him up now.
        ASSERT(FALSE);
    }
    else
    {
        // Didn't go to 0, so keep going.
        ExReleaseResource(&pNSGO->Resource);
    }

}


/******************************************************************************

Routine Description:

    Bind a process to a name space group object. We return a pointer to a name
    space process structure for future use as the file context.

Arguments:

    pName           - Name of the name space group
    NameLength      - Length pointed to by pName
    pFileContext    - Where to return file context


Return Value:

    Status of attempt to bind the process


******************************************************************************/
NTSTATUS
UlBindToNameSpaceGroup(
    PWCHAR                  pName,
    SIZE_T                  NameLength,
    PVOID                   *pFileContext
    )
{
    PNAME_SPACE_GROUP_OBJECT    pNSGO;
    PNAME_SPACE_PROCESS         pNewProcess;

    pNSGO = FindAndReferenceNSGO(pName, NameLength);

    if (pNSGO == NULL)
    {
        // No such NSGO.
        return STATUS_INVALID_DEVICE_REQUEST;
    }

    // Otherwise, have an NSGO. Try to allocate a name space process item
    // for it.

    pNewProcess = UL_ALLOCATE_POOL(
                    NonPagedPool,
                    sizeof(NAME_SPACE_PROCESS),
                    UL_NSGO_POOL_TAG
                    );

    if (pNewProcess == NULL)
    {
        // Couldn't get it.
        DereferenceNSGO(pNSGO);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    InitializeListHead(&pNewProcess->PendingIRPs);

    // Now link this guy on.

    ExAcquireResourceExclusive(&pNSGO->Resource, TRUE);

    pNewProcess->pParentNSGO = pNSGO;

    InsertTailList(&pNSGO->ProcessList, &pNewProcess->List);

    ExReleaseResource(&pNSGO->Resource);

    // It worked. Leave the reference on the NSGO to hold the NSGO here while
    // the process sticks around.
    //

    *pFileContext = (PVOID)pNewProcess;

    return STATUS_SUCCESS;


}


/******************************************************************************

Routine Description:

    Unbind a process from a name space group object.

Arguments:

    pFileContext    - The file context returned from UlBindToNameSpaceGroup.


Return Value:

    Status of attempt to unbind the process

******************************************************************************/
NTSTATUS
UlUnbindFromNameSpaceGroup(
    IN PVOID pFileContext
    )
{
    PNAME_SPACE_GROUP_OBJECT    pNSGO;
    PNAME_SPACE_PROCESS         pProcess;

    pProcess = (PNAME_SPACE_PROCESS)pFileContext;
    ASSERT( pProcess != NULL );
    pNSGO = pProcess->pParentNSGO;
    ASSERT( pNSGO != NULL );

    //
    // Unlink from the NSGO list.
    //

    ExAcquireResourceExclusive(&pNSGO->Resource, TRUE);
    RemoveEntryList( &pProcess->List );
    ExReleaseResource(&pNSGO->Resource);

    //
    // Dereference the NSGO, release the resources.
    //

    DereferenceNSGO( pNSGO );
    UL_FREE_POOL( pProcess, UL_NSGO_POOL_TAG );

    return STATUS_SUCCESS;

}   // UlUnbindFromNameSpaceGroup


/***************************************************************************++

Routine Description:

    Cancel routine for UlReceiveHttpRequest IRPs.

Arguments:

    pDeviceObject - Supplies the device object. Not used.

    pIrp - Supplies the IRP to cancel.

--***************************************************************************/
VOID
UlCancelHttpReceive(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
{
    KIRQL oldIrql;
    PIO_STACK_LOCATION pIrpSp;
    PNAME_SPACE_GROUP_OBJECT pRequestNSGO;

    pIrpSp = IoGetCurrentIrpStackLocation( pIrp );
    pRequestNSGO = pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    UlAcquireSpinLock( &pRequestNSGO->SpinLock, &oldIrql );

    if (pIrp->Tail.Overlay.ListEntry.Flink != NULL)
    {
        RemoveEntryList( &pIrp->Tail.Overlay.ListEntry );
        UlReleaseSpinLock( &pRequestNSGO->SpinLock, oldIrql );
        IoReleaseCancelSpinLock( pIrp->CancelIrql );

        pIrp->IoStatus.Status = STATUS_CANCELLED;
        IoCompleteRequest( pIrp, g_UlPriorityBoost );
    }
    else
    {
        UlReleaseSpinLock( &pRequestNSGO->SpinLock, oldIrql );
        IoReleaseCancelSpinLock( pIrp->CancelIrql );
    }

}   // UlCancelHttpReceive


/******************************************************************************

Routine Description:

    Post a receive request on a name space process object.

Arguments:

    pFileContext    - Pointer to the name space process representing the
                        calling process.
    pIRP            - IRP to be posted.

Return Value:

    Status of attempt to post the request.


******************************************************************************/

NTSTATUS
UlReceiveHttpRequest(
    IN  PVOID                   pFileContext,
    IN  PIRP                    pIRP
    )
{
    KIRQL                       OldIrql;
    PNAME_SPACE_GROUP_OBJECT    pRequestNSGO;
    PNAME_SPACE_PROCESS         pRequestNSP;

    pRequestNSP = (PNAME_SPACE_PROCESS)pFileContext;

    // The name space group object is reference by this connection, so it
    // must be there. Get the lock on it and make sure it's valid. If it is,
    // see if there's a pending request or if we can just queue this IRP.

    pRequestNSGO = pRequestNSP->pParentNSGO;

    ASSERT(pRequestNSGO->RefCount >= 1);

    UlAcquireSpinLock(&pRequestNSGO->SpinLock, &OldIrql);

    if (pRequestNSGO->NameSpaceValid)
    {
        // Name space object is valid. See if we have a pending request.

        if (IsListEmpty(&pRequestNSGO->PendingRequestList))
        {
            PIO_STACK_LOCATION pIrpSp;

            pIrpSp = IoGetCurrentIrpStackLocation( pIRP );
            pIrpSp->Parameters.DeviceIoControl.Type3InputBuffer = pRequestNSGO;

            // No pending request, just queue this IRP and we're done.

            IoMarkIrpPending( pIRP );

            IoSetCancelRoutine( pIRP, &UlCancelHttpReceive );

            if (!pIRP->Cancel)
            {
                InsertTailList(
                    &pRequestNSP->PendingIRPs,
                    &pIRP->Tail.Overlay.ListEntry
                    );

                UlReleaseSpinLock(&pRequestNSGO->SpinLock, OldIrql);
            }
            else
            {
                //
                // Irp is being canceled.
                //

                UlReleaseSpinLock(&pRequestNSGO->SpinLock, OldIrql);

                if (IoSetCancelRoutine( pIRP, NULL ) != NULL)
                {
                    IoAcquireCancelSpinLock( &pIRP->CancelIrql );
                    UlCancelHttpReceive( g_pUlAppPoolDeviceObject, pIRP );
                }
            }

            return STATUS_PENDING;
        }
        else
        {
            PLIST_ENTRY             pList;
            PPENDING_HTTP_REQUEST   pPendingRequest;
            PIO_STACK_LOCATION      pCurrentIRPStack;
            ULONG                   BufferLength;
            PUCHAR                  pBuffer;

            // Have a pending request. Pull it from the list now.

            pList = RemoveHeadList(&pRequestNSGO->PendingRequestList);
            UlReleaseSpinLock(&pRequestNSGO->SpinLock, OldIrql);

            pPendingRequest = CONTAINING_RECORD(
                                pList,
                                PENDING_HTTP_REQUEST,
                                List
                                );

            // Make sure this is big enough to handle the request, and
            // if so copy it in.
            //

            pCurrentIRPStack = IoGetCurrentIrpStackLocation(pIRP);

            // Make sure we've got enough space to handle the whole request.
            //

            BufferLength =
                pCurrentIRPStack->Parameters.DeviceIoControl.OutputBufferLength;

            if (pPendingRequest->RequestSize <= BufferLength)
            {
                // This request will fit in this buffer, so copy it.

                pBuffer = (PUCHAR)MmGetSystemAddressForMdl(pIRP->MdlAddress);

                RtlCopyMemory(
                    pBuffer,
                    &pPendingRequest->Request,
                    pPendingRequest->RequestSize
                    );

                pIRP->IoStatus.Status = STATUS_SUCCESS;
                pIRP->IoStatus.Information = pPendingRequest->RequestSize;

                // We're done with the pending request, so free it.
                UL_FREE_POOL(pPendingRequest, UL_NONPAGED_DATA_POOL_TAG);

                return STATUS_SUCCESS;


            }
            else
            {
                // BUGBUG This isn't done yet. Need to handle partial request
                // completions. The code below is totally wrong. Don't believe
                // the hype.

                ASSERT(FALSE);
                pIRP->IoStatus.Status = STATUS_SUCCESS;
                pIRP->IoStatus.Information = 0;

                // We're done with the pending request, so free it.
                UL_FREE_POOL(pPendingRequest, UL_NONPAGED_DATA_POOL_TAG);

                return STATUS_SUCCESS;
            }


        }
    }
    UlReleaseSpinLock(&pRequestNSGO->SpinLock, OldIrql);

    return STATUS_INVALID_DEVICE_REQUEST;
}

/******************************************************************************

Routine Description:

    Routine to initialize the NSGO code.

Return Value:

    NSTATUS - Completion status.

******************************************************************************/
NTSTATUS
InitializeNSGO(
    VOID
    )
{
    ExInitializeResource(&NameSpaceListResource);
    InitializeListHead(&NameSpaceList);

    return STATUS_SUCCESS;
}

/******************************************************************************

Routine Description:

    Routine to terminate the NSGO code.

******************************************************************************/
VOID
TerminateNSGO(
    VOID
    )
{
    ExDeleteResource(&NameSpaceListResource);

}   // TerminateNSGO

#endif  // obsolete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\urlmapp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    urlmapp.h

Abstract:

    The private definition of URL map interfaces.

Author:

    Henry Sanders (henrysa)       21-Jun-1998


Revision History:

--*/


#ifndef _URLMAPP_H_
#define _URLMAPP_H_

#if 0
VOID
CleanupURLMapWorker(
    IN PUL_WORK_ITEM pWorkItem
    );

VOID
DeleteURLMapHeader(
    PHTTP_URL_MAP_HEADER    pMapHeader
    );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\tditest.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tditest.c

Abstract:

    This module implements the (temporary) TDI test module.

Author:

    Keith Moore (keithmo)       19-Jun-1998

Revision History:

--*/


#include "precomp.h"


//
// Private types.
//

typedef struct _TEST_SHUTDOWN
{
    KEVENT Event;
    NTSTATUS Status;

} TEST_SHUTDOWN, *PTEST_SHUTDOWN;


//
// Private prototypes.
//

BOOLEAN
UlpTestConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    );

VOID
UlpTestConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UlpTestConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    );

VOID
UlpTestConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    );

NTSTATUS
UlpTestReceiveData(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    );

VOID
UlpCloseEndpointComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    );


//
// Private globals.
//

BOOLEAN g_TdiTestInitialized;
PUL_ENDPOINT g_TdiTestEndpoint;
PMDL g_TdiTestResponseMdl;
CHAR g_TdiTestResponseBuffer[] =
    "HTTP/1.1 404 Object Not Found\r\n"
    "Server: Keith & Henry's Excellent Device Driver (Duct-Tape)\r\n"
    "Content-Type: text/html\r\n"
    "Content-Length: 102\r\n"
    "\r\n"
    "<html><head><title>Error</title></head>"
    "<body>The system cannot find the file specified. </body></html>";


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeTdiTest )
#pragma alloc_text( PAGE, UlTerminateTdiTest )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpTestConnectionRequest
NOT PAGEABLE -- UlpTestConnectionComplete
NOT PAGEABLE -- UlpTestConnectionDisconnect
NOT PAGEABLE -- UlpTestConnectionDestroyed
NOT PAGEABLE -- UlpTestReceiveData
NOT PAGEABLE -- UlpCloseEndpointComplete
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of this module.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeTdiTest(
    VOID
    )
{
    NTSTATUS status;
    TA_IP_ADDRESS localAddress;

    //
    // Sanity check.
    //

    PAGED_CODE();

    ASSERT( !g_TdiTestInitialized );

    //
    // Allocate a MDL describing the response buffer.
    //

    g_TdiTestResponseMdl = IoAllocateMdl(
                                g_TdiTestResponseBuffer,
                                sizeof(g_TdiTestResponseBuffer) - 1,
                                FALSE,
                                FALSE,
                                NULL
                                );

    if (g_TdiTestResponseMdl == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    MmBuildMdlForNonPagedPool( g_TdiTestResponseMdl );

    //
    // Create the listening endpoint. Note that our listening endpoint
    // context is just a double indirect pointer to the raw UL_ENDPOINT.
    //

    UlInitializeIpTransportAddress(
        &localAddress,
        0,
        80
        );

    status = UlCreateListeningEndpoint(
                    (PTRANSPORT_ADDRESS)&localAddress,
                    sizeof(localAddress),
                    10,
                    &UlpTestConnectionRequest,
                    &UlpTestConnectionComplete,
                    &UlpTestConnectionDisconnect,
                    &UlpTestConnectionDestroyed,
                    &UlpTestReceiveData,
                    &g_TdiTestEndpoint,
                    &g_TdiTestEndpoint
                    );

    if (!NT_SUCCESS(status))
    {
        IoFreeMdl( g_TdiTestResponseMdl );
        return status;
    }

    g_TdiTestInitialized = TRUE;

    return STATUS_SUCCESS;

}   // UlInitializeTdiTest


/***************************************************************************++

Routine Description:

    Performs global termination of this module.

--***************************************************************************/
VOID
UlTerminateTdiTest(
    VOID
    )
{
    NTSTATUS status;
    TEST_SHUTDOWN shutdown;

    //
    // Sanity check.
    //

    PAGED_CODE();

    if (g_TdiTestInitialized)
    {
        g_TdiTestInitialized = FALSE;

        //
        // Close the listening endpoint and wait for it to complete.
        //

        KeInitializeEvent( &shutdown.Event, SynchronizationEvent, FALSE );

        status = UlCloseListeningEndpoint(
                        g_TdiTestEndpoint,
                        &UlpCloseEndpointComplete,
                        &shutdown
                        );

        if (status == STATUS_PENDING)
        {
            KeWaitForSingleObject(
                &shutdown.Event,                // Object
                UserRequest,                    // WaitReason
                KernelMode,                     // WaitMode
                FALSE,                          // Alertable
                NULL                            // Timeout
                );

            status = shutdown.Status;
        }

        if (!NT_SUCCESS(status))
        {
            IF_DEBUG( TDI_TEST )
            {
                KdPrint((
                    "UlTerminateTdiTest: UlCloseListeningEndpoint failed, %08lx\n",
                    status
                    ));
            }
        }

        //
        // Free the response MDL we created above.
        //

        IoFreeMdl( g_TdiTestResponseMdl );
    }

}   // UlTerminateTdiTest


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    received (but not yet accepted).

Arguments:

    pListeningContext - Supplies an uninterpreted context value as
        passed to the UlCreateListeningEndpoint() API.

    pConnection - Supplies the connection being established.

    pRemoteAddress - Supplies the remote (client-side) address
        requesting the connection.

    RemoteAddressLength - Supplies the total byte length of the
        pRemoteAddress structure.

    ppConnectionContext - Receives a pointer to an uninterpreted
        context value to be associated with the new connection if
        accepted. If the new connection is not accepted, this
        parameter is ignored.

Return Value:

    BOOL - TRUE if the connection was accepted, FALSE if not.

--***************************************************************************/
BOOLEAN
UlpTestConnectionRequest(
    IN PVOID pListeningContext,
    IN PUL_CONNECTION pConnection,
    IN PTRANSPORT_ADDRESS pRemoteAddress,
    IN ULONG RemoteAddressLength,
    OUT PVOID *ppConnectionContext
    )
{
    PUL_ENDPOINT pEndpoint;
    PHTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    //
    // Sanity check.
    //

    pEndpoint = *(PUL_ENDPOINT *)pListeningContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestConnectionRequest: conn %p\n",
            pConnection
            ));
    }

    //
    // Create a new HTTP connection.
    //

    status = UlCreateHttpConnection( &pHttpConnection, pConnection );

    if (NT_SUCCESS(status))
    {
        //
        // We the HTTP_CONNECTION pointer as our connection context.
        //

        *ppConnectionContext = pHttpConnection;

        return TRUE;
    }

    //
    // Failed to create new connection.
    //

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestConnectionRequest: cannot create new conn, error %08lx\n",
            status
            ));
    }

    return FALSE;

}   // UlpTestConnectionRequest


/***************************************************************************++

Routine Description:

    Routine invoked after an incoming TCP/MUX connection has been
    fully accepted.

    This routine is also invoked if an incoming connection was not
    accepted *after* PUL_CONNECTION_REQUEST returned TRUE. In other
    words, if PUL_CONNECTION_REQUEST indicated that the connection
    should be accepted but a fatal error occurred later, then
    PUL_CONNECTION_COMPLETE is invoked.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

    Status - Supplies the completion status. If this value is
        STATUS_SUCCESS, then the connection is now fully accepted.
        Otherwise, the connection has been aborted.

--***************************************************************************/
VOID
UlpTestConnectionComplete(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    PHTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    pEndpoint = *(PUL_ENDPOINT *)pListeningContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    pHttpConnection = (PHTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestConnectionComplete: http %p conn %p status %08lx\n",
            pHttpConnection,
            pConnection,
            Status
            ));
    }

    //
    // Blow away our HTTP connection if the connect failed.
    //

    if (!NT_SUCCESS(Status))
    {
        UlDereferenceHttpConnection( pHttpConnection );
    }

}   // UlpTestConnectionComplete


/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    disconnected by the remote (client) side.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

    Status - Supplies the termination status.

--***************************************************************************/
VOID
UlpTestConnectionDisconnect(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN NTSTATUS Status
    )
{
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    PHTTP_CONNECTION pHttpConnection;

    //
    // Sanity check.
    //

    pEndpoint = *(PUL_ENDPOINT *)pListeningContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    pHttpConnection = (PHTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestConnectionDisconnect: http %p conn %p\n",
            pHttpConnection,
            pConnection
            ));
    }

}   // UlpTestConnectionDisconnect


/***************************************************************************++

Routine Description:

    Routine invoked after an established TCP/MUX connection has been
    destroyed.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies the uninterpreted context value
        as returned by PUL_CONNECTION_REQUEST.

--***************************************************************************/
VOID
UlpTestConnectionDestroyed(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext
    )
{
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    PHTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    //
    // Sanity check.
    //

    pEndpoint = *(PUL_ENDPOINT *)pListeningContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    pHttpConnection = (PHTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestConnectionDestroyed: http %p conn %p\n",
            pHttpConnection,
            pConnection
            ));
    }

    //
    // Tear it down.
    //

    UlDereferenceHttpConnection( pHttpConnection );

}   // UlpTestConnectionDestroyed


/***************************************************************************++

Routine Description:

    Routine invoked after data has been received on an established
    TCP/MUX connection.

Arguments:

    pListeningContext - Supplies an uninterpreted context value
        as passed to the UlCreateListeningEndpoint() API.

    pConnectionContext - Supplies an uninterpreted context value
        as returend from the PUL_CONNECTION_REQUEST callback.

    pBuffer - Supplies a pointer to the received data.

    IndicatedLength - Supplies the length of the received data
        available in pBuffer.

    pTakenLength - Receives the number of bytes consumed by
        the receive handler.

Return Value:

     NTSTATUS - The status of the consumed data. The behavior of
         the TDI/MUX component is dependent on the return value
         and the value set in *pTakenLength, and is defined as
         follows:

             STATUS_SUCCESS, *pTakenLength == IndicatedLength -
                 All indicated data was consumed by the receive
                 handler. Additional incoming data will cause
                 subsequent receive indications.

             STATUS_SUCCESS, *pTakenLength < IndicatedLength -
                 Part of the indicated data was consumed by the
                 receive handler. The network transport will
                 buffer data and no further indications will be
                 made until the UlReceiveData() is called.

             STATUS_MORE_PROCESSING_REQUIRED - Part of the
                 indicated data was consumed by the receive handler.
                 A subsequent receive indication will be made
                 when additional data is available. The subsequent
                 indication will include the unconsumed data from
                 the current indication plus any additional data
                 received.

             Any other status - Indicates a fatal error in the
                 receive handler. The connection will be aborted.

             *pTakenLength > IndicatedLength - This is an error
                 condition and should never occur.

--***************************************************************************/
NTSTATUS
UlpTestReceiveData(
    IN PVOID pListeningContext,
    IN PVOID pConnectionContext,
    IN PVOID pBuffer,
    IN ULONG IndicatedLength,
    OUT PULONG pTakenLength
    )
{
    PUL_CONNECTION pConnection;
    PUL_ENDPOINT pEndpoint;
    PHTTP_CONNECTION pHttpConnection;
    NTSTATUS status;

    //
    // Sanity check.
    //

    pEndpoint = *(PUL_ENDPOINT *)pListeningContext;
    ASSERT( IS_VALID_ENDPOINT( pEndpoint ) );
    pHttpConnection = (PHTTP_CONNECTION)pConnectionContext;
    pConnection = pHttpConnection->pConnection;
    ASSERT( IS_VALID_CONNECTION( pConnection ) );

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpTestReceiveData: http %p conn %p\n",
            pHttpConnection,
            pConnection
            ));
    }

    //
    // Call through to the receive handler.
    //

    status = HttpReceive(
                    pHttpConnection,
                    (PUCHAR)pBuffer,
                    (SIZE_T)IndicatedLength,
                    (SIZE_T *)pTakenLength  // Bogus! FIX THIS
                    );


    if (!NT_SUCCESS(status))
    {
        IF_DEBUG( TDI_TEST )
        {
            KdPrint((
                "UlpTestReceiveData: HttpReceive failed, error %08lx\n",
                status
                ));
        }
    }

    return status;

}   // UlpTestReceiveData


/***************************************************************************++

Routine Description:

    Completion handler for UlCloseListeningEndpoint().

Arguments:

    pCompletionContext - Supplies an uninterpreted context value
        as passed to the asynchronous API. This is actually a
        pointer to a TEST_SHUTDOWN structure.

    Status - Supplies the final completion status of the
        asynchronous API.

    Information - Optionally supplies additional information about
        the completed operation, such as the number of bytes
        transferred. This field is unused for UlCloseListeningEndpoint().

--***************************************************************************/
VOID
UlpCloseEndpointComplete(
    IN PVOID pCompletionContext,
    IN NTSTATUS Status,
    IN ULONG_PTR Information
    )
{
    PTEST_SHUTDOWN pShutdown;

    IF_DEBUG( TDI_TEST )
    {
        KdPrint((
            "UlpCloseEndpointComplete: %08lx %p\n",
            Status,
            Information
            ));
    }

    //
    // Save the completion status, signal the event.
    //

    pShutdown = (PTEST_SHUTDOWN)pCompletionContext;

    pShutdown->Status = Status;
    KeSetEvent( &pShutdown->Event, 0, FALSE );

}   // UlpCloseEndpointComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\virthost.c ===
/******************************************************************************

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    virthost.c

Abstract:

    Contains the HTTP virtual host manipulation code.

Author:

    Henry Sanders (henrysa)       17-Jun-1998

Revision History:

******************************************************************************/

#include    "precomp.h"

#if 0   // obsolete

UL_SPIN_LOCK    VirtHostLock;
UL_SPIN_LOCK    VirtualHostUpdateLock;

PVIRTUAL_HOST   pDefaultVirtualHost;
VIRTUAL_HOST_ID NextVirtualHostId;


/******************************************************************************

Routine Description:

    The routine that looks up a virtual host. This routine must be called
    at DPC level!

    Currently we only support one virtual host. Eventually we'll have to
    support more, but we'll still probably want to special case the
    situation where we only have one, so hopefully this isn't throw away
    code.

Arguments:

    pHttpConn       - Pointer to HTTP connection on which data was received.
    pBuffer         - Pointer to data received.
    BufferLength    - Length of data pointed to by pBuffer.
    pBytesTaken     - Pointer to where to return bytes taken.

Return Value:

    Status of receive.

******************************************************************************/

PVIRTUAL_HOST
FindVirtualHost(
    PHTTP_CONNECTION        pHttpConn,
    PHTTP_CACHE_TABLE       *ppCacheTable,
    PHTTP_URL_MAP_HEADER    *ppURLMapHeader
    )
{
    PVIRTUAL_HOST   pVirtHost;

    UlAcquireSpinLockAtDpcLevel(&VirtHostLock);

    pVirtHost = pDefaultVirtualHost;

    //
    // Make sure we've got a virtual host configured, and if we do
    // reference the tables and return the appropriate pointers.
    //

    if (pVirtHost != NULL)
    {
        *ppCacheTable = NULL;

        // Increment the reference count on the URL map header.

        *ppURLMapHeader = pVirtHost->pURLMapHeader;

        if (pVirtHost->pURLMapHeader != NULL)
        {

            ReferenceURLMap(pVirtHost->pURLMapHeader);

        }

    }

    UlReleaseSpinLockFromDpcLevel(&VirtHostLock);

    return pVirtHost;
}

/******************************************************************************

Routine Description:

    Insert a virtual host structure into the virtual host table.

Arguments:

    pVirtHost           - Initialized virtual host structure.

    Flags               - Flags for the virtual host.


Return Value:

    Status of attempt to insert virtual host.

******************************************************************************/

NTSTATUS
InsertVirtualHost(
    IN  PVIRTUAL_HOST       pVirtHost,
    IN  ULONG               Flags
    )
{
    KIRQL           OldIrql;
    NTSTATUS        Status;

    // For now, we only allow the default virtual host to be created.

    if (!(Flags & DEFAULT_VIRTUAL_HOST))
    {
        return STATUS_INVALID_DEVICE_REQUEST;

    }

    UlAcquireSpinLock(&VirtHostLock, &OldIrql);

    if (pDefaultVirtualHost != NULL)
    {
        Status =  STATUS_DUPLICATE_NAME;
    }
    else
    {
        pDefaultVirtualHost = pVirtHost;
        Status = STATUS_SUCCESS;
    }

    UlReleaseSpinLock(&VirtHostLock, OldIrql);

    return Status;

}


/******************************************************************************

Routine Description:

    Create a virtual host. If the virtual host already exists, it's an error.

Arguments:

    pHostAddress        - Pointer to the host address for the new virtual
                            host. The IP address portion of the address
                            may be 0, in which case the host name identifies
                            the virtual host.

    pHostName           - Name of the virtual host. If this is NULL, the
                            host address must be fully specified.

    Flags               - Flags for the virtual host.


Return Value:

    Status of attempt to create virtual host.

******************************************************************************/
NTSTATUS
UlCreateVirtualHost(
    IN  PTRANSPORT_ADDRESS  pHostAddress,
    IN  OPTIONAL PUCHAR     pHostName,
    IN  SIZE_T              HostNameLength,
    IN  ULONG               Flags
    )
{
    PVIRTUAL_HOST           pVirtHost;
    PTA_ADDRESS             pInputAddress;
    PTA_ADDRESS             pAddress;
    PUCHAR                  pKernelHostName;
    NTSTATUS                Status;

    // Allocate memory for the virtual host, on the assumption that it
    // doesn't already exist.

    pVirtHost = UL_ALLOCATE_POOL(NonPagedPool,
                                 sizeof(VIRTUAL_HOST),
                                 UL_VIRTHOST_POOL_TAG
                                 );

    if (pVirtHost == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;

    }

    RtlZeroMemory(pVirtHost, sizeof(VIRTUAL_HOST));

    ExInitializeResource(&pVirtHost->UpdateResource);
    KeInitializeEvent(&pVirtHost->DeleteEvent, SynchronizationEvent, FALSE);
    pVirtHost->UpdateCount = 1;
    pVirtHost->HostID = GetNextVirtualHostID();

    //
    // Check out the address to make sure it's valid.

    if (pHostAddress->TAAddressCount != 1)
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto error;
    }

    pInputAddress = (PTA_ADDRESS)pHostAddress->Address;

    if (pInputAddress->AddressType != TDI_ADDRESS_TYPE_IP ||
        pInputAddress->AddressLength != sizeof(TDI_ADDRESS_IP))
    {
        Status = STATUS_INVALID_DEVICE_REQUEST;
        goto error;
    }

    //
    // Now copy the address.
    //
    pAddress = UL_ALLOCATE_POOL(NonPagedPool,
                                 FIELD_OFFSET(TA_ADDRESS, Address) +
                                    sizeof(TDI_ADDRESS_IP),
                                 UL_ADDRESS_POOL_TAG
                                 );

    if (pAddress == NULL)
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto error;
    }

    pVirtHost->pLocalAddress = pAddress;

    RtlCopyMemory(pAddress,
                  pInputAddress,
                  FIELD_OFFSET(TA_ADDRESS, Address) + sizeof(TDI_ADDRESS_IP)
                  );

    //
    // Now allocate and copy the host name, if there is one.
    //
    if (pHostName != NULL)
    {
        pKernelHostName = UL_ALLOCATE_POOL(NonPagedPool,
                                 HostNameLength,
                                 UL_ADDRESS_POOL_TAG
                                 );

        // Make sure we got it.

        if (pKernelHostName == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto error;
        }

        pVirtHost->pHostName = pKernelHostName;

        // And copy the host name.
        RtlCopyMemory(pKernelHostName,
                      pHostName,
                      HostNameLength
                      );
    }

    Status = InsertVirtualHost(pVirtHost, Flags);

    if (Status != STATUS_SUCCESS)
    {
        goto error;
    }

    return Status;

error:

    ASSERT(pVirtHost != NULL);

    if (pVirtHost->pURLMapHeader != NULL)
    {
        DereferenceURLMap(pVirtHost->pURLMapHeader);
    }

    if (pVirtHost->pHostName != NULL)
    {
        UL_FREE_POOL(pVirtHost->pHostName, UL_ADDRESS_POOL_TAG);
    }

    if (pVirtHost->pLocalAddress != NULL)
    {
        UL_FREE_POOL(pVirtHost->pLocalAddress, UL_ADDRESS_POOL_TAG);
    }

    UL_FREE_POOL(pVirtHost, UL_VIRTHOST_POOL_TAG);

    return Status;

}

/******************************************************************************

Routine Description:

    Find a virtual host ID, given an address and host name.

Arguments:

    pVirtHostID             - Where to return the virtual host ID
    pAddress                - Pointer to the transport address identifying the
                                virtual host.
    pHostName               - Pointer to the host name id'ing the host.
    HostNameLength          - Length pointed to by pHostName.

Return Value:

    Host ID if we found one.

******************************************************************************/
VOID
FindVirtualHostID(
    OUT PVIRTUAL_HOST_ID    pVirtHostID,
    IN  PTRANSPORT_ADDRESS  pAddress,
    IN  PUCHAR              pHostName,
    IN  SIZE_T              HostNameLength
    )
{
    KIRQL           OldIrql;

    UlAcquireSpinLock(&VirtHostLock, &OldIrql);
    if (pDefaultVirtualHost != NULL)
    {
        *pVirtHostID = pDefaultVirtualHost->HostID;
    }
    else
    {
        *pVirtHostID = 0;
    }

    UlReleaseSpinLock(&VirtHostLock, OldIrql);

}

/******************************************************************************

Routine Description:

    Acquire the update resource on a virtual host, given the virtual host ID,
    and return a pointer to the virtual host.

    Sort of faked up now, because we only support one virtual host.


Arguments:

    pVirtHostID             - Pointer to the virtual host ID

Return Value:

    Pointer to virtual host with update resource held, or NULL if we can't
    find or can't acquire the resource.

******************************************************************************/
PVIRTUAL_HOST
AcquireVirtualHostUpdateResource(
    IN  PVIRTUAL_HOST_ID    pVirtHostID
    )
{
    KIRQL           OldIrql;

    // The algorithm is this: find the proper virtual host structure
    // while holding the the spin lock that is used to look it up,
    // probably a spin lock on a hash table bucket eventually. While
    // holding this lock, see if a delete is in process. If there is one,
    // free the lock and fail this request because we can't acquire the
    // resource while the VH is going away. Otherwise, increment the update
    // count, free the lock, and acquire the resource. Anyone trying to delete
    // this VH will check the update count, and if it's non-zero they'll set
    // the deleting flag and block on the update done event until the update
    // count is decremented to 0. Whoever decrements the update flag to 0
    // must signal the update done event. Having the delete in progress flag
    // set will prevent anyone else from incrementing the count while someone
    // is waiting.

    UlAcquireSpinLock(&VirtHostLock, &OldIrql);
    if (pDefaultVirtualHost != NULL)
    {
        if (!(pDefaultVirtualHost->DeleteInProgress))
        {
            InterlockedIncrement(&pDefaultVirtualHost->UpdateCount);

            UlReleaseSpinLock(&VirtHostLock, OldIrql);

            ExAcquireResourceExclusive(&pDefaultVirtualHost->UpdateResource,
                                        TRUE
                                        );

            return pDefaultVirtualHost;
        }

    }

    // If we get here, either we didn't find the virtual host or it's in the
    // process of deleting.

    UlReleaseSpinLock(&VirtHostLock, OldIrql);

    return NULL;
}

/******************************************************************************

Routine Description:

    Release the update resource on a virtual host.

    Sort of faked up now, because we only support one virtual host.


Arguments:

    pVirtualHost            - Pointer to the virtual host
    pVirtHostID             - Pointer to the virtual host ID

Return Value:


******************************************************************************/
VOID
ReleaseVirtualHostUpdateResource(
    IN  PVIRTUAL_HOST       pVirtualHost,
    IN  PVIRTUAL_HOST_ID    pVirtHostID
    )
{
    ASSERT(pVirtualHost->UpdateCount >= 1);

    // Free the update resource, then decrement the update count. If it goes
    // to 0 signal the delete event to get whoever is deleteing this going.
    // No one will increment it after we decrement it if we dec to 0, since
    // the incrementing of the count is atomically interlocked with the
    // checking of the delete in progress flag.
    //

    ExReleaseResource(&pVirtualHost->UpdateResource);

    if (InterlockedDecrement(&pVirtualHost->UpdateCount) == 0)
    {
        KeSetEvent(&pVirtualHost->DeleteEvent, g_UlPriorityBoost, FALSE);
    }
}

/******************************************************************************

Routine Description:

    Delete a virtual host. Mostly a dummy routine now, just to make sure I've
    got some of my thoughts on how to do it down.

Arguments:

    pHostAddress        - Pointer to the host address for the new virtual
                            host. The IP address portion of the address
                            may be 0, in which case the host name identifies
                            the virtual host.

    pHostName           - Name of the virtual host. If this is NULL, the
                            host address must be fully specified.

    HostNameLength      - Length of host name.


Return Value:

    Status of attempt to delete virtual host.

******************************************************************************/


NTSTATUS
UlDeleteVirtualHost(
    IN  PTRANSPORT_ADDRESS  pHostAddress,
    IN  OPTIONAL PUCHAR     pHostName,
    IN  SIZE_T              HostNameLength
    )
{
    KIRQL           OldIrql;
    PVIRTUAL_HOST   pVirtualHost;

    //
    // It's a little tricky to do this given our URL table swapping strategy.
    // The basic idea is to find the virtual host, and while holding the
    // 'appropriate' lock, most likely whatever hash table bucket lock we have,
    // check to see if it's deleting or if there's an update in progress. If
    // it's deleting, it's an error. If there's an update in progress, block
    // until the update is finished.

    UlAcquireSpinLock(&VirtHostLock, &OldIrql);

    pVirtualHost = pDefaultVirtualHost;

    if (pVirtualHost != NULL)
    {
        if (pVirtualHost->DeleteInProgress)
        {
            // A delete already going on.
            UlReleaseSpinLock(&VirtHostLock, OldIrql);

            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if (pVirtualHost->UpdateCount == 1)
        {
            // No updates in progress, so remove him and free him now. Since
            // the update count is only incremented when the table lock is
            // held, it can't increase on us. But it might decrease, since
            // it's decremented outside the table lock scope. That's not
            // an issue here, since it should never get lower than 1. But
            // the code below needs to deal with this.
            //

            pDefaultVirtualHost = NULL;

            UlReleaseSpinLock(&VirtHostLock, OldIrql);
            // Not done yet!
            ASSERT(FALSE);
            return STATUS_SUCCESS;

        }
        else
        {
            // There's an update in progress. Set our deleting flag and
            // decrement the update count. If it goes to 0 it means the update
            // finished while we're here. If not, block on the delete event
            // and whoever decrements it to 0 will signal us.
            //

            pVirtualHost->DeleteInProgress = TRUE;

            if (InterlockedDecrement(&pVirtualHost->UpdateCount) == 0)
            {
                // It went to 0, so the update is done now.
                pDefaultVirtualHost = NULL;

                UlReleaseSpinLock(&VirtHostLock, OldIrql);
                // This code's not done yet!
                ASSERT(FALSE);
                return STATUS_SUCCESS;
            }
            UlReleaseSpinLock(&VirtHostLock, OldIrql);

            //
            // Someone could have come in and decremented the count to 0 before
            // we block. This is OK, we'll just fall right through the wait
            // in that case.
            //

            KeWaitForSingleObject((PVOID)&pVirtualHost->DeleteEvent,
                                    UserRequest,
                                    KernelMode,
                                    FALSE,
                                    NULL
                                    );

            // BUGBUG - Not done yet. Reacquire the lock, delete the virtual
            // host.
            ASSERT(FALSE);
            return STATUS_SUCCESS;

        }
    }

    UlReleaseSpinLock(&VirtHostLock, OldIrql);

    // Host wasn't found or delete already in progress.
    return STATUS_INVALID_DEVICE_REQUEST;
}

/******************************************************************************

Routine Description:

    Update the URL map table on a virtual host.

    We find the appropriate virtual host, then while holding the lock
    protecting that host we swap the old pointer out for the new map
    pointer. Since incrementing the reference count on the URL map
    is protected by the spinlock, we know that the reference count
    on the URL map can't be incremented after we do the swap.
    We then dereference the URL map.

    Sort of faked up now, because we only support one virtual host.


Arguments:

    pVirtualHost            - Pointer to the virtual host
    pVirtHostID             - Pointer to the virtual host ID
    pNewMapHeader           - Pointer to the new URL map.

Return Value:


******************************************************************************/
VOID
UpdateURLMapTable(
    IN  PVIRTUAL_HOST           pVirtualHost,
    IN  PVIRTUAL_HOST_ID        pVirtHostID,
    IN  PHTTP_URL_MAP_HEADER    pNewMapHeader
    )
{
    KIRQL                   OldIrql;
    PVIRTUAL_HOST           pUpdateVirtualHost;
    PHTTP_URL_MAP_HEADER    pOldMapHeader = NULL;

    UlAcquireSpinLock(&VirtHostLock, &OldIrql);

    pUpdateVirtualHost = pDefaultVirtualHost;

    if (pUpdateVirtualHost != NULL)
    {
        pOldMapHeader = pUpdateVirtualHost->pURLMapHeader;
        pUpdateVirtualHost->pURLMapHeader = pNewMapHeader;

    }
    UlReleaseSpinLock(&VirtHostLock, OldIrql);

    if (pOldMapHeader != NULL)
    {
        // Dereference this guy now, to remove the final reference. No
        // other references will be put on because we were synchronized
        // via the spinlock.

        DereferenceURLMap(pOldMapHeader);
    }

}


/******************************************************************************

Routine Description:

    Routine to initialize the virtual host module.

Return Value:

    NTSTATUS - Completion status.

******************************************************************************/
NTSTATUS
InitializeVirtHost(
    VOID
    )
{
    UlInitializeSpinLock(&VirtHostLock);
    UlInitializeSpinLock(&VirtualHostUpdateLock);

    return STATUS_SUCCESS;

}   // InitializeVirtHost


/******************************************************************************

Routine Description:

    Routine to terminate the virtual host module.

******************************************************************************/
VOID
TerminateVirtHost(
    VOID
    )
{
    // NYI

}   // TerminateVirtHost


/******************************************************************************

Routine Description:

    Chooses a new virtual host ID.

Return Value:

    VIRTUAL_HOST_ID - The new virtual host ID.

******************************************************************************/
VIRTUAL_HOST_ID
GetNextVirtualHostID(
    VOID
    )
{
    VIRTUAL_HOST_ID nextId;

    do
    {
        nextId = (VIRTUAL_HOST_ID)InterlockedIncrement(
                        (PLONG)&NextVirtualHostId
                        );

    } while (!VALID_HOST_ID(nextId));

    return nextId;

}   // GetNextVirtualHostID

#endif  // obsolete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\urlmap.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    urlmap.h

Abstract:

    The public definition of URL map interfaces.

Author:


Revision History:

--*/


#ifndef _URLMAP_H_
#define _URLMAP_H_

extern  UL_SPIN_LOCK    MapHeaderLock;      // Not really used.

typedef struct _NAME_SPACE_URL_ENTRY    *PNAME_SPACE_URL_ENTRY;
typedef struct _NAME_SPACE_GROUP_OBJECT *PNAME_SPACE_GROUP_OBJECT;

// Structure defining an entry in the map table.
//
typedef struct _HTTP_URL_MAP_ENTRY  // MapEntry
{
    struct _HTTP_URL_MAP_ENTRY  *pNextMapEntry;
    PVOID                       pNSGO;
    SIZE_T                      URLPrefixLength;
    UCHAR                       URLPrefix[ANYSIZE_ARRAY];

} HTTP_URL_MAP_ENTRY, *PHTTP_URL_MAP_ENTRY;

//
// Structure defining the URL map table.
//

typedef struct _HTTP_URL_MAP    // URLMap
{
    PHTTP_URL_MAP_ENTRY pFirstMapEntry;

} HTTP_URL_MAP, *PHTTP_URL_MAP;

//
// Structure defining the header for a URL map table.
//

typedef struct _HTTP_URL_MAP_HEADER   // MapHeader
{
    ULONG               RefCount;
    UL_WORK_ITEM        WorkItem;
    SIZE_T              EntryCount;
    HTTP_URL_MAP        Table;

} HTTP_URL_MAP_HEADER, *PHTTP_URL_MAP_HEADER;


#define ReferenceURLMap(pURLMap) \
    InterlockedIncrement(&(pURLMap)->RefCount)

PHTTP_URL_MAP_ENTRY
FindURLMapEntry(
    PHTTP_CONNECTION        pHttpConn,
    PHTTP_URL_MAP_HEADER    pMapHeader
    );

VOID
DelayedDereferenceURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    );

PHTTP_URL_MAP_HEADER
CreateURLMapHeader(
    VOID
    );

PHTTP_URL_MAP_HEADER
CopyURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    );

VOID
DereferenceURLMap(
    PHTTP_URL_MAP_HEADER    pMapHeader
    );

SIZE_T
AddURLMapEntry(
    IN  PVIRTUAL_HOST_ID            pVirtHostID,
    IN  PNAME_SPACE_URL_ENTRY       pNewURL,
    IN  PNAME_SPACE_GROUP_OBJECT    pNSGO,
    OUT NTSTATUS                    *pStatus
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\drv\archive\virthost.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    virthost.h

Abstract:

    The public definition of the virtual host interfaces.

Author:


Revision History:

--*/


#ifndef _VIRTHOST_H_
#define _VIRTHOST_H_

typedef struct _HTTP_URL_MAP_HEADER *PHTTP_URL_MAP_HEADER;

//
// Type of our internal virtual host ID structure, and macros for manipulating
// it.
typedef SIZE_T              VIRTUAL_HOST_ID, *PVIRTUAL_HOST_ID;
#define VALID_HOST_ID(HostID)               ((HostID) != 0)
#define HOST_ID_EQUAL(HostID1, HostID2)     ((HostID1) == (HostID2))

//
// Structure defining a virtual host object.
//

typedef struct _VIRTUAL_HOST    // VirtHost
{
    ERESOURCE               UpdateResource;
    KEVENT                  DeleteEvent;
    SIZE_T                  UpdateCount;
    SIZE_T                  DeleteInProgress:1;
    PTA_ADDRESS             pLocalAddress;
    PUCHAR                  pHostName;

    VIRTUAL_HOST_ID         HostID;

    PHTTP_CACHE_TABLE       pCacheTable;
    PHTTP_URL_MAP_HEADER    pURLMapHeader;

} VIRTUAL_HOST, *PVIRTUAL_HOST;

#define GetURLMapFromVirtualHost(pVirtHost) \
    (pVirtHost)->pURLMapHeader



PVIRTUAL_HOST
FindVirtualHost(
    IN  PHTTP_CONNECTION        pHttpConn,
    IN  PHTTP_CACHE_TABLE       *ppCacheTable,
    IN  PHTTP_URL_MAP_HEADER    *ppURLMapHeader
    );

NTSTATUS
UlCreateVirtualHost(
    IN  PTRANSPORT_ADDRESS  pHostAddress,
    IN  OPTIONAL PUCHAR     pHostName,
    IN  SIZE_T              HostNameLength,
    IN  ULONG               Flags
    );

NTSTATUS
UlDeleteVirtualHost(
    IN  PTRANSPORT_ADDRESS  pHostAddress,
    IN  OPTIONAL PUCHAR     pHostName,
    IN  SIZE_T              HostNameLength
    );


NTSTATUS
InsertVirtualHost(
    IN  PVIRTUAL_HOST       pVirtHost,
    IN  ULONG               Flags
    );

VOID
FindVirtualHostID(
    OUT PVIRTUAL_HOST_ID    VirtHostID,
    IN  PTRANSPORT_ADDRESS  pAddress,
    IN  PUCHAR              pHostName,
    IN  SIZE_T              HostNameLength
    );

PVIRTUAL_HOST
AcquireVirtualHostUpdateResource(
    IN  PVIRTUAL_HOST_ID    pVirtHostID
    );

VOID
ReleaseVirtualHostUpdateResource(
    IN  PVIRTUAL_HOST       pVirtualHost,
    IN  PVIRTUAL_HOST_ID    pVirtHostID
    );

VOID
UpdateURLMapTable(
    IN  PVIRTUAL_HOST           pVirtHost,
    IN  PVIRTUAL_HOST_ID        pVirtHostID,
    IN  PHTTP_URL_MAP_HEADER    pNewMapHeader
    );

#define DEFAULT_VIRTUAL_HOST    0x01

NTSTATUS
InitializeVirtHost(
    VOID
    );

VOID
TerminateVirtHost(
    VOID
    );

VIRTUAL_HOST_ID
GetNextVirtualHostID(
    VOID
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\misc\objtable.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    objtable.h

Abstract:

    This module contains public declarations and definitions for the
    UL object table package.

Author:

    Keith Moore (keithmo)       20-Apr-1999

Revision History:

--*/


#ifndef _OBJTABLE_H_
#define _OBJTABLE_H_


//
// Pointer to an object cleanup routine. This cleanup routine is invoked
// whenever the final reference to an object is removed by a call to
// UlDereferenceObject().
//
// Arguments:
//
//      pObjectInfo - Supplies a pointer to the UL_OBJECT_INFO structure
//          embedded within the object being destroyed. The destruction
//          handler can get to the original object with the
//          CONTAINING_RECORD() macro.
//
//  Note:
//
//      This routine is invoked without the table lock held.
//
//      This routine is invoked at the same IRQL as the caller to
//      UlDereferenceObject().
//

typedef
VOID
(NTAPI * PUL_DESTROY_HANDLER)(
    IN struct _UL_OBJECT_INFO *pObjectInfo
    );


//
// An object type definition. One of these must be registered with UL
// for each object type supported.
//

typedef struct _UL_OBJECT_TYPE
{
    //
    // All object types are kept on a global list.
    //

    LIST_ENTRY ObjectTypeListEntry;

    //
    // The cleanup routine for this object type.
    //

    PUL_DESTROY_HANDLER pDestroyHandler;

    //
    // The name of this object type.
    //

    UNICODE_STRING TypeName;

    //
    // Various statistics.
    //

    LONG ObjectsCreated;
    LONG ObjectsDestroyed;
    LONG References;
    LONG Dereferences;

} UL_OBJECT_TYPE, *PUL_OBJECT_TYPE;


//
// Per-object info. One of these structures must be present in each
// object managed by the object package.
//

typedef struct _UL_OBJECT_INFO
{
    //
    // Pointer to the type definition information for this object.
    //

    PUL_OBJECT_TYPE pType;

    //
    // The number of outstanding references to this object.
    //

    LONG ReferenceCount;

} UL_OBJECT_INFO, *PUL_OBJECT_INFO;


//
// Initialize/terminate the object table package.
//

NTSTATUS
UlInitializeObjectTablePackage(
    VOID
    );

VOID
UlTerminateObjectTablePackage(
    VOID
    );


//
// Initialize an object type descriptor.
//
// Arguments:
//
//      pType - Receives the initialized object type descriptor.
//
//      pTypeName - Supplies a human-readable name for the new type.
//
//      pDestroyHandler - Supplies the object destruction handler
//          for this type.
//
// Note:
//
//      The UL_OBJECT_TYPE structure must be in non-paged memory
//      and must remain available throughout the life of the driver.
//

VOID
UlInitializeObjectType(
    OUT PUL_OBJECT_TYPE pType,
    IN PWSTR pTypeName,
    IN PUL_DESTROY_HANDLER pDestroyHandler
    );


//
// Create a new object table.
//
// Arguments:
//
//      pNewObjectTable - Receives a pointer to the new object table
//          if successful.
//
// Return Value:
//
//      NTSTATUS - Completion status.
//


NTSTATUS
UlCreateObjectTable(
    OUT PUL_OBJECT_TABLE *pNewObjectTable
    );


//
// Destroys an existing object table.
//
// Arguments:
//
//      pObjectTable - Supplies the object table to destroy.
//
// Return Value:
//
//      NTSTATUS - Completion status.
//
// Note:
//
//      Any outstanding objects in the table are removed (and dereferenced)
//      by this routine. This may result in a flood of destruction handler
//      invocations.
//

NTSTATUS
UlDestroyObjectTable(
    IN PUL_OBJECT_TABLE pObjectTable
    );


//
// Creates an table entry for a newly created object.
//
// Arguments:
//
//      pObjectTable - Supplies the object table that will contain the
//          new object.
//
//      pObjectType - Supplies the object type for the new object.
//
//      pObjectInfo - Supplies a pointer to the UL_OBJECT_INFO
//          struture embedded within the newly created object.
//
//      pNewOpaqueId - Receives the new opaque ID for the object
//          if successful.
//
// Return Value:
//
//      NTSTATUS - Completion status.
//
// Note:
//
//      The newly created object (the one containing pObjectInfo) is
//      assumed to have been created with a reference count of at least
//      one. In other words, the object already accounts for the object
//      table's reference. This reference is removed when the object's
//      opaque ID is removed from the object table.
//

NTSTATUS
UlCreateObject(
    IN PUL_OBJECT_TABLE pObjectTable,
    IN PUL_OBJECT_TYPE pObjectType,
    IN PUL_OBJECT_INFO pObjectInfo,
    OUT PUL_OPAQUE_ID pNewOpaqueId
    );


//
// Closes an object by invaliding the opaque ID and dereferenceing the
// associated object.
//
// Arguments:
//
//      pObjectTable - Supplies the object table containing the object.
//
//      pObjectType - Supplies the object type for the object.
//
//      OpaqueId - Supplies the opaque ID of the object to close.
//
//      pLastReference - Receives TRUE if the last reference to the
//          object was removed.
//
// Return Value:
//
//      NTSTATUS - Completion status.
//

NTSTATUS
UlCloseObject(
    IN PUL_OBJECT_TABLE pObjectTable,
    IN PUL_OBJECT_TYPE pObjectType,
    IN UL_OPAQUE_ID OpaqueId,
    OUT PBOOLEAN pLastReference
    );


//
// Increments the reference count on an object given the object's
// opaque ID.
//
// Arguments:
//
//      pObjectTable - Supplies the object table containing the object.
//
//      pObjectType - Supplies the object type for the object.
//
//      OpaqueId - Supplies the opaque ID of the object to reference.
//
//      pObjectInfo - Receives a pointer to the UL_OBJECT_INFO structure
//          embedded within the referenced object if successful.
//
// Return Value:
//
//      NTSTATUS - Completion status.
//

NTSTATUS
UlReferenceObjectByOpaqueId(
    IN PUL_OBJECT_TABLE pObjectTable,
    IN PUL_OBJECT_TYPE pObjectType,
    IN UL_OPAQUE_ID OpaqueId,
    OUT PUL_OBJECT_INFO *pObjectInfo
    );


//
// Increments the reference count on an object given a pointer to
// the object.
//
// Arguments:
//
//      pObjectInfo - Supplies a pointer to the UL_OBJECT_INFO structure
//          embedded within the object to reference.
//

VOID
UlReferenceObjectByPointer(
    IN PUL_OBJECT_INFO pObjectInfo
    );


//
// Dereferences an object. If this removes the last reference to the
// object, then the destruction handler is invoked.
//
// Arguments:
//
//      pObjectInfo - Supplies a pointer to the UL_OBJECT_INFO structure
//          embedded within the object to dereference.
//
// Return Value:
//
//      BOOLEAN - TRUE if the final reference to the object was removed
//          (and therefore the destruction handler was invoked), FALSE
//          otherwise.
//

BOOLEAN
UlDereferenceObject(
    IN PUL_OBJECT_INFO pObjectInfo
    );


#endif  // _OBJTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\misc\objtable.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    objtable.c

Abstract:

    This module implements the object ID table. The ID table is
    implemented as a two-level array.

    The first level is an array of pointers to the second-level arrays.
    This first-level array is growable, but this should happen very
    infrequently.

    The second level is an array of OBJECT_TABLE_ENTRY structures.
    These structures contain a cyclic (to detect stale IDs) and a caller-
    supplied context value.

    The data structures may be diagrammed as follows:

        g_FirstLevelTable
               |
               |   +-----+
               |   |     |      +-----+-----+-----+-----+-----+-----+
               |   |     |      | OBJECT_   | OBJECT_   | OBJECT_   |
               +-->|  *-------->| TABLE_    | TABLE_    | TABLE_    |
                   |     |      | ENTRY     | ENTRY     | ENTRY     |
                   |     |      +-----+-----+-----+-----+-----+-----+
                   +-----+
                   |     |      +-----+-----+-----+-----+-----+-----+
                   |     |      | OBJECT_   | OBJECT_   | OBJECT_   |
                   |  *-------->| TABLE_    | TABLE_    | TABLE_    |
                   |     |      | ENTRY     | ENTRY     | ENTRY     |
                   |     |      +-----+-----+-----+-----+-----+-----+
                   +-----+
                   |     .
                   |     .
                   .     .
                   .     |
                   .     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+
                   |     |
                   |     |
                   |  /  |
                   |     |
                   |     |
                   +-----+

    Note that all free OBJECT_TABLE_ENTRY structures are kept on a single
    (global) free list. Whenever a new ID needs to be allocated, the free
    list is consulted. If it's not empty, an item is popped from the list
    and used. If the list is empty, then new space must be allocated. Best
    case, this will involve the allocation of a new second-level array.
    Worst case, this will also involve a reallocation of the first-level
    array. Reallocation of the first-level array should be relatively rare.

    A UL_OPAQUE_ID is opaque at user-mode. Internally, it consists of three
    fields:

        1) An index into the first-level array.
        2) An index into the second-level array referenced by the
           first-level index.
        3) A cyclic, used to detect stale IDs.

    See the OPAQUE_ID_INTERNAL structure definition (below) for details.

Author:

    Keith Moore (keithmo)       20-Apr-1999

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define FIRST_LEVEL_TABLE_GROWTH    32      // entries
#define SECOND_LEVEL_TABLE_SIZE     256     // entries


//
// Private prototypes.
//

POPAQUE_ID_TABLE_ENTRY
UlpMapOpaqueIdToTableEntry(
    IN UL_OPAQUE_ID OpaqueId
    );

NTSTATUS
UlpReallocOpaqueIdTables(
    IN ULONG CapturedFirstTableSize,
    IN ULONG CapturedFirstTableInUse
    );

__inline
CYCLIC
UlpGetNextCyclic(
    VOID
    )
{
    OPAQUE_ID_TABLE_ENTRY entry;

    entry.Cyclic = (CYCLIC)InterlockedIncrement( &g_OpaqueIdCyclic );
    entry.EntryType = ENTRY_TYPE_IN_USE;

    return entry.Cyclic;

}   // UlpGetNextCyclic


//
// Private globals.
//

LIST_ENTRY g_UlObjectTypeListHead;
UL_SPIN_LOCK g_UlObjectLock;


#ifdef ALLOC_PRAGMA
#pragma alloc_text( INIT, UlInitializeObjectTablePackage )
#pragma alloc_text( PAGE, UlTerminateObjectTablePackage )
#pragma alloc_text( INIT, UlInitializeObjectType )
#pragma alloc_text( PAGE, UlCreateObjectTable )
#pragma alloc_text( PAGE, UlDestroyObjectTable )
#pragma alloc_text( PAGE, UlCreateObject )
#pragma alloc_text( PAGE, UlCloseObject )
#pragma alloc_text( PAGE, UlReferenceObjectByOpaqueId )
#pragma alloc_text( PAGE, UlReferenceObjectByPointer )
#pragma alloc_text( PAGE, UlDereferenceObject )
#endif  // ALLOC_PRAGMA
#if 0
NOT PAGEABLE -- UlpMapOpaqueIdToTableEntry
NOT PAGEABLE -- UlpReallocOpaqueIdTables
#endif


//
// Public functions.
//

/***************************************************************************++

Routine Description:

    Performs global initialization of the object table package.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlInitializeObjectTablePackage(
    VOID
    )
{
    LARGE_INTEGER timeNow;

    INITIALIZE_LOCK( &g_OpaqueIdTableLock );
    KeInitializeSpinLock( &g_FreeOpaqueIdSListLock );
    ExInitializeSListHead( &g_FreeOpaqueIdSListHead );

    KeQuerySystemTime( &timeNow );
    g_OpaqueIdCyclic = (LONG)( timeNow.HighPart + timeNow.LowPart );

    g_FirstLevelTableInUse = 0;
    g_FirstLevelTableSize = FIRST_LEVEL_TABLE_GROWTH;

    //
    // Go ahead and allocate the first-level table now. This makes the
    // normal runtime path a little cleaner because it doesn't have to
    // deal with the "first time" case.
    //

    g_FirstLevelTable = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            POPAQUE_ID_TABLE_ENTRY,
                            g_FirstLevelTableSize,
                            UL_OPAQUE_ID_TABLE_POOL_TAG
                            );

    if (g_FirstLevelTable == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(
        g_FirstLevelTable,
        g_FirstLevelTableSize * sizeof(POPAQUE_ID_TABLE_ENTRY)
        );

    return STATUS_SUCCESS;

}   // InitializeOpaqueIdTable


/***************************************************************************++

Routine Description:

    Performs global termination of the object table package.

--***************************************************************************/
VOID
UlTerminateObjectTablePackage(
    VOID
    )
{
    ULONG i;

    if (g_FirstLevelTable != NULL)
    {
        //
        // Free the second-level tables.
        //

        for (i = 0 ; i < g_FirstLevelTableInUse ; i++)
        {
            if (g_FirstLevelTable[i] != NULL)
            {
                UL_FREE_POOL(
                    g_FirstLevelTable[i],
                    UL_OPAQUE_ID_TABLE_POOL_TAG
                    );
            }

            g_FirstLevelTable[i] = NULL;
        }

        //
        // Free the first-level table.
        //

        UL_FREE_POOL(
            g_FirstLevelTable,
            UL_OPAQUE_ID_TABLE_POOL_TAG
            );

        g_FirstLevelTable = NULL;
    }

    ExInitializeSListHead( &g_FreeOpaqueIdSListHead );

    g_OpaqueIdCyclic = 0;
    g_FirstLevelTableSize = 0;
    g_FirstLevelTableInUse = 0;

}   // TerminateOpaqueIdTable


/***************************************************************************++

Routine Description:

    Allocates a new opaque ID and associates it with the specified context.

Arguments:

    pOpaqueId - Receives the newly allocated opaque ID if successful.

    OpaqueIdType - Supplies an uninterpreted

    pContext - Supplies the context to associate with the new opaque ID.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlAllocateOpaqueId(
    OUT PUL_OPAQUE_ID pOpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType,
    IN PVOID pContext
    )
{
    NTSTATUS status;
    CYCLIC cyclic;
    ULONG firstIndex;
    ULONG secondIndex;
    PSINGLE_LIST_ENTRY listEntry;
    OPAQUE_ID_INTERNAL internal;
    POPAQUE_ID_TABLE_ENTRY tableEntry;
    ULONG capturedFirstTableSize;
    ULONG capturedFirstTableInUse;

#if HACK_OPAQUE_ID
    KIRQL oldIrql;

    oldIrql = KeRaiseIrqlToDpcLevel();
#endif

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Allocate a new cyclic while we're outside the lock.
    //

    cyclic = UlpGetNextCyclic();

    //
    // Loop, trying to allocate an item from the table.
    //

    do
    {
        ACQUIRE_READ_LOCK( &g_OpaqueIdTableLock );

        listEntry = ExInterlockedPopEntrySList(
                        &g_FreeOpaqueIdSListHead,
                        &g_FreeOpaqueIdSListLock
                        );

        if (listEntry != NULL)
        {
            //
            // The free list isn't empty, so we can just use this
            // entry. We'll calculate the indices for this entry,
            // initialize the entry, then release the table lock.
            //

            tableEntry = CONTAINING_RECORD(
                             listEntry,
                             OPAQUE_ID_TABLE_ENTRY,
                             FreeListEntry
                             );

            firstIndex = tableEntry->FirstLevelIndex;
            secondIndex = (ULONG)(tableEntry - g_FirstLevelTable[firstIndex]);

            tableEntry->pContext = pContext;
            tableEntry->Cyclic = cyclic;

            RELEASE_READ_LOCK( &g_OpaqueIdTableLock );

            //
            // Pack the cyclic & indices into the opaque ID and return it.
            //

            internal.Cyclic = cyclic;
            internal.FirstIndex = firstIndex;
            internal.SecondIndex = secondIndex;

            *pOpaqueId = internal.OpaqueId;

#if HACK_OPAQUE_ID
            if (oldIrql != DISPATCH_LEVEL)
            {
                KeLowerIrql( oldIrql );
            }
#endif
            return STATUS_SUCCESS;
        }

        //
        // We only make it to this point if the free list is empty,
        // meaning we need to do some memory allocations before
        // we can continue. We'll put this off into a separate routine
        // to keep this one small (to avoid cache thrash). The realloc
        // routine returns STATUS_SUCCESS if it (or another thread)
        // managed to successfully reallocate the tables. Otherwise, it
        // returns a failure code.
        //

        capturedFirstTableSize = g_FirstLevelTableSize;
        capturedFirstTableInUse = g_FirstLevelTableInUse;
        RELEASE_READ_LOCK( &g_OpaqueIdTableLock );

        status = UlpReallocOpaqueIdTables(
                        capturedFirstTableSize,
                        capturedFirstTableInUse
                        );

    } while( status == STATUS_SUCCESS );

    return status;

}   // UlAllocateOpaqueId


/***************************************************************************++

Routine Description:

    Frees the specified opaque ID.

Arguments:

    OpaqueId - Supplies the connection ID to free.

Return Value:

    PVOID - Returns the HTTP_CONNECTION associated with the
        connection ID if successful, NULL otherwise.

--***************************************************************************/
PVOID
UlFreeOpaqueId(
    IN UL_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    )
{
    POPAQUE_ID_TABLE_ENTRY tableEntry;
    PVOID pContext;

#if HACK_OPAQUE_ID
    KIRQL oldIrql;

    oldIrql = KeRaiseIrqlToDpcLevel();
#endif

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Try to map the opaque ID to a table entry.
    //

    tableEntry = UlpMapOpaqueIdToTableEntry( OpaqueId );

    if (tableEntry != NULL)
    {
        OPAQUE_ID_INTERNAL internal;

        //
        // Got a match. Snag the context, free the table entry, then
        // unlock the table.
        //

        pContext = tableEntry->pContext;

        internal.OpaqueId = OpaqueId;
        tableEntry->FirstLevelIndex = internal.FirstIndex;
        tableEntry->EntryType = ENTRY_TYPE_FREE;

        ExInterlockedPushEntrySList(
            &g_FreeOpaqueIdSListHead,
            &tableEntry->FreeListEntry,
            &g_FreeOpaqueIdSListLock
            );

        RELEASE_READ_LOCK( &g_OpaqueIdTableLock );
#if HACK_OPAQUE_ID
        if (oldIrql != DISPATCH_LEVEL)
        {
            KeLowerIrql( oldIrql );
        }
#endif
        return pContext;
    }

#if HACK_OPAQUE_ID
    if (oldIrql != DISPATCH_LEVEL)
    {
        KeLowerIrql( oldIrql );
    }
#endif
    return NULL;

}   // UlFreeOpaqueId


/***************************************************************************++

Routine Description:

    Maps the specified opaque ID to the corresponding context value.

Arguments:

    OpaqueId - Supplies the opaque ID to map.

Return Value:

    PVOID - Returns the context value associated with the opaque ID
        if successful, NULL otherwise.

--***************************************************************************/
PVOID
UlGetObjectFromOpaqueId(
    IN UL_OPAQUE_ID OpaqueId,
    IN UL_OPAQUE_ID_TYPE OpaqueIdType
    )
{
    POPAQUE_ID_TABLE_ENTRY tableEntry;
    PVOID pContext;

#if HACK_OPAQUE_ID
    KIRQL oldIrql;

    oldIrql = KeRaiseIrqlToDpcLevel();
#endif

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Try to map the opaque ID to a table entry.
    //

    tableEntry = UlpMapOpaqueIdToTableEntry( OpaqueId );

    if (tableEntry != NULL)
    {
        //
        // Got a match. Retrieve the context value, then unlock the
        // table. Note that we cannot touch the table entry once we
        // unlock the table.
        //

        pContext = tableEntry->pContext;

        RELEASE_READ_LOCK( &g_OpaqueIdTableLock );
#if HACK_OPAQUE_ID
        if (oldIrql != DISPATCH_LEVEL)
        {
            KeLowerIrql( oldIrql );
        }
#endif
        return pContext;
    }

#if HACK_OPAQUE_ID
    if (oldIrql != DISPATCH_LEVEL)
    {
        KeLowerIrql( oldIrql );
    }
#endif
    return NULL;

}   // UlGetObjectFromOpaqueId


//
// Private functions.
//

/***************************************************************************++

Routine Description:

    Maps the specified UL_OPAQUE_ID to the corresponding
    PVOID pointer.

Arguments:

    OpaqueId - Supplies the opaque ID to map.

Return Value:

    POPAQUE_ID_TABLE_ENTRY - Pointer to the table entry corresponding to the
        opaque ID if successful, NULL otherwise.

    N.B. If this function is successful, it returns with the table lock
        held for read access!

--***************************************************************************/
POPAQUE_ID_TABLE_ENTRY
UlpMapOpaqueIdToTableEntry(
    IN UL_OPAQUE_ID OpaqueId
    )
{
    POPAQUE_ID_TABLE_ENTRY secondTable;
    POPAQUE_ID_TABLE_ENTRY tableEntry;
    OPAQUE_ID_INTERNAL internal;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );

    //
    // Unpack the ID.
    //

    internal.OpaqueId = OpaqueId;

    //
    // Lock the table.
    //

    ACQUIRE_READ_LOCK( &g_OpaqueIdTableLock );

    //
    // Validate the index.
    //

    if (internal.FirstIndex >= 0 &&
        internal.FirstIndex < g_FirstLevelTableInUse)
    {
        secondTable = g_FirstLevelTable[internal.FirstIndex];
        ASSERT( secondTable != NULL );
        ASSERT( internal.SecondIndex >= 0 );
        ASSERT( internal.SecondIndex <= SECOND_LEVEL_TABLE_SIZE );

        tableEntry = secondTable + internal.SecondIndex;

        //
        // The index is within legal range. Ensure it's in use and
        // the cyclic matches.
        //

        if (tableEntry->Cyclic == internal.Cyclic &&
            tableEntry->EntryType == ENTRY_TYPE_IN_USE)
        {
            return tableEntry;
        }
    }

    //
    // Invalid opaque ID. Fail it.
    //

    RELEASE_READ_LOCK( &g_OpaqueIdTableLock );
    return NULL;

}   // UlpMapOpaqueIdToTableEntry


/***************************************************************************++

Routine Description:

    Allocates a new second-level table, and (optionally) reallocates the
    first-level table if necessary.

Arguments:

    CapturedFirstTableSize - The size of the first-level table as captured
        with the table lock held.

    CapturedFirstTableInUse - The number of entries currently used in the
        first-level table as captured with the table lock held.

Return Value:

    NTSTATUS - Completion status.

--***************************************************************************/
NTSTATUS
UlpReallocOpaqueIdTables(
    IN ULONG CapturedFirstTableSize,
    IN ULONG CapturedFirstTableInUse
    )
{
    ULONG firstIndex;
    ULONG secondIndex;
    POPAQUE_ID_TABLE_ENTRY tableEntry;
    POPAQUE_ID_TABLE_ENTRY newSecondTable;
    POPAQUE_ID_TABLE_ENTRY *newFirstTable;
    ULONG newFirstTableSize;
    ULONG i;
    PLIST_ENTRY listEntry;

    //
    // Sanity check.
    //

    ASSERT( KeGetCurrentIrql() == DISPATCH_LEVEL );
    ASSERT( ExQueryDepthSList( &g_FreeOpaqueIdSListHead ) == 0 );

    //
    // Assume we won't actually allocate anything.
    //

    newFirstTable = NULL;
    newSecondTable = NULL;

    //
    // Allocate a new second-level table.
    //

    newSecondTable = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            OPAQUE_ID_TABLE_ENTRY,
                            SECOND_LEVEL_TABLE_SIZE,
                            UL_OPAQUE_ID_TABLE_POOL_TAG
                            );

    if (newSecondTable == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    if (CapturedFirstTableInUse == CapturedFirstTableSize)
    {
        //
        // We need a new first-level table.
        //

        newFirstTableSize =
            CapturedFirstTableSize + FIRST_LEVEL_TABLE_GROWTH;

        newFirstTable = UL_ALLOCATE_ARRAY(
                            NonPagedPool,
                            POPAQUE_ID_TABLE_ENTRY,
                            newFirstTableSize,
                            UL_OPAQUE_ID_TABLE_POOL_TAG
                            );

        if (newFirstTable == NULL)
        {
            UL_FREE_POOL( newSecondTable, UL_OPAQUE_ID_TABLE_POOL_TAG );
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(
            newFirstTable + CapturedFirstTableSize,
            FIRST_LEVEL_TABLE_GROWTH * sizeof(POPAQUE_ID_TABLE_ENTRY)
            );
    }

    //
    // OK, we've got the new table(s). Acquire the lock for write access
    // and see if another thread has already done the work for us.
    //

    ACQUIRE_WRITE_LOCK( &g_OpaqueIdTableLock );

    if (ExQueryDepthSList( &g_FreeOpaqueIdSListHead ) == 0)
    {
        //
        // The free list is still empty. This could potentially
        // mean that another thread has already performed the
        // realloc and all of *those* new entries are now in use.
        // We can detect this by comparing the current table size
        // with the size we captured previously with the lock held.
        //

        if (CapturedFirstTableSize != g_FirstLevelTableSize)
        {
            goto cleanup;
        }

        //
        // OK, we're the one performing the realloc.
        //

        if (newFirstTable != NULL)
        {
            POPAQUE_ID_TABLE_ENTRY *tmp;

            //
            // Copy the old table into the new table.
            //

            RtlCopyMemory(
                newFirstTable,
                g_FirstLevelTable,
                g_FirstLevelTableSize * sizeof(POPAQUE_ID_TABLE_ENTRY)
                );

            //
            // Swap the new & old table pointers so we can keep the
            // original pointer & free it later (after we've released
            // the table lock).
            //

            tmp = g_FirstLevelTable;
            g_FirstLevelTable = newFirstTable;
            newFirstTable = tmp;

            g_FirstLevelTableSize = newFirstTableSize;
        }

        //
        // Attach the second-level table to the first-level table,
        //

        ASSERT( g_FirstLevelTable[g_FirstLevelTableInUse] == NULL );
        g_FirstLevelTable[g_FirstLevelTableInUse++] = newSecondTable;
        ASSERT( g_FirstLevelTableInUse <= g_FirstLevelTableSize );

        //
        // Link it onto the global free list.
        //

        for (i = 0 ; i < SECOND_LEVEL_TABLE_SIZE ; i++)
        {
            newSecondTable[i].FirstLevelIndex = CapturedFirstTableInUse;
            newSecondTable[i].EntryType = ENTRY_TYPE_FREE;

            ExInterlockedPushEntrySList(
                &g_FreeOpaqueIdSListHead,
                &newSecondTable[i].FreeListEntry,
                &g_FreeOpaqueIdSListLock
                );
        }

        //
        // Remember that we don't need to free the second-level table.
        //

        newSecondTable = NULL;
    }
    else
    {
        //
        // The free list was not empty after we reacquired the lock,
        // indicating that another thread has already performed the
        // realloc. This is cool; we'll just free the pool we allocated
        // and return.
        //
    }

    //
    // Cleanup.
    //

cleanup:

    RELEASE_WRITE_LOCK( &g_OpaqueIdTableLock );

    if (newSecondTable != NULL)
    {
        UL_FREE_POOL( newSecondTable, UL_OPAQUE_ID_TABLE_POOL_TAG );
    }

    if (newFirstTable != NULL)
    {
        UL_FREE_POOL( newFirstTable, UL_OPAQUE_ID_TABLE_POOL_TAG );
    }

    return STATUS_SUCCESS;

}   // UlpReallocOpaqueIdTables
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\misc\iul.h ===
UL APIs that need to be represented in the managed interface:

    UlOpenAppPool

    UlReceiveHttpRequest
    UlReceiveEntityBody
    UlSendHttpResponse
    UlSendEntityBody

    UlCloseConnection                   <- NYI, questionable value

    UlFlushResponseCache
    UlEnumerateCacheContents            <- New API wanted by XSP folks

    UlRegisterUrlPrefix                 <- New transient registrations APIs
    UlDeregisterUrlPrefix               <-






class UlGlobal
{
    static UlListener OpenAppPool( ... );
    static UlListener RegisterUrlPrefix( ... );
};

class UlListener
{
    // Async I/O callback stuff

    AsyncResult ReceiveRequest( ... );  // async, UlRequest via delegate?
    UlRequest ReceiveRequest( ... );    // synch

    ??? Deregister( ... );              // implied via destructor?
    AsyncResult FlushCache( ... );
    ??? QueryCache( ... );
};

class UlRequest // derives from common base shared with Net Classes
{
    AsyncResult ReceiveEntityBody( ... );
    AsyncResult ForceDisconnect( ... );

    UlResponse GetResponse( ... );
};

class UlResponse // derives from common base shared with Net Classes
{
    AsyncResult SendResponse( ... );    
    AsyncResult SendEntityBody( ... );  
};




































class HttpGlobal
{
    static HttpListener OpenAppPool( ... );
    static HttpListener RegisterUrlPrefix( ... );
};

class HttpListener
{
    // Async I/O Goo goes here

    ServerHttpRequest GetRequest( ... );
    AsyncResult AsyncGetRequest( ... );

    ??? FlushCache( ... );
    AsyncResult AsyncFlushCache( ... );

    ??? QueryCache( ... );
};

class BaseHttpRequest
{
    read-only Verb
    read-only Headers
    read-only URL
};

class ClientHttpRequest : BaseHttpRequest
{
    read-write Verb
    read-write Headers

    ClientHttpResponse GetResponse( ... );
    AsyncResult AsyncGetResponse( ... );
};

class ServerHttpRequest : BaseHttpRequest
{
    ServerHttpResponse GetResponse( ... );
};

class BaseHttpResponse
{
    read-only result-code
    read-only result-string
    read-only headers
};

class ClientHttpResponse : BaseHttpResponse
{
    ??
};

class ServerHttpResponse : BaseHttpResponse
{
    // Async I/O Goo goes here

    AsyncResult SendResponse( ... {pbuf, cb} );
    AsyncResult SendEntityBody( ... );

    read-write base properties
};


ISSUES:

    Mechanism to indicate client disconnects to user-mode?
    Integrate AppPool and transient URL registration?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\misc\objtablep.h ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    objtablep.h

Abstract:

    This module contains private declarations and definitions for the
    UL object table package.

Author:

    Keith Moore (keithmo)       20-Apr-1999

Revision History:

--*/


#ifndef _OBJTABLEP_H_
#define _OBJTABLEP_H_


//
// Our cyclic type. Just a 32-bit value.
//

typedef ULONG CYCLIC;


//
// An object table.
//

typedef struct _UL_OBJECT_TABLE
{
    //
    // Structure signature.
    //

    ULONG Signature;

    //
    // The lock protecting the table.
    //

    UL_SPIN_LOCK TableSpinLock;

    //
    // The free entry list. Note that the spin-lock is only used on
    // processor architectures that don't natively support SLISTs.
    //

    SLIST_HEADER FreeEntrySListHead;
    KSPIN_LOCK FreeEntrySListLock;

    //
    // The first-level lookup table.
    //

    struct _UL_OBJECT_TABLE_ENTRY **ppFirstLevelTable;

    //
    // Usage counters.
    //

    ULONG FirstLevelTableSize;
    ULONG FirstLevelTableInUse;

    //
    // The cyclic.
    //

    CYCLIC Cyclic;

} UL_OBJECT_TABLE, *PUL_OBJECT_TABLE;


//
// The internal structure of an UL_OPAQUE_ID.
//
// N.B. This structure must be EXACTLY the same size as an UL_OPAQUE_ID!
//

#define FIRST_INDEX_BIT_WIDTH   24
#define SECOND_INDEX_BIT_WIDTH  8

typedef union _OPAQUE_ID_INTERNAL
{
    UL_OPAQUE_ID OpaqueId;

    struct
    {
        CYCLIC Cyclic;
        ULONG FirstIndex:FIRST_INDEX_BIT_WIDTH;
        ULONG SecondIndex:SECOND_INDEX_BIT_WIDTH;
    };

} OPAQUE_ID_INTERNAL, *POPAQUE_ID_INTERNAL;

C_ASSERT( sizeof(UL_OPAQUE_ID) == sizeof(OPAQUE_ID_INTERNAL) );
C_ASSERT( (FIRST_INDEX_BIT_WIDTH + SECOND_INDEX_BIT_WIDTH) ==
    (sizeof(CYCLIC) * 8) );


//
// A second-level table entry.
//
// Note that FreeListEntry and pContext are in an anonymous
// union to save space; an entry is either on the free list or in use,
// so only one of these fields will be used at a time.
//
// Also note that Cyclic is in a second anonymous union. It's overlayed
// with FirstLevelIndex (which is basically the second-level table's
// index in the first-level table) and EntryType (used to distinguish
// free entries from in-use entries). The internal GetNextCyclic() function
// is careful to always return cyclics with EntryType set to
// ENTRY_TYPE_IN_USE.
//

typedef struct _OPAQUE_ID_TABLE_ENTRY
{
    union
    {
        SINGLE_LIST_ENTRY FreeListEntry;
        PVOID pContext;
    };

    union
    {
        CYCLIC Cyclic;

        struct
        {
            ULONG FirstLevelIndex:FIRST_INDEX_BIT_WIDTH;
            ULONG EntryType:SECOND_INDEX_BIT_WIDTH;
        };
    };

} OPAQUE_ID_TABLE_ENTRY, *POPAQUE_ID_TABLE_ENTRY;

#define ENTRY_TYPE_FREE     0xFF
#define ENTRY_TYPE_IN_USE   0x00


#endif  // _OBJTABLEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\qosinc\gpcifc.h ===
/********************************************************************/
/**                 Microsoft Generic Packet Scheduler             **/
/**               Copyright(c) Microsoft Corp., 1996-1997          **/
/********************************************************************/

#ifndef __GPCIFC
#define __GPCIFC

//***   gpcifc.h - GPC interface definitions
//
//  This file containes all the GPC interface definitions.


/*
/////////////////////////////////////////////////////////////////
//
//   defines
//
/////////////////////////////////////////////////////////////////
*/

//
// Protocol Template Id's
//
#define GPC_PROTOCOL_TEMPLATE_IP                  0
#define GPC_PROTOCOL_TEMPLATE_IPX                 1

#define GPC_PROTOCOL_TEMPLATE_MAX                 2

#define GPC_PROTOCOL_TEMPLATE_NOT_SPECIFIED       (-1)

#define DD_GPC_DEVICE_NAME      L"\\Device\\Gpc"

#define GpcMajorVersion 2

//
// GPC max supported priorities
//
#define GPC_PRIORITY_MAX    16

//
// Classification Family IDs
//
#define GPC_CF_QOS			0
#define GPC_CF_IPSEC_OUT	1
#define GPC_CF_IPSEC_IN		2
#define GPC_CF_FILTER		3
#define GPC_CF_CLASS_MAP	4

#define GPC_CF_MAX			5

//
// IPSEC specific
//
#define GPC_PRIORITY_IPSEC	2
#define GPC_CF_IPSEC	    GPC_CF_IPSEC_OUT
#define GPC_CF_IPSEC_MAX    GPC_CF_IPSEC_IN
#define GPC_CF_IPSEC_MIN    GPC_CF_IPSEC_OUT

//
// GPC flags defined
//
#define GPC_FLAGS_FRAGMENT          0x00000001

#define MAX_STRING_LENGTH	256

//
// handle definitions and error codes
//
#define GPC_INVALID_HANDLE	    (-1)

#define GPC_STATUS_SUCCESS				STATUS_SUCCESS
#define GPC_STATUS_PENDING				STATUS_PENDING
#define GPC_STATUS_FAILURE				STATUS_UNSUCCESSFUL
#define GPC_STATUS_RESOURCES			STATUS_INSUFFICIENT_RESOURCES
#define GPC_STATUS_NOTREADY				STATUS_DEVICE_NOT_READY 
#define GPC_STATUS_NOT_FOUND			STATUS_NOT_FOUND
#define GPC_STATUS_CONFLICT				STATUS_DUPLICATE_NAME
#define GPC_STATUS_INVALID_HANDLE		STATUS_INVALID_HANDLE
#define GPC_STATUS_INVALID_PARAMETER	STATUS_INVALID_PARAMETER
#define GPC_STATUS_NOT_SUPPORTED    	STATUS_NOT_SUPPORTED
#define GPC_STATUS_NOT_EMPTY            STATUS_DIRECTORY_NOT_EMPTY
#define GPC_STATUS_TOO_MANY_HANDLES     STATUS_TOO_MANY_OPENED_FILES
#define GPC_STATUS_NOT_IMPLEMENTED      STATUS_NOT_IMPLEMENTED
#define GPC_STATUS_INSUFFICIENT_BUFFER	STATUS_BUFFER_TOO_SMALL
#define GPC_STATUS_NO_MEMORY			STATUS_NO_MEMORY
#define GPC_STATUS_IGNORED				1L


/*
/////////////////////////////////////////////////////////////////
//
//   typedef
//
/////////////////////////////////////////////////////////////////
*/

//
// Gpc status
//
typedef NTSTATUS  GPC_STATUS;

//
// handles
//

typedef HANDLE  GPC_HANDLE, *PGPC_HANDLE;
typedef HANDLE  GPC_CLIENT_HANDLE, *PGPC_CLIENT_HANDLE;

//
// A classification handle is used as a reference to a classification 
// block by the clients
//

typedef ULONG	CLASSIFICATION_HANDLE, *PCLASSIFICATION_HANDLE;

//
// A pointer to the CfInfo blob data that is stored in the GPC.
// The client will use this definition in all references to a CfInfo blob.
//

typedef UCHAR	GPC_CFINFO, *PGPC_CFINFO;

typedef VOID    GPC_PATTERN, *PGPC_PATTERN;

typedef struct _TC_INTERFACE_ID {

    ULONG	InterfaceId;
    ULONG	LinkId;

} TC_INTERFACE_ID, *PTC_INTERFACE_ID;

//
// Clients on the IP stack use the IP template.
// The usage of the union is defined by the value of the ProtocolId,
// which can be IP, TCP, UDP, ICMP or IPSEC.
//
typedef struct _GPC_IP_PATTERN {

    TC_INTERFACE_ID	InterfaceId;
    ULONG			SrcAddr;
    ULONG			DstAddr;
	
    union {
        struct { USHORT s_srcport,s_dstport; } S_un_ports;	      // UDP, TCP
        struct { UCHAR s_type,s_code; USHORT filler; } S_un_icmp; // ICMP
        ULONG	S_Spi;							                  // IPSEC
    } S_un;

    UCHAR	    	ProtocolId;

    UCHAR       	Reserved[3];
    
#define gpcSrcPort	S_un.S_un_ports.s_srcport
#define gpcDstPort	S_un.S_un_ports.s_dstport
#define gpcIcmpType	S_un.S_un_icmp.s_type
#define gpcIcmpCode	S_un.S_un_icmp.s_code
#define gpcSpi		S_un.S_Spi

} GPC_IP_PATTERN, *PGPC_IP_PATTERN;

//
// Clients of the IPX stack will use the IPX pattern
//
typedef struct _GPC_IPX_PATTERN {

    struct {
        ULONG 	NetworkAddress;
        UCHAR 	NodeAddress[6];
        USHORT 	Socket;
    } Src, Dest;

} GPC_IPX_PATTERN, *PGPC_IPX_PATTERN;


typedef struct _GPC_GEN_PATTERN {

    ULONG	ProtocolId;
	ULONG	PatternSize;
	ULONG  	PatternOffset;
	ULONG  	MaskOffset;
    //
    // the pattern and mask bits will follow here...
    //

} GPC_GEN_PATTERN, *PGPC_GEN_PATTERN;


typedef struct _GPC_ENUM_CFINFO_BUFFER {

    ULONG				Length;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    ULONG				CfInfoSize;
    ULONG				CfInfoOffset;	// from the beginning of this buffer
    GPC_CLIENT_HANDLE	OwnerClientCtx;
    ULONG				PatternCount;
    ULONG				PatternMaskLen;
    GPC_GEN_PATTERN		GenericPattern[1];

} GPC_ENUM_CFINFO_BUFFER, *PGPC_ENUM_CFINFO_BUFFER;

/*
/////////////////////////////////////////////////////////////////
//
//   Client handler prototypes
//
/////////////////////////////////////////////////////////////////
*/


typedef
GPC_STATUS
(*GPC_CL_ADD_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_HANDLE				GpcCfInfoHandle,
    IN  ULONG                   CfInfoSize,
    IN  PVOID					pCfInfo,
	OUT	PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

  
typedef
VOID
(*GPC_CL_ADD_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
VOID
(*GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS	        	Status
    );


typedef
GPC_STATUS
(*GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    IN	ULONG					CfInfoSize,
	IN	PVOID                   pNewCfInfo
    );


typedef
VOID
(*GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	IN	GPC_STATUS				Status
    );


typedef
GPC_STATUS
(*GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_CL_GET_CFINFO_NAME)(
	IN	GPC_CLIENT_HANDLE		ClientContext,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
    OUT	PUNICODE_STRING			CfInfoName
    );


//
// A function list used to pass function pointers for client registration.
//
typedef struct _GPC_CLIENT_FUNC_LIST {

    ULONG 									GpcVersion;
    GPC_CL_ADD_CFINFO_COMPLETE_HANDLER		ClAddCfInfoCompleteHandler;
    GPC_CL_ADD_CFINFO_NOTIFY_HANDLER		ClAddCfInfoNotifyHandler;
    GPC_CL_MODIFY_CFINFO_COMPLETE_HANDLER	ClModifyCfInfoCompleteHandler;
    GPC_CL_MODIFY_CFINFO_NOTIFY_HANDLER		ClModifyCfInfoNotifyHandler;
    GPC_CL_REMOVE_CFINFO_COMPLETE_HANDLER	ClRemoveCfInfoCompleteHandler;
    GPC_CL_REMOVE_CFINFO_NOTIFY_HANDLER		ClRemoveCfInfoNotifyHandler;
    GPC_CL_GET_CFINFO_NAME					ClGetCfInfoName;
    
} GPC_CLIENT_FUNC_LIST, *PGPC_CLIENT_FUNC_LIST;


/*
/////////////////////////////////////////////////////////////////
//
//   GPC API prototypes
//
/////////////////////////////////////////////////////////////////
*/


//
// Calls to GPC
//

typedef
GPC_STATUS
(*GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    OUT PGPC_CLIENT_HANDLE      pClientCfInfoContext
    );

typedef
GPC_CLIENT_HANDLE
(*GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN  ULONG                   Offset
    );

typedef
GPC_STATUS
(*GPC_GET_ULONG_FROM_CFINFO_HANDLER)(
    IN	GPC_HANDLE				ClientHandle,
    IN	CLASSIFICATION_HANDLE	ClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue
    );

typedef
GPC_STATUS
(*GPC_REGISTER_CLIENT_HANDLER)(
    IN	ULONG					CfId,
	IN	ULONG					Flags,
    IN  ULONG					MaxPriorities,
	IN	PGPC_CLIENT_FUNC_LIST	pClientFuncList,
	IN	GPC_CLIENT_HANDLE		ClientContext,
	OUT	PGPC_HANDLE				pClientHandle
    );

typedef
GPC_STATUS
(*GPC_DEREGISTER_CLIENT_HANDLER)(
	IN	GPC_HANDLE				ClientHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_CFINFO_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
    IN  ULONG					CfInfoSize,
	IN	PVOID					pClientCfInfo,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext,
	OUT	PGPC_HANDLE	    		pGpcCfInfoHandle
    );

typedef
GPC_STATUS
(*GPC_ADD_PATTERN_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					Pattern,
	IN	PVOID					Mask,
	IN	ULONG					Priority,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	OUT	PGPC_HANDLE				pGpcPatternHandle,
	OUT	PCLASSIFICATION_HANDLE  pClassificationHandle
    );

typedef
VOID
(*GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status,
	IN	GPC_CLIENT_HANDLE		ClientCfInfoContext
    );

typedef
GPC_STATUS
(*GPC_MODIFY_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE	    		GpcCfInfoHandle,
    IN	ULONG					CfInfoSize,
	IN  PVOID	    			pClientCfInfo
    );

typedef
VOID
(*GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_CFINFO_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle
    );

typedef
VOID
(*GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER)(
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcCfInfoHandle,
	IN	GPC_STATUS				Status
    );

typedef
GPC_STATUS
(*GPC_REMOVE_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	GPC_HANDLE				GpcPatternHandle
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PATTERN_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID			        pPattern,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle,
    IN	ULONG					Offset,
    OUT	PULONG					pValue,
    IN	BOOLEAN					bNoCache
    );

typedef
GPC_STATUS
(*GPC_CLASSIFY_PACKET_HANDLER) (
	IN	GPC_HANDLE				ClientHandle,
	IN	ULONG					ProtocolTemplate,
	IN	PVOID					pNdisPacket,   // PNDIS_PACKET type
	IN	ULONG					TransportHeaderOffset,
    IN  PTC_INTERFACE_ID		pInterfaceId,
	OUT	PGPC_CLIENT_HANDLE		pClientCfInfoContext,
	IN OUT	PCLASSIFICATION_HANDLE	pClassificationHandle
    );

typedef struct _GPC_EXPORTED_CALLS {

    ULONG										    GpcVersion;
    HANDLE										    Reserved;
    GPC_GET_CFINFO_CLIENT_CONTEXT_HANDLER		    GpcGetCfInfoClientContextHandler;
    GPC_GET_CFINFO_CLIENT_CONTEXT_WITH_REF_HANDLER	GpcGetCfInfoClientContextWithRefHandler;
    GPC_GET_ULONG_FROM_CFINFO_HANDLER			    GpcGetUlongFromCfInfoHandler;
    GPC_REGISTER_CLIENT_HANDLER					    GpcRegisterClientHandler;
    GPC_DEREGISTER_CLIENT_HANDLER				    GpcDeregisterClientHandler;
    GPC_ADD_CFINFO_HANDLER						    GpcAddCfInfoHandler;
    GPC_ADD_PATTERN_HANDLER						    GpcAddPatternHandler;
    GPC_ADD_CFINFO_NOTIFY_COMPLETE_HANDLER		    GpcAddCfInfoNotifyCompleteHandler;
    GPC_MODIFY_CFINFO_HANDLER					    GpcModifyCfInfoHandler;
    GPC_MODIFY_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcModifyCfInfoNotifyCompleteHandler;
    GPC_REMOVE_CFINFO_HANDLER					    GpcRemoveCfInfoHandler;
    GPC_REMOVE_CFINFO_NOTIFY_COMPLETE_HANDLER	    GpcRemoveCfInfoNotifyCompleteHandler;
    GPC_REMOVE_PATTERN_HANDLER					    GpcRemovePatternHandler;
    GPC_CLASSIFY_PATTERN_HANDLER				    GpcClassifyPatternHandler;
    GPC_CLASSIFY_PACKET_HANDLER					    GpcClassifyPacketHandler;

} GPC_EXPORTED_CALLS, *PGPC_EXPORTED_CALLS;


NTSTATUS
GpcInitialize(
	OUT	PGPC_EXPORTED_CALLS		pGpcEntries
    );


NTSTATUS
GpcDeinitialize(
	IN	PGPC_EXPORTED_CALLS		pGpcEntries
    );

#if 0
NTSTATUS
GetInterfaceIdFromIp(
	IN	ULONG   DestAddress,
	IN	PULONG  pBestIfIndex
    );
#endif

#endif // __GPCIFC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\atl.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#include <precomp.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\qosinc\gpcstruc.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    gpcstruc.h

Abstract:

    This module contains type definitions for the interface between the traffic dll and
    kernel mode components.

Author:

    Jim Stewart ( jstew )    August 22, 1996

Revision History:

    Yoram Bernet (yoramb)       May 1, 1997

    Ofer Bar (oferbar)          Oct 1, 1997 - Revision 2 changes


--*/

#ifndef __GPCSTRUC_H
#define __GPCSTRUC_H


#define GPC_NOTIFY_CFINFO_CLOSED	1

//
// NtDeviceIoControlFile IoControlCode values for the GPC.
//
#define CTRL_CODE(function, method, access) \
                CTL_CODE(FILE_DEVICE_NETWORK, function, method, access)


#define IOCTL_GPC_REGISTER_CLIENT       CTRL_CODE( 20, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_DEREGISTER_CLIENT     CTRL_CODE( 21, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_CF_INFO           CTRL_CODE( 22, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ADD_PATTERN           CTRL_CODE( 23, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_MODIFY_CF_INFO        CTRL_CODE( 24, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_CF_INFO        CTRL_CODE( 25, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_REMOVE_PATTERN        CTRL_CODE( 26, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_ENUM_CFINFO           CTRL_CODE( 27, METHOD_BUFFERED,FILE_WRITE_ACCESS)
#define IOCTL_GPC_NOTIFY_REQUEST        CTRL_CODE( 28, METHOD_BUFFERED,FILE_WRITE_ACCESS)

#define IOCTL_GPC_GET_ENTRIES           CTRL_CODE( 50, METHOD_BUFFERED,FILE_ANY_ACCESS)


/*
/////////////////////////////////////////////////////////////////
//
//   Ioctl buffer formats - user level clients send buffers to the
//   GPC instead of calling entry points. Parameters are returned 
//   in other buffers. Buffers are defined below:
//
/////////////////////////////////////////////////////////////////
*/


//
// Register client
//
typedef struct _GPC_REGISTER_CLIENT_REQ {

    ULONG               CfId;
    ULONG               Flags;
    ULONG               MaxPriorities;
    GPC_CLIENT_HANDLE   ClientContext;

} GPC_REGISTER_CLIENT_REQ, *PGPC_REGISTER_CLIENT_REQ;

typedef struct _GPC_REGISTER_CLIENT_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          ClientHandle;

} GPC_REGISTER_CLIENT_RES, *PGPC_REGISTER_CLIENT_RES;


//
// Deregister client
//
typedef struct _GPC_DEREGISTER_CLIENT_REQ {

    GPC_HANDLE          ClientHandle;

} GPC_DEREGISTER_CLIENT_REQ, *PGPC_DEREGISTER_CLIENT_REQ;

typedef struct _GPC_DEREGISTER_CLIENT_RES {

    GPC_STATUS          Status;

} GPC_DEREGISTER_CLIENT_RES, *PGPC_DEREGISTER_CLIENT_RES;


//
// Add CfInfo
//
typedef struct _GPC_ADD_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_CLIENT_HANDLE   ClientCfInfoContext;    // client specific context
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];  // Varies from CF to CF

} GPC_ADD_CF_INFO_REQ, *PGPC_ADD_CF_INFO_REQ;

typedef struct _GPC_ADD_CF_INFO_RES {

    GPC_STATUS          Status;
    GPC_HANDLE          GpcCfInfoHandle;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;
    USHORT				InstanceNameLength;
    WCHAR				InstanceName[MAX_STRING_LENGTH];
    
} GPC_ADD_CF_INFO_RES, *PGPC_ADD_CF_INFO_RES;


//
// Add pattern
//
typedef struct _GPC_ADD_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    GPC_CLIENT_HANDLE   ClientPatternContext;
    ULONG               Priority;
    ULONG				ProtocolTemplate;
    ULONG               PatternSize;
    CHAR                PatternAndMask[1];

} GPC_ADD_PATTERN_REQ, *PGPC_ADD_PATTERN_REQ;

typedef struct _GPC_ADD_PATTERN_RES {

    GPC_STATUS              Status;
    GPC_HANDLE              GpcPatternHandle;
    CLASSIFICATION_HANDLE   ClassificationHandle;

} GPC_ADD_PATTERN_RES, *PGPC_ADD_PATTERN_RES;


//
// Modify CfInfo
//
typedef struct _GPC_MODIFY_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;
    ULONG               CfInfoSize;
    CHAR                CfInfo[1];

} GPC_MODIFY_CF_INFO_REQ, *PGPC_MODIFY_CF_INFO_REQ;

typedef struct _GPC_MODIFY_CF_INFO_RES {
    
    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_MODIFY_CF_INFO_RES, *PGPC_MODIFY_CF_INFO_RES;


//
// Remove CfInfo
//
typedef struct _GPC_REMOVE_CF_INFO_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcCfInfoHandle;

} GPC_REMOVE_CF_INFO_REQ, *PGPC_REMOVE_CF_INFO_REQ;

typedef struct _GPC_REMOVE_CF_INFO_RES {

    GPC_STATUS          Status;
    // this is filled after PENDING
    GPC_CLIENT_HANDLE	ClientCtx;
    GPC_CLIENT_HANDLE	CfInfoCtx;

} GPC_REMOVE_CF_INFO_RES, *PGPC_REMOVE_CF_INFO_RES;


//
// Remove pattern
//
typedef struct _GPC_REMOVE_PATTERN_REQ {

    GPC_HANDLE          ClientHandle;
    GPC_HANDLE          GpcPatternHandle;

} GPC_REMOVE_PATTERN_REQ, *PGPC_REMOVE_PATTERN_REQ;

typedef struct _GPC_REMOVE_PATTERN_RES {

    GPC_STATUS          Status;

} GPC_REMOVE_PATTERN_RES, *PGPC_REMOVE_PATTERN_RES;


//
// Enumerate CfInfo
//
typedef struct _GPC_ENUM_CFINFO_REQ {

    GPC_HANDLE          ClientHandle;
    HANDLE				EnumHandle;
    ULONG				CfInfoCount;     // # requested

} GPC_ENUM_CFINFO_REQ, *PGPC_ENUM_CFINFO_REQ;

typedef struct _GPC_ENUM_CFINFO_RES {

    GPC_STATUS          	Status;
    HANDLE					EnumHandle;
    ULONG					TotalCfInfo;     // total installed
    GPC_ENUM_CFINFO_BUFFER	EnumBuffer[1];

} GPC_ENUM_CFINFO_RES, *PGPC_ENUM_CFINFO_RES;


//
// Notify request
//
typedef struct _GPC_NOTIFY_REQUEST_REQ {

    HANDLE       	ClientHandle;

} GPC_NOTIFY_REQUEST_REQ, *PGPC_NOTIFY_REQUEST_REQ;

typedef struct _GPC_NOTIFY_REQUEST_RES {

    HANDLE			ClientCtx;
    ULONG			SubCode;			// notification type
    ULONG			Reason;				// reason
    ULONG_PTR	    NotificationCtx;	// i.e. flow context
    ULONG			Param1;				// optional param
    IO_STATUS_BLOCK	IoStatBlock;		// reserved for the IOCTL

} GPC_NOTIFY_REQUEST_RES, *PGPC_NOTIFY_REQUEST_RES;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\qosinc\ntddtc.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntddtc.h

Abstract:

    This module contains type definitions for the interface between the 
    traffic dll and kernel mode components.
    Definitions here should not be exposed to the external user.
    'traffic.h' and 'qos.h' should be used as public include files instead.

Author:

    Ofer Bar ( oferbar )    Oct 8, 1997

Revision History:

    Ofer Bar ( oferbar )    Dec 1, 1997

        Add error codes

--*/

//---------------------------------------------------------------------------
// 
//      QoS supported guid
// 
//---------------------------------------------------------------------------

DEFINE_GUID( GUID_QOS_TC_SUPPORTED, 0xe40056dcL, 
             0x40c8, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x59, 0x15);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_UP_INDICATION, 
             0x0ca13af0L, 0x46c4, 0x11d1, 0x78, 0xac, 0x00, 0x80, 0x5f, 0x68, 0x35, 0x1e);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_DOWN_INDICATION, 
             0xaf5315e4L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);
DEFINE_GUID( GUID_QOS_TC_INTERFACE_CHANGE_INDICATION, 
             0xda76a254L, 0xce61, 0x11d1, 0x7c, 0x8a, 0x00, 0xc0, 0x4f, 0xc9, 0xb5, 0x7c);

DEFINE_GUID( GUID_QOS_SCHEDULING_PROFILES_SUPPORTED, 0x1ff890f0L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_CURRENT_SCHEDULING_PROFILE, 0x2966ed30L, 0x40ed, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_DISABLE_DRR, 0x1fa6dc7aL, 0x6120, 0x11d1, 0x2c, 0x91, 0x00, 0xaa, 0x00, 0x57, 0x49, 0x15);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD_REACHED, 0x357b74d2L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_BUFFER_SIZE, 0x357b74d3L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_THRESHOLD, 0x357b74d0L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_DATA, 0x357b74d1L,0x6134,0x11d1,0xab,0x5b,0x00,0xa0,0xc9,0x24,0x88,0x37);

DEFINE_GUID( GUID_QOS_LOG_LEVEL,0x9dd7f3ae,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);

DEFINE_GUID( GUID_QOS_LOG_MASK,0x9e696320,0xf2a8,0x11d2,0xbe,0x1b,0x00,0xa0,0xc9,0x9e,0xe6,0x3b);



#ifndef __NTDDTC_H
#define __NTDDTC_H

//
// Kernel NT private error codes
// these should be only returned to the GPC but not
// to NDIS, since WMI will not map them to winerror
//

#define QOS_STATUS_INVALID_SERVICE_TYPE        0xC0020080L
#define QOS_STATUS_INVALID_TOKEN_RATE          0xC0020081L
#define QOS_STATUS_INVALID_PEAK_RATE           0xC0020082L
#define QOS_STATUS_INVALID_SD_MODE             0xC0020083L
#define QOS_STATUS_INVALID_QOS_PRIORITY        0xC0020084L
#define QOS_STATUS_INVALID_TRAFFIC_CLASS       0xC0020085L
#define QOS_STATUS_TC_OBJECT_LENGTH_INVALID    0xC0020086L
#define QOS_STATUS_INVALID_FLOW_MODE           0xC0020087L
#define QOS_STATUS_INVALID_DIFFSERV_FLOW       0xC0020088L
#define QOS_STATUS_DS_MAPPING_EXISTS           0xC0020089L
#define QOS_STATUS_INVALID_SHAPE_RATE          0xC0020090L
#define QOS_STATUS_INVALID_DS_CLASS            0xC0020091L

//
// These are the public QOS error codes
//

#define QOS_STATUS_INCOMPATABLE_QOS                     NDIS_STATUS_INCOMPATABLE_QOS

// The CF_INFO structure for the QoS classification family.
// Note that this is not interpreted by the GPC, but it is shared by 
// all clients of the GPC which are of the QoS classification family.

#define MAX_INSTANCE_NAME_LENGTH        256


typedef struct _CF_INFO_QOS {

    USHORT                      InstanceNameLength;     // name length
    WCHAR                       InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name
    ULONG           ToSValue;
    ULONG                       Flags;
    TC_GEN_FLOW         GenFlow;

} CF_INFO_QOS, *PCF_INFO_QOS;


//
// This is the buffer that the data provider sends up 
// on Interface Up notification
//
typedef struct _TC_INDICATION_BUFFER {

    ULONG                                               SubCode;                // reason for notification
    TC_SUPPORTED_INFO_BUFFER    InfoBuffer;

} TC_INDICATION_BUFFER, *PTC_INDICATION_BUFFER;

//
// Definitions for the Class Map (including CBQ)
//

typedef struct _TC_CLASS_MAP_FLOW {

    ULONG             DefaultClass;                   // Default Class Id
    ULONG             ObjectsLength;                  // Length of Objects
    QOS_OBJECT_HDR    Objects;                                // Offset to Objects

} TC_CLASS_MAP_FLOW, *PTC_CLASS_MAP_FLOW;

typedef struct _CF_INFO_CLASS_MAP {

    USHORT                              InstanceNameLength;     // name length
    WCHAR                               InstanceName[MAX_INSTANCE_NAME_LENGTH]; // instance name
    
    ULONG                               Flags;
    TC_CLASS_MAP_FLOW   ClassMapInfo;
    
} CF_INFO_CLASS_MAP, *PCF_INFO_CLASS_MAP;

//
// Internal QoS Objects start at this offset from the base
//

#define QOS_PRIVATE_GENERAL_ID_BASE 3000

#define QOS_OBJECT_WAN_MEDIA                   (0x00000001 + QOS_PRIVATE_GENERAL_ID_BASE)
        /* QOS_WAN_MEDIA structure passed */
#define QOS_OBJECT_SHAPER_QUEUE_DROP_MODE	   (0x00000002 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueDropMode structure */
#define QOS_OBJECT_SHAPER_QUEUE_LIMIT          (0x00000003 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_ShaperQueueLimit structure */
#define QOS_OBJECT_PRIORITY                    (0x00000004 + QOS_PRIVATE_GENERAL_ID_BASE)
          /* QOS_PRIORITY structure passed */

//
// This structure defines the media specific information needed by ndiswan to 
// create a flow.
//
typedef struct _QOS_WAN_MEDIA {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           LinkId[6];
    ULONG           ISSLOW;

} QOS_WAN_MEDIA, *LPQOS_WAN_MEDIA;


//
// This structure allows overriding of the default schema used to drop 
// packets when a flow's shaper queue limit is reached.
//
// DropMethod - 
// 	QOS_SHAPER_DROP_FROM_HEAD - Drop packets from
// 		the head of the queue until the new packet can be
// 		accepted into the shaper under the current limit.  This
// 		behavior is the default.
// 	QOS_SHAPER_DROP_INCOMING - Drop the incoming, 
// 		limit-offending packet.
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT_DROP_MODE {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            DropMode;

} QOS_SHAPER_QUEUE_LIMIT_DROP_MODE, *LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE;

#define QOS_SHAPER_DROP_INCOMING	0
#define QOS_SHAPER_DROP_FROM_HEAD	1

//
// This structure allows the default per-flow limit on the shaper queue
// size to be overridden.
//
// QueueSizeLimit - Limit, in bytes, of the size of the shaper queue
//
//

typedef struct _QOS_SHAPER_QUEUE_LIMIT {

    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            QueueSizeLimit;

} QOS_SHAPER_QUEUE_LIMIT, *LPQOS_SHAPER_QUEUE_LIMIT;


//
// This structure defines the absolute priorty of the flow.  Priorities in the 
// range of 0-7 are currently defined. Receive Priority is not currently used, 
// but may at some point in the future.
//
typedef struct _QOS_PRIORITY {

    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           SendPriority;     /* this gets mapped to layer 2 priority.*/
    UCHAR           SendFlags;        /* there are none currently defined.*/
    UCHAR           ReceivePriority;  /* this could be used to decide who 
                                       * gets forwarded up the stack first 
                                       * - not used now */
    UCHAR           Unused;

} QOS_PRIORITY, *LPQOS_PRIORITY;


#define PARAM_TYPE_GQOS_INFO        0xABC0DEF0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\init.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

// init.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for AUO.idl by adding the following 
//		files to the Outputs.
//			AUO_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f AUOps.mk in the project directory.

#include "precomp.h"
#include "resource.h"
#include "initguid.h"
//#include "initguid.h"
#include "autosock.h" // midl generated
//#include "dlldatax.h"

#include "main.h" // gut implementation
#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;
GUID LIBID_StdOle2 = {0x00020430,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


BEGIN_OBJECT_MAP(ObjectMap)

    OBJECT_ENTRY(CLSID_AutoSock, CAutoSock)
	
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		
        g_hInstance = hInstance;

		DisableThreadLibraryCalls(hInstance);

        g_lInit = 0;
		
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
    return S_FALSE;
//	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif

    OnAttach();
    
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\precomp.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__77BD6B2B_B1B5_11D0_BBD6_00C04FB615E5__INCLUDED_)
#define AFX_STDAFX_H__77BD6B2B_B1B5_11D0_BBD6_00C04FB615E5__INCLUDED_

#define STRICT
#define _ATL_APARTMENT_THREADED

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#undef ASSERT
#include <afx.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <winsock.h>

#endif // !defined(AFX_STDAFX_H__77BD6B2B_B1B5_11D0_BBD6_00C04FB615E5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\main.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//


#ifndef __MAIN_H_
#define __MAIN_H_

#include "resource.h"       // main symbols
#include <afxtempl.h>

class CritSecLocker
{
public:
    CritSecLocker(CComAutoCriticalSection *pCritSect)
        {
            this->pCritSect = pCritSect;
            if (pCritSect) pCritSect->Lock();
        }
    ~CritSecLocker()
        {
            if (this->pCritSect) this->pCritSect->Unlock();
        }
private:
    CComAutoCriticalSection *pCritSect;
};

/////////////////////////////////////////////////////////////////////////////
// CUlControlChannel
class ATL_NO_VTABLE CAutoSock : 
	public CComObjectRoot,
	public CComCoClass<CAutoSock, &CLSID_AutoSock>,
	public IDispatchImpl<IAutoSock, &IID_IAutoSock, &LIBID_AutoSockLib>,
	public ISupportErrorInfo
{
public:
	CAutoSock();
	~CAutoSock();

    DECLARE_REGISTRY_RESOURCEID(IDR_AUTOSOCK)
    DECLARE_NOT_AGGREGATABLE(CAutoSock)

    BEGIN_COM_MAP(CAutoSock)
    	COM_INTERFACE_ENTRY(IDispatch)
    	COM_INTERFACE_ENTRY(ISupportErrorInfo)
    	COM_INTERFACE_ENTRY(IAutoSock)
    END_COM_MAP()

public:

    // ISupportsErrorInfo
    //
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // IAutoSock
    //
    STDMETHOD(Connect)(BSTR IpAddress);
    STDMETHOD(Send)(BSTR Data);
    STDMETHOD(Recv)(BSTR * ppRetVal);
    STDMETHOD(Close)();

    // Private
    //

public:
    CComAutoCriticalSection CritSect;


    SOCKET Socket;
};


/////////////////////////////////////////////////////////////////////////////
// Globals
//

extern LONG                g_lInit;
extern HINSTANCE           g_hInstance;

BOOL OnAttach();
void OnDetach();

HRESULT ReturnError(UINT nID, WCHAR *wszSource, BSTR bszParam = NULL);


#endif //__MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\resource.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#define IDR_AUTOSOCK                      100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\makefile.inc ===
$(O)\tsrv.res: tsrv.rc

$(O)\tfile.res: tfile.rc

$(O)\tsec.res: tsec.rc

$(O)\tperf.res: tperf.rc

$(O)\tnagle.res: tnagle.rc

$(O)\techo.res: techo.rc

$(O)\tcgsec.res: tcgsec.rc

$(O)\tfilt.res: tfilt.rc

$(O)\tfilt2.res: tfilt2.rc

$(O)\tlog.res: tlog.rc

$(O)\tsrv.res: tsrv.rc

$(O)\ttrans.res: ttrans.rc

$(O)\tupfilt.res: tupfilt.rc

$(O)\tqueue.res: tqueue.rc

$(O)\tctr.res: tctr.rc

$(O)\tover.res: tover.rc

$(O)\tmultiecho.res: tmultiecho.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\autosock\main.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#include "precomp.h"
#include <afxdisp.h>
#include "autosock.h"
#include "main.h"


#define SWAP_SHORT(s)                               \
            ( ( ((s) >> 8) & 0x00FF ) |             \
              ( ((s) << 8) & 0xFF00 ) )

 


// **************************************************************************
//
// Globals
//

LONG                g_lInit;
HINSTANCE           g_hInstance;

CComAutoCriticalSection g_InitLock;


BOOL OnAttach()
{
    if (0 == g_lInit)
    {
        g_InitLock.Lock();

        if (0 == g_lInit)
        {
            WSADATA wd;
            
            g_lInit = 1;

            if (WSAStartup(MAKEWORD(1,1), &wd) != 0)
            {
                MessageBox(NULL, L"WSAStartup failed!", L"Error", MB_OK);
            }
            
        }

        g_InitLock.Unlock();
    }
	
    return TRUE;
}

void OnDetach()
{

}


// **************************************************************************
//
// CAutoSock
//

CAutoSock::CAutoSock()
{
    this->Socket = INVALID_SOCKET;

}

CAutoSock::~CAutoSock()
{
    this->Close();
}

//
// ISupportsErrorInfo
//

STDMETHODIMP CAutoSock::InterfaceSupportsErrorInfo(REFIID riid)
{
    CritSecLocker csl(&(this->CritSect));
	if (riid == IID_IAutoSock)
		return S_OK;
	return S_FALSE;
}

//
// IAutoSock
//

STDMETHODIMP CAutoSock::Connect(BSTR IpAddress)
{
    USES_CONVERSION;
    
    sockaddr_in     SockAddr;
    BOOL            BoolTrue = TRUE;
    PCHAR           pAddress, pPort;
    USHORT          PortNum;
    HOSTENT *       pHost;

    if (this->Socket != INVALID_SOCKET)
    {
        return HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
    }

    //
    // create the socket
    //

    this->Socket = socket(AF_INET, SOCK_STREAM, 0);

    if (this->Socket == INVALID_SOCKET)
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    //
    // format the address to a sock_addr
    //

    pAddress = W2A(IpAddress);

    pPort = strchr(pAddress, ':');
    if (pPort == NULL)
    {
        PortNum = 80;
    }
    else
    {
        pPort[0] = ANSI_NULL;
        pPort += 1;

        PortNum = (USHORT)atol(pPort);
        if (PortNum == 0)
        {
            closesocket(this->Socket);
            this->Socket = INVALID_SOCKET;

            return E_FAIL;
        }
    }
    
    pHost = gethostbyname(pAddress);

    if (pHost == NULL)
    {
        closesocket(this->Socket);
        this->Socket = INVALID_SOCKET;

        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    ZeroMemory(&SockAddr, sizeof(SockAddr));
    
    SockAddr.sin_family = AF_INET;
    SockAddr.sin_port = SWAP_SHORT(PortNum);
    SockAddr.sin_addr = * (in_addr *) (pHost->h_addr);
    
    //
    // and now connect
    //
    
    if (connect(this->Socket, (sockaddr *)&SockAddr, sizeof(SockAddr)) == SOCKET_ERROR)
    {
        closesocket(this->Socket);
        this->Socket = INVALID_SOCKET;

        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    //
    // turn off nagling, so the script can control packet contents.
    //

    if (
        setsockopt(
            this->Socket, 
            IPPROTO_TCP, 
            TCP_NODELAY, 
            (const char *)&BoolTrue, 
            sizeof(BOOL)
            ) == SOCKET_ERROR
        )
    {
        closesocket(this->Socket);
        this->Socket = INVALID_SOCKET;

        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    //
    // all done
    //
    
    return NO_ERROR;
}

STDMETHODIMP CAutoSock::Send(BSTR Data)
{
    USES_CONVERSION;

    PCHAR pData = W2A(Data);
    if (send(this->Socket, pData, strlen(pData), 0) == SOCKET_ERROR)
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    return NO_ERROR;
}

STDMETHODIMP CAutoSock::Recv(BSTR * ppRetVal)
{
    char    Data[4*1024];
    WCHAR   WideData[(sizeof(Data)+1) * sizeof(WCHAR)];
    ULONG   BytesRead;

    BytesRead = recv(this->Socket, &(Data[0]), sizeof(Data), 0);
    if (BytesRead == SOCKET_ERROR)
    {
        return HRESULT_FROM_WIN32(WSAGetLastError());
    }

    BytesRead = MultiByteToWideChar(
                        CP_ACP, 
                        0,
                        &(Data[0]), 
                        BytesRead, 
                        &(WideData[0]), 
                        sizeof(WideData)/sizeof(WCHAR)
                        );

    if (BytesRead == 0)
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    ASSERT(BytesRead < (sizeof(WideData)/sizeof(WCHAR))-1);

    WideData[BytesRead] = UNICODE_NULL;
    
    *ppRetVal = SysAllocString(&(WideData[0]));
    if (*ppRetVal == NULL)
    {
        return E_OUTOFMEMORY;
    }

    return NO_ERROR;
}

STDMETHODIMP CAutoSock::Close()
{
    if (this->Socket != INVALID_SOCKET)
    {
        closesocket(this->Socket);
        this->Socket = INVALID_SOCKET;
    }
    
    return NO_ERROR;
}



// **************************************************************************
//
// Utils
//

HRESULT ReturnError(UINT nID, WCHAR *wszSource, BSTR bszParam /* = NULL */)
{
    HRESULT             hr;
    ICreateErrorInfo *  pcei;
    IErrorInfo *        pei;
    CString             str;
    BSTR                bstr;
    HINSTANCE           hInstance;

    pei = NULL;
    pcei = NULL;

    hr = CreateErrorInfo(&pcei);
	if (FAILED(hr))
	    goto end;

    // This is needed in order to use CString::LoadString
    //
    hInstance = AfxGetModuleState()->m_hCurrentResourceHandle;
    AfxGetModuleState()->m_hCurrentResourceHandle = g_hInstance;
		
    if (NULL == bszParam)
    {
        str.LoadString(nID);
    } else
    {
        str.FormatMessage(nID,bszParam);
    }

    AfxGetModuleState()->m_hCurrentResourceHandle = hInstance;

    bstr = str.AllocSysString();
    hr = pcei->SetDescription(bstr);
    SysFreeString(bstr);
    if (FAILED(hr))
        goto end;

    bstr = SysAllocString(wszSource);
    hr = pcei->SetSource(bstr);
    SysFreeString(bstr);
    if (FAILED(hr))
        goto end;

    hr = pcei->QueryInterface(IID_IErrorInfo, (LPVOID FAR*) &pei);
	if (FAILED(hr))
	    goto end;

	hr = SetErrorInfo(0, pei);
	if (FAILED(hr))
	    goto end;
	
    hr = DISP_E_EXCEPTION;
    
end:
    if (pei != NULL)
        pei->Release();
        
    if (pcei != NULL)
        pcei->Release();
        
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\techo.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    techo.c

Abstract:

    Stupid test server for UL.SYS.

Author:

    Keith Moore (keithmo)        16-Nov-1999

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    PWSTR tmp;
    BOOL initDone;
    PCHAR pRenderedRequest;
    ULONG RenderedLength;
    PCHAR pRequestBuffer;
    ULONG RequestBufferLength;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );
    pRenderedRequest = NULL;
    RenderedLength = 0;

    RequestBufferLength = 2048;
    pRequestBuffer = ALLOC( RequestBufferLength );

    if (pRequestBuffer == NULL)
    {
        wprintf( L"out of memory\n" );
        return 1;
    }

    request = (PHTTP_REQUEST)pRequestBuffer;

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Build the fixed part of our response.
    //

    INIT_RESPONSE( &response, 200, "OK" );

    //
    // Loop forever...
    //

    for (;;)
    {
        //
        // Wait for a request.
        //

        HTTP_SET_NULL_ID( &requestId );

        do
        {
            result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        request,
                        RequestBufferLength,
                        &bytesRead,
                        NULL
                        );

            if (result == ERROR_MORE_DATA)
            {
                //
                // Buffer was too small.
                //

                if (bytesRead < RequestBufferLength)
                {
                    result = ERROR_INVALID_DATA;
                    wprintf( L"got bogus %lu BytesRead\n" );
                    break;
                }

                //
                // Note that we must snag the request ID from the
                // old buffer before replacing it with a new buffer.
                //

                requestId = request->RequestId;

                RequestBufferLength = bytesRead;
                FREE( pRequestBuffer );
                pRequestBuffer = ALLOC( RequestBufferLength );

                if (pRequestBuffer == NULL)
                {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                    wprintf( L"out of memory\n" );
                    break;
                }

                request = (PHTTP_REQUEST)pRequestBuffer;
                continue;
            }

        } while (result == ERROR_MORE_DATA);

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Render the request as an ASCII string.
        //

        for (;;)
        {
            if (RenderHttpRequest( request, pRenderedRequest, RenderedLength ))
            {
                break;
            }

            FREE( pRenderedRequest );
            RenderedLength += 1024;
            pRenderedRequest = ALLOC( RenderedLength );

            if (pRenderedRequest == NULL)
            {
                wprintf( L"out of memory\n" );
                break;
            }
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Build the response.
        //

        dataChunk.DataChunkType = HttpDataChunkFromMemory;
        dataChunk.FromMemory.pBuffer = pRenderedRequest;
        dataChunk.FromMemory.BufferLength = (ULONG)strlen( pRenderedRequest );

        //
        // Send the response.
        //

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (pRequestBuffer != NULL)
    {
        FREE( pRequestBuffer );
    }

    if (pRenderedRequest != NULL)
    {
        FREE( pRenderedRequest );
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tctr.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tctr.c

Abstract:

    A test for UL performance monitoring counter API.

Author:

    Eric Stenson (ericsten)     21-Sep-2000

Revision History:

--*/


#include "precomp.h"
#include "iiscnfg.h"

DEFINE_COMMON_GLOBALS();


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    BOOL initDone;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;

    DWORD  cbBlockSize;
    DWORD  cbBytesWritten;
    HTTP_GLOBAL_COUNTERS ULGC;
    PHTTP_SITE_COUNTERS  pULSC;
    DWORD  dwNumInst;
    

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        int i;
        
        wprintf( L"ParseCommandLine() failed:\n" );
        for (i = 0; i < argc; i++)
        {
            wprintf( L"\tArg[%d]: %s\n", i, argv[i] );
        }
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone        = FALSE;
    controlChannel  = NULL;
    appPool         = NULL;
    HTTP_SET_NULL_ID( &configId );
    pULSC           = NULL;

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto Cleanup;
    }

    initDone = TRUE;

    //
    // test UL perfmon counter API
    //

    cbBlockSize = sizeof(ULGC);
    RtlFillMemory( &ULGC, sizeof(ULGC), '\xE0' );
    dwNumInst = 0;

    result = HttpGetCounters(
                    controlChannel,
                    HttpCounterGroupGlobal,
                    &cbBlockSize,
                    &ULGC,
                    &dwNumInst
                    );

    if ( result == STATUS_SUCCESS )
    {
        wprintf( L"HttpGetCounters: result == 0x%08X\n"
                 L"\tcbBlockSize == %d (0x%08X)\n"
                 L"\tdwNumInst == %d (0x%08X)\n",
                 result,
                 cbBlockSize, cbBlockSize,
                 dwNumInst, dwNumInst
                 );

        wprintf( L"CurrentUrisCached = %d\n", ULGC.CurrentUrisCached );
        wprintf( L"TotalUrisCached   = %d\n", ULGC.TotalUrisCached );
        wprintf( L"UriCacheHits      = %d\n", ULGC.UriCacheHits ); 
        wprintf( L"UriCacheMisses    = %d\n", ULGC.UriCacheMisses ); 
        wprintf( L"UriCacheFlushes   = %d\n", ULGC.UriCacheFlushes );
        wprintf( L"TotalFlushedUris  = %d\n", ULGC.TotalFlushedUris );
    }
    else
    {
        wprintf( L"HttpGetCounters() failed, error 0x%08X\n", result );
    }

    //
    // Test Site Counters
    //

    cbBlockSize = sizeof(HTTP_SITE_COUNTERS);
    dwNumInst = 0;
    pULSC = (PHTTP_SITE_COUNTERS) HeapAlloc(GetProcessHeap(), 0, cbBlockSize);
    result = E_FAIL;

    while( FAILED(result) )
    {
        cbBytesWritten = cbBlockSize;
        
        result = HttpGetCounters(
                        controlChannel,
                        HttpCounterGroupSite,
                        &cbBytesWritten,
                        (PVOID) pULSC,
                        &dwNumInst
                        );
        
        if ( !FAILED(result) )
        {
            ULONG   i;

            wprintf( L"%d Site Counter Blocks Returned\n", dwNumInst );
            wprintf( L"---------------------------------------------\n" );
            
            // Iterate through blocks
            for ( i = 0; i < dwNumInst; i++ )
            {
                wprintf( L"SiteId            = %d\n", pULSC[i].SiteId );
                wprintf( L"BytesSent         = %I64u\n", pULSC[i].BytesSent );
                wprintf( L"BytesRec'd        = %I64u\n", pULSC[i].BytesReceived );
                wprintf( L"BytesTransf'd     = %I64u\n", pULSC[i].BytesTransfered );
                wprintf( L"CurrentConns      = %d\n", pULSC[i].CurrentConns );
                wprintf( L"MaxConn's         = %d\n", pULSC[i].MaxConnections );
                wprintf( L"GetReqs           = %d\n", pULSC[i].GetReqs );
                wprintf( L"HeadReqs          = %d\n", pULSC[i].HeadReqs );
                wprintf( L"AllReqs           = %d\n", pULSC[i].AllReqs );
                wprintf( L"BW Usage          = %d\n", pULSC[i].BytesSent );
                wprintf( L"Blocked BW        = %d\n", pULSC[i].BytesSent );
                wprintf( L"TotalBlocked BW   = %d\n", pULSC[i].BytesSent );
                wprintf( L"---------------------------------------------\n" );
            }
        }
        else
        {
            // Failed.  Allocate more space?
            if (HRESULT_CODE(result) == ERROR_INSUFFICIENT_BUFFER)
            {
                PVOID   pTmp = NULL;
                
                cbBlockSize *= 2;
        
                pTmp = HeapReAlloc(GetProcessHeap(), 0, pULSC, cbBlockSize);
                if (pTmp)
                {
                    pULSC = (PHTTP_SITE_COUNTERS) pTmp;
                }

                ASSERT(pULSC);
            }
            else
            {
                wprintf( L"HttpGetCounters failed on site counters (0x%08X)\n", result );
                result = S_OK;
            }
        }
    }

    // Done!
    goto Cleanup;

 Cleanup:

    if (pULSC)
    {
        HeapFree(GetProcessHeap(), 0, pULSC);
    }
    
    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tfilt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tfilt.c

Abstract:

    Stupid filter test server for UL.SYS.
    This program configures a global filter called TestFilter
    and then servs requests like tfile. See tupfilt and tsslfilt
    for actual filter processes.

Author:

    Michael Courage (mcourage)      16-Mar-2000

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();


ULONG
InitFilterStuff(
    IN HANDLE ControlChannel,
    OUT PHANDLE pFitlerHandle
    );


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HANDLE filterChannel;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    PWSTR fileNamePart;
    ULONG i;
    ULONG urlLength;
    PWSTR url;
    PWSTR tmp;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];
    WCHAR fileName[MAX_PATH + 10];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    filterChannel = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    &filterChannel,         // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    TRUE,                   // EnableSsl
                    TRUE                    // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }
/*
    result = InitFilterStuff(
                    controlChannel,
                    &filterChannel
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitFilterStuff() failed, error %lu\n", result );
        goto cleanup;
    }
*/
    initDone = TRUE;

    //
    // Get the local directory and build part of the fully canonicalized
    // NT path. This makes it a bit faster to build the physical file name
    // down in the request/response loop.
    //

    GetCurrentDirectoryW( MAX_PATH, fileName );

    if (fileName[wcslen(fileName) - 1] == L'\\' )
    {
        fileName[wcslen(fileName) - 1] = L'\0';
    }

    fileNamePart = fileName + wcslen(fileName);

    //
    // Build the fixed part of our response.
    //

    INIT_RESPONSE( &response, 200, "OK" );

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Build the response.
        //

        url = request->CookedUrl.pFullUrl;
        urlLength = request->CookedUrl.FullUrlLength;

        //
        // Hack: Find the port number, then skip to the following slash.
        //

        tmp = wcschr( url, L':' );

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L':' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            urlLength -= (ULONG)( (tmp - url) * sizeof(WCHAR) );
            url = tmp;
        }

        //
        // Map it into the filename.
        //

        for (i = 0 ; i < (urlLength/sizeof(WCHAR)) ; url++, i++)
        {
            if (*url == L'/')
            {
                fileNamePart[i] = L'\\';
            }
            else
            {
                fileNamePart[i] = *url;
            }
        }

        fileNamePart[i] = L'\0';

        if (wcscmp( fileNamePart, L"\\" ) == 0 )
        {
            wcscat( fileNamePart, L"default.htm" );
        }

        if (TEST_OPTION(Verbose))
        {
            wprintf(
                L"mapped URL %s to physical file %s\n",
                request->CookedUrl.pFullUrl,
                fileName
                );
        }

        dataChunk.DataChunkType = HttpDataChunkFromFileName;
        dataChunk.FromFileName.FileNameLength = wcslen(fileName) * sizeof(WCHAR);
        dataChunk.FromFileName.pFileName = fileName;
        dataChunk.FromFileName.ByteRange.StartingOffset.QuadPart = 0;
        dataChunk.FromFileName.ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if ((result != NO_ERROR) && (result != ERROR_NETNAME_DELETED))
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (filterChannel != NULL)
    {
        CloseHandle( filterChannel );
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain


ULONG
InitFilterStuff(
    IN HANDLE ControlChannel,
    OUT PHANDLE pFilterHandle
    )
{
    HANDLE filterHandle;
    ULONG result;
    HTTP_CONTROL_CHANNEL_FILTER controlFilter;
    
    //
    // Create the filter.
    //
    result = HttpCreateFilter(
                    &filterHandle,          // filter handle
                    L"TestFilter",          // filter name
                    NULL,                   // security attributes
                    HTTP_OPTION_OVERLAPPED  // options
                    );

    if (result == NO_ERROR)
    {
        //
        // Attach the filter to the control channel.
        //
        RtlZeroMemory(&controlFilter, sizeof(controlFilter));
        
        controlFilter.Flags.Present = 1;
        controlFilter.FilterHandle = filterHandle;
        controlFilter.FilterOnlySsl = FALSE;
        
        result = HttpSetControlChannelInformation(
                        ControlChannel,
                        HttpControlChannelFilterInformation,
                        &controlFilter,
                        sizeof(controlFilter)
                        );

        if (result == NO_ERROR)
        {
            //
            // Return the filter handle.
            //
            *pFilterHandle = filterHandle;
        }
        else
        {
            CloseHandle(filterHandle);
        }
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tfilt2.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    tfilt2.c

Abstract:

    Stupid filter test server for UL.SYS.
    This program configures a global filter called TestFilter
    and then servs requests like tfile. See tupfilt and tsslfilt
    for actual filter processes.

    The difference between this program and tfilt is that this
    one starts up with the filter channel disabled, so that we
    can test the case where filters are enabled on the fly.

Author:

    Michael Courage (mcourage)      11-May-2001

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();


ULONG
EnableFilterChannel(
    IN HANDLE ControlChannel,
    IN HANDLE FilterHandle
    );

ULONG
DisableFilterChannel(
    IN HANDLE ControlChannel,
    IN HANDLE FilterHandle
    );


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HANDLE filterChannel;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    PWSTR fileNamePart;
    ULONG i;
    ULONG j;
    ULONG urlLength;
    PWSTR url;
    PWSTR tmp;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];
    WCHAR fileName[MAX_PATH + 10];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    filterChannel = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    &filterChannel,         // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    TRUE,                   // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    result = EnableFilterChannel(
                    controlChannel,
                    filterChannel
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"EnableFilterChannel() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Get the local directory and build part of the fully canonicalized
    // NT path. This makes it a bit faster to build the physical file name
    // down in the request/response loop.
    //

    GetCurrentDirectoryW( MAX_PATH, fileName );

    if (fileName[wcslen(fileName) - 1] == L'\\' )
    {
        fileName[wcslen(fileName) - 1] = L'\0';
    }

    fileNamePart = fileName + wcslen(fileName);

    //
    // Build the fixed part of our response.
    //

    INIT_RESPONSE( &response, 200, "OK" );

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );
    j = 0;

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Build the response.
        //

        url = request->CookedUrl.pFullUrl;
        urlLength = request->CookedUrl.FullUrlLength;

        //
        // Hack: Find the port number, then skip to the following slash.
        //

        tmp = wcschr( url, L':' );

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L':' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            urlLength -= (ULONG)( (tmp - url) * sizeof(WCHAR) );
            url = tmp;
        }

        //
        // Map it into the filename.
        //

        for (i = 0 ; i < (urlLength/sizeof(WCHAR)) ; url++, i++)
        {
            if (*url == L'/')
            {
                fileNamePart[i] = L'\\';
            }
            else
            {
                fileNamePart[i] = *url;
            }
        }

        fileNamePart[i] = L'\0';

        if (wcscmp( fileNamePart, L"\\" ) == 0 )
        {
            wcscat( fileNamePart, L"default.htm" );
        }

        if (TEST_OPTION(Verbose))
        {
            wprintf(
                L"mapped URL %s to physical file %s\n",
                request->CookedUrl.pFullUrl,
                fileName
                );
        }

        dataChunk.DataChunkType = HttpDataChunkFromFileName;
        dataChunk.FromFileName.FileNameLength = wcslen(fileName) * sizeof(WCHAR);
        dataChunk.FromFileName.pFileName = fileName;
        dataChunk.FromFileName.ByteRange.StartingOffset.QuadPart = 0;
        dataChunk.FromFileName.ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if ((result != NO_ERROR) && (result != ERROR_NETNAME_DELETED))
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }

        //
        // Toggle the filter channel every third request.
        //
        j++;
        if ((j % 3) == 0)
        {
            if ((j % 2) == 0)
            {
                result = EnableFilterChannel(
                                controlChannel,
                                filterChannel
                                );
            }
            else
            {
                result = DisableFilterChannel(
                                controlChannel,
                                filterChannel
                                );
            }

            if (result != NO_ERROR)
            {
                wprintf( L"HttpSetControlChannelInformation() failed, error %lu\n", result );
                break;
            }
            
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (filterChannel != NULL)
    {
        CloseHandle( filterChannel );
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain


ULONG
EnableFilterChannel(
    IN HANDLE ControlChannel,
    IN HANDLE FilterHandle
    )
{
    ULONG result;
    HTTP_CONTROL_CHANNEL_FILTER controlFilter;
    
    //
    // Attach the filter to the control channel.
    //
    RtlZeroMemory(&controlFilter, sizeof(controlFilter));
    
    controlFilter.Flags.Present = 1;
    controlFilter.FilterHandle = FilterHandle;
    controlFilter.FilterOnlySsl = FALSE;
    
    result = HttpSetControlChannelInformation(
                    ControlChannel,
                    HttpControlChannelFilterInformation,
                    &controlFilter,
                    sizeof(controlFilter)
                    );

    if (result == NO_ERROR)
    {
        wprintf(L"Filtering enabled.\n");
    }
                    
    return result;
}

ULONG
DisableFilterChannel(
    IN HANDLE ControlChannel,
    IN HANDLE FilterHandle
    )
{
    ULONG result;
    HTTP_CONTROL_CHANNEL_FILTER controlFilter;
    
    //
    // Attach the filter to the control channel.
    //
    RtlZeroMemory(&controlFilter, sizeof(controlFilter));
    
    controlFilter.Flags.Present = 1;
    controlFilter.FilterHandle = FilterHandle;
    controlFilter.FilterOnlySsl = TRUE;
    
    result = HttpSetControlChannelInformation(
                    ControlChannel,
                    HttpControlChannelFilterInformation,
                    &controlFilter,
                    sizeof(controlFilter)
                    );

    if (result == NO_ERROR)
    {
        wprintf(L"Filtering disabled.\n");
    }
                    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tcgsec.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tcgsec.c

Abstract:

    Config Group security test. See also ttrans.c.

Author:

    Michael Courage (mcourage)   15-Jan-2000

Revision History:

--*/


#include "precomp.h"


UCHAR CannedResponseEntityBody[] =
    "<html><head><title>Hello!</title></head>"
    "<body>This section of the namespace is owned by tcgsec.</body></html>";

DEFINE_COMMON_GLOBALS();

ULONG
InitTransientNameSpace(
    IN HANDLE ControlChannel,
    IN HANDLE AppPool,
    OUT PHTTP_CONFIG_GROUP_ID pConfigId
    );

ULONG
InitSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR * ppSD
    );

VOID
FreeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    );


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_ID transConfigId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    result = InitTransientNameSpace(controlChannel, appPool, &transConfigId);

    if (result != NO_ERROR)
    {
        wprintf( L"InitTransientNamespace() failed, error %lu\n", result);
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Build our canned response.
    //

    INIT_RESPONSE( &response, 200, "OK" );
    INIT_HEADER( &response, HttpHeaderContentType, "text/html" );
    INIT_HEADER( &response, HttpHeaderContentLength, "109" );

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = CannedResponseEntityBody;
    dataChunk.FromMemory.BufferLength = sizeof(CannedResponseEntityBody) - 1;

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup(1) failed, error %lu\n", result );
        }
    }

    if (!HTTP_IS_NULL_ID( &transConfigId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        transConfigId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup(2) failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain


ULONG
InitTransientNameSpace(
    IN HANDLE ControlChannel,
    IN HANDLE AppPool,
    OUT PHTTP_CONFIG_GROUP_ID pConfigId
    )
{
    ULONG result;
    HTTP_CONFIG_GROUP_ID configId = HTTP_NULL_ID;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_CONFIG_GROUP_SECURITY configSecurity;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;

    //
    // Create a configuration group.
    //

    result = HttpCreateConfigGroup(
                    ControlChannel,
                    &configId
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateConfigGroup() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Add a URL to the configuration group.
    //

    result = HttpAddUrlToConfigGroup(
                    ControlChannel,
                    configId,
                    TRANS_URL_NAME,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpAddUrlToConfigGroup() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Associate the configuration group with the application pool.
    //

    configAppPool.Flags.Present = 1;
    configAppPool.AppPoolHandle = AppPool;

    result = HttpSetConfigGroupInformation(
                    ControlChannel,
                    configId,
                    HttpConfigGroupAppPoolInformation,
                    &configAppPool,
                    sizeof(configAppPool)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(1) failed, error %lu\n", result );
        goto cleanup;
    }    

    //
    // Set the config group state.
    //

    configState.Flags.Present = 1;
    configState.State = HttpEnabledStateActive;   // not really necessary

    result = HttpSetConfigGroupInformation(
                    ControlChannel,
                    configId,
                    HttpConfigGroupStateInformation,
                    &configState,
                    sizeof(configState)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(2) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set security
    //
    result = InitSecurityDescriptor(&pSecurityDescriptor);

    if (result != NO_ERROR)
    {
        wprintf( L"InitSecurityDescriptor() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set the security descriptor into the config group
    //
    configSecurity.Flags.Present = 1;
    configSecurity.pSecurityDescriptor = pSecurityDescriptor;
    
    result = HttpSetConfigGroupInformation(
                    ControlChannel,
                    configId,
                    HttpConfigGroupSecurityInformation,
                    &configSecurity,
                    sizeof(configSecurity)
                    );

    FreeSecurityDescriptor(pSecurityDescriptor);

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(3) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Done!
    //
    *pConfigId = configId;

    return NO_ERROR;

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        ControlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    return result;
}

ULONG
InitSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR * ppSD
    )
{
    ULONG result;
    SID_IDENTIFIER_AUTHORITY worldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    ULONG daclSize;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    PACL pAcl = NULL;
    PSID pSid = NULL;
    BOOL success;

    //
    // Create the world sid
    //
    success = AllocateAndInitializeSid(
                    &worldAuthority,
                    1,
                    SECURITY_WORLD_RID,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &pSid
                    );

    if (!success) {
        result = GetLastError();
        goto cleanup;
    }

    //
    // allocate the security descriptor
    //
    pSecurityDescriptor = ALLOC( sizeof(SECURITY_DESCRIPTOR) );

    if (pSecurityDescriptor == NULL)
    {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    success = InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }

    //
    // allocate and initialize the dacl
    //

    daclSize = sizeof(ACL) +
                sizeof(ACCESS_ALLOWED_ACE) +
                GetLengthSid(pSid);

    pAcl = ALLOC(daclSize);

    if (pAcl == NULL) {
        result = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    success = InitializeAcl(pAcl, daclSize, ACL_REVISION);

    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }
    
    //
    // Add the ACE.
    //

    success = AddAccessAllowedAce(
                pAcl,
                ACL_REVISION,
                FILE_ALL_ACCESS,
                pSid
                );

    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }

    //
    // Set the DACL into the security descriptor
    //

    success = SetSecurityDescriptorDacl(
                    pSecurityDescriptor,
                    TRUE,                   // DaclPresent
                    pAcl,                   // pDacl
                    FALSE                   // DaclDefaulted
                    );

    if (!success)
    {
        result = GetLastError();
        goto cleanup;
    }

    *ppSD = pSecurityDescriptor;

    result = NO_ERROR;

cleanup:
    if (pSid) {
        FreeSid(pSid);
    }

    if (result != NO_ERROR) {
        if (pSecurityDescriptor) {
            FREE(pSecurityDescriptor);
        }

        if (pAcl) {
            FREE(pAcl);
        }
    }

    return result;
}


VOID
FreeSecurityDescriptor(
    IN PSECURITY_DESCRIPTOR pSD
    )
{
    BOOL success;
    BOOL DaclPresent;
    PACL pDacl;
    BOOL DaclDefaulted;

    success = GetSecurityDescriptorDacl(
                    pSD,
                    &DaclPresent,
                    &pDacl,
                    &DaclDefaulted
                    );

    if (success && DaclPresent && !DaclDefaulted) {
        FREE(pDacl);
    }

    FREE(pSD);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for the UL.SYS test app.

Author:

    Keith Moore (keithmo)       19-Jun-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <http.h>
#include <httpapi.h>


//
// Constants.
//

#define URL_NAME                L"http://*:80/"
#define TRANS_URL_NAME          L"http://*:80/transient/"
#define SECURE_URL_NAME         L"https://*:443/"
#define APP_POOL_NAME           L"UL Test App Pool"
#define REQUEST_LENGTH          4096
#define FILENAME_BUFFER_LENGTH  (MAX_PATH + sizeof("\\??\\"))

#define RANDOM_CONSTANT         314159269UL
#define RANDOM_PRIME            1000000007UL
#define HASH_SCRAMBLE(hash)                                                 \
    (ULONG)((((ULONG)(hash)) * (ULONG)RANDOM_CONSTANT) % (ULONG)RANDOM_PRIME)


//
// Heap manipulators.
//

#define ALLOC(len)  (PVOID)RtlAllocateHeap( RtlProcessHeap(), 0, (len) )
#define FREE(ptr)   (VOID)RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )


//
// Command line configuration options.
//

typedef struct _OPTIONS
{
    BOOL Verbose;
    BOOL EnableBreak;

} OPTIONS, *POPTIONS;

#define TEST_OPTION(name)                                                   \
    (g_Options.name)

extern OPTIONS g_Options;

#define DEFINE_COMMON_GLOBALS()                                             \
    OPTIONS g_Options


//
// Generate a breakpoint, but only if we're running under
// the debugger.
//

#define DEBUG_BREAK()                                                       \
    if (TEST_OPTION(EnableBreak) && IsDebuggerPresent()) {                  \
        DebugBreak();                                                       \
    } else


//
// Alignment thingy.
// Note: I can't figure out any way to avoid hard coding
// the alignment size here. <Offensive word> compiler :P
//

#define HTTP_REQUEST_ALIGNMENT DECLSPEC_ALIGN( 16 )

//
// Utility functions from ULUTIL.C.
//

PWSTR
IpAddrToString(
    IN ULONG IpAddress,
    IN PWSTR String
    );

BOOL
ParseCommandLine(
    IN INT argc,
    IN PWSTR argv[]
    );

ULONG
CommonInit(
    VOID
    );

ULONG
InitUlStuff(
    OUT PHANDLE pControlChannel,
    OUT PHANDLE pAppPool,
    OUT PHANDLE pFilterChannel,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroup,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld,
    IN ULONG AppPoolOptions,
    IN BOOL EnableSsl,
    IN BOOL EnableRawFilters
    );

VOID
DumpHttpRequest(
    IN PHTTP_REQUEST pRequest
    );

BOOLEAN
RenderHttpRequest(
    IN PHTTP_REQUEST pRequest,
    OUT PCHAR pBuffer,
    IN ULONG BufferLength
    );

PSTR
VerbToString(
    IN HTTP_VERB Verb
    );

PSTR
VersionToString(
    IN HTTP_VERSION Version
    );

PSTR
HeaderIdToString(
    IN HTTP_HEADER_ID HeaderId
    );

ULONG
InitSecurityAttributes(
    OUT PSECURITY_ATTRIBUTES pSecurityAttributes,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld
    );


#define INIT_RESPONSE( resp, status, reason )                               \
    do                                                                      \
    {                                                                       \
        RtlZeroMemory( (resp), sizeof(*(resp)) );                           \
        (resp)->Flags = 0;                                                  \
        (resp)->StatusCode = (status);                                      \
        (resp)->pReason = (reason);                                         \
        (resp)->ReasonLength = sizeof(reason) - sizeof(CHAR);               \
        (resp)->Headers.UnknownHeaderCount = 0;                             \
    } while (FALSE)


#define INIT_HEADER( resp, ndx, str )                                       \
    do                                                                      \
    {                                                                       \
        (resp)->Headers.pKnownHeaders[ndx].pRawValue = (str);               \
        (resp)->Headers.pKnownHeaders[ndx].RawValueLength =                 \
            sizeof(str) - sizeof(CHAR);                                     \
    } while (FALSE)


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tlog.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tlog.c

Abstract:

    A test for configuring UL Logging settings.

Author:

    Ali E Turkoglu (alitu)   20-May-2000

Revision History:

--*/


#include "precomp.h"
#include "iiscnfg.h"


DEFINE_COMMON_GLOBALS();

UCHAR CannedResponseEntityBody[] =
    "<html><head><title>Error</title></head>"
    "<body>The system cannot find the file specified. </body></html>";

#define LOG_DIR_NAME           L"C:\\temp\\w3svc1"
#define LOG_DIR_NAME2          L"C:\\temp2\\w3svc1"
#define LOG_DIR_NAME3          L"%SystemRoot%\\System32\\w3svc1"

#define LOG_SITE_NAME          L"w3svc1"


#define US_UserName     L"BigDataBigDataBigDataBigDaddyUserName"
#define US_UriStem      L"BigDataBigDataBigDataBigDaddyUriStem"

#define US_ClientIp     "BigDataBigDataBigDataBigDaddyClientIp"
#define US_ServiceName  "BigDataBigDataBigDataBigDaddyServiceName"
#define US_ServerName   "BigDataBigDataBigDataBigDaddyServerName"
#define US_ServerIp     "BigDataBigDataBigDataBigDaddyServerIp"
#define US_Method       "BigDataBigDataBigDataBigDaddyMethod"
#define US_UriQuery     "BigDataBigDataBigDataBigDaddyUriQuery"
#define US_Host         "BigDataBigDataBigDataBigDaddyHost"
#define US_UserAgent    "BigDataBigDataBigDataBigDaddyUserAgent"
#define US_Cookie       "BigDataBigDataBigDataBigDaddyCookie"
#define US_Referrer     "BigDataBigDataBigDataBigDaddyReferrer"


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];

    HTTP_CONFIG_GROUP_LOGGING   ulLogConfig;

    HTTP_LOG_FIELDS_DATA   LogData;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;


    //
    // Setup Logging config thru config_group
    //

    RtlZeroMemory( &LogData, sizeof(HTTP_LOG_FIELDS_DATA));

    wcscpy ( LogData.UserName, US_UserName );
    LogData.UserNameLength = (USHORT)wcslen( US_UserName );

    wcscpy ( LogData.UriStem, US_UriStem );
    LogData.UriStemLength = (USHORT)wcslen( US_UriStem );

    strcpy ( LogData.ClientIp, US_ClientIp );
    LogData.ClientIpLength = (USHORT) strlen( US_ClientIp );

    strcpy ( LogData.ServiceName, US_ServiceName );
    LogData.ServiceNameLength = (USHORT) strlen( US_ServiceName );

    strcpy ( LogData.ServerName, US_ServerName );
    LogData.ServerNameLength = (USHORT) strlen( US_ServerName );

    strcpy ( LogData.ServerIp, US_ServerIp );
    LogData.ServerIpLength = (USHORT) strlen( US_ServerIp );

    strcpy ( LogData.Method, US_Method );
    LogData.MethodLength = (USHORT) strlen( US_Method );

    strcpy ( LogData.UriQuery, US_UriQuery );
    LogData.UriQueryLength = (USHORT) strlen( US_UriQuery );

    strcpy ( LogData.Host, US_Host );
    LogData.HostLength = (USHORT) strlen( US_Host );

    strcpy ( LogData.UserAgent, US_UserAgent );
    LogData.UserAgentLength = (USHORT) strlen( US_UserAgent );

    strcpy ( LogData.Cookie, US_Cookie );
    LogData.CookieLength = (USHORT) strlen( US_Cookie );

    strcpy ( LogData.Referrer, US_Referrer );
    LogData.ReferrerLength = (USHORT) strlen( US_Referrer );


    RtlInitUnicodeString ( &ulLogConfig.LogFileDir,
                           LOG_DIR_NAME );
    RtlInitUnicodeString ( &ulLogConfig.SiteName,
                           LOG_SITE_NAME );
                           
    ulLogConfig.Flags.Present       = 1;    
    ulLogConfig.LoggingEnabled      = TRUE;
    ulLogConfig.LogFormat           = HttpLoggingTypeW3C; 
    ulLogConfig.LogPeriod           = HttpLoggingPeriodDaily;
    ulLogConfig.LogFileTruncateSize = HTTP_LIMIT_INFINITE;
    ulLogConfig.LogExtFileFlags     = MD_EXTLOG_DATE|
                                      MD_EXTLOG_TIME|
                                      MD_EXTLOG_CLIENT_IP|
                                      MD_EXTLOG_COOKIE |
                                      MD_EXTLOG_URI_STEM |
                                      MD_EXTLOG_URI_QUERY |
                                      MD_EXTLOG_PROTOCOL_VERSION |
                                      MD_EXTLOG_METHOD |
                                      MD_EXTLOG_BYTES_SENT |
                                      MD_EXTLOG_BYTES_RECV |
                                      MD_EXTLOG_TIME_TAKEN
                                      ;
    
    result = HttpSetConfigGroupInformation
                    (
                    controlChannel,
                    configId,
                    HttpConfigGroupLogInformation,
                    &ulLogConfig,
                    sizeof(ulLogConfig)
                    );
                    
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroup...(forConfigGroupLog...) failed, error %lu\n", result );
        goto cleanup;
    }

    result = HttpSetConfigGroupInformation
                    (
                    controlChannel,
                    configId,
                    HttpConfigGroupLogInformation,
                    &ulLogConfig,
                    sizeof(ulLogConfig)
                    );
                    
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroup...(forConfigGroupLog...) failed, error %lu\n", result );
        goto cleanup;
    }

    /*
    RtlInitUnicodeString ( &ulLogConfig.LogFileDir,
                           LOG_DIR_NAME2 );

    result = HttpSetConfigGroupInformation
                    (
                    controlChannel,
                    configId,
                    HttpConfigGroupLogInformation,
                    &ulLogConfig,
                    sizeof(ulLogConfig)
                    );
                    
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroup2...(forConfigGroupLog...) failed, error %lu\n", result );
        goto cleanup;
    }
    */

    wprintf( L"Success waiting for activity.\n" );

    //
    // Build our canned response.
    //

    INIT_RESPONSE( &response, 404, "Object Not Found" );
    INIT_HEADER( &response, HttpHeaderContentType, "text/html" );
    INIT_HEADER( &response, HttpHeaderContentLength, "102" );

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = CannedResponseEntityBody;
    dataChunk.FromMemory.BufferLength = sizeof(CannedResponseEntityBody) - 1;

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        &LogData
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }


  
cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tfile.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tfile.c

Abstract:

    Stupid test server for UL.SYS.

Author:

    Keith Moore (keithmo)        08-Aug-1998

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    PWSTR fileNamePart;
    ULONG i;
    ULONG urlLength;
    PWSTR url;
    PWSTR tmp;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];
    WCHAR fileName[MAX_PATH + 10];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Get the local directory and build part of the fully canonicalized
    // NT path. This makes it a bit faster to build the physical file name
    // down in the request/response loop.
    //

    GetCurrentDirectoryW( MAX_PATH, fileName );

    if (fileName[wcslen(fileName) - 1] == L'\\' )
    {
        fileName[wcslen(fileName) - 1] = L'\0';
    }

    fileNamePart = fileName + wcslen(fileName);

    //
    // Build the fixed part of our response.
    //

    INIT_RESPONSE( &response, 200, "OK" );

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"UlReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Build the response.
        //

        url = request->CookedUrl.pFullUrl;
        urlLength = request->CookedUrl.FullUrlLength;

        //
        // Hack: Find the port number, then skip to the following slash.
        //

        tmp = wcschr( url, L':' );

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L':' );
        }

        if (tmp != NULL)
        {
            tmp = wcschr( tmp, L'/' );
        }

        if (tmp != NULL)
        {
            urlLength -= (ULONG)( (tmp - url) * sizeof(WCHAR) );
            url = tmp;
        }

        //
        // Map it into the filename.
        //

        for (i = 0 ; i < (urlLength/sizeof(WCHAR)) ; url++, i++)
        {
            if (*url == L'/')
            {
                fileNamePart[i] = L'\\';
            }
            else
            {
                fileNamePart[i] = *url;
            }
        }

        fileNamePart[i] = L'\0';

        if (wcscmp( fileNamePart, L"\\" ) == 0 )
        {
            wcscat( fileNamePart, L"default.htm" );
        }

        if (TEST_OPTION(Verbose))
        {
            wprintf(
                L"mapped URL %s to physical file %s\n",
                request->CookedUrl.pFullUrl,
                fileName
                );
        }

        dataChunk.DataChunkType = HttpDataChunkFromFileName;
        dataChunk.FromFileName.FileNameLength = wcslen(fileName) * sizeof(WCHAR);
        dataChunk.FromFileName.pFileName = fileName;
        dataChunk.FromFileName.ByteRange.StartingOffset.QuadPart = 0;
        dataChunk.FromFileName.ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;

        //
        // Send the canned response.
        //

        DEBUG_BREAK();
        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"UlSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"UlDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tover.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    tover.c

Abstract:

    Minimal test server to test UL<-->WP overhead
    Heavily copied from tperf.c

Author:

    Keith Moore (keithmo)        13-Sep-1999

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define PENDING_IO_COUNT        8

//
// Private types.
//

typedef
ULONG
(* PCOMPLETION_ROUTINE)(
    IN struct _MY_OVERLAPPED *pMyOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

typedef struct _GLOBALS
{
    HANDLE ControlChannel;
    HANDLE AppPool;
    HTTP_CONFIG_GROUP_ID ConfigGroup;
    BOOL SendRawResponse;
    BOOL EnableLogging;
    BYTE * FileBuffer;
    DWORD FileSize;
    HTTP_DATA_CHUNK FileContentChunk;
    HTTP_RESPONSE StaticResponse;
    HTTP_DATA_CHUNK StaticRawResponse;
    HTTP_LOG_FIELDS_DATA LogFields;
    HANDLE CompletionPort;
    BOOL DoShutdown;

} GLOBALS, *PGLOBALS;

typedef struct _MY_OVERLAPPED
{
    OVERLAPPED Overlapped;
    struct _IO_CONTEXT *pIoContext;
    PCOMPLETION_ROUTINE pCompletionRoutine;

} MY_OVERLAPPED, *PMY_OVERLAPPED;

typedef struct _IO_CONTEXT
{
    MY_OVERLAPPED Read;
    MY_OVERLAPPED Send;
    PHTTP_REQUEST pRequestBuffer;
    DWORD RequestBufferLength;
    UCHAR StaticRequestBuffer[REQUEST_LENGTH];

} IO_CONTEXT, *PIO_CONTEXT;

//
// Private prototypes.
//

ULONG
LocalInitialize(
    DWORD NumberOfThreads,
    WCHAR * FilePath,
    BOOL EnableLogging,
    BOOL DoRawResponse
    );

VOID
LocalTerminate(
    IN BOOLEAN TerminateUl
    );

PIO_CONTEXT
AllocateIoContext(
    VOID
    );

VOID
InitializeIoContext(
    IN PIO_CONTEXT pIoContext
    );

VOID
FreeIoContext(
    IN PIO_CONTEXT pIoContext
    );

VOID
CleanupIoContext(
    IN PIO_CONTEXT pIoContext
    );

ULONG
GrowRequestBuffer(
    IN PIO_CONTEXT pIoContext,
    IN ULONG RequestBufferLength
    );

ULONG
ReadRequest(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_REQUEST_ID RequestId
    );

ULONG
ReadRequestComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

ULONG
SendResponse(
    IN PIO_CONTEXT pIoContext
    );

ULONG
SendResponseComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

DWORD
CALLBACK
WorkerThreadRoutine(
    PVOID Arg
    );

//
// Private globals.
//

DEFINE_COMMON_GLOBALS();

GLOBALS Globals;



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    ULONG i;
    PIO_CONTEXT pIoContext;
    DWORD NumberOfThreads;
    WCHAR * FilePath;
    BOOL EnableLogging;
    BOOL DoRawResponse;
    DWORD PendingIoCount;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    //
    // Parse command line
    //

    if ( argc != 6 )
    {
        wprintf( L"Usage: tover.exe <number-of-threads> <file-path> <log-0/1> <raw-0/1> <pending-IO-count>\n" );
        return 1;
    }

    NumberOfThreads = _wtoi( argv[ 1 ] );
    FilePath = argv[ 2 ];
    EnableLogging = _wtoi( argv[ 3 ] ) ? TRUE : FALSE;
    DoRawResponse = _wtoi( argv[ 4 ] ) ? TRUE : FALSE;
    PendingIoCount = _wtoi( argv[ 5 ] );

    result = LocalInitialize( NumberOfThreads,
                              FilePath,
                              EnableLogging,
                              DoRawResponse );

    if (result != NO_ERROR)
    {
        wprintf( L"LocalInitialize() failed, error %lu\n", result );
        return 1;
    }

    //
    // Fire off the initial I/O requests.
    //

    for (i = 0 ; i < PendingIoCount ; i++)
    {
        pIoContext = AllocateIoContext();

        if (pIoContext == NULL)
        {
            wprintf( L"Cannot allocate IO_CONTEXT\n" );
            return 1;
        }

        result = ReadRequest( pIoContext, HTTP_NULL_ID );

        if (result != NO_ERROR && result != ERROR_IO_PENDING)
        {
            wprintf( L"ReadRequest() failed, error %lu\n", result );
            return 1;
        }
    }

    //
    // Wait forever...
    //

    Sleep( INFINITE );

    //
    // BUGBUG: Need some way to get past the sleep...
    //

    LocalTerminate( TRUE );

    return 0;

}   // wmain


//
// Private functions.
//

ULONG
LocalInitialize(
    DWORD NumberOfThreads,
    WCHAR * FilePath,
    BOOL EnableLogging,
    BOOL DoRawResponse
    )
{
    ULONG result;
    ULONG i;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    BOOLEAN initDone;
    SECURITY_ATTRIBUTES securityAttributes;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    HANDLE Thread;
    DWORD BytesRead;
    DWORD RawSize;
    CHAR * RawBuffer;
    DWORD RawResponseSize;

    //
    // Setup globals & locals so we know how to cleanup on exit.
    //

    Globals.ControlChannel = NULL;
    Globals.AppPool = NULL;
    Globals.ConfigGroup = HTTP_NULL_ID;
    initDone = FALSE;

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &Globals.ControlChannel,
                    &Globals.AppPool,
                    NULL,                   // FilterChannel
                    &Globals.ConfigGroup,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    HTTP_OPTION_OVERLAPPED,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto fatal;
    }

    initDone = TRUE;

    //
    // Open the file and generate the response
    //

    FileHandle = CreateFileW( FilePath,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL );
    if ( FileHandle == INVALID_HANDLE_VALUE )
    {
        result = GetLastError();
        wprintf( L"Could not open content file %ws because of %d\n", FilePath, result );
        goto fatal;
    }

    Globals.FileSize = GetFileSize( FileHandle, NULL );
    if ( Globals.FileSize == 0 )
    {
        result = ERROR_INVALID_DATA;
        wprintf( L"File has not content\n" );
        goto fatal;
    }

    Globals.FileBuffer = LocalAlloc( LPTR, Globals.FileSize + 1 );
    if ( Globals.FileBuffer == NULL )
    {
        result = GetLastError();
        wprintf( L"Could not allocate content buffer\n" );
        goto fatal;
    }

    if ( !ReadFile( FileHandle,
                    Globals.FileBuffer,
                    Globals.FileSize,
                    &BytesRead,
                    NULL ) )
    {
        result = GetLastError();
        wprintf( L"Could not read file content\n" );
        goto fatal;
    }

    CloseHandle( FileHandle );
    FileHandle = INVALID_HANDLE_VALUE;

    //
    // Generate the appropriate response
    //

    if ( DoRawResponse )
    {
        //
        // Generate the entire raw response
        //

        RawSize = Globals.FileSize + 512;

        RawBuffer = LocalAlloc( LPTR, RawSize );
        if ( RawBuffer == NULL )
        {
            result = GetLastError();
            wprintf( L"Could not allocate raw response buffer\n" );
            goto fatal;
        }

        wsprintfA( RawBuffer,
                   "HTTP/1.1 200 OK\r\n"
                   "Server: Microsoft-IIS/6.0\r\n"
                   "Date: Thu, 30 Nov 2000 01:01:07 GMT\r\n"
                   "Content-Length: %d\r\n\r\n",
                   Globals.FileSize );

        RawResponseSize = strlen( RawBuffer );

        memcpy( RawBuffer + RawResponseSize,
                Globals.FileBuffer,
                Globals.FileSize );

        Globals.StaticRawResponse.DataChunkType = HttpDataChunkFromMemory;
        Globals.StaticRawResponse.FromMemory.pBuffer = RawBuffer;
        Globals.StaticRawResponse.FromMemory.BufferLength = RawResponseSize + Globals.FileSize;

        LocalFree( Globals.FileBuffer );

        Globals.FileBuffer = RawBuffer;

        Globals.SendRawResponse = TRUE;
    }
    else
    {
        //
        // Create an HTTP_RESPONSE
        //

        Globals.FileContentChunk.DataChunkType = HttpDataChunkFromMemory;
        Globals.FileContentChunk.FromMemory.pBuffer = Globals.FileBuffer;
        Globals.FileContentChunk.FromMemory.BufferLength = Globals.FileSize;

        Globals.StaticResponse.Flags = 0;
        Globals.StaticResponse.StatusCode = 200;
        Globals.StaticResponse.pReason = "OK";
        Globals.StaticResponse.ReasonLength = 2;
        Globals.StaticResponse.Headers.UnknownHeaderCount = 0;
        Globals.StaticResponse.EntityChunkCount = 1;
        Globals.StaticResponse.pEntityChunks = &Globals.FileContentChunk;
    }

    //
    // Are we logging or not?
    //

    if ( EnableLogging )
    {
        //
        // Generate a logging record
        //

        Globals.LogFields.UserNameLength = 0;
        Globals.LogFields.UserName = L"";
        Globals.LogFields.UriStemLength = 5 * 2;
        Globals.LogFields.UriStem = L"/Hell";
        Globals.LogFields.ClientIpLength = 15;
        Globals.LogFields.ClientIp = "111.111.111.111";
        Globals.LogFields.ServerNameLength = 9;
        Globals.LogFields.ServerName = "localhost";
        Globals.LogFields.ServiceNameLength = 0;
        Globals.LogFields.ServiceName = "";
        Globals.LogFields.ServerIpLength = 15;
        Globals.LogFields.ServerIp = "111.111.111.111";
        Globals.LogFields.MethodLength = 3;
        Globals.LogFields.Method = "GET";
        Globals.LogFields.UriQueryLength = 0;
        Globals.LogFields.UriQuery = "";
        Globals.LogFields.HostLength = 9;
        Globals.LogFields.Host = "localhost";
        Globals.LogFields.UserAgentLength = 0;
        Globals.LogFields.UserAgent = "";
        Globals.LogFields.CookieLength = 0;
        Globals.LogFields.Cookie = "";
        Globals.LogFields.ReferrerLength = 0;
        Globals.LogFields.Referrer = "";
        Globals.LogFields.ServerPort = 80;
        Globals.LogFields.ProtocolStatus = 200;
        Globals.LogFields.Win32Status = 0;

        Globals.EnableLogging = TRUE;
    }

    //
    // Create IO completion port
    //

    Globals.CompletionPort = CreateIoCompletionPort( Globals.AppPool,
                                                     NULL,
                                                     (ULONG_PTR) 0,
                                                     0 );
    if ( Globals.CompletionPort == NULL )
    {
        result = GetLastError();
        wprintf( L"Error creating completion port.  Error = %d\n", result );
        goto fatal;
    }

    //
    // Create worker threads
    //

    for ( i = 0; i < NumberOfThreads; i++ )
    {
        Thread = CreateThread( NULL,
                               0,
                               WorkerThreadRoutine,
                               NULL,
                               CREATE_SUSPENDED,
                               NULL );
        if ( Thread == NULL )
        {
            result = GetLastError();
            wprintf( L"Error creating thread.  Error = %d\n", result );
            goto fatal;
        }

        //
        // Do some affinitization stuff?
        //

        ResumeThread( Thread );

        CloseHandle( Thread );
    }

    //
    // Success!
    //

    return NO_ERROR;

fatal:

    if ( FileHandle != INVALID_HANDLE_VALUE )
    {
        CloseHandle( FileHandle );
    }

    LocalTerminate( initDone );

    return result;

}   // LocalInitialize


VOID
LocalTerminate(
    IN BOOLEAN TerminateUl
    )
{
    ULONG result;
    ULONG i;

    if (Globals.ConfigGroup != HTTP_NULL_ID)
    {
        result = HttpDeleteConfigGroup(
                        Globals.ControlChannel,
                        Globals.ConfigGroup
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (Globals.AppPool != NULL)
    {
        CloseHandle( Globals.AppPool );
    }

    if (Globals.ControlChannel != NULL)
    {
        CloseHandle( Globals.ControlChannel );
    }

    if (TerminateUl)
    {
        HttpTerminate();
    }

}   // LocalTerminate


PIO_CONTEXT
AllocateIoContext(
    VOID
    )
{
    PIO_CONTEXT pIoContext;

    pIoContext = ALLOC( sizeof(*pIoContext) );

    if (pIoContext != NULL)
    {
        InitializeIoContext( pIoContext );
    }

    return pIoContext;

}   // AllocateIoContext


VOID
InitializeIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    ZeroMemory( pIoContext, sizeof(*pIoContext) );
    pIoContext->pRequestBuffer = (PHTTP_REQUEST)pIoContext->StaticRequestBuffer;
    pIoContext->RequestBufferLength = sizeof(pIoContext->StaticRequestBuffer);
    pIoContext->Read.pIoContext = pIoContext;
    pIoContext->Read.pCompletionRoutine = &ReadRequestComplete;
    pIoContext->Send.pIoContext = pIoContext;
    pIoContext->Send.pCompletionRoutine = &SendResponseComplete;

}   // InitializeIoContext


VOID
FreeIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    CleanupIoContext( pIoContext );
    FREE( pIoContext );

}   // FreeIoContext


VOID
CleanupIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    if (pIoContext->pRequestBuffer != (PHTTP_REQUEST)pIoContext->StaticRequestBuffer)
    {
        FREE( pIoContext->pRequestBuffer );
        pIoContext->pRequestBuffer = (PHTTP_REQUEST)pIoContext->StaticRequestBuffer;
    }

}   // CleanupIoContext


ULONG
GrowRequestBuffer(
    IN PIO_CONTEXT pIoContext,
    IN ULONG RequestBufferLength
    )
{
    PHTTP_REQUEST pNewBuffer;

    if (RequestBufferLength <= pIoContext->RequestBufferLength)
    {
        return NO_ERROR;
    }

    pNewBuffer = ALLOC( RequestBufferLength );

    if (pNewBuffer != NULL)
    {
        if (pIoContext->pRequestBuffer != (PHTTP_REQUEST)pIoContext->StaticRequestBuffer)
        {
            FREE( pIoContext->pRequestBuffer );
        }

        pIoContext->pRequestBuffer = pNewBuffer;
        return NO_ERROR;
    }

    return ERROR_NOT_ENOUGH_MEMORY;

}   // GrowRequestBuffer


ULONG
ReadRequest(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_REQUEST_ID RequestId
    )
{
    ULONG result;
    ULONG bytesRead;

    //
    // Read a request.
    //

    result = HttpReceiveHttpRequest(
                    Globals.AppPool,
                    RequestId,
                    0,
                    pIoContext->pRequestBuffer,
                    pIoContext->RequestBufferLength,
                    &bytesRead,
                    &pIoContext->Read.Overlapped
                    );

    if (result != ERROR_IO_PENDING)
    {
        result = (pIoContext->Read.pCompletionRoutine)(
                        &pIoContext->Read,
                        result,
                        bytesRead
                        );
    }

    return result;

}   // ReadRequest


ULONG
ReadRequestComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    )
{
    PIO_CONTEXT pIoContext;

    pIoContext = pOverlapped->pIoContext;

    if (ErrorCode == ERROR_MORE_DATA)
    {
        //
        // Request buffer too small; reallocate & try again.
        //

        ErrorCode = GrowRequestBuffer( pIoContext, BytesTransferred );

        if (ErrorCode == NO_ERROR)
        {
            ErrorCode = ReadRequest(
                            pIoContext,
                            pIoContext->pRequestBuffer->RequestId
                            );
        }
    }

    ErrorCode = SendResponse( pIoContext );

    return ErrorCode;

}   // ReadRequestComplete


ULONG
SendResponse(
    IN PIO_CONTEXT pIoContext
    )
{
    DWORD               bytesSent;
    ULONG               result;
    
    if ( Globals.SendRawResponse )
    {
        result = HttpSendEntityBody( Globals.AppPool,
                                     pIoContext->pRequestBuffer->RequestId,
                                     HTTP_SEND_RESPONSE_FLAG_RAW_HEADER,
                                     1,
                                     &Globals.StaticRawResponse,
                                     &bytesSent,
                                     &pIoContext->Send.Overlapped,
                                     Globals.EnableLogging ? &Globals.LogFields : NULL );
    }
    else
    {
        result = HttpSendHttpResponse( Globals.AppPool,
                                       pIoContext->pRequestBuffer->RequestId,
                                       0,
                                       &Globals.StaticResponse,
                                       NULL,
                                       &bytesSent,
                                       &pIoContext->Send.Overlapped,
                                       Globals.EnableLogging ? &Globals.LogFields : NULL );
    }

    return result;

}   // SendResponse


ULONG
SendResponseComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    )
{
    PIO_CONTEXT pIoContext;

    pIoContext = pOverlapped->pIoContext;

    ErrorCode = ReadRequest( pIoContext, HTTP_NULL_ID );
    return ErrorCode;

}   // SendResponseComplete

DWORD
CALLBACK
WorkerThreadRoutine(
    VOID *          Arg
    )
{
    BOOL            Complete;
    OVERLAPPED *    pOverlapped;
    DWORD           Bytes;
    ULONG_PTR       CompletionKey;
    DWORD           ErrorStatus;
    PMY_OVERLAPPED  pMyOverlapped;
    PIO_CONTEXT     pIoContext;
    
    for ( ; !Globals.DoShutdown ; )
    {
        Complete = GetQueuedCompletionStatus( Globals.CompletionPort,
                                              &Bytes,
                                              &CompletionKey,
                                              &pOverlapped,
                                              INFINITE );

        ErrorStatus = Complete ? ERROR_SUCCESS : GetLastError();

        pMyOverlapped = CONTAINING_RECORD( pOverlapped,
                                           MY_OVERLAPPED,
                                           Overlapped );

        pMyOverlapped->pCompletionRoutine( pMyOverlapped,
                                           ErrorStatus,
                                           Bytes );
    }

    return NO_ERROR;
}

VOID
CALLBACK
IoCompletionRoutine(
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred,
    IN LPOVERLAPPED pOverlapped
    )
{
    PMY_OVERLAPPED pMyOverlapped;
    PIO_CONTEXT pIoContext;

    pMyOverlapped = CONTAINING_RECORD(
                        pOverlapped,
                        MY_OVERLAPPED,
                        Overlapped
                        );

    (pMyOverlapped->pCompletionRoutine)(
        pMyOverlapped,
        ErrorCode,
        BytesTransferred
        );

}   // IoCompletionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tnagle.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    tnagle.c

Abstract:

    Stupid test server for UL.SYS.

Author:

    Keith Moore (keithmo)        15-Sep-1999

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    UCHAR responseBuffer[80];
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Build our canned response.
    //

    INIT_RESPONSE( &response, 200, "OK" );
    INIT_HEADER( &response, HttpHeaderContentType, "text/plain" );

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 0;
        response.pEntityChunks = NULL;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        HTTP_SEND_RESPONSE_FLAG_MORE_DATA,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }

        for (i = 0 ; i < 1000 ; i++)
        {
            sprintf( responseBuffer, "Line %lu\r\n", i );

            dataChunk.DataChunkType = HttpDataChunkFromMemory;
            dataChunk.FromMemory.pBuffer = responseBuffer;
            dataChunk.FromMemory.BufferLength = strlen(responseBuffer);

            result = HttpSendEntityBody(
                         appPool,
                         request->RequestId,
                         HTTP_SEND_RESPONSE_FLAG_MORE_DATA,
                         1,
                         &dataChunk,
                         &bytesSent,
                         NULL,
                         NULL
                         );

            if (result != NO_ERROR)
            {
                wprintf( L"HttpSendEntityBody() failed, error %lu\n", result );
                break;
            }
        }

        result = HttpSendEntityBody(
                     appPool,
                     request->RequestId,
                     0,
                     0,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendEntityBody() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tsec.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tsec.c

Abstract:

    Stupid security test for UL.SYS.

Author:

    Keith Moore (keithmo)        22-Mar-1999

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool1;
    HANDLE appPool2;
    BOOL initDone;
    SECURITY_ATTRIBUTES securityAttributes;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool1 = NULL;
    appPool2 = NULL;

    //
    // Initialize the security attributes. This should create a
    // security descriptor that we ourselves cannot even access.
    // Bizarre, yes, but it allows us to test the access check code.
    //

    result = InitSecurityAttributes(
                    &securityAttributes,
                    TRUE,                   // AllowSystem
                    FALSE,                  // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE                   // AllowWorld
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitSecurityAttributes() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Initialize the UL interface.
    //

    result = HttpInitialize( 0 );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpInitialize() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Open a control channel to the driver.
    //

    result = HttpOpenControlChannel(
                    &controlChannel,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpOpenControlChannel() failed, error %lu\n", result );

        //
        // Non-fatal; test if we can create the app pool.
        //
    }

    //
    // Create an application pool.
    //

    result = HttpCreateAppPool(
                    &appPool1,
                    APP_POOL_NAME,
                    &securityAttributes,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateAppPool() failed, error %lu\n", result );

        //
        // Non-fatal; test if we can open the app pool.
        //
    }

    //
    // Try to open the same app pool. This should fail.
    //

    result = HttpOpenAppPool(
                    &appPool2,
                    APP_POOL_NAME,
                    0
                    );

    if (result == NO_ERROR)
    {
        wprintf( L"HttpOpenAppPool() succeeded (!?!?!)\n" );
    }
    else
    {
        wprintf(
            L"HttpOpenAppPool() failed, error %lu (%s)\n",
            result,
            (result == ERROR_ACCESS_DENIED)
                ? L"EXPECTED"
                : L"BOGUS!"
            );
    }

cleanup:

    if (appPool1 != NULL)
    {
        CloseHandle( appPool1 );
    }

    if (appPool2 != NULL)
    {
        CloseHandle( appPool2 );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tperf.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    tperf.c

Abstract:

    UL Performance Test Server.

Author:

    Keith Moore (keithmo)        13-Sep-1999

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define PENDING_IO_COUNT        8
#define NUM_HASH_BUCKETS        17

#define HASH_CONNECTION(connid)                                             \
    ((HASH_SCRAMBLE(connid) + HASH_SCRAMBLE(connid >> 32)) % NUM_HASH_BUCKETS)


//
// Private types.
//

typedef
ULONG
(* PCOMPLETION_ROUTINE)(
    IN struct _MY_OVERLAPPED *pMyOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

typedef struct _GLOBALS
{
    HANDLE ControlChannel;
    HANDLE AppPool;
    HTTP_CONFIG_GROUP_ID ConfigGroup;

    CRITICAL_SECTION HashLock;
    LIST_ENTRY HashBucketListHead[NUM_HASH_BUCKETS];

    ULONG RootFileNameLength;
    WCHAR RootFileName[FILENAME_BUFFER_LENGTH];

} GLOBALS, *PGLOBALS;

typedef struct _MY_OVERLAPPED
{
    OVERLAPPED Overlapped;
    struct _IO_CONTEXT *pIoContext;
    PCOMPLETION_ROUTINE pCompletionRoutine;

} MY_OVERLAPPED, *PMY_OVERLAPPED;

typedef struct _IO_CONTEXT
{
    MY_OVERLAPPED Read;
    MY_OVERLAPPED Send;
    PHTTP_REQUEST pRequestBuffer;
    HTTP_RESPONSE Response;
    HTTP_DATA_CHUNK DataChunk;
    PWCHAR pFileNamePart;
    ULONG RequestBufferLength;

    UCHAR StaticRequestBuffer[REQUEST_LENGTH];
    WCHAR FileNameBuffer[FILENAME_BUFFER_LENGTH];

} IO_CONTEXT, *PIO_CONTEXT;

typedef struct _HASH_ENTRY
{
    LIST_ENTRY HashBucketListEntry;
    HTTP_CONNECTION_ID ConnectionId;
    MY_OVERLAPPED Disconnect;

} HASH_ENTRY, *PHASH_ENTRY;


//
// Private prototypes.
//

ULONG
LocalInitialize(
    VOID
    );

VOID
LocalTerminate(
    IN BOOLEAN TerminateUl
    );

PIO_CONTEXT
AllocateIoContext(
    VOID
    );

VOID
InitializeIoContext(
    IN PIO_CONTEXT pIoContext
    );

VOID
FreeIoContext(
    IN PIO_CONTEXT pIoContext
    );

VOID
CleanupIoContext(
    IN PIO_CONTEXT pIoContext
    );

ULONG
GrowRequestBuffer(
    IN PIO_CONTEXT pIoContext,
    IN ULONG RequestBufferLength
    );

ULONG
ReadRequest(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_REQUEST_ID RequestId
    );

ULONG
ReadRequestComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

ULONG
SendResponse(
    IN PIO_CONTEXT pIoContext
    );

ULONG
SendResponseComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

ULONG
WaitForDisconnect(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_CONNECTION_ID ConnectionId
    );

ULONG
WaitForDisconnectComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    );

VOID
CALLBACK
IoCompletionRoutine(
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred,
    IN LPOVERLAPPED pOverlapped
    );

PHASH_ENTRY
FindHashEntryForConnection(
    IN HTTP_CONNECTION_ID ConnectionId,
    IN BOOLEAN OkToCreate
    );

VOID
RemoveHashEntry(
    IN PHASH_ENTRY pHashEntry
    );


//
// Private globals.
//

DEFINE_COMMON_GLOBALS();

GLOBALS Globals;



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    ULONG i;
    PIO_CONTEXT pIoContext;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    result = LocalInitialize();

    if (result != NO_ERROR)
    {
        wprintf( L"LocalInitialize() failed, error %lu\n", result );
        return 1;
    }

    //
    // Fire off the initial I/O requests.
    //

    for (i = 0 ; i < PENDING_IO_COUNT ; i++)
    {
        pIoContext = AllocateIoContext();

        if (pIoContext == NULL)
        {
            wprintf( L"Cannot allocate IO_CONTEXT\n" );
            return 1;
        }

        result = ReadRequest( pIoContext, HTTP_NULL_ID );

        if (result != NO_ERROR && result != ERROR_IO_PENDING)
        {
            wprintf( L"ReadRequest() failed, error %lu\n", result );
            return 1;
        }
    }

    //
    // Wait forever...
    //

    Sleep( INFINITE );

    //
    // BUGBUG: Need some way to get past the sleep...
    //

    LocalTerminate( TRUE );

    return 0;

}   // wmain


//
// Private functions.
//

ULONG
LocalInitialize(
    VOID
    )
{
    ULONG result;
    ULONG i;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    BOOLEAN initDone;
    SECURITY_ATTRIBUTES securityAttributes;

    //
    // Setup globals & locals so we know how to cleanup on exit.
    //

    Globals.ControlChannel = NULL;
    Globals.AppPool = NULL;
    Globals.ConfigGroup = HTTP_NULL_ID;
    initDone = FALSE;

    //
    // Initialize the hash data.
    //

    InitializeCriticalSection( &Globals.HashLock );

    for (i = 0 ; i < NUM_HASH_BUCKETS ; i++)
    {
        InitializeListHead( &Globals.HashBucketListHead[i] );
    }

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &Globals.ControlChannel,
                    &Globals.AppPool,
                    NULL,                   // FilterChannel
                    &Globals.ConfigGroup,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    HTTP_OPTION_OVERLAPPED,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto fatal;
    }

    initDone = TRUE;

    //
    // Get the local directory and build part of the fully canonicalized
    // NT path. This makes it a bit faster to build the physical file name
    // down in the request/response loop.
    //

    GetCurrentDirectoryW( MAX_PATH, Globals.RootFileName );

    if (Globals.RootFileName[wcslen(Globals.RootFileName) - 1] == L'\\' )
    {
        Globals.RootFileName[wcslen(Globals.RootFileName) - 1] = L'\0';
    }

    Globals.RootFileNameLength = wcslen(Globals.RootFileName);

    //
    // Associate the app pool with an I/O completion port buried down
    // in the thread pool package.
    //

    if (!BindIoCompletionCallback(
            Globals.AppPool,
            &IoCompletionRoutine,
            0
            ))
    {
        result = GetLastError();
        wprintf( L"BindIoCompletionCallback() failed, error %lu\n", result );
        goto fatal;
    }

    //
    // Success!
    //

    return NO_ERROR;

fatal:

    LocalTerminate( initDone );

    return result;

}   // LocalInitialize


VOID
LocalTerminate(
    IN BOOLEAN TerminateUl
    )
{
    ULONG result;
    ULONG i;
    PLIST_ENTRY pListEntry;
    PHASH_ENTRY pHashEntry;

    if (Globals.ConfigGroup != HTTP_NULL_ID)
    {
        result = HttpDeleteConfigGroup(
                        Globals.ControlChannel,
                        Globals.ConfigGroup
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (Globals.AppPool != NULL)
    {
        CloseHandle( Globals.AppPool );
    }

    if (Globals.ControlChannel != NULL)
    {
        CloseHandle( Globals.ControlChannel );
    }

    if (TerminateUl)
    {
        HttpTerminate();
    }

    for (i = 0 ; i < NUM_HASH_BUCKETS ; i++)
    {
        while (!IsListEmpty( &Globals.HashBucketListHead[i] ))
        {
            pListEntry = RemoveHeadList( &Globals.HashBucketListHead[i] );

            pHashEntry = CONTAINING_RECORD(
                             pListEntry,
                             HASH_ENTRY,
                             HashBucketListEntry
                             );

            FREE( pHashEntry );
        }
    }

    DeleteCriticalSection( &Globals.HashLock );

}   // LocalTerminate


PIO_CONTEXT
AllocateIoContext(
    VOID
    )
{
    PIO_CONTEXT pIoContext;

    pIoContext = ALLOC( sizeof(*pIoContext) );

    if (pIoContext != NULL)
    {
        InitializeIoContext( pIoContext );
    }

    return pIoContext;

}   // AllocateIoContext


VOID
InitializeIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    ZeroMemory( pIoContext, sizeof(*pIoContext) );
    pIoContext->pRequestBuffer = (PHTTP_REQUEST)pIoContext->StaticRequestBuffer;
    pIoContext->RequestBufferLength = sizeof(pIoContext->StaticRequestBuffer);
    wcscpy( pIoContext->FileNameBuffer, Globals.RootFileName );
    pIoContext->pFileNamePart = pIoContext->FileNameBuffer + Globals.RootFileNameLength;
    pIoContext->Read.pIoContext = pIoContext;
    pIoContext->Read.pCompletionRoutine = &ReadRequestComplete;
    pIoContext->Send.pIoContext = pIoContext;
    pIoContext->Send.pCompletionRoutine = &SendResponseComplete;

}   // InitializeIoContext


VOID
FreeIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    CleanupIoContext( pIoContext );
    FREE( pIoContext );

}   // FreeIoContext


VOID
CleanupIoContext(
    IN PIO_CONTEXT pIoContext
    )
{
    if (pIoContext->pRequestBuffer != (PHTTP_REQUEST)pIoContext->StaticRequestBuffer)
    {
        FREE( pIoContext->pRequestBuffer );
        pIoContext->pRequestBuffer = (PHTTP_REQUEST)pIoContext->StaticRequestBuffer;
    }

}   // CleanupIoContext


ULONG
GrowRequestBuffer(
    IN PIO_CONTEXT pIoContext,
    IN ULONG RequestBufferLength
    )
{
    PHTTP_REQUEST pNewBuffer;

    if (RequestBufferLength <= pIoContext->RequestBufferLength)
    {
        return NO_ERROR;
    }

    pNewBuffer = ALLOC( RequestBufferLength );

    if (pNewBuffer != NULL)
    {
        if (pIoContext->pRequestBuffer != (PHTTP_REQUEST)pIoContext->StaticRequestBuffer)
        {
            FREE( pIoContext->pRequestBuffer );
        }

        pIoContext->pRequestBuffer = pNewBuffer;
        return NO_ERROR;
    }

    return ERROR_NOT_ENOUGH_MEMORY;

}   // GrowRequestBuffer


ULONG
ReadRequest(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_REQUEST_ID RequestId
    )
{
    ULONG result;
    ULONG bytesRead;

    //
    // Read a request.
    //

    result = HttpReceiveHttpRequest(
                    Globals.AppPool,
                    RequestId,
                    0,
                    pIoContext->pRequestBuffer,
                    pIoContext->RequestBufferLength,
                    &bytesRead,
                    &pIoContext->Read.Overlapped
                    );

    if (result != ERROR_IO_PENDING)
    {
        result = (pIoContext->Read.pCompletionRoutine)(
                        &pIoContext->Read,
                        result,
                        bytesRead
                        );
    }

    return result;

}   // ReadRequest


ULONG
ReadRequestComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    )
{
    PIO_CONTEXT pIoContext;
    PHASH_ENTRY pHashEntry;

    pIoContext = pOverlapped->pIoContext;

    if (ErrorCode == ERROR_MORE_DATA)
    {
        //
        // Request buffer too small; reallocate & try again.
        //

        ErrorCode = GrowRequestBuffer( pIoContext, BytesTransferred );

        if (ErrorCode == NO_ERROR)
        {
            ErrorCode = ReadRequest(
                            pIoContext,
                            pIoContext->pRequestBuffer->RequestId
                            );
        }
    }

    if (ErrorCode == NO_ERROR)
    {
        pHashEntry = FindHashEntryForConnection(
                            pIoContext->pRequestBuffer->ConnectionId,
                            FALSE
                            );

        if (pHashEntry == NULL)
        {
            WaitForDisconnect(
                pIoContext,
                pIoContext->pRequestBuffer->ConnectionId
                );
        }

        ErrorCode = SendResponse( pIoContext );
    }

    return ErrorCode;

}   // ReadRequestComplete


ULONG
SendResponse(
    IN PIO_CONTEXT pIoContext
    )
{
    ULONG result;
    ULONG bytesSent;
    ULONG i;
    ULONG urlLength;
    PWSTR url;
    PWSTR tmp;

    //
    // Dump it.
    //

    if (TEST_OPTION(Verbose))
    {
        DumpHttpRequest( pIoContext->pRequestBuffer );
    }

    //
    // Build the response.
    //

    INIT_RESPONSE( &pIoContext->Response, 200, "OK" );

    url = pIoContext->pRequestBuffer->CookedUrl.pFullUrl;
    urlLength = pIoContext->pRequestBuffer->CookedUrl.FullUrlLength;

    //
    // Hack: Find the port number, then skip to the following slash.
    //

    tmp = wcschr( url, L':' );

    if (tmp != NULL)
    {
        tmp = wcschr( tmp, L'/' );
    }

    if (tmp != NULL)
    {
        tmp = wcschr( tmp, L':' );
    }

    if (tmp != NULL)
    {
        tmp = wcschr( tmp, L'/' );
    }

    if (tmp != NULL)
    {
        urlLength -= (ULONG)( (tmp - url) * sizeof(WCHAR) );
        url = tmp;
    }

    //
    // Map it into the filename.
    //

    for (i = 0 ; i < (urlLength/sizeof(WCHAR)) ; url++, i++)
    {
        if (*url == L'/')
        {
            pIoContext->pFileNamePart[i] = L'\\';
        }
        else
        {
            pIoContext->pFileNamePart[i] = *url;
        }
    }

    pIoContext->pFileNamePart[i] = L'\0';

    if (wcscmp( pIoContext->pFileNamePart, L"\\" ) == 0 )
    {
        wcscat( pIoContext->pFileNamePart, L"default.htm" );
    }

    if (TEST_OPTION(Verbose))
    {
        wprintf(
            L"mapped URL %s to physical file %s\n",
            pIoContext->pRequestBuffer->CookedUrl.pFullUrl,
            pIoContext->FileNameBuffer
            );
    }

    pIoContext->DataChunk.DataChunkType = HttpDataChunkFromFileName;
    pIoContext->DataChunk.FromFileName.FileNameLength = wcslen(pIoContext->FileNameBuffer) * sizeof(WCHAR);
    pIoContext->DataChunk.FromFileName.pFileName = pIoContext->FileNameBuffer;
    pIoContext->DataChunk.FromFileName.ByteRange.StartingOffset.QuadPart = 0;
    pIoContext->DataChunk.FromFileName.ByteRange.Length.QuadPart = HTTP_BYTE_RANGE_TO_EOF;

    //
    // Send the response.
    //

    pIoContext->Response.EntityChunkCount = 1;
    pIoContext->Response.pEntityChunks = &pIoContext->DataChunk;

    result = HttpSendHttpResponse(
                    Globals.AppPool,
                    pIoContext->pRequestBuffer->RequestId,
                    0,
                    &pIoContext->Response,
                    NULL,
                    &bytesSent,
                    &pIoContext->Send.Overlapped,
                    NULL
                    );

    if (result != ERROR_IO_PENDING)
    {
        result = (pIoContext->Read.pCompletionRoutine)(
                        &pIoContext->Send,
                        result,
                        bytesSent
                        );
    }

    return result;

}   // SendResponse


ULONG
SendResponseComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    )
{
    PIO_CONTEXT pIoContext;

    pIoContext = pOverlapped->pIoContext;

    ErrorCode = ReadRequest( pIoContext, HTTP_NULL_ID );
    return ErrorCode;

}   // SendResponseComplete


ULONG
WaitForDisconnect(
    IN PIO_CONTEXT pIoContext,
    IN HTTP_CONNECTION_ID ConnectionId
    )
{
    ULONG result;
    PHASH_ENTRY pHashEntry;

    pHashEntry = FindHashEntryForConnection( ConnectionId, TRUE );

    if (pHashEntry == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pHashEntry->Disconnect.pIoContext = pIoContext;
    pHashEntry->Disconnect.pCompletionRoutine = &WaitForDisconnectComplete;

    //
    // Wait for disconnect.
    //

    wprintf( L"%I64x wait for disconnect\n", pHashEntry->ConnectionId );

    result = HttpWaitForDisconnect(
                    Globals.AppPool,
                    ConnectionId,
                    &pHashEntry->Disconnect.Overlapped
                    );

    if (result != ERROR_IO_PENDING)
    {
        result = (pHashEntry->Disconnect.pCompletionRoutine)(
                        &pHashEntry->Disconnect,
                        result,
                        0
                        );
    }

    return result;

}   // WaitForDisconnect


ULONG
WaitForDisconnectComplete(
    IN PMY_OVERLAPPED pOverlapped,
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred
    )
{
    PHASH_ENTRY pHashEntry;

    pHashEntry = CONTAINING_RECORD(
                        pOverlapped,
                        HASH_ENTRY,
                        Disconnect
                        );

    wprintf( L"%I64x disconnected\n", pHashEntry->ConnectionId );
    RemoveHashEntry( pHashEntry );

    return NO_ERROR;

}   // WaitForDisconnectComplete


VOID
CALLBACK
IoCompletionRoutine(
    IN ULONG ErrorCode,
    IN ULONG BytesTransferred,
    IN LPOVERLAPPED pOverlapped
    )
{
    PMY_OVERLAPPED pMyOverlapped;
    PIO_CONTEXT pIoContext;

    pMyOverlapped = CONTAINING_RECORD(
                        pOverlapped,
                        MY_OVERLAPPED,
                        Overlapped
                        );

    (pMyOverlapped->pCompletionRoutine)(
        pMyOverlapped,
        ErrorCode,
        BytesTransferred
        );

}   // IoCompletionRoutine


PHASH_ENTRY
FindHashEntryForConnection(
    IN HTTP_CONNECTION_ID ConnectionId,
    IN BOOLEAN OkToCreate
    )
{
    PLIST_ENTRY pListHead;
    PLIST_ENTRY pListEntry;
    PHASH_ENTRY pHashEntry;

    pListHead = &Globals.HashBucketListHead[HASH_CONNECTION(ConnectionId)];

    EnterCriticalSection( &Globals.HashLock );

    pListEntry = pListHead->Flink;
    pHashEntry = NULL;

    while (pListEntry != pListHead)
    {
        pHashEntry = CONTAINING_RECORD(
                         pListEntry,
                         HASH_ENTRY,
                         HashBucketListEntry
                         );

        if (pHashEntry->ConnectionId == ConnectionId)
        {
            break;
        }

        pListEntry = pListEntry->Flink;
        pHashEntry = NULL;
    }

    if (pHashEntry == NULL)
    {
        if (OkToCreate)
        {
            pHashEntry = ALLOC( sizeof(*pHashEntry) );

            if (pHashEntry != NULL)
            {
                InsertTailList( pListHead, &pHashEntry->HashBucketListEntry );
                pHashEntry->ConnectionId = ConnectionId;
            }
        }
    }

    LeaveCriticalSection( &Globals.HashLock );

    return pHashEntry;

}   // FindHashEntryForConnection


VOID
RemoveHashEntry(
    IN PHASH_ENTRY pHashEntry
    )
{
    EnterCriticalSection( &Globals.HashLock );
    RemoveEntryList( &pHashEntry->HashBucketListEntry );
    LeaveCriticalSection( &Globals.HashLock );

}   // RemoveHashEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tmultiecho.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    tmultiecho.c

Abstract:

    Echo test server for HTTP.SYS for multiple control channels

Author:

    Keith Moore (keithmo)        16-Nov-1999

Revision History:

    Eric Stenson (ericsten)      10-May-2001    Ripped off 

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();

#define MAX_APP_NAME_LEN    128

ULONG
InitTransUlStuff(
    OUT PHANDLE pControlChannel,
    OUT PHANDLE pAppPool,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroup,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld,
    IN ULONG AppPoolOptions,
    IN PWSTR wszAppPoolName,
    IN PWSTR wszUrl
    );



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    PWSTR tmp;
    BOOL initDone;
    PCHAR pRenderedRequest;
    ULONG RenderedLength;
    PCHAR pRequestBuffer;
    ULONG RequestBufferLength;
    WCHAR wszAppPoolName[MAX_APP_NAME_LEN];
    PWSTR wszUrl = NULL;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (argc > 1)
    {
        wszUrl = argv[1];
    } else
    {
        wszUrl = TRANS_URL_NAME;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );
    pRenderedRequest = NULL;
    RenderedLength = 0;

    RequestBufferLength = 2048;
    pRequestBuffer = ALLOC( RequestBufferLength );

    if (pRequestBuffer == NULL)
    {
        wprintf( L"out of memory\n" );
        return 1;
    }

    request = (PHTTP_REQUEST)pRequestBuffer;

    //
    // Set up (relatively) unique app pool name
    //
    wsprintf( wszAppPoolName, L"%s [%d]",
              APP_POOL_NAME,
              GetCurrentProcessId()
              );

    //
    // Get UL started.
    //

    result = InitTransUlStuff(
                    &controlChannel,
                    &appPool,
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    wszAppPoolName,
                    wszUrl
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Build the fixed part of our response.
    //

    INIT_RESPONSE( &response, 200, "OK" );

    //
    // Loop forever...
    //

    for (;;)
    {
        //
        // Wait for a request.
        //

        HTTP_SET_NULL_ID( &requestId );

        do
        {
            result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        request,
                        RequestBufferLength,
                        &bytesRead,
                        NULL
                        );

            if (result == ERROR_MORE_DATA)
            {
                //
                // Buffer was too small.
                //

                if (bytesRead < RequestBufferLength)
                {
                    result = ERROR_INVALID_DATA;
                    wprintf( L"got bogus %lu BytesRead\n" );
                    break;
                }

                //
                // Note that we must snag the request ID from the
                // old buffer before replacing it with a new buffer.
                //

                requestId = request->RequestId;

                RequestBufferLength = bytesRead;
                FREE( pRequestBuffer );
                pRequestBuffer = ALLOC( RequestBufferLength );

                if (pRequestBuffer == NULL)
                {
                    result = ERROR_NOT_ENOUGH_MEMORY;
                    wprintf( L"out of memory\n" );
                    break;
                }

                request = (PHTTP_REQUEST)pRequestBuffer;
                continue;
            }

        } while (result == ERROR_MORE_DATA);

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Render the request as an ASCII string.
        //

        for (;;)
        {
            if (RenderHttpRequest( request, pRenderedRequest, RenderedLength ))
            {
                break;
            }

            FREE( pRenderedRequest );
            RenderedLength += 1024;
            pRenderedRequest = ALLOC( RenderedLength );

            if (pRenderedRequest == NULL)
            {
                wprintf( L"out of memory\n" );
                break;
            }
        }

        //
        // Dump it.
        //

        DumpHttpRequest( request );

        //
        // Build the response.
        //

        dataChunk.DataChunkType = HttpDataChunkFromMemory;
        dataChunk.FromMemory.pBuffer = pRenderedRequest;
        dataChunk.FromMemory.BufferLength = (ULONG)strlen( pRenderedRequest );

        //
        // Send the response.
        //

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (pRequestBuffer != NULL)
    {
        FREE( pRequestBuffer );
    }

    if (pRenderedRequest != NULL)
    {
        FREE( pRenderedRequest );
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain

ULONG
InitTransUlStuff(
    OUT PHANDLE pControlChannel,
    OUT PHANDLE pAppPool,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroup,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld,
    IN ULONG AppPoolOptions,
    IN PWSTR wszAppPoolName,
    IN PWSTR wszUrl
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HANDLE filterChannel;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_CONFIG_GROUP_SITE configSite;
    BOOL initDone;
    SECURITY_ATTRIBUTES securityAttributes;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    filterChannel = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Initialize the security attributes.
    //

    result = InitSecurityAttributes(
                    &securityAttributes,
                    AllowSystem,
                    AllowAdmin,
                    AllowCurrentUser,
                    AllowWorld
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitSecurityAttributes() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Initialize the UL interface.
    //

    result = HttpInitialize( 0 );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpInitialize() failed, error %lu\n", result );
        goto cleanup;
    }


    initDone = TRUE;

    //
    // Open a control channel to the driver.
    //

    result = HttpOpenControlChannel(
                    &controlChannel,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpOpenControlChannel() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Create an application pool.
    //

    result = HttpCreateAppPool(
                    &appPool,
                    wszAppPoolName,
                    &securityAttributes,
                    AppPoolOptions
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateAppPool() failed, error %lu\n", result );
        goto cleanup;
    }


    result = HttpCreateConfigGroup(
                    controlChannel,
                    &configId
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateConfigGroup() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Add a URL to the configuration group.
    //

    result = HttpAddUrlToConfigGroup(
                    controlChannel,
                    configId,
                    wszUrl,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpAddUrlToConfigGroup(1) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Associate the configuration group with the application pool.
    //

    configAppPool.Flags.Present = 1;
    configAppPool.AppPoolHandle = appPool;

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupAppPoolInformation,
                    &configAppPool,
                    sizeof(configAppPool)
                    );
    
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(1) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set the config group state.
    //

    configState.Flags.Present = 1;
    configState.State = HttpEnabledStateActive;   // not really necessary

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupStateInformation,
                    &configState,
                    sizeof(configState)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(2) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set the Site ID on the Root Config Group object
    //

    configSite.SiteId = (ULONG) configId;

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupSiteInformation,
                    &configSite,
                    sizeof(configSite)
                    );
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(3) failed, error 0x%08X\n", result);
        // NOTE: continue on; site-id not essential.
    }

    //
    // Throw the big switch.
    //

    controlState = HttpEnabledStateActive;

    result = HttpSetControlChannelInformation(
                    controlChannel,
                    HttpControlChannelStateInformation,
                    &controlState,
                    sizeof(controlState)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetControlChannelInformation() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Success!
    //

    *pControlChannel = controlChannel;
    *pAppPool = appPool;
    *pConfigGroup = configId;

    return NO_ERROR;

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        ULONG result2;

        result2 = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result2 != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result2 );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return result;

}   // InitTransUlStuff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tqueue.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tqueue.c

Abstract:

    Stupid test server for UL.SYS.

Author:

    Michael Courage (mcourage)   10-Jan-2000

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    LONG queueLength;
    LONG  queueLengthOut;
    ULONG requiredLength;
    ULONG MaxBandwidth,MaxConnections;
    ULONG outMaxBandwidth,outMaxConnections;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // try setting an illegal queue length
    //
    queueLength = -3;
    result = HttpSetAppPoolInformation(
                    appPool,
                    HttpAppPoolQueueLengthInformation,
                    &queueLength,
                    sizeof(queueLength)
                    );

    if (result == NO_ERROR) {
        wprintf( L"HttpSetAppPoolInformation let us set a bad queue length!" );
        goto cleanup;
    }

    //
    // now set a small but good length
    //
    queueLength = 2;
    result = HttpSetAppPoolInformation(
                    appPool,
                    HttpAppPoolQueueLengthInformation,
                    &queueLength,
                    sizeof(queueLength)
                    );

    if (result != NO_ERROR) {
        wprintf( L"HttpSetAppPoolInformation failed!" );
        goto cleanup;
    }

    //
    // try to get this good value
    //
    
    result = HttpQueryAppPoolInformation(
                    appPool,
                    HttpAppPoolQueueLengthInformation,
                    &queueLengthOut,
                    sizeof(queueLengthOut),
                    &requiredLength
                    );

    if (result != NO_ERROR) 
    {
        wprintf( L"1 HttpQueryAppPoolInformation failed, error %lu\n", result );
        goto cleanup;
    }
    else 
    {
        if ( queueLengthOut != 2 ) 
            wprintf( L"2 HttpQueryAppPoolInformation returned wrong value." );
    }

    result = HttpQueryAppPoolInformation(
                    appPool,
                    HttpAppPoolQueueLengthInformation,
                    NULL,
                    0,
                    &requiredLength
                    );

    if (result != NO_ERROR) 
    {
        wprintf( L"3 HttpQueryAppPoolInformation() failed, error %lu\n", result );
        goto cleanup;
    }
    else 
    {
        if ( requiredLength != sizeof(LONG) ) 
        {
            wprintf( L"4 HttpQueryAppPoolInformation returned wrong length." );
            goto cleanup;
        }
    }
	
    //
    // Set 
    //
    MaxBandwidth   = 1024;
    MaxConnections = 100;
    
    result = HttpSetControlChannelInformation(
                    controlChannel,
                    HttpControlChannelBandwidthInformation,
                    &MaxBandwidth,
                    sizeof(MaxBandwidth)
                    );
    if (result != NO_ERROR) {
        wprintf( L"HttpSetControlChannelInformation - MaxBandwidth failed." );
        goto cleanup;
    }
    
    result = HttpSetControlChannelInformation(
                    controlChannel,
                    HttpControlChannelConnectionInformation,
                    &MaxConnections,
                    sizeof(MaxConnections)
                    );
    if (result != NO_ERROR) {
        wprintf( L"HttpSetControlChannelInformation - MaxConnections failed." );
        goto cleanup;
    }

    result = HttpQueryControlChannelInformation(
                    controlChannel,
                    HttpControlChannelBandwidthInformation,
                    &outMaxBandwidth,
                    sizeof(outMaxBandwidth),
                    &requiredLength
                    );
    if (result != NO_ERROR) {
        wprintf( L"HttpQueryControlChannelInformation - MaxBandwidth failed." );
        goto cleanup;
    }
    else
    {
        if ( outMaxBandwidth != MaxBandwidth )
            wprintf( L"HttpQueryControlChannelInformation - MaxBandwidth returned bad value" );
    }

    result = HttpQueryControlChannelInformation(
                    controlChannel,
                    HttpControlChannelConnectionInformation,
                    &outMaxConnections,
                    sizeof(outMaxConnections),
                    &requiredLength
                    );
    if (result != NO_ERROR) {
        wprintf( L"HttpQueryControlChannelInformation - MaxConnections failed." );
        goto cleanup;
    }
    else
    {
        if ( outMaxConnections != MaxConnections )
            wprintf( L"HttpQueryControlChannelInformation - MaxConnections returned bad value" );
    }
    

    //
    // just hang around so we can test the limit
    //

    Sleep(INFINITE);

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tsrv.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    tsrv.c

Abstract:

    Stupid test server for UL.SYS.

Author:

    Keith Moore (keithmo)        01-Jul-1998

Revision History:

--*/


#include "precomp.h"


UCHAR CannedResponseEntityBody[] =
    "<html><head><title>Error</title></head>"
    "<body>The system cannot find the file specified. </body></html>";

DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Get UL started.
    //

    result = InitUlStuff(
                    &controlChannel,
                    &appPool,
                    NULL,                   // FilterChannel
                    &configId,
                    TRUE,                   // AllowSystem
                    TRUE,                   // AllowAdmin
                    FALSE,                  // AllowCurrentUser
                    FALSE,                  // AllowWorld
                    0,
                    FALSE,                  // EnableSsl
                    FALSE                   // EnableRawFilters
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitUlStuff() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Build our canned response.
    //

    INIT_RESPONSE( &response, 404, "Object Not Found" );
    INIT_HEADER( &response, HttpHeaderContentType, "text/html" );
    INIT_HEADER( &response, HttpHeaderContentLength, "102" );

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = CannedResponseEntityBody;
    dataChunk.FromMemory.BufferLength = sizeof(CannedResponseEntityBody) - 1;

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Send the canned response.
        //

        DEBUG_BREAK();
        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk,
        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        result = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\ulutil.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ulutil.c

Abstract:

    General utility functions shared by the various UL test apps.

Author:

    Keith Moore (keithmo)        19-Aug-1998

Revision History:

--*/


#include "precomp.h"


#define MAX_VERB_LENGTH     16
#define MAX_HEADER_LENGTH   256
#define MAX_URL_LENGTH      256

#define READ_STRING( localaddr, locallen, remoteaddr, remotelen )           \
    do                                                                      \
    {                                                                       \
        ULONG _len;                                                         \
        RtlZeroMemory( (localaddr), (locallen) );                           \
        _len = min( (locallen), (remotelen) + sizeof(WCHAR) );              \
        RtlCopyMemory(                                                      \
            (PVOID)(localaddr),                                             \
            (PVOID)(remoteaddr),                                            \
            _len                                                            \
            );                                                              \
    } while (FALSE)


typedef struct _HEADER_PAIR
{
    HTTP_HEADER_ID HeaderId;
    PSTR HeaderName;

} HEADER_PAIR, *PHEADER_PAIR;

#define MAKE_HEADER_PAIR( name )                                            \
    {                                                                       \
        HttpHeader ## name,                                                 \
        #name                                                               \
    }


HEADER_PAIR g_HeaderPairs[] =
    {
        MAKE_HEADER_PAIR( Accept ),
        MAKE_HEADER_PAIR( AcceptLanguage ),
        MAKE_HEADER_PAIR( AcceptEncoding ),
        MAKE_HEADER_PAIR( AcceptCharset ),
        MAKE_HEADER_PAIR( Authorization ),
        MAKE_HEADER_PAIR( Allow ),
        MAKE_HEADER_PAIR( Connection ),
        MAKE_HEADER_PAIR( CacheControl ),
        MAKE_HEADER_PAIR( Cookie ),
        MAKE_HEADER_PAIR( ContentLength ),
        MAKE_HEADER_PAIR( ContentType ),
        MAKE_HEADER_PAIR( ContentEncoding ),
        MAKE_HEADER_PAIR( ContentLanguage ),
        MAKE_HEADER_PAIR( ContentLocation ),
        MAKE_HEADER_PAIR( ContentMd5 ),
        MAKE_HEADER_PAIR( ContentRange ),
        MAKE_HEADER_PAIR( Date ),
        MAKE_HEADER_PAIR( Etag ),
        MAKE_HEADER_PAIR( Expect ),
        MAKE_HEADER_PAIR( Expires ),
        MAKE_HEADER_PAIR( From ),
        MAKE_HEADER_PAIR( Host ),
        MAKE_HEADER_PAIR( IfModifiedSince ),
        MAKE_HEADER_PAIR( IfNoneMatch ),
        MAKE_HEADER_PAIR( IfMatch ),
        MAKE_HEADER_PAIR( IfUnmodifiedSince ),
        MAKE_HEADER_PAIR( IfRange ),
        MAKE_HEADER_PAIR( LastModified ),
        MAKE_HEADER_PAIR( MaxForwards ),
        MAKE_HEADER_PAIR( Pragma ),
        MAKE_HEADER_PAIR( ProxyAuthorization ),
        MAKE_HEADER_PAIR( Referer ),
        MAKE_HEADER_PAIR( Range ),
        MAKE_HEADER_PAIR( Trailer ),
        MAKE_HEADER_PAIR( TransferEncoding ),
        MAKE_HEADER_PAIR( Te ),
        MAKE_HEADER_PAIR( Upgrade ),
        MAKE_HEADER_PAIR( UserAgent ),
        MAKE_HEADER_PAIR( Via ),
        MAKE_HEADER_PAIR( Warning )
    };

#define NUM_HEADER_PAIRS (sizeof(g_HeaderPairs) / sizeof(g_HeaderPairs[0]))


PSID g_pSystemSid;
PSID g_pAdminSid;
PSID g_pCurrentUserSid;
PSID g_pWorldSid;


PWSTR
IpAddrToString(
    IN ULONG IpAddress,
    IN PWSTR String
    )
{
    wsprintf(
        String,
        L"%u.%u.%u.%u",
        (IpAddress >> 24) & 0xFF,
        (IpAddress >> 16) & 0xFF,
        (IpAddress >>  8) & 0xFF,
        (IpAddress >>  0) & 0xFF
        );

    return String;

}   // IpAddrToString


BOOL
ParseCommandLine(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    INT i;
    PWSTR arg;

    //
    // Establish defaults.
    //

    g_Options.Verbose = FALSE;
    g_Options.EnableBreak = FALSE;

    //
    // Scan the arguments.
    //

    for (i = 1 ; i < argc ; i++)
    {
        arg = argv[i];

        if (!_wcsicmp(arg, L"Verbose"))
        {
            g_Options.Verbose = TRUE;
        }
        else if (!_wcsicmp(arg, L"EnableBreak"))
        {
            g_Options.EnableBreak = TRUE;
        }
        else
        {
            wprintf(
                L"invalid option %s\n"
                L"\n"
                L"valid options are:\n"
                L"\n"
                L"    Verbose - Enable verbose output\n"
                L"    EnableBreak - Enable debug breaks\n",
                arg
                );

            return FALSE;
        }
    }

    return TRUE;

}   // ParseCommandLine


ULONG
CommonInit(
    VOID
    )
{
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY worldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    HANDLE token;
    PTOKEN_USER pTokenInfo;
    ULONG length;
    ULONG err;
    BOOL status;

    //
    // Setup so we know how to cleanup on exit.
    //

    g_pSystemSid = NULL;
    g_pAdminSid = NULL;
    g_pCurrentUserSid = NULL;
    g_pWorldSid = NULL;
    pTokenInfo = NULL;

    //
    // Nuke stdio buffering.
    //

    setvbuf( stdin,  NULL, _IONBF, 0 );
    setvbuf( stdout, NULL, _IONBF, 0 );

    //
    // This makes it a bit easier to find this process in the
    // kernel debugger...
    //

    wprintf( L"PID = 0x%lx\n", GetCurrentProcessId() );

    //
    // Create the standard SIDs.
    //

    status = AllocateAndInitializeSid(
                    &ntAuthority,
                    1,
                    SECURITY_LOCAL_SYSTEM_RID,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &g_pSystemSid
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    status = AllocateAndInitializeSid(
                    &ntAuthority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &g_pAdminSid
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    status = AllocateAndInitializeSid(
                    &worldAuthority,
                    1,
                    SECURITY_WORLD_RID,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    0,
                    &g_pWorldSid
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    status = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_READ,
                    &token
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    GetTokenInformation(
        token,
        TokenUser,
        NULL,
        0,
        &length
        );

    pTokenInfo = ALLOC( length );

    if (pTokenInfo == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }

    status = GetTokenInformation(
                    token,
                    TokenUser,
                    pTokenInfo,
                    length,
                    &length
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    g_pCurrentUserSid = pTokenInfo->User.Sid;

    //
    // Success!
    //

    err = NO_ERROR;

cleanup:

    if (err != NO_ERROR)
    {
        if (g_pSystemSid != NULL)
        {
            FreeSid( g_pSystemSid );
            g_pSystemSid = NULL;
        }

        if (g_pAdminSid != NULL)
        {
            FreeSid( g_pAdminSid );
            g_pAdminSid = NULL;
        }

        if (g_pWorldSid != NULL)
        {
            FreeSid( g_pWorldSid );
            g_pWorldSid = NULL;
        }

        if (pTokenInfo != NULL)
        {
            FREE( pTokenInfo );
        }
    }

    return err;

}   // CommonInit


ULONG
InitUlStuff(
    OUT PHANDLE pControlChannel,
    OUT PHANDLE pAppPool,
    OUT PHANDLE pFilterChannel,
    OUT PHTTP_CONFIG_GROUP_ID pConfigGroup,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld,
    IN ULONG AppPoolOptions,
    IN BOOL EnableSsl,
    IN BOOL EnableRawFilters
    )
{
    ULONG result;
    HANDLE controlChannel;
    HANDLE appPool;
    HANDLE filterChannel;
    HTTP_CONFIG_GROUP_ID configId;
    HTTP_CONFIG_GROUP_APP_POOL configAppPool;
    HTTP_CONFIG_GROUP_STATE configState;
    HTTP_ENABLED_STATE controlState;
    HTTP_CONFIG_GROUP_SITE configSite;
    BOOL initDone;
    SECURITY_ATTRIBUTES securityAttributes;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    controlChannel = NULL;
    appPool = NULL;
    filterChannel = NULL;
    HTTP_SET_NULL_ID( &configId );

    //
    // Initialize the security attributes.
    //

    result = InitSecurityAttributes(
                    &securityAttributes,
                    AllowSystem,
                    AllowAdmin,
                    AllowCurrentUser,
                    AllowWorld
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"InitSecurityAttributes() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Initialize the UL interface.
    //

    result = HttpInitialize( 0 );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpInitialize() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Open a control channel to the driver.
    //

    result = HttpOpenControlChannel(
                    &controlChannel,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpOpenControlChannel() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Create a filter channel.
    //
    if (EnableSsl || EnableRawFilters)
    {
        HTTP_CONTROL_CHANNEL_FILTER controlFilter;
    
        //
        // Create the filter.
        //
        result = HttpCreateFilter(
                        &filterChannel,         // filter handle
                        L"TestFilter",          // filter name
                        NULL,                   // security attributes
                        HTTP_OPTION_OVERLAPPED  // options
                        );

        if (result == NO_ERROR)
        {
            //
            // Attach the filter to the control channel.
            //
            RtlZeroMemory(&controlFilter, sizeof(controlFilter));
            
            controlFilter.Flags.Present = 1;
            controlFilter.FilterHandle = filterChannel;
            controlFilter.FilterOnlySsl = !EnableRawFilters;
            
            result = HttpSetControlChannelInformation(
                            controlChannel,
                            HttpControlChannelFilterInformation,
                            &controlFilter,
                            sizeof(controlFilter)
                            );

            if (result != NO_ERROR)
            {
                CloseHandle(filterChannel);
                filterChannel = NULL;
            }
        }
                        
    }

    //
    // Create an application pool.
    //

    result = HttpCreateAppPool(
                    &appPool,
                    APP_POOL_NAME,
                    &securityAttributes,
                    AppPoolOptions
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateAppPool() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Create a configuration group.
    //

    result = HttpCreateConfigGroup(
                    controlChannel,
                    &configId
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateConfigGroup() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Add a URL to the configuration group.
    //

    result = HttpAddUrlToConfigGroup(
                    controlChannel,
                    configId,
                    URL_NAME,
                    0
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpAddUrlToConfigGroup(1) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Add a secure URL to the configuration group.
    //
    if (EnableSsl)
    {
        result = HttpAddUrlToConfigGroup(
                        controlChannel,
                        configId,
                        SECURE_URL_NAME,
                        1
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpAddUrlToConfigGroup(2) failed, error %lu\n", result );
            goto cleanup;
        }
    }

    //
    // Associate the configuration group with the application pool.
    //

    configAppPool.Flags.Present = 1;
    configAppPool.AppPoolHandle = appPool;

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupAppPoolInformation,
                    &configAppPool,
                    sizeof(configAppPool)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(1) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set the config group state.
    //

    configState.Flags.Present = 1;
    configState.State = HttpEnabledStateActive;   // not really necessary

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupStateInformation,
                    &configState,
                    sizeof(configState)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(2) failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Set the Site ID on the Root Config Group object
    //

    configSite.SiteId = (ULONG) configId;

    result = HttpSetConfigGroupInformation(
                    controlChannel,
                    configId,
                    HttpConfigGroupSiteInformation,
                    &configSite,
                    sizeof(configSite)
                    );
    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetConfigGroupInformation(3) failed, error 0x%08X\n", result);
        // NOTE: continue on; site-id not essential.
    }

    //
    // Throw the big switch.
    //

    controlState = HttpEnabledStateActive;

    result = HttpSetControlChannelInformation(
                    controlChannel,
                    HttpControlChannelStateInformation,
                    &controlState,
                    sizeof(controlState)
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpSetControlChannelInformation() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Success!
    //

    *pControlChannel = controlChannel;
    *pAppPool = appPool;
    if (EnableSsl || EnableRawFilters)
    {
        *pFilterChannel = filterChannel;
    }
    *pConfigGroup = configId;

    return NO_ERROR;

cleanup:

    if (!HTTP_IS_NULL_ID( &configId ))
    {
        ULONG result2;

        result2 = HttpDeleteConfigGroup(
                        controlChannel,
                        configId
                        );

        if (result2 != NO_ERROR)
        {
            wprintf( L"HttpDeleteConfigGroup() failed, error %lu\n", result2 );
        }
    }

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }

    if (controlChannel != NULL)
    {
        CloseHandle( controlChannel );
    }

    if (initDone)
    {
        HttpTerminate();
    }

    return result;

}   // InitUlStuff


VOID
DumpHttpRequest(
    IN PHTTP_REQUEST pRequest
    )
{
    PCHAR pBuffer;
    ULONG BufferLength;

    pBuffer = NULL;
    BufferLength = 0;

    for (;;)
    {
        if (pBuffer != NULL)
        {
            FREE( pBuffer );
        }

        BufferLength += 1024;
        pBuffer = ALLOC( BufferLength );

        if (pBuffer == NULL)
        {
            wprintf( L"out of memory\n" );
            return;
        }

        if (RenderHttpRequest( pRequest, pBuffer, BufferLength ))
        {
            break;
        }
    }

    wprintf( L"%hs\n", pBuffer );
    FREE( pBuffer );

}   // DumpHttpRequest


PSTR
VerbToString(
    IN HTTP_VERB Verb
    )
{
    PSTR result;

    switch (Verb)
    {
    case HttpVerbUnparsed:
        result = "UnparsedVerb";
        break;

    case HttpVerbGET:
        result = "GET";
        break;

    case HttpVerbPUT:
        result = "PUT";
        break;

    case HttpVerbHEAD:
        result = "HEAD";
        break;

    case HttpVerbPOST:
        result = "POST";
        break;

    case HttpVerbDELETE:
        result = "DELETE";
        break;

    case HttpVerbTRACE:
        result = "TRACE";
        break;

    case HttpVerbOPTIONS:
        result = "OPTIONS";
        break;

    case HttpVerbMOVE:
        result = "MOVE";
        break;

    case HttpVerbCOPY:
        result = "COPY";
        break;

    case HttpVerbPROPFIND:
        result = "PROPFIND";
        break;

    case HttpVerbPROPPATCH:
        result = "PROPPATCH";
        break;

    case HttpVerbMKCOL:
        result = "MKCOL";
        break;

    case HttpVerbLOCK:
        result = "LOCK";
        break;

    case HttpVerbUnknown:
        result = "UnknownVerb";
        break;

    case HttpVerbInvalid:
        result = "InvalidVerb";
        break;

    default:
        result = "INVALID";
        break;
    }

    return result;

}   // VerbToString


PSTR
VersionToString(
    IN HTTP_VERSION Version
    )
{
    PSTR result;

    if (HTTP_EQUAL_VERSION(Version, 0, 0))
    {
        result = "Unknown";
    }
    else
    if (HTTP_EQUAL_VERSION(Version, 0, 9))
    {
        result = "HTTP/0.9";
    }
    else
    if (HTTP_EQUAL_VERSION(Version, 1, 0))
    {
        result = "HTTP/1.0";
    }
    else
    if (HTTP_EQUAL_VERSION(Version, 1, 1))
    {
        result = "HTTP/1.1";
    }
    else
    {
        result = "INVALID";
    }

    return result;

}   // VersionToString


PSTR
HeaderIdToString(
    IN HTTP_HEADER_ID HeaderId
    )
{
    INT i;
    PSTR result;

    result = "INVALID";

    for (i = 0 ; i < NUM_HEADER_PAIRS ; i++)
    {
        if (g_HeaderPairs[i].HeaderId == HeaderId)
        {
            result = g_HeaderPairs[i].HeaderName;
            break;
        }
    }

    return result;

}   // HeaderIdToString


ULONG
InitSecurityAttributes(
    OUT PSECURITY_ATTRIBUTES pSecurityAttributes,
    IN BOOL AllowSystem,
    IN BOOL AllowAdmin,
    IN BOOL AllowCurrentUser,
    IN BOOL AllowWorld
    )
{
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    PSECURITY_DESCRIPTOR pSecurityDescriptor;
    PACL pDacl;
    ULONG daclSize;
    ULONG err;
    BOOL status;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    pSecurityDescriptor = NULL;
    pDacl = NULL;

    //
    // Initialize the easy parts.
    //

    ZeroMemory( pSecurityAttributes, sizeof(*pSecurityAttributes) );

    pSecurityAttributes->nLength = sizeof(*pSecurityAttributes);
    pSecurityAttributes->bInheritHandle = FALSE;
    pSecurityAttributes->lpSecurityDescriptor = NULL;

    //
    // Allocate and initialize the security descriptor.
    //

    pSecurityDescriptor = ALLOC( sizeof(SECURITY_DESCRIPTOR) );

    if (pSecurityDescriptor == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    status = InitializeSecurityDescriptor(
                    pSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Allocate the DACL containing one access-allowed ACE for each
    // SID requested.
    //

    daclSize = sizeof(ACL);

    if (AllowSystem)
    {
        daclSize +=
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( g_pSystemSid );
    }

    if (AllowAdmin)
    {
        daclSize +=
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( g_pAdminSid );
    }

    if (AllowCurrentUser)
    {
        daclSize +=
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( g_pCurrentUserSid );
    }

    if (AllowWorld)
    {
        daclSize +=
            sizeof(ACCESS_ALLOWED_ACE) + GetLengthSid( g_pWorldSid );
    }

    pDacl = ALLOC( daclSize );

    if (pDacl == NULL)
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    status = InitializeAcl(
                    pDacl,
                    daclSize,
                    ACL_REVISION
                    );

    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Add the ACEs.
    //

    if (AllowSystem)
    {
        status = AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        FILE_ALL_ACCESS,
                        g_pSystemSid
                        );

        if (!status)
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    if (AllowAdmin)
    {
        status = AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        FILE_ALL_ACCESS,
                        g_pAdminSid
                        );

        if (!status)
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    if (AllowCurrentUser)
    {
        status = AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        FILE_ALL_ACCESS,
                        g_pCurrentUserSid
                        );

        if (!status)
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    if (AllowWorld)
    {
        status = AddAccessAllowedAce(
                        pDacl,
                        ACL_REVISION,
                        FILE_ALL_ACCESS,
                        g_pWorldSid
                        );

        if (!status)
        {
            err = GetLastError();
            goto cleanup;
        }
    }

    //
    // Set the DACL into the security descriptor.
    //

    status = SetSecurityDescriptorDacl(
                    pSecurityDescriptor,
                    TRUE,
                    pDacl,
                    FALSE
                    );
    if (!status)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Attach the security descriptor to the security attributes.
    //

    pSecurityAttributes->lpSecurityDescriptor = pSecurityDescriptor;

    //
    // Success!
    //

    err = NO_ERROR;

cleanup:

    if (err != NO_ERROR)
    {
        if (pDacl != NULL)
        {
            FREE( pDacl );
        }

        if (pSecurityDescriptor != NULL)
        {
            FREE( pSecurityDescriptor );
        }
    }

    return err;

}   // InitSecurityAttributes

BOOLEAN
RenderHttpRequest(
    IN PHTTP_REQUEST pRequest,
    OUT PCHAR pBuffer,
    IN ULONG BufferLength
    )
{
    PHTTP_KNOWN_HEADER pKnownHeader;
    PHTTP_UNKNOWN_HEADER pUnknownHeader;
    PHTTP_NETWORK_ADDRESS_IPV4 pNetAddr;
    ULONG i;
    INT len;
    CHAR verbBuffer[MAX_VERB_LENGTH];
    CHAR headerBuffer[MAX_HEADER_LENGTH];
    CHAR headerNameBuffer[MAX_HEADER_LENGTH];
    WCHAR urlBuffer[MAX_URL_LENGTH];
    CHAR rawUrlBuffer[MAX_URL_LENGTH];
    WCHAR ipAddrBuffer[sizeof("123.123.123.123")];

    if (pBuffer == NULL || BufferLength == 0)
    {
        return FALSE;
    }

    //
    // Read the raw verb, raw url, and url buffers.
    //

    if (pRequest->Verb == HttpVerbUnknown)
    {
        READ_STRING(
            verbBuffer,
            sizeof(verbBuffer),
            pRequest->pUnknownVerb,
            pRequest->UnknownVerbLength
            );
    }
    else
    {
        verbBuffer[0] = '\0';
    }

    READ_STRING(
        rawUrlBuffer,
        sizeof(rawUrlBuffer),
        pRequest->pRawUrl,
        pRequest->RawUrlLength
        );

    READ_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        pRequest->CookedUrl.pFullUrl,
        pRequest->CookedUrl.FullUrlLength
        );

    //
    // Render the header.
    //

    len = _snprintf(
                pBuffer,
                BufferLength,
                "HTTP_REQUEST:\n"
                "    ConnectionId                   = %016I64x\n"
                "    RequestId                      = %016I64x\n"
                "    UrlContext                     = %016I64x\n"
                "    Version                        = %s\n"
                "    Verb                           = %s\n",
                pRequest->ConnectionId,
                pRequest->RequestId,
                pRequest->UrlContext,
                VersionToString( pRequest->Version ),
                VerbToString( pRequest->Verb )
                );

    if (len < 0)
    {
        return FALSE;
    }

    BufferLength -= (ULONG)len;
    pBuffer += len;

    len = _snprintf(
                pBuffer,
                BufferLength,
                "    UnknownVerbLength              = %lu\n"
                "    pUnknownVerb                   = %p (%ws)\n"
                "    RawUrlLength                   = %lu\n"
                "    pRawUrl                        = %p (%ws)\n"
                "    FullUrlLength                  = %lu\n"
                "    pFullUrl                       = %p (%ws)\n",
                pRequest->UnknownVerbLength,
                pRequest->pUnknownVerb,
                verbBuffer,
                pRequest->RawUrlLength,
                pRequest->pRawUrl,
                rawUrlBuffer,
                pRequest->CookedUrl.FullUrlLength,
                pRequest->CookedUrl.pFullUrl,
                urlBuffer
                );

    if (len < 0)
    {
        return FALSE;
    }

    BufferLength -= (ULONG)len;
    pBuffer += len;

    len = _snprintf(
                pBuffer,
                BufferLength,
                "    Headers.UnknownHeaderCount     = %lu\n"
                "    Headers.pUnknownHeaders        = %p\n"
                "    EntityBodyLength               = %lu\n"
                "    pEntityBody                    = %p\n",
                pRequest->Headers.UnknownHeaderCount,
                pRequest->Headers.pUnknownHeaders,
                (pRequest->pEntityChunks ? pRequest->pEntityChunks[0].FromMemory.BufferLength : 0),
                (pRequest->pEntityChunks ? pRequest->pEntityChunks[0].FromMemory.pBuffer : 0)
                );

    if (len < 0)
    {
        return FALSE;
    }

    BufferLength -= (ULONG)len;
    pBuffer += len;

    pNetAddr = pRequest->Address.pRemoteAddress;

    len = _snprintf(
                pBuffer,
                BufferLength,
                "    RemoteAddressLength            = %u\n"
                "    RemoteAddressType              = %u\n"
                "    pRemoteAddress                 = %p (%ws:%u)\n",
                pRequest->Address.RemoteAddressLength,
                pRequest->Address.RemoteAddressType,
                pRequest->Address.pRemoteAddress,
                IpAddrToString( pNetAddr->IpAddress, ipAddrBuffer ),
                pNetAddr->Port
                );

    if (len < 0)
    {
        return FALSE;
    }

    BufferLength -= (ULONG)len;
    pBuffer += len;

    pNetAddr = pRequest->Address.pLocalAddress;

    len = _snprintf(
                pBuffer,
                BufferLength,
                "    LocalAddressLength             = %u\n"
                "    LocalAddressType               = %u\n"
                "    pLocalAddress                  = %p (%ws:%u)\n",
                pRequest->Address.LocalAddressLength,
                pRequest->Address.LocalAddressType,
                pRequest->Address.pLocalAddress,
                IpAddrToString( pNetAddr->IpAddress, ipAddrBuffer ),
                pNetAddr->Port
                );

    if (len < 0)
    {
        return FALSE;
    }

    BufferLength -= (ULONG)len;
    pBuffer += len;

    //
    // Render the known headers.
    //

    pKnownHeader = pRequest->Headers.pKnownHeaders;

    for (i = 0 ; i < HttpHeaderRequestMaximum ; i++)
    {
        if (pKnownHeader->pRawValue != NULL)
        {
            READ_STRING(
                headerBuffer,
                sizeof(headerBuffer),
                pKnownHeader->pRawValue,
                pKnownHeader->RawValueLength
                );

            len = _snprintf(
                        pBuffer,
                        BufferLength,
                        "    HTTP_HEADER[%lu]:\n"
                        "        HeaderId           = %s\n"
                        "        RawValueLength     = %lu\n"
                        "        pRawValue          = %p (%s)\n",
                        i,
                        HeaderIdToString( (HTTP_HEADER_ID)i ),
                        pKnownHeader->RawValueLength,
                        pKnownHeader->pRawValue,
                        headerBuffer
                        );
            if (len < 0)
            {
                return FALSE;
            }

            BufferLength -= (ULONG)len;
            pBuffer += len;
        }

        pKnownHeader++;
    }

    //
    // Render the unknown headers.
    //

    pUnknownHeader = pRequest->Headers.pUnknownHeaders;

    for (i = 0 ; i < pRequest->Headers.UnknownHeaderCount ; i++)
    {
        READ_STRING(
            headerNameBuffer,
            sizeof(headerNameBuffer),
            pUnknownHeader->pName,
            pUnknownHeader->NameLength
            );

        READ_STRING(
            headerBuffer,
            sizeof(headerBuffer),
            pUnknownHeader->pRawValue,
            pUnknownHeader->RawValueLength
            );

        len = _snprintf(
                    pBuffer,
                    BufferLength,
                    "    HTTP_UNKNOWN_HEADER[%lu]:\n"
                    "        NameLength             = %lu\n"
                    "        NameOffset             = %p (%s)\n"
                    "        ValueLength            = %lu\n"
                    "        ValueOffset            = %p (%s)\n",
                    i,
                    pUnknownHeader->NameLength,
                    pUnknownHeader->pName,
                    headerNameBuffer,
                    pUnknownHeader->RawValueLength,
                    pUnknownHeader->pRawValue,
                    headerBuffer
                    );

        if (len < 0)
        {
            return FALSE;
        }

        BufferLength -= (ULONG)len;
        pBuffer += len;

        pUnknownHeader++;
    }

    return TRUE;

}   // RenderHttpRequest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\apool.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    apool.c

Abstract:

    Dumps Application Pool structures.

Author:

    Michael Courage (mcourage) 21-Oct-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private prototypes.
//


//
// Public functions.
//



DECLARE_API( apool )

/*++

Routine Description:

    Dumps a UL_APP_POOL_OBJECT structure.

Arguments:

    Address of structure

Return Value:

    None.

--*/
{
    ULONG_PTR address = 0;
    CHAR  star = 0;
    ULONG result;
    UL_APP_POOL_OBJECT apoolobj;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        sscanf( args, "%c", &star );

        if (star == '*') {
            DumpAllApoolObjs();
        } else {
            PrintUsage( "apool" );
        }
        return;
    }

    //
    // Read the request header.
    //

    if (!ReadMemory(
            address,
            &apoolobj,
            sizeof(apoolobj),
            &result
            ))
    {
        dprintf(
            "apool: cannot read UL_APP_POOL_OBJECT @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpApoolObj(
        "",
        "apool: ",
        address,
        &apoolobj
        );

}   // apool


DECLARE_API( proc )

/*++

Routine Description:

    Dumps a UL_APP_POOL_PROCESS structure.

Arguments:

    Address of structure

Return Value:

    None.

--*/
{
    ULONG_PTR address = 0;
    ULONG result;
    UL_APP_POOL_PROCESS apoolproc;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "proc" );
        return;
    }

    //
    // Read the request header.
    //

    if (!ReadMemory(
            address,
            &apoolproc,
            sizeof(apoolproc),
            &result
            ))
    {
        dprintf(
            "proc: cannot read UL_APP_POOL_PROCESS @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpApoolProc(
        "",
        "proc: ",
        address,
        &apoolproc
        );

}   // uri
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\tupfilt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    tupfilt.c

Abstract:

    Stupid filter test for UL.SYS.
    Converts all data to upper case. See tfilt.

Author:

    Michael Courage (mcourage)      21-Mar-2000

Revision History:

--*/


#include "precomp.h"


DEFINE_COMMON_GLOBALS();

//
// Private constants.
//
#define ACCEPT_INITIAL_DATA 1024
#define ACCEPT_INFO (sizeof(HTTP_RAW_CONNECTION_INFO) + 2 * sizeof(HTTP_NETWORK_ADDRESS_IPV4))
#define ACCEPT_BUFFER_SIZE (ACCEPT_INFO + ACCEPT_INITIAL_DATA)

//
// Private types.
//
typedef struct _FILTER_THREAD_PARAM
{
    HANDLE              FilterHandle;
    HTTP_CONNECTION_ID  ConnectionId;

} FILTER_THREAD_PARAM, *PFILTER_THREAD_PARAM;

//
// Private prototypes.
//
ULONG
ProcessConnection(
    IN HANDLE FilterChannel
    );

VOID
DumpConnectInfo(
    IN PHTTP_RAW_CONNECTION_INFO pConnInfo
    );

DWORD
WINAPI
ReadFilter(
    LPVOID Param
    );

DWORD
WINAPI
WriteFilter(
    LPVOID Param
    );

VOID
UpcaseBuffer(
    ULONG Length,
    PUCHAR pBuffer
    );
    

INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE filterChannel;
    BOOL initDone;

    //
    // Initialize.
    //

    result = CommonInit();

    if (result != NO_ERROR)
    {
        wprintf( L"CommonInit() failed, error %lu\n", result );
        return 1;
    }

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //
    initDone = FALSE;
    filterChannel = NULL;

    //
    // Open the filter channel.
    //
    result = HttpOpenFilter(
                    &filterChannel,         // FilterHandle
                    L"TestFilter",          // FilterName
                    HTTP_OPTION_OVERLAPPED  // Options
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpOpenFilter() failed, error %lu\n", result );
        goto cleanup;
    }

    initDone = TRUE;

    //
    // Filter data.
    //
    do
    {
        result = ProcessConnection(filterChannel);
        
    } while (result == NO_ERROR);

    wprintf( L"ProcessConnection() failed, error %lu\n", result );

cleanup:

    if (filterChannel != NULL)
    {
        CloseHandle(filterChannel);
    }

    return 0;
}


ULONG
ProcessConnection(
    IN HANDLE FilterChannel
    )
{
    PHTTP_RAW_CONNECTION_INFO pConnInfo;
    HTTP_FILTER_BUFFER FiltBuffer;
    BYTE buffer[ACCEPT_BUFFER_SIZE];
    ULONG result;
    ULONG bytesRead;
    FILTER_THREAD_PARAM param;
    HANDLE threadHandles[2];
    DWORD threadId;

    //
    // Get a connection from UL.
    //
    DEBUG_BREAK();
    result = HttpFilterAccept(
                    FilterChannel,
                    (PHTTP_RAW_CONNECTION_INFO) buffer,
                    sizeof(buffer),
                    &bytesRead,
                    NULL
                    );

    if (result != NO_ERROR)
    {
        wprintf(L"HttpFilterAccept() failed, error %lu\n", result );
        return result;
    }

    pConnInfo = (PHTTP_RAW_CONNECTION_INFO) buffer;

    if (TEST_OPTION(Verbose))
    {
        DumpConnectInfo(pConnInfo);
    }

    //
    // If there was initial data, filter it and pass it on to the app.
    //
    if (pConnInfo->InitialDataSize)
    {
        ULONG bytesWritten;
        PUCHAR pBuffer;
        ULONG BufferSize;
    
        UpcaseBuffer(pConnInfo->InitialDataSize, pConnInfo->pInitialData);

        //
        // Set up the filter buffer structure.
        //

        pBuffer = pConnInfo->pInitialData;
        BufferSize = pConnInfo->InitialDataSize;

        FiltBuffer.BufferType = HttpFilterBufferHttpStream;
        FiltBuffer.pBuffer = pBuffer;
        FiltBuffer.BufferSize = BufferSize;

        //
        // Pass on the data.
        //
        
        result = HttpFilterAppWrite(
                        FilterChannel,
                        pConnInfo->ConnectionId,
                        &FiltBuffer,
                        BufferSize,
                        &bytesWritten,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf(L"HttpFilterAppWrite() (initial) failed, error %lu\n", result);
        }
        else if (TEST_OPTION(Verbose))
        {
            wprintf(L"Wrote back %d bytes of initial data.\n", bytesWritten);
        }
    }

    //
    // Start up the read and write filters.
    //

    param.FilterHandle = FilterChannel;
    param.ConnectionId = pConnInfo->ConnectionId;

    //
    // Create two threads to handle the filtering.
    //
    threadHandles[0] = NULL;
    threadHandles[1] = NULL;

    threadHandles[0] = CreateThread(
                            NULL,               // security
                            0,                  // stack size
                            ReadFilter,         // start address
                            &param,             // param
                            0,                  // flags
                            &threadId           // id
                            );

    if (threadHandles[0])
    {
        threadHandles[1] = CreateThread(
                                NULL,           // security
                                0,              // stack size
                                WriteFilter,    // start address
                                &param,         // param
                                0,              // flags
                                &threadId       // id
                                );

        if (threadHandles[1])
        {
            //
            // Wait for the threads to exit.
            //
            WaitForMultipleObjects(
                2,                  // object count
                threadHandles,      // object array
                TRUE,               // wait for all
                INFINITE            // timeout
                );
         }
         else
         {
            result = GetLastError();
         }
    }
    else
    {
        result = GetLastError();
    }

    CloseHandle( threadHandles[0] );
    CloseHandle( threadHandles[1] );

    return result;
}

VOID
DumpConnectInfo(
    IN PHTTP_RAW_CONNECTION_INFO pConnInfo
    )
{
    WCHAR ipAddrBuffer[sizeof("123.123.123.123")];
    PHTTP_NETWORK_ADDRESS_IPV4 pIpAddress;

    wprintf(
        L"HTTP_RAW_CONNECTION_INFO @ %p\n"
        L"    ConnectionId          = %I64x\n"
        L"    RemoteAddressLength   = %lu\n"
        L"    RemoteAddressType     = %lu\n"
        L"    LocalAddressLength    = %lu\n"
        L"    LocalAddressType      = %lu\n"
        L"    pRemoteAddress        = %p\n"
        L"    pLocalAddress         = %p\n"
        L"    InitialDataSize       = %lu\n"
        L"    pInitialData          = %p\n\n",
        pConnInfo,
        pConnInfo->ConnectionId,
        (ULONG) pConnInfo->Address.RemoteAddressLength,
        (ULONG) pConnInfo->Address.RemoteAddressType,
        (ULONG) pConnInfo->Address.LocalAddressLength,
        (ULONG) pConnInfo->Address.LocalAddressType,
        pConnInfo->Address.pRemoteAddress,
        pConnInfo->Address.pLocalAddress,
        pConnInfo->InitialDataSize,
        pConnInfo->pInitialData
        );

    pIpAddress = pConnInfo->Address.pRemoteAddress;
    IpAddrToString(pIpAddress->IpAddress, ipAddrBuffer);
    wprintf(
        L"    Remote %s:%u\n",
        ipAddrBuffer,
        pIpAddress->Port
        );
        
    pIpAddress = pConnInfo->Address.pLocalAddress;
    IpAddrToString(pIpAddress->IpAddress, ipAddrBuffer);
    wprintf(
        L"    Local  %s:%u\n"
        L"\n",
        ipAddrBuffer,
        pIpAddress->Port
        );

    if (pConnInfo->InitialDataSize)
    {
        ULONG i;
        PUCHAR pData = pConnInfo->pInitialData;
        
        wprintf(L"Accepted %d bytes of initial data:\n", pConnInfo->InitialDataSize);

        for (i = 0; i < pConnInfo->InitialDataSize; i++)
        {
            printf("%c", pData[i]);
        }

        wprintf(L"[End of data]\n");
    }
}

DWORD
WINAPI
ReadFilter(
    LPVOID Param
    )
{
    PFILTER_THREAD_PARAM param = (PFILTER_THREAD_PARAM)Param;
    ULONG result = NO_ERROR;
    UCHAR buffer[256];
    ULONG bytesRead;
    PHTTP_FILTER_BUFFER pFiltBuffer;
    HTTP_FILTER_BUFFER WriteBuffer;

    //
    // Set up some buffer magic.
    //
    pFiltBuffer = (PHTTP_FILTER_BUFFER)buffer;

    WriteBuffer.BufferType = HttpFilterBufferHttpStream;
    WriteBuffer.pBuffer = buffer;

    //
    // Actually do the filtering.
    //

    for ( ; ; )
    {
        result = HttpFilterRawRead(
                        param->FilterHandle,
                        param->ConnectionId,
                        buffer,
                        sizeof(buffer) - 1,
                        &bytesRead,
                        NULL
                        );

         
        if (result == NO_ERROR)
        {
            if (TEST_OPTION(Verbose))
            {
                buffer[bytesRead] = '\0';

                wprintf(
                    L"HttpFilterRawRead read %d bytes:\n"
                    L"%S[End of data]\n",
                    bytesRead,
                    buffer
                    );

            }

            if (bytesRead)
            {
                ULONG bytesWritten;
            
                UpcaseBuffer(bytesRead, buffer);
                WriteBuffer.BufferSize = bytesRead;
                
                result = HttpFilterAppWrite(
                                param->FilterHandle,
                                param->ConnectionId,
                                &WriteBuffer,
                                WriteBuffer.BufferSize,
                                &bytesWritten,
                                NULL
                                );

                if (result != NO_ERROR)
                {
                    wprintf(L"HttpFilterAppWrite() failed, error %lu\n", result);
                }
                else if (TEST_OPTION(Verbose))
                {
                    wprintf(L"Wrote %d bytes of app data.\n", bytesWritten);
                }
            }

        }
        else
        {
            wprintf(L"HttpFilterRawRead() failed, error %lu\n", result );
            return result;
        }
    }
    
    return NO_ERROR;
}

DWORD
WINAPI
WriteFilter(
    LPVOID Param
    )
{
    PFILTER_THREAD_PARAM param = (PFILTER_THREAD_PARAM)Param;
    ULONG result = NO_ERROR;
    UCHAR buffer[256];
    ULONG bytesRead;
    HTTP_FILTER_BUFFER FiltDesc;
    PHTTP_FILTER_BUFFER pFiltBuffer;

    //
    // Set up some buffer magic.
    //
    pFiltBuffer = (PHTTP_FILTER_BUFFER)buffer;

    FiltDesc.pBuffer = buffer;
    FiltDesc.BufferSize = sizeof(buffer) - 1;

    //
    // Actually do the filtering.
    //
    
    for ( ; ; )
    {
        result = HttpFilterAppRead(
                        param->FilterHandle,
                        param->ConnectionId,
                        &FiltDesc,
                        FiltDesc.BufferSize,
                        &bytesRead,
                        NULL
                        );

         
        if (result == NO_ERROR)
        {
            if (TEST_OPTION(Verbose))
            {
                buffer[bytesRead] = '\0';

                wprintf(
                    L"HttpFilterAppRead(%p) read %d bytes starting at %p:\n"
                    L"%S[End of data]\n",
                    pFiltBuffer,
                    pFiltBuffer->BufferSize,
                    pFiltBuffer->pBuffer,
                    pFiltBuffer->pBuffer
                    );
            }

            if (pFiltBuffer->BufferSize)
            {
                ULONG bytesWritten;
            
                UpcaseBuffer(pFiltBuffer->BufferSize, pFiltBuffer->pBuffer);
                
                result = HttpFilterRawWrite(
                                param->FilterHandle,
                                param->ConnectionId,
                                pFiltBuffer->pBuffer,
                                pFiltBuffer->BufferSize,
                                &bytesWritten,
                                NULL
                                );

                if (result != NO_ERROR)
                {
                    wprintf(L"HttpFilterRawWrite() failed, error %lu\n", result);
                }
                else if (TEST_OPTION(Verbose))
                {
                    wprintf(L"Wrote %d bytes of raw data.\n", bytesWritten);
                }
            }
            
        }
        else
        {
            wprintf(L"HttpFilterAppRead() failed, error %lu\n", result );
            return result;
        }
    }

    return result;
}

VOID
UpcaseBuffer(
    ULONG Length,
    PUCHAR pBuffer
    )
{
    ULONG i;

    for (i = 0; i < Length; i++)
    {
        pBuffer[i] = (UCHAR)toupper(pBuffer[i]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\buff.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    buff.c

Abstract:

    Dumps UL_RECEIVE_BUFFER and UL_REQUEST_BUFFER structures.

Author:

    Keith Moore (keithmo) 01-Jul-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Public functions.
//

DECLARE_API( buff )

/*++

Routine Description:

    Dumps UL_RECEIVE_BUFFER structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_RECEIVE_BUFFER buffer;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "buff" );
        return;
    }

    //
    // Read the buffer.
    //

    if (!ReadMemory(
            address,
            &buffer,
            sizeof(buffer),
            &result
            ))
    {
        dprintf(
            "buff: cannot read UL_RECEIVE_BUFFER @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpReceiveBuffer(
        "",
        "buff: ",
        address,
        &buffer
        );

}   // buff


DECLARE_API( reqbuff )

/*++

Routine Description:

    Dumps UL_REQUEST_BUFFER structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_REQUEST_BUFFER buffer;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "reqbuff" );
        return;
    }

    //
    // Read the buffer.
    //

    if (!ReadMemory(
            address,
            &buffer,
            sizeof(buffer),
            &result
            ))
    {
        dprintf(
            "buff: cannot read UL_REQUEST_BUFFER @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpRequestBuffer(
        "",
        "reqbuff: ",
        address,
        &buffer
        );

}   // reqbuff
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\test\dll\ttrans.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ttrans.c

Abstract:

    Transient URL registration test. See also tcgsec.c.

Author:

    Michael Courage (mcourage)   15-Jan-2000

Revision History:

--*/


#include "precomp.h"


UCHAR CannedResponseEntityBody[] =
    "<html><head><title>Hello!</title></head>"
    "<body>This section of the namespace is owned by ttrans.</body></html>";

DEFINE_COMMON_GLOBALS();



INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    ULONG result;
    HANDLE appPool;
    HTTP_REQUEST_ID requestId;
    DWORD bytesRead;
    DWORD bytesSent;
    PHTTP_REQUEST request;
    HTTP_RESPONSE response;
    HTTP_DATA_CHUNK dataChunk;
    ULONG i;
    BOOL initDone;
    HTTP_REQUEST_ALIGNMENT UCHAR requestBuffer[REQUEST_LENGTH];

    //
    // Initialize.
    //

    if (!ParseCommandLine( argc, argv ))
    {
        return 1;
    }

    //
    // Setup locals so we know how to cleanup on exit.
    //

    initDone = FALSE;
    appPool = NULL;

    //
    // Get UL started.
    //

    result = HttpInitialize( 0 );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpInitialize() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Create an anonymous application pool
    //
    result = HttpCreateAppPool(
                    &appPool,   // pHandle
                    L"",        // name
                    NULL,       // security
                    0           // options
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpCreateAppPool() failed, error %lu\n", result );
        goto cleanup;
    }

    //
    // Attach a transient URL to the app pool
    //
    result = HttpAddTransientUrl(
                    appPool,
                    TRANS_URL_NAME L"ttrans/"
                    );

    if (result != NO_ERROR)
    {
        wprintf( L"HttpAddTransientUrl() failed, error %lu\n", result );
        goto cleanup;
    }                    

    initDone = TRUE;

    //
    // Build our canned response.
    //

    INIT_RESPONSE( &response, 200, "OK" );
    INIT_HEADER( &response, HttpHeaderContentType, "text/html" );
    INIT_HEADER( &response, HttpHeaderContentLength, "109" );

    dataChunk.DataChunkType = HttpDataChunkFromMemory;
    dataChunk.FromMemory.pBuffer = CannedResponseEntityBody;
    dataChunk.FromMemory.BufferLength = sizeof(CannedResponseEntityBody) - 1;

    //
    // Loop forever...
    //

    request = (PHTTP_REQUEST)requestBuffer;

    HTTP_SET_NULL_ID( &requestId );

    for( ; ; )
    {
        //
        // Wait for a request.
        //

        //DEBUG_BREAK();
        result = HttpReceiveHttpRequest(
                        appPool,
                        requestId,
                        0,
                        (PHTTP_REQUEST)requestBuffer,
                        sizeof(requestBuffer),
                        &bytesRead,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpReceiveHttpRequest() failed, error %lu\n", result );
            break;
        }

        //
        // Dump it.
        //

        if (TEST_OPTION(Verbose))
        {
            DumpHttpRequest( request );
        }

        //
        // Send the canned response.
        //

        DEBUG_BREAK();

        response.EntityChunkCount = 1;
        response.pEntityChunks = &dataChunk;

        result = HttpSendHttpResponse(
                        appPool,
                        request->RequestId,
                        0,
                        &response,
                        NULL,
                        &bytesSent,
                        NULL,
                        NULL
                        );

        if (result != NO_ERROR)
        {
            wprintf( L"HttpSendHttpResponse() failed, error %lu\n", result );
            break;
        }
    }

cleanup:

    if (appPool != NULL)
    {
        CloseHandle( appPool );
    }


    if (initDone)
    {
        HttpTerminate();
    }

    return 0;

}   // wmain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\cgroup.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    cgroup.c

Abstract:

    Dumps config group structures.

Author:

    Michael Courage (MCourage) 4-Nov-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Public functions.
//

DECLARE_API( cgentry )
/*++

Routine Description:

    Dumps UL_CG_URL_TREE_ENTRY structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_CG_URL_TREE_ENTRY entry;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "cgentry" );
        return;
    }

    //
    // Read the entry.
    //

    if (!ReadMemory(
            address,
            &entry,
            sizeof(entry),
            &result
            ))
    {
        dprintf(
            "cgentry: cannot read UL_CG_URL_TREE_ENTRY @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpCgroupEntry(
        "",
        "cgentry: ",
        address,
        &entry
        );

}   // cgentry


DECLARE_API( cghead )
/*++

Routine Description:

    Dumps UL_CG_HEADER_ENTRY structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_CG_HEADER_ENTRY header;
    UL_CG_URL_TREE_ENTRY entry;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "cghead" );
        return;
    }

    //
    // read the header
    //

    if (!ReadMemory(
            address,
            &header,
            sizeof(header),
            &result
            ))
    {
        dprintf(
            "cghead: cannot read UL_CG_HEADER_ENTRY @ %p\n",
            address
            );
        return;
    }


    //
    // Read the entry.
    //

    if (!ReadMemory(
            (ULONG_PTR)header.pEntry,
            &entry,
            sizeof(entry),
            &result
            ))
    {
        dprintf(
            "cghead: cannot read UL_CG_URL_TREE_ENTRY @ %p\n",
            address
            );
        return;
    }

    //
    // Dump 'em.
    //
    DumpCgroupHeader(
        "",
        "cghead: ",
        address,
        &header
        );

    DumpCgroupEntry(
        "    ",
        "cghead: ",
        (ULONG_PTR)header.pEntry,
        &entry
        );

}   // cghead


DECLARE_API( cgroup )
/*++

Routine Description:

    Dumps UL_CONFIG_GROUP_OBJECT structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_CONFIG_GROUP_OBJECT object;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "cgroup" );
        return;
    }

    //
    // Read the object.
    //

    if (!ReadMemory(
            address,
            &object,
            sizeof(object),
            &result
            ))
    {
        dprintf(
            "cgroup: cannot read UL_CONFIG_GROUP_OBJECT @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpConfigGroup(
        "",
        "cgroup: ",
        address,
        &object
        );

}   // cgroup


DECLARE_API( cgtree )
/*++

Routine Description:

    Dumps UL_CG_TREE_HEADER structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    ULONG i;
    UL_CG_URL_TREE_HEADER header;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        ULONG_PTR globaladdr;
        globaladdr = GetExpression("&http!g_pSites");
        if (globaladdr == 0) {
            dprintf("cgtree: couldn't evaluate &http!g_pSites\n");
            return;
        }

        if (!ReadMemory(
                globaladdr,
                &address,
                sizeof(address),
                &result
                ))
        {
            dprintf(
                "cgtree: couldn't read PUL_CG_URL_TREE_HEADER g_pSites @ %p\n",
                globaladdr
                );
        }
    }

    //
    // Read the object.
    //

    if (!ReadMemory(
            address,
            &header,
            sizeof(header),
            &result
            ))
    {
        dprintf(
            "cgtree: cannot read UL_CG_URL_TREE_HEADER @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpConfigTree(
        "",
        "cgtree: ",
        address,
        &header
        );

    for (i = 0; i < header.UsedCount; i++) {
        ULONG_PTR entryaddr;
        UL_CG_HEADER_ENTRY entry;

        entryaddr = (ULONG_PTR)REMOTE_OFFSET(address, UL_CG_URL_TREE_HEADER, pEntries);
        entryaddr += i * sizeof(entry);

        if (!ReadMemory(
                entryaddr,
                &entry,
                sizeof(entry),
                &result
                ))
        {
            dprintf(
                "cgtree: cannot read UL_CG_HEADER_ENTRY @ %p\n",
                entryaddr
                );
            break;
        }

        DumpCgroupHeader(
            "    ",
            "cgtree: ",
            entryaddr,
            &entry
            );
    }

}   // cgtree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\cons.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    cons.h

Abstract:

    Global constant definitions for the UL.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 17-Jun-1998.

Environment:

    User Mode.

--*/


#ifndef _CONS_H_
#define _CONS_H_

#ifdef __cplusplus
extern "C" {
#endif


#define DIM(x)  (sizeof(x) / sizeof(x[0]))


#define MAX_TRANSPORT_ADDRESS_LENGTH    128
#define MAX_SYMBOL_LENGTH               256
#define MAX_RESOURCE_STATE_LENGTH       80
#define MAX_SIGNATURE_LENGTH            20

#define Address00   Address[0].Address[0]
#define UC(x)       ((UINT)((x) & 0xFF))
#define NTOHS(x)    ( (UC(x) * 256) + UC((x) >> 8) )

#define IS_LIST_EMPTY( localaddr, remoteaddr, type, fieldname )             \
    ( ((type *)(localaddr))->fieldname.Flink ==                             \
        (PLIST_ENTRY)( (remoteaddr) +                                       \
              FIELD_OFFSET( type, fieldname ) ) )

#define REMOTE_OFFSET( remoteaddr, type, fieldname )                        \
    ( (PUCHAR)(remoteaddr) + FIELD_OFFSET( type, fieldname ) )

#define READ_REMOTE_STRING( localaddr, locallen, remoteaddr, remotelen )    \
    if( TRUE )                                                              \
    {                                                                       \
        ULONG _len;                                                         \
        ULONG _res;                                                         \
        RtlZeroMemory( (localaddr), (locallen) );                           \
        _len = min( (locallen), (remotelen) );                              \
        if (_len > 0)                                                       \
        {                                                                   \
            ReadMemory(                                                     \
                (ULONG_PTR)(remoteaddr),                                    \
                (PVOID)(localaddr),                                         \
                _len,                                                       \
                &_res                                                       \
                );                                                          \
        }                                                                   \
    } else

#ifdef _WIN64
// Hack: the Next and Depth fields are no longer accessible
// This definition allows us to compile and link. 
# define SLIST_HEADER_NEXT(psh)  ((PSINGLE_LIST_ENTRY) NULL)
# define SLIST_HEADER_DEPTH(psh) ((USHORT) -1)
#else // !_WIN64
# define SLIST_HEADER_NEXT(psh)  ((psh)->Next.Next)
# define SLIST_HEADER_DEPTH(psh) ((psh)->Depth)
#endif // !_WIN64

#define SNAPSHOT_EXTENSION_DATA()                                           \
    do                                                                      \
    {                                                                       \
        g_hCurrentProcess = hCurrentProcess;                                \
        g_hCurrentThread = hCurrentThread;                                  \
        g_dwCurrentPc = dwCurrentPc;                                        \
        g_dwProcessor = g_dwProcessor;                                      \
    } while (FALSE)


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _CONS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\ds.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    ds.c

Abstract:

    Dumps symbols found on the stack.

Author:

    Keith Moore (keithmo) 12-Nov-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


#define NUM_STACK_SYMBOLS_TO_DUMP   48


//
//  Public functions.
//

DECLARE_API( ds )

/*++

Routine Description:

    Dumps symbols found on the stack.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR startingAddress;
    ULONG_PTR stack;
    ULONG i;
    ULONG result;
    CHAR  symbol[MAX_SYMBOL_LENGTH];
    ULONG_PTR offset;
    PCHAR format;
    BOOLEAN validSymbolsOnly = FALSE;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Skip leading blanks.
    //

    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    if (*args == '-')
    {
        args++;

        switch (*args)
        {
        case 'v' :
        case 'V' :
            validSymbolsOnly = TRUE;
            args++;
            break;

        default :
            PrintUsage( "ds" );
            return;
        }
    }

    while (*args == ' ')
    {
        args++;
    }

    //
    // By default, start at the current stack location. Otherwise,
    // start at the given address.
    //

    if (!*args)
    {
#if defined(_X86_)
        args = "esp";
#elif defined(_AMD64_)
        args = "rsp";
#elif defined(_IA64_)
        args = "sp";
#else
#error "unsupported CPU"
#endif
    }

    startingAddress = GetExpression( args );

    if (startingAddress == 0)
    {
        dprintf( "!inetdbg.ds: cannot evaluate \"%s\"\n", args );
        return;
    }

    //
    // Ensure startingAddress is properly aligned.
    //

    startingAddress &= ~(sizeof(ULONG_PTR) - 1);

    //
    // Read the stack.
    //

    for (i = 0 ; i < NUM_STACK_SYMBOLS_TO_DUMP ; startingAddress += sizeof(ULONG_PTR) )
    {
        if (CheckControlC())
        {
            break;
        }

        if (!ReadMemory(
                startingAddress,
                &stack,
                sizeof(stack),
                &result
                ))
        {
            dprintf( "ds: cannot read memory @ %p\n", startingAddress );
            return;
        }

        GetSymbol( (PVOID)stack, symbol, &offset );

        if (symbol[0] == '\0')
        {
            if (validSymbolsOnly)
            {
                continue;
            }

            format = "%p : %p\n";
        }
        else if (offset == 0)
        {
            format = "%p : %p : %s\n";
        }
        else
        {
            format = "%p : %p : %s+0x%lx\n";
        }

        dprintf(
            format,
            startingAddress,
            stack,
            symbol,
            offset
            );

        i++;
    }

    dprintf(
        "!ulkd.ds %s%lx to dump next block\n",
        validSymbolsOnly ? "-v " : "",
        startingAddress
        );

}   // ds
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\dumpers.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    dumpers.c

Abstract:

    Dump routines for various structures.

Author:

    Keith Moore (keithmo) 31-Jul-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define MAX_NSGO_NAME_BUFFER    256
#define MAX_URL_PREFIX_BUFFER   256
#define MAX_RAW_VERB_BUFFER     16
#define MAX_RAW_URL_BUFFER      256
#define MAX_URL_BUFFER          256
#define MAX_HEADER_BUFFER       256
#define MAX_FILE_NAME_BUFFER    256


//
// Private prototypes.
//

BOOLEAN
DumpUnknownHeadersCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpUriEntryCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpApoolCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

#define ENDPOINT_GLOBAL_CALLBACK_CONTEXT_SIGNATURE ((ULONG) 'xGPE')

typedef struct _ENDPOINT_GLOBAL_CALLBACK_CONTEXT
{
    ULONG           Signature;
    PSTR            Prefix;
    ENDPOINT_CONNS  Verbosity;
} ENDPOINT_GLOBAL_CALLBACK_CONTEXT, *PENDPOINT_GLOBAL_CALLBACK_CONTEXT;

BOOLEAN
DumpEndpointCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
IrpListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
ProcListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
RequestListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpKQueueEntriesCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
FiltProcListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpUlActiveConnectionCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpUlIdleConnectionCallback(
    IN PSINGLE_LIST_ENTRY RemoteSListEntry,
    IN PVOID Context
    );

typedef struct _CONN_CALLBACK_CONTEXT
{
    ULONG           Signature;
    LONG            Index;
    LONG            SubIndex;
    ENDPOINT_CONNS  Verbosity;
    PSTR            Prefix;
} CONN_CALLBACK_CONTEXT, *PCONN_CALLBACK_CONTEXT;

#define CONN_CALLBACK_CONTEXT_SIGNATURE ((ULONG) 'xCcC')


//
// Private globals.
//

PSTR
g_RequestHeaderIDs[] =
    {
        "CacheControl",
        "Connection",
        "Date",
        "KeepAlive",
        "Pragma",
        "Trailer",
        "TransferEncoding",
        "Upgrade",
        "Via",
        "Warning",
        "Allow",
        "ContentLength",
        "ContentType",
        "ContentEncoding",
        "ContentLanguage",
        "ContentLocation",
        "ContentMd5",
        "ContentRange",
        "Expires",
        "LastModified",
        "Accept",
        "AcceptCharset",
        "AcceptEncoding",
        "AcceptLanguage",
        "Authorization",
        "Cookie",
        "Expect",
        "From",
        "Host",
        "IfMatch",
        "IfModifiedSince",
        "IfNoneMatch",
        "IfRange",
        "IfUnmodifiedSince",
        "MaxForwards",
        "ProxyAuthorization",
        "Referer",
        "Range",
        "Te",
        "UserAgent"
    };

PSTR
g_ResponseHeaderIDs[] =
    {
        "CacheControl",
        "Connection",
        "Date",
        "KeepAlive",
        "Pragma",
        "Trailer",
        "TransferEncoding",
        "Upgrade",
        "Via",
        "Warning",
        "Allow",
        "ContentLength",
        "ContentType",
        "ContentEncoding",
        "ContentLanguage",
        "ContentLocation",
        "ContentMd5",
        "ContentRange",
        "Expires",
        "LastModified",
        "AcceptRanges",
        "Age",
        "Etag",
        "Location",
        "ProxyAuthenticate",
        "RetryAfter",
        "Server",
        "SetCookie",
        "Vary",
        "WwwAuthenticate"
    };

VECTORMAP
g_MdlFlagVector[] =
    {
        VECTORMAP_ENTRY( MDL_MAPPED_TO_SYSTEM_VA ),
        VECTORMAP_ENTRY( MDL_PAGES_LOCKED ),
        VECTORMAP_ENTRY( MDL_SOURCE_IS_NONPAGED_POOL),
        VECTORMAP_ENTRY( MDL_ALLOCATED_FIXED_SIZE ),
        VECTORMAP_ENTRY( MDL_PARTIAL ),
        VECTORMAP_ENTRY( MDL_PARTIAL_HAS_BEEN_MAPPED),
        VECTORMAP_ENTRY( MDL_IO_PAGE_READ ),
        VECTORMAP_ENTRY( MDL_WRITE_OPERATION ),
        VECTORMAP_ENTRY( MDL_PARENT_MAPPED_SYSTEM_VA),
        VECTORMAP_ENTRY( MDL_LOCK_HELD ),
        VECTORMAP_ENTRY( MDL_PHYSICAL_VIEW ),
        VECTORMAP_ENTRY( MDL_IO_SPACE ),
        VECTORMAP_ENTRY( MDL_NETWORK_HEADER ),
        VECTORMAP_ENTRY( MDL_MAPPING_CAN_FAIL ),
        VECTORMAP_ENTRY( MDL_ALLOCATED_MUST_SUCCEED ),
        VECTORMAP_END
    };


//
// Public functions.
//

// If you modify DumpUlConnection, you may need to modify DumpUlConnectionLite

VOID
DumpUlConnection(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONNECTION LocalConnection
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];
    
    //
    // Dump it.
    //

    dprintf(
        "%s%sUL_CONNECTION @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    ReferenceCount                 = %lu\n"
        "%s    ConnectionFlags                = %08lx\n"
        "%s        AcceptPending              = %ld\n"
        "%s        AcceptComplete             = %ld\n"
        "%s        DisconnectPending          = %ld\n"
        "%s        DisconnectComplete         = %ld\n"
        "%s        AbortPending               = %ld\n"
        "%s        AbortComplete              = %ld\n"
        "%s        DisconnectIndicated        = %ld\n"
        "%s        AbortIndicated             = %ld\n"
        "%s        CleanupBegun               = %ld\n"
        "%s        FinalReferenceRemoved      = %ld\n"
#if REFERENCE_DEBUG
        "%s    pTraceLog                      = %p\n"
#endif // REFERENCE_DEBUG
        "%s    IdleSListEntry                 @ %p (%p)\n"
        "%s    ActiveListEntry                @ %p (%p)\n"
        "%s    ConnectionObject               @ %p\n"
        "%s        Handle                     = %p\n"
        "%s        pFileObject                = %p\n"
        "%s        pDeviceObject              = %p\n"
        "%s    pConnectionContext             = %p\n"
        "%s    pOwningEndpoint                = %p\n"
        "%s    WorkItem                       @ %p\n"
        "%s    LocalAddress                   = %x\n"   // IPv6
        "%s    LocalPort                      = %d\n"
        "%s    RemoteAddress                  = %x\n"   // IPv6
        "%s    RemotePort                     = %d\n"
        "%s    ConnectionId                   = %I64x\n"
        "%s    pFilterChannel                 = %p\n"
        "%s    ChannelEntry                   @ %p\n"
        "%s    FilterConnState                = %ld\n"
        "%s    ConnectionDelivered            = %ld\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalConnection->Signature,
        SignatureToString(
            LocalConnection->Signature,
            UL_CONNECTION_SIGNATURE,
            UL_CONNECTION_SIGNATURE_X,
            strSignature
            ),
        Prefix,
        LocalConnection->ReferenceCount,
        Prefix,
        LocalConnection->ConnectionFlags.Value,
        Prefix,
        LocalConnection->ConnectionFlags.AcceptPending,
        Prefix,
        LocalConnection->ConnectionFlags.AcceptComplete,
        Prefix,
        LocalConnection->ConnectionFlags.DisconnectPending,
        Prefix,
        LocalConnection->ConnectionFlags.DisconnectComplete,
        Prefix,
        LocalConnection->ConnectionFlags.AbortPending,
        Prefix,
        LocalConnection->ConnectionFlags.AbortComplete,
        Prefix,
        LocalConnection->ConnectionFlags.DisconnectIndicated,
        Prefix,
        LocalConnection->ConnectionFlags.AbortIndicated,
        Prefix,
        LocalConnection->ConnectionFlags.CleanupBegun,
        Prefix,
        LocalConnection->ConnectionFlags.FinalReferenceRemoved,
#if REFERENCE_DEBUG
        Prefix,
        LocalConnection->pTraceLog,
#endif // REFERENCE_DEBUG
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, IdleSListEntry ),
        LocalConnection->IdleSListEntry.Next,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, ActiveListEntry ),
        LocalConnection->ActiveListEntry.Flink,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, ConnectionObject ),
        Prefix,
        LocalConnection->ConnectionObject.Handle,
        Prefix,
        LocalConnection->ConnectionObject.pFileObject,
        Prefix,
        LocalConnection->ConnectionObject.pDeviceObject,
        Prefix,
        LocalConnection->pConnectionContext,
        Prefix,
        LocalConnection->pOwningEndpoint,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, WorkItem ),
        Prefix,
        LocalConnection->LocalAddress,
        Prefix,
        LocalConnection->LocalPort,
        Prefix,
        LocalConnection->RemoteAddress,
        Prefix,
        LocalConnection->RemotePort,
        Prefix,
        LocalConnection->FilterInfo.ConnectionId,
        Prefix,
        LocalConnection->FilterInfo.pFilterChannel,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, FilterInfo.ChannelEntry ),
        Prefix,
        (int) LocalConnection->FilterInfo.ConnState,
        Prefix,
        LocalConnection->FilterInfo.ConnectionDelivered
        );
}   // DumpUlConnection


VOID
DumpUlConnectionLite(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONNECTION LocalConnection
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];
    
    //
    // Dump it.
    //

    dprintf(
        "%s%sUL_CONNECTION @ %p\n",
        Prefix,
        CommandName,
        RemoteAddress
        );
    
    if (LocalConnection->Signature != UL_CONNECTION_SIGNATURE)
    {
        dprintf(
            "%s    Signature                      = %08lx (%s)\n",
            Prefix,
            LocalConnection->Signature,
            SignatureToString(
                LocalConnection->Signature,
                UL_CONNECTION_SIGNATURE,
                UL_CONNECTION_SIGNATURE_X,
                strSignature
                )
            );
    }
    
    dprintf(
        "%s    ReferenceCount                 = %lu\n"
        "%s    ConnectionFlags                = %08lx\n",
        Prefix,
        LocalConnection->ReferenceCount,
        Prefix,
        LocalConnection->ConnectionFlags.Value
        );

    if (! HTTP_IS_NULL_ID(&LocalConnection->FilterInfo.ConnectionId))
    {
        dprintf(
            "%s    ConnectionId                   = %I64x\n",
            Prefix,
            LocalConnection->FilterInfo.ConnectionId
            );
    }
    
    if (LocalConnection->ActiveListEntry.Flink != NULL)
    {
        dprintf(
            "%s    ActiveListEntry                @ %p (%p)\n",
            Prefix,
            REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, ActiveListEntry ),
            LocalConnection->ActiveListEntry.Flink
            );
    }
    else
    {
        dprintf(
            "%s    IdleSListEntry                 @ %p (%p)\n",
            Prefix,
            REMOTE_OFFSET( RemoteAddress, UL_CONNECTION, IdleSListEntry ),
            LocalConnection->IdleSListEntry.Next
            );
    }

}   // DumpUlConnectionLite

VOID
DumpHttpConnection(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_CONNECTION LocalConnection
    )
{
    CHAR resourceState[MAX_RESOURCE_STATE_LENGTH];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    //
    // Dump the easy parts.
    //

    dprintf(
        "%s%sUL_HTTP_CONNECTION @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    ConnectionId                   = %I64x\n"
        "%s    WorkItem                       @ %p\n"
        "%s    RefCount                       = %lu\n"
        "%s    NextRecvNumber                 = %lu\n"
        "%s    NextBufferNumber               = %lu\n"
        "%s    NextBufferToParse              = %lu\n"
        "%s    pConnection                    = %p\n"
        "%s    pRequest                       = %p\n"
        "%s    Resource                       @ %p (%s)\n"
        "%s    BufferHead                     @ %p%s\n"
        "%s    BindingHead                    @ %p%s\n"
        "%s    pCurrentBuffer                 = %p\n"
        "%s    NeedMoreData                   = %lu\n"
        "%s    UlconnDestroyed                = %lu\n"
        "%s    WaitingForResponse             = %lu\n"
        "%s    WaitForDisconnectHead          @ %p\n"
        "%s    DisconnectFlag                 = %s\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalConnection->Signature,
        SignatureToString(
            LocalConnection->Signature,
            UL_HTTP_CONNECTION_POOL_TAG,
            0,
            strSignature
            ),
        Prefix,
        LocalConnection->ConnectionId,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_CONNECTION, WorkItem ),
        Prefix,
        LocalConnection->RefCount,
        Prefix,
        LocalConnection->NextRecvNumber,
        Prefix,
        LocalConnection->NextBufferNumber,
        Prefix,
        LocalConnection->NextBufferToParse,
        Prefix,
        LocalConnection->pConnection,
        Prefix,
        LocalConnection->pRequest,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_CONNECTION, Resource ),
        BuildResourceState( &LocalConnection->Resource, resourceState ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_CONNECTION, BufferHead ),
        IS_LIST_EMPTY(
            LocalConnection,
            RemoteAddress,
            UL_HTTP_CONNECTION,
            BufferHead,
            ) ? " (EMPTY)" : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_CONNECTION, BindingHead ),
        IS_LIST_EMPTY(
            LocalConnection,
            RemoteAddress,
            UL_HTTP_CONNECTION,
            BindingHead,
            ) ? " (EMPTY)" : "",
        Prefix,
        LocalConnection->pCurrentBuffer,
        Prefix,
        LocalConnection->NeedMoreData,
        Prefix,
        LocalConnection->UlconnDestroyed,
        Prefix,
        LocalConnection->WaitingForResponse,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_CONNECTION, WaitForDisconnectHead ),
        Prefix,
        LocalConnection->DisconnectFlag ? "TRUE" : "FALSE"
        );

#if REFERENCE_DEBUG
    dprintf(
        "%s    pTraceLog                      = %p\n",
        Prefix,
        LocalConnection->pTraceLog
        );
#endif

    dprintf( "\n" );

}   // DumpHttpConnection

VOID
DumpHttpRequest(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_REQUEST LocalRequest
    )
{
    UCHAR rawVerbBuffer[MAX_RAW_VERB_BUFFER];
    UCHAR rawURLBuffer[MAX_RAW_URL_BUFFER];
    UCHAR urlBuffer[MAX_URL_BUFFER];
    CHAR resourceState[MAX_RESOURCE_STATE_LENGTH];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];
    ULONG i;

    //
    // Try to read the raw verb, raw url, and url buffers.
    //

    READ_REMOTE_STRING(
        rawVerbBuffer,
        sizeof(rawVerbBuffer),
        LocalRequest->pRawVerb,
        LocalRequest->RawVerbLength
        );

    READ_REMOTE_STRING(
        rawURLBuffer,
        sizeof(rawURLBuffer),
        LocalRequest->RawUrl.pUrl,
        LocalRequest->RawUrl.Length
        );

    READ_REMOTE_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        LocalRequest->CookedUrl.pUrl,
        LocalRequest->CookedUrl.Length
        );

    //
    // Dump the easy parts.
    //

    dprintf(
        "%s%sHTTP_REQUEST @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    RefCount                       = %lu\n"
        "%s    RequestId                      = %I64x\n"
        "%s    ConnectionId                   = %I64x\n"
        "%s    pHttpConn                      = %p\n"
        "%s    WorkItem                       @ %p\n"
        "%s    AppPool.QueueState             = %s\n"
        "%s    AppPool.pProcess               = %p\n"
        "%s    AppPool.AppPoolEntry           @ %p\n"
        "%s    pConfigInfo                    = %p\n"
        "%s    RecvNumber                     = %lu\n"
        "%s    ParseState                     = %d (%s)\n"
        "%s    ErrorCode                      = %lu\n"
        "%s    TotalRequestSize               = %lu\n"
        "%s    UnknownHeaderCount             = %lu\n"
        "%s    Verb                           = %s\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalRequest->Signature,
        SignatureToString(
            LocalRequest->Signature,
            UL_INTERNAL_REQUEST_POOL_TAG,
            0,
            strSignature
            ),
        Prefix,
        LocalRequest->RefCount,
        Prefix,
        LocalRequest->RequestId,
        Prefix,
        LocalRequest->ConnectionId,
        Prefix,
        LocalRequest->pHttpConn,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, WorkItem ),
        Prefix,
        QueueStateToString( LocalRequest->AppPool.QueueState ),
        Prefix,
        LocalRequest->AppPool.pProcess,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, AppPool.AppPoolEntry ),
        Prefix,
        &LocalRequest->ConfigInfo,
        Prefix,
        LocalRequest->RecvNumber,
        Prefix,
        LocalRequest->ParseState,
        ParseStateToString( LocalRequest->ParseState ),
        Prefix,
        LocalRequest->ErrorCode,
        Prefix,
        LocalRequest->TotalRequestSize,
        Prefix,
        LocalRequest->UnknownHeaderCount,
        Prefix,
        VerbToString( LocalRequest->Verb )
        );

    dprintf(
        "%s    pRawVerb                       = %p (%s)\n"
        "%s    RawVerbLength                  = %lu\n"
        "%s    RawUrl.pUrl                    = %p (%s)\n"
        "%s    RawUrl.pHost                   = %p\n"
        "%s    RawUrl.pAbsPath                = %p\n"
        "%s    RawUrl.Length                  = %lu\n"
        "%s    CookedUrl.pUrl                 = %p (%ws)\n"
        "%s    CookedUrl.pHost                = %p\n"
        "%s    CookedUrl.pAbsPath             = %p\n"
        "%s    CookedUrl.pQueryString         = %p\n"
        "%s    CookedUrl.Length               = %lu\n"
        "%s    CookedUrl.Hash                 = %08lx\n"
        "%s    Version                        = %s\n"
        "%s    Headers                        @ %p\n"
        "%s    UnknownHeaderList              @ %p%s\n",
        Prefix,
        LocalRequest->pRawVerb,
        rawVerbBuffer,
        Prefix,
        LocalRequest->RawVerbLength,
        Prefix,
        LocalRequest->RawUrl.pUrl,
        rawURLBuffer,
        Prefix,
        LocalRequest->RawUrl.pHost,
        Prefix,
        LocalRequest->RawUrl.pAbsPath,
        Prefix,
        LocalRequest->RawUrl.Length,
        Prefix,
        LocalRequest->CookedUrl.pUrl,
        urlBuffer,
        Prefix,
        LocalRequest->CookedUrl.pHost,
        Prefix,
        LocalRequest->CookedUrl.pAbsPath,
        Prefix,
        LocalRequest->CookedUrl.pQueryString,
        Prefix,
        LocalRequest->CookedUrl.Length,
        Prefix,
        LocalRequest->CookedUrl.Hash,
        Prefix,
        VersionToString( LocalRequest->Version ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, Headers ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, UnknownHeaderList ),
        IS_LIST_EMPTY(
            LocalRequest,
            RemoteAddress,
            UL_INTERNAL_REQUEST,
            UnknownHeaderList
            ) ? " (EMPTY)" : ""
        );

    dprintf(
        "%s    ContentLength                  = %I64u\n"
        "%s    ChunkBytesToParse              = %I64u\n"
        "%s    ChunkBytesParsed               = %I64u\n"
        "%s    ChunkBytesToRead               = %I64u\n"
        "%s    ChunkBytesRead                 = %I64u\n"
        "%s    Chunked                        = %lu\n"
        "%s    ParsedFirstChunk               = %lu\n"
        "%s    SentResponse                   = %lu\n"
        "%s    SentLast                       = %lu\n"
        "%s    pHeaderBuffer                  = %p\n"
        "%s    pLastHeaderBuffer              = %p\n"
        "%s    IrpHead                        @ %p%s\n"
        "%s    pChunkBuffer                   = %p\n"
        "%s    pChunkLocation                 = %p\n",
        Prefix,
        LocalRequest->ContentLength,
        Prefix,
        LocalRequest->ChunkBytesToParse,
        Prefix,
        LocalRequest->ChunkBytesParsed,
        Prefix,
        LocalRequest->ChunkBytesToRead,
        Prefix,
        LocalRequest->ChunkBytesRead,
        Prefix,
        LocalRequest->Chunked,
        Prefix,
        LocalRequest->ParsedFirstChunk,
        Prefix,
        LocalRequest->SentResponse,
        Prefix,
        LocalRequest->SentLast,
        Prefix,
        LocalRequest->pHeaderBuffer,
        Prefix,
        LocalRequest->pLastHeaderBuffer,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, IrpHead ),
        IS_LIST_EMPTY(
            LocalRequest,
            RemoteAddress,
            UL_INTERNAL_REQUEST,
            IrpHead
            ) ? " (EMPTY)" : "",
        Prefix,
        LocalRequest->pChunkBuffer,
        Prefix,
        LocalRequest->pChunkLocation
        );

#if REFERENCE_DEBUG
    dprintf(
        "%s    pTraceLog                      = %p\n",
        Prefix,
        LocalRequest->pTraceLog
        );
#endif

    //
    // Dump the known headers.
    //

    for (i = 0 ; i < HttpHeaderRequestMaximum ; i++)
    {
        if (LocalRequest->HeaderValid[i])
        {
            DumpHttpHeader(
                Prefix,
                "",
                (ULONG_PTR)REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, Headers[i] ),
                &LocalRequest->Headers[i],
                i,
                g_RequestHeaderIDs
                );
        }
    }

    //
    // Dump the unknown headers.
    //

    EnumLinkedList(
        (PLIST_ENTRY)REMOTE_OFFSET( RemoteAddress, UL_INTERNAL_REQUEST, UnknownHeaderList ),
        &DumpUnknownHeadersCallback,
        Prefix
        );

}   // DumpHttpRequest

VOID
DumpHttpResponse(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_RESPONSE LocalResponse
    )
{
    ULONG i;
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    //
    // Dump the easy parts.
    //

    dprintf(
        "%s%sUL_INTERNAL_RESPONSE @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    ReferenceCount                 = %d\n"
        "%s    CompleteIrpEarly               = %d\n"
        "%s    ContentLengthSpecified         = %d\n"
        "%s    ChunkedSpecified               = %d\n"
        "%s    StatusCode                     = %lu\n"
        "%s    Verb                           = %s\n"
        "%s    HeaderLength                   = %u\n"
        "%s    pHeaders                       = %p\n"
        "%s    AuxBufferLength                = %u\n"
        "%s    pAuxiliaryBuffer               = %p\n"
        "%s    MaxFileSystemStackSize         = %d\n"
        "%s    ResponseLength                 = %I64u\n"
        "%s    ChunkCount                     = %d\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalResponse->Signature,
        SignatureToString(
            LocalResponse->Signature,
            UL_INTERNAL_RESPONSE_POOL_TAG,
            MAKE_FREE_TAG( UL_INTERNAL_RESPONSE_POOL_TAG ),
            strSignature
            ),
        Prefix,
        LocalResponse->ReferenceCount,
        Prefix,
        LocalResponse->CompleteIrpEarly,
        Prefix,
        LocalResponse->ContentLengthSpecified,
        Prefix,
        LocalResponse->ChunkedSpecified,
        Prefix,
        (ULONG)LocalResponse->StatusCode,
        Prefix,
        VerbToString( LocalResponse->Verb ),
        Prefix,
        LocalResponse->HeaderLength,
        Prefix,
        LocalResponse->pHeaders,
        Prefix,
        LocalResponse->AuxBufferLength,
        Prefix,
        LocalResponse->pAuxiliaryBuffer,
        Prefix,
        LocalResponse->MaxFileSystemStackSize,
        Prefix,
        LocalResponse->ResponseLength,
        Prefix,
        LocalResponse->ChunkCount
        );

    //
    // Dump the chunks
    //
    for (i = 0; i < LocalResponse->ChunkCount; i++) {
        UL_INTERNAL_DATA_CHUNK chunk;
        ULONG_PTR address;
        ULONG result;

        address = (ULONG_PTR)REMOTE_OFFSET(
                        RemoteAddress,
                        UL_INTERNAL_RESPONSE,
                        pDataChunks
                        ) + (i * sizeof(UL_INTERNAL_DATA_CHUNK));

        if (!ReadMemory(
                address,
                &chunk,
                sizeof(chunk),
                &result
                ))
        {
            dprintf(
                "%s: cannot read UL_INTERNAL_DATA_CHUNK @ %p\n",
                CommandName,
                address
                );
            break;
        }

        DumpDataChunk(
            "    ",
            CommandName,
            address,
            &chunk
            );
    }

}   // DumpHttpResponse

VOID
DumpDataChunk(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_DATA_CHUNK Chunk
    )
{
    dprintf("%s%sUL_INTERNAL_DATA_CHUNK @ %p\n", Prefix, CommandName, RemoteAddress);

    switch (Chunk->ChunkType) {
        case HttpDataChunkFromMemory:
            dprintf(
                "%s    ChunkType        = HttpDataChunkFromMemory\n"
                "%s    pMdl             = %p\n"
                "%s    pCopiedBuffer    = %p\n"
                "%s    pUserBuffer      = %p\n"
                "%s    BufferLength     = %u\n",
                Prefix,
                Prefix,
                Chunk->FromMemory.pMdl,
                Prefix,
                Chunk->FromMemory.pCopiedBuffer,
                Prefix,
                Chunk->FromMemory.pUserBuffer,
                Prefix,
                Chunk->FromMemory.BufferLength
                );
            break;

        case HttpDataChunkFromFileName:
            dprintf(
                "%s    ChunkType        = HttpDataChunkFromFileName\n"
                "%s    ByteRange        = [offset %I64d, len %I64d]\n"
                "%s    FileName         = %ws\n"
                "%s    pFileCacheEntry  = %p\n",
                Prefix,
                Prefix,
                Chunk->FromFile.ByteRange.StartingOffset.QuadPart,
                Chunk->FromFile.ByteRange.Length.QuadPart,
                Prefix,
                Chunk->FromFile.FileName.Buffer,
                Prefix,
                Chunk->FromFile.pFileCacheEntry
                );
            break;

        case HttpDataChunkFromFileHandle:
            dprintf(
                "%s    ChunkType        = HttpDataChunkFromFileHandle\n"
                "%s    ByteRange        = [offset %I64d, len %I64d]\n"
                "%s    FileHandle       = %p\n"
                "%s    pFileCacheEntry  = %p\n",
                Prefix,
                Prefix,
                Chunk->FromFile.ByteRange.StartingOffset.QuadPart,
                Chunk->FromFile.ByteRange.Length.QuadPart,
                Prefix,
                Chunk->FromFile.FileHandle,
                Prefix,
                Chunk->FromFile.pFileCacheEntry
                );
            break;

        default:
            dprintf(
                "%s    ChunkType        = <Invalid>\n",
                Prefix
                );
            break;
    }
} // DumpDataChunk


VOID
DumpReceiveBuffer(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_RECEIVE_BUFFER LocalBuffer
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_RECEIVE_BUFFER @ %p\n"
        "%s    LookasideEntry         @ %p\n"
        "%s    Signature              = %08lx (%s)\n"
        "%s    pIrp                   = %p\n"
        "%s    pMdl                   = %p\n"
        "%s    pPartialMdl            = %p\n"
        "%s    pDataArea              = %p\n"
        "%s    pConnection            = %p\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_RECEIVE_BUFFER, LookasideEntry ),
        Prefix,
        LocalBuffer->Signature,
        SignatureToString(
            LocalBuffer->Signature,
            UL_RECEIVE_BUFFER_SIGNATURE,
            UL_RECEIVE_BUFFER_SIGNATURE_X,
            strSignature
            ),
        Prefix,
        LocalBuffer->pIrp,
        Prefix,
        LocalBuffer->pMdl,
        Prefix,
        LocalBuffer->pPartialMdl,
        Prefix,
        LocalBuffer->pDataArea,
        Prefix,
        LocalBuffer->pConnectionContext
        );

}   // DumpReceiveBuffer


VOID
DumpRequestBuffer(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_REQUEST_BUFFER LocalBuffer
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_REQUEST_BUFFER @ %p\n"
        "%s    Signature              = %08lx (%s)\n"
        "%s    ListEntry              @ %p\n"
        "%s    pConnection            = %p\n"
        "%s    WorkItem               @ %p\n"
        "%s    UsedBytes              = %lu\n"
        "%s    AllocBytes             = %lu\n"
        "%s    ParsedBytes            = %lu\n"
        "%s    BufferNumber           = %lu\n"
        "%s    JumboBuffer            = %lu\n"
        "%s    pBuffer                @ %p\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalBuffer->Signature,
        SignatureToString(
            LocalBuffer->Signature,
            UL_REQUEST_BUFFER_POOL_TAG,
            MAKE_FREE_TAG( UL_REQUEST_BUFFER_POOL_TAG ),
            strSignature
            ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_REQUEST_BUFFER, ListEntry ),
        Prefix,
        LocalBuffer->pConnection,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_REQUEST_BUFFER, WorkItem ),
        Prefix,
        LocalBuffer->UsedBytes,
        Prefix,
        LocalBuffer->AllocBytes,
        Prefix,
        LocalBuffer->ParsedBytes,
        Prefix,
        LocalBuffer->BufferNumber,
        Prefix,
        LocalBuffer->JumboBuffer,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_REQUEST_BUFFER, pBuffer )
        );

}   // DumpRequestBuffer


VOID
DumpUlEndpoint(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_ENDPOINT LocalEndpoint,
    IN ENDPOINT_CONNS Verbosity
    )
{
    PTRANSPORT_ADDRESS pTransportAddress;
    UCHAR addressBuffer[MAX_TRANSPORT_ADDRESS_LENGTH];
    CHAR connectionRequestSymbol[MAX_SYMBOL_LENGTH];
    CHAR connectionCompleteSymbol[MAX_SYMBOL_LENGTH];
    CHAR connectionDisconnectSymbol[MAX_SYMBOL_LENGTH];
    CHAR connectionDestroyedSymbol[MAX_SYMBOL_LENGTH];
    CHAR dataReceiveSymbol[MAX_SYMBOL_LENGTH];
    CHAR tmpSymbol[MAX_SYMBOL_LENGTH];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];
    ULONG offset;
    ULONG result;
    BOOLEAN NoActiveConns;
    int i;

    //
    // Read the local address if it fits into our stack buffer.
    //

    pTransportAddress = NULL;

    if (LocalEndpoint->LocalAddressLength <= sizeof(addressBuffer))
    {
        if (ReadMemory(
                (ULONG_PTR)LocalEndpoint->pLocalAddress,
                addressBuffer,
                LocalEndpoint->LocalAddressLength,
                &result
                ))
        {
            pTransportAddress = (PTRANSPORT_ADDRESS)addressBuffer;
        }
    }

    //
    // Try to resolve the callback symbols.
    //

    BuildSymbol(
        LocalEndpoint->pConnectionRequestHandler,
        connectionRequestSymbol
        );

    BuildSymbol(
        LocalEndpoint->pConnectionCompleteHandler,
        connectionCompleteSymbol
        );

    BuildSymbol(
        LocalEndpoint->pConnectionDisconnectHandler,
        connectionDisconnectSymbol
        );

    BuildSymbol(
        LocalEndpoint->pConnectionDestroyedHandler,
        connectionDestroyedSymbol
        );

    BuildSymbol(
        LocalEndpoint->pDataReceiveHandler,
        dataReceiveSymbol
        );

    NoActiveConns = TRUE;

    for (i = 0;  i < DEFAULT_MAX_CONNECTION_ACTIVE_LISTS;  ++i)
    {
        NoActiveConns &= IS_LIST_EMPTY(
                                LocalEndpoint,
                                RemoteAddress,
                                UL_ENDPOINT,
                                ActiveConnectionListHead[i]
                                );
    }

    //
    // Dump it.
    //

    dprintf(
        "%s%sUL_ENDPOINT @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    ReferenceCount                 = %ld\n"
        "%s    UsageCount                     = %ld\n"
        "%s    GlobalEndpointListEntry        @ %p%s\n"
        "%s    IdleConnectionSListHead        @ %p (%hd entries)\n"
        "%s    ActiveConnectionListHead       @ %p%s\n"
        "%s    EndpointSpinLock               @ %p (%s)\n"
        "%s    AddressObject                  @ %p\n"
        "%s        Handle                     = %p\n"
        "%s        pFileObject                = %p\n"
        "%s        pDeviceObject              = %p\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalEndpoint->Signature,
        SignatureToString(
            LocalEndpoint->Signature,
            UL_ENDPOINT_SIGNATURE,
            UL_ENDPOINT_SIGNATURE_X,
            strSignature
            ),
        Prefix,
        LocalEndpoint->ReferenceCount,
        Prefix,
        LocalEndpoint->UsageCount,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, GlobalEndpointListEntry ),
        LocalEndpoint->GlobalEndpointListEntry.Flink == NULL
            ? " (DISCONNECTED)"
            : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, IdleConnectionSListHead ),
        SLIST_HEADER_DEPTH(&LocalEndpoint->IdleConnectionSListHead),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, ActiveConnectionListHead ),
        NoActiveConns ? " (EMPTY)" : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, EndpointSpinLock ),
        GetSpinlockState( &LocalEndpoint->EndpointSpinLock ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, AddressObject ),
        Prefix,
        LocalEndpoint->AddressObject.Handle,
        Prefix,
        LocalEndpoint->AddressObject.pFileObject,
        Prefix,
        LocalEndpoint->AddressObject.pDeviceObject
        );

    dprintf(
        "%s    pConnectionRequestHandler      = %p %s\n"
        "%s    pConnectionCompleteHandler     = %p %s\n"
        "%s    pConnectionDisconnectHandler   = %p %s\n"
        "%s    pConnectionDestroyedHandler    = %p %s\n"
        "%s    pDataReceiveHandler            = %p %s\n"
        "%s    pListeningContext              = %p\n"
        "%s    pLocalAddress                  = %p\n"
        "%s    LocalAddressLength             = %lu\n",
        Prefix,
        LocalEndpoint->pConnectionRequestHandler,
        connectionRequestSymbol,
        Prefix,
        LocalEndpoint->pConnectionCompleteHandler,
        connectionCompleteSymbol,
        Prefix,
        LocalEndpoint->pConnectionDisconnectHandler,
        connectionDisconnectSymbol,
        Prefix,
        LocalEndpoint->pConnectionDestroyedHandler,
        connectionDestroyedSymbol,
        Prefix,
        LocalEndpoint->pDataReceiveHandler,
        dataReceiveSymbol,
        Prefix,
        LocalEndpoint->pListeningContext,
        Prefix,
        LocalEndpoint->pLocalAddress,
        Prefix,
        LocalEndpoint->LocalAddressLength
        );

    if (pTransportAddress != NULL)
    {
        CHAR newPrefix[256];

        sprintf( newPrefix, "%s        ", Prefix );

        DumpTransportAddress(
            newPrefix,
            pTransportAddress,
            (ULONG_PTR)LocalEndpoint->pLocalAddress
            );
    }

    dprintf(
#if ENABLE_OWNER_REF_TRACE
        "%s    pOwnerRefTraceLog              = %p\n"
#endif
        "%s    WorkItem                       @ %p\n"
        "%s    EndpointSynch                  @ %p\n"
        "%s        ReplenishScheduled         = %d\n"
        "%s        IdleConnections            = %d\n"
        "\n",
#if ENABLE_OWNER_REF_TRACE
        Prefix,
        LocalEndpoint->pOwnerRefTraceLog,
#endif
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, WorkItem ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_ENDPOINT, EndpointSynch ),
        Prefix,
        LocalEndpoint->EndpointSynch.ReplenishScheduled,
        Prefix,
        LocalEndpoint->EndpointSynch.IdleConnections
        );

    if (Verbosity != ENDPOINT_NO_CONNS)
    {
        CONN_CALLBACK_CONTEXT ConnContext;

        ConnContext.Signature = CONN_CALLBACK_CONTEXT_SIGNATURE;
        ConnContext.Index     = 0;
        ConnContext.SubIndex  = 0;
        ConnContext.Verbosity = Verbosity;
        ConnContext.Prefix    = "";

        if (! NoActiveConns)
        {
            dprintf(
                "\n"
                "%s    Active Connections\n",
                Prefix);

            for (i = 0;  i < DEFAULT_MAX_CONNECTION_ACTIVE_LISTS;  ++i)
            {
                if (! IS_LIST_EMPTY(LocalEndpoint,
                                    RemoteAddress,
                                    UL_ENDPOINT,
                                    ActiveConnectionListHead[i]))
                {
                    CHAR newPrefix[256];

                    sprintf( newPrefix, "%s %2d     ", Prefix, i );

                    dprintf(
                        "\n"
                        "%s    Active Connections[%d]\n",
                        Prefix);

                    ConnContext.Index    = i;
                    ConnContext.SubIndex = 0;
                    ConnContext.Prefix   = newPrefix;

                    EnumLinkedList(
                        (PLIST_ENTRY) REMOTE_OFFSET(RemoteAddress, UL_ENDPOINT,
                                                    ActiveConnectionListHead[i]),
                        &DumpUlActiveConnectionCallback,
                        &ConnContext
                        );
                }
            }
        }

        if (SLIST_HEADER_NEXT(&LocalEndpoint->IdleConnectionSListHead) != NULL)
        {
            dprintf(
                "\n"
                "%s    Idle Connections, slist depth = %hd\n",
                Prefix,
                SLIST_HEADER_DEPTH(&LocalEndpoint->IdleConnectionSListHead)
                );

            ConnContext.Index    = 0;
            ConnContext.SubIndex = 0;
            ConnContext.Prefix   = Prefix;

            EnumSList(
                (PSLIST_HEADER) REMOTE_OFFSET(RemoteAddress, UL_ENDPOINT,
                                              IdleConnectionSListHead),
                &DumpUlIdleConnectionCallback,
                &ConnContext
                );
        }
    }
#ifdef _WIN64
    else
    {
        dprintf("\n"
                "    Cannot enumerate Idle Connections SList on Win64 :-(\n");
    }
#endif // _WIN64

}   // DumpUlEndpoint


VOID
DumpAllEndpoints(
    IN ENDPOINT_CONNS Verbosity
    )
{
    ULONG_PTR address = GetExpression("&http!g_TdiEndpointListHead");
    ENDPOINT_GLOBAL_CALLBACK_CONTEXT Context;

    if (!address) {
        dprintf(
            "!endp *: cannot find symbol for http!g_TdiEndpointListHead\n"
            );

        return;
    }

    Context.Signature = ENDPOINT_GLOBAL_CALLBACK_CONTEXT_SIGNATURE ;
    Context.Verbosity = Verbosity;
    Context.Prefix = "";

    EnumLinkedList(
        (PLIST_ENTRY) address,
        &DumpEndpointCallback,
        &Context
        );
}

VOID
DumpUlRequest(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PHTTP_REQUEST LocalRequest
    )
{
    UCHAR rawVerbBuffer[MAX_RAW_VERB_BUFFER];
    UCHAR rawURLBuffer[MAX_RAW_URL_BUFFER];
    UCHAR urlBuffer[MAX_URL_BUFFER];

    //
    // Try to read the raw verb, raw url, and url buffers.
    //

    READ_REMOTE_STRING(
        rawVerbBuffer,
        sizeof(rawVerbBuffer),
        LocalRequest->pUnknownVerb,
        LocalRequest->UnknownVerbLength
        );

    READ_REMOTE_STRING(
        rawURLBuffer,
        sizeof(rawURLBuffer),
        LocalRequest->pRawUrl,
        LocalRequest->RawUrlLength
        );

    READ_REMOTE_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        LocalRequest->CookedUrl.pFullUrl,
        LocalRequest->CookedUrl.FullUrlLength
        );

    //
    // Dump the easy parts.
    //

    dprintf(
        "%s%sHTTP_REQUEST @ %p:\n"
        "%s    ConnectionId             = %I64x\n"
        "%s    RequestId                = %I64x\n"
        "%s    Verb                     = %s\n"
        "%s    VerbLength               = %lu\n"
        "%s    VerbOffset               = %p (%S)\n"
        "%s    RawUrlLength             = %lu\n"
        "%s    RawUrlOffset             = %p (%S)\n"
        "%s    UrlLength                = %lu\n"
        "%s    UrlOffset                = %p (%S)\n"
        "%s    UnknownHeaderCount       = %lu\n"
        "%s    UnknownHeaderOffset      = %p\n"
        "%s    EntityBodyLength         = %lu\n"
        "%s    EntityBodyOffset         = %p\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalRequest->ConnectionId,
        Prefix,
        LocalRequest->RequestId,
        Prefix,
        VerbToString( LocalRequest->Verb ),
        Prefix,
        LocalRequest->UnknownVerbLength,
        Prefix,
        LocalRequest->pUnknownVerb,
        rawVerbBuffer,
        Prefix,
        LocalRequest->RawUrlLength,
        Prefix,
        LocalRequest->pRawUrl,
        rawURLBuffer,
        Prefix,
        LocalRequest->CookedUrl.FullUrlLength,
        Prefix,
        LocalRequest->CookedUrl.pFullUrl,
        urlBuffer,
        Prefix,
        LocalRequest->Headers.UnknownHeaderCount,
        Prefix,
        LocalRequest->Headers.pUnknownHeaders,
        Prefix,
        LocalRequest->pEntityChunks->FromMemory.BufferLength,
        Prefix,
        LocalRequest->pEntityChunks->FromMemory.pBuffer
        );

}   // DumpUlRequest


VOID
DumpHttpHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_HEADER LocalHeader,
    IN ULONG HeaderOrdinal,
    IN PSTR *pHeaderIdMap
    )
{
    UCHAR headerBuffer[MAX_HEADER_BUFFER];

    READ_REMOTE_STRING(
        headerBuffer,
        sizeof(headerBuffer),
        LocalHeader->pHeader,
        LocalHeader->HeaderLength
        );

    dprintf(
        "%s%s    UL_HTTP_HEADER[%lu] @ %p (%s):\n"
        "%s        HeaderLength           = %lu\n"
        "%s        pHeader                = %p (%s)\n"
        "%s        OurBuffer              = %lu\n"
        "%s        Valid                  = %lu\n",
        Prefix,
        CommandName,
        HeaderOrdinal,
        RemoteAddress,
        pHeaderIdMap[HeaderOrdinal],
        Prefix,
        LocalHeader->HeaderLength,
        Prefix,
        LocalHeader->pHeader,
        headerBuffer,
        Prefix,
        LocalHeader->OurBuffer,
        Prefix,
        1
        );

}   // DumpHttpHeader


VOID
DumpUnknownHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_UNKNOWN_HEADER LocalHeader
    )
{
    UCHAR headerName[MAX_HEADER_BUFFER];
    UCHAR headerValue[MAX_HEADER_BUFFER];

    READ_REMOTE_STRING(
        headerName,
        sizeof(headerName),
        LocalHeader->pHeaderName,
        LocalHeader->HeaderNameLength
        );

    READ_REMOTE_STRING(
        headerValue,
        sizeof(headerValue),
        LocalHeader->HeaderValue.pHeader,
        LocalHeader->HeaderValue.HeaderLength
        );

    dprintf(
        "%s%s    HTTP_UNKNOWN_HEADER @ %p:\n"
        "%s        List                   @ %p\n"
        "%s        HeaderNameLength       = %lu\n"
        "%s        pHeaderName            = %p (%s)\n"
        "%s        HeaderValue            @ %p\n"
        "%s            HeaderLength       = %lu\n"
        "%s            pHeader            = %p (%s)\n"
        "%s            OurBuffer          = %lu\n"
        "%s            Valid              = %lu\n",
        "%s            ExternalAllocated  = %lu\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_UNKNOWN_HEADER, List ),
        Prefix,
        LocalHeader->HeaderNameLength,
        Prefix,
        LocalHeader->pHeaderName,
        headerName,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_HTTP_UNKNOWN_HEADER, HeaderValue ),
        Prefix,
        LocalHeader->HeaderValue.HeaderLength,
        Prefix,
        LocalHeader->HeaderValue.pHeader,
        headerValue,
        Prefix,
        LocalHeader->HeaderValue.OurBuffer,
        Prefix,
        1,
        Prefix,
        LocalHeader->HeaderValue.ExternalAllocated
        );

}   // DumpUnknownHeader


VOID
DumpFileCacheEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILE_CACHE_ENTRY LocalFile
    )
{
    ULONG result;
    ULONG_PTR offset;
    ULONG nameLength;
    WCHAR fileNameBuffer[MAX_PATH+1];
    CHAR mdlReadSymbol[MAX_SYMBOL_LENGTH];
    CHAR mdlReadCompleteSymbol[MAX_SYMBOL_LENGTH];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    nameLength = min( sizeof(fileNameBuffer), (ULONG)LocalFile->FileName.Length );

    if (!ReadMemory(
            (ULONG_PTR)LocalFile->FileName.Buffer,
            fileNameBuffer,
            nameLength,
            &result
            ))
    {
        nameLength = 0;
    }

    fileNameBuffer[nameLength / sizeof(WCHAR)] = L'\0';

    GetSymbol(
        LocalFile->pMdlRead,
        mdlReadSymbol,
        &offset
        );

    GetSymbol(
        LocalFile->pMdlReadComplete,
        mdlReadCompleteSymbol,
        &offset
        );

    dprintf(
        "%s%sUL_FILE_CACHE_ENTRY @ %p\n"
        "%s    Signature          = %08lx (%s)\n"
        "%s    ReferenceCount     = %lu\n"
        "%s    pFileObject        = %p\n"
        "%s    pDeviceObject      = %p\n"
        "%s    pMdlRead           = %p %s\n"
        "%s    pMdlReadComplete   = %p %s\n"
        "%s    FileName           @ %p (%ws)\n"
        "%s    FileHandle         = %p\n"
        "%s    WorkItem           @ %p\n"
        "%s    FileInfo           @ %p\n"
        "%s        AllocationSize = %I64u\n"
        "%s        EndOfFile      = %I64u\n"
        "%s        NumberOfLinks  = %lu\n"
        "%s        DeletePending  = %lu\n"
        "%s        Directory      = %lu\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalFile->Signature,
        SignatureToString(
            LocalFile->Signature,
            UL_FILE_CACHE_ENTRY_SIGNATURE,
            UL_FILE_CACHE_ENTRY_SIGNATURE_X,
            strSignature
            ),
        Prefix,
        LocalFile->ReferenceCount,
        Prefix,
        LocalFile->pFileObject,
        Prefix,
        LocalFile->pDeviceObject,
        Prefix,
        LocalFile->pMdlRead,
        mdlReadSymbol,
        Prefix,
        LocalFile->pMdlReadComplete,
        mdlReadCompleteSymbol,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILE_CACHE_ENTRY, FileName ),
        fileNameBuffer,
        Prefix,
        LocalFile->FileHandle,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILE_CACHE_ENTRY, WorkItem ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILE_CACHE_ENTRY, FileInfo ),
        Prefix,
        LocalFile->FileInfo.AllocationSize.QuadPart,
        Prefix,
        LocalFile->FileInfo.EndOfFile.QuadPart,
        Prefix,
        LocalFile->FileInfo.NumberOfLinks,
        Prefix,
        (ULONG)LocalFile->FileInfo.DeletePending,
        Prefix,
        (ULONG)LocalFile->FileInfo.Directory
        );

}   // DumpFileCacheEntry


#if 0
// BUGBUG: GeorgeRe must fix

VOID
DumpUriEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_URI_CACHE_ENTRY UriEntry
    )
{
    UCHAR urlBuffer[MAX_URL_BUFFER];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    READ_REMOTE_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        UriEntry->Uri.pUri,
        UriEntry->Uri.Length
        );

    dprintf(
        "%s%sUL_URI_CACHE_ENTRY @ %p\n"
        "%s%S\n"
        "%s\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    BucketEntry                    @ %p\n"
        "%s        Flink                      = %p ( !ulkd.uri %p )\n"
        "%s        Blink                      = %p ( !ulkd.uri %p )\n"
        "%s    Uri                            @ %p\n"
        "%s        Hash                       = %08lx\n"
        "%s        Length                     = %lu\n"
        "%s        pUri                       = %p\n"
        "%s    ReferenceCount                 = %lu\n"
        "%s    HitCount                       = %lu\n"
        "%s    Zombie                         = %lu\n"
        "%s    Cached                         = %lu\n"
        "%s    ContentLengthSpecified         = %lu\n"
        "%s    StatusCode                     = %u\n"
        "%s    Verb                           = %s\n"
        "%s    ScavengerTicks                 = %lu\n"
        "%s    CachePolicy                    @ %p\n"
        "%s        Policy                     = %s\n"
        "%s        SecondsToLive              = %lu\n"
        "%s    ExpirationTime                 = %08x%08x\n"
        "%s    pConfigInfo                    = %p\n"
        "%s    pProcess                       = %p\n"
        "%s    HeaderLength                   = %lu\n"
        "%s    pHeaders                       = %p\n"
        "%s    ContentLength                  = %lu\n"
        "%s    pContent                       = %p\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        urlBuffer,
        Prefix,
        Prefix,
        UriEntry->Signature,
        SignatureToString(
            UriEntry->Signature,
            UL_URI_CACHE_ENTRY_POOL_TAG,
            MAKE_FREE_TAG(UL_URI_CACHE_ENTRY_POOL_TAG),
            strSignature
            ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_URI_CACHE_ENTRY, BucketEntry ),
        Prefix,
        UriEntry->BucketEntry.Flink,
        CONTAINING_RECORD(
            UriEntry->BucketEntry.Flink,
            UL_URI_CACHE_ENTRY,
            BucketEntry
            ),
        Prefix,
        UriEntry->BucketEntry.Blink,
        CONTAINING_RECORD(
            UriEntry->BucketEntry.Blink,
            UL_URI_CACHE_ENTRY,
            BucketEntry
            ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_URI_CACHE_ENTRY, Uri ),
        Prefix,
        UriEntry->Uri.Hash,
        Prefix,
        UriEntry->Uri.Length,
        Prefix,
        UriEntry->Uri.pUri,
        Prefix,
        UriEntry->ReferenceCount,
        Prefix,
        UriEntry->HitCount,
        Prefix,
        UriEntry->Zombie,
        Prefix,
        UriEntry->Cached,
        Prefix,
        UriEntry->ContentLengthSpecified,
        Prefix,
        (ULONG)UriEntry->StatusCode,
        Prefix,
        VerbToString( UriEntry->Verb ),
        Prefix,
        UriEntry->ScavengerTicks,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_URI_CACHE_ENTRY, CachePolicy ),
        Prefix,
        CachePolicyToString( UriEntry->CachePolicy.Policy ),
        Prefix,
        UriEntry->CachePolicy.SecondsToLive,
        Prefix,
        UriEntry->ExpirationTime.HighPart,
        UriEntry->ExpirationTime.LowPart,
        Prefix,
        UriEntry->pConfigInfo,
        Prefix,
        UriEntry->pProcess,
        Prefix,
        UriEntry->HeaderLength,
        Prefix,
        UriEntry->pHeaders,
        Prefix,
        UriEntry->ContentLength,
        Prefix,
        UriEntry->pContent
        );

}   // DumpUriEntry

#endif

VOID
DumpAllUriEntries(
    VOID
    )
{
    ULONG_PTR           address = 0;
//  UL_URI_CACHE_TABLE  table;
    ULONG_PTR           dataAddress;
    ULONG               i;

    dprintf("BUGBUG: GeorgeRe needs to fix DumpAllUriEntries!\n");
    
#if 0
    //
    // find table
    //

    address = GetExpression("&http!g_pUriCacheTable");
    if (address) {
        if (ReadMemory(
                address,
                &dataAddress,
                sizeof(dataAddress),
                NULL
                ))
        {
            if (ReadMemory(
                    dataAddress,
                    &table,
                    sizeof(table),
                    NULL
                    ))
            {
                //
                // dump live entries
                //
                dprintf("Live UL_URI_CACHE_ENTRIES\n\n");

                for (i = 0; i < table.BucketCount; i++) {

                    EnumLinkedList(
                        ((PLIST_ENTRY)
                            REMOTE_OFFSET(
                                dataAddress,
                                UL_URI_CACHE_TABLE,
                                Buckets
                                )) + i,
                        &DumpUriEntryCallback,
                        "L   "
                        );
                }

            } else {
                dprintf(
                    "uri*: cannot read memory for http!g_pUriCacheTable = %p\n",
                    dataAddress
                    );
            }
        } else {
            dprintf(
                "uri*: cannot read memory for http!g_pUriCacheTable @ %p\n",
                address
                );
        }
    } else {
        dprintf(
            "uri*: cannot find symbol for http!g_pUriCacheTable\n"
            );
    }

    //
    // dump the zombie list
    //
    address = GetExpression("&http!g_ZombieListHead");

    if (!address) {
        dprintf(
            "uri*: cannot find symbol for http!g_ZombieListHead\n"
            );

        return;
    }

    dprintf("Zombie UL_URI_CACHE_ENTRIES\n\n");

    EnumLinkedList(
        (PLIST_ENTRY) address,
        &DumpUriEntryCallback,
        "Z   "
        );

#endif

} // DumpAllUriEntries


VOID
DumpMdl(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PMDL LocalMdl,
    IN ULONG MaxBytesToDump
    )
{
    dprintf(
        "%s%sMDL @ %p\n"
        "%s    Next             = %p\n"
        "%s    Size             = %04x\n"
        "%s    MdlFlags         = %04x\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalMdl->Next,
        Prefix,
        LocalMdl->Size,
        Prefix,
        LocalMdl->MdlFlags
        );

    DumpBitVector(
        Prefix,
        "                       ",
        LocalMdl->MdlFlags,
        g_MdlFlagVector
        );

    dprintf(
        "%s    Process          = %p\n"
        "%s    MappedSystemVa   = %p\n"
        "%s    StartVa          = %p\n"
        "%s    ByteCount        = %08lx\n"
        "%s    ByteOffset       = %08lx\n",
        Prefix,
        LocalMdl->Process,
        Prefix,
        LocalMdl->MappedSystemVa,
        Prefix,
        LocalMdl->StartVa,
        Prefix,
        LocalMdl->ByteCount,
        Prefix,
        LocalMdl->ByteOffset
        );

    if (MaxBytesToDump > LocalMdl->ByteCount)
    {
        MaxBytesToDump = LocalMdl->ByteCount;
    }

    if (MaxBytesToDump > 0)
    {
        DumpRawData(
            Prefix,
            (ULONG_PTR)LocalMdl->MappedSystemVa,
            MaxBytesToDump
            );
    }

}   // DumpMdl


//
// Private functions.
//

BOOLEAN
DumpUnknownHeadersCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    UL_HTTP_UNKNOWN_HEADER header;
    UCHAR headerName[MAX_HEADER_BUFFER];
    UCHAR headerValue[MAX_HEADER_BUFFER];
    ULONG result;
    ULONG_PTR address;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_HTTP_UNKNOWN_HEADER,
                            List
                            );

    if (!ReadMemory(
            address,
            &header,
            sizeof(header),
            &result
            ))
    {
        return FALSE;
    }

    DumpUnknownHeader(
        (PSTR) Context,
        "",
        address,
        &header
        );

    return TRUE;

}   // DumpUnknownHeadersCallback



VOID
DumpApoolObj(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_APP_POOL_OBJECT ApoolObj
    )
{
    UCHAR name[MAX_URL_BUFFER];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    READ_REMOTE_STRING(
        name,
        sizeof(name),
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_OBJECT, pName ),
        ApoolObj->NameLength
        );
        
    dprintf(
        "%s%sUL_APP_POOL_OBJECT @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    RefCount                       = %d\n"
        "%s    ListEntry                      @ %p\n"
        "%s        Flink                      = %p ( !ulkd.apool %p )\n"
        "%s        Blink                      = %p ( !ulkd.apool %p )\n"
        "%s    pResource                      = %p\n"
        "%s    NewRequestQueue\n"
        "%s        RequestCount               = %d\n"
        "%s        MaxRequests                = %d\n"
        "%s        RequestHead                @ %p\n"
        "%s    pDemandStartIrp                = %p\n"
        "%s    pDemandStartProcess            = %p\n"
        "%s    ProcessListHead                @ %p\n"
        "%s    pSecurityDescriptor            = %p\n"
        "%s    NameLength                     = %d\n"
        "%s    pName                          = %p ( %S )\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        ApoolObj->Signature,
        SignatureToString(
            ApoolObj->Signature,
            UL_APP_POOL_OBJECT_POOL_TAG,
            MAKE_FREE_TAG(UL_APP_POOL_OBJECT_POOL_TAG),
            strSignature
            ),
        Prefix,
        ApoolObj->RefCount,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_OBJECT, ListEntry ),
        Prefix,
        ApoolObj->ListEntry.Flink,
        CONTAINING_RECORD(
            ApoolObj->ListEntry.Flink,
            UL_APP_POOL_OBJECT,
            ListEntry
            ),
        Prefix,
        ApoolObj->ListEntry.Blink,
        CONTAINING_RECORD(
            ApoolObj->ListEntry.Blink,
            UL_APP_POOL_OBJECT,
            ListEntry
            ),
        Prefix,
        ApoolObj->pResource,
        Prefix,
        Prefix,
        ApoolObj->NewRequestQueue.RequestCount,
        Prefix,
        ApoolObj->NewRequestQueue.MaxRequests,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_OBJECT, NewRequestQueue.RequestHead ),
        Prefix,
        ApoolObj->pDemandStartIrp,
        Prefix,
        ApoolObj->pDemandStartProcess,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_OBJECT, ProcessListHead ),
        Prefix,
        ApoolObj->pSecurityDescriptor,
        Prefix,
        ApoolObj->NameLength,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_OBJECT, pName ),
        name
        );

    if (ApoolObj->ProcessListHead.Flink != (PLIST_ENTRY)REMOTE_OFFSET(
                                                RemoteAddress,
                                                UL_APP_POOL_OBJECT,
                                                ProcessListHead
                                                ))
    {
        dprintf("%s    AP Process List:\n", Prefix);
        EnumLinkedList(
            (PLIST_ENTRY)REMOTE_OFFSET(
                                RemoteAddress,
                                UL_APP_POOL_OBJECT,
                                ProcessListHead
                                ),
            &ProcListCallback,
            Prefix
            );
    }

    if (ApoolObj->NewRequestQueue.RequestHead.Flink != (PLIST_ENTRY)REMOTE_OFFSET(
                                                            RemoteAddress,
                                                            UL_APP_POOL_OBJECT,
                                                            NewRequestQueue.RequestHead
                                                            ))
    {
        dprintf("%s    New Request List:\n", Prefix);
        EnumLinkedList(
            (PLIST_ENTRY)REMOTE_OFFSET(
                                RemoteAddress,
                                UL_APP_POOL_OBJECT,
                                NewRequestQueue.RequestHead
                                ),
            &RequestListCallback,
            Prefix
            );
    }

    dprintf("\n");

}   // DumpApoolObj


VOID
DumpAllApoolObjs(
    VOID
    )
{
    ULONG_PTR           address = 0;

    address = GetExpression("&http!g_AppPoolListHead");
    if (!address) {
        dprintf(
            "apool*: cannot find symbol for http!g_AppPoolListHead\n"
            );

        return;
    }

    EnumLinkedList(
        (PLIST_ENTRY) address,
        &DumpApoolCallback,
        ""
        );
}

VOID
DumpApoolProc(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_APP_POOL_PROCESS ApoolProc
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_APP_POOL_PROCESS @ %p\n"
        "%s    Signature                      = %08lx (%s)\n"
        "%s    InCleanup                      = %d\n"
        "%s    ListEntry                      @ %p\n"
        "%s        Flink                      = %p ( !ulkd.proc %p )\n"
        "%s        Blink                      = %p ( !ulkd.proc %p )\n"
        "%s    pAppPool                       = %p\n"
        "%s    NewIrpHead                     @ %p\n"
        "%s    PendingRequestQueue\n"
        "%s        RequestCount               = %d\n"
        "%s        MaxRequests                = %d\n"
        "%s        RequestHead                @ %p\n"
        "%s    pProcess                       = %p\n"
        "%s    WaitForDisconnectHead          @ %p\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        ApoolProc->Signature,
        SignatureToString(
            ApoolProc->Signature,
            UL_APP_POOL_PROCESS_POOL_TAG,
            MAKE_FREE_TAG(UL_APP_POOL_PROCESS_POOL_TAG),
            strSignature
            ),
        Prefix,
        ApoolProc->InCleanup,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_PROCESS, ListEntry ),
        Prefix,
        ApoolProc->ListEntry.Flink,
        CONTAINING_RECORD(
            ApoolProc->ListEntry.Flink,
            UL_APP_POOL_PROCESS,
            ListEntry
            ),
        Prefix,
        ApoolProc->ListEntry.Blink,
        CONTAINING_RECORD(
            ApoolProc->ListEntry.Blink,
            UL_APP_POOL_PROCESS,
            ListEntry
            ),
        Prefix,
        ApoolProc->pAppPool,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_PROCESS, NewIrpHead ),
        Prefix,
        Prefix,
        ApoolProc->PendingRequestQueue.RequestCount,
        Prefix,
        ApoolProc->PendingRequestQueue.MaxRequests,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_PROCESS, PendingRequestQueue.RequestHead ),
        Prefix,
        ApoolProc->pProcess,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_APP_POOL_PROCESS, WaitForDisconnectHead )
        );

    //
    // dump the IRP list
    //
    if (ApoolProc->NewIrpHead.Flink != (PLIST_ENTRY)REMOTE_OFFSET(
                                            RemoteAddress,
                                            UL_APP_POOL_PROCESS,
                                            NewIrpHead
                                            ))
    {
        dprintf("%s    Irp List:\n", Prefix);

        EnumLinkedList(
            (PLIST_ENTRY) REMOTE_OFFSET(
                                RemoteAddress,
                                UL_APP_POOL_PROCESS,
                                NewIrpHead
                                ),
            &IrpListCallback,
            Prefix
            );
    }

    //
    // dump pending request list
    //
    if (ApoolProc->PendingRequestQueue.RequestHead.Flink != (PLIST_ENTRY)REMOTE_OFFSET(
                                                                RemoteAddress,
                                                                UL_APP_POOL_PROCESS,
                                                                PendingRequestQueue.RequestHead
                                                                ))
    {
        dprintf("%s    Request List:\n", Prefix);

        EnumLinkedList(
            (PLIST_ENTRY) REMOTE_OFFSET(
                                RemoteAddress,
                                UL_APP_POOL_PROCESS,
                                PendingRequestQueue.RequestHead
                                ),
            &RequestListCallback,
            Prefix
            );
    }

    dprintf("\n");
}   // DumpApoolProc

VOID
DumpConfigGroup(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONFIG_GROUP_OBJECT Obj
    )
{
    CHAR temp[sizeof("1234567812345678")];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_CONFIG_GROUP_OBJECT @ %p\n"
        "%s    Signature                    = %x (%s)\n"
        "%s    RefCount                     = %d\n"
        "%s    ConfigGroupId                = %I64x\n"
        "%s    ControlChannelEntry          @ %p\n"
        "%s    pControlChannel              = %p\n"
        "%s    UrlListHead                  @ %p\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Obj->Signature,
        SignatureToString(
            Obj->Signature,
            UL_CG_OBJECT_POOL_TAG,
            MAKE_FREE_TAG(UL_CG_OBJECT_POOL_TAG),
            strSignature
            ),
        Prefix,
        Obj->RefCount,
        Prefix,
        Obj->ConfigGroupId,
        Prefix,
        REMOTE_OFFSET(RemoteAddress, UL_CONFIG_GROUP_OBJECT, ControlChannelEntry),
        Prefix,
        Obj->pControlChannel,
        Prefix,
        REMOTE_OFFSET(RemoteAddress, UL_CONFIG_GROUP_OBJECT, UrlListHead)
        );

    if (Obj->AppPoolFlags.Present) {
        dprintf(
            "%s    pAppPool                     = %p\n",
            Prefix,
            Obj->pAppPool
            );
    } else {
        dprintf(
            "%s    pAppPool (none)\n",
            Prefix
            );
    }

    dprintf(
        "%s    pAutoResponse                = %p\n",
        Prefix,
        Obj->pAutoResponse
        );

    if (Obj->MaxBandwidth.Flags.Present) {
        dprintf(
            "%s    MaxBandwidth                 = %d\n",
            Prefix,
            Obj->MaxBandwidth.MaxBandwidth
            );
    } else {
        dprintf(
            "%s    MaxBandwidth (none)\n",
            Prefix
            );
    }

    if (Obj->MaxConnections.Flags.Present) {
        dprintf(
            "%s    MaxConnections               = %d\n",
            Prefix,
            Obj->MaxConnections.MaxConnections
            );
    } else {
        dprintf(
            "%s    MaxConnections (none)\n",
            Prefix
            );
    }

    if (Obj->State.Flags.Present) {
        dprintf(
            "%s    State                        = %s\n",
            Prefix,
            UlEnabledStateToString(Obj->State.State)
            );
    } else {
        dprintf(
            "%s    State (none)\n",
            Prefix
            );
    }

    if (Obj->Security.Flags.Present) {
        dprintf(
            "%s    Security.pSecurityDescriptor = %p\n",
            Prefix,
            Obj->Security.pSecurityDescriptor
            );

        if (Obj->Security.pSecurityDescriptor) {
            sprintf(temp, "%p", Obj->Security.pSecurityDescriptor);
            CallExtensionRoutine("sd", temp);
        }
    } else {
        dprintf(
            "%s    Security (none)\n",
            Prefix
            );
    }
}

VOID
DumpConfigTree(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_URL_TREE_HEADER Tree
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_CG_URL_TREE_HEADER @ %p\n"
        "%s    Signature    = %x (%s)\n"
        "%s    AllocCount   = %u\n"
        "%s    UsedCount    = %u\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Tree->Signature,
        SignatureToString(
            Tree->Signature,
            UL_CG_TREE_HEADER_POOL_TAG,
            MAKE_FREE_TAG(UL_CG_TREE_HEADER_POOL_TAG),
            strSignature
            ),
        Prefix,
        Tree->AllocCount,
        Prefix,
        Tree->UsedCount
        );
}


VOID
DumpCgroupEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_URL_TREE_ENTRY Entry
    )
{
    UCHAR tokenBuffer[MAX_URL_BUFFER];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_CG_URL_TREE_ENTRY @ %p\n"
        "%s    Signature                    = %08lx (%s)\n"
        "%s    pParent                      = %p (cgentry)\n"
        "%s    pChildren                    = %p (cgtree)\n"
        "%s    TokenHash                    = 0x%08x\n"
        "%s    TokenLength                  = %d\n"
        "%s    FullUrl                      = %d\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Entry->Signature,
        SignatureToString(
            Entry->Signature,
            UL_CG_TREE_ENTRY_POOL_TAG,
            MAKE_FREE_TAG(UL_CG_TREE_ENTRY_POOL_TAG),
            strSignature
            ),
        Prefix,
        Entry->pParent,
        Prefix,
        Entry->pChildren,
        Prefix,
        Entry->TokenHash,
        Prefix,
        Entry->TokenLength,
        Prefix,
        Entry->FullUrl
        );

    if (Entry->FullUrl) {

        dprintf(
            "%s    UrlContext                   = %I64x\n"
            "%s    pConfigGroup                 = %p\n"
            "%s    ConfigGroupListEntry         @ %p\n",
            Prefix,
            Entry->UrlContext,
            Prefix,
            Entry->pConfigGroup,
            Prefix,
            REMOTE_OFFSET(RemoteAddress, UL_CG_URL_TREE_ENTRY, ConfigGroupListEntry)
            );

    }

    READ_REMOTE_STRING(
        tokenBuffer,
        sizeof(tokenBuffer),
        REMOTE_OFFSET(RemoteAddress, UL_CG_URL_TREE_ENTRY, pToken),
        Entry->TokenLength
        );

    dprintf(
        "%s    pToken                       = %ws\n"
        "\n",
        Prefix,
        tokenBuffer
        );
}

VOID
DumpCgroupHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_HEADER_ENTRY Entry
    )
{
    UL_CG_URL_TREE_ENTRY tentry;
    ULONG result;

    dprintf(
        "%s%sUL_CG_HEADER_ENTRY @ %p\n"
        "%s    TokenHash    = 0x%08x\n"
        "%s    pEntry       = %p\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Entry->TokenHash,
        Prefix,
        Entry->pEntry
        );

    if (!ReadMemory(
            (ULONG_PTR)Entry->pEntry,
            &tentry,
            sizeof(tentry),
            &result
            ))
    {
         dprintf(
                "%scouldn't read UL_CG_TREE_ENTRY @ %p\n",
                CommandName,
                Entry->pEntry
                );
         return;
    }

    DumpCgroupEntry(
        Prefix,
        CommandName,
        (ULONG_PTR)Entry->pEntry,
        &tentry
        );
}

#if 0

BOOLEAN
DumpUriEntryCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    UL_URI_CACHE_ENTRY entry;
    ULONG_PTR address;
    ULONG result;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_URI_CACHE_ENTRY,
                            BucketEntry
                            );

    if (!ReadMemory(
            address,
            &entry,
            sizeof(entry),
            &result
            ))
    {
        return FALSE;
    }

    DumpUriEntry(
        (PSTR) Context,
        "uri*: ",
        address,
        &entry
        );

    return TRUE;

}   // DumpUriEntryCallback

#endif

BOOLEAN
DumpApoolCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    UL_APP_POOL_OBJECT obj;
    ULONG_PTR address;
    ULONG result;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_APP_POOL_OBJECT,
                            ListEntry
                            );

    if (!ReadMemory(
            address,
            &obj,
            sizeof(obj),
            &result
            ))
    {
        return FALSE;
    }

    DumpApoolObj(
        (PSTR) Context,
        "apool*: ",
        address,
        &obj
        );

    return TRUE;

}   // DumpApoolCallback


BOOLEAN
DumpEndpointCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    UL_ENDPOINT endp;
    ULONG_PTR address;
    ULONG result;

    PENDPOINT_GLOBAL_CALLBACK_CONTEXT pCtxt
        = (PENDPOINT_GLOBAL_CALLBACK_CONTEXT) Context;

    ASSERT(pCtxt->Signature == ENDPOINT_GLOBAL_CALLBACK_CONTEXT_SIGNATURE);

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_ENDPOINT,
                            GlobalEndpointListEntry
                            );

    if (!ReadMemory(
            address,
            &endp,
            sizeof(endp),
            &result
            ))
    {
        return FALSE;
    }

    DumpUlEndpoint(
        pCtxt->Prefix,
        "endp *: ",
        address,
        &endp,
        pCtxt->Verbosity
        );

    return TRUE;

}   // DumpEndpointCallback


BOOLEAN
ProcListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_APP_POOL_PROCESS,
                            ListEntry
                            );

    dprintf("%s        %p\n", (PSTR) Context, address);

    return TRUE;

}   // ProcListCallback


BOOLEAN
IrpListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

    dprintf("%s        %p\n", (PSTR) Context, address);

    return TRUE;

}   // IrpListCallback

BOOLEAN
RequestListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    UL_INTERNAL_REQUEST request;
    ULONG_PTR address;
    ULONG result;
    UCHAR urlBuffer[MAX_URL_BUFFER];

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_INTERNAL_REQUEST,
                            AppPool.AppPoolEntry
                            );

    if (!ReadMemory(
            address,
            &request,
            sizeof(request),
            &result
            ))
    {
        return FALSE;
    }

    READ_REMOTE_STRING(
        urlBuffer,
        sizeof(urlBuffer),
        request.CookedUrl.pUrl,
        request.CookedUrl.Length
        );

    dprintf(
        "%s        %p - %s %ws\n",
        (PSTR) Context,
        address,
        VerbToString(request.Verb),
        urlBuffer
        );

    return TRUE;

}   // RequestListCallback


VOID
DumpKernelQueue(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PKQUEUE LocalQueue,
    IN ULONG Flags
    )
{
    dprintf(
        "%s%sKQUEUE @ %p\n"
        "%s    Type             = %02x\n"
        "%s    Absolute         = %02x\n"
        "%s    Size             = %02x\n"
        "%s    Inserted         = %02x\n"
        "%s    SignalState      = %ld\n"
        "%s    WaitListHead     @ %p%s\n"
        "%s    EntryListHead    @ %p%s\n"
        "%s    CurrentCount     = %lu\n"
        "%s    MaximumCount     = %lu\n"
        "%s    ThreadListHead   @ %p%s\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        LocalQueue->Header.Type,
        Prefix,
        LocalQueue->Header.Absolute,
        Prefix,
        LocalQueue->Header.Size,
        Prefix,
        LocalQueue->Header.Inserted,
        Prefix,
        LocalQueue->Header.SignalState,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, KQUEUE, Header.WaitListHead ),
        IS_LIST_EMPTY(
            LocalQueue,
            RemoteAddress,
            KQUEUE,
            Header.WaitListHead
            ) ? " (EMPTY)" : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, KQUEUE, EntryListHead ),
        IS_LIST_EMPTY(
            LocalQueue,
            RemoteAddress,
            KQUEUE,
            EntryListHead
            ) ? " (EMPTY)" : "",
        Prefix,
        LocalQueue->CurrentCount,
        Prefix,
        LocalQueue->MaximumCount,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, KQUEUE, ThreadListHead ),
        IS_LIST_EMPTY(
            LocalQueue,
            RemoteAddress,
            KQUEUE,
            ThreadListHead
            ) ? " (EMPTY)" : ""
        );

    if (Flags & 1)
    {
        EnumLinkedList(
            (PLIST_ENTRY)REMOTE_OFFSET( RemoteAddress, KQUEUE, EntryListHead ),
            &DumpKQueueEntriesCallback,
            NULL
            );
    }

}   // DumpKernelQueue

BOOLEAN
DumpKQueueEntriesCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;
    CHAR temp[sizeof("1234567812345678 f")];

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            IRP,
                            Tail.Overlay.ListEntry
                            );

    sprintf( temp, "%p f", address );

    CallExtensionRoutine( "irp", temp );

    return TRUE;

}   // DumpKQueueEntriesCallback

VOID
DumpFilterChannel(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILTER_CHANNEL Filter,
    IN ULONG Flags
    )
{
    UCHAR name[MAX_URL_BUFFER];
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    READ_REMOTE_STRING(
        name,
        sizeof(name),
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_CHANNEL, pName ),
        Filter->NameLength
        );
        
    dprintf(
        "%s%sUL_FILTER_CHANNEL @ %p\n"
        "%s    Signature            = %x (%s)\n"
        "%s    RefCount             = %d\n"
        "%s    ListEntry            @ %p\n"
        "%s    pDemandStartIrp      = %p\n"
        "%s    pDemandStartProcess  = %p\n"
        "%s    SpinLock             @ %p (%s)\n"
        "%s    ProcessListHead      @ %p%s\n"
        "%s    ConnectionListHead   @ %p%s\n"
        "%s    pSecurityDescriptor  = %p\n"
        "%s    NameLength           = %d\n"
        "%s    pName                = %p (%S)\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Filter->Signature,
        SignatureToString(
            Filter->Signature,
            UL_FILTER_CHANNEL_POOL_TAG,
            MAKE_FREE_TAG(UL_FILTER_CHANNEL_POOL_TAG),
            strSignature
            ),
        Prefix,
        Filter->RefCount,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_CHANNEL, ListEntry ),
        Prefix,
        Filter->pDemandStartIrp,
        Prefix,
        Filter->pDemandStartProcess,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_CHANNEL, SpinLock ),
        GetSpinlockState( &Filter->SpinLock ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_CHANNEL, ProcessListHead ),
        IS_LIST_EMPTY(
            Filter,
            RemoteAddress,
            UL_FILTER_CHANNEL,
            ProcessListHead
            ) ? " (EMPTY)" : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_CHANNEL, ConnectionListHead ),
        IS_LIST_EMPTY(
            Filter,
            RemoteAddress,
            UL_FILTER_CHANNEL,
            ConnectionListHead
            ) ? " (EMPTY)" : "",
        Prefix,
        Filter->pSecurityDescriptor,
        Prefix,
        Filter->NameLength,
        Prefix,
        Filter->pName,
        name
        );


    if (Filter->ProcessListHead.Flink != (PLIST_ENTRY)REMOTE_OFFSET(
                                                RemoteAddress,
                                                UL_FILTER_CHANNEL,
                                                ProcessListHead
                                                ))
    {
        dprintf("%s    Filter Process List:\n", Prefix);
        EnumLinkedList(
            (PLIST_ENTRY)REMOTE_OFFSET(
                                RemoteAddress,
                                UL_FILTER_CHANNEL,
                                ProcessListHead
                                ),
            &FiltProcListCallback,
            Prefix
            );
    }

    dprintf("\n");
}

BOOLEAN
FiltProcListCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            UL_FILTER_PROCESS,
                            ListEntry
                            );

    dprintf("%s        %p\n", (PSTR) Context, address);

    return TRUE;

}   // FiltProcListCallback


VOID
DumpFilterProc(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILTER_PROCESS Proc,
    IN ULONG Flags
    )
{
    CHAR strSignature[MAX_SIGNATURE_LENGTH];

    dprintf(
        "%s%sUL_FILTER_PROCESS @ %p\n"
        "%s    Signature            = %x (%s)\n"
        "%s    InCleanup            = %ld\n"
        "%s    pFilterChannel       = %p\n"
        "%s    ListEntry            @ %p\n"
        "%s    ConnectionHead       @ %p%s\n"
        "%s    IrpHead              @ %p%s\n"
        "%s    pProcess             = %p\n"
        "\n",
        Prefix,
        CommandName,
        RemoteAddress,
        Prefix,
        Proc->Signature,
        SignatureToString(
            Proc->Signature,
            UL_FILTER_PROCESS_POOL_TAG,
            MAKE_FREE_TAG(UL_FILTER_PROCESS_POOL_TAG),
            strSignature
            ),
        Prefix,
        Proc->InCleanup,
        Prefix,
        Proc->pFilterChannel,
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_PROCESS, ListEntry ),
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_PROCESS, ConnectionHead ),
        IS_LIST_EMPTY(
            Proc,
            RemoteAddress,
            UL_FILTER_PROCESS,
            ConnectionHead
            ) ? " (EMPTY)" : "",
        Prefix,
        REMOTE_OFFSET( RemoteAddress, UL_FILTER_PROCESS, IrpHead ),
        IS_LIST_EMPTY(
            Proc,
            RemoteAddress,
            UL_FILTER_PROCESS,
            IrpHead
            ) ? " (EMPTY)" : "",
        Prefix,
        Proc->pProcess
        );
        
} // DumpFilterProc


BOOLEAN
DumpUlActiveConnectionCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;
    UL_CONNECTION connection;
    ULONG result;
    PCONN_CALLBACK_CONTEXT pConnContext = (PCONN_CALLBACK_CONTEXT) Context;

    ASSERT(pConnContext->Signature == CONN_CALLBACK_CONTEXT_SIGNATURE);

    address = (ULONG_PTR) CONTAINING_RECORD(
                                RemoteListEntry,
                                UL_CONNECTION,
                                ActiveListEntry // <--
                                );

    if (!ReadMemory(
            address,
            &connection,
            sizeof(connection),
            &result
            ))
    {
        return FALSE;
    }

    dprintf("active conn[%2d][%2d]: ",
            pConnContext->Index, pConnContext->SubIndex++);
    
    switch (pConnContext->Verbosity)
    {
    case ENDPOINT_BRIEF_CONNS:
        DumpUlConnectionLite(
            pConnContext->Prefix,
            "",
            address,
            &connection
            );
        break;

    case ENDPOINT_VERBOSE_CONNS:
        DumpUlConnection(
            pConnContext->Prefix,
            "",
            address,
            &connection
            );
        break;

    default:
        ASSERT(! "Invalid ENDPOINT_CONNS");
    }

    return TRUE;

} // DumpUlActiveConnectionCallback


BOOLEAN
DumpUlIdleConnectionCallback(
    IN PSINGLE_LIST_ENTRY RemoteSListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;
    UL_CONNECTION connection;
    ULONG result;
    PCONN_CALLBACK_CONTEXT pConnContext = (PCONN_CALLBACK_CONTEXT) Context;

    ASSERT(pConnContext->Signature == CONN_CALLBACK_CONTEXT_SIGNATURE);

    address = (ULONG_PTR) CONTAINING_RECORD(
                                RemoteSListEntry,
                                UL_CONNECTION,
                                IdleSListEntry // <--
                                );

    if (!ReadMemory(
            address,
            &connection,
            sizeof(connection),
            &result
            ))
    {
        return FALSE;
    }

    dprintf("idle conn[%2d]: ", pConnContext->SubIndex++);
    
    switch (pConnContext->Verbosity)
    {
    case ENDPOINT_BRIEF_CONNS:
        DumpUlConnectionLite(
            pConnContext->Prefix,
            "",
            address,
            &connection
            );
        break;

    case ENDPOINT_VERBOSE_CONNS:
        DumpUlConnection(
            pConnContext->Prefix,
            "",
            address,
            &connection
            );
        break;

    default:
        ASSERT(! "Invalid ENDPOINT_CONNS");
    }

    return TRUE;

} // DumpUlIdleConnectionCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\dbgutil.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    dbgutil.c

Abstract:

    Utility functions for dealing with the kernel debugger.

Author:

    Keith Moore (keithmo) 17-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//

#define EXT_DLL "kdexts.dll"


//
//  Private globals.
//

PSTR WeekdayNames[] =
     {
         "Sunday",
         "Monday",
         "Tuesday",
         "Wednesday",
         "Thursday",
         "Friday",
         "Saturday"
     };

PSTR MonthNames[] =
     {
         "",
         "January",
         "February",
         "March",
         "April",
         "May",
         "June",
         "July",
         "August",
         "September",
         "October",
         "November",
         "December"
     };

HMODULE ExtensionDll = NULL;


//
//  Public functions.
//


VOID
SystemTimeToString(
    IN LONGLONG Value,
    OUT PSTR Buffer
    )

/*++

Routine Description:

    Maps a LONGLONG representing system time to a displayable string.

Arguments:

    Value - The LONGLONG time to map.

    Buffer - Receives the mapped time.

Return Value:

    None.

--*/

{

    NTSTATUS status;
    LARGE_INTEGER systemTime;
    LARGE_INTEGER localTime;
    TIME_FIELDS timeFields;

    systemTime.QuadPart = Value;

    status = RtlSystemTimeToLocalTime( &systemTime, &localTime );

    if( !NT_SUCCESS(status) ) {
        sprintf( Buffer, "%I64d", Value );
        return;
    }

    RtlTimeToTimeFields( &localTime, &timeFields );

    sprintf(
        Buffer,
        "%s %s %2d %4d %02d:%02d:%02d.%03d",
        WeekdayNames[timeFields.Weekday],
        MonthNames[timeFields.Month],
        timeFields.Day,
        timeFields.Year,
        timeFields.Hour,
        timeFields.Minute,
        timeFields.Second,
        timeFields.Milliseconds
        );

}   // SystemTimeToString

PSTR
SignatureToString(
    IN ULONG CurrentSignature,
    IN ULONG ValidSignature,
    IN ULONG FreedSignature,
    OUT PSTR Buffer
    )
{
    PSTR pstr = Buffer;
    int i;
    UCHAR ch;

    *pstr++ = '\'';

    for (i = 0;  i < 4;  ++i)
    {
        ch = (UCHAR)((CurrentSignature >> (8 * i)) & 0xFF);
        *pstr++ = isprint(ch) ? (ch) : '?';
    }
    
    *pstr++ = '\'';
    *pstr++ = ' ';
    *pstr = '\0';
    
    if (CurrentSignature == ValidSignature)
    {
        strcat(pstr, "OK");
    }
    else if (CurrentSignature == FreedSignature)
    {
        strcat(pstr, "FREED");
    }
    else
    {
        strcat(pstr, "INVALID");
    }

    return Buffer;
}   // SignatureToString


PSTR
ParseStateToString(
    IN PARSE_STATE State
    )
{
    PSTR result;

    switch (State)
    {
    case ParseVerbState:
        result = "ParseVerbState";
        break;

    case ParseUrlState:
        result = "ParseUrlState";
        break;

    case ParseVersionState:
        result = "ParseVersionState";
        break;

    case ParseHeadersState:
        result = "ParseHeadersState";
        break;

    case ParseCookState:
        result = "ParseCookState";
        break;

    case ParseEntityBodyState:
        result = "ParseEntityBodyState";
        break;

    case ParseTrailerState:
        result = "ParseTrailerState";
        break;

    case ParseDoneState:
        result = "ParseDoneState";
        break;

    case ParseErrorState:
        result = "ParseErrorState";
        break;

    default:
        result = "INVALID";
        break;
    }

    return result;

}   // ParseStateToString


PSTR
UlEnabledStateToString(
    IN HTTP_ENABLED_STATE State
    )
{
    PSTR result;

    switch (State)
    {
    case HttpEnabledStateActive:
        result = "HttpEnabledStateActive";
        break;

    case HttpEnabledStateInactive:
        result = "HttpEnabledStateInactive";
        break;

    default:
        result = "INVALID";
        break;
    }

    return result;
}


PSTR
CachePolicyToString(
    IN HTTP_CACHE_POLICY_TYPE PolicyType
    )
{
    PSTR result;

    switch (PolicyType)
    {
    case HttpCachePolicyNocache:
        result = "HttpCachePolicyNocache";
        break;

    case HttpCachePolicyUserInvalidates:
        result = "HttpCachePolicyUserInvalidates";
        break;

    case HttpCachePolicyTimeToLive:
        result = "HttpCachePolicyTimeToLive";
        break;

    default:
        result = "INVALID";
        break;
    }

    return result;
}


PSTR
VerbToString(
    IN HTTP_VERB Verb
    )
{
    PSTR result;

    switch (Verb)
    {
    case HttpVerbUnparsed:
        result = "UnparsedVerb";
        break;

    case HttpVerbGET:
        result = "GET";
        break;

    case HttpVerbPUT:
        result = "PUT";
        break;

    case HttpVerbHEAD:
        result = "HEAD";
        break;

    case HttpVerbPOST:
        result = "POST";
        break;

    case HttpVerbDELETE:
        result = "DELETE";
        break;

    case HttpVerbTRACE:
        result = "TRACE";
        break;

    case HttpVerbOPTIONS:
        result = "OPTIONS";
        break;

    case HttpVerbCONNECT:
        result = "CONNECT";
        break;

    case HttpVerbMOVE:
        result = "MOVE";
        break;

    case HttpVerbCOPY:
        result = "COPY";
        break;

    case HttpVerbPROPFIND:
        result = "PROPFIND";
        break;

    case HttpVerbPROPPATCH:
        result = "PROPPATCH";
        break;

    case HttpVerbMKCOL:
        result = "MKCOL";
        break;

    case HttpVerbLOCK:
        result = "LOCK";
        break;

    case HttpVerbUNLOCK:
        result = "LOCK";
        break;

    case HttpVerbSEARCH:
        result = "SEARCH";
        break;

    case HttpVerbUnknown:
        result = "UnknownVerb";
        break;

    case HttpVerbInvalid:
        result = "InvalidVerb";
        break;

    default:
        result = "INVALID";
        break;
    }

    return result;

}   // VerbToString


PSTR
VersionToString(
    IN HTTP_VERSION Version
    )
{
    PSTR result;

    if (HTTP_EQUAL_VERSION(Version, 0, 9))
    {
        result = "Version09";
    }
    else
    if (HTTP_EQUAL_VERSION(Version, 1, 0))
    {
        result = "Version10";
    }
    else
    if (HTTP_EQUAL_VERSION(Version, 1, 1))
    {
        result = "Version11";
    }
    else
    {
        result = "INVALID";
    }

    return result;

}   // VersionToString

PSTR
QueueStateToString(
    IN QUEUE_STATE QueueState
    )
{
    PSTR result;

    switch (QueueState)
    {
    case QueueUnroutedState:
        result = "QueueUnroutedState";
        break;
        
    case QueueDeliveredState:
        result = "QueueDeliveredState";
        break;
        
    case QueueCopiedState:
        result = "QueueCopiedState";
        break;
        
    case QueueUnlinkedState:
        result = "QueueUnlinkedState";
        break;

    default:
        result = "INVALID";
        break;
    }
    
    return result;
}

VOID
BuildSymbol(
    IN PVOID RemoteAddress,
    OUT PSTR Symbol
    )
{
    ULONG_PTR offset;
    CHAR tmpSymbol[MAX_SYMBOL_LENGTH];

    tmpSymbol[0] = '\0';
    GetSymbol( RemoteAddress, tmpSymbol, &offset );

    if (tmpSymbol[0] == '\0')
    {
        Symbol[0] = '\0';
    }
    else
    if (offset == 0)
    {
        strcpy( Symbol, (PCHAR)tmpSymbol );
    }
    else
    {
        sprintf( Symbol, "%s+0x%p", tmpSymbol, offset );
    }

}   // BuildSymbol

PSTR
GetSpinlockState(
    IN PUL_SPIN_LOCK SpinLock
    )
{
    if (*((PULONG_PTR)SpinLock) == 0)
    {
        return "FREE";
    }
    else
    {
        return "ACQUIRED";
    }

}   // GetSpinlockState

BOOLEAN
EnumLinkedList(
    IN PLIST_ENTRY RemoteListHead,
    IN PENUM_LINKED_LIST_CALLBACK Callback,
    IN PVOID Context
    )
{
    LIST_ENTRY localListEntry;
    PLIST_ENTRY nextRemoteListEntry;
    ULONG result;

    //
    // Try to read the list head.
    //

    if (!ReadMemory(
            (ULONG_PTR)RemoteListHead,
            &localListEntry,
            sizeof(localListEntry),
            &result
            ))
    {
        return FALSE;
    }

    //
    // Loop through the entries.
    //

    nextRemoteListEntry = localListEntry.Flink;

    while (nextRemoteListEntry != RemoteListHead)
    {
        if (CheckControlC())
        {
            break;
        }

        if (!(Callback)( nextRemoteListEntry, Context ))
        {
            break;
        }

        if (!ReadMemory(
                (ULONG_PTR)nextRemoteListEntry,
                &localListEntry,
                sizeof(localListEntry),
                &result
                ))
        {
            return FALSE;
        }

        nextRemoteListEntry = localListEntry.Flink;
    }

    return TRUE;

}   // EnumLinkedList



BOOLEAN
EnumSList(
    IN PSLIST_HEADER RemoteSListHead, 
    IN PENUM_SLIST_CALLBACK Callback,
    IN PVOID Context
    )
{
    SLIST_HEADER       localSListHead; 
    SINGLE_LIST_ENTRY  localSListEntry;
    PSINGLE_LIST_ENTRY nextRemoteSListEntry;
    ULONG result;

    //
    // Try to read the list head.
    //

    if (!ReadMemory(
            (ULONG_PTR)RemoteSListHead,
            &localSListHead,
            sizeof(localSListHead),
            &result
            ))
    {
        return FALSE;
    }

    //
    // Loop through the entries.
    //

    nextRemoteSListEntry = SLIST_HEADER_NEXT(&localSListHead);

    while (nextRemoteSListEntry != NULL)
    {
        if (CheckControlC())
        {
            break;
        }

        if (!(Callback)( nextRemoteSListEntry, Context ))
        {
            break;
        }

        if (!ReadMemory(
                (ULONG_PTR)nextRemoteSListEntry,
                &localSListEntry,
                sizeof(localSListEntry),
                &result
                ))
        {
            return FALSE;
        }

        nextRemoteSListEntry = localSListEntry.Next;
    }

    return TRUE;

}   // EnumSList



PSTR
BuildResourceState(
    IN PUL_ERESOURCE LocalAddress,
    OUT PSTR Buffer
    )
{
    PERESOURCE pResource;

    pResource = (PERESOURCE)LocalAddress;

    if (pResource->ActiveCount == 0)
    {
        sprintf(
            Buffer,
            "UNOWNED"
            );
    }
    else
    {
        if ((pResource->Flag & ResourceOwnedExclusive) != 0)
        {
            sprintf(
                Buffer,
                "OWNED EXCLUSIVE BY %p [%ld]",
                pResource->OwnerThreads[0].OwnerThread,
                pResource->OwnerThreads[0].OwnerCount
                );
        }
        else
        {
            sprintf(
                Buffer,
                "OWNED SHARED"
                );
        }
    }

    return Buffer;

}   // BuildResourceState

BOOLEAN
IsThisACheckedBuild(
    VOID
    )
{
    ULONG_PTR address;
    ULONG value = 0;
    ULONG result;
    BOOLEAN isChecked = FALSE;

    address = GetExpression( "&http!g_UlCheckedBuild" );

    if (address != 0)
    {
        if (ReadMemory(
                address,
                &value,
                sizeof(value),
                &result
                ))
        {
            isChecked = (value != 0);
        }
    }

    return isChecked;

}   // IsThisACheckedBuild

VOID
DumpBitVector(
    IN PSTR Prefix1,
    IN PSTR Prefix2,
    IN ULONG Vector,
    IN PVECTORMAP VectorMap
    )
{
    while ((Vector != 0) && (VectorMap->Vector != 0))
    {
        if (Vector & VectorMap->Vector)
        {
            dprintf(
                "%s%s%s\n",
                Prefix1,
                Prefix2,
                VectorMap->Name
                );

            Vector &= ~(VectorMap->Vector);
        }

        VectorMap++;
    }

    if (Vector != 0)
    {
        dprintf(
            "%s%sExtra Bits = %08lx\n",
            Prefix1,
            Prefix2,
            Vector
            );
    }

}   // DumpBitVector

VOID
DumpRawData(
    IN PSTR Prefix,
    IN ULONG_PTR RemoteAddress,
    IN ULONG BufferLength
    )
{
    PSTR lineScan;
    ULONG lineLength;
    ULONG i;
    ULONG result;
    UCHAR ch;
    UCHAR rawData[16];
    CHAR formattedData[sizeof("1234567812345678  11 22 33 44 55 66 77 88-99 aa bb cc dd ee ff 00  123456789abcdef0")];

    while (BufferLength > 0)
    {
        lineLength = (BufferLength > 16) ? 16 : BufferLength;

        if (!ReadMemory(
                RemoteAddress,
                rawData,
                lineLength,
                &result
                ))
        {
            dprintf( "%sCannot read memory @ %p\n", Prefix, RemoteAddress );
            break;
        }

        lineScan = formattedData;

        lineScan += sprintf( lineScan, "%p  ", RemoteAddress );

        for (i = 0 ; i < 16 ; i++)
        {
            if (i < lineLength)
            {
                lineScan += sprintf(
                                lineScan,
                                "%02X%c",
                                rawData[i],
                                (i == 7)
                                    ? '-'
                                    : ' '
                                );
            }
            else
            {
                *lineScan++ = ' ';
                *lineScan++ = ' ';
                *lineScan++ = ' ';
            }
        }

        *lineScan++ = ' ';
        *lineScan++ = ' ';

        for (i = 0 ; i < 16 ; i++)
        {
            if (i < lineLength)
            {
                ch = rawData[i];

                if ((ch < ' ') || (ch > '~'))
                {
                    ch = '.';
                }
            }
            else
            {
                ch = ' ';
            }

            *lineScan++ = ch;
        }

        *lineScan = '\0';

        dprintf(
            "%s%s\n",
            Prefix,
            formattedData
            );

        BufferLength -= lineLength;
        RemoteAddress += (ULONG_PTR)lineLength;
    }

}   // DumpRawData


BOOLEAN
CallExtensionRoutine(
    IN PSTR RoutineName,
    IN PSTR ArgumentString
    )
{
#if _WIN64
    PWINDBG_EXTENSION_ROUTINE64 ExtRoutine;
#else
    PWINDBG_EXTENSION_ROUTINE ExtRoutine;
#endif

    BOOLEAN result = FALSE;

#ifdef EXT_DLL
    if (ExtensionDll == NULL)
    {
        ExtensionDll = LoadLibraryA( EXT_DLL );
    }
#endif

    if (ExtensionDll != NULL)
    {
#if _WIN64
        ExtRoutine = (PWINDBG_EXTENSION_ROUTINE64)GetProcAddress(
                            ExtensionDll,
                            RoutineName
                            );
#else
        ExtRoutine = (PWINDBG_EXTENSION_ROUTINE)GetProcAddress(
                            ExtensionDll,
                            RoutineName
                            );
#endif
        if (ExtRoutine != NULL)
        {
            (ExtRoutine)(
                g_hCurrentProcess,
                g_hCurrentThread,
                g_dwCurrentPc,
                g_dwProcessor,
                ArgumentString
                );

            result = TRUE;
        }
    }

    return result;

}   // CallExtensionRoutine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\conn.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    conn.c

Abstract:

    Dumps UL_CONNECTION and HTTP_CONNECTION structures.

Author:

    Keith Moore (keithmo) 26-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Public functions.
//

DECLARE_API( ulconn )

/*++

Routine Description:

    Dumps UL_CONNECTION structures.

Arguments:

    None.

Return Value:

    None.

--*/
{

    ULONG_PTR address = 0;
    ULONG result;
    UL_CONNECTION connection;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "ulconn" );
        return;
    }

    //
    // Read the connection.
    //

    if (!ReadMemory(
            address,
            &connection,
            sizeof(connection),
            &result
            ))
    {
        dprintf(
            "ulconn: cannot read UL_CONNECTION @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpUlConnection(
        "",
        "ulconn: ",
        address,
        &connection
        );

}   // ulconn


DECLARE_API( httpconn )

/*++

Routine Description:

    Dumps HTTP_CONNECTION structures.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG_PTR address = 0;
    ULONG result;
    UL_HTTP_CONNECTION connection;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "httpconn" );
        return;
    }

    //
    // Read the connection.
    //

    if (!ReadMemory(
            address,
            &connection,
            sizeof(connection),
            &result
            ))
    {
        dprintf(
            "httpconn: cannot read HTTP_CONNECTION @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpHttpConnection(
        "",
        "httpconn: ",
        address,
        &connection
        );

}   // httpconn


DECLARE_API( httpreq )

/*++

Routine Description:

    Dumps UL_INTERNAL_REQUEST structures.

Arguments:

    None.

Return Value:

    None.

--*/

{

    ULONG_PTR address = 0;
    ULONG result;
    UL_INTERNAL_REQUEST request;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "httpreq" );
        return;
    }

    //
    // Read the connection.
    //

    if (!ReadMemory(
            address,
            &request,
            sizeof(request),
            &result
            ))
    {
        dprintf(
            "httpreq: cannot read HTTP_REQUEST @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpHttpRequest(
        "",
        "httpreq: ",
        address,
        &request
        );

}   // httpreq
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\file.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    file.c

Abstract:

    Dumps UL_FILE_CACHE_ENTRY structures.

Author:

    Keith Moore (keithmo) 16-Sep-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private prototypes.
//


//
// Public functions.
//

DECLARE_API( file )

/*++

Routine Description:

    Dumps UL_FILE_CACHE_ENTRY structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_FILE_CACHE_ENTRY file;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "file" );
        return;
    }

    //
    // Read the nsgo.
    //

    if (!ReadMemory(
            address,
            &file,
            sizeof(file),
            &result
            ))
    {
        dprintf(
            "nsgo: cannot read UL_FILE_CACHE_ENTRY @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpFileCacheEntry(
        "",
        "file: ",
        address,
        &file
        );

}   // file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\endp.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    endp.c

Abstract:

    Dumps UL_ENDPOINT structures.

Author:

    Keith Moore (keithmo) 26-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Public functions.
//

DECLARE_API( endp )

/*++

Routine Description:

    Dumps UL_ENDPOINT structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_ENDPOINT endpoint;
    ENDPOINT_CONNS Verbosity = ENDPOINT_NO_CONNS;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Skip leading blanks.
    //

    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    while ((*args == '*') || (*args == '-'))
    {
        if (*args == '*')
        {
            DumpAllEndpoints(Verbosity);
            return;
        }
        else if (*args == '-')
        {
            args++;

            switch (*args)
            {
            case 'c' :
            case 'C' :
                Verbosity = ENDPOINT_BRIEF_CONNS;
                args++;
                break;

            case 'v' :
            case 'V' :
                Verbosity = ENDPOINT_VERBOSE_CONNS;
                args++;
                break;

            default :
                PrintUsage( "endp" );
                return;
            }
        }

        while (*args == ' ' || *args == '\t')
        {
            args++;
        }
    }

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "endp" );
        return;
    }

    //
    // Read the endpoint.
    //

    if (!ReadMemory(
            address,
            &endpoint,
            sizeof(endpoint),
            &result
            ))
    {
        dprintf(
            "endp: cannot read UL_ENDPOINT @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpUlEndpoint(
        "",
        "endp: ",
        address,
        &endpoint,
        Verbosity
        );

}   // endp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\filt.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    filt.c

Abstract:

    Extensions for dumping filter information.

Author:

    Michael Courage (mcourage) 6-Apr-2000

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"

//
// Private globals.
//

PSTR g_pFiltqActions[] =
    {
        "QUEUE_IRP          ",
        "DEQUEUE_IRP        ",
        "START_WRITE        ",
        "FINISH_WRITE       ",
        "BLOCK_WRITE        ",
        "WAKE_WRITE         ",
        "BLOCK_PARTIAL_WRITE",
        "WAKE_PARTIAL_WRITE "
    
    };

C_ASSERT( DIM(g_pFiltqActions) == FILTQ_ACTION_COUNT );


//
//  Public functions.
//

DECLARE_API( filter )

/*++

Routine Description:

    Dumps a filter channel.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_FILTER_CHANNEL channel;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        address = GetExpression( "&http!g_pFilterChannel" );
    }

    if (address != 0)
    {
        if (!ReadMemory(
            address,
            &address,
            sizeof(address),
            NULL
                    ))
        {
            dprintf(
                "filter: Cannot read memory @ %p\n",
                address
                );
            return;
        }
    }

    if (address == 0)
    {
        PrintUsage( "filter" );
        return;
    }

    //
    // Read the filter.
    //

    if (!ReadMemory(
            address,
            &channel,
            sizeof(channel),
            &result
            ))
    {
        dprintf(
            "filter: cannot read UL_FILTER_CHANNEL @ %p\n",
            address
            );
        return;
    }

    DumpFilterChannel(
        "",
        "filter: ",
        address,
        &channel,
        0
        );
    

}   // filter


DECLARE_API( fproc )

/*++

Routine Description:

    Dumps a filter process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_FILTER_PROCESS process;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "fproc" );
        return;
    }

    //
    // Read the filter proc.
    //

    if (!ReadMemory(
            address,
            &process,
            sizeof(process),
            &result
            ))
    {
        dprintf(
            "fproc: cannot read UL_FILTER_PROCESS @ %p\n",
            address
            );
        return;
    }

    DumpFilterProc(
        "",
        "fproc: ",
        address,
        &process,
        0
        );
    

}   // fproc


DECLARE_API( fqlog )

/*++

Routine Description:

    Dumps the filter queue trace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR               address = 0;
    ULONG_PTR               context = 0;
    ULONG_PTR               flags = 0;
    ULONG_PTR               entryAddress;
    ULONG_PTR               logPointer;
    ULONG                   result;
    TRACE_LOG               logHeader;
    LONGLONG                numEntries;
    FILTQ_TRACE_LOG_ENTRY   logEntry;
    PSTR                    pAction;
    LONGLONG                index;
    ULONG                   offset1;
    ULONG                   offset2;
    CHAR                    invalidAction[sizeof("2047")];
    PSTR                    fileName;
    CHAR                    filePath[MAX_PATH];

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the optional context from the command line.
    //

    context = GetExpression( args );

    //
    // Find the log.
    //

    address = GetExpression( "&http!g_pFilterQueueTraceLog" );

    if (address == 0)
    {
        dprintf( "fqlog: cannot find http!g_pFilterQueueTraceLog\n" );
        return;
    }

    //
    // Read the pointer.
    //

    if (!ReadMemory(
            address,
            &logPointer,
            sizeof(logPointer),
            &result
            ))
    {
        dprintf(
            "fqlog: cannot read PTRACE_LOG @ %p\n",
            address
            );
        return;
    }

    //
    // Read the log header.
    //

    if (!ReadMemory(
            logPointer,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "fqlog: cannot read TRACE_LOG @ %p\n",
            logPointer
            );
        return;
    }

    dprintf(
        "fqlog: log @ %p\n"
        "    Signature = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx '%c%c%c%c'\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %I64d\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        address,
        logHeader.Signature,
        DECODE_SIGNATURE(logHeader.Signature),
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TypeSignature,
        DECODE_SIGNATURE(logHeader.TypeSignature),
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.pLogBuffer
        );

    if (logHeader.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader) ))
    {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X)
    {
        dprintf(
            "fqlog: log @ %p has invalid signature %08lx:\n",
            address,
            logHeader.Signature
            );
        return;
    }

    if (logHeader.EntrySize != sizeof(logEntry)
        || logHeader.TypeSignature != FILTQ_TRACE_LOG_SIGNATURE)
    {
        dprintf(
            "fqlog: log @ %p is not a filter queue trace log\n",
            address
            );
        return;
    }

    if (logHeader.NextEntry == -1)
    {
        dprintf(
            "fqlog: empty log @ %p\n",
            address
            );
        return;
    }

    //
    // Calculate the log size to dump.
    //

    if (logHeader.NextEntry < logHeader.LogSize)
    {
        numEntries = logHeader.NextEntry + 1;
        index = 0;
    }
    else
    {
        numEntries = logHeader.LogSize;
        index = (logHeader.NextEntry + 1) % logHeader.LogSize;
    }

    entryAddress = (ULONG_PTR)logHeader.pLogBuffer +
        (ULONG_PTR)( index * sizeof(logEntry) );

    if (entryAddress >=
        ( (ULONG_PTR)logHeader.pLogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) )
    {
        dprintf(
            "fqlog: log @ %p has invalid data\n",
            address
            );
        return;
    }

    //
    // Dump the log.
    //

    for (;
         numEntries > 0 ;
         index++,
         numEntries--,
         entryAddress += sizeof(logEntry))
     {
        if (CheckControlC())
        {
            break;
        }

        if (index >= logHeader.LogSize)
        {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.pLogBuffer;
        }

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "fqlog: cannot read memory @ %p\n",
                entryAddress
                );
            return;
        }

        if (context == 0 ||
            context == (ULONG_PTR)logEntry.pConnection)
        {

            //
            // Grab the file name.
            //
            
            if (ReadMemory(
                    (ULONG_PTR)logEntry.pFileName,
                    filePath,
                    sizeof(filePath),
                    &result
                    ))
            {
                fileName = strrchr( filePath, '\\' );

                if (fileName != NULL)
                {
                    fileName++;
                }
                else
                {
                    fileName = filePath;
                }
            }
            else
            {
                sprintf(
                    filePath,
                    "%p",
                    logEntry.pFileName
                    );

                fileName = filePath;
            }

            //
            // And the action name.
            //
            
            if (logEntry.Action < FILTQ_ACTION_COUNT)
            {
                pAction = g_pFiltqActions[logEntry.Action];
            }
            else
            {
                sprintf( invalidAction, "%lu", (ULONG)logEntry.Action );
                pAction = invalidAction;
            }

                
            dprintf(
                "CPU=%lu Conn=%p Act=%s ReadIrps=%lu Writers=%lu, %s:%u\n",
                logEntry.Processor,
                logEntry.pConnection,
                pAction,
                logEntry.ReadIrps,
                logEntry.Writers,
                fileName,
                logEntry.LineNumber
                );
                
        }
    }

}   // fqlog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\glob.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    glob.c

Abstract:

    Dumps critical global UL data.

Author:

    Keith Moore (keithmo) 07-Apr-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private types.
//

typedef struct _UL_SYMBOL
{
    PSTR pSymbolName;
    ULONG_PTR Address;
    ULONG_PTR Value;
    ULONG Size;
    BOOLEAN Pointer;

} UL_SYMBOL, *PUL_SYMBOL;

#define MAKE_POINTER( name, type )                                          \
    {                                                                       \
        "&http!" name,                                                        \
        0,                                                                  \
        0,                                                                  \
        (ULONG)sizeof(type),                                                \
        TRUE                                                                \
    }

#define MAKE_ORDINAL( name, type )                                          \
    {                                                                       \
        "&http!" name,                                                        \
        0,                                                                  \
        0,                                                                  \
        (ULONG)sizeof(type),                                                \
        FALSE                                                               \
    }

UL_SYMBOL g_GlobalSymbols[] =
    {
        MAKE_ORDINAL( "g_UlNumberOfProcessors",     CLONG               ),
        MAKE_POINTER( "g_pUlNonpagedData",          PUL_NONPAGED_DATA   ),
        MAKE_POINTER( "g_pUlSystemProcess",         PKPROCESS           ),
        MAKE_POINTER( "g_UlDirectoryObject",        HANDLE              ),
        MAKE_POINTER( "g_pUlControlDeviceObject",   PDEVICE_OBJECT      ),
        MAKE_POINTER( "g_pUlFilterDeviceObject",    PDEVICE_OBJECT      ),
        MAKE_POINTER( "g_pUlAppPoolDeviceObject",   PDEVICE_OBJECT      ),
        MAKE_ORDINAL( "g_UlPriorityBoost",          CCHAR               ),
        MAKE_ORDINAL( "g_UlIrpStackSize",           CCHAR               ),
        MAKE_ORDINAL( "g_UlMinIdleConnections",     USHORT              ),
        MAKE_ORDINAL( "g_UlMaxIdleConnections",     USHORT              ),
        MAKE_ORDINAL( "g_UlReceiveBufferSize",      ULONG               ),
        MAKE_POINTER( "g_pFilterChannel",           PUL_FILTER_CHANNEL  ),
        MAKE_ORDINAL( "g_FilterOnlySsl",            BOOLEAN             )
#if REFERENCE_DEBUG
        ,
        MAKE_POINTER( "g_pMondoGlobalTraceLog",     PTRACE_LOG          ),
        MAKE_POINTER( "g_pTdiTraceLog",             PTRACE_LOG          ),
        MAKE_POINTER( "g_pHttpRequestTraceLog",     PTRACE_LOG          ),
        MAKE_POINTER( "g_pHttpConnectionTraceLog",  PTRACE_LOG          ),
        MAKE_POINTER( "g_pHttpResponseTraceLog",    PTRACE_LOG          ),
        MAKE_POINTER( "g_pAppPoolTraceLog",         PTRACE_LOG          ),
        MAKE_POINTER( "g_pConfigGroupTraceLog",     PTRACE_LOG          ),
        MAKE_POINTER( "g_pMdlTraceLog",             PTRACE_LOG          ),
        MAKE_POINTER( "g_pIrpTraceLog",             PTRACE_LOG          ),
        MAKE_POINTER( "g_pFilterTraceLog",          PTRACE_LOG          ),
        MAKE_POINTER( "g_pTimeTraceLog",            PTRACE_LOG          ),
        MAKE_POINTER( "g_pReplenishTraceLog",       PTRACE_LOG          ),
        MAKE_POINTER( "g_pFiltQueueTraceLog",       PTRACE_LOG          ),
        MAKE_POINTER( "g_pSiteCounterTraceLog",     PTRACE_LOG          ),
        MAKE_POINTER( "g_pConfigGroupInfoTraceLog", PTRACE_LOG          )
#endif
    };

#define NUM_SYMBOLS DIM(g_GlobalSymbols)


//
// Public functions.
//

DECLARE_API( glob )

/*++

Routine Description:

    Dumps critical global UL data.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PUL_SYMBOL pSymbols;
    ULONG i;
    ULONG_PTR address;
    ULONG_PTR dataAddress;
    UL_NONPAGED_DATA data;
    CHAR configGroupResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR appPoolResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR disconnectResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR uriZombieResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR filterResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR logListResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR tciIfcResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR dateHeaderResource[MAX_RESOURCE_STATE_LENGTH];

    SNAPSHOT_EXTENSION_DATA();

    //
    // Dump the simple data.
    //

    for (i = NUM_SYMBOLS, pSymbols = &g_GlobalSymbols[0] ;
         i > 0 ;
         i--, pSymbols++)
    {
        pSymbols->Address = GetExpression( pSymbols->pSymbolName );

        if (pSymbols->Address == 0)
        {
            dprintf(
                "glob: cannot find symbol for %s\n",
                pSymbols->pSymbolName
                );
        }
        else
        {
            pSymbols->Value = 0;

            if (ReadMemory(
                    pSymbols->Address,
                    &pSymbols->Value,
                    pSymbols->Size,
                    NULL
                    ))
            {
                if (pSymbols->Pointer)
                {
                    dprintf(
                        "%-30s = %p\n",
                        pSymbols->pSymbolName,
                        pSymbols->Value
                        );
                }
                else
                {
                    dprintf(
                        "%-30s = %lu\n",
                        pSymbols->pSymbolName,
                        (ULONG)pSymbols->Value
                        );
                }
            }
            else
            {
                dprintf(
                    "glob: cannot read memory for %s @ %p\n",
                    pSymbols->pSymbolName,
                    pSymbols->Address
                    );
            }
        }
    }

    //
    // Dump the nonpaged data.
    //

    address = GetExpression( "&http!g_pUlNonpagedData" );

    if (address == 0)
    {
        dprintf(
            "glob: cannot find symbol for http!g_pUlNonpagedData\n"
            );
    }
    else
    {
        if (ReadMemory(
                address,
                &dataAddress,
                sizeof(dataAddress),
                NULL
                ))
        {
            if (ReadMemory(
                    dataAddress,
                    &data,
                    sizeof(data),
                    NULL
                    ))
            {
                dprintf(
                    "\n"
                    "UL_NONPAGED_DATA @ %p:\n"
                    "    IrpContextLookaside    @ %p\n"
                    "    ReceiveBufferLookaside @ %p\n"
                    "    ResourceLookaside      @ %p\n"
                    "    ConfigGroupResource    @ %p (%s)\n"
                    "    AppPoolResource        @ %p (%s)\n"
                    "    DisconnectResource     @ %p (%s)\n"
                    "    UriZombieResource      @ %p (%s)\n"
                    "    FilterSpinLock         @ %p (%s)\n"
                    "    LogListResource        @ %p (%s)\n"
                    "    TciIfResource          @ %p (%s)\n"
                    "    DateHeaderResource     @ %p (%s)\n",
                    dataAddress,
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, IrpContextLookaside ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, ReceiveBufferLookaside ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, ResourceLookaside ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, ConfigGroupResource ),
                    BuildResourceState( &data.ConfigGroupResource, configGroupResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, AppPoolResource ),
                    BuildResourceState( &data.AppPoolResource, appPoolResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, DisconnectResource ),
                    BuildResourceState( &data.DisconnectResource, disconnectResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, UriZombieResource ),
                    BuildResourceState( &data.UriZombieResource, uriZombieResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, FilterSpinLock ),
                    GetSpinlockState( &data.FilterSpinLock ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, LogListResource ),
                    BuildResourceState( &data.LogListResource, logListResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, TciIfcResource ),
                    BuildResourceState( &data.TciIfcResource, tciIfcResource ),
                    REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, DateHeaderResource ),
                    BuildResourceState( &data.DateHeaderResource, dateHeaderResource )
                    );
            }
            else
            {
                dprintf(
                    "glob: cannot read memory for http!g_pUlNonpagedData = %p\n",
                    dataAddress
                    );
            }
        }
        else
        {
            dprintf(

                "glob: cannot read memory for http!g_pUlNonpagedData @ %p\n",
                address
                );
        }
    }

}   // glob
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\help.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    help.c

Abstract:

    Help for http.sys Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 17-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// The following structure defines the text displayed in response
// to the "!help" command. This text may also be displayed if invalid
// arguments are passed to a command.
//

typedef struct _HELP_MAP {

    //
    // This is the name of the command.
    //

    PSTR Command;

    //
    // This is a "one-liner" displayed when the user executes "!help".
    //

    PSTR OneLiner;

    //
    // This is the full help text displayed when the user executes
    // "!help <cmd>".
    //

    PSTR FullHelp;

} HELP_MAP, *PHELP_MAP;


HELP_MAP HelpMaps[] =
    {
        {
            "help",
            "Dump this list or help for specific command",
            "help [<cmd>] - Dump help for command\n"
            "  If no <cmd> is given, a list of all available commands is displayed\n"
        },

        {
            "ds",
            "Dump stack with symbols",
            "!ds [-v] <addr>  - Dump symbols on stack\n"
            "    -v == print valid symbols only\n"
            "    default addr == current stack pointer\n"
        },

        {
            "ref",
            "Dump reference trace log",
            "!ref <addr> [context [flags]] - Dump reference trace log at <addr>\n"
            "    context - if != 0, print only traces with matching context\n"
            "    flags   - if == 1, print process, thread, caller, callers caller\n"
            "!ref -l - Dump all reftrace action codes\n"
        },

        {
            "tref",
            "Dump reference trace log, by thread",
            "!tref <addr> [thread [flags]] - Dump reference trace log at <addr>, by thread\n"
            "    thread - if != 0, print only traces with matching thread\n"
            "    flags  - if == 1, print process, thread, caller, callers caller\n"
        },

        {
            "ownref",
            "Dump owner reference trace log",
            "!ownref [-o ] [ -r ] [ -v] <addr> [context] - Dump owner reference trace log at <addr>\n"
            // "    -g == list *all* owner reftrace logs (g_OwnerRefTraceLogGlobalListHead)\n"
            "    -v == Verbose\n"
            "    -O == list all Owners of current reftraced object (verbosity =-v)\n"
            "    -o == dump REF_OWNER at <addr>\n"
            "    -r == list Reftraces (dump reftrace log)\n"
            "    context - if non-zero, print only traces with matching owner\n"
        },

        {
            "thrdpool",
            "Dump UL_THREAD_POOL",
            "!thrdpool <addr> - Dump UL_THREAD_POOL at <addr>\n"
            "    default addr == http!g_UlThreadPool\n"
        },

        {
            "endp",
            "Dump UL_ENDPOINT",
            "!endp [-v | -c] *      - Dump all UL_ENDPOINTs\n"
            "!endp [-v | -c] <addr> - Dump UL_ENDPOINT at <addr>\n"
            "    -c == connections: briefly print all active and idle connections\n"
            "    -v == verbose: verbosely print all active and idle connections\n"
        },

        {
            "ulconn",
            "Dump UL_CONNECTION",
            "!ulconn <addr> - Dump UL_CONNECTION at <addr>\n"
        },

        {
            "ulreq",
            "Dump UL_HTTP_REQUEST",
            "!ulreq <addr> - Dump UL_HTTP_REQUEST at <addr>\n"
        },

        {
            "buff",
            "Dump UL_RECEIVE_BUFFER",
            "!buff <addr> - Dump UL_RECEIVE_BUFFER at <addr>\n"
        },

        {
            "httpconn",
            "Dump HTTP_CONNECTION",
            "!httpconn <addr> - Dump HTTP_CONNECTION at <addr>\n"
        },

        {
            "httpreq",
            "Dump HTTP_REQUEST",
            "!httpreq <addr> - Dump HTTP_REQUEST at <addr>\n"
        },

        {
            "httpres",
            "Dump UL_INTERNAL_HTTP_RESPONSE",
            "!httpres <addr> - Dump UL_INTERNAL_HTTP_RESPONSE at <addr>\n"
        },

        {
            "file",
            "Dump UL_FILE_CACHE_ENTRY",
            "!file <addr> - Dump UL_FILE_CACHE_ENTRY at <addr>\n"
        },

        {
            "glob",
            "Dump critical UL global data",
            "!glob - Dump critical UL global data\n"
        },

        {
            "uriglob",
            "Dump URI Cache global data",
            "!uriglob - Dump URI Cache global data\n"
        },

        {
            "uri",
            "Dump UL_URI_CACHE_ENTRY",
            "!uri <addr> - Dump UL_URI_CACHE_ENTRY at <addr>\n"
            "!uri *      - Dump all UL_URI_CACHE_ENTRYs\n"
        },

        {
            "resource",
            "Dump all resources",
            "!resource [-v] - Dump all (locked) resources\n"
            "    -v == Dump all resources (including unlocked)\n"
        },

        {
            "reqbuff",
            "Dump UL_REQUEST_BUFFER",
            "!reqbuff <addr> - Dump UL_REQUEST_BUFFER at <addr>\n"
        },

        {
            "irplog",
            "Dump the IRP trace log",
            "!irplog [<ctx> [flags [StartingIndex]]] - Dump the IRP trace log\n"
            "    If <ctx> is specified, only log entries with matching context are dumped\n"
            "    flags - TBD\n"
            "    StartingIndex - TBD\n"
        },

        {
            "timelog",
            "Dump the timing trace log",
            "!timelog [<ctx>] - Dump the timing trace log\n"
            "    If <ctx> is specified, only log entries with matching conn id are dumped\n"
        },

        {
            "replog",
            "Dump the replenish trace log",
            "!replog [<ctx>] - Dump the replenish trace log\n"
            "    If <ctx> is specified, only log entries with matching endpoint are dumped\n"
        },

        {
            "fqlog",
            "Dump the filter queue trace log",
            "!fqlog [<ctx>] - Dump the filter queue trace log\n"
            "    If <ctx> is specified, only log entries with matching connection are dumped\n"
        },

        {
            "opaqueid",
            "Dump the Opaque ID table",
            "!opaqueid - Dump the Opaque ID table\n"
        },

        {
            "mdl",
            "Dump MDL",
            "!mdl <addr> [<len>] - Dump MDL at <addr>\n"
            "    If <len> specified, at most <len> raw bytes are dumped from the MDL\n"
            "    If <len> not specified, no raw data is dumped\n"
        },

        {
            "apool",
            "Dump UL_APP_POOL_OBJECT",
            "!apool <addr> - Dump UL_APP_POOL_OBJECT at <addr>\n"
            "!apool *      - Dump all UL_APP_POOL_OBJECTs\n"
        },

        {
            "proc",
            "Dump UL_APP_POOL_PROCESS",
            "!proc <addr> - Dump UL_APP_POOL_PROCESS at <addr>\n"
        },

        {
            "cgroup",
            "Dump UL_CONFIG_GROUP_OBJECT",
            "!cgroup <addr> - Dump UL_CONFIG_GROUP_OBJECT at <addr>\n"
        },

        {
            "cgentry",
            "Dump UL_CG_URL_TREE_ENTRY",
            "!cgentry <addr> - Dump UL_CG_URL_TREE_ENTRY at <addr>\n"
        },

        {
            "cghead",
            "Dump UL_CG_HEADER_ENTRY",
            "!cghead <addr> - Dump UL_CG_HEADER_ENTRY at <addr>\n"
        },

        {
            "cgtree",
            "Dump UL_CG_URL_TREE at <addr> or g_pSites",
            "!cgtree [<addr>] - Dump UL_CG_URL_TREE at <addr> or g_pSites\n"
        },

        {
            "kqueue",
            "Dump KQUEUE",
            "!kqueue <addr> <f> - Dump KQUEUE at <addr>, flags <f>\n"
            "    f == 0 - Only dump the KQUEUE header data\n"
            "    f == 1 - Dump the IRPs queued on the KQUEUE\n"
        },

        {
            "procirps",
            "BUGBUG - This extension is broken in Whistler!",
            "!procirps <addr> - Dump all IRPs issued by process @ <addr>\n"
        },

        {
            "filter",
            "Dumps a UL_FILTER_CHANNEL at <addr> or g_pFilterChannel",
            "!filter [<addr>] - Dump a UL_FILTER_CHANNEL.\n"
        },
        
        {
            "fproc",
            "Dumps a UL_FILTER_PROCESS at <addr>\n",
            "!fproc <addr> - Dump a UL_FILTER_PROCESS.\n"
        },

        {
            "ulhash",
            "Dump URI Cache Hash Table",
            "!ulhash - Dump URI Cache Hash Table\n"
        }   
    };

#define NUM_HELP_MAPS DIM(HelpMaps)

PSTR
FindHelpForCommand(
    IN PCSTR CommandName
    )
{

    PHELP_MAP helpMap;
    ULONG i;

    for( i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++ ) {
        if( _stricmp( helpMap->Command, CommandName ) == 0 ) {
            return helpMap->FullHelp;
        }
    }

    return NULL;

}   // FindHelpForCommand


//
// Public functions.
//

VOID
PrintUsage(
    IN PCSTR CommandName
    )
{
    PSTR cmdHelp;
    PHELP_MAP helpMap;
    ULONG i;
    ULONG maxLength;
    ULONG length;

    if (CommandName == NULL)
    {
        //
        // We'll display the one-liners for each command. Start by
        // scanning the commands to find the longest length. This makes the
        // output much prettier without having to manually tweak the
        // columns.
        //

        maxLength = 0;

        for (i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++)
        {
            length = (ULONG)strlen( helpMap->Command );

            if (length > maxLength)
            {
                maxLength = length;
            }
        }

        //
        // Now actually display the one-liners.
        //

        for (i = NUM_HELP_MAPS, helpMap = HelpMaps ; i > 0 ; i--, helpMap++)
        {
            dprintf(
                "!%-*s - %s\n",
                maxLength,
                helpMap->Command,
                helpMap->OneLiner
                );
        }
    }
    else
    {
        //
        // Find a specific command and display the full help.
        //

        cmdHelp = FindHelpForCommand( CommandName );

        if (cmdHelp == NULL)
        {
            dprintf( "unrecognized command %s\n", CommandName );
        }
        else
        {
            dprintf( "%s", cmdHelp );
        }
    }

} // PrintUsage()


DECLARE_API( help )

/*++

Routine Description:

    Displays help for the UL.SYS Kernel Debugger Extensions.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SNAPSHOT_EXTENSION_DATA();

    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    if (!strcmp( args, "?" ))
    {
        args = "help";
    }

    if (*args == '\0')
    {
        args = NULL;
    }

    PrintUsage( args );

}   // help
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\kddata.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    data.h

Abstract:

    Global data definitions for the UL.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 17-Jun-1998.

Environment:

    User Mode.

--*/


#ifndef _KDDATA_H_
#define _KDDATA_H_

#ifdef __cplusplus
extern "C" {
#endif


extern EXT_API_VERSION        ApiVersion;
extern WINDBG_EXTENSION_APIS  ExtensionApis;
extern USHORT                 SavedMajorVersion;
extern USHORT                 SavedMinorVersion;


//
// Snapshot from the extension routines.
//

extern HANDLE                 g_hCurrentProcess;
extern HANDLE                 g_hCurrentThread;
extern ULONG_PTR              g_dwCurrentPc;
extern ULONG                  g_dwProcessor;

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _KDDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\httpres.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    httpres.c

Abstract:

    Dumps UL_HTTP_REQUEST structures.

Author:

    Michael Courage (MCourage) 29-Oct-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Public functions.
//

DECLARE_API( httpres )

/*++

Routine Description:

    Dumps UL_INTERNAL_RESPONSE structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    UL_INTERNAL_RESPONSE response;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "httpres" );
        return;
    }

    //
    // Read the request header.
    //

    if (!ReadMemory(
            address,
            &response,
            sizeof(response),
            &result
            ))
    {
        dprintf(
            "httpres: cannot read UL_INTERNAL_RESPONSE @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpHttpResponse(
        "",
        "httpres: ",
        address,
        &response
        );

}   // httpres
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\irp.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    irp.c

Abstract:

    Implements the irplog command.

Author:

    Keith Moore (keithmo) 10-Aug-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private globals.
//

PSTR g_pIrpActions[] =
    {
        "INCOMING",
        "ALLOCATE",
        "FREE    ",
        "CALL    ",
        "COMPLETE"
    };

C_ASSERT( DIM(g_pIrpActions) == IRP_ACTION_COUNT );


//
//  Public functions.
//

DECLARE_API( irplog )

/*++

Routine Description:

    Dumps the IRP trace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR           address = 0;
    ULONGLONG           context = 0;
    ULONGLONG           flags = 0;
    ULONG_PTR           entryAddress;
    ULONG_PTR           logPointer;
    ULONG               result;
    TRACE_LOG           logHeader;
    LONGLONG            numEntries;
    IRP_TRACE_LOG_ENTRY logEntry;
    PSTR                pFileName;
    PSTR                pAction;
    LONGLONG            index;
    LONGLONG            StartingIndex = 0;
    ULONG_PTR           offset1;
    ULONG_PTR           offset2;
    CHAR                filePath[MAX_PATH];
    CHAR                symbol1[MAX_SYMBOL_LENGTH];
    CHAR                symbol2[MAX_SYMBOL_LENGTH];
    CHAR                invalidAction[sizeof("2047")];
    ULONG64             context64 = 0;
    ULONG64             flags64 = 0;
    ULONG64             StartingIndex64 = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the optional context, flags, and StartingIndex from the command line.
    //

    if (GetExpressionEx(args, &context64, &args))
        if (GetExpressionEx(args, &flags64, &args))
            GetExpressionEx(args, &StartingIndex64, &args);

    context = (ULONG_PTR) context64;
    flags = (ULONG_PTR) flags64;
    StartingIndex = (ULONG_PTR) StartingIndex64;

    //
    // Find the log.
    //

    address = GetExpression( "&http!g_pIrpTraceLog" );

    if (address == 0)
    {
        dprintf( "irplog: cannot find http!g_pIrpTraceLog\n" );
        return;
    }

    //
    // Read the pointer.
    //

    if (!ReadMemory(
            address,
            &logPointer,
            sizeof(logPointer),
            &result
            ))
    {
        dprintf(
            "irplog: cannot read PTRACE_LOG @ %p\n",
            address
            );
        return;
    }

    //
    // Read the log header.
    //

    if (!ReadMemory(
            logPointer,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "ref: cannot read TRACE_LOG @ %p\n",
            logPointer
            );
        return;
    }

    dprintf(
        "ref: log @ %p\n"
        "    Signature = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx '%c%c%c%c'\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %I64d\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        address,
        logHeader.Signature,
        DECODE_SIGNATURE(logHeader.Signature),
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TypeSignature,
        DECODE_SIGNATURE(logHeader.TypeSignature),
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.pLogBuffer
        );

   if (logHeader.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader) ))
   {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X)
    {
        dprintf(
            "irplog: log @ %p has invalid signature %08lx:\n",
            address,
            logHeader.Signature
            );
        return;
    }

    if (logHeader.EntrySize != sizeof(logEntry)
        || logHeader.TypeSignature != IRP_TRACE_LOG_SIGNATURE)
    {
        dprintf(
            "irplog: log @ %p is not an IRP trace log\n",
            address
            );
        return;
    }

    if (logHeader.NextEntry == -1)
    {
        dprintf(
            "irplog: empty log @ %p\n",
            address
            );
        return;
    }

    //
    // Calculate the log size to dump.
    //

    if (logHeader.NextEntry < logHeader.LogSize)
    {
        numEntries = logHeader.NextEntry + 1;
        index = 0;
    }
    else
    {
        numEntries = logHeader.LogSize;
        index = (logHeader.NextEntry + 1) % logHeader.LogSize;
    }

    entryAddress = (ULONG_PTR)logHeader.pLogBuffer +
        (ULONG_PTR)( index * sizeof(logEntry) );

    if (entryAddress >=
        ( (ULONG_PTR)logHeader.pLogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) )
    {
        dprintf(
            "irplog: log @ %p has invalid data\n",
            address
            );
        return;
    }

    if ((flags & 4) && (StartingIndex!=0) && (StartingIndex<numEntries))
    {
        index = StartingIndex;
        entryAddress += (ULONG_PTR)(sizeof(logEntry)*index);
        numEntries -= StartingIndex;
    }
    
    //
    // Dump the log.
    //

    for (;
         numEntries > 0 ;
         index++,
         numEntries--,
         entryAddress += sizeof(logEntry))
     {
        if (CheckControlC())
        {
            break;
        }

        if (index >= logHeader.LogSize)
        {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.pLogBuffer;
        }

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "irplog: cannot read memory @ %p\n",
                entryAddress
                );
            return;
        }

        if (context == 0 ||
            context == (ULONG_PTR)logEntry.pIrp)
        {
            if (ReadMemory(
                    (ULONG_PTR)logEntry.pFileName,
                    filePath,
                    sizeof(filePath),
                    &result
                    ))
            {
                pFileName = strrchr( filePath, '\\' );

                if (pFileName != NULL)
                {
                    pFileName++;
                }
                else
                {
                    pFileName = filePath;
                }
            }
            else
            {
                sprintf(
                    filePath,
                    "%p",
                    logEntry.pFileName
                    );

                pFileName = filePath;
            }

            if (logEntry.Action < IRP_ACTION_COUNT)
            {
                pAction = g_pIrpActions[logEntry.Action];
            }
            else
            {
                sprintf( invalidAction, "%lu", (ULONG)logEntry.Action );
                pAction = invalidAction;
            }

            dprintf(
                "Entry=%lu CPU=%lu IRP=%p Act=%s Src=%s:%lu\n",
                index,
                (ULONG)logEntry.Processor,
                logEntry.pIrp,
                pAction,
                pFileName,
                logEntry.LineNumber
                );

            if (flags & 1)
            {
                GetSymbol(
                    logEntry.pCaller,
                    symbol1,
                    &offset1
                    );

                GetSymbol(
                    logEntry.pCallersCaller,
                    symbol2,
                    &offset2
                    );

                dprintf(
                    "      Process=%p Thread=%p\n"
                    "      Caller1=%p (%s+0x%p)\n"
                    "      Caller2=%p (%s+0x%p)\n",
                    logEntry.pProcess,
                    logEntry.pThread,
                    logEntry.pCaller,
                    symbol1,
                    offset1,
                    logEntry.pCallersCaller,
                    symbol2,
                    offset2
                    );
            }

#if ENABLE_IRP_CAPTURE
            if (flags & 2)
            {
                CHAR temp[sizeof("1234567812345678 f")];

                sprintf(
                    temp,
                    "%p",
                    REMOTE_OFFSET(
                        entryAddress,
                        IRP_TRACE_LOG_ENTRY,
                        CapturedIrp
                        )
                    );

                if (flags & 4)
                {
                    strcat( temp, " f" );
                }

                CallExtensionRoutine( "irp", temp );
            }
#endif
        }
    }

}   // irplog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\httpreq.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    httpreq.c

Abstract:

    Dumps UL_HTTP_REQUEST structures.

Author:

    Keith Moore (keithmo) 31-Jul-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Public functions.
//

DECLARE_API( ulreq )

/*++

Routine Description:

    Dumps HTTP_REQUEST structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    HTTP_REQUEST request;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "ulreq" );
        return;
    }

    //
    // Read the request header.
    //

    if (!ReadMemory(
            address,
            &request,
            sizeof(request),
            &result
            ))
    {
        dprintf(
            "ulreq: cannot read HTTP_REQUEST @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpUlRequest(
        "",
        "ulreq: ",
        address,
        &request
        );

}   // ulreq
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\kqueue.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    kqueue.c

Abstract:

    Dumps KQUEUEs.

Author:

    Keith Moore (keithmo) 11-Nov-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Public functions.
//

DECLARE_API( kqueue )

/*++

Routine Description:

    Dumps KQUEUEs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    ULONG_PTR flags = 0;
    KQUEUE localKQueue;
    ULONG64 address64 = 0, flags64 = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    if (! GetExpressionEx(args, &address64, &args))
    {
        PrintUsage( "kqueue" );
        return;
    }

    GetExpressionEx(args, &flags64, &args);

    address = (ULONG_PTR) address64;
    flags = (ULONG_PTR) flags64;

    //
    // Read the kqueue.
    //

    if (!ReadMemory(
            address,
            &localKQueue,
            sizeof(localKQueue),
            &result
            ))
    {
        dprintf(
            "kqueue: cannot read KQUEUE @ %p\n",
            address
            );
        return;
    }

    DumpKernelQueue(
        "",
        "kqueue: ",
        address,
        &localKQueue,
        (ULONG)flags
        );

}   // kqueue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\kdexts.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Keith Moore (keithmo) 17-Jun-1998.

--*/

#include "precomp.h"

// #include <ntverp.h>
// #include <imagehlp.h>

//
// globals
//

EXT_API_VERSION        ApiVersion =
    {
        (VER_PRODUCTVERSION_W >> 8),
        (VER_PRODUCTVERSION_W & 0xFF),
        EXT_API_VERSION_NUMBER,
        0
    };

WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;

//
// Snapshot from the extension routines.
//

HANDLE                 g_hCurrentProcess;
HANDLE                 g_hCurrentThread;
ULONG_PTR              g_dwCurrentPc;
ULONG                  g_dwProcessor;


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    SNAPSHOT_EXTENSION_DATA();

    dprintf(
        "%s Extension dll for Build %s debugging %s kernel for Build %d\n",
        DebuggerType,
        VER_PRODUCTVERSION_STR,
        SavedMajorVersion == 0x0c
            ? "Checked"
            : "Free",
        SavedMinorVersion
        );
}

VOID
CheckVersion(
    VOID
    )
{
#if 0
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD))
    {
        dprintf(
            "\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f)
                ? "Free"
                : "Checked"
            );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD))
    {
        dprintf(
            "\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
            VER_PRODUCTBUILD,
            SavedMinorVersion,
            (SavedMajorVersion==0x0f)
                ? "Free"
                : "Checked"
            );
    }
#endif
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\lock.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    lock.c

Abstract:

    Implements the !resource command.

Author:

    Keith Moore (keithmo) 16-Jun-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private types.
//

typedef struct _LOCK_OPTIONS
{
    BOOLEAN Verbose;

} LOCK_OPTIONS, *PLOCK_OPTIONS;


//
// Private prototypes.
//

BOOLEAN
DumpResourceCallback(
    IN PLIST_ENTRY pRemoteListEntry,
    IN PVOID pContext
    );


//
// Public functions.
//

DECLARE_API( resource )

/*++

Routine Description:

    Dumps all resources.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address;
    ULONG result;
    LOCK_OPTIONS options;

    SNAPSHOT_EXTENSION_DATA();

    if (!IsThisACheckedBuild() || !DBG)
    {
        dprintf( "resource: command valid on checked builds only!\n" );
        return;
    }

#if DBG
    //
    // Process the arguments.
    //

    options.Verbose = FALSE;

    if (_strnicmp( args, "-v", 2 ) == 0)
    {
        options.Verbose = TRUE;
    }

    //
    // Snag the list head address.
    //

    address = GetExpression( "&http!g_DbgGlobalResourceListHead" );

    if (address == 0)
    {
        dprintf( "resource: cannot find http!g_DbgGlobalResourceListHead\n" );
        return;
    }

    EnumLinkedList(
        (PLIST_ENTRY)address,
        &DumpResourceCallback,
        &options
        );
#endif

}   // resource


//
// Private functions.
//

BOOLEAN
DumpResourceCallback(
    IN PLIST_ENTRY pRemoteListEntry,
    IN PVOID pContext
    )
{
#if DBG
    PLOCK_OPTIONS pOptions;
    UL_ERESOURCE localResource;
    PUL_ERESOURCE pRemoteResource;
    ULONG result;
    BOOLEAN lockHeld;
    CHAR resourceState[MAX_RESOURCE_STATE_LENGTH];

    pOptions = (PLOCK_OPTIONS)pContext;

    pRemoteResource = CONTAINING_RECORD(
                            pRemoteListEntry,
                            UL_ERESOURCE,
                            GlobalResourceListEntry
                            );

    if (!ReadMemory(
            (ULONG_PTR)pRemoteResource,
            &localResource,
            sizeof(localResource),
            &result
            ))
    {
        dprintf( "resource: cannot read UL_ERESOURCE @ %p\n", pRemoteResource );
        return FALSE;
    }

    lockHeld = localResource.Resource.ActiveCount != 0;

    if (pOptions->Verbose || lockHeld)
    {
        dprintf(
            "UL_ERESOURCE @ %p\n"
            "    Resource                @ %p (%s)\n"
            "    GlobalResourceListEntry @ %p\n"
            "    pExclusiveOwner         = %p\n"
            "    pPreviousOwner          = %p\n"
            "    ExclusiveCount          = %lu\n"
            "    SharedCount             = %lu\n"
            "    ReleaseCount            = %lu\n"
            "    ContentionCount         = %lu\n"
            "    ResourceName            = %s\n"
            "    OwnerTag                = %08lx\n"
            "\n",
            pRemoteResource,
            REMOTE_OFFSET( pRemoteResource, UL_ERESOURCE, Resource ),
            BuildResourceState( &localResource, resourceState ),
            REMOTE_OFFSET( pRemoteResource, UL_ERESOURCE, GlobalResourceListEntry ),
            localResource.pExclusiveOwner,
            localResource.pPreviousOwner,
            localResource.ExclusiveCount,
            localResource.SharedCount,
            localResource.ReleaseCount,
            localResource.Resource.ContentionCount,
            localResource.ResourceName,
            localResource.OwnerTag
            );
    }
#endif

    return TRUE;

}   // DumpResourceCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\ownref.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    ownref.c

Abstract:

    Implements the ownref command.

Author:

    George V. Reilly (GeorgeRe)  23-Jan-2001

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"

typedef struct _REF_OWNER_GLOBAL_CALLBACK_CONTEXT
{
    ULONG           Signature;
    LONG            Index;
    BOOLEAN         Verbose;
    PSTR            Prefix;
} REF_OWNER_GLOBAL_CALLBACK_CONTEXT, *PREF_OWNER_GLOBAL_CALLBACK_CONTEXT;

#define REF_OWNER_GLOBAL_CALLBACK_CONTEXT_SIGNATURE ((ULONG) 'xGOR')


BOOLEAN
DumpOwnerRefTraceLog(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;
    ULONG result;
    OWNER_REF_TRACELOG logHeader;
    PREF_OWNER_GLOBAL_CALLBACK_CONTEXT pCtxt
        = (PREF_OWNER_GLOBAL_CALLBACK_CONTEXT) Context;

    ASSERT(pCtxt->Signature == REF_OWNER_GLOBAL_CALLBACK_CONTEXT_SIGNATURE);

    address = (ULONG_PTR) CONTAINING_RECORD(
                                RemoteListEntry,
                                OWNER_REF_TRACELOG,
                                OwnerHeader.GlobalListEntry
                                );

    if (!ReadMemory(
            address,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        return FALSE;
    }

    dprintf("OWNER_REF_TRACELOG[%d] @ %p\n", ++pCtxt->Index, address);

    return TRUE;
} // DumpOwnerRefTraceLog


#if 0

VOID
DumpOwnerRefTraceLogGlobalList(
    IN BOOLEAN              Verbose
    )
{
    REF_OWNER_GLOBAL_CALLBACK_CONTEXT Context;

    Context.Signature = REF_OWNER_GLOBAL_CALLBACK_CONTEXT_SIGNATURE ;
    Context.Verbose = Verbose;
    Context.Prefix = "";
    Context.Index  = 0;
"&http!g_OwnerRefTraceLogGlobalListHead"
    dprintf(
        "\n"
        "    OWNER_REF_TRACELOG @ %p: %d owners\n",
        RemoteAddress,
        plogHeader->OwnerHeader.OwnersCount
        );
    
    EnumLinkedList(
        (PLIST_ENTRY)REMOTE_OFFSET(
            RemoteAddress,
            OWNER_REF_TRACELOG,
            OwnerHeader.ListHead
            ),
        &DumpOwnerRefTraceLogOwnerCallback,
        &Context
        );
} // DumpOwnerRefTraceLogGlobalList

#endif


typedef struct _REF_OWNER_CALLBACK_CONTEXT
{
    ULONG           Signature;
    LONG            Index;
    BOOLEAN         Verbose;
    PSTR            Prefix;
    LONG            TotalRefs;
} REF_OWNER_CALLBACK_CONTEXT, *PREF_OWNER_CALLBACK_CONTEXT;

#define REF_OWNER_CALLBACK_CONTEXT_SIGNATURE ((ULONG) 'xCOR')


BOOLEAN
DumpOwnerRefTraceLogOwner(
    IN ULONG_PTR                   address,
    IN PREF_OWNER_CALLBACK_CONTEXT pCtxt
    )
{
    ULONG result;
    REF_OWNER RefOwner;
    LONG  index;
    ULONG index2;

    ASSERT(pCtxt->Signature == REF_OWNER_CALLBACK_CONTEXT_SIGNATURE);

    if (!ReadMemory(
            address,
            &RefOwner,
            sizeof(RefOwner),
            &result
            ))
    {
        return FALSE;
    }

    if (RefOwner.Signature != OWNER_REF_SIGNATURE)
    {
        dprintf(
            "Invalid REF_OWNER @ %p: signature = '%c%c%c%c'\n",
            address,
            DECODE_SIGNATURE(RefOwner.Signature)
            );

        return FALSE;
    }

    pCtxt->TotalRefs += RefOwner.RelativeRefCount;

    dprintf(
        "%s\tREF_OWNER[%3d] @ %p:"
        " pOwner=%p '%c%c%c%c',"
        " RelativeRefCount=%d,"
        " OwnedNextEntry=%d.\n"
        ,
        pCtxt->Verbose ? "\n" : "",
        pCtxt->Index++,
        address,
        RefOwner.pOwner,
        DECODE_SIGNATURE(RefOwner.OwnerSignature),
        RefOwner.RelativeRefCount,
        RefOwner.OwnedNextEntry
        );

    if (RefOwner.OwnedNextEntry == -1  ||  !pCtxt->Verbose)
        return TRUE;

    index  = max( 0, (RefOwner.OwnedNextEntry + 1) - OWNED_REF_NUM_ENTRIES );
    index2 = index % OWNED_REF_NUM_ENTRIES;

    for ( ;
         index <= RefOwner.OwnedNextEntry;
         index++, index2++
        )
    {
        if (CheckControlC())
        {
            break;
        }

        if (index2 >= OWNED_REF_NUM_ENTRIES)
            index2 = 0;

        dprintf(
            "\t\t%8ld: RefIndex=%6I64d, MonotonicId=%ld, Act=%s\n",
            index,
            RefOwner.RecentEntries[index2].RefIndex,
            RefOwner.RecentEntries[index2].MonotonicId,
            Action2Name(RefOwner.RecentEntries[index2].Action)
            );
     }

    return TRUE;
} // DumpOwnerRefTraceLogOwner


BOOLEAN
DumpOwnerRefTraceLogOwnerCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address = (ULONG_PTR) CONTAINING_RECORD(
                                RemoteListEntry,
                                REF_OWNER,
                                ListEntry
                                );
    PREF_OWNER_CALLBACK_CONTEXT pCtxt = (PREF_OWNER_CALLBACK_CONTEXT) Context;

    return DumpOwnerRefTraceLogOwner(address, pCtxt);
} // DumpOwnerRefTraceLogOwnerCallback



VOID
DumpOwnerRefTraceLogOwnersList(
    IN POWNER_REF_TRACELOG  plogHeader,
    IN ULONG_PTR            RemoteAddress,
    IN BOOLEAN              Verbose
    )
{
    REF_OWNER_CALLBACK_CONTEXT Context;

    Context.Signature = REF_OWNER_CALLBACK_CONTEXT_SIGNATURE ;
    Context.Verbose = Verbose;
    Context.Prefix = "";
    Context.Index  = 0;
    Context.TotalRefs = 0;

    dprintf(
        "\n"
        "    OWNER_REF_TRACELOG @ %p: %d owners\n",
        RemoteAddress,
        plogHeader->OwnerHeader.OwnersCount
        );
    
    EnumLinkedList(
        (PLIST_ENTRY) REMOTE_OFFSET(
            RemoteAddress,
            OWNER_REF_TRACELOG,
            OwnerHeader.ListHead
            ),
        &DumpOwnerRefTraceLogOwnerCallback,
        &Context
        );

    dprintf("\nTotal RefCount = %d\n\n", Context.TotalRefs);
    
} // DumpOwnerRefTraceLogOwnersList


VOID
DumpOwnerRefTraceLogData(
    IN POWNER_REF_TRACELOG  plogHeader,
    IN ULONG_PTR            RemoteAddress,
    IN BOOLEAN              Verbose,
    IN ULONG_PTR            context
    )
{
    OWNER_REF_TRACE_LOG_ENTRY   logEntry;
    ULONG_PTR                   entryAddress;
    CHAR                        filePath[MAX_PATH];
    PSTR                        fileName;
    PVOID                       pPrevFilePath;
    CHAR                        symbol1[MAX_SYMBOL_LENGTH];
    CHAR                        symbol2[MAX_SYMBOL_LENGTH];
    ULONG                       result;
    ULONG                       Dumped = 0;
    ULONG                       NonMatch = 0;
    ULONG                       NumToDump = plogHeader->TraceLog.LogSize;

    LONGLONG                    index = max( 0, ((plogHeader->TraceLog.NextEntry + 1)
                                    - NumToDump) );

    ULONGLONG                   index2 = index % plogHeader->TraceLog.LogSize;
    ULONGLONG                   index1000 = index % 1000;


    entryAddress = (ULONG_PTR) plogHeader->TraceLog.pLogBuffer +
            (ULONG_PTR)( index2 * sizeof(logEntry) );

    pPrevFilePath = NULL;
    *filePath = '\0';

    //
    // Dump the log.
    //

    dprintf(
        "\n"
        "    OWNER_REF_TRACELOG @ %p: dumping entries[%I64d-%I64d]",
        RemoteAddress,
        index,
        plogHeader->TraceLog.NextEntry
        );

    if (context != 0)
        dprintf(", filtering on owner=%p", context);
    
    dprintf("\n");

    for ( ;
         index <= plogHeader->TraceLog.NextEntry;
         index++,
         index2++,
         index1000++,
         entryAddress += sizeof(logEntry)
        )
    {
        if (CheckControlC())
        {
            break;
        }

        if (index2 >= (ULONG)(plogHeader->TraceLog.LogSize))
        {
            index2 = 0;
            entryAddress = (ULONG_PTR) plogHeader->TraceLog.pLogBuffer;
        }

        if (index1000 >= 1000)
            index1000 = 0;

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "ownref: cannot read memory @ %p\n",
                entryAddress
                );
            return;
        }

        if (context == 0 || context == (ULONG_PTR)logEntry.pOwner)
        {
            if (logEntry.pFileName != pPrevFilePath)
            {
                if (ReadMemory(
                        (ULONG_PTR)logEntry.pFileName,
                        filePath,
                        sizeof(filePath),
                        &result
                        ))
                {
                    fileName = strrchr( filePath, '\\' );
                    
                    if (fileName != NULL)
                    {
                        fileName++;
                    }
                    else
                    {
                        fileName = filePath;
                    }

                    pPrevFilePath = logEntry.pFileName;
                }
                else
                {
                    sprintf(
                        filePath,
                        "%p",
                        logEntry.pFileName
                        );
                    
                    fileName = filePath;
                }
            }

            dprintf(
                "%s%4I64d: Own=%p Act=%2lu %-30s Ref=%4d Src=%s:%lu\n",
                (NonMatch > 0) ? "\n" : "",
                index,
                logEntry.pOwner,
                (ULONG)logEntry.Action,
                Action2Name(logEntry.Action),
                logEntry.NewRefCount,
                fileName,
                (ULONG)logEntry.LineNumber
                );

            ++Dumped;
            NonMatch = 0;
        }
        else
        {
            if (index1000 == 0)
                dprintf("%d", index);
            
            if ((++NonMatch & 127) == 127)
                dprintf(".");
        }
    }

    if (context != 0)
        dprintf("%d entries dumped\n\n", Dumped);

} // DumpOwnerRefTraceLogData



//
//  Public functions.
//

DECLARE_API( ownref )

/*++

Routine Description:

    Dumps the owner reference trace log at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG_PTR context = 0;
    ULONG64 address64 = 0, context64 = 0;
    ULONG result;
    OWNER_REF_TRACELOG logHeader;
    CHAR strSignature[MAX_SIGNATURE_LENGTH];
    BOOLEAN ListGlobal = FALSE; // CODEWORK
    BOOLEAN ListAllOwners = FALSE;
    BOOLEAN ListOneOwner = FALSE;
    BOOLEAN ListRefs = FALSE;
    BOOLEAN Verbose = FALSE;

    SNAPSHOT_EXTENSION_DATA();

    // Parse any leading flags
    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    if (*args == '-')
    {
        args++;

        switch (*args)
        {
        case 'g' :
            ListGlobal = TRUE;
            args++;
            break;

        case 'O' :
            ListAllOwners = TRUE;
            args++;
            break;

        case 'o' :
            ListOneOwner = TRUE;
            args++;
            break;

        case 'r' :
            ListRefs = TRUE;
            args++;
            break;

        case 'v' :
            Verbose = TRUE;
            args++;
            break;

        default :
            PrintUsage( "ownref" );
            return;
        }
    }

    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    //
    // Snag the address and optional context from the command line.
    //

    if (! GetExpressionEx(args, &address64, &args))
    {
        PrintUsage( "ownref" );
        return;
    }

    GetExpressionEx(args, &context64, &args);

    address = (ULONG_PTR) address64;
    context = (ULONG_PTR) context64;

    //
    // Read the log header.
    //

    if (!ReadMemory(
            address,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "ownref: cannot read OWNER_REF_TRACELOG @ %p\n",
            address
            );
        return;
    }

    if (ListGlobal)
    {
        dprintf("Sorry, -g option not yet implemented.\n"
                "Use: dl http!g_OwnerRefTraceLogGlobalListHead\n");
    }

    if (ListOneOwner)
    {
        REF_OWNER_CALLBACK_CONTEXT Context;

        Context.Signature = REF_OWNER_CALLBACK_CONTEXT_SIGNATURE ;
        Context.Verbose = TRUE;
        Context.Prefix = "";
        Context.Index  = -1;
        Context.TotalRefs = 0;

        DumpOwnerRefTraceLogOwner(address, &Context);

        return;
    }

    dprintf(
        "ownref: log @ %p\n"
        "    Signature     = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx (%s)\n"
        "    LogSize       = %lu\n"
        "    NextEntry     = %I64d\n"
        "    EntrySize     = %lu\n"
        "    LogBuffer     = %p\n"
        "    OwnersCount   = %d\n"
        "    MonotonicId   = %d\n",
        address,
        logHeader.TraceLog.Signature,
        DECODE_SIGNATURE(logHeader.TraceLog.Signature),
        logHeader.TraceLog.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.TraceLog.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TraceLog.TypeSignature,
        SignatureToString(
            logHeader.TraceLog.TypeSignature,
            OWNER_REF_TRACELOG_SIGNATURE,
            0,
            strSignature
            ),
        logHeader.TraceLog.LogSize,
        logHeader.TraceLog.NextEntry,
        logHeader.TraceLog.EntrySize,
        logHeader.TraceLog.pLogBuffer,
        logHeader.OwnerHeader.OwnersCount,
        logHeader.OwnerHeader.MonotonicId
        );

    if (logHeader.TraceLog.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader)))
    {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.TraceLog.TypeSignature != OWNER_REF_TRACELOG_SIGNATURE)
    {
        dprintf(
            "ownref: log @ %p has invalid signature %08lx, '%c%c%c%c':\n",
            address,
            logHeader.TraceLog.TypeSignature,
            DECODE_SIGNATURE(logHeader.TraceLog.TypeSignature)
            );
        return;
    }

    if (logHeader.TraceLog.EntrySize != sizeof(OWNER_REF_TRACE_LOG_ENTRY)
        || logHeader.TraceLog.TypeSignature != OWNER_REF_TRACELOG_SIGNATURE)
    {
        dprintf(
            "ownref: log @ %p is not an owner ref count log\n",
            address
            );
        return;
    }

    if (logHeader.TraceLog.NextEntry == -1)
    {
        dprintf(
            "ownref: empty log @ %p\n",
            address
            );
        return;
    }


    if (Verbose || ListAllOwners)
        DumpOwnerRefTraceLogOwnersList(&logHeader, address, Verbose);

    if (Verbose || ListRefs)
        DumpOwnerRefTraceLogData(&logHeader, address, Verbose, context);

}   // ownref
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\mdl.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    mdl.c

Abstract:

    Dumps MDLs.

Author:

    Keith Moore (keithmo) 20-Oct-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Public functions.
//

DECLARE_API( mdl )

/*++

Routine Description:

    Dumps MDLs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;
    MDL localMdl;
    PSTR command;
    ULONG_PTR maxBytesToDump = 0;
    ULONG64 address64 = 0, maxBytesToDump64 = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    if (! GetExpressionEx(args, &address64, &args))
    {
        PrintUsage( "mdl" );
        return;
    }

    GetExpressionEx(args, &maxBytesToDump64, &args);

    address = (ULONG_PTR) address64;
    maxBytesToDump = (ULONG_PTR) maxBytesToDump64;

    command = "mdl: ";

    for (;;)
    {
        //
        // Read the mdl.
        //

        if (!ReadMemory(
                address,
                &localMdl,
                sizeof(localMdl),
                &result
                ))
        {
            dprintf(
                "mdl: cannot read MDL @ %p\n",
                address
                );
            return;
        }

        DumpMdl(
            "",
            command,
            address,
            &localMdl,
            (ULONG)maxBytesToDump
            );

        address = (ULONG_PTR)localMdl.Next;

        if (address == 0)
        {
            break;
        }

        dprintf( "\n" );
        command = "     ";
    }

}   // mdl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\opaqueid.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    opaqueid.c

Abstract:

    Dumps the Opaque ID table.

Author:

    Keith Moore (keithmo) 10-Sep-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private prototypes.
//


//
// Public functions.
//

DECLARE_API( opaqueid )

/*++

Routine Description:

    Dumps the Opaque ID table.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address;
    UL_ALIGNED_OPAQUE_ID_TABLE OpaqueIdTables[MAXIMUM_PROCESSORS];
    PUL_OPAQUE_ID_TABLE_ENTRY *firstLevelTable = NULL;
    ULONG firstLevelTableInUse;
    ULONG result;
    LONG iSubTable, i, j, k;
    LONG  BaseIdCyclic;
    LONG  SecondaryIdCyclic;
    CHAR  signature[sizeof("1234")];
    UL_OPAQUE_ID_TABLE_ENTRY secondLevelTable[SECOND_LEVEL_TABLE_SIZE];
    UL_OPAQUE_ID_INTERNAL internal;
    LONG NumberOfProcessors;

    SNAPSHOT_EXTENSION_DATA();

    //
    // CODEWORK: Add a read-variable function to encapsulate all of
    // this repetitive goo
    //
    
    //
    // Read the size of the first-level lookup table.
    //

    address = GetExpression( "&http!g_UlOpaqueIdTable" );

    if (address == 0)
    {
        dprintf( "opaqueid: cannot find http!g_UlOpaqueIdTable\n" );
        goto cleanup;
    }

    if (!ReadMemory(
            address,
            &OpaqueIdTables[0],
            sizeof(OpaqueIdTables),
            &result
            ))
    {
        dprintf(
            "opaqueid: cannot read g_UlOpaqueIdTable[0..%u] @ %p\n",
            MAXIMUM_PROCESSORS-1, address
            );
        goto cleanup;
    }

    address = GetExpression( "&http!g_UlNumberOfProcessors" );

    if (address == 0)
    {
        dprintf( "opaqueid: cannot find http!g_UlNumberOfProcessors\n" );
        goto cleanup;
    }

    if (!ReadMemory(
            address,
            &NumberOfProcessors,
            sizeof(NumberOfProcessors),
            &result
            ))
    {
        dprintf(
            "opaqueid: cannot read g_UlNumberOfProcessors @ %p\n",
            address
            );
        goto cleanup;
    }

    dprintf( "(%u subtables)\n\n", NumberOfProcessors);
             
    for (iSubTable = 0;  iSubTable < NumberOfProcessors;  iSubTable++)
    {
        //
        // Allocate and read the first level table.
        //
        firstLevelTableInUse = OpaqueIdTables[iSubTable].OpaqueIdTable.FirstLevelTableInUse;

        firstLevelTable = (PUL_OPAQUE_ID_TABLE_ENTRY*)
            ALLOC( firstLevelTableInUse * sizeof(*firstLevelTable) );

        if (firstLevelTable == NULL)
        {
            dprintf("opaqueid: cannot allocate FirstLevelTable[%u]"
                    " (%u entries)\n",
                    iSubTable, firstLevelTableInUse);
            goto cleanup;
        }

        if (!ReadMemory(
                (ULONG_PTR) OpaqueIdTables[iSubTable].OpaqueIdTable.FirstLevelTable,
                firstLevelTable,
                firstLevelTableInUse * sizeof(*firstLevelTable),
                &result
                ))
        {
            dprintf(
                "opaqueid: cannot read "
                "OpaqueIdTables[%u].FirstLevelTable @ %p\n",
                iSubTable, 
                OpaqueIdTables[iSubTable].OpaqueIdTable.FirstLevelTable
                );
            goto cleanup;
        }

        dprintf( "opaqueid: OpaqueIdTables[%u].FirstLevelTable @ %p\n", 
                 iSubTable, 
                 OpaqueIdTables[iSubTable].OpaqueIdTable.FirstLevelTable);
        
#ifdef OPAQUE_ID_INSTRUMENTATION
        dprintf( "\tNumberOfAllocations=%I64d, NumberOfFrees=%I64d, "
                 "NumberOfTotalGets=%I64d, NumberOfSuccessfulGets=%I64d, "
                 "Reallocs=%d.\n",
                 OpaqueIdTables[iSubTable].OpaqueIdTable.NumberOfAllocations,
                 OpaqueIdTables[iSubTable].OpaqueIdTable.NumberOfFrees,
                 OpaqueIdTables[iSubTable].OpaqueIdTable.NumberOfTotalGets,
                 OpaqueIdTables[iSubTable].OpaqueIdTable.NumberOfSuccessfulGets,
                 firstLevelTableInUse);
#endif // OPAQUE_ID_INSTRUMENTATION

        for (i = 0 ; i < (LONG)firstLevelTableInUse ; i++)
        {
            dprintf( "    SecondLevelTable[%u] @ %p\n",
                     i, firstLevelTable[i] );

            if (!ReadMemory(
                (ULONG_PTR) firstLevelTable[i],
                secondLevelTable,
                sizeof(secondLevelTable),
                &result
                ))
            {
                dprintf( "    cannot read SecondLevelTable[%u] @ %p\n",
                         i, firstLevelTable[i] );
                continue;
            }

            for (j = SECOND_LEVEL_TABLE_SIZE ; --j>= 0 ; )
            {
                if (secondLevelTable[j].OpaqueIdType != UlOpaqueIdTypeInvalid)
                {
                    dprintf(
                        " pContext - %p, "
                        " EntryOpaqueIdCyclic - %x, "
                        " Lock %x, "
                        " OpaqueIdCyclic - %x, "
                        " OpaqueIdType - %d.\n",
                        secondLevelTable[j].pContext,
                        secondLevelTable[j].EntryOpaqueIdCyclic,
                        secondLevelTable[j].Lock,
                        secondLevelTable[j].OpaqueIdCyclic,
                        secondLevelTable[j].OpaqueIdType
                        );
                }
            }
        }

        FREE( firstLevelTable );

        firstLevelTable = NULL;
    }

cleanup:

    if (firstLevelTable != NULL)
    {
        FREE( firstLevelTable );
    }

}   // opaqueid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\proc.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    proc.h

Abstract:

    Global procedure declarations for the UL.SYS Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 17-Jun-1998.

Environment:

    User Mode.

--*/


#ifndef _PROC_H_
#define _PROC_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// Functions from HELP.C.
//

VOID
PrintUsage(
    IN PCSTR CommandName
    );


//
// Functions from DBGUTIL.C.
//

VOID
SystemTimeToString(
    IN LONGLONG Value,
    OUT PSTR Buffer
    );

PSTR
SignatureToString(
    IN ULONG CurrentSignature,
    IN ULONG ValidSignature,
    IN ULONG FreedSignature,
    OUT PSTR Buffer
    );

PSTR
ParseStateToString(
    IN PARSE_STATE State
    );

PSTR
UlEnabledStateToString(
    IN HTTP_ENABLED_STATE State
    );

PSTR
CachePolicyToString(
    IN HTTP_CACHE_POLICY_TYPE PolicyType
    );

PSTR
VerbToString(
    IN HTTP_VERB Verb
    );

PSTR
VersionToString(
    IN HTTP_VERSION Version
    );

PSTR
QueueStateToString(
    IN QUEUE_STATE QueueState
    );

VOID
DumpTransportAddress(
    IN PCHAR Prefix,
    IN PTRANSPORT_ADDRESS Address,
    IN ULONG_PTR ActualAddress
    );

VOID
BuildSymbol(
    IN PVOID RemoteAddress,
    OUT PSTR Symbol
    );

PSTR
GetSpinlockState(
    IN PUL_SPIN_LOCK SpinLock
    );

BOOLEAN
EnumLinkedList(
    IN PLIST_ENTRY RemoteListHead,
    IN PENUM_LINKED_LIST_CALLBACK Callback,
    IN PVOID Context
    );

BOOLEAN
EnumSList(
    IN PSLIST_HEADER RemoteSListHead, 
    IN PENUM_SLIST_CALLBACK Callback,
    IN PVOID Context
    );

PSTR
BuildResourceState(
    IN PUL_ERESOURCE LocalAddress,
    OUT PSTR Buffer
    );

BOOLEAN
IsThisACheckedBuild(
    VOID
    );

VOID
DumpBitVector(
    IN PSTR Prefix1,
    IN PSTR Prefix2,
    IN ULONG Vector,
    IN PVECTORMAP VectorMap
    );

VOID
DumpRawData(
    IN PSTR Prefix,
    IN ULONG_PTR RemoteAddress,
    IN ULONG BufferLength
    );

BOOLEAN
CallExtensionRoutine(
    IN PSTR RoutineName,
    IN PSTR ArgumentString
    );


//
// Dump routines from DUMPERS.C.
//

VOID
DumpUlConnection(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONNECTION LocalConnection
    );

VOID
DumpUlConnectionLite(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONNECTION LocalConnection
    );

VOID
DumpHttpConnection(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_CONNECTION LocalConnection
    );

VOID
DumpHttpRequest(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_REQUEST LocalRequest
    );

VOID
DumpHttpResponse(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_RESPONSE LocalResponse
    );

VOID
DumpDataChunk(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_INTERNAL_DATA_CHUNK Chunk
    );

VOID
DumpReceiveBuffer(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_RECEIVE_BUFFER LocalBuffer
    );

VOID
DumpRequestBuffer(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_REQUEST_BUFFER LocalBuffer
    );

typedef enum {
    ENDPOINT_NO_CONNS = 0,
    ENDPOINT_BRIEF_CONNS,
    ENDPOINT_VERBOSE_CONNS,
} ENDPOINT_CONNS;

VOID
DumpUlEndpoint(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_ENDPOINT LocalEndpoint,
    IN ENDPOINT_CONNS Verbosity
    );

VOID
DumpAllEndpoints(
    IN ENDPOINT_CONNS Verbosity
    );

VOID
DumpUlRequest(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PHTTP_REQUEST LocalRequest
    );

VOID
DumpHttpHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_HEADER LocalHeader,
    IN ULONG HeaderOrdinal,
    IN PSTR *pHeaderIdMap
    );

VOID
DumpUnknownHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_HTTP_UNKNOWN_HEADER LocalHeader
    );

VOID
DumpFileCacheEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILE_CACHE_ENTRY LocalFile
    );

VOID
DumpUriEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_URI_CACHE_ENTRY UriEntry
    );

VOID
DumpAllUriEntries(
    VOID
    );

VOID
DumpMdl(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PMDL LocalMdl,
    IN ULONG MaxBytesToDump
    );

VOID
DumpApoolObj(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_APP_POOL_OBJECT ApoolObj
    );

VOID
DumpAllApoolObjs(
    VOID
    );

VOID
DumpApoolProc(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_APP_POOL_PROCESS ApoolProc
    );

VOID
DumpCgroupEntry(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_URL_TREE_ENTRY Entry
    );

VOID
DumpCgroupHeader(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_HEADER_ENTRY Entry
    );

VOID
DumpConfigGroup(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CONFIG_GROUP_OBJECT Obj
    );

VOID
DumpConfigTree(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_CG_URL_TREE_HEADER Tree
    );

VOID
DumpKernelQueue(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PKQUEUE LocalQueue,
    IN ULONG Flags
    );

VOID
DumpFilterChannel(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILTER_CHANNEL Filter,
    IN ULONG Flags
    );

VOID
DumpFilterProc(
    IN PSTR Prefix,
    IN PSTR CommandName,
    IN ULONG_PTR RemoteAddress,
    IN PUL_FILTER_PROCESS Proc,
    IN ULONG Flags
    );

const CHAR*
Action2Name(
    ULONG Action);

#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _PROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\precomp.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master header file for the UL.SYS Kernel Debugger Extensions.

Author:

    Keith Moore (keithmo) 17-Jun-1998.

Environment:

    User Mode.

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_

//
//  System include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosp.h>

#include <ntverp.h>
#include <tdikrnl.h>
#include <ipexport.h>
#include <limits.h>

#define NOGDICAPMASKS
#define NOVIRTUALKEYCODES
#define NOWINMESSAGES
#define NOWINSTYLES
#define NOSYSMETRICS
#define NOMENUS
#define NOICONS
#define NOKEYSTATES
#define NOSYSCOMMANDS
#define NORASTEROPS
#define NOSHOWWINDOW
#define OEMRESOURCE
#define NOATOM
#define NOCLIPBOARD
#define NOCOLOR
#define NOCTLMGR
#define NODRAWTEXT
#define NOGDI
#define NOKERNEL
#define NOUSER
#define NONLS
#define NOMB
#define NOMEMMGR
#define NOMETAFILE
#define NOMINMAX
#define NOMSG
#define NOOPENFILE
#define NOSCROLL
#define NOSERVICE
#define NOSOUND
#define NOTEXTMETRIC
#define NOWH
#define NOWINOFFSETS
#define NOCOMM
#define NOKANJI
#define NOHELP
#define NOPROFILER
#define NODEFERWINDOWPOS
#define NOWINBASEINTERLOCK 

#include <windows.h>
#include <wdbgexts.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <http.h>

//
// Include files stolen from the driver sources.
//

#pragma warning( disable: 4200 )    //  zero length arrays

#include "iisdef.h"
#include "..\drv\config.h"
#include "..\drv\debug.h"
#include "..\drv\notify.h"
#include "..\drv\type.h"
#include "..\drv\tracelog.h"
#include "..\drv\reftrace.h"
#include "..\drv\ownerref.h"
#include "..\drv\irptrace.h"
#include "..\drv\timetrace.h"
#include "..\drv\thrdpool.h"
#include "..\drv\pipeline.h"
#include "..\drv\pipelinep.h"
#include "..\drv\opaqueid.h"
#include "..\drv\httptdi.h"
#include "..\drv\cgroup.h"
#include "..\drv\filterp.h"
#include "..\drv\filter.h"
#include "..\drv\ullog.h"
#include "..\drv\cache.h"
#include "..\drv\cachep.h"
#include "..\drv\data.h"
#include "..\drv\httptypes.h"
#include "..\drv\rwlock.h"
#include "..\drv\ultdi.h"
#include "..\drv\ultdip.h"
#include "..\drv\repltrace.h"
#include "..\drv\filtqtrace.h"
#include "..\drv\hash.h"
#include "..\drv\misc.h"
#include "..\drv\apool.h"
#include "..\drv\apoolp.h"
#include "..\drv\filecache.h"
#include "..\drv\sendresponse.h"
#include "..\drv\sendresponsep.h"
#include "..\drv\opaqueidp.h"
#include "..\drv\control.h"
#include "..\drv\counters.h"
#include "..\drv\cgroupp.h"

//
//  Local include files.
//

#include <cons.h>
#undef _TYPE_H_
#include <type.h>
#include <kddata.h>
#include <proc.h>


#define ALLOC(len)  (PVOID)RtlAllocateHeap( RtlProcessHeap(), 0, (len) )
#define FREE(ptr)   (VOID)RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )


// BUGBUG

#define ResourceOwnedExclusive      0x80
#define MDL_LOCK_HELD               0x0200
#define MDL_PHYSICAL_VIEW           0x0400


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\ref.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ref.c

Abstract:

    Implements the ref command.

Author:

    Keith Moore (keithmo) 17-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"

#undef BEGIN_REF_ACTION
#undef END_REF_ACTION
#undef REF_ACTION

#define BEGIN_REF_ACTION()      NAMED_REFTRACE_ACTION g_RefTraceActions[] = {
#define END_REF_ACTION()        };
#define REF_ACTION(x)           { REF_ACTION_##x, #x },

#include "..\drv\refaction.h"

#define NUM_REFTRACE_ACTIONS \
    (sizeof(g_RefTraceActions) / sizeof(g_RefTraceActions[0]))


const CHAR*
Action2Name(
    ULONG Action)
{
    if (Action < NUM_REFTRACE_ACTIONS)
    {
        ASSERT(g_RefTraceActions[Action].Action == Action);
        return g_RefTraceActions[Action].Name;
    }
    else
        return "????";
}

typedef
BOOLEAN
(*FN_MATCH_CONTEXT)(
    IN ULONG_PTR            context,
    IN PREF_TRACE_LOG_ENTRY plogEntry
    );

BOOLEAN
RefMatchContext(
    IN ULONG_PTR            context,
    IN PREF_TRACE_LOG_ENTRY plogEntry)
{
    return (context == 0 || context == (ULONG_PTR) plogEntry->pContext);
}

BOOLEAN
ThreadMatchContext(
    IN ULONG_PTR            context,
    IN PREF_TRACE_LOG_ENTRY plogEntry)
{
    return (context == 0 || context == (ULONG_PTR) plogEntry->pThread);
}


// Do all the real
VOID
DumpRefTrace(
    PCSTR args,
    FN_MATCH_CONTEXT pfnMatchContext,
    PCSTR cmd)
{
    ULONG_PTR           address = 0;
    ULONG_PTR           context = 0;
    ULONG_PTR           flags = 0;
    ULONG_PTR           entryAddress;
    ULONG               result;
    TRACE_LOG           logHeader;
    REF_TRACE_LOG_ENTRY logEntry;
    PSTR                fileName;
    LONGLONG            index;
    ULONGLONG           index2;
    ULONGLONG           index1000;
    ULONG_PTR           offset1;
    ULONG_PTR           offset2;
    CHAR                filePath[MAX_PATH];
    PVOID               pPrevFilePath;
    CHAR                symbol1[MAX_SYMBOL_LENGTH];
    CHAR                symbol2[MAX_SYMBOL_LENGTH];
    ULONG               Dumped = 0;
    ULONG               NonMatch = 0;
    ULONG64             address64 = 0;
    ULONG64             context64 = 0;
    ULONG64             flags64 = 0;
    ULONG               NumToDump = 0;

    while (*args == ' ' || *args == '\t')
    {
        args++;
    }

    if (*args == '-')
    {
        args++;

        switch (*args)
        {
        case 'l' :
            for (index = 0;  index < NUM_REFTRACE_ACTIONS;  ++index)
            {
                dprintf(
                    "%4u: REF_ACTION_%s\n",
                    g_RefTraceActions[index].Action,
                    g_RefTraceActions[index].Name);
            }
            return;

        default :
            PrintUsage( cmd );
            return;
        }
    }

    //
    // Snag the address and optional context and flags from the command line.
    //

    if (! GetExpressionEx(args, &address64, &args))
    {
        PrintUsage( cmd );
        return;
    }

    if (GetExpressionEx(args, &context64, &args))
        GetExpressionEx(args, &flags64, &args);

    address = (ULONG_PTR) address64;
    context = (ULONG_PTR) context64;
    flags = (ULONG_PTR) flags64;

    //
    // Read the log header.
    //

    if (!ReadMemory(
            address,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "%s: cannot read TRACE_LOG @ %p\n",
            cmd,
            address
            );
        return;
    }

    dprintf(
        "%s: log @ %p\n"
        "    Signature = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx '%c%c%c%c'\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %I64d\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        cmd,
        address,
        logHeader.Signature,
        DECODE_SIGNATURE(logHeader.Signature),
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TypeSignature,
        DECODE_SIGNATURE(logHeader.TypeSignature),
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.pLogBuffer
        );

   if (logHeader.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader) ))
   {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X)
    {
        dprintf(
            "%s: log @ %p has invalid signature %08lx:\n",
            cmd,
            address,
            logHeader.Signature
            );
        return;
    }

    if (logHeader.EntrySize != sizeof(logEntry)
        || logHeader.TypeSignature != REF_TRACELOG_SIGNATURE
        )
    {
        dprintf(
            "%s: log @ %p is not a ref count log\n",
            cmd,
            address
            );
        return;
    }

    if (logHeader.NextEntry == -1)
    {
        dprintf(
            "%s: empty log @ %p\n",
            cmd,
            address
            );
        return;
    }

    //
    // Calculate the log size to dump.
    //

    NumToDump = logHeader.LogSize;

    index  = max( 0, (logHeader.NextEntry + 1) - NumToDump );
    index2 = index % logHeader.LogSize;
    index1000 = index % 1000;

    pPrevFilePath = NULL;
    *filePath = '\0';

    entryAddress = (ULONG_PTR) logHeader.pLogBuffer +
        (ULONG_PTR)( index2 * sizeof(logEntry) );

    //
    // Dump the log.
    //

    for ( ;
         index <= logHeader.NextEntry;
         index++,
         index2++,
         index1000++,
         entryAddress += sizeof(logEntry)
        )
    {
        if (CheckControlC())
        {
            break;
        }

        if (index2 >= (ULONG)(logHeader.LogSize))
        {
            index2 = 0;
            entryAddress = (ULONG_PTR) logHeader.pLogBuffer;
        }

        if (index1000 >= 1000)
            index1000 = 0;

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "%s: cannot read memory @ %p\n",
                cmd,
                entryAddress
                );
            return;
        }

        if ((*pfnMatchContext)(context, &logEntry))
        {
            if (logEntry.pFileName != pPrevFilePath)
            {
                if (ReadMemory(
                        (ULONG_PTR)logEntry.pFileName,
                        filePath,
                        sizeof(filePath),
                        &result
                        ))
                {
                    fileName = strrchr( filePath, '\\' );
                    
                    if (fileName != NULL)
                    {
                        fileName++;
                    }
                    else
                    {
                        fileName = filePath;
                    }

                    pPrevFilePath = logEntry.pFileName;
                }
                else
                {
                    sprintf(
                        filePath,
                        "%p",
                        logEntry.pFileName
                        );
                    
                    fileName = filePath;
                }
            }

            dprintf(
                "%s%4I64d: CPU=%lu Ctx=%p Act=%2lu %-30s Ref=%4d Src=%s:%lu\n",
                (NonMatch > 0) ? "\n" : "",
                index,
                (ULONG)logEntry.Processor,
                logEntry.pContext,
                (ULONG)logEntry.Action,
                Action2Name(logEntry.Action),
                logEntry.NewRefCount,
                fileName,
                (ULONG)logEntry.LineNumber
                );

            if (flags & 1)
            {
                GetSymbol(
                    logEntry.pCaller,
                    symbol1,
                    &offset1
                    );

                GetSymbol(
                    logEntry.pCallersCaller,
                    symbol2,
                    &offset2
                    );

                dprintf(
                    "      Process=%p Thread=%p\n"
                    "      Caller1=%p (%s+0x%p)\n"
                    "      Caller2=%p (%s+0x%p)\n",
                    logEntry.pProcess,
                    logEntry.pThread,
                    logEntry.pCaller,
                    symbol1,
                    offset1,
                    logEntry.pCallersCaller,
                    symbol2,
                    offset2
                    );
            }

            ++Dumped;
            NonMatch = 0;
        }
        else
        {
            if (index1000 == 0)
                dprintf("%I64d", index);
            
            if ((++NonMatch & 127) == 127)
                dprintf(".");
        }
    }

    if (context != 0)
        dprintf("%d entries dumped\n\n", Dumped);

}   // DumpRefTrace



//
//  Public functions.
//

DECLARE_API( ref )

/*++

Routine Description:

    Dumps the reference trace log at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/
{
    SNAPSHOT_EXTENSION_DATA();

    DumpRefTrace(args, RefMatchContext, "ref");
} // ref


DECLARE_API( tref )

/*++

Routine Description:

    Dumps the trace log at the specified address.
    Filtering done by thread instead of context.

Arguments:

    None.

Return Value:

    None.

--*/

{
    SNAPSHOT_EXTENSION_DATA();

    DumpRefTrace(args, ThreadMatchContext, "tref");
} // ref
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\procirps.c ===
/*++

Copyright (c) 1999-2001 Microsoft Corporation

Module Name:

    procirps.c

Abstract:

    Dumps all IRPs issued by the specified process.

Author:

    Keith Moore (keithmo) 12-Nov-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private prototypes.
//

BOOLEAN
DumpThreadCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );

BOOLEAN
DumpIrpCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );


//
// Public functions.
//

DECLARE_API( procirps )

/*++

Routine Description:

    Dumps all IRPs issued by the specified process.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        PrintUsage( "procirps" );
        return;
    }

    //
    // Enumerate the threads.
    //

    EnumLinkedList(
        (PLIST_ENTRY)REMOTE_OFFSET( address, EPROCESS, Pcb.ThreadListHead ),
        &DumpThreadCallback,
        NULL
        );

}   // procirps


//
// Private functions.
//

BOOLEAN
DumpThreadCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR threadAddress;

    threadAddress = (ULONG_PTR)CONTAINING_RECORD(
                                    RemoteListEntry,
                                    KTHREAD,
                                    ThreadListEntry
                                    );

    //
    // Enumerate the IRPs.
    //

    EnumLinkedList(
        (PLIST_ENTRY)REMOTE_OFFSET( threadAddress, ETHREAD, IrpList ),
        &DumpIrpCallback,
        NULL
        );

    return TRUE;

}   // DumpThreadCallback


BOOLEAN
DumpIrpCallback(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    )
{
    ULONG_PTR address;
    CHAR temp[sizeof("1234567812345678 f")];

    address = (ULONG_PTR)CONTAINING_RECORD(
                            RemoteListEntry,
                            IRP,
                            ThreadListEntry
                            );

    sprintf( temp, "%p f", address );

    CallExtensionRoutine( "irp", temp );

    return TRUE;

}   // DumpIrpCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\atl.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#include <precomp.h>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\replenish.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    replenish.c

Abstract:

    Implements the replog command.

Author:

    Michael Courage (mcourage)      3-Oct-2000

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private globals.
//

PSTR g_pReplenishActions[] =
    {
        "START REPLENISH",
        "END REPLENISH  ",
        "QUEUE_REPLENISH",
        "INCREMENT      ",
        "DECREMENT      "
    };

C_ASSERT( DIM(g_pReplenishActions) == REPLENISH_ACTION_COUNT );


//
//  Public functions.
//

DECLARE_API( replog )

/*++

Routine Description:

    Dumps the replenish trace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR                   address = 0;
    ULONG_PTR                   context = 0;
    ULONG_PTR                   flags = 0;
    ULONG_PTR                   entryAddress;
    ULONG_PTR                   logPointer;
    ULONG                       result;
    TRACE_LOG                   logHeader;
    LONGLONG                    numEntries;
    REPLENISH_TRACE_LOG_ENTRY   logEntry;
    PSTR                        pAction;
    LONGLONG                    index;
    ULONG                       offset1;
    ULONG                       offset2;
    CHAR                        invalidAction[sizeof("2047")];
    ULONG64                     context64 = 0;
    ULONG64                     flags64 = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the optional context and flags from the command line.
    //

    if (GetExpressionEx(args, &context64, &args))
        GetExpressionEx(args, &flags64, &args);

    context = (ULONG_PTR) context64;
    flags = (ULONG_PTR) flags64;

    //
    // Find the log.
    //

    address = GetExpression( "&http!g_pReplenishTraceLog" );

    if (address == 0)
    {
        dprintf( "replog: cannot find http!g_pReplenishTraceLog\n" );
        return;
    }

    //
    // Read the pointer.
    //

    if (!ReadMemory(
            address,
            &logPointer,
            sizeof(logPointer),
            &result
            ))
    {
        dprintf(
            "replog: cannot read PTRACE_LOG @ %p\n",
            address
            );
        return;
    }

    //
    // Read the log header.
    //

    if (!ReadMemory(
            logPointer,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "ref: cannot read TRACE_LOG @ %p\n",
            logPointer
            );
        return;
    }

    dprintf(
        "ref: log @ %p\n"
        "    Signature = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx '%c%c%c%c'\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %I64d\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        address,
        logHeader.Signature,
        DECODE_SIGNATURE(logHeader.Signature),
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TypeSignature,
        DECODE_SIGNATURE(logHeader.TypeSignature),
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.pLogBuffer
        );

    if (logHeader.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader) ))
    {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X)
    {
        dprintf(
            "replog: log @ %p has invalid signature %08lx:\n",
            address,
            logHeader.Signature
            );
        return;
    }

    if (logHeader.EntrySize != sizeof(logEntry)
        || logHeader.TypeSignature != REPLENISH_TRACE_LOG_SIGNATURE)
    {
        dprintf(
            "replog: log @ %p is not a replenish trace log\n",
            address
            );
        return;
    }

    if (logHeader.NextEntry == -1)
    {
        dprintf(
            "replog: empty log @ %p\n",
            address
            );
        return;
    }

    //
    // Calculate the log size to dump.
    //

    if (logHeader.NextEntry < logHeader.LogSize)
    {
        numEntries = logHeader.NextEntry + 1;
        index = 0;
    }
    else
    {
        numEntries = logHeader.LogSize;
        index = (logHeader.NextEntry + 1) % logHeader.LogSize;
    }

    entryAddress = (ULONG_PTR)logHeader.pLogBuffer +
        (ULONG_PTR)( index * sizeof(logEntry) );

    if (entryAddress >=
        ( (ULONG_PTR)logHeader.pLogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) )
    {
        dprintf(
            "replog: log @ %p has invalid data\n",
            address
            );
        return;
    }

    //
    // Dump the log.
    //

    for (;
         numEntries > 0 ;
         index++,
         numEntries--,
         entryAddress += sizeof(logEntry))
     {
        if (CheckControlC())
        {
            break;
        }

        if (index >= logHeader.LogSize)
        {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.pLogBuffer;
        }

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "replog: cannot read memory @ %p\n",
                entryAddress
                );
            return;
        }

        if (context == 0 ||
            context == (ULONG_PTR)logEntry.pEndpoint)
        {
            if (logEntry.Action < REPLENISH_ACTION_COUNT)
            {
                pAction = g_pReplenishActions[logEntry.Action];
            }
            else
            {
                sprintf( invalidAction, "%lu", (ULONG)logEntry.Action );
                pAction = invalidAction;
            }

            dprintf(
                "CPU=%lu Endpoint=%p Act=%s"
                "  oldCount=%3d %s newCount=%3d %s\n",
                logEntry.Processor,
                logEntry.pEndpoint,
                pAction,
                logEntry.Previous.IdleConnections,
                logEntry.Previous.ReplenishScheduled ? "S" : " ",
                logEntry.Current.IdleConnections,
                logEntry.Current.ReplenishScheduled ? "S" : " "
                );
                

/*
            if (flags & 1)
            {
                dprintf(
                    "\nCPU=%lu Conn=%I64x Req=%I64x Act=%s\n"
                    "        Time=%I64x ",
                    (ULONG)logEntry.Processor,
                    logEntry.ConnectionId,
                    logEntry.RequestId,
                    pAction,
                    logEntry.TimeStamp,
                    (logEntry.TimeStamp - PreviousTime),
                    (logEntry.TimeStamp - PreviousTime) / 10
                    );
            } else {
                dprintf(
                    "C=%I64x R=%I64x A=%s ",
                    logEntry.ConnectionId,
                    logEntry.RequestId,
                    pAction
                    );
            }
*/

        }
    }

}   // replog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\thrdpool.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    thrdpool.c

Abstract:

    Implements the thrdpool command.

Author:

    Keith Moore (keithmo) 17-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private types.
//

typedef struct _THREAD_ENUM_STATE
{
    ULONG ThreadNumber;

} THREAD_ENUM_STATE, *PTHREAD_ENUM_STATE;


//
// Private prototypes.
//

BOOLEAN
DumpThreadPoolCallback(
    IN PLIST_ENTRY pRemoteListEntry,
    IN PVOID pContext
    );


//
// Public functions.
//

DECLARE_API( thrdpool )

/*++

Routine Description:

    Dumps the thread pool at the specified address.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    CLONG count = 1;
    ULONG_PTR countAddress = 0;
    CLONG i;
    UL_THREAD_POOL threadPool;
    ULONG result;
    THREAD_ENUM_STATE state;

    SNAPSHOT_EXTENSION_DATA();

    state.ThreadNumber = 0;

    //
    // Snag the address from the command line.
    //
    address = GetExpression( args );

    if (address == 0)
    {
        address = GetExpression( "&http!g_UlThreadPool" );

        if (address == 0)
        {
            dprintf( "thrdpool: Cannot find http!g_UlThreadPool\n" );
            return;
        }

        countAddress = GetExpression( "&http!g_UlNumberOfProcessors" );

        if (countAddress == 0)
        {
            dprintf( "thrdpool: Cannot find http!g_UlNumberOfProcessors\n" );
            return;
        }

        if (!ReadMemory(
                countAddress,
                &count,
                sizeof(count),
                &result
                ))
        {
            dprintf(
                "thrdpool: Cannot read http!g_UlNumberOfProcessors at %p.\n",
                countAddress
                );
            return;
        }
    }

    if (address == 0)
    {
        PrintUsage( "thrdpool" );
        return;
    }

    // g_UlThreadPool[g_UlNumberOfProcessors] == WAIT_THREAD_POOL
    for (i = 0; i <= count; i++)
    {
        if (CheckControlC())
        {
            break;
        }
    
        //
        // Read the thread pool.
        //

        if (!ReadMemory(
                address,
                &threadPool,
                sizeof(threadPool),
                &result
                ))
        {
            dprintf(
                "thrdpool: cannot read UL_THREAD_POOL @ %p\n",
                address
                );
            return;
        }

        dprintf(
            "thrdpool: %sthread pool @ %p (%d)\n"
            "    WorkQueueSList        @ %p depth=%d\n"
            "    WorkQueueEvent        @ %p\n"
            "    ThreadListHead        @ %p%s\n"
            "    pIrpThread            = %p\n"
            "    ThreadSpinLock        @ %p\n"
            "    Initialized           = %s\n"
            "    ThreadCount           = %lu\n"
            "    ThreadCpu             = %lu\n",
            (i == count) ? "wait " : "",
            address,
            threadPool.ThreadCpu,
            REMOTE_OFFSET( address, UL_THREAD_POOL, WorkQueueSList ),
            SLIST_HEADER_DEPTH(&threadPool.WorkQueueSList),
            address + FIELD_OFFSET( UL_THREAD_POOL, WorkQueueEvent ),
            REMOTE_OFFSET( address, UL_THREAD_POOL, ThreadListHead ),
            IS_LIST_EMPTY(
                &threadPool,
                address,
                UL_THREAD_POOL,
                ThreadListHead
                ) ? " (EMPTY)" : "",
            threadPool.pIrpThread,
            address + FIELD_OFFSET( UL_THREAD_POOL, ThreadSpinLock ),
            threadPool.Initialized
                ? "TRUE"
                : "FALSE",
            (ULONG)threadPool.ThreadCount,
            (ULONG)threadPool.ThreadCpu
            );

        EnumLinkedList(
            (PLIST_ENTRY)REMOTE_OFFSET( address, UL_THREAD_POOL, ThreadListHead ),
            &DumpThreadPoolCallback,
            (PVOID)&state
            );

        address += sizeof(threadPool);
    }

}   // thrdpool

BOOLEAN
DumpThreadPoolCallback(
    IN PLIST_ENTRY pRemoteListEntry,
    IN PVOID pContext
    )
{
    UL_THREAD_TRACKER localTracker;
    PUL_THREAD_TRACKER pRemoteTracker;
    PTHREAD_ENUM_STATE pState;
    ULONG result;
    CHAR temp[sizeof("1234567812345678 f")];

    pState = (PTHREAD_ENUM_STATE)pContext;

    pRemoteTracker = CONTAINING_RECORD(
                            pRemoteListEntry,
                            UL_THREAD_TRACKER,
                            ThreadListEntry
                            );

    if (!ReadMemory(
            (ULONG_PTR)pRemoteTracker,
            &localTracker,
            sizeof(localTracker),
            &result
            ))
    {
        dprintf( "thrdpool: cannot read UL_THREAD_TRACKER @ %p\n", pRemoteTracker );
        return FALSE;
    }

    sprintf( temp, "%p f", localTracker.pThread );

#if 0
    dprintf( "About to `.thread %p f'\n", localTracker.pThread );

    // !kdexts.thread appears to be broken
    if (!CallExtensionRoutine( "thread", temp ))
#endif // 0
    {
        dprintf(
            "    %3lu : %p\n",
            pState->ThreadNumber,
            localTracker.pThread
            );

        pState->ThreadNumber++;
    }

    return TRUE;

}   // DumpThreadPoolCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\tdiutil.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    tdiutil.c

Abstract:

    Utility functions for dumping various TDI structures.

Author:

    Keith Moore (keithmo) 17-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Private prototypes.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    );

PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    );


//
//  Public functions.
//

VOID
DumpTransportAddress(
    PCHAR Prefix,
    PTRANSPORT_ADDRESS Address,
    ULONG_PTR ActualAddress
    )

/*++

Routine Description:

    Dumps the specified TRANSPORT_ADDRESS structure.

Arguments:

    Prefix - A character string prefix to display before each line. Used
        to make things pretty.

    Address - Points to the TRANSPORT_ADDRESS to dump.

    ActualAddress - The actual address where the structure resides on the
        debugee.

Return Value:

    None.

--*/

{

    dprintf(
        "%sTRANSPORT_ADDRESS @ %p\n",
        Prefix,
        ActualAddress
        );

    dprintf(
        "%s    AddressLength   = %u\n",
        Prefix,
        Address->Address[0].AddressLength
        );

    dprintf(
        "%s    AddressType     = %u (%s)\n",
        Prefix,
        Address->Address[0].AddressType,
        TransportAddressTypeToString( Address->Address[0].AddressType )
        );

    switch( Address->Address[0].AddressType ) {

    case TDI_ADDRESS_TYPE_IP : {

        PTA_IP_ADDRESS ipAddress;

        ipAddress = (PTA_IP_ADDRESS)Address;

        dprintf(
            "%s    sin_port        = %u\n",
            Prefix,
            NTOHS(ipAddress->Address00.sin_port)
            );

        dprintf(
            "%s    in_addr         = %d.%d.%d.%d\n",
            Prefix,
            UC(ipAddress->Address00.in_addr >>  0),
            UC(ipAddress->Address00.in_addr >>  8),
            UC(ipAddress->Address00.in_addr >> 16),
            UC(ipAddress->Address00.in_addr >> 24)
            );

        }
        break;

    case TDI_ADDRESS_TYPE_IPX : {

        PTA_IPX_ADDRESS ipxAddress;

        ipxAddress = (PTA_IPX_ADDRESS)Address;

        dprintf(
            "%s    NetworkAddress  = %08lx\n",
            Prefix,
            ipxAddress->Address00.NetworkAddress
            );

        dprintf(
            "%s    NodeAddress     = %02X-%02X-%02X-%02X-%02X-%02X\n",
            Prefix,
            ipxAddress->Address00.NodeAddress[0],
            ipxAddress->Address00.NodeAddress[1],
            ipxAddress->Address00.NodeAddress[2],
            ipxAddress->Address00.NodeAddress[3],
            ipxAddress->Address00.NodeAddress[4],
            ipxAddress->Address00.NodeAddress[5]
            );

        dprintf(
            "%s    Socket          = %04X\n",
            Prefix,
            ipxAddress->Address00.Socket
            );

        }
        break;

    case TDI_ADDRESS_TYPE_NETBIOS : {

        PTA_NETBIOS_ADDRESS netbiosAddress;
        UCHAR netbiosName[17];

        netbiosAddress = (PTA_NETBIOS_ADDRESS)Address;

        dprintf(
            "%s    NetbiosNameType = %04X (%s)\n",
            Prefix,
            netbiosAddress->Address00.NetbiosNameType,
            NetbiosNameTypeToString( netbiosAddress->Address00.NetbiosNameType )
            );

        RtlCopyMemory(
            netbiosName,
            netbiosAddress->Address00.NetbiosName,
            16
            );

        netbiosName[16] = '\0';

        dprintf(
            "%s    NetbiosName     = %s\n",
            Prefix,
            netbiosName
            );

        }
        break;

    default :

        dprintf(
            "%s    Unsupported address type\n",
            Prefix
            );

        break;

    }

}   // DumpAfdEndpoint


//
//  Private functions.
//

PSTR
TransportAddressTypeToString(
    USHORT AddressType
    )

/*++

Routine Description:

    Maps a transport address type to a displayable string.

Arguments:

    AddressType - The transport address type to map.

Return Value:

    PSTR - Points to the displayable form of the tranport address type.

--*/

{

    switch( AddressType ) {

    case TDI_ADDRESS_TYPE_UNSPEC :

        return "Unspecified";

    case TDI_ADDRESS_TYPE_UNIX :

        return "Unix";

    case TDI_ADDRESS_TYPE_IP :

        return "Ip";

    case TDI_ADDRESS_TYPE_IMPLINK :

        return "Implink";

    case TDI_ADDRESS_TYPE_PUP :

        return "Pup";

    case TDI_ADDRESS_TYPE_CHAOS :

        return "Chaos";

    case TDI_ADDRESS_TYPE_IPX :

        return "Ipx";

    case TDI_ADDRESS_TYPE_NBS :

        return "Nbs";

    case TDI_ADDRESS_TYPE_ECMA :

        return "Ecma";

    case TDI_ADDRESS_TYPE_DATAKIT :

        return "Datakit";

    case TDI_ADDRESS_TYPE_CCITT :

        return "Ccitt";

    case TDI_ADDRESS_TYPE_SNA :

        return "Sna";

    case TDI_ADDRESS_TYPE_DECnet :

        return "Decnet";

    case TDI_ADDRESS_TYPE_DLI :

        return "Dli";

    case TDI_ADDRESS_TYPE_LAT :

        return "Lat";

    case TDI_ADDRESS_TYPE_HYLINK :

        return "Hylink";

    case TDI_ADDRESS_TYPE_APPLETALK :

        return "Appletalk";

    case TDI_ADDRESS_TYPE_NETBIOS :

        return "Netbios";

    case TDI_ADDRESS_TYPE_8022 :

        return "8022";

    case TDI_ADDRESS_TYPE_OSI_TSAP :

        return "Osi Trap";

    case TDI_ADDRESS_TYPE_NETONE :

        return "Netone";

    }

    return "UNKNOWN";

}   // TransportAddressTypeToString

PSTR
NetbiosNameTypeToString(
    USHORT NetbiosNameType
    )

/*++

Routine Description:

    Maps a NetBIOS name type to a displayable string.

Arguments:

    NetbiosNameType - The NetBIOS name type to map.

Return Value:

    PSTR - Points to the displayable form of the NetBIOS name type.

--*/

{

    switch( NetbiosNameType ) {

    case TDI_ADDRESS_NETBIOS_TYPE_UNIQUE :

        return "Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_GROUP :

        return "Group";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_UNIQUE :

        return "Quick Unique";

    case TDI_ADDRESS_NETBIOS_TYPE_QUICK_GROUP :

        return "Quick Group";

    }

    return "UNKNOWN";

}   // NetbiosNameTypeToString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\time.c ===
/*++

Copyright (c) 2000-2001 Microsoft Corporation

Module Name:

    time.c

Abstract:

    Implements the timelog command.

Author:

    Michael Courage (mcourage)      8-Mar-2000

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
// Private constants.
//


//
// Private globals.
//

PSTR g_pTimeActions[] =
    {
        "CREATE CONNECTION",
        "CREATE REQUEST   ",
        "ROUTE REQUEST    ",
        "COPY REQUEST     ",
        "SEND RESPONSE    ",
        "SEND COMPLETE    "
    };

C_ASSERT( DIM(g_pTimeActions) == TIME_ACTION_COUNT );


//
//  Public functions.
//

DECLARE_API( timelog )

/*++

Routine Description:

    Dumps the time trace log.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR               address = 0;
    ULONG_PTR               context = 0;
    ULONG_PTR               flags = 0;
    ULONG_PTR               entryAddress;
    ULONG_PTR               logPointer;
    ULONG                   result;
    TRACE_LOG               logHeader;
    LONGLONG                numEntries;
    TIME_TRACE_LOG_ENTRY    logEntry;
    PSTR                    pAction;
    LONGLONG                index;
    ULONG                   offset1;
    ULONG                   offset2;
    UCHAR                   invalidAction[sizeof("2047")];
    ULONGLONG               PreviousTime = 0;
    USHORT                  PreviousProcessor = -1;
    ULONG64                 context64 = 0;
    ULONG64                 flags64 = 0;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the optional context and flags from the command line.
    //

    if (GetExpressionEx(args, &context64, &args))
        GetExpressionEx(args, &flags64, &args);

    context = (ULONG_PTR) context64;
    flags = (ULONG_PTR) flags64;

    //
    // Find the log.
    //

    address = GetExpression( "&http!g_pTimeTraceLog" );

    if (address == 0)
    {
        dprintf( "timelog: cannot find http!g_pTimeTraceLog\n" );
        return;
    }

    //
    // Read the pointer.
    //

    if (!ReadMemory(
            address,
            &logPointer,
            sizeof(logPointer),
            &result
            ))
    {
        dprintf(
            "timelog: cannot read PTRACE_LOG @ %p\n",
            address
            );
        return;
    }

    //
    // Read the log header.
    //

    if (!ReadMemory(
            logPointer,
            &logHeader,
            sizeof(logHeader),
            &result
            ))
    {
        dprintf(
            "timelog: cannot read TRACE_LOG @ %p\n",
            logPointer
            );
        return;
    }

    dprintf(
        "timelog: log @ %p\n"
        "    Signature = %08lx '%c%c%c%c' (%s)\n"
        "    TypeSignature = %08lx '%c%c%c%c'\n"
        "    LogSize   = %lu\n"
        "    NextEntry = %I64d\n"
        "    EntrySize = %lu\n"
        "    LogBuffer = %p\n",
        address,
        logHeader.Signature,
        DECODE_SIGNATURE(logHeader.Signature),
        logHeader.Signature == TRACE_LOG_SIGNATURE
            ? "OK"
            : logHeader.Signature == TRACE_LOG_SIGNATURE_X
                ? "FREED"
                : "INVALID",
        logHeader.TypeSignature,
        DECODE_SIGNATURE(logHeader.TypeSignature),
        logHeader.LogSize,
        logHeader.NextEntry,
        logHeader.EntrySize,
        logHeader.pLogBuffer
        );

    if (logHeader.pLogBuffer > ( (PUCHAR)address + sizeof(logHeader) ))
    {
        dprintf(
            "    ExtraData @ %p\n",
            address + sizeof(logHeader)
            );
    }

    if (logHeader.Signature != TRACE_LOG_SIGNATURE &&
        logHeader.Signature != TRACE_LOG_SIGNATURE_X)
    {
        dprintf(
            "timelog: log @ %p has invalid signature %08lx:\n",
            address,
            logHeader.Signature
            );
        return;
    }

    if (logHeader.EntrySize != sizeof(logEntry)
        || logHeader.TypeSignature != TIME_TRACE_LOG_SIGNATURE)
    {
        dprintf(
            "timelog: log @ %p is not a time trace log\n",
            address
            );
        return;
    }

    if (logHeader.NextEntry == -1)
    {
        dprintf(
            "timelog: empty log @ %p\n",
            address
            );
        return;
    }

    //
    // Calculate the log size to dump.
    //

    if (logHeader.NextEntry < logHeader.LogSize)
    {
        numEntries = logHeader.NextEntry + 1;
        index = 0;
    }
    else
    {
        numEntries = logHeader.LogSize;
        index = (logHeader.NextEntry + 1) % logHeader.LogSize;
    }

    entryAddress = (ULONG_PTR)logHeader.pLogBuffer +
        (ULONG_PTR)( index * sizeof(logEntry) );

    if (entryAddress >=
        ( (ULONG_PTR)logHeader.pLogBuffer + (ULONG_PTR)( numEntries * sizeof(logEntry) ) ) )
    {
        dprintf(
            "timelog: log @ %p has invalid data\n",
            address
            );
        return;
    }

    //
    // Dump the log.
    //

    for (;
         numEntries > 0 ;
         index++,
         numEntries--,
         entryAddress += sizeof(logEntry))
     {
        if (CheckControlC())
        {
            break;
        }

        if (index >= logHeader.LogSize)
        {
            index = 0;
            entryAddress = (ULONG_PTR)logHeader.pLogBuffer;
        }

        if (!ReadMemory(
                entryAddress,
                &logEntry,
                sizeof(logEntry),
                NULL
                ))
        {
            dprintf(
                "timelog: cannot read memory @ %p\n",
                entryAddress
                );
            return;
        }

        if (context == 0 ||
            context == (ULONG_PTR)logEntry.ConnectionId)
        {
            if (logEntry.Action < TIME_ACTION_COUNT)
            {
                pAction = g_pTimeActions[logEntry.Action];
            }
            else
            {
                sprintf( (char*)invalidAction, "%lu", (ULONG)logEntry.Action );
                pAction = (PSTR) invalidAction;
            }

            if (flags & 1)
            {
                dprintf(
                    "\nCPU=%lu Conn=%I64x Req=%I64x Act=%s\n"
                    "        Time=%I64x ",
                    (ULONG)logEntry.Processor,
                    logEntry.ConnectionId,
                    logEntry.RequestId,
                    pAction,
                    logEntry.TimeStamp,
                    (logEntry.TimeStamp - PreviousTime),
                    (logEntry.TimeStamp - PreviousTime) / 10
                    );
            } else {
                dprintf(
                    "C=%I64x R=%I64x A=%s ",
                    logEntry.ConnectionId,
                    logEntry.RequestId,
                    pAction
                    );
            }

            if (logEntry.Processor == PreviousProcessor) {
                ULONGLONG Delta;
                Delta = (logEntry.TimeStamp - PreviousTime);

                if (flags & 1) {
                    dprintf(
                        "Delta=%I64x (%I64d Kcycles)\n",
                        Delta,
                        Delta / 1024
                        );
                } else {
                    dprintf(
                        "(%I64d) D=%I64x\n",
                        Delta / 1024,
                        Delta
                        );
                }
            } else {
                dprintf("cpu switch\n");
            }

            PreviousTime = logEntry.TimeStamp;
            PreviousProcessor = logEntry.Processor;

        }
    }

}   // timelog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\type.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    type.h

Abstract:

    Global type definitions for the http.sys Kernel Debugger
    Extensions.

Author:

    Keith Moore (keithmo) 19-Apr-1995.

Environment:

    User Mode.

--*/


#ifndef _TYPE_H_
#define _TYPE_H_

#ifdef __cplusplus
extern "C" {
#endif


//
// A callback from EnumLinkedList().
//

typedef
BOOLEAN
(*PENUM_LINKED_LIST_CALLBACK)(
    IN PLIST_ENTRY RemoteListEntry,
    IN PVOID Context
    );


//
// A callback from EnumSList().
//

typedef
BOOLEAN
(*PENUM_SLIST_CALLBACK)(
    IN PSINGLE_LIST_ENTRY RemoteSListEntry,
    IN PVOID Context
    );


//
// A bit vector.
//

typedef struct _VECTORMAP
{
    ULONG Vector;
    PSTR Name;

} VECTORMAP, *PVECTORMAP;

#define VECTORMAP_ENTRY(x)      { x, #x }   
#define VECTORMAP_END           { 0, NULL }


//
// Decoding REF_ACTION_*
//

typedef struct _NAMED_REFTRACE_ACTION {
    ULONG       Action;
    const CHAR* Name;
} NAMED_REFTRACE_ACTION, *PNAMED_REFTRACE_ACTION;


// For use as arguments to '%c%c%c%c'
#define DECODE_SIGNATURE(dw) \
    isprint(((dw) >>  0) & 0xFF) ? (((dw) >>  0) & 0xFF) : '?', \
    isprint(((dw) >>  8) & 0xFF) ? (((dw) >>  8) & 0xFF) : '?', \
    isprint(((dw) >> 16) & 0xFF) ? (((dw) >> 16) & 0xFF) : '?', \
    isprint(((dw) >> 24) & 0xFF) ? (((dw) >> 24) & 0xFF) : '?'


#ifdef __cplusplus
}; // extern "C"
#endif

#endif  // _TYPE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\uri.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    uri.c

Abstract:

    Dumps URI Cache structures.

Author:

    Michael Courage (mcourage) 19-May-1999

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"
#include "..\drv\hashfn.h"
#include "..\drv\hashp.h"


//
// Private prototypes.
//


//
// Public functions.
//

DECLARE_API( uriglob )

/*++

Routine Description:

    Dumps global URI Cache structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR           address = 0;
    BOOL                Enabled = FALSE;
    UL_URI_CACHE_CONFIG config;
    UL_URI_CACHE_STATS  stats;
//  UL_URI_CACHE_TABLE  table;

    ULONG_PTR           dataAddress;
    UL_NONPAGED_DATA    data;
    BOOL                gotData = FALSE;
    CHAR                uriCacheResource[MAX_RESOURCE_STATE_LENGTH];
    CHAR                uriZombieResource[MAX_RESOURCE_STATE_LENGTH];

    SNAPSHOT_EXTENSION_DATA();

    //
    // Dump cache configuration.
    //
    address = GetExpression( "&http!g_UriCacheConfig" );
    if (address) {
        if (ReadMemory(
                address,
                &config,
                sizeof(config),
                NULL
                ))
        {
            dprintf(
                "UL_URI_CACHE_CONFIG   @ %p:\n"
                "    EnableCache           = %d\n"
                "    MaxCacheUriCount      = %d\n"
                "    MaxCacheMegabyteCount = %d\n"
                "    ScavengerPeriod       = %d\n"
                "    MaxUriBytes           = %d\n"
                "    HashTableBits         = %d\n",
                address,
                config.EnableCache,
                config.MaxCacheUriCount,
                config.MaxCacheMegabyteCount,
                config.ScavengerPeriod,
                config.MaxUriBytes,
                config.HashTableBits
                );

            Enabled = config.EnableCache;

        } else {
            dprintf(
                "glob: cannot read memory for http!g_UriCacheConfig @ %p\n",
                address
                );
        }

    } else {
        dprintf(
            "uriglob: cannot find symbol for http!g_UriCacheConfig\n"
            );
    }

    if (!Enabled) {
        //
        // no point in going on..
        //
        return;
    }

    //
    // Dump Cache Statistics
    //
    address = GetExpression( "&http!g_UriCacheStats" );
    if (address) {
        if (ReadMemory(
                address,
                &stats,
                sizeof(stats),
                NULL
                ))
        {
            dprintf(
                "\n"
                "UL_URI_CACHE_STATS         @ %p:\n"
                "    UriCount               = %d\n"
                "    UriCountMax            = %d\n"
                "    UriAddedTotal          = %I64d\n"
                "    ByteCount              = %I64d\n"
                "    ByteCountMax           = %I64d\n"
                "    ZombieCount            = %d\n"
                "    ZombieCountMax         = %d\n"
                "    HitCount               = %d\n"
                "    MissTableCount         = %d\n"
                "    MissPrecondtionCount   = %d\n"
                "    MissConfigCount        = %d\n"
                "\n",
                address,
                stats.UriCount,
                stats.UriCountMax,
                stats.UriAddedTotal,
                stats.ByteCount,
                stats.ByteCountMax,
                stats.ZombieCount,
                stats.ZombieCountMax,
                stats.HitCount,
                stats.MissTableCount,
                stats.MissPreconditionCount,
                stats.MissConfigCount
                );

        } else {
            dprintf(
                "glob: cannot read memory for http!g_UriCacheStats @ %p\n",
                address
                );
        }

    } else {
        dprintf(
            "uriglob: cannot find symbol for http!g_UriCacheStats\n"
            );
    }

    //
    // Read in resource info from non-paged data
    //
    address = GetExpression( "&http!g_pUlNonpagedData" );
    if (address) {
        if (ReadMemory(
                address,
                &dataAddress,
                sizeof(dataAddress),
                NULL
                ))
        {
            if (ReadMemory(
                    dataAddress,
                    &data,
                    sizeof(data),
                    NULL
                    ))
            {
                gotData = TRUE;
            } else {
                dprintf(
                    "uriglob: cannot read memory for http!g_pUlNonpagedData = %p\n",
                    dataAddress
                    );
            }
        } else {
            dprintf(
                "uriglob: cannot read memory for http!g_pUlNonpagedData @ %p\n",
                address
                );
        }
    } else {
        dprintf(
            "uriglob: cannot find symbol for http!g_pUlNonpagedData\n"
            );
    }

#if 0
// BUGBUG: GeorgeRe must fix
    //
    // Dump table info.
    //
    if (gotData) {
        dprintf(
            "UriCacheResource      @ %p (%s)\n",
            REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, UriCacheResource ),
            BuildResourceState( &data.UriCacheResource, uriCacheResource )
            );
    }

    address = GetExpression("&http!g_pUriCacheTable");
    if (address) {
        if (ReadMemory(
                address,
                &dataAddress,
                sizeof(dataAddress),
                NULL
                ))
        {
            if (ReadMemory(
                    dataAddress,
                    &table,
                    sizeof(table),
                    NULL
                    ))
            {
                dprintf(
                    "UL_URI_CACHE_TABLE    @ %p:\n"
                    "    UriCount          = %d\n"
                    "    ByteCount         = %d\n"
                    "    BucketCount       = %d\n"
                    "    Buckets           @ %p\n"
                    "\n",
                    dataAddress,
                    table.UriCount,
                    table.ByteCount,
                    table.BucketCount,
                    REMOTE_OFFSET( dataAddress, UL_URI_CACHE_TABLE, Buckets )
                    );

            } else {
                dprintf(
                    "uriglob: cannot read memory for http!g_pUriCacheTable = %p\n",
                    dataAddress
                    );
            }
        } else {
            dprintf(
                "uriglob: cannot read memory for http!g_pUriCacheTable @ %p\n",
                address
                );
        }
    } else {
        dprintf(
            "uriglob: cannot find symbol for http!g_pUriCacheTable\n"
            );
    }
#endif

    //
    // Dump Zombie list info.
    //
    if (gotData) {
        dprintf(
            "UriZombieResource     @ %p (%s)\n",
            REMOTE_OFFSET( dataAddress, UL_NONPAGED_DATA, UriZombieResource ),
            BuildResourceState( &data.UriZombieResource, uriZombieResource )
            );
    }

    dprintf(
        "g_ZombieListHead      @ %p\n"
        "\n",
        GetExpression("&http!g_ZombieListHead")
        );

    //
    // Dump reftrace info
    //
    address = GetExpression("&http!g_UriTraceLog");
    if (address) {
        if (ReadMemory(
                address,
                &dataAddress,
                sizeof(dataAddress),
                NULL
                ))
        {
            dprintf(
                "UL_URI_CACHE_ENTRY ref log: "
                "!ulkd.ref %x\n"
                "\n",
                dataAddress
                );
        }
    }

}   // uriglob


DECLARE_API( uri )

/*++

Routine Description:

    Dumps a UL_URI_CACHE_ENTRY structure.

Arguments:

    Address of structure

Return Value:

    None.

--*/
{
    ULONG_PTR address = 0;
    CHAR  star = 0;
    ULONG result;
    UL_URI_CACHE_ENTRY urientry;

    dprintf("BUGBUG: GeorgeRe needs to fix DumpAllUriEntries!\n");

#if 0
    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    address = GetExpression( args );

    if (address == 0)
    {
        sscanf( args, "%c", &star );

        if (star == '*') {
            DumpAllUriEntries();
        } else {
            PrintUsage( "uri" );
        }
        return;
    }

    //
    // Read the request header.
    //

    if (!ReadMemory(
            address,
            &urientry,
            sizeof(urientry),
            &result
            ))
    {
        dprintf(
            "uri: cannot read UL_URI_CACHE_ENTRY @ %p\n",
            address
            );
        return;
    }

    //
    // Dump it.
    //

    DumpUriEntry(
        "",
        "uri: ",
        address,
        &urientry
        );
#endif
}   // uri

VOID
AnalysisHashTable(
    IN ULONG_PTR RemoteAddress,
    IN ULONG     TableSize,
    IN ULONG     CacheLineSize
    )
{
    ULONG_PTR   address = 0;
    HASHBUCKET  bucket;
    ULONG       i;
    ULONG       max, min, zeros, total;
    FLOAT       avg, avg_nonzero;
    ULONG       result;

    max = 0;
    min =  ULONG_MAX;
    total = 0;
    zeros = 0;
    
    for (i = 0; i < TableSize; i++) 
    {

        address = (ULONG_PTR)(RemoteAddress + (i * CacheLineSize));

        if (!ReadMemory(
                address,
                &bucket,
                sizeof(bucket),
                &result
                ))
        {
            dprintf(
                "cannot read HASHBUCKET @ %p, i = %d\n",
                address,
                i
                );
            
            break;

        }
        
        total += (ULONG) bucket.Entries;
        
        if (bucket.Entries > max) 
        {
            max = (ULONG) bucket.Entries;
        }
        
        if (bucket.Entries < min)
        {
            min = (ULONG) bucket.Entries;
        }
        
        if (bucket.Entries == 0)
        {
            ++zeros;
        }
    }

    avg = (FLOAT)total / (FLOAT)i;
    avg_nonzero = (FLOAT)total / (FLOAT)(i - zeros);

    dprintf(
          "Total Entries  = %d:\n"
          "MAX Entries in a bucket  = %d:\n"
          "MIN Entries in a bucket  = %d:\n"
          "AVG Entries in a bucket  = %f:\n"
          "ZERO buckets  = %d:\n"
          "AVG NONZERO Entries in a bucket  = %f:\n",
          total,
          max,
          min,
          avg,
          zeros,
          avg_nonzero
          );
} // AnalysisHashTable


DECLARE_API( urihash )

/*++

Routine Description:

    Dumps URI Cache Hash Table structures.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR           address = 0;
    ULONG_PTR           address2 = 0;
    ULONG_PTR           address3 = 0;
    HASHTABLE           table;
    ULONG               tablesize;
    ULONG               cachelinesize;
    
    SNAPSHOT_EXTENSION_DATA();

    //
    // Dump cache configuration.
    //
    address = GetExpression( "&http!g_UriCacheTable" );
    if (address) 
    {
        if (ReadMemory(
                address,
                &table,
                sizeof(table),
                NULL
                ))
        {
            dprintf(
                "HASHTABLE   @ %p:\n"
                "    Signature           = %d\n"
                "    PoolType      = %d\n"
                "    NumberOfBytes      = %d\n"
                "    pAllocMem = %p\n"
                "    pBuckets           = %p\n",
                address,
                table.Signature,
                table.PoolType,
                table.NumberOfBytes,
                table.pAllocMem,
                table.pBuckets
                );

            address2 = GetExpression( "&http!g_UlHashTableSize" );

            if (address2) 
            {
                if (ReadMemory(
                                address2,
                                &tablesize,
                                sizeof(tablesize),
                                NULL
                               ))
                {
                    address3 = GetExpression( "&http!g_UlCacheLineSize" );

                    if (address3) 
                    {
                        if (ReadMemory(
                                        address3,
                                        &cachelinesize,
                                        sizeof(cachelinesize),
                                        NULL
                                        ))
                        {
                            AnalysisHashTable((ULONG_PTR)table.pBuckets, tablesize, cachelinesize);
                        } 
                        else 
                        {

                            dprintf(
                                    "urihash: cannot read memory for http!g_UlCacheLineSize @ %p\n",
                                    address3
                                   );
                        }
                    } 
                    else 
                    {
                        dprintf(
                                "urihash: cannot find symbol for http!g_UlCacheLineSize\n"
                               );
                    }
                } 
                else 
                {
                    dprintf(
                            "urihash: cannot read memory for http!g_UlHashTableSize @ %p\n",
                            address2
                            );
                }

            } 
            else 
            {
                dprintf(
                        "urihash: cannot find symbol for http!g_UlHashTableSize\n"
                        );
            }

        }
        else 
        {
            dprintf(
                "urihash: cannot read memory for http!g_UriCacheTable @ %p\n",
                address
                );
        }

    }
    else 
    {
        dprintf(
            "urihash: cannot find symbol for http!g_UriCacheTable\n"
            );
    }

}   // urihash
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulkd\_template.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    _template

Abstract:

    Template kernel debugger extension.

Author:

    Keith Moore (keithmo) 26-Jun-1998

Environment:

    User Mode.

Revision History:

--*/


#include "precomp.h"


//
//  Public functions.
//

DECLARE_API( _template )

/*++

Routine Description:

    Dumps something useful.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG_PTR address = 0;
    ULONG result;

    SNAPSHOT_EXTENSION_DATA();

    //
    // Snag the address from the command line.
    //

    if (! GetExpressionEx(args, &address, &args))
    {
        address = GetExpression( "&http!_template" );

        if (address != 0)
        {
            if (!ReadMemory(
                    address,
                    &address,
                    sizeof(address),
                    NULL
                    ))
            {
                dprintf(
                    "_template: Cannot read memory @ %p\n",
                    address
                    );
                return;
            }
        }
    }

    if (address == 0)
    {
        PrintUsage( "_template" );
        return;
    }

    //
    // Read the _template.
    //

    if (!ReadMemory(
            address,
            &threadPool,
            sizeof(threadPool),
            &result
            ))
    {
        dprintf(
            "_template: cannot read UL_THREAD_POOL @ %p\n",
            address
            );
        return;
    }

    dprintf(
        "_template: thread pool @ %p\n"
        "    WorkQueue             @ %p (%lu, %lu)\n"
        "    AvailableThreads      = %u\n"
        "    AvailablePending      = %u\n"
        "    NumberOfThreads       = %u\n"
        "    MaximumThreads        = %u\n"
        "    MinAvailableThreads   = %u\n"
        "    pIrpThread            = %p\n"
        "    ShutdownEvent         @ %p (%s)\n"
        "    Killer                @ %p\n"
        "    ThreadSpinLock        @ %p\n"
        "    ThreadSeed            = %lu\n"
        "    Initialized           = %s\n",
        address,
        address + FIELD_OFFSET( UL_THREAD_POOL, WorkQueue ),
        threadPool.WorkQueue.CurrentCount,
        threadPool.WorkQueue.MaximumCount,
        threadPool.ThreadSynch.AvailableThreads,
        threadPool.ThreadSynch.AvailablePending,
        threadPool.ThreadSynch.NumberOfThreads,
        threadPool.MaximumThreads,
        threadPool.MinAvailableThreads,
        threadPool.pIrpThread,
        address + FIELD_OFFSET( UL_THREAD_POOL, ShutdownEvent ),
        threadPool.ShutdownEvent.Header.SignalState == 0
            ? "NOT signaled"
            : "SIGNALED",
        address + FIELD_OFFSET( UL_THREAD_POOL, Killer ),
        address + FIELD_OFFSET( UL_THREAD_POOL, ThreadSpinLock ),
        threadPool.ThreadSeed,
        threadPool.Initialized
            ? "TRUE"
            : "FALSE"
        );

}   // _template
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\precomp.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
//


#define STRICT
#define _ATL_APARTMENT_THREADED

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#undef ASSERT
#include <afx.h>

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>

#include <wbemprov.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\resource.h ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

#define IDR_ULPERF                      100
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\ulctrs.h ===
#ifndef _ULCTRS_H_
#define _ULCTRS_H_



//
//  The ul counter object.
//

#define UL_COUNTER_OBJECT                   0


//
//  The individual counters.
//

#define UL_BYTES_SENT_COUNTER               2
#define UL_BYTES_RECEIVED_COUNTER           4

#define UL_CURRENT_CONNECTIONS_NUMBER       6
#define UL_CURRENT_REQUESTS_NUMBER          8

#define UL_QUEUED_REQUESTS_NUMBER           10

#define UL_ATTACHED_PROCESSES_NUMBER        12



#endif // _ULCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\init.cpp ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1998 Microsoft Corporation.  All rights reserved.
//

// init.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To merge the proxy/stub code into the object DLL, add the file 
//		dlldatax.c to the project.  Make sure precompiled headers 
//		are turned off for this file, and add _MERGE_PROXYSTUB to the 
//		defines for the project.  
//
//		If you are not running WinNT4.0 or Win95 with DCOM, then you
//		need to remove the following define from dlldatax.c
//		#define _WIN32_WINNT 0x0400
//
//		Further, if you are running MIDL without /Oicf switch, you also 
//		need to remove the following define from dlldatax.c.
//		#define USE_STUBLESS_PROXY
//
//		Modify the custom build rule for AUO.idl by adding the following 
//		files to the Outputs.
//			AUO_p.c
//			dlldata.c
//		To build a separate proxy/stub DLL, 
//		run nmake -f AUOps.mk in the project directory.

#include "precomp.h"
#include "initguid.h"
#include "ulperf.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;
GUID LIBID_StdOle2 = {0x00020430,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}};


BEGIN_OBJECT_MAP(ObjectMap)

    OBJECT_ENTRY(CLSID_UlPerfCounters, CUlPerfCounters)
	
END_OBJECT_MAP()


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
	lpReserved;
#ifdef _MERGE_PROXYSTUB
	if (!PrxDllMain(hInstance, dwReason, lpReserved))
		return FALSE;
#endif
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		
        g_hInstance = hInstance;

		DisableThreadLibraryCalls(hInstance);

        g_lInit = 0;
		
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		_Module.Term();
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	if (PrxDllCanUnloadNow() != S_OK)
		return S_FALSE;
#endif
    return S_FALSE;
//	return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
		return S_OK;
#endif

	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	HRESULT hRes = PrxDllRegisterServer();
	if (FAILED(hRes))
		return hRes;
#endif

	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer();
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
//	AFX_MANAGE_STATE(AfxGetStaticModuleState());
#ifdef _MERGE_PROXYSTUB
	PrxDllUnregisterServer();
#endif
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\util\makefile.inc ===
$(O)\tul.res: tul.rc

$(O)\dtsetup.res: dtsetup.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\ulperf.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ulperf.cpp

Abstract:

    This is the main code for the ul.sys performance counter support object

Author:

    Paul McDaniel (paulmcd)       11-May-1999

Revision History:

--*/

#include "precomp.h"
#include "ulperf.h"


//
// Globals
//

LONG                g_lInit;
HINSTANCE           g_hInstance;

//
// Active "opens" reference count for Open/Close PerformanceData
//
ULONG OpenCount = 0;

//
// An open handle to the event log for error logging
//
HANDLE hEventLog;

//
//  Initialize the constant portions of the HKEY_PERFORMANCE data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

const UL_COUNTER_BLOCK CounterBlock;

UL_PERF_OBJECT_DEFINITION ObjectDefinition =
{
    {   // ObjectType
        sizeof(UL_PERF_OBJECT_DEFINITION) + sizeof(UL_COUNTER_BLOCK),
        sizeof(UL_PERF_OBJECT_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        UL_COUNTER_OBJECT,
        NULL,
        UL_COUNTER_OBJECT,
        NULL,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_UL_COUNTERS,
        -1,                                     // DefaultCounter
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // BytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        UL_BYTES_SENT_COUNTER,
        NULL,                           // assigned in OpenPerformanceData()
        UL_BYTES_SENT_COUNTER,
        NULL,                           // assigned in OpenPerformanceData()
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        0,                              // assigned in OpenPerformanceData()
        0                               // assigned in OpenPerformanceData()
    },

    {   // BytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        UL_BYTES_RECEIVED_COUNTER,
        NULL,
        UL_BYTES_RECEIVED_COUNTER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_COUNTER,
        0,
        0
    },

    {   // CurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        UL_CURRENT_CONNECTIONS_NUMBER,
        NULL,
        UL_CURRENT_CONNECTIONS_NUMBER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        0,
        0
    },
    
    {   // CurrentRequests
        sizeof(PERF_COUNTER_DEFINITION),
        UL_CURRENT_REQUESTS_NUMBER,
        NULL,
        UL_CURRENT_REQUESTS_NUMBER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        0,
        0
    },

    {   // QueuedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        UL_QUEUED_REQUESTS_NUMBER,
        NULL,
        UL_QUEUED_REQUESTS_NUMBER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        0,
        0
    },
    
    {   // AttachedProcesses
        sizeof(PERF_COUNTER_DEFINITION),
        UL_ATTACHED_PROCESSES_NUMBER,
        NULL,
        UL_ATTACHED_PROCESSES_NUMBER,
        NULL,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        0,
        0
    }

};


DWORD 
OpenPerformanceData(
    LPWSTR lpDeviceNames
    )
{
    DWORD   Error = NO_ERROR;
    HKEY    hkey = NULL;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;
    DWORD   i;
    
    PERF_COUNTER_DEFINITION *   pctr;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if (OpenCount == 0)
    {

        //
        //  This is the *first* open.
        //

        // open event log interface

        if (hEventLog == NULL)
        {
            hEventLog = RegisterEventSource(
                            (LPTSTR)NULL,       // Use Local Machine
                            APP_NAME            // event log app name 
                                                // to find in registry
                            );               
        }

        //
        //  open the performance key
        //

        Error = RegOpenKeyEx( 
                    HKEY_LOCAL_MACHINE,
                    REGISTRY_UL_INFORMATION L"\\Performance",
                    0,
                    KEY_ALL_ACCESS,
                    &hkey 
                    );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( 
                        hkey,
                        L"First Counter",
                        NULL,
                        &type,
                        (LPBYTE)&dwFirstCounter,
                        &size 
                        );
                        
            if( err == NO_ERROR )
            {
                //
                //  Read the first help DWORD.
                //

                size = sizeof(DWORD);

                err = RegQueryValueEx( hkey,
                                    L"First Help",
                                    NULL,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size );

                if ( err == NO_ERROR )
                {
                    //
                    //  Update the object & counter name & help indicies.
                    //

                    ObjectDefinition.ObjectType.ObjectNameTitleIndex
                        += dwFirstCounter;
                    ObjectDefinition.ObjectType.ObjectHelpTitleIndex
                        += dwFirstHelp;

#define ADJUST_VALUES(CounterName) \
do {\
    ObjectDefinition.##CounterName.CounterNameTitleIndex \
        += dwFirstCounter; \
    ObjectDefinition.##CounterName.CounterHelpTitleIndex \
        += dwFirstHelp; \
    ObjectDefinition.##CounterName.CounterSize \
        = sizeof(CounterBlock.##CounterName); \
    ObjectDefinition.##CounterName.CounterOffset = \
        DIFF((LPBYTE)&CounterBlock.##CounterName - (LPBYTE)&CounterBlock);\
} while (0)

                    ADJUST_VALUES(BytesSent);
                    ADJUST_VALUES(BytesReceived);
                    ADJUST_VALUES(CurrentConnections);
                    ADJUST_VALUES(CurrentRequests);
                    ADJUST_VALUES(QueuedRequests);
                    ADJUST_VALUES(AttachedProcesses);

                    //
                    //  Remember that we initialized OK.
                    //

                    fInitOK = TRUE;

                } else {
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                        0, W3_UNABLE_READ_FIRST_HELP,
                        (PSID)NULL, 0,
                        sizeof(err), NULL,
                        (PVOID)(&err));
                }
            } else {
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                    0, W3_UNABLE_READ_FIRST_COUNTER,
                    (PSID)NULL, 0,
                    sizeof(err), NULL,
                    (PVOID)(&err));
            }

            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
        } else {
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                0, W3_UNABLE_OPEN_W3SVC_PERF_KEY,
                (PSID)NULL, 0,
                sizeof(err), NULL,
                (PVOID)(&err));
        }
    }

    //
    //  Bump open counter.
    //

    OpenCount += 1;

end:
    return Error;

}   // OpenPerformanceData

DWORD
CollectPerformanceData(
    LPWSTR lpwszValue, 
    LPVOID *lppData, 
    LPDWORD lpcbBytes, 
    LPDWORD lpcObjectTypes
    )
{

}

DWORD
WINAPI
ClosePerformanceData(
    )
{
    //
    //  Clean up
    //

    OpenCount -= 1;
    if (OpenCount == 0)
    {
        if (hEventLog != NULL) 
        {
            DeregisterEventSource(hEventLog);
            hEventLog = NULL;
        }
    }

    return NO_ERROR;
    
}   // ClosePerformanceData




CUlPerfCounters::CUlPerfCounters()
{

}

CUlPerfCounters::~CUlPerfCounters()
{

}


//
// IWbemProviderInit
//

STDMETHODIMP CUlPerfCounters::Initialize(LPWSTR wszUser,LONG lFlags,LPWSTR wszNamespace,LPWSTR wszLocale,IWbemServices* pNamespace,IWbemContext* pCtx,IWbemProviderInitSink* pInitSink)
{ 
    HRESULT Result;

    ASSERT(pInitSink != NULL);

    TRACE(L"ulperf!CUlPerfCounters::Initialize called\n");

    //
    // tell wbem we are ready to go.
    //
    
    Result = pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    

    return Result; 
    
}   // CUlPerfCounters::Initialize


//
// IWbemServices
//

// Context.
// ========

STDMETHODIMP CUlPerfCounters::OpenNamespace(BSTR strNamespace, long lFlags, IWbemContext* pCtx, IWbemServices** ppWorkingNamespace, IWbemCallResult** ppResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::CancelAsyncCall(IWbemObjectSink* pSink)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::QueryObjectSink(long lFlags,IWbemObjectSink** ppResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


// Classes and instances.
// ======================

STDMETHODIMP CUlPerfCounters::GetObject(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemClassObject** ppObject,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::GetObjectAsync(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ 
    IWbemClassObject pObj;
    HRESULT Result;
    CObjectPathParser PathParser;
    ParsedObjectPath *pParsedPath = NULL;

    Result = WBEM_S_NO_ERROR;

    
    //
    // crack the object path
    //

    Result = PathParser.Parse(strObjectPath, &pParsedPath);
    if (Result != CObjectPathParser::NoError)
        return E_FAIL;

    //
    // create a perfctr object
    //

    pObject = new CComObject<CUlPerfCounterObject>;
    if (pObject == NULL)
    {
        Result = E_OUTOFMEMORY
        goto end;
    }

    //
    // init it
    //
    
    Result = pObject->Init(pParsedPath);
    if (FAILED(Result))
        goto end;

    //
    // and hand it off to wbem
    //
    
    Result = pGroup->_InternalQueryInterface(IID_IWbemClassObject, (PVOID*)&pWbemObj);
    if (FAILED(Result))
        goto end;
    
    Result = pHandler->Indicate(1, &pWbemObj);
    if (FAILED(Result))
        goto end;

end:
    if (pParsedPath != NULL)
    {
        PathParser.Free(pParsedPath);
        pParsedPath = NULL;
    }

    if (pWbemObj != NULL)
    {
        pWbemObj->Release();
        pWbemObj = NULL;
    }
    
    pHandler->SetStatus(0, Result, NULL, NULL);
    return Result; 
    
}

// Class manipulation.
// ===================

STDMETHODIMP CUlPerfCounters::PutClass(IWbemClassObject* pObject,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::PutClassAsync(IWbemClassObject* pObject,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::DeleteClass(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::DeleteClassAsync(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::CreateClassEnum(BSTR strSuperclass,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::CreateClassEnumAsync(BSTR strSuperclass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


// Instances.
// ==========

STDMETHODIMP CUlPerfCounters::PutInstance(IWbemClassObject* pInst,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::PutInstanceAsync(IWbemClassObject* pInst,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::DeleteInstance(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::DeleteInstanceAsync(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::CreateInstanceEnum(BSTR strClass,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::CreateInstanceEnumAsync(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


// Queries.
// ========

STDMETHODIMP CUlPerfCounters::ExecQuery(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::ExecQueryAsync(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


STDMETHODIMP CUlPerfCounters::ExecNotificationQuery(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::ExecNotificationQueryAsync(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }


// Methods
// =======

STDMETHODIMP CUlPerfCounters::ExecMethod(BSTR strObjectPath,BSTR strMethodName,long lFlags,IWbemContext* pCtx,IWbemClassObject* pInParams,IWbemClassObject** ppOutParams,IWbemCallResult** ppCallResult)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }

STDMETHODIMP CUlPerfCounters::ExecMethodAsync(BSTR strObjectPath,BSTR strMethodName,long lFlags,IWbemContext* pCtx,IWbemClassObject* pInParams,IWbemObjectSink* pResponseHandler)
{ return WBEM_E_METHOD_NOT_IMPLEMENTED; }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\ulperf\ulperf.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    ulperf.h

Abstract:

    This is the main header for the ul.sys performance counter support object

Author:

    Paul McDaniel (paulmcd)       10-May-1999

Revision History:

--*/

#ifndef __ULPERF_H_
#define __ULPERF_H_


#include <afxtempl.h>
#include "resource.h"

DEFINE_GUID(CLSID_UlPerfCounters, 0xe8833ce8,0x0722,0x11d3,0xa4,0x41,0x00,0x80,0xc7,0xe1,0x1d,0x99);

//
// CritSecLocker
//
class CritSecLocker
{
public:
    CritSecLocker(CComAutoCriticalSection *pCritSect)
        {
            this->pCritSect = pCritSect;
            if (pCritSect) pCritSect->Lock();
        }
    ~CritSecLocker()
        {
            if (this->pCritSect) this->pCritSect->Unlock();
        }
private:
    CComAutoCriticalSection *pCritSect;
};


//
// CUlPerfCounters
//
class ATL_NO_VTABLE CUlPerfCounters : 
	public CComObjectRoot,
	public CComCoClass<CUlPerfCounters, &CLSID_UlPerfCounters>,
	public IWbemServices,
	public IWbemProviderInit
{
public:
	CUlPerfCounters();
	~CUlPerfCounters();

    DECLARE_REGISTRY_RESOURCEID(IDR_ULPERF)
    DECLARE_NOT_AGGREGATABLE(CUlPerfCounters)

    BEGIN_COM_MAP(CUlPerfCounters)
    	COM_INTERFACE_ENTRY(IWbemServices)
    	COM_INTERFACE_ENTRY(IWbemProviderInit)
    END_COM_MAP()

public:

    //
    // IWbemProviderInit
    //

    STDMETHOD(Initialize)(LPWSTR wszUser,LONG lFlags,LPWSTR wszNamespace,LPWSTR wszLocale,IWbemServices* pNamespace,IWbemContext* pCtx,IWbemProviderInitSink* pInitSink);

    //
    // IWbemServices
    //

    // Context.
    // ========
    
    STDMETHOD(OpenNamespace)(BSTR strNamespace, long lFlags, IWbemContext* pCtx, IWbemServices** ppWorkingNamespace, IWbemCallResult** ppResult);
    STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);

    STDMETHOD(QueryObjectSink)(long lFlags,IWbemObjectSink** ppResponseHandler);

    // Classes and instances.
    // ======================

    STDMETHOD(GetObject)(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemClassObject** ppObject,IWbemCallResult** ppCallResult);
    STDMETHOD(GetObjectAsync)(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    // Class manipulation.
    // ===================

    STDMETHOD(PutClass)(IWbemClassObject* pObject,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult);
    STDMETHOD(PutClassAsync)(IWbemClassObject* pObject,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    STDMETHOD(DeleteClass)(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult);
    STDMETHOD(DeleteClassAsync)(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    STDMETHOD(CreateClassEnum)(BSTR strSuperclass,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum);
    STDMETHOD(CreateClassEnumAsync)(BSTR strSuperclass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    // Instances.
    // ==========

    STDMETHOD(PutInstance)(IWbemClassObject* pInst,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult);
    STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    STDMETHOD(DeleteInstance)(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemCallResult** ppCallResult);
    STDMETHOD(DeleteInstanceAsync)(BSTR strObjectPath,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    STDMETHOD(CreateInstanceEnum)(BSTR strClass,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum);
    STDMETHOD(CreateInstanceEnumAsync)(BSTR strClass,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    // Queries.
    // ========

    STDMETHOD(ExecQuery)(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum);
    STDMETHOD(ExecQueryAsync)(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);
    
    STDMETHOD(ExecNotificationQuery)(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IEnumWbemClassObject** ppEnum);
    STDMETHOD(ExecNotificationQueryAsync)(BSTR strQueryLanguage,BSTR strQuery,long lFlags,IWbemContext* pCtx,IWbemObjectSink* pResponseHandler);

    // Methods
    // =======

    STDMETHOD(ExecMethod)(BSTR strObjectPath,BSTR strMethodName,long lFlags,IWbemContext* pCtx,IWbemClassObject* pInParams,IWbemClassObject** ppOutParams,IWbemCallResult** ppCallResult);
    STDMETHOD(ExecMethodAsync)(BSTR strObjectPath,BSTR strMethodName,long lFlags,IWbemContext* pCtx,IWbemClassObject* pInParams,IWbemObjectSink* pResponseHandler);


public:

    CComAutoCriticalSection CritSect;

};



//
// Globals
//

extern LONG                g_lInit;
extern HINSTANCE           g_hInstance;

typedef struct _UL_PERF_OBJECT_DEFINITION
{
    PERF_OBJECT_TYPE            ObjectType;
    
    PERF_COUNTER_DEFINITION     BytesSent;
    PERF_COUNTER_DEFINITION     BytesReceived;

    PERF_COUNTER_DEFINITION     CurrentConnections;
    PERF_COUNTER_DEFINITION     CurrentRequests;

    PERF_COUNTER_DEFINITION     QueuedRequests;
    PERF_COUNTER_DEFINITION     AttachedProcesses;

} UL_PERF_OBJECT_DEFINITION;

typedef struct _UL_COUNTER_BLOCK 
{

    PERF_COUNTER_BLOCK  PerfCounterBlock;

    DWORD               BytesSent;
    DWORD               BytesReceived;

    DWORD               CurrentConnections;
    DWORD               CurrentRequests;

    DWORD               QueuedRequests;
    DWORD               AttachedProcesses;
    
} UL_COUNTER_BLOCK;

extern  UL_PERF_OBJECT_DEFINITION    PerfObjectDefinition;

#endif // __ULPERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\util\precomp.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    Master include file for the UL.SYS test app.

Author:

    Keith Moore (keithmo)       19-Jun-1998

Revision History:

--*/


#ifndef _PRECOMP_H_
#define _PRECOMP_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tdi.h>
#include <ntosp.h>

#define NOWINBASEINTERLOCK
#include <windows.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <wchar.h>

#include <http.h>
#include <httpapi.h>


//
// Heap manipulators.
//

#define ALLOC(len)  (PVOID)RtlAllocateHeap( RtlProcessHeap(), 0, (len) )
#define FREE(ptr)   (VOID)RtlFreeHeap( RtlProcessHeap(), 0, (ptr) )


//
// Generate a breakpoint, but only if we're running under
// the debugger.
//

#define DEBUG_BREAK()                                                       \
    if (TEST_OPTION(EnableBreak) && IsDebuggerPresent()) {                  \
        DebugBreak();                                                       \
    } else


#endif  // _PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\util\tul.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    tul.c

Abstract:

    Stupid test file for HTTP.SYS (formerly UL.SYS).

Author:

    Keith Moore (keithmo)        17-Jun-1998

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop
#include <..\..\drv\config.h>

// this funny business gets me the UL_DEBUG_* flags on free builds
#if !DBG
#undef DBG
#define DBG 1
#define DBG_FLIP
#endif

#include <..\..\drv\debug.h>

#ifdef DBG_FLIP
#undef DBG_FLIP
#undef DBG
#define DBG 0
#endif

//
// Our command table.
//

typedef
INT
(WINAPI * PFN_COMMAND)(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

typedef struct _COMMAND_ENTRY
{
    PWSTR pCommandName;
    PWSTR pUsageHelp;
    PFN_COMMAND pCommandHandler;
    BOOL AutoStartUl;
} COMMAND_ENTRY, *PCOMMAND_ENTRY;


//
// Performance counters.
//

#if LATER
typedef enum _COUNTER_TYPE
{
    Cumulative,
    Percentage,
    Average

} COUNTER_TYPE, *PCOUNTER_TYPE;

typedef struct _PERF_COUNTER
{
    PWSTR pDisplayName;
    LONG FieldOffset;
    COUNTER_TYPE Type;

} PERF_COUNTER, *PPERF_COUNTER;

#define MAKE_CUMULATIVE( name )                                             \
    {                                                                       \
        (PWSTR)L#name,                                                      \
        FIELD_OFFSET( UL_PERF_COUNTERS_USER, name ),                        \
        Cumulative                                                          \
    }

#define MAKE_PERCENTAGE( name )                                             \
    {                                                                       \
        (PWSTR)L#name,                                                      \
        FIELD_OFFSET( UL_PERF_COUNTERS_USER, name ),                        \
        Percentage                                                          \
    }

#define MAKE_AVERAGE( name )                                                \
    {                                                                       \
        (PWSTR)L#name,                                                      \
        FIELD_OFFSET( UL_PERF_COUNTERS_USER, name ),                        \
        Average                                                             \
    }

PERF_COUNTER UlPerfCounters[] =
    {
        MAKE_CUMULATIVE( BytesReceived ),
        MAKE_CUMULATIVE( BytesSent ),
        MAKE_CUMULATIVE( ConnectionsReceived ),
        MAKE_CUMULATIVE( FilesSent ),
        MAKE_CUMULATIVE( FileCacheAttempts ),
        MAKE_PERCENTAGE( FileCacheHits ),
        MAKE_CUMULATIVE( FileCacheNegativeHits ),
        MAKE_CUMULATIVE( FileCacheEntries ),
        MAKE_CUMULATIVE( FastAcceptAttempted ),
        MAKE_PERCENTAGE( FastAcceptSucceeded ),
        MAKE_CUMULATIVE( FastReceiveAttempted ),
        MAKE_PERCENTAGE( FastReceiveSucceeded ),
        MAKE_CUMULATIVE( FastSendAttempted ),
        MAKE_PERCENTAGE( FastSendSucceeded ),
        MAKE_CUMULATIVE( MdlReadAttempted ),
        MAKE_PERCENTAGE( MdlReadSucceeded ),
        MAKE_CUMULATIVE( DecAvailThreads ),
        MAKE_AVERAGE( DecAvailThreadsRetry ),
        MAKE_CUMULATIVE( IncAvailThreads ),
        MAKE_AVERAGE( IncAvailThreadsRetry ),
        MAKE_CUMULATIVE( DecAvailPending ),
        MAKE_AVERAGE( DecAvailPendingRetry ),
        MAKE_CUMULATIVE( DecNumberOfThreads ),
        MAKE_AVERAGE( DecNumberOfThreadsRetry ),
        MAKE_CUMULATIVE( IncNumberOfThreads ),
        MAKE_AVERAGE( IncNumberOfThreadsRetry ),
        MAKE_CUMULATIVE( CreateSession ),
        MAKE_AVERAGE( CreateSessionRetry ),
        MAKE_CUMULATIVE( DestroySession ),
        MAKE_AVERAGE( DestroySessionRetry ),
        MAKE_CUMULATIVE( IncAcceptPending ),
        MAKE_AVERAGE( IncAcceptPendingRetry ),
        MAKE_CUMULATIVE( DecAcceptPending ),
        MAKE_AVERAGE( DecAcceptPendingRetry ),
        MAKE_CUMULATIVE( PerCpuNetworkDpcCounters[0] ),
        MAKE_CUMULATIVE( PerCpuNetworkDpcCounters[1] ),
        MAKE_CUMULATIVE( PerCpuNetworkDpcCounters[2] ),
        MAKE_CUMULATIVE( PerCpuNetworkDpcCounters[3] ),
        MAKE_CUMULATIVE( PerCpuFileSystemDpcCounters[0] ),
        MAKE_CUMULATIVE( PerCpuFileSystemDpcCounters[1] ),
        MAKE_CUMULATIVE( PerCpuFileSystemDpcCounters[2] ),
        MAKE_CUMULATIVE( PerCpuFileSystemDpcCounters[3] ),
        MAKE_CUMULATIVE( PerCpuThreadPoolActivity[0] ),
        MAKE_CUMULATIVE( PerCpuThreadPoolActivity[1] ),
        MAKE_CUMULATIVE( PerCpuThreadPoolActivity[2] ),
        MAKE_CUMULATIVE( PerCpuThreadPoolActivity[3] )
    };

#define NUM_PERF_COUNTERS (sizeof(UlPerfCounters) / sizeof(UlPerfCounters[0]))

#define GET_LONGLONG( buffer, offset )                                      \
    *(LONGLONG *)(((PCHAR)(buffer)) + (offset))
#endif  // LATER


//
// Configuration stuff.
//

typedef struct _CONFIG_ENTRY
{
    PWSTR pConfigName;
    PWSTR pDisplayFormat;
    ULONG Type;
    LONGLONG SavedValue;
    LONG Status;

} CONFIG_ENTRY, *PCONFIG_ENTRY;

CONFIG_ENTRY ConfigTable[] =
    {
        {
            REGISTRY_IRP_STACK_SIZE,
            L"%lu",
            REG_DWORD,
            DEFAULT_IRP_STACK_SIZE
        },

        {
            REGISTRY_PRIORITY_BOOST,
            L"%lu",
            REG_DWORD,
            DEFAULT_PRIORITY_BOOST
        },

        {
            REGISTRY_DEBUG_FLAGS,
            L"%08lx",
            REG_DWORD,
            DEFAULT_DEBUG_FLAGS
        },

        {
            REGISTRY_BREAK_ON_STARTUP,
            L"%lu",
            REG_DWORD,
            DEFAULT_BREAK_ON_STARTUP
        },

        {
            REGISTRY_BREAK_ON_ERROR,
            L"%lu",
            REG_DWORD,
            DEFAULT_BREAK_ON_ERROR
        },

        {
            REGISTRY_VERBOSE_ERRORS,
            L"%lu",
            REG_DWORD,
            DEFAULT_VERBOSE_ERRORS
        },

        {
            REGISTRY_ENABLE_UNLOAD,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_UNLOAD
        },

        {
            REGISTRY_ENABLE_SECURITY,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_SECURITY
        },

        {
            REGISTRY_MIN_IDLE_CONNECTIONS,
            L"%lu",
            REG_DWORD,
            DEFAULT_MIN_IDLE_CONNECTIONS
        },

        {
            REGISTRY_MAX_IDLE_CONNECTIONS,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_IDLE_CONNECTIONS
        },

        {
            REGISTRY_IRP_CONTEXT_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_IRP_CONTEXT_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_RCV_BUFFER_SIZE,
            L"%lu",
            REG_DWORD,
            DEFAULT_RCV_BUFFER_SIZE
        },

        {
            REGISTRY_RCV_BUFFER_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_RCV_BUFFER_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_RESOURCE_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_RESOURCE_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_REQ_BUFFER_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_REQ_BUFFER_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_INT_REQUEST_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_INT_REQUEST_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_RESP_BUFFER_SIZE,
            L"%lu",
            REG_DWORD,
            DEFAULT_RESP_BUFFER_SIZE
        },

        {
            REGISTRY_RESP_BUFFER_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_RESP_BUFFER_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_SEND_TRACKER_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_SEND_TRACKER_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_LOG_BUFFER_LOOKASIDE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_LOG_BUFFER_LOOKASIDE_DEPTH
        },

        {
            REGISTRY_MAX_INTERNAL_URL_LENGTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_INTERNAL_URL_LENGTH
        },

        {
            REGISTRY_MAX_REQUEST_BYTES,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_REQUEST_BYTES
        },

        {
            REGISTRY_ENABLE_CONNECTION_REUSE,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_CONNECTION_REUSE
        },

        {
            REGISTRY_ENABLE_NAGLING,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_NAGLING
        },

        {
            REGISTRY_ENABLE_THREAD_AFFINITY,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_THREAD_AFFINITY
        },

        {
            REGISTRY_THREAD_AFFINITY_MASK,
            L"%I64x",
            REG_QWORD,
            0
        },

        {
            REGISTRY_THREADS_PER_CPU,
            L"%lu",
            REG_DWORD,
            DEFAULT_THREADS_PER_CPU
        },

        {
            REGISTRY_MAX_WORK_QUEUE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_WORK_QUEUE_DEPTH,
        },

        {
            REGISTRY_MIN_WORK_DEQUEUE_DEPTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_MIN_WORK_DEQUEUE_DEPTH,
        },

        {
            REGISTRY_MAX_URL_LENGTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_URL_LENGTH
        },

        {
            REGISTRY_MAX_FIELD_LENGTH,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_FIELD_LENGTH
        },

        {
            REGISTRY_DEBUG_LOGTIMER_CYCLE,
            L"%lu",
            REG_DWORD,
            DEFAULT_DEBUG_LOGTIMER_CYCLE
        },

        {
            REGISTRY_DEBUG_LOG_BUFFER_PERIOD,
            L"%lu",
            REG_DWORD,
            DEFAULT_DEBUG_LOG_BUFFER_PERIOD
        },

        {
            REGISTRY_LOG_BUFFER_SIZE,
            L"%lu",
            REG_DWORD,
            DEFAULT_LOG_BUFFER_SIZE
        },

        {
            REGISTRY_ENABLE_NON_UTF8_URL,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_NON_UTF8_URL
        },

        {
            REGISTRY_ENABLE_DBCS_URL,
            L"%lu",
            REG_DWORD,
            DEFAULT_ENABLE_DBCS_URL
        },

        {
            REGISTRY_FAVOR_DBCS_URL,
            L"%lu",
            REG_DWORD,
            DEFAULT_FAVOR_DBCS_URL
        },

        {
            REGISTRY_CACHE_ENABLED,
            L"%lu",
            REG_DWORD,
            DEFAULT_CACHE_ENABLED
        },

        {
            REGISTRY_MAX_CACHE_URI_COUNT,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_CACHE_URI_COUNT
        },

        {
            REGISTRY_MAX_CACHE_MEGABYTE_COUNT,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_CACHE_MEGABYTE_COUNT
        },

        {
            REGISTRY_CACHE_SCAVENGER_PERIOD,
            L"%lu",
            REG_DWORD,
            DEFAULT_CACHE_SCAVENGER_PERIOD
        },

        {
            REGISTRY_MAX_URI_BYTES,
            L"%lu",
            REG_DWORD,
            DEFAULT_MAX_URI_BYTES
        },

        {
            REGISTRY_HASH_TABLE_BITS,
            L"%ld",
            REG_DWORD,
            DEFAULT_HASH_TABLE_BITS
        },

        {
            REGISTRY_LARGE_MEM_MEGABYTES,
            L"%ld",
            REG_DWORD,
            DEFAULT_LARGE_MEM_MEGABYTES
        },

        {
            REGISTRY_OPAQUE_ID_TABLE_SIZE,
            L"%lu",
            REG_DWORD,
            DEFAULT_OPAQUE_ID_TABLE_SIZE
        },

    };

#define NUM_CONFIG_ENTRIES (sizeof(ConfigTable) / sizeof(ConfigTable[0]))

#define DEFAULT_SUFFIX_SZ L" [default]"


typedef struct _FLAG_ENTRY {
    PWSTR pName;
    PWSTR pDisplayFormat;
    LONG  Value;
} FLAG_ENTRY, *PFLAG_ENTRY;

#define MAKE_FLAG( name, display )                                          \
    {                                                                       \
        (PWSTR)L#name,                                                      \
        (display),                                                          \
        UL_DEBUG_ ## name                                                   \
    }

FLAG_ENTRY FlagTable[] =
{
    MAKE_FLAG(OPEN_CLOSE, L"file object create/close"),
    MAKE_FLAG(SEND_RESPONSE, L"send response ioctl"),
    MAKE_FLAG(SEND_BUFFER, L"send buffer"),
    MAKE_FLAG(TDI, L"low level network stuff"),

    MAKE_FLAG(FILE_CACHE, L"open/close files"),
    MAKE_FLAG(CONFIG_GROUP_FNC, L"config group changes"),
    MAKE_FLAG(CONFIG_GROUP_TREE, L"cgroup tree operations"),
    MAKE_FLAG(REFCOUNT, L"object refcounting"),

    MAKE_FLAG(HTTP_IO, L"high level network & buffers"),
    MAKE_FLAG(ROUTING, L"request to process routing"),
    MAKE_FLAG(URI_CACHE, L"uri content cache"),
    MAKE_FLAG(PARSER, L"request parsing"),

    MAKE_FLAG(SITE, L"sites and endpoints"),
    MAKE_FLAG(WORK_ITEM, L"thread pool work queue"),
    MAKE_FLAG(FILTER, L"filters and ssl"),
    MAKE_FLAG(LOGGING, L"ul logging"),

    MAKE_FLAG(TC, L"traffic control"),
    MAKE_FLAG(OPAQUE_ID, L"opaque ids"),
    MAKE_FLAG(PERF_COUNTERS, L"perf counters"),
    MAKE_FLAG(LKRHASH, L"LKRhash hashtables"),

    MAKE_FLAG(TIMEOUTS, L"timeout monitor"),
    MAKE_FLAG(LIMITS, L"connection limits"),
    MAKE_FLAG(LARGE_MEM, L"large memory"),
    MAKE_FLAG(IOCTL, L"ioctl"),

    MAKE_FLAG(VERBOSE, L"verbose"),
};

#define NUM_FLAG_ENTRIES (sizeof(FlagTable) / sizeof(FlagTable[0]))


DEFINE_COMMON_GLOBALS();


VOID
Usage(
    VOID
    );

NTSTATUS
OpenUlDevice(
    PHANDLE pHandle
    );

BOOL
TryToStartUlDevice(
    VOID
    );

INT
LongLongToString(
    LONGLONG Value,
    PWSTR pBuffer
    );

LONG
CalcPercentage(
    LONGLONG High,
    LONGLONG Low
    );

PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    );

PCONFIG_ENTRY
FindConfigByName(
    IN PWSTR pConfig
    );

ULONG
FindFlagByName(
    IN PWSTR pFlagName
    );

INT
ControlHttpServer(
    IN HANDLE UlHandle,
    IN ULONG Command
    );

VOID
DumpConfiguration(
    IN HKEY Key
    );

VOID
DumpFlags(
    IN HKEY Key
    );


#if LATER
INT
WINAPI
DoStart(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoStop(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoPause(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoContinue(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoQuery(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoPerf(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoClear(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoFlush(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );
#endif  // LATER

INT
WINAPI
DoConfig(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

INT
WINAPI
DoFlags(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    );

COMMAND_ENTRY CommandTable[] =
    {
#if LATER
        {
            L"start",
            L"starts the server",
            &DoStart,
            TRUE
        },

        {
            L"stop",
            L"stops the server",
            &DoStop,
            TRUE
        },

        {
            L"pause",
            L"pauses the server",
            &DoPause,
            TRUE
        },

        {
            L"continue",
            L"continues the server",
            &DoContinue,
            TRUE
        },

        {
            L"query",
            L"queries the current state",
            &DoQuery,
            TRUE
        },

        {
            L"perf",
            L"displays perf counters",
            &DoPerf,
            TRUE
        },

        {
            L"clear",
            L"clears perf counters",
            &DoClear,
            TRUE
        },

        {
            L"flush",
            L"flushes file cache",
            &DoFlush,
            TRUE
        },
#endif  // LATER

        {
            L"config",
            L"configures the server",
            &DoConfig,
            FALSE
        },

        {
            L"flags",
            L"configures debug flags",
            &DoFlags,
            FALSE
        }

    };

#define NUM_COMMAND_ENTRIES (sizeof(CommandTable) / sizeof(CommandTable[0]))


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    NTSTATUS status;
    HANDLE handle;
    PCOMMAND_ENTRY pEntry;
    INT result;
    ULONG err;

    //
    // Initialize.
    //

    setvbuf( stdin,  NULL, _IONBF, 0 );
    setvbuf( stdout, NULL, _IONBF, 0 );

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = NULL;

    //
    // Find the command handler.
    //

    if (argc == 1)
    {
        pEntry = NULL;
    }
    else
    {
        pEntry = FindCommandByName( argv[1] );
    }

    if (pEntry == NULL)
    {
        Usage();
        result = 1;
        goto cleanup;
    }

    //
    // Open the UL.SYS device.
    //

    status = OpenUlDevice( &handle );

    if (!NT_SUCCESS(status))
    {
        if (pEntry->AutoStartUl)
        {
            if (TryToStartUlDevice())
            {
                status = OpenUlDevice( &handle );
            }
        }
        else
        {
            status = STATUS_SUCCESS;
        }
    }

    if (!NT_SUCCESS(status))
    {
        wprintf(
            L"Cannot open %s, error %08lx\n",
            HTTP_CONTROL_DEVICE_NAME,
            status
            );

        result = 1;
        goto cleanup;
    }

    //
    // Call the handler.
    //

    argc--;
    argv++;

    result = (pEntry->pCommandHandler)(
                 handle,
                 argc,
                 argv
                 );

cleanup:

    if (handle != NULL)
    {
        NtClose( handle );
    }

    return result;

}   // main


PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
     {
        if (_wcsicmp( pCommand, pEntry->pCommandName ) == 0)
        {
            return pEntry;
        }
    }

    return NULL;

}   // FindCommandByName


PCONFIG_ENTRY
FindConfigByName(
    IN PWSTR pConfig
    )
{
    PCONFIG_ENTRY pEntry;
    INT i;
    INT len;

    //
    // First off, validate that the incoming configuration name
    // is of the form "property=". The trailing '=' is required.
    //

    len = wcslen( pConfig );

    if (pConfig[len - 1] != L'=')
    {
        return NULL;
    }

    len--;

    for (i = NUM_CONFIG_ENTRIES, pEntry = &ConfigTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        if ((INT)wcslen( pEntry->pConfigName ) == len &&
            _wcsnicmp( pConfig, pEntry->pConfigName, len ) == 0)
        {
            return pEntry;
        }
    }

    return NULL;

}   // FindConfigByName



ULONG
FindFlagByName(
    IN PWSTR pFlagName
    )
{
    INT len;
    ULONG flags;
    ULONG i;

    len = wcslen(pFlagName);
    if ((len > 2) && (wcsncmp(pFlagName, L"0x", 2) == 0)) {
        // numeric flag
        flags = wcstoul(pFlagName, NULL, 16);
    } else {
        // named flag
        flags = 0;
        for (i = 0; i < NUM_FLAG_ENTRIES; i++) {
            if (_wcsicmp(pFlagName, FlagTable[i].pName) == 0) {
                flags = FlagTable[i].Value;
                break;
            }
        }
    }

    return flags;
}


VOID
Usage(
    VOID
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;
    INT maxLength;
    INT len;

    //
    // Scan the command table, searching for the longest command name.
    // (This makes the output much prettier...)
    //

    maxLength = 0;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        len = wcslen( pEntry->pCommandName );

        if (len > maxLength)
        {
            maxLength = len;
        }
    }

    //
    // Now display the usage information.
    //

    wprintf(
        L"use: tul action [options]\n"
        L"\n"
        L"valid actions are:\n"
        L"\n"
        );

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        wprintf(
            L"    %-*s - %s\n",
            maxLength,
            pEntry->pCommandName,
            pEntry->pUsageHelp
            );
    }

}   // Usage


NTSTATUS
OpenUlDevice(
    PHANDLE pHandle
    )
{
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING deviceName;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Open the UL device.
    //

    RtlInitUnicodeString(
        &deviceName,
        HTTP_CONTROL_DEVICE_NAME
        );

    InitializeObjectAttributes(
        &objectAttributes,                      // ObjectAttributes
        &deviceName,                            // ObjectName
        OBJ_CASE_INSENSITIVE,                   // Attributes
        NULL,                                   // RootDirectory
        NULL                                    // SecurityDescriptor
        );

    status = NtCreateFile(
                pHandle,                        // FileHandle
                GENERIC_READ |                  // DesiredAccess
                    GENERIC_WRITE |
                    SYNCHRONIZE,
                &objectAttributes,              // ObjectAttributes
                &ioStatusBlock,                 // IoStatusBlock
                NULL,                           // AllocationSize
                0,                              // FileAttributes
                FILE_SHARE_READ |               // ShareAccess
                    FILE_SHARE_WRITE,
                FILE_OPEN_IF,                   // CreateDisposition
                FILE_SYNCHRONOUS_IO_NONALERT,   // CreateOptions
                NULL,                           // EaBuffer
                0                               // EaLength
                );

    if (!NT_SUCCESS(status))
    {
        *pHandle = NULL;
    }

    return status;

}   // OpenHdhDevice


BOOL
TryToStartUlDevice(
    VOID
    )
{
    BOOL result = FALSE;
    SC_HANDLE scHandle = NULL;
    SC_HANDLE svcHandle = NULL;

    scHandle = OpenSCManager(
                   NULL,
                   NULL,
                   SC_MANAGER_ALL_ACCESS
                   );

    if (scHandle == NULL)
    {
        goto exit;
    }

    svcHandle = OpenService(
                    scHandle,
                    L"Ul",
                    SERVICE_ALL_ACCESS
                    );

    if (svcHandle == NULL)
    {
        goto exit;
    }

    if (!StartService( svcHandle, 0, NULL ))
    {
        goto exit;
    }

    result = TRUE;

exit:

    if (svcHandle != NULL)
    {
        CloseServiceHandle( svcHandle );
    }

    if (scHandle != NULL)
    {
        CloseServiceHandle( scHandle );
    }

    return result;

}   // TryToStartHdhDevice


INT
LongLongToString(
    LONGLONG Value,
    PWSTR pBuffer
    )
{
    PWSTR p1;
    PWSTR p2;
    WCHAR ch;
    INT digit;
    BOOL negative;
    INT count;
    BOOL needComma;
    INT length;
    ULONGLONG unsignedValue;

    //
    // Handling zero specially makes everything else a bit easier.
    //

    if (Value == 0)
    {
        wcscpy( pBuffer, L"0" );
        return 1;
    }

    //
    // Remember if the value is negative.
    //

    if (Value < 0)
    {
        negative = TRUE;
        unsignedValue = (ULONGLONG)-Value;
    }
    else
    {
        negative = FALSE;
        unsignedValue = (ULONGLONG)Value;
    }

    //
    // Pull the least signifigant digits off the value and store them
    // into the buffer. Note that this will store the digits in the
    // reverse order.
    //

    p1 = p2 = pBuffer;
    count = 3;
    needComma = FALSE;

    while (unsignedValue != 0)
    {
        if (needComma)
        {
            *p1++ = L',';
            needComma = FALSE;
        }

        digit = (INT)( unsignedValue % 10 );
        unsignedValue = unsignedValue / 10;

        *p1++ = L'0' + digit;

        count--;
        if (count == 0)
        {
            count = 3;
            needComma = TRUE;
        }
    }

    //
    // Tack on a leading L'-' if necessary.
    //

    if (negative)
    {
        *p1++ = L'-';
    }

    length = (INT)( p1 - pBuffer );

    //
    // Reverse the digits in the buffer.
    //

    *p1-- = L'\0';

    while (p1 > p2)
    {
        ch = *p1;
        *p1 = *p2;
        *p2 = ch;

        p2++;
        p1--;
    }

    return length;

}   // LongLongToString


LONG
CalcPercentage(
    LONGLONG High,
    LONGLONG Low
    )
{

    LONG result;

    if (High == 0 || Low == 0)
    {
        result = 0;
    }
    else
    {
        result = (LONG)( ( Low * 100 ) / High );
    }

    return result;

}   // CalcPercentage

#if LATER

INT
ControlHttpServer(
    IN HANDLE UlHandle,
    IN ULONG Command
    )
{

    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;
    UL_CONTROL_HTTP_SERVER_INFO controlInfo;

    controlInfo.Command = Command;

    //
    // Issue the request.
    //

    status = NtDeviceIoControlFile(
                 UlHandle,                     // FileHandle
                 NULL,                          // Event
                 NULL,                          // ApcRoutine
                 NULL,                          // ApcContext
                 &ioStatusBlock,                // IoStatusBlock
                 IOCTL_UL_CONTROL_HTTP_SERVER, // IoControlCode
                 &controlInfo,                  // InputBuffer
                 sizeof(controlInfo),           // InputBufferLength,
                 &controlInfo,                  // OutputBuffer,
                 sizeof(controlInfo)            // OutputBufferLength
                 );

    if (!NT_SUCCESS(status))
    {
        wprintf(
            L"NtDeviceIoControlFile() failed, error %08lx\n",
            status
            );
        return 1;
    }

    wprintf(
        L"HTTP server state = %lu (%s)\n",
        controlInfo.State,
        UlStateToString( controlInfo.State )
        );

    return 0;

}   // ControlHttpServer
#endif  // LATER


VOID
DumpConfiguration(
    IN HKEY Key
    )
{
    PCONFIG_ENTRY pEntry;
    INT i;
    INT len;
    INT maxNameLength;
    INT maxValueLength;
    LONG err;
    LONG longValue;
    DWORD type;
    DWORD length;
    PWSTR pDefaultSuffix;
    WCHAR stringValue[MAX_PATH];

    //
    // Scan the config table, searching for the longest parameter name.
    // (This makes the output much prettier...)
    //

    maxNameLength = 0;
    maxValueLength = 0;

    for (i = NUM_CONFIG_ENTRIES, pEntry = &ConfigTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        len = wcslen( pEntry->pConfigName );

        if (len > maxNameLength)
        {
            maxNameLength = len;
        }

        if (pEntry->Type == REG_DWORD)
        {
            length = sizeof(pEntry->SavedValue);

            pEntry->Status = RegQueryValueEx(
                                    Key,
                                    pEntry->pConfigName,
                                    NULL,
                                    &type,
                                    (LPBYTE)&pEntry->SavedValue,
                                    &length
                                    );

            len = swprintf(
                        stringValue,
                        pEntry->pDisplayFormat,
                        (LONG) pEntry->SavedValue
                        );

            if (len > maxValueLength)
            {
                maxValueLength = len;
            }
        }
        else if (pEntry->Type == REG_QWORD)
        {
            length = sizeof(pEntry->SavedValue);

            pEntry->Status = RegQueryValueEx(
                                    Key,
                                    pEntry->pConfigName,
                                    NULL,
                                    &type,
                                    (LPBYTE)&pEntry->SavedValue,
                                    &length
                                    );

            len = swprintf(
                        stringValue,
                        pEntry->pDisplayFormat,
                        (LONGLONG) pEntry->SavedValue
                        );

            if (len > maxValueLength)
            {
                maxValueLength = len;
            }
        }
    }

    //
    // Now display the parameters.
    //

    wprintf( L"Configuration:\n" );

    for (i = NUM_CONFIG_ENTRIES, pEntry = &ConfigTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        len = 0;
        pDefaultSuffix = L"";

        if (pEntry->Type == REG_DWORD)
        {
            swprintf(
                stringValue,
                pEntry->pDisplayFormat,
                (LONG) pEntry->SavedValue
                );

            if (pEntry->Status != NO_ERROR)
            {
                pDefaultSuffix = DEFAULT_SUFFIX_SZ;
            }

            len = maxValueLength;
        }
        else if (pEntry->Type == REG_QWORD)
        {
            swprintf(
                stringValue,
                pEntry->pDisplayFormat,
                (LONGLONG) pEntry->SavedValue
                );

            if (pEntry->Status != NO_ERROR)
            {
                pDefaultSuffix = DEFAULT_SUFFIX_SZ;
            }

            len = maxValueLength;
        }
        else
        {
            length = sizeof(stringValue) / sizeof(stringValue[0]);

            err = RegQueryValueEx(
                        Key,
                        pEntry->pConfigName,
                        NULL,
                        &type,
                        (LPBYTE)stringValue,
                        &length
                        );

            if (err != NO_ERROR)
            {
                wcscpy(
                    stringValue,
                    ( pEntry->SavedValue == 0 )
                        ? L"(null)"
                        : (PWSTR)pEntry->SavedValue
                    );

                pDefaultSuffix = DEFAULT_SUFFIX_SZ;
            }
        }

        wprintf(
            L"    %-*s : %*s%s\n",
            maxNameLength,
            pEntry->pConfigName,
            len,
            stringValue,
            pDefaultSuffix
            );
    }

}   // DumpConfiguration


VOID
DumpFlags(
    IN HKEY Key
    )
{
    LONG err;
    DWORD length;
    DWORD flags;
    DWORD flagsDisplayed;
    ULONG i;

    //
    // Read the flags from the registry
    //

    flags = DEFAULT_DEBUG_FLAGS;
    length = sizeof(flags);

    err = RegQueryValueEx(
                Key,                    // key
                REGISTRY_DEBUG_FLAGS,   // name
                NULL,                   // reserved
                NULL,                   // type
                (LPBYTE) &flags,        // value
                &length                 // value length
                );


    //
    // Now display the flags
    //
    flagsDisplayed = 0;

    wprintf( L"\n");
    for (i = 0; i < NUM_FLAG_ENTRIES; i++) {
        wprintf(
            L"%-20s",
            FlagTable[i].pName
            );

        if (flags & FlagTable[i].Value) {
            wprintf(L"[on]    ");
            flagsDisplayed |= FlagTable[i].Value;
        } else {
            wprintf(L"        ");
        }

        wprintf(L"%s\n", FlagTable[i].pDisplayFormat);
    }
    wprintf( L"\n" );

    //
    // dump any set flags that we missed
    //
    flags &= ~flagsDisplayed;
    if (flags) {
        wprintf(L"The following set flags are not in the table 0x%08x\n\n", flags);
    }

    //
    // a handy thing to cut and paste
    //
    wprintf(L"tul flags 0x%08x\n", flags | flagsDisplayed);

}   // DumpFlags

#if LATER

INT
WINAPI
DoStart(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    INT result;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul start\n"
            );
        return 1;
    }

    //
    // Do it.
    //

    result = ControlHttpServer(
                 UlHandle,
                 UL_HTTP_SERVER_COMMAND_START
                 );

    return result;

}   // DoStart


INT
WINAPI
DoStop(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    INT result;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul stop\n"
            );
        return 1;
    }

    //
    // Do it.
    //

    result = ControlHttpServer(
                 UlHandle,
                 UL_HTTP_SERVER_COMMAND_STOP
                 );

    return result;

}   // DoStop


INT
WINAPI
DoPause(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    INT result;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul pause\n"
            );
        return 1;
    }

    //
    // Do it.
    //

    result = ControlHttpServer(
                 UlHandle,
                 UL_HTTP_SERVER_COMMAND_PAUSE
                 );

    return result;

}   // DoPause


INT
WINAPI
DoContinue(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    INT result;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul continue\n"
            );
        return 1;
    }

    //
    // Do it.
    //

    result = ControlHttpServer(
                 UlHandle,
                 UL_HTTP_SERVER_COMMAND_CONTINUE
                 );

    return result;

}   // DoContinue


INT
WINAPI
DoQuery(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    INT result;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul query\n"
            );
        return 1;
    }

    //
    // Do it.
    //

    result = ControlHttpServer(
                 UlHandle,
                 UL_HTTP_SERVER_COMMAND_QUERY
                 );

    return result;

}   // DoQuery


INT
WINAPI
DoPerf(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    UL_PERF_COUNTERS_USER perfCounters;
    IO_STATUS_BLOCK ioStatusBlock;
    NTSTATUS status;
    INT i;
    INT maxNameLength;
    INT maxValueLength;
    INT len;
    PPERF_COUNTER counter;
    WCHAR value[32];
    WCHAR suffix[32];

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul perf\n"
            );
        return 1;
    }

    //
    // Read the perf counters.
    //

    status = NtDeviceIoControlFile(
                 UlHandle,                     // FileHandle
                 NULL,                          // Event
                 NULL,                          // ApcRoutine
                 NULL,                          // ApcContext
                 &ioStatusBlock,                // IoStatusBlock
                 IOCTL_UL_QUERY_PERF_COUNTERS, // IoControlCode
                 NULL,                          // InputBuffer
                 0,                             // InputBufferLength,
                 &perfCounters,                 // OutputBuffer,
                 sizeof(perfCounters)           // OutputBufferLength
                 );

    if (!NT_SUCCESS(status))
    {
        wprintf(
            L"NtDeviceIoControlFile() failed, error %08lx\n",
            status
            );
        return 1;
    }

    //
    // Pass 1: Calculate the maximum lengths of the display names and
    // the printable values.
    //

    maxNameLength = 0;
    maxValueLength = 0;

    for( i = NUM_PERF_COUNTERS, counter = UlPerfCounters ;
         i > 0 ;
         i--, counter++ ) {

        len = wcslen( counter->DisplayName );
        if (len > maxNameLength)
        {
            maxNameLength = len;
        }

        len = LongLongToString(
                  GET_LONGLONG( &perfCounters, counter->FieldOffset ),
                  value
                  );
        if (len > maxValueLength)
        {
            maxValueLength = len;
        }

    }

    //
    // Pass 2: Display the counters.
    //

    wprintf( L"Performance Counters:\n" );

    for( i = NUM_PERF_COUNTERS, counter = UlPerfCounters ;
         i > 0 ;
         i--, counter++ ) {

        LongLongToString(
            GET_LONGLONG( &perfCounters, counter->FieldOffset ),
            value
            );

        suffix[0] = '\0';   // until proven otherwise...

        if (counter->Type == Percentage)
        {
            LONGLONG high;
            LONGLONG low;

            high = GET_LONGLONG( &perfCounters, counter[-1].FieldOffset );
            low = GET_LONGLONG( &perfCounters, counter->FieldOffset );

            if (high != 0 || low != 0)
            {
                swprintf(
                    suffix,
                    L" [%ld%%]",
                    CalcPercentage(
                        high,
                        low
                        )
                    );
            }
        }
        else
        if (counter->Type == Average)
        {
            LONGLONG numerator;
            LONGLONG divisor;
            float average;

            numerator = GET_LONGLONG( &perfCounters, counter->FieldOffset );
            divisor = GET_LONGLONG( &perfCounters, counter[-1].FieldOffset );

            if (divisor != 0)
            {
                average = (float)numerator / (float)divisor;

                swprintf(
                    suffix,
                    L" [%.3f]",
                    average
                    );
            }
        }

        wprintf(
            L"    %-*s = %*s%s\n",
            maxNameLength,
            counter->DisplayName,
            maxValueLength,
            value,
            suffix
            );

    }

    return 0;

}   // DoPerf


INT
WINAPI
DoClear(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul clear\n"
            );
        return 1;
    }

    //
    // Issue the request.
    //

    status = NtDeviceIoControlFile(
                 UlHandle,                     // FileHandle
                 NULL,                          // Event
                 NULL,                          // ApcRoutine
                 NULL,                          // ApcContext
                 &ioStatusBlock,                // IoStatusBlock
                 IOCTL_UL_CLEAR_PERF_COUNTERS, // IoControlCode
                 NULL,                          // InputBuffer
                 0,                             // InputBufferLength,
                 NULL,                          // OutputBuffer,
                 0                              // OutputBufferLength
                 );

    if (!NT_SUCCESS(status))
    {
        wprintf(
            L"NtDeviceIoControlFile() failed, error %08lx\n",
            status
            );
        return 1;
    }

    wprintf(
        L"Performance counters cleared\n"
        );

    return 0;

}   // DoClear


INT
WINAPI
DoFlush(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{

    NTSTATUS status;
    IO_STATUS_BLOCK ioStatusBlock;

    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf(
            L"use: tul flush\n"
            );
        return 1;
    }

    //
    // Issue the request.
    //

    status = NtDeviceIoControlFile(
                 UlHandle,                     // FileHandle
                 NULL,                          // Event
                 NULL,                          // ApcRoutine
                 NULL,                          // ApcContext
                 &ioStatusBlock,                // IoStatusBlock
                 IOCTL_UL_FLUSH_FILE_CACHE,    // IoControlCode
                 NULL,                          // InputBuffer
                 0,                             // InputBufferLength,
                 NULL,                          // OutputBuffer,
                 0                              // OutputBufferLength
                 );

    if (!NT_SUCCESS(status))
    {
        wprintf(
            L"NtDeviceIoControlFile() failed, error %08lx\n",
            status
            );
        return 1;
    }

    wprintf(
        L"File cache flushed\n"
        );

    return 0;

}   // DoFlush
#endif  // LATER


INT
WINAPI
DoConfig(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{
    PCONFIG_ENTRY pEntry;
    LONG longValue;
    LONGLONG longlongValue;
    HKEY key;
    INT result;
    LONG err;
    CONST BYTE * pNewValue;
    DWORD newValueLength;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    key = NULL;

    //
    // Try to open the registry.
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Http\\Parameters",
                0,
                KEY_ALL_ACCESS,
                &key
                );

    if (err != NO_ERROR)
    {
        wprintf(
            L"tul: cannot open registry, error %ld\n",
            err
            );
        result = 1;
        goto cleanup;
    }

    //
    // Validate the arguments.
    //

    if (argc == 1)
    {
        DumpConfiguration( key );
        result = 0;
        goto cleanup;
    }
    else
    if (argc != 3)
    {
        wprintf(
            L"use: tul config [property= value]\n"
            );
        result = 1;
        goto cleanup;
    }

    //
    // Find the entry.
    //

    pEntry = FindConfigByName( argv[1] );

    if (pEntry == NULL)
    {
        wprintf(
            L"tul: invalid property %s\n",
            argv[1]
            );
        result = 1;
        goto cleanup;
    }

    //
    // Interpret it.
    //

    if (pEntry->Type == REG_DWORD)
    {
        if (argv[2][0] == L'-')
            longValue = wcstol( argv[2], NULL, 0 );
        else
            longValue = (LONG) wcstoul( argv[2], NULL, 0 );
        pNewValue = (CONST BYTE *)&longValue;
        newValueLength = sizeof(longValue);
    }
    else if (pEntry->Type == REG_QWORD)
    {
// Hack: because link fails for Win32 and we don't need top 32 bits on Win32
#ifndef _WIN64
# define _wcstoi64(nptr, endptr, base)   \
        (__int64)          wcstol((nptr), (endptr), (base))
# define _wcstoui64(nptr, endptr, base)  \
        (unsigned __int64) wcstoul((nptr), (endptr), (base))
#endif

        if (argv[2][0] == L'-')
            longlongValue = _wcstoi64( argv[2], NULL, 0 );
        else
            longlongValue = (LONGLONG) _wcstoui64( argv[2], NULL, 0 );
        pNewValue = (CONST BYTE *)&longlongValue;
        newValueLength = sizeof(longlongValue);
    }
    else
    {
        pNewValue = (CONST BYTE *)argv[2];
        newValueLength = (DWORD)( wcslen( argv[2] ) + 1 ) * sizeof(argv[0][0]);
    }

    if (_wcsicmp( argv[2], L"/delete" ) == 0)
    {
        err = RegDeleteValue(
                    key,
                    pEntry->pConfigName
                    );
    }
    else
    {
        err = RegSetValueEx(
                    key,
                    pEntry->pConfigName,
                    0,
                    pEntry->Type,
                    pNewValue,
                    newValueLength
                    );
    }

    if (err != NO_ERROR)
    {
        wprintf(
            L"tul: cannot write to registry, error %ld\n",
            err
            );
        result = 1;
        goto cleanup;
    }

    //
    // Success!
    //

    DumpConfiguration( key );
    result = 0;

cleanup:

    if (key != NULL)
    {
        RegCloseKey( key );
    }

    return result;

}   // DoConfig


INT
WINAPI
DoFlags(
    IN HANDLE UlHandle,
    IN INT argc,
    IN PWSTR argv[]
    )
{
    HKEY key;
    INT result;
    LONG err;
    LONG i;
    ULONG flags;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    key = NULL;

    //
    // Try to open the registry.
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"System\\CurrentControlSet\\Services\\Http\\Parameters",
                0,
                KEY_ALL_ACCESS,
                &key
                );

    if (err != NO_ERROR)
    {
        wprintf(
            L"tul: cannot open registry, error %ld\n",
            err
            );
        result = 1;
        goto cleanup;
    }

    //
    // Validate the arguments.
    //

    if (argc == 1)
    {
        DumpFlags( key );
        result = 0;
        goto cleanup;
    }

    //
    // read each flag on the command line and set it
    //
    flags = 0;
    for (i = 1; i < argc; i++) {
        flags |= FindFlagByName(argv[i]);
    }

    err = RegSetValueEx(
                key,
                REGISTRY_DEBUG_FLAGS,
                0,
                REG_DWORD,
                (LPBYTE)&flags,
                sizeof(flags)
                );


    //
    // Success!
    //

    DumpFlags( key );
    result = 0;

cleanup:

    if (key != NULL)
    {
        RegCloseKey( key );
    }

    return result;

}   // DoFlags
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\iisrearc\ul\util\dtsetup.c ===
/*++

Copyright (c) 1999-1999 Microsoft Corporation

Module Name:

    dtsetup.c

Abstract:

    Simple Duct-Tape setup.

Author:

    Keith Moore (keithmo)        02-Sep-1999

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop


//
// Configuration data.
//

#define UL_SERVICE_NAME     L"UL"
#define UL_DISPLAY_NAME     L"UL"
#define UL_DRIVER_NAME      L"UL.SYS"
#define UL_DEPENDENCIES     NULL

#define WAS_SERVICE_NAME    L"IISW3ADM"
#define WAS_DISPLAY_NAME    L"IIS Web Admin Service"
#define WAS_DLL_NAME        L"iisw3adm.dll"
#define WAS_DEPENDENCIES    L"UL"
#define WAS_COMMAND_LINE    L"%SystemRoot%\\System32\\svchost.exe -k iissvcs"
#define WAS_PARAM_KEY       L"System\\CurrentControlSet\\Services\\iisw3adm\\Parameters"
#define WAS_EVENT_KEY       L"System\\CurrentControlSet\\Services\\EventLog\\System\\WAS"
#define WAS_SVCHOST_KEY     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"

#define SERVICE_DLL_VALUE   L"ServiceDll"
#define EVENT_MESSAGE_VALUE L"EventMessageFile"
#define SVCHOST_VALUE       L"iissvcs"

#define CATALOG_DLL_NAME    L"catalog.dll"
#define CATALOG_KEY         L"Software\\Microsoft\\Catalog42"
#define CATALOG_URT_VALUE   L"URT"


//
// Our command table.
//

typedef
VOID
(* PFN_COMMAND)(
    IN INT argc,
    IN PWSTR argv[]
    );

typedef struct _COMMAND_ENTRY
{
    PWSTR pCommandName;
    PWSTR pUsageHelp;
    PFN_COMMAND pCommandHandler;

} COMMAND_ENTRY, *PCOMMAND_ENTRY;


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );

PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    );

VOID
DoInstall(
    IN INT argc,
    IN PWSTR argv[]
    );

VOID
DoRemove(
    IN INT argc,
    IN PWSTR argv[]
    );

DWORD
InstallUL(
    IN PWSTR pBaseDirectory
    );

DWORD
InstallWAS(
    IN PWSTR pBaseDirectory
    );

DWORD
InstallCatalog(
    IN PWSTR pBaseDirectory
    );

VOID
RemoveCatalog(
    VOID
    );

VOID
RemoveWAS(
    VOID
    );

VOID
RemoveUL(
    VOID
    );

DWORD
InstallService(
    IN PWSTR pServiceName,
    IN PWSTR pDisplayName OPTIONAL,
    IN PWSTR pBinPath,
    IN PWSTR pDependencies OPTIONAL,
    IN DWORD ServiceType,
    IN DWORD StartType,
    IN DWORD ErrorControl
    );

DWORD
RemoveService(
    IN PWSTR pServiceName
    );

DWORD
WriteRegValue(
    IN PWSTR pKeyName,
    IN PWSTR pValueName,
    IN PWSTR pValue
    );

DWORD
DeleteRegKey(
    IN PWSTR pKeyName
    );


//
// Private globals.
//

COMMAND_ENTRY CommandTable[] =
    {
        {
            L"install",
            L"install UL and WAS",
            &DoInstall
        },

        {
            L"remove",
            L"remove UL and WAS",
            &DoRemove
        }

    };

#define NUM_COMMAND_ENTRIES (sizeof(CommandTable) / sizeof(CommandTable[0]))


//
// Public functions.
//


INT
__cdecl
wmain(
    INT argc,
    PWSTR argv[]
    )
{
    PCOMMAND_ENTRY pEntry;

    //
    // Find the command handler.
    //

    if (argc == 1)
    {
        pEntry = NULL;
    }
    else
    {
        pEntry = FindCommandByName( argv[1] );
    }

    if (pEntry == NULL)
    {
        Usage();
        return 1;
    }

    //
    // Call the handler.
    //

    argc--;
    argv++;

    (pEntry->pCommandHandler)( argc, argv );

    return 0;

}   // wmain


//
// Private functions.
//

PCOMMAND_ENTRY
FindCommandByName(
    IN PWSTR pCommand
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
     {
        if (_wcsicmp( pCommand, pEntry->pCommandName ) == 0)
        {
            return pEntry;
        }
    }

    return NULL;

}   // FindCommandByName


VOID
Usage(
    VOID
    )
{
    PCOMMAND_ENTRY pEntry;
    INT i;
    INT maxLength;
    INT len;

    //
    // Scan the command table, searching for the longest command name.
    // (This makes the output much prettier...)
    //

    maxLength = 0;

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        len = wcslen( pEntry->pCommandName );

        if (len > maxLength)
        {
            maxLength = len;
        }
    }

    //
    // Now display the usage information.
    //

    wprintf(
        L"use: dtsetup action [options]\n"
        L"\n"
        L"valid actions are:\n"
        L"\n"
        );

    for (i = NUM_COMMAND_ENTRIES, pEntry = &CommandTable[0] ;
         i > 0 ;
         i--, pEntry++)
    {
        wprintf(
            L"    %-*s - %s\n",
            maxLength,
            pEntry->pCommandName,
            pEntry->pUsageHelp
            );
    }

}   // Usage


VOID
DoInstall(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    PWSTR pBaseDirectory;
    DWORD err;

    //
    // Validate the arguments.
    //

    if (argc != 2)
    {
        wprintf( L"use: dtsetup install directory\n" );
        return;
    }

    //
    // Install 'em.
    //

    wprintf( L"installing UL..." );
    err = InstallUL( argv[1] );

    if (err != NO_ERROR)
    {
        wprintf( L"error %lu\n", err );
        return;
    }

    wprintf( L"done\n" );

    wprintf( L"installing WAS..." );
    err = InstallWAS( argv[1] );

    if (err != NO_ERROR)
    {
        wprintf( L"error %lu\n", err );
        RemoveUL();
        return;
    }

    wprintf( L"done\n" );

    wprintf( L"installing Catalog..." );
    err = InstallCatalog( argv[1] );

    if (err != NO_ERROR)
    {
        wprintf( L"error %lu\n", err );
        RemoveWAS();
        RemoveUL();
        return;
    }

    wprintf( L"done\n" );

    //
    // Success!
    //

}   // DoInstall


VOID
DoRemove(
    IN INT argc,
    IN PWSTR argv[]
    )
{
    //
    // Validate the arguments.
    //

    if (argc != 1)
    {
        wprintf( L"use: dtsetup remove\n" );
        return;
    }

    //
    // Remove 'em.
    //

    wprintf( L"removing Catalog..." );
    RemoveCatalog();
    wprintf( L"done\n" );

    wprintf( L"removing WAS..." );
    RemoveWAS();
    wprintf( L"done\n" );

    wprintf( L"removing UL..." );
    RemoveUL();
    wprintf( L"done\n" );

}   // DoRemove


DWORD
InstallUL(
    IN PWSTR pBaseDirectory
    )
{
    DWORD err;
    WCHAR binPath[MAX_PATH];

    //
    // Build the path to the driver.
    //

    wcscpy( binPath, pBaseDirectory );

    if (binPath[wcslen(binPath) - 1] != L'\\')
    {
        wcscat( binPath, L"\\" );
    }

    wcscat( binPath, UL_DRIVER_NAME );

    //
    // Install it.
    //

    err = InstallService(
                UL_SERVICE_NAME,                // pServiceName
                UL_DISPLAY_NAME,                // pDisplayName
                binPath,                        // pBinPath
                UL_DEPENDENCIES,                // pDependencies
                SERVICE_KERNEL_DRIVER,          // ServiceType
                SERVICE_DEMAND_START,           // StartType
                SERVICE_ERROR_NORMAL            // ErrorControl
                );

    return err;

}   // InstallUL


DWORD
InstallWAS(
    IN PWSTR pBaseDirectory
    )
{
    DWORD err;
    WCHAR binPath[MAX_PATH];

    //
    // Build the path to the service.
    //

    wcscpy( binPath, pBaseDirectory );

    if (binPath[wcslen(binPath) - 1] != L'\\')
    {
        wcscat( binPath, L"\\" );
    }

    wcscat( binPath, WAS_DLL_NAME );

    //
    // Install it.
    //

    err = InstallService(
                WAS_SERVICE_NAME,               // pServiceName
                WAS_DISPLAY_NAME,               // pDisplayName
                WAS_COMMAND_LINE,               // pBinPath
                WAS_DEPENDENCIES,               // pDependencies
                SERVICE_WIN32_SHARE_PROCESS |   // ServiceType
                    SERVICE_INTERACTIVE_PROCESS,
                SERVICE_DEMAND_START,           // StartType
                SERVICE_ERROR_NORMAL            // ErrorControl
                );

    if (err == NO_ERROR)
    {
        err = WriteRegValue(
                    WAS_PARAM_KEY,              // pKeyName
                    SERVICE_DLL_VALUE,          // pValueName
                    binPath                     // pValue
                    );
    }

    if (err == NO_ERROR)
    {
        err = WriteRegValue(
                    WAS_EVENT_KEY,              // pKeyName
                    EVENT_MESSAGE_VALUE,        // pValueName
                    binPath                     // pValue
                    );
    }

    if (err == NO_ERROR)
    {
        err = WriteRegValue(
                    WAS_SVCHOST_KEY,            // pKeyName
                    SVCHOST_VALUE,              // pValueName
                    WAS_SERVICE_NAME            // pValue
                    );
    }

    return err;

}   // InstallWAS


DWORD
InstallCatalog(
    IN PWSTR pBaseDirectory
    )
{
    DWORD err;
    WCHAR binPath[MAX_PATH];

    //
    // Build the path to the service.
    //

    wcscpy( binPath, pBaseDirectory );

    if (binPath[wcslen(binPath) - 1] != L'\\')
    {
        wcscat( binPath, L"\\" );
    }

    wcscat( binPath, CATALOG_DLL_NAME );

    //
    // Install it.
    //

    err = WriteRegValue(
                CATALOG_KEY,                    // pKeyName
                CATALOG_URT_VALUE,              // pValueName
                binPath                         // pValue
                );

    return err;

}   // InstallCatalog


VOID
RemoveCatalog(
    VOID
    )
{
    (VOID)DeleteRegKey( CATALOG_KEY );

}   // RemoveCatalog


VOID
RemoveWAS(
    VOID
    )
{
    (VOID)RemoveService( WAS_SERVICE_NAME );
    (VOID)DeleteRegKey( WAS_EVENT_KEY );

}   // RemoveWAS


VOID
RemoveUL(
    VOID
    )
{
    (VOID)RemoveService( UL_SERVICE_NAME );

}   // RemoveUL


DWORD
InstallService(
    IN PWSTR pServiceName,
    IN PWSTR pDisplayName OPTIONAL,
    IN PWSTR pBinPath,
    IN PWSTR pDependencies OPTIONAL,
    IN DWORD ServiceType,
    IN DWORD StartType,
    IN DWORD ErrorControl
    )
{
    SC_HANDLE scHandle;
    SC_HANDLE svcHandle;
    DWORD err;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    scHandle = NULL;
    svcHandle = NULL;

    //
    // If no display name specified, just use the service name.
    //

    if (pDisplayName == NULL)
    {
        pDisplayName = pServiceName;
    }

    //
    // Open the service controller.
    //

    scHandle = OpenSCManagerW(
                   NULL,                        // lpMachineName
                   NULL,                        // lpDatabaseName
                   SC_MANAGER_ALL_ACCESS        // dwDesiredAccess
                   );

    if (scHandle == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Create the service.
    //

    svcHandle = CreateServiceW(
                    scHandle,                   // hSCManager
                    pServiceName,               // lpServiceName
                    pDisplayName,               // lpDisplayName
                    SERVICE_ALL_ACCESS,         // dwDesiredAccess
                    ServiceType,                // dwServiceType
                    StartType,                  // dwStartType
                    ErrorControl,               // dwErrorControl
                    pBinPath,                   // lpBinaryPathName
                    NULL,                       // lpLoadOrderGroup
                    NULL,                       // lpdwTagId
                    pDependencies,              // lpDependencies
                    NULL,                       // lpServiceStartName
                    NULL                        // lpPassword
                    );

    if (svcHandle == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Success!
    //

    err = 0;

cleanup:

    if (svcHandle != NULL)
    {
        CloseServiceHandle( svcHandle );
    }

    if (scHandle != NULL)
    {
        CloseServiceHandle( scHandle );
    }

    return err;

}   // InstallService


DWORD
RemoveService(
    IN PWSTR pServiceName
    )
{
    SC_HANDLE scHandle;
    SC_HANDLE svcHandle;
    DWORD err;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    scHandle = NULL;
    svcHandle = NULL;

    //
    // Open the service controller.
    //

    scHandle = OpenSCManagerW(
                   NULL,                        // lpMachineName
                   NULL,                        // lpDatabaseName
                   SC_MANAGER_ALL_ACCESS        // dwDesiredAccess
                   );

    if (scHandle == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Open the service.
    //

    svcHandle = OpenServiceW(
                    scHandle,                   // hSCManager
                    pServiceName,               // lpServiceName
                    SERVICE_ALL_ACCESS          // dwDesiredAccess
                    );

    if (svcHandle == NULL)
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Delete it.
    //

    if (!DeleteService( svcHandle ))
    {
        err = GetLastError();
        goto cleanup;
    }

    //
    // Success!
    //

    err = 0;

cleanup:

    if (svcHandle != NULL)
    {
        CloseServiceHandle( svcHandle );
    }

    if (scHandle != NULL)
    {
        CloseServiceHandle( scHandle );
    }

    return err;

}   // RemoveService


DWORD
WriteRegValue(
    IN PWSTR pKeyName,
    IN PWSTR pValueName,
    IN PWSTR pValue
    )
{
    DWORD err;
    HKEY key;
    DWORD disposition;
    DWORD length;

    err = RegCreateKeyExW(
                HKEY_LOCAL_MACHINE,             // hKey
                pKeyName,                       // lpSubKey
                0,                              // Reserved
                NULL,                  