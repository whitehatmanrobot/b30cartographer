-------------------------------------
Purpose: Disable all the controls.  Remove any selections.
Returns: --
Cond:    --
*/
void PRIVATE Info_DisableAll(
    PINFO this)
    {
    ASSERT(!Info_StandAlone(this));
    
    // Remove selections
    //
    ListBox_ResetContent(GetDlgItem(this->hwnd, IDC_LBINTYPES));
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_RBINALL), 0);
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_RBINSELECTED), 0);
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_CHININCLUDE), 0);
    
    // Disable the controls
    //
    Button_Enable(GetDlgItem(this->hwnd, IDC_RBINALL), FALSE);
    Button_Enable(GetDlgItem(this->hwnd, IDC_RBINSELECTED), FALSE);
    
    ListBox_Enable(GetDlgItem(this->hwnd, IDC_LBINTYPES), FALSE);
    
    Button_Enable(GetDlgItem(this->hwnd, IDC_CHININCLUDE), FALSE);
    }


/*----------------------------------------------------------
Purpose: Initialize the labels for our formatted radio buttons
Returns: --
Cond:    --
*/
void PRIVATE Info_InitLabels(
    PINFO this)
    {
    HWND hwnd = this->hwnd;
    HWND hwndST = GetDlgItem(hwnd, IDC_CHININCLUDE);
    TCHAR sz[MAXMSGLEN];
    TCHAR szFmt[MAXBUFLEN];
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
    LPTSTR pszFile;

    pszFile = PathFindFileName(pszPath);

    // Set static label
    //
    GetWindowText(hwndST, szFmt, ARRAYSIZE(szFmt));
    wsprintf(sz, szFmt, pszFile);
    SetWindowText(hwndST, sz);

    if (Info_StandAlone(this))
        {
        // Set title ("Create Twin of %s")
        //
        GetWindowText(hwnd, szFmt, ARRAYSIZE(szFmt));
        wsprintf(sz, szFmt, pszFile);
        SetWindowText(hwnd, sz);
        }
    }


/*----------------------------------------------------------
Purpose: Queries the registry for all the legal extensions that
         are registered.  These extensions are returned as a 
         space-separated list in buffer.

Returns: --
Cond:    Caller must GFree *ppszBuffer
*/
void PRIVATE GetExtensionList(
    LPTSTR * ppszBuffer)
    {
    HKEY hkRoot;

    *ppszBuffer = NULL;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hkRoot))
        {
        DWORD dwIndex;
        TCHAR szExt[MAX_PATH];
        
        // Enumerate this key
        for (dwIndex = 0;
                ERROR_SUCCESS == RegEnumKey(hkRoot, dwIndex, szExt, ARRAYSIZE(szExt));
                dwIndex++)
            {
            // Did we get a node that is an extension AND
            // is it a legal MS-DOS extension?
            if (TEXT('.') == *szExt &&
                4 >= lstrlen(szExt))
                {
                // Yes; add this extension to our list
                lstrcat(szExt, TEXT(" "));
                if (FALSE == GCatString(ppszBuffer, szExt))
                    {
                    // Uh oh, something bad happened
                    break;
                    }
                }
            }
        RegCloseKey(hkRoot);
        }
    }


/*----------------------------------------------------------
Purpose: Fill the file types listbox
Returns: --
Cond:    --
*/
void PRIVATE Info_FillTypesList(
    PINFO this)
    {
    HWND hwndCtl = GetDlgItem(this->hwnd, IDC_LBINTYPES);
    LPTSTR pszExtList;

    GetExtensionList(&pszExtList);
    if (pszExtList)
        {
        int nTabWidth;
        TCHAR szExt[MAXBUFLEN];
        LPTSTR psz;
        LPTSTR pszT;
        UINT uLen;
        SHFILEINFO sfi;

        nTabWidth = 30;
        ListBox_SetTabStops(hwndCtl, 1, &nTabWidth);

        for (psz = pszExtList; *psz; psz = CharNext(psz))
            {
            // Skip any leading white-space 
            for (; TEXT(' ') == *psz; psz = CharNext(psz))
                ;

            if (0 == *psz)
                {
                break;  // End of string
                }
            
            // Skip to next white-space (or null)
            for (pszT = psz; TEXT(' ') < *pszT; pszT = CharNext(pszT))
                {
                // (This will also stop at null)
                }

            // (GetExtensionList should only get max 3 char extensions)
            uLen = pszT - psz;
            ASSERT(ARRAYSIZE(szExt) > uLen);

            lstrcpyn(szExt, psz, uLen+1);
            CharUpper(szExt);
            SHGetFileInfo(szExt, 0, &sfi, sizeof(sfi), SHGFI_TYPENAME | SHGFI_USEFILEATTRIBUTES);

            // Although this forces the format for international versions,
            // it makes extraction much much easier.
            lstrcat(szExt, TEXT("\t("));
            lstrcat(szExt, sfi.szTypeName);
            lstrcat(szExt, TEXT(")"));
            ListBox_AddString(hwndCtl, szExt);

            psz = pszT;     // To next extension
            }
        
        GFree(pszExtList);
        }
    }

/*----------------------------------------------------------
Purpose: Set the selection of the dialog controls
Returns: --
Cond:    --
*/
void PRIVATE Info_SetSelections(
    PINFO this)
    {
    HWND hwndLB = GetDlgItem(this->hwnd, IDC_LBINTYPES);
    int idBtn;
    int cItems = ListBox_GetCount(hwndLB);

    ListBox_SetSel(hwndLB, FALSE, -1);  // deselect everything

    // Is this the 'Add Folder' dialog?
    if (Info_StandAlone(this))
        {
        // Yes; default to *.* settings
        SetFlag(this->uState, IS_ALLTYPES);
        SetFlag(this->uState, IS_INCLUDESUBS);
        }
    else
        {
        // No; query what the selections are
        TCHAR szExt[MAXBUFLEN];
        PFOLDERTWINLIST pftl;
        PCFOLDERTWIN pcft;
        int cItems;
        int i;
        BOOL bStarDotStar;
        LPTSTR psz;

        if (S_OK == PageData_Query(this->ppagedata, this->hwnd, NULL, &pftl))
            {
            // Determine the selections in the listbox
            szExt[0] = TEXT('*');
            
            cItems = ListBox_GetCount(hwndLB);
            for (i = 0; i < cItems; i++)
                {
                // Extract the extension (it will be the first part of the
                // string)
                ListBox_GetText(hwndLB, i, &szExt[1]);
                for (psz = szExt; *psz && TEXT('\t') != *psz; psz = CharNext(psz))
                    ;
                ASSERT(TEXT('\t') == *psz);
                *psz = 0;           // null terminate after the extension

                // Is this extension in the folder twin list?
                if (FindExtension(pftl, szExt))
                    {
                    // Yes; select the entry
                    ListBox_SetSel(hwndLB, TRUE, i);
                    }
                }

            ListBox_SetTopIndex(hwndLB, 0);
            this->cselPrev = ListBox_GetSelCount(hwndLB);
            
            // Determine the Include Subdirectories checkbox setting
            //
            bStarDotStar = FALSE;
            ClearFlag(this->uState, IS_INCLUDESUBS);
            for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
                {
                if (IsFlagSet(pcft->dwFlags, FT_FL_SUBTREE))
                    SetFlag(this->uState, IS_INCLUDESUBS);
                
                if (IsSzEqual(pcft->pcszName, c_szAllFiles))
                    bStarDotStar = TRUE;
                }
            
            // Set the default radio button choice, and disable listbox 
            // if necessary.  The default radio choice will be IDC_RBINALL, 
            // unless there are selections in the listbox AND there is no 
            // *.* occurrence in the folder twin list.
            //
            if (0 == this->cselPrev || bStarDotStar)
                SetFlag(this->uState, IS_ALLTYPES);
            else
                ClearFlag(this->uState, IS_ALLTYPES);
            }
        else
            {
            // An error occurred or this is an orphan.  Bail early.
            return;
            }
        }

    if (IsFlagSet(this->uState, IS_INCLUDESUBS))
        SetFlag(this->uState, IS_LAST_INCLUDESUBS);
    else
        ClearFlag(this->uState, IS_LAST_INCLUDESUBS);
        
    // Set the control settings 
    Button_SetCheck(GetDlgItem(this->hwnd, IDC_CHININCLUDE), IsFlagSet(this->uState, IS_INCLUDESUBS));

    ListBox_Enable(hwndLB, IsFlagClear(this->uState, IS_ALLTYPES));
    idBtn =  IsFlagSet(this->uState, IS_ALLTYPES) ? IDC_RBINALL : IDC_RBINSELECTED;
    CheckRadioButton(this->hwnd, IDC_RBINALL, IDC_RBINSELECTED, idBtn);
    
    // If listbox is empty, disable Selected Types radio button
    if (0 == cItems)
        {
        Button_Enable(GetDlgItem(this->hwnd, IDC_RBINSELECTED), FALSE);
        }
    }


/*----------------------------------------------------------
Purpose: Get the selected extensions in the listbox
         and place them as a list in *ppszExtList. 

         .* is placed in the buffer if the Select All radio button
         is chosen instead.

Returns: TRUE on success

Cond:    The caller must GFree *ppszExtList
*/
BOOL PRIVATE Info_GetSelections(
    PINFO this,
    LPTSTR * ppszExtList)
    {
    BOOL bRet = FALSE;

    *ppszExtList = NULL;

    // Did user choose the All Types radio button?
    if (IsFlagSet(this->uState, IS_ALLTYPES))
        {
        // Yes; store the .* extension
        bRet = GSetString(ppszExtList, c_szAllFilesExt);
        }
    else
        {
        // No; user selected a bunch of wildcards to filter
        LPINT pisel;
        TCHAR szExt[MAXBUFLEN];
        int csel;
        int isel;
        HWND hwndCtl = GetDlgItem(this->hwnd, IDC_LBINTYPES);
        
        // Allocate memory for the selection buffer
        csel = ListBox_GetSelCount(hwndCtl);
        pisel = GAllocArray(int, csel);
        if (pisel)
            {
            // Get the selected extensions from the listbox
            LPTSTR psz;

            if (0 < csel)
                {
                ListBox_GetSelItems(hwndCtl, csel, pisel);
                for (isel = 0; isel < csel; isel++)
                    {
                    // Extract the extension (it will be the first part of the string)
                    ListBox_GetText(hwndCtl, pisel[isel], szExt);
                    for (psz = szExt; *psz && TEXT('\t') != *psz; psz = CharNext(psz))
                        ;
                    ASSERT(TEXT('\t') == *psz);
                    *psz = 0;

                    if (FALSE == GCatString(ppszExtList, szExt))
                        {
                        break;
                        }
                    }

                if (isel == csel)
                    {
                    bRet = TRUE;    // Success
                    }
                else
                    {
                    GFree(*ppszExtList);
                    }
                }
            GFree(pisel);
            }
        }
        
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Create a sorted DPA version of the folder twin list

Returns: hdpa
         NULL on OOM
Cond:    --
*/
HDPA PRIVATE CreateSortedFolderDPA(
    PFOLDERTWINLIST pftl)
    {
    HDPA hdpa;

    ASSERT(pftl);

    hdpa = DPA_Create(8);
    if (hdpa)
        {
        PCFOLDERTWIN pcft;

        for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
            {
            // Use the dwUser field as a deletion flag
            ((PFOLDERTWIN)pcft)->dwUser = FALSE;
            
            if (DPA_ERR == DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)pcft))
                {
                DPA_Destroy(hdpa);
                return NULL;
                }
            }
        DPA_Sort(hdpa, NCompareFolders, CMP_FOLDERTWINS);
        }

    return hdpa;
    }
    

/*----------------------------------------------------------
Purpose: Process callback after adding a folder twin

Returns: standard result
Cond:    --
*/
HRESULT CALLBACK ChangeTwinProc(
    PNEWFOLDERTWIN pnft,
    TWINRESULT tr,
    PCHANGEDATA pcd)
    {
    HRESULT hres = NOERROR;

    // Is this a duplicate twin?
    if (TR_DUPLICATE_TWIN == tr)
        {
        // Yes; there's a wierd case to deal with.  It's possible that the 
        // only thing the user did was check/uncheck the Include Subdirs 
        // checkbox.  If this is true, then we delete the old twin and add 
        // a new twin (with same filespec as before) with the flags set 
        // differently.
        PCFOLDERTWIN pcft;
        HDPA hdpaFolders = pcd->hdpaFolders;
        int cdpa = DPA_GetPtrCount(hdpaFolders);
        int idpa;
        BOOL bOldInclude;

        // Find the correct pcfolder.  We will either tag it or
        // we will delete it right now and re-add the new twin.
        for (idpa = pcd->idpaStart; idpa < cdpa; idpa++)
            {
            pcft = DPA_FastGetPtr(hdpaFolders, idpa);
        
            if (IsSzEqual(pcft->pcszName, pnft->pcszName))
                break;      // found it!
            }
        ASSERT(idpa < cdpa);
        
        // Tag the twin to save from impending doom...
        ((PFOLDERTWIN)(DWORD)pcft)->dwUser = TRUE;
        
        // Has the Include Subfolders checkbox setting changed?
        bOldInclude = IsFlagSet(pcft->dwFlags, FT_FL_SUBTREE);
        if (bOldInclude ^ IsFlagSet(pcd->uState, IS_INCLUDESUBS))
            {
            // Yes; delete the twin anyway and add the new one.
            HFOLDERTWIN hft;

            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Deleting old folder twin")); )
            Sync_DeleteTwin(pcft->hftOther);

            // Add the new folder twin to the database
            tr = Sync_AddFolder(pcd->hbrf, pnft, &hft);
            if (TR_SUCCESS != tr)
                {
                // Adding the new twin failed
                DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
                hres = HRESULT_FROM_TR(tr);
                }
            else 
                {
                // Set the new twin handle in the pcd->hdpaTwins list
                DPA_SetPtr(pcd->hdpaTwins, pcd->idpaTwin, (LPVOID)hft);

                DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding new folder twin")); )
                DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
                }
            }
        else
            {
            // No; this isn't new, so don't add to list
            DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
            }
        }
    else if (tr != TR_SUCCESS)
        {
        // Sync_AddFolder failed
        DPA_DeletePtr(pcd->hdpaTwins, pcd->idpaTwin);
        hres = HRESULT_FROM_TR(tr);
        }
    else
        {
        // Sync_AddFolder succeeded
        DPA_SetPtr(pcd->hdpaTwins, pcd->idpaTwin, (LPVOID)pcd->hft);

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding new folder twin")); )
        DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Add folder twins based on the list of extensions

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE Info_AddTwins(
    PINFO this,
    PNEWFOLDERTWIN pnft,
    PADDTWINSDATA patd,         // May be NULL
    LPTSTR pszExtList)           // This function writes in this buffer
    {
    HRESULT hres = NOERROR;
    CHANGEDATA cd;
    HDPA hdpa;
    int  idpa;
    TCHAR szWildcard[MAX_EXT_LEN];
    LPTSTR psz;
    LPTSTR pszT;
    TCHAR ch;

    hdpa = this->pinfodata->hdpaTwins;

    cd.hbrf = PageData_GetHbrf(this->ppagedata);
    cd.hdpaTwins = hdpa;
    if (patd)
        {
        cd.hdpaFolders = patd->hdpaSortedFolders;
        cd.idpaStart = patd->idpaStart;
        }
    cd.uState = this->uState;

    pnft->pcszName = szWildcard;
    szWildcard[0] = TEXT('*');

    for (psz = pszExtList; *psz; )
        {
        TWINRESULT tr;
        HFOLDERTWIN hft = NULL;

        // Find the beginning of the next extension for the next iteration
        for (pszT = CharNext(psz); *pszT && TEXT('.') != *pszT; pszT = CharNext(pszT))
            ;
        ch = *pszT;
        *pszT = 0;      // Temporary assignment

        // Copy the extension into the name string
        lstrcpy(&szWildcard[1], psz);

        *pszT = ch;
        psz = pszT;
        
        // First make sure we can add another handle to hdpaTwins
        if (DPA_ERR == (idpa = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)hft)))
            {
            hres = ResultFromScode(E_OUTOFMEMORY);
            break;      // Failed
            }
    
        // Add the folder twin to the database
        tr = Sync_AddFolder(cd.hbrf, pnft, &hft);

        if (patd)
            {
            cd.idpaTwin = idpa;
            cd.hft = hft;

            ASSERT(patd->pfnCallback);
            if ( FAILED((hres = patd->pfnCallback(pnft, tr, &cd))) )
                {
                break;
                }
            }
        else if (TR_SUCCESS != tr)
            {
            // Sync_AddFolder failed
            DPA_DeletePtr(hdpa, idpa);
            hres = HRESULT_FROM_TR(tr);
            break;
            }
        else
            {
            // Sync_AddFolder succeeded
            DPA_SetPtr(hdpa, idpa, (LPVOID)hft);

            DEBUG_CODE( Sync_Dump(pnft, NEWFOLDERTWIN); )
            }
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Add the folder twin to the database

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE Info_CommitStandAlone(
    PINFO this)
    {
    HRESULT hres;
    NEWFOLDERTWIN nft;
    LPTSTR pszExtList;

    RETRY_BEGIN(FALSE)
        {
        ZeroInit(&nft, NEWFOLDERTWIN);
        nft.ulSize = sizeof(nft);
        nft.pcszFolder1 = Atom_GetName(this->ppagedata->atomPath);
        nft.pcszFolder2 = Atom_GetName(this->pinfodata->atomTo);
        // nft.pcszName is set in Info_AddTwins()
        nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
        nft.dwFlags = IsFlagSet(this->uState, IS_INCLUDESUBS) ? NFT_FL_SUBTREE : 0;

        // Create an extension list based on the dialog settings
        if (!Info_GetSelections(this, &pszExtList))
            {
            // Failed
            hres = ResultFromScode(E_OUTOFMEMORY); 
            }
        else
            {
            // Add the twins
            hres = Info_AddTwins(this, &nft, NULL, pszExtList);
            GFree(pszExtList);
            }

        if (SUCCEEDED(hres))
            {
            // Since the engine does not create folders if the folder is empty,
            // we will create the folder now (whether it is empty or not).
            // If the folder already exists, CreateDirectory will fail.
            // Big deal.
            CreateDirectory(nft.pcszFolder2, NULL);
            PathNotifyShell(nft.pcszFolder2, NSE_MKDIR, FALSE);
            }
        else
            {
            DWORD dwError = GetLastError();
            int id;

            // Unavailable disk?
            if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                {
                // Yes
                hres = E_TR_UNAVAILABLE_VOLUME;
                }

            id = SEMsgBox(this->hwnd, IDS_CAP_INFO, hres, c_rgseInfo, ARRAYSIZE(c_rgseInfo));
            if (IDRETRY == id)
                {
                // Try the operation again
                RETRY_SET();
                }
            }
        }
    RETRY_END()

    return hres;
    }


/*----------------------------------------------------------
Purpose: Commit the user changes to the database.  We delete
         all old hFolderTwins, and add new ones.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE Info_CommitChange(
    PINFO this)
    {
    HRESULT hres;
    PFOLDERTWINLIST pftl;

    hres = PageData_Query(this->ppagedata, this->hwnd, NULL, &pftl);
    if (S_FALSE == hres)
        {
        // The folder has become an orphan right under our nose.
        // Don't do anything.
        Info_DisableAll(this);
        }
    else if (S_OK == hres)
        {
        LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
        ADDTWINSDATA atd;
        DECLAREHOURGLASS;

        SetHourglass();

        atd.pfnCallback = ChangeTwinProc;

        // Create a sorted DPA based on the folder twin list
        atd.hdpaSortedFolders = CreateSortedFolderDPA(pftl);
        if (atd.hdpaSortedFolders)
            {
            // Create an extension list based on the dialog settings
            LPTSTR pszExtList = NULL;

            if (Info_GetSelections(this, &pszExtList))
                {
                NEWFOLDERTWIN nft;
                PCFOLDERTWIN pcft;
                PCFOLDERTWIN pcftLast;
                int idpa;
                int cdpa;

                // Now add new folder twins.  Iterate thru atd.hdpaSortedFolders.  
                // For each unique folder twin in this list, we add a new twin, 
                // using the old lpcszFolder as the lpcszFolder2 field in our 
                // NEWFOLDERTWIN structure.
                //
                ZeroInit(&nft, NEWFOLDERTWIN);
                nft.ulSize = sizeof(NEWFOLDERTWIN);
                nft.pcszFolder1 = pszPath;
                // nft.pcszFolder2 is set in loop below
                // nft.pcszName is set in Info_AddTwins()
                nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
                nft.dwFlags = IsFlagSet(this->uState, IS_INCLUDESUBS) ? NFT_FL_SUBTREE : 0;
                
                // Iterate thru existing folder twins.  Act on each unique one.
                cdpa = DPA_GetPtrCount(atd.hdpaSortedFolders);
                pcftLast = NULL;
                for (idpa = 0; idpa < cdpa; idpa++)
                    {
                    pcft = DPA_FastGetPtr(atd.hdpaSortedFolders, idpa);
                    
                    // Unique?
                    if (pcftLast && pcft->pcszOtherFolder == pcftLast->pcszOtherFolder)
                        {
                        // No; skip to next one
                        continue;
                        }
                    
                    // This is a unique folder.  Add it using the extensions in 
                    // pszExtList.
                    atd.idpaStart = idpa;
                    nft.pcszFolder2 = pcft->pcszOtherFolder;

                    hres = Info_AddTwins(this, &nft, &atd, pszExtList);
                    if (FAILED(hres))
                        {
                        goto Cleanup;
                        }
                    pcftLast = pcft;
                    }
                
                // Delete any old twins
                for (pcft = pftl->pcftFirst; pcft; pcft = pcft->pcftNext)
                    {
                    // Is it okay to delete this twin?
                    if (pcft->hftOther && FALSE == pcft->dwUser)
                        {
                        // Yes
                        TRACE_MSG(TF_GENERAL, TEXT("Deleting folder twin with extension '%s'"), pcft->pcszName);
                        Sync_DeleteTwin(pcft->hftOther);
                        }
                    }

Cleanup:
                GFree(pszExtList);
                }
            DPA_Destroy(atd.hdpaSortedFolders);
            }
        
        ResetHourglass();

        // Notify the shell of the change
        PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);

        // Throw out the last saved settings and reset
        GFree(this->pszExtListPrev);
        Info_GetSelections(this, &this->pszExtListPrev);

        this->ppagedata->bRecalc = TRUE;

        if (FAILED(hres))
            {
#pragma data_seg(DATASEG_READONLY)  
            static SETbl const c_rgseInfoChange[] = {
                    { E_TR_OUT_OF_MEMORY, IDS_OOM_CHANGETYPES, MB_ERROR },
                    { E_OUTOFMEMORY, IDS_OOM_CHANGETYPES, MB_ERROR },
                    { E_TR_SUBTREE_CYCLE_FOUND, IDS_ERR_ADD_SUBTREECYCLE, MB_WARNING },
                    };
#pragma data_seg()

            SEMsgBox(this->hwnd, IDS_CAP_INFO, hres, c_rgseInfoChange, ARRAYSIZE(c_rgseInfoChange));
            }
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Info WM_INITDIALOG Handler
Returns: 
Cond:    --
*/
BOOL PRIVATE Info_OnInitDialog(
    PINFO this,
    HWND hwndFocus,
    LPARAM lParam)              // LPPROPSHEETINFO
    {
    this->ppagedata = (PPAGEDATA)((LPPROPSHEETPAGE)lParam)->lParam;
    this->pinfodata = (PINFODATA)this->ppagedata->lParam;

    // Set the text of the controls
    Info_InitLabels(this);
    
    // Fill listbox and set the control selections
    Info_FillTypesList(this);
    if (Info_StandAlone(this))
        {
        Info_SetSelections(this);
        Info_GetSelections(this, &this->pszExtListPrev);
        }

    this->bInit = TRUE;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: PSN_APPLY handler

Returns: FALSE if everything is OK
         TRUE to have the property sheet switch to this page to 
            correct something.
Cond:    --
*/
BOOL PRIVATE Info_OnApply(
    PINFO this)
    {
    BOOL bRet;
    LPTSTR pszExtList;

    ASSERT(!Info_StandAlone(this));

    Info_GetSelections(this, &pszExtList);

    // Deny the apply?
    if (IsFlagSet(this->uState, IS_DENYAPPLY))
        {
        // Yes; don't let the apply go thru
        MsgBox(this->hwnd, MAKEINTRESOURCE(IDS_MSG_SPECIFYTYPE), 
               MAKEINTRESOURCE(IDS_CAP_INFO),NULL,GUID_NULL, NULL, MB_ERROR);
        bRet = PSNRET_INVALID;
        }
    // Have any settings changed?
    else if (pszExtList && this->pszExtListPrev &&
        // (Assume extensions are always listed in same order)
        IsSzEqual(this->pszExtListPrev, pszExtList) &&
        IsFlagSet(this->uState, IS_INCLUDESUBS) == IsFlagSet(this->uState, IS_LAST_INCLUDESUBS))
        {
        // No
        bRet = PSNRET_NOERROR;
        }
    else
        {
        // Yes; commit the changes
        Info_CommitChange(this);

        // Sync up the current/previous state
        if (IsFlagSet(this->uState, IS_INCLUDESUBS))
            SetFlag(this->uState, IS_LAST_INCLUDESUBS);
        else
            ClearFlag(this->uState, IS_LAST_INCLUDESUBS);

        bRet = PSNRET_NOERROR;
        }

    GFree(pszExtList);
    ClearFlag(this->uState, IS_CHANGED);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: PSN_SETACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE Info_OnSetActive(
    PINFO this)
    {
    HWND hwnd = this->hwnd;

    // Cause the page to be painted right away 
    SetWindowRedraw(hwnd, TRUE);
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);

    if (this->bInit)
        {
        PageData_Init(this->ppagedata, GetParent(hwnd));
        this->bInit = FALSE;

        Info_SetSelections(this);
        Info_GetSelections(this, &this->pszExtListPrev);
        }

    // Is this data still valid?
    else if (S_FALSE == PageData_Query(this->ppagedata, this->hwnd, NULL, NULL))
        {
        // No; the folder has become an orphan
        Info_DisableAll(this);
        }
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE Info_OnNotify(
    PINFO this,
    int idFrom,
    NMHDR  * lpnmhdr)
    {
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
        {
    case PSN_SETACTIVE:
        Info_OnSetActive(this);
        break;

    case PSN_APPLY:
        lRet = Info_OnApply(this);
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: Determines whether to keep from leaving this sheet.
         For the stand-alone ('Add Folder') dialog, this 
         function enables or disables the OK button.

Returns: --
Cond:    --
*/
void PRIVATE Info_DenyKill(
    PINFO this,
    BOOL bDeny)
    {
    if (Info_StandAlone(this))
        {
        Button_Enable(GetDlgItem(this->hwnd, IDOK), !bDeny);
        }
    else
        {
        if (bDeny)
            SetFlag(this->uState, IS_DENYAPPLY);
        else
            ClearFlag(this->uState, IS_DENYAPPLY);
        }
    }


/*----------------------------------------------------------
Purpose: Enable the Apply button 

Returns: --
Cond:    --
*/
void PRIVATE Info_HandleChange(
    PINFO this)
    {
    if (IsFlagClear(this->uState, IS_CHANGED) && !Info_StandAlone(this))
        {
        SetFlag(this->uState, IS_CHANGED);
        PropSheet_Changed(GetParent(this->hwnd), this->hwnd);
        }
    }


/*----------------------------------------------------------
Purpose: Info WM_COMMAND Handler
Returns: --
Cond:    --
*/
VOID PRIVATE Info_OnCommand(
    PINFO this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    HWND hwnd = this->hwnd;

    switch (id)
        {
    case IDC_RBINALL:
        Info_DenyKill(this, FALSE);
        
        // fall thru

    case IDC_RBINSELECTED:
        // Disable/enable listbox depending on which radio button
        //  is marked.
        //
        if (IDC_RBINALL == id)
            SetFlag(this->uState, IS_ALLTYPES);
        else
            ClearFlag(this->uState, IS_ALLTYPES);
        ListBox_Enable(GetDlgItem(hwnd, IDC_LBINTYPES), IsFlagClear(this->uState, IS_ALLTYPES));
        
        if (IDC_RBINSELECTED == id &&
            0 == ListBox_GetSelCount(GetDlgItem(hwnd, IDC_LBINTYPES)))
            {
            Info_DenyKill(this, TRUE);
            }

        Info_HandleChange(this);
        break;
    
    case IDC_LBINTYPES:
        if (uNotifyCode == LBN_SELCHANGE)
            {
            // Disable/enable OK button based on number of selections
            //  in listbox.
            //
            int csel = ListBox_GetSelCount(GetDlgItem(hwnd, IDC_LBINTYPES));
            
            if (csel == 0)
                Info_DenyKill(this, TRUE);
            else if (csel != this->cselPrev && this->cselPrev == 0)
                Info_DenyKill(this, FALSE);
            this->cselPrev = csel;

            Info_HandleChange(this);
            }

        break;

    case IDC_CHININCLUDE:
        if (FALSE != Button_GetCheck(GetDlgItem(hwnd, IDC_CHININCLUDE)))
            SetFlag(this->uState, IS_INCLUDESUBS);
        else
            ClearFlag(this->uState, IS_INCLUDESUBS);
        Info_HandleChange(this);
        break;
    
    case IDOK:
        if (FAILED(Info_CommitStandAlone(this)))
            EndDialog(hwnd, -1);
    
        // Fall thru
        //  |    |
        //  v    v
    
    case IDCANCEL:
        if (Info_StandAlone(this))
            EndDialog(hwnd, id);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Handle WM_DESTROY
Returns: --
Cond:    --
*/
void PRIVATE Info_OnDestroy(
    PINFO this)
    {
    GFree(this->pszExtListPrev);
    }


/////////////////////////////////////////////////////  PRIVATE FUNCTIONS


static BOOL s_bInfoRecurse = FALSE;

LRESULT INLINE Info_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
    {
    ENTEREXCLUSIVE()
        {
        s_bInfoRecurse = TRUE;
        }
    LEAVEEXCLUSIVE()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
    }


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
*/
LRESULT Info_DlgProc(
    PINFO this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
#pragma data_seg(DATASEG_READONLY)
    const static DWORD rgHelpIDs[] = {
        IDC_RBINALL,        IDH_BFC_FILTER_TYPE,
        IDC_RBINSELECTED,   IDH_BFC_FILTER_TYPE,
        IDC_LBINTYPES,      IDH_BFC_FILTER_TYPE,
        IDC_CHININCLUDE,    IDH_BFC_FILTER_INCLUDE,
        0, 0 };
#pragma data_seg()

    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, Info_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, Info_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, Info_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, Info_OnDestroy);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (DWORD)(LPVOID)rgHelpIDs);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (DWORD)(LPVOID)rgHelpIDs);
        return 0;

    default:
        return Info_DefProc(this->hwnd, message, wParam, lParam);
        }
    }


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
*/
BOOL _export CALLBACK Info_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    PINFO this;
    
    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE()
        {
        if (s_bInfoRecurse)
            {
            s_bInfoRecurse = FALSE;
            LEAVEEXCLUSIVE()
            return FALSE;
            }
        }
    LEAVEEXCLUSIVE()

    this = Info_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = GAlloc(sizeof(*this));
            if (!this)
                {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_INFO), MAKEINTRESOURCE(IDS_CAP_INFO), 
                       NULL,GUID_NULL,NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)Info_DefProc(hDlg, message, wParam, lParam);
                }
            this->hwnd = hDlg;
            Info_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)Info_DefProc(hDlg, message, wParam, lParam);
            }
        }
    
    if (message == WM_DESTROY)
        {
        Info_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Info_SetPtr(hDlg, NULL);
        return 0;
        }
    
    return SetDlgMsgResult(hDlg, message, Info_DlgProc(this, message, wParam, lParam));
    }



/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Entry point to invoke dialog

Returns: standard hresult
Cond:    --
*/
HRESULT PUBLIC Info_DoModal(
    HWND hwndOwner,
    LPCTSTR pszPathFrom,      // Source path
    LPCTSTR pszPathTo,        // Target path
    HDPA hdpaTwin,
    PCBS pcbs)
    {
    HRESULT hres;
    PROPSHEETPAGE psp;
    PAGEDATA pagedata;
    INFODATA infodata;
    
    // (Use the source path for the atomPath because the target path
    // does not exist yet.)
    pagedata.atomPath = Atom_Add(pszPathFrom);
    if (ATOM_ERR != pagedata.atomPath)
        {
        infodata.atomTo = Atom_Add(pszPathTo);
        if (ATOM_ERR != infodata.atomTo)
            {
            int nRet; 

            pagedata.pcbs = pcbs;
            pagedata.lParam = (LPARAM)&infodata;

            infodata.hdpaTwins = hdpaTwin;
            infodata.bStandAlone = TRUE;

            // Fake up a propsheetinfo struct for the dialog box
            psp.lParam = (LPARAM)&pagedata;        // this is all we care about
        
            nRet = DoModal(hwndOwner, Info_WrapperProc, IDD_INFOCREATE, (LPARAM)(LPVOID)&psp);
            Atom_Delete(infodata.atomTo);

            switch (nRet)
                {
            case IDOK:      hres = NOERROR;         break;
            case IDCANCEL:  hres = E_ABORT;         break;
            default:        hres = E_OUTOFMEMORY;   break;
                }
            }
        else
            {
            hres = E_OUTOFMEMORY;
            }
        Atom_Delete(pagedata.atomPath);
        }
    else
        {
        hres = E_OUTOFMEMORY;
        }
    return hres;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\err.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: err.c
//
//  This files contains all error handling routines.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common headers

/////////////////////////////////////////////////////  TYPEDEFS

/////////////////////////////////////////////////////  CONTROLLING DEFINES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MODULE DATA

#ifdef DEBUG

#pragma data_seg(DATASEG_READONLY)

TCHAR const  c_szNewline[] = TEXT("\r\n");
TCHAR const  c_szTrace[] = TEXT("t BRIEFCASE  ");
TCHAR const  c_szDbg[] = TEXT("BRIEFCASE  ");
TCHAR const  c_szAssertFailed[] = TEXT("BRIEFCASE  Assertion failed in %s on line %d\r\n");

struct _RIIDMAP
    {
    REFIID  riid;
    LPCTSTR  psz;
    } const c_rgriidmap[] = {
        { &IID_IUnknown,        TEXT("IID_IUnknown") },
        { &IID_IBriefcaseStg,   TEXT("IID_IBriefcaseStg") },
        { &IID_IBriefcaseStg2,   TEXT("IID_IBriefcaseStg2") },
        { &IID_IEnumUnknown,    TEXT("IID_IEnumUnknown") },
        { &IID_IShellBrowser,   TEXT("IID_IShellBrowser") },
        { &IID_IShellView,      TEXT("IID_IShellView") },
        { &IID_IContextMenu,    TEXT("IID_IContextMenu") },
        { &IID_IShellFolder,    TEXT("IID_IShellFolder") },
        { &IID_IShellExtInit,   TEXT("IID_IShellExtInit") },
        { &IID_IShellPropSheetExt, TEXT("IID_IShellPropSheetExt") },
        { &IID_IPersistFolder,  TEXT("IID_IPersistFolder") },
        { &IID_IExtractIcon,    TEXT("IID_IExtractIcon") },
        { &IID_IShellDetails,   TEXT("IID_IShellDetails") },
        { &IID_IDelayedRelease, TEXT("IID_IDelayedRelease") },
        { &IID_IShellLink,      TEXT("IID_IShellLink") },
        };

struct _SCODEMAP
    {
    SCODE  sc;
    LPCTSTR psz;
    } const c_rgscodemap[] = {
        { S_OK,             TEXT("S_OK") },
        { S_FALSE,          TEXT("S_FALSE") },
        { E_UNEXPECTED,     TEXT("E_UNEXPECTED") },
        { E_NOTIMPL,        TEXT("E_NOTIMPL") },
        { E_OUTOFMEMORY,    TEXT("E_OUTOFMEMORY") },
        { E_INVALIDARG,     TEXT("E_INVALIDARG") },
        { E_NOINTERFACE,    TEXT("E_NOINTERFACE") },
        { E_POINTER,        TEXT("E_POINTER") },
        { E_HANDLE,         TEXT("E_HANDLE") },
        { E_ABORT,          TEXT("E_ABORT") },
        { E_FAIL,           TEXT("E_FAIL") },
        { E_ACCESSDENIED,   TEXT("E_ACCESSDENIED") },
        };


#pragma data_seg()

#endif

/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Return English reason for the debug break
Returns: String
Cond:    --
*/
LPCTSTR PRIVATE GetReasonString(
    UINT flag)      // One of BF_ flags
    {
    LPCTSTR psz;

    if (IsFlagSet(flag, BF_ONOPEN))
        psz = TEXT("BREAK ON OPEN BRIEFCASE\r\n");

    else if (IsFlagSet(flag, BF_ONCLOSE))
        psz = TEXT("BREAK ON CLOSE BRIEFCASE\r\n");

    else if (IsFlagSet(flag, BF_ONRUNONCE))
        psz = TEXT("BREAK ON RunDLL_RunOnlyOnce\r\n");

    else if (IsFlagSet(flag, BF_ONVALIDATE))
        psz = TEXT("BREAK ON VALIDATION FAILURE\r\n");

    else if (IsFlagSet(flag, BF_ONTHREADATT))
        psz = TEXT("BREAK ON THREAD ATTACH\r\n");

    else if (IsFlagSet(flag, BF_ONTHREADDET))
        psz = TEXT("BREAK ON THREAD DETACH\r\n");

    else if (IsFlagSet(flag, BF_ONPROCESSATT))
        psz = TEXT("BREAK ON PROCESS ATTACH\r\n");

    else if (IsFlagSet(flag, BF_ONPROCESSDET))
        psz = TEXT("BREAK ON PROCESS DETACH\r\n");

    else
        psz = c_szNewline;

    return psz;
    }


/*----------------------------------------------------------
Purpose: Perform a debug break based on the flag
Returns: --
Cond:    --
*/
void PUBLIC DEBUG_BREAK(
    UINT flag)      // One of BF_ flags
    {
    BOOL bBreak;
    LPCTSTR psz;

    ENTEREXCLUSIVE()
        {
        bBreak = IsFlagSet(g_uBreakFlags, flag);
        psz = GetReasonString(flag);
        }
    LEAVEEXCLUSIVE()

    if (bBreak)
        {
        TRACE_MSG(TF_ALWAYS, psz);
        DebugBreak();
        }
    }


void PUBLIC BrfAssertFailed(
    LPCTSTR pszFile, 
    int line)
    {
    LPCTSTR psz;
    TCHAR ach[256];
    UINT uBreakFlags;

    ENTEREXCLUSIVE()
        {
        uBreakFlags = g_uBreakFlags;
        }
    LEAVEEXCLUSIVE()

    // Strip off path info from filename string, if present.
    //
    for (psz = pszFile + lstrlen(pszFile); psz != pszFile; psz=CharPrev(pszFile, psz))
        {
        if ((CharPrev(pszFile, psz) != (psz-2)) && *(psz - 1) == TEXT('\\'))
            break;
        }
    wsprintf(ach, c_szAssertFailed, psz, line);
    OutputDebugString(ach);
    
    if (IsFlagSet(uBreakFlags, BF_ONVALIDATE))
        DebugBreak();
    }


void CPUBLIC BrfAssertMsg(
    BOOL f, 
    LPCTSTR pszMsg, ...)
    {
    TCHAR ach[MAXPATHLEN+40];    // Largest path plus extra

    if (!f)
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[ARRAYSIZE(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


void CPUBLIC BrfDebugMsg(
    UINT uFlag, 
    LPCTSTR pszMsg, ...)
    {
    TCHAR ach[MAXPATHLEN+40];    // Largest path plus extra
    UINT uTraceFlags;

    ENTEREXCLUSIVE()
        {
        uTraceFlags = g_uTraceFlags;
        }
    LEAVEEXCLUSIVE()

    if (uFlag == TF_ALWAYS || IsFlagSet(uTraceFlags, uFlag))
        {
        lstrcpy(ach, c_szTrace);
        wvsprintf(&ach[ARRAYSIZE(c_szTrace)-1], pszMsg, (va_list)(&pszMsg + 1));
        OutputDebugString(ach);
        OutputDebugString(c_szNewline);
        }
    }


/*----------------------------------------------------------
Purpose: Returns the string form of an known interface ID.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_GetRiidName(
    REFIID riid)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(c_rgriidmap); i++)
        {
        if (IsEqualIID(riid, c_rgriidmap[i].riid))
            return c_rgriidmap[i].psz;
        }
    return TEXT("Unknown riid");
    }


/*----------------------------------------------------------
Purpose: Returns the string form of an scode given an hresult.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_GetScode(
    HRESULT hres)
    {
    int i;
    SCODE sc;

    sc = GetScode(hres);
    for (i = 0; i < ARRAYSIZE(c_rgscodemap); i++)
        {
        if (sc == c_rgscodemap[i].sc)
            return c_rgscodemap[i].psz;
        }
    return TEXT("Unknown scode");
    }


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print...and I don't
         mean swear words.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_SafeStr(
    LPCTSTR psz)
    {
    if (psz)
        return psz;
    else
        return TEXT("NULL");
    }


/*----------------------------------------------------------
Purpose: Returns a string safe enough to print given an IDataObject.

Returns: String ptr
Cond:    --
*/
LPCTSTR PUBLIC Dbg_DataObjStr(
    LPDATAOBJECT pdtobj,
    LPTSTR pszBuf)
    {
    if (pdtobj)
        {
        DataObj_QueryPath(pdtobj, pszBuf);
        }
    else
        {
        lstrcpy(pszBuf, TEXT("NULL"));
        }
    return pszBuf;
    }


#endif  // DEBUG


/*----------------------------------------------------------
Purpose: This function maps the hresult to an hresult in the 
         error table, and displays the corresponding string
         in a messagebox.

Returns: return value of MessageBox
Cond:    --
*/
int PUBLIC SEMsgBox(
    HWND hwnd,
    UINT idsCaption,
    HRESULT hres,
    PCSETBL pTable,
    UINT cArraySize)        // Number of elements in table
    {
    PCSETBL p;
    PCSETBL pEnd;

    p = pTable;
    pEnd = &pTable[cArraySize-1];
    while (p != pEnd)
        {
        if (p->hres == hres)
            {
            return MsgBox(hwnd, MAKEINTRESOURCE(p->ids), MAKEINTRESOURCE(idsCaption), 
                NULL,GUID_NULL,NULL, p->uStyle);
            }
        p++;
        }

    // Cover last entry
    if (p->hres == hres)
        {
        return MsgBox(hwnd, MAKEINTRESOURCE(p->ids), MAKEINTRESOURCE(idsCaption), 
            NULL,GUID_NULL,NULL, p->uStyle);
        }

    return -1;
    }


/*----------------------------------------------------------
Purpose: Maps an hresult to a valid "official" hresult.  This
         is necessary because the SYNCUI uses a FACILITY_TR
         which is only good for us, but unknown to the outside
         world.

Returns: hresult
Cond:    --
*/
HRESULT PUBLIC MapToOfficialHresult(
    HRESULT hres)
    {
    if (IS_ENGINE_ERROR(hres))
        {
        SCODE sc = GetScode(hres);

        if (E_TR_OUT_OF_MEMORY == sc)
            hres = ResultFromScode(E_OUTOFMEMORY);
        else
            hres = ResultFromScode(E_FAIL);
        }

    return hres;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\ibrfstg.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: ibrfstg.c
//
//  This files contains the IBriefcaseStg interface.
//
// History:
//  02-02-94 ScottH     Converted from iface.c
//
//---------------------------------------------------------------------------

#include "brfprv.h"         // common headers
#undef LODWORD              // (because they are redefined by configmg.h)
#undef HIDWORD

#include "brfcasep.h"
#include "update.h"
#include "recact.h"
#include "res.h"

// #include <help.h> // rogerg commented out

#ifdef WINNT
    // BobDay - We need some mechanism of determining dock state
#else
    // Needed for dock state determination
#define Not_VxD
#define No_CM_Calls
#include <vmm.h>
#include <configmg.h> // rogerg, need a define or something from here.

#endif 

//---------------------------------------------------------------------------
// BriefStg Class
//---------------------------------------------------------------------------

// An IBriefcaseStg interface instance is created for each
// folder the caller (the Shell) binds to, where the folder
// is known to be inside a briefcase storage.  A briefcase
// storage is the overall storage area (the database) that
// starts at a given folder (called the "briefcase root")
// and extends onwards and below in the file-system.
//
// Internally, the briefcase storage holds the path to the
// folder that this instance is bound to, and it holds a
// cached briefcase structure (CBS), which itself holds a
// reference to the briefcase root.
//
typedef struct _BriefStg
    {
    IBriefcaseStg   bs;
    UINT            cRef;           // reference count
    CBS *           pcbs;           // cached briefcase info
    TCHAR            szFolder[MAX_PATH]; // canonical path
    HBRFCASEITER    hbrfcaseiter;   // handle to iterate briefcases
    DWORD           dwFlags;        // BSTG_* flags

	// rogerg - add items for sync interfaces
	PRECLIST prl; 
	UPDCOUNT updcount;
	UINT uVal;

    } BriefStg, * PBRIEFSTG;

// Flags for BriefStg
#define BSTG_SYNCFOLDER     0x00000001      // This folder has a sync copy


//---------------------------------------------------------------------------
// Supporting private code
//---------------------------------------------------------------------------


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump all the cache tables
Returns: --
Cond:    --
*/
void PUBLIC DumpTables()
    {
    Atom_DumpAll();
    CBS_DumpAll();
    CRL_DumpAll();
    }
#endif


/*----------------------------------------------------------
Purpose: Initialize the cache tables
Returns: --
Cond:    --
*/
BOOL PRIVATE InitCacheTables()
    {
    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Initialize cache tables")); )

    if (!CBS_Init())
        goto Init_Fail;

    if (!CRL_Init())
        goto Init_Fail;

    return TRUE;

Init_Fail:

    CRL_Term();
    CBS_Term(NULL);
    return FALSE;
    }


/*----------------------------------------------------------
Purpose: Terminate the cache tables
Returns: --
Cond:    --
*/
void PUBLIC TermCacheTables(void)
    {
    ASSERT(Sync_IsEngineLoaded());

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Terminate cache tables")); )

    CRL_Term();

    CBS_Term(NULL);
    }


/*----------------------------------------------------------
Purpose: Returns TRUE if the path (a folder) has a sync copy.

Returns: see above
Cond:    --
*/
BOOL PRIVATE HasFolderSyncCopy(
    HBRFCASE hbrf,
    LPCTSTR pszPath)
    {
    ASSERT(pszPath);
    ASSERT(PathIsDirectory(pszPath));

    return (S_OK == Sync_IsTwin(hbrf, pszPath, SF_ISFOLDER) ||
            IsSubfolderTwin(hbrf, pszPath));
    }


/*----------------------------------------------------------
Purpose: Open a folder that belongs to a briefcase storage.
         The pszPath parameter is a folder, which is not necessarily
         the briefcase root.

Returns: NOERROR on success
Cond:    --
*/
HRESULT PRIVATE OpenBriefcaseStorage(
    LPCTSTR pszPath,
    CBS ** ppcbs,
    HWND hwndOwner)
    {
    HRESULT hres;
    UINT uLocality;
    int atomBrf;
    TCHAR szBrfPath[MAX_PATH];
    TCHAR szBrfCanon[MAX_PATH];

    ASSERT(pszPath);
    ASSERT(ppcbs);

    DBG_ENTER_SZ(TEXT("OpenBriefcaseStorage"), pszPath);
    DEBUG_CODE( DEBUG_BREAK(BF_ONOPEN); )

    // Get the root folder of the briefcase storage
    // Get strictly up to the briefcase portion of path
    //
    uLocality = PathGetLocality(pszPath, szBrfPath);
    if (PL_FALSE == uLocality)
        {
        // The only time we get here is if the caller had a legitimate
        // reason to believe this folder was a briefcase storage,
        // but no database exists (yet).  Just continue on as normal,
        // the database will get created later.
        BrfPathCanonicalize(pszPath, szBrfCanon);
        }
    else
        {
        BrfPathCanonicalize(szBrfPath, szBrfCanon);
        }

    // Add this path to the atom list and add it to the
    // cached briefcase structure table.
    // (Reference count decrement happens in CloseBriefcase)
    //
    atomBrf = Atom_Add(szBrfCanon);
    if (atomBrf != ATOM_ERR)
        {
        hres = CBS_Add(ppcbs, atomBrf, hwndOwner);
        }
    else
        {
        *ppcbs = NULL;
        hres = ResultFromScode(E_OUTOFMEMORY);
        }

    DEBUG_CODE( DumpTables(); )

    DBG_EXIT_HRES(TEXT("OpenBriefcaseStorage"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Close a briefcase.

Returns: NOERROR on success
Cond:    --
*/
HRESULT PRIVATE CloseBriefcaseStorage(
    LPCTSTR pszPath)
    {
    int atomBrf;
    TCHAR szBrfPath[MAX_PATH];
    TCHAR szBrfCanon[MAX_PATH];
    UINT uLocality;

    ASSERT(pszPath);
    ASSERT(*pszPath);       // Should not be an emptry string

    DBG_ENTER_SZ(TEXT("CloseBriefcaseStorage"), pszPath);
    DEBUG_CODE( DEBUG_BREAK(BF_ONCLOSE); )

    DEBUG_CODE( DumpTables(); )

    // Save the briefcase and remove it from the cache
    //
    // Get the root folder of the briefcase storage
    // Get strictly up to the briefcase portion of path
    //
    uLocality = PathGetLocality(pszPath, szBrfPath);
    if (PL_FALSE == uLocality)
        {
        // The only time we get here is for a briefcase storage that
        // has no database yet.  Just continue on as normal,
        // the database will get created very soon now.
        BrfPathCanonicalize(pszPath, szBrfCanon);
        }
    else
        {
        BrfPathCanonicalize(szBrfPath, szBrfCanon);
        }

    atomBrf = Atom_Find(szBrfCanon);
    ASSERT(atomBrf != ATOM_ERR);

    CBS_Delete(atomBrf, NULL);

    Atom_Delete(atomBrf);      // for the Add in OpenBriefcaseStorage

    DBG_EXIT_HRES(TEXT("CloseBriefcaseStorage"), NOERROR);

    return NOERROR;
    }


// Confirm button flags
#define CBF_YES         0x0001
#define CBF_NO          0x0002
#define CBF_TOALL       0x0004
#define CBF_CANCEL      0x0008

/*----------------------------------------------------------
Purpose: Checks to see if the given file/folder already exists
          in the given directory.  Prompts the user to confirm
          replacing if this is true.

Returns: TRUE if path exists
         confirm flag settings

Cond:    --
*/
BOOL PRIVATE DoesPathAlreadyExist(
    CBS  * pcbs,
    LPCTSTR pszPathOld,
    LPCTSTR pszPathNew,
    LPUINT puConfirmFlags,  // CBF_*
    UINT uFlags,            // SF_ISFOLDER or SF_ISFILE
    HWND hwndOwner,
    BOOL bMultiDrop)
    {
    BOOL bRet;
    BOOL bIsTwin;

    ASSERT(puConfirmFlags);

    // Retain settings of *puConfirmFlags coming in

    bIsTwin = (S_OK == Sync_IsTwin(pcbs->hbrf, pszPathOld, uFlags));
    if (bIsTwin)
        uFlags |= SF_ISTWIN;
    else
        uFlags |= SF_ISNOTTWIN;

    bRet = (FALSE != PathExists(pszPathOld));

    // Does the path already exist?
    if (!bRet)
        {
        // No; remove it from the database if it is in there so we
        // don't add duplicates.
        Sync_Split(pcbs->hbrf, pszPathOld, 1, hwndOwner, uFlags | SF_QUIET | SF_NOCONFIRM);
        }
    else
        {
        // Yes; has a "to all" previously been specified by the user?
        if (IsFlagSet(*puConfirmFlags, CBF_TOALL))
            {
            // Yes; keep flags as they are

            // (CBF_YES and CBF_NO flags are mutually exclusive)
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_YES) &&
                        IsFlagClear(*puConfirmFlags, CBF_NO | CBF_CANCEL) ||
                   IsFlagSet(*puConfirmFlags, CBF_NO) &&
                        IsFlagClear(*puConfirmFlags, CBF_YES | CBF_CANCEL));
            }
        else
            {
            // No; prompt the user
            UINT uFlagsCRF = bMultiDrop ? CRF_MULTI : CRF_DEFAULT;
            int id = ConfirmReplace_DoModal(hwndOwner, pszPathOld, pszPathNew, uFlagsCRF);

            *puConfirmFlags = 0;

            if (GetKeyState(VK_SHIFT) < 0)
                SetFlag(*puConfirmFlags, CBF_TOALL);

            if (IDYES == id)
                SetFlag(*puConfirmFlags, CBF_YES);
            else if (IDNO == id)
                SetFlag(*puConfirmFlags, CBF_NO);
            else if (IDC_YESTOALL == id)
                SetFlag(*puConfirmFlags, CBF_YES | CBF_TOALL);
            else
                {
                ASSERT(IDCANCEL == id);
                SetFlag(*puConfirmFlags, CBF_CANCEL);
                }
            }

        // Has the user chosen to replace the file?
        if (IsFlagSet(*puConfirmFlags, CBF_YES))
            {
            // Yes; is this an existing twin?
            if (bIsTwin)
                {
                // Yes; delete it from the database before we continue
                Sync_Split(pcbs->hbrf, pszPathOld, 1, hwndOwner, SF_QUIET | SF_NOCONFIRM);
                }

            // Some merge-handlers need the unwanted file to be deleted
            // first because they cannot tell the difference between
            // a newly added file (that is replacing an existing file)
            // and a one-way merge.
            if (!PathIsDirectory(pszPathOld))
                DeleteFile(pszPathOld);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Add the folder twin to the database, using the default
         *.* wildcard settings.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE AddDefaultFolderTwin(
    HWND hwndOwner,
    HBRFCASE hbrf,
    HDPA hdpa,               // Return: twin handle in array
    LPCTSTR pszPathFrom,      // Source path
    LPCTSTR pszPathTo)        // Target path
    {
    HRESULT hres;
    int iTwin;

    // First make sure we can add another handle to hdpa (set to zero for now)
    if (DPA_ERR == (iTwin = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)NULL)))
        {
        hres = E_OUTOFMEMORY;
        }
    else
        {
        NEWFOLDERTWIN nft;
        TWINRESULT tr;
        HFOLDERTWIN hft;

        RETRY_BEGIN(FALSE)
            {
            ZeroInit(&nft, NEWFOLDERTWIN);
            nft.ulSize = sizeof(nft);
            nft.pcszFolder1 = pszPathFrom;
            nft.pcszFolder2 = pszPathTo;
            nft.pcszName = c_szAllFiles;
            nft.dwAttributes = OBJECT_TWIN_ATTRIBUTES;
            nft.dwFlags = NFT_FL_SUBTREE;

            // Add the twin
            tr = Sync_AddFolder(hbrf, &nft, &hft);
            hres = HRESULT_FROM_TR(tr);

            if (FAILED(hres))
                {
                DWORD dwError = GetLastError();
                int id;
                extern SETbl const c_rgseInfo[4];

                // Unavailable disk?
                if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                    {
                    // Yes
                    hres = E_TR_UNAVAILABLE_VOLUME;
                    }

                id = SEMsgBox(hwndOwner, IDS_CAP_INFO, hres, c_rgseInfo, ARRAYSIZE(c_rgseInfo));
                if (IDRETRY == id)
                    {
                    // Try the operation again
                    RETRY_SET();
                    }
                }
            }
        RETRY_END()

        if (FAILED(hres))
            {
            DPA_DeletePtr(hdpa, iTwin);
            }
        else
            {
            // Success
            ASSERT(DPA_ERR != iTwin);
            ASSERT(NULL != hft);
            DPA_SetPtr(hdpa, iTwin, (LPVOID)(DWORD)hft);
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a twin relationship between a folder and
         another folder.

Returns: standard hresult
         handles to created twins in hdpa
         confirm flag settings

Cond:    --
*/
HRESULT PRIVATE CreateTwinOfFolder(
    CBS  * pcbs,
    LPTSTR pszPath,          // Dragged folder path
    LPCTSTR pszDir,          // Location to place twin
    HDPA hdpaTwin,          // array of twin handles
    UINT uFlags,            // AOF_*
    PUINT puConfirmFlags,   // CBF_*
    HWND hwndOwner,
    BOOL bMultiDrop)        // TRUE: more than 1 file/folder was dropped
    {
    HRESULT hres;
    TCHAR szPathB[MAX_PATH];
    LPTSTR pszFile;

    ASSERT(pszPath);
    ASSERT(pszDir);

    pszFile = PathFindFileName(pszPath);

    // Will the path name be too long?
    if (PathsTooLong(pszDir, pszFile))
        {
        // Yes; bail
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFOLDER_TOOLONG),
               MAKEINTRESOURCE(IDS_CAP_ADD),NULL,GUID_NULL, NULL, MB_ERROR, pszFile);
        hres = E_FAIL;
        }
    // Did the user drag another briefcase root into this briefcase?
    else if (PathIsBriefcase(pszPath))
        {
        // Yes; we don't allow nested briefcases!  Tell the user.
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_CANTADDBRIEFCASE),
               MAKEINTRESOURCE(IDS_CAP_ADD),NULL,GUID_NULL, NULL, MB_WARNING);
        hres = E_FAIL;
        }
    else
        {
        // No; check for an existing folder in the target folder.
        BOOL bExists;

        PathCombine(szPathB, pszDir, pszFile);
        bExists = DoesPathAlreadyExist(pcbs, szPathB, pszPath, puConfirmFlags, SF_ISFOLDER, hwndOwner, bMultiDrop);

        if (!bExists || IsFlagSet(*puConfirmFlags, CBF_YES))
            {
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_NO) &&
                   IsFlagClear(*puConfirmFlags, CBF_CANCEL));

            // Show 'Add Folder' dialog?
            if (IsFlagSet(uFlags, AOF_FILTERPROMPT))
                {
                // Yes
                hres = Info_DoModal(hwndOwner, pszPath, szPathB, hdpaTwin,
                        pcbs);
                }
            else
                {
                // No; just default to *.*
                hres = AddDefaultFolderTwin(hwndOwner, pcbs->hbrf, hdpaTwin,
                        pszPath, szPathB);
                }
            }
        else if (IsFlagSet(*puConfirmFlags, CBF_NO))
            {
            // The user said NO
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                   IsFlagClear(*puConfirmFlags, CBF_CANCEL));
            hres = NOERROR;
            }
        else
            {
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_CANCEL));
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                   IsFlagClear(*puConfirmFlags, CBF_NO));
            hres = E_ABORT;
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a twin of a file.

Returns: standard result
         twin handle in hdpa
Cond:    --
*/
HRESULT PRIVATE CreateTwinOfFile(
    CBS  * pcbs,
    LPCTSTR pszPath,         // ptr to path to twin
    LPCTSTR pszTargetDir,    // ptr to dest dir
    HDPA hdpa,              // Return: twin handle in array
    UINT uFlags,            // AOF_*
    PUINT puConfirmFlags,   // CBF_*
    HWND hwndOwner,
    BOOL bMultiDrop)        // TRUE: more than 1 file/folder was dropped
    {
    HRESULT hres;
    int iTwin;
    TCHAR szPath[MAX_PATH];
    LPCTSTR pszFile;
    HTWINFAMILY htfam = NULL;

    ASSERT(pszPath);
    ASSERT(pszTargetDir);

    pszFile = PathFindFileName(pszPath);

    // Will the path name be too long?
    if (PathsTooLong(pszTargetDir, pszFile))
        {
        // Yes; bail
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFILE_TOOLONG),
               MAKEINTRESOURCE(IDS_CAP_ADD),NULL,GUID_NULL,NULL,0, NULL, MB_ERROR, pszFile);
        iTwin = DPA_ERR;
        hres = E_FAIL;
        }
    // First make sure we can add another handle to hdpa (set to zero for now)
    else if (DPA_ERR == (iTwin = DPA_InsertPtr(hdpa, DPA_APPEND, (LPVOID)NULL)))
        {
        hres = E_OUTOFMEMORY;
        }
    else
        {
        BOOL bExists;

        // Confirm the replace if a file with the same name already exists.
        //
        PathCombine(szPath, pszTargetDir, pszFile);
        bExists = DoesPathAlreadyExist(pcbs, szPath, pszPath, puConfirmFlags, SF_ISFILE, hwndOwner, bMultiDrop);

        if (!bExists ||
            IsFlagSet(*puConfirmFlags, CBF_YES))
            {
            NEWOBJECTTWIN not;
            TWINRESULT tr;
            DECLAREHOURGLASS;

            ASSERT(IsFlagClear(*puConfirmFlags, CBF_NO) &&
                   IsFlagClear(*puConfirmFlags, CBF_CANCEL));

            lstrcpy(szPath, pszPath);
            PathRemoveFileSpec(szPath);

            // User has either opted to continue adding this object to the
            // database, or it does not exist in the destination folder.

            RETRY_BEGIN(FALSE)
                {
                ZeroInit(&not, NEWOBJECTTWIN);
                not.ulSize = sizeof(NEWOBJECTTWIN);
                not.pcszFolder1 = szPath;
                not.pcszFolder2 = pszTargetDir;
                not.pcszName = pszFile;

                SetHourglass();
                Sync_Dump(&not, NEWOBJECTTWIN);
                tr = Sync_AddObject(pcbs->hbrf, &not, &htfam);
                ResetHourglass();

                hres = HRESULT_FROM_TR(tr);

                if (FAILED(hres))
                    {
                    DWORD dwError = GetLastError();

                    // Unavailable disk?
                    if (ERROR_INVALID_DATA == dwError || ERROR_ACCESS_DENIED == dwError)
                        {
                        // Yes; ask user to retry/cancel
                        int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_ADDFILE_UNAVAIL_VOL),
                            MAKEINTRESOURCE(IDS_CAP_ADD),NULL,GUID_NULL, NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                        // Set specific error value
                        hres = E_TR_UNAVAILABLE_VOLUME;

                        if (IDRETRY == id)
                            {
                            RETRY_SET();    // Try again
                            }
                        }
                    }
                }
            RETRY_END()
            }
        else if (IsFlagSet(*puConfirmFlags, CBF_NO))
            {
            // The user said NO
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                   IsFlagClear(*puConfirmFlags, CBF_CANCEL));
            DPA_DeletePtr(hdpa, iTwin);
            hres = NOERROR;
            }
        else
            {
            ASSERT(IsFlagSet(*puConfirmFlags, CBF_CANCEL));
            ASSERT(IsFlagClear(*puConfirmFlags, CBF_YES) &&
                   IsFlagClear(*puConfirmFlags, CBF_NO));
            hres = E_ABORT;
            }
        }

    if (FAILED(hres))
        {
        if (DPA_ERR != iTwin)
            {
            DPA_DeletePtr(hdpa, iTwin);
            }
        }
    else
        {
        // Success
        ASSERT(DPA_ERR != iTwin);
        if (htfam)
            DPA_SetPtr(hdpa, iTwin, (LPVOID)(DWORD)htfam);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Deletes the new twins
Returns: --
Cond:    --
*/
void PRIVATE DeleteNewTwins(
    CBS  * pcbs,
    HDPA hdpa)
    {
    int iItem;
    int cItems;

    ASSERT(pcbs);
    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    for (iItem = 0; iItem < cItems; iItem++)
        {
        HTWIN htwin = DPA_FastGetPtr(hdpa, iItem);

        if (htwin)
            Sync_DeleteTwin(htwin);
        }
    }


/*----------------------------------------------------------
Purpose: Releases the twin handles
Returns: --
Cond:    --
*/
void PRIVATE ReleaseNewTwins(
    HDPA hdpa)
    {
    int i;
    int cItems;

    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    for (i = 0; i < cItems; i++)
        {
        HTWIN htwin = DPA_FastGetPtr(hdpa, i);

        if (htwin)
            Sync_ReleaseTwin(htwin);
        }
    }


/*----------------------------------------------------------
Purpose: Returns the count of nodes that do not have FS_COND_UNAVAILABLE.

Returns: see above
Cond:    --
*/
UINT PRIVATE CountAvailableNodes(
    PRECITEM pri)
    {
    UINT ucNodes = 0;
    PRECNODE prn;

    for (prn = pri->prnFirst; prn; prn = prn->prnNext)
        {
        if (FS_COND_UNAVAILABLE != prn->fsCurrent.fscond)
            {
            ucNodes++;
            }
        }
    return ucNodes;
    }


/*----------------------------------------------------------
Purpose: Returns the count of nodes that require some sort of
         action.

Returns: see above
Cond:    --
*/
UINT PRIVATE CountActionItem(
    PRECLIST prl)
    {
    UINT uc = 0;
    PRECITEM pri;

    for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
        if (RIA_NOTHING != pri->riaction)
            {
            uc++;
            }
        }
    return uc;
    }


/*----------------------------------------------------------
Purpose: Update the twins in the list

Returns:
Cond:    --
*/
HRESULT PRIVATE MassageReclist(
    CBS * pcbs,
    PRECLIST prl,
    LPCTSTR pszInsideDir,
    BOOL bCopyIn,
    HWND hwndOwner)
    {
    HRESULT hres = NOERROR;
    PRECITEM pri;
    BOOL bWarnUser = TRUE;
    PRECNODE prnInside;
    PRECNODE prnOutside;

    // Make sure the direction of the reconciliation coincides
    // with the direction of the user's action.
    for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
        if (RIA_NOTHING != pri->riaction)
            {
            UINT cAvailableNodes = CountAvailableNodes(pri);

            // Is this a wierd multi-edged case (not including
            // Sneakernet)?
            if (2 < cAvailableNodes)
                {
                // Should never get here, but better safe than sorry
                ASSERT(0);
                }
            else
                {
                // No; get the pair of nodes that we just added to the
                // database.
                hres = Sync_GetNodePair(pri, Atom_GetName(pcbs->atomBrf),
                    pszInsideDir, &prnInside, &prnOutside);

                if (SUCCEEDED(hres))
                    {
                    ASSERT(prnInside);
                    ASSERT(prnOutside);

                    if (bCopyIn)
                        {
                        switch (prnOutside->rnstate)
                            {
                        case RNS_UNAVAILABLE:
                        case RNS_DOES_NOT_EXIST:
                        case RNS_DELETED:
                            break;      // leave alone

                        default:
                            // Force the update to be a copy into the briefcase.
                            pri->riaction = RIA_COPY;
                            prnInside->rnaction = RNA_COPY_TO_ME;
                            prnOutside->rnaction = RNA_COPY_FROM_ME;

                            TRACE_MSG(TF_GENERAL, TEXT("Massaging reclist"));
                            break;
                            }
                        }
                    else
                        {
                        switch (prnInside->rnstate)
                            {
                        case RNS_UNAVAILABLE:
                        case RNS_DOES_NOT_EXIST:
                        case RNS_DELETED:
                            break;      // leave alone

                        default:
                            // Force the update to be a copy out of the briefcase.
                            pri->riaction = RIA_COPY;
                            prnInside->rnaction = RNA_COPY_FROM_ME;
                            prnOutside->rnaction = RNA_COPY_TO_ME;

                            TRACE_MSG(TF_GENERAL, TEXT("Massaging reclist"));
                            break;
                            }
                        }
                    }
                else
                    break;      // Error
                }
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Check for more than 2 available nodes in each recitem.
         Remove the associated twin if we find such a case,
         to prevent multiple sync copies.

Returns: S_OK if everything looks ok
         S_FALSE if there were multiple sync copies introduced

Cond:    --
*/
HRESULT PRIVATE VerifyTwins(
    CBS  * pcbs,
    PRECLIST prl,
    LPCTSTR pszTargetDir,
    HWND hwndOwner)
    {
    HRESULT hres = NOERROR;
    PRECITEM pri;
    BOOL bWarnUser = TRUE;
    BOOL bWarnUserFolder = TRUE;
    TCHAR szPath[MAX_PATH];

    // Look thru the reclist and pick out recitems that have more than
    // 2 recnodes that are currently available.

    // Scenarios when this can happen:
    //
    //  1) Foo.txt --> BC
    //     Foo.txt --> BC\Orphan Folder
    //
    //          Expected result: delete BC\Orphan Folder\Foo.txt twin
    //
    //  2) Foo.txt --> BC\Orphan Folder
    //     Orphan Folder --> BC
    //
    //          Expected result: delete BC\Orphan Folder twin
    //
    //  3) Foo.txt --> BC\Orphan Folder
    //     Foo.txt --> BC
    //
    //          Expected result: delete BC\Foo.txt twin
    //

    for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
        UINT cAvailableNodes = CountAvailableNodes(pri);
        PRECNODE prn;

        // Are there more than 2 available nodes?
        if (2 < cAvailableNodes && *pri->pcszName)
            {
            BOOL bLookForFolders = TRUE;

            // FIRST: Look for object twins that are not in folder twins.
            for (prn = pri->prnFirst; prn; prn = prn->prnNext)
                {
                // Is this file here because the file was dragged in?
                if (IsSzEqual(pszTargetDir, prn->pcszFolder))
                    {
                    // Yes; warn the user
                    if (bWarnUser)
                        {
                        MsgBox(hwndOwner,
                               MAKEINTRESOURCE(IDS_ERR_ADDFILE_TOOMANY),
                               MAKEINTRESOURCE(IDS_CAP_ADD),
                               NULL,GUID_NULL,NULL, MB_WARNING, pri->pcszName);

                        if (0 > GetKeyState(VK_SHIFT))
                            {
                            bWarnUser = FALSE;
                            }
                        }

                    // Try to remove the object twin
                    PathCombine(szPath, prn->pcszFolder, pri->pcszName);
                    hres = Sync_Split(pcbs->hbrf, szPath, 1, hwndOwner,
                                        SF_QUIET | SF_NOCONFIRM);

                    TRACE_MSG(TF_GENERAL, TEXT("Deleted object twin for %s"), szPath);
                    ASSERT(FAILED(hres) || S_OK == hres);

                    bLookForFolders = FALSE;
                    break;
                    }
                }


            if (bLookForFolders)
                {
                // SECOND: Look for object twins that exist because of folder
                // twins.
                for (prn = pri->prnFirst; prn; prn = prn->prnNext)
                    {
                    lstrcpy(szPath, prn->pcszFolder);
                    PathRemoveFileSpec(szPath);

                    // Is this file here because it is in a folder that was
                    // dragged in?
                    if (IsSzEqual(pszTargetDir, szPath))
                        {
                        // Yes; warn the user
                        if (bWarnUserFolder && bWarnUser)
                            {
                            MsgBox(hwndOwner,
                                   MAKEINTRESOURCE(IDS_ERR_ADDFOLDER_TOOMANY),
                                   MAKEINTRESOURCE(IDS_CAP_ADD),
                                   NULL,GUID_NULL,NULL, MB_WARNING, PathFindFileName(prn->pcszFolder));

                            // Hack: to prevent showing this messagebox for
                            // every file in this folder, set this flag
                            bWarnUserFolder = FALSE;

                            if (0 > GetKeyState(VK_SHIFT))
                                {
                                bWarnUser = FALSE;
                                }
                            }

                        // Remove the folder twin
                        hres = Sync_Split(pcbs->hbrf, prn->pcszFolder, 1, hwndOwner,
                                            SF_ISFOLDER | SF_QUIET | SF_NOCONFIRM);

                        TRACE_MSG(TF_GENERAL, TEXT("Deleted folder twin for %s"), prn->pcszFolder);

                        ASSERT(FAILED(hres) || !bWarnUserFolder || S_OK == hres);
                        break;
                        }
                    }
                }
            hres = S_FALSE;
            }
        }
    return hres;
    }


#define STATE_VERIFY    0
#define STATE_UPDATE    1
#define STATE_STOP      2

/*----------------------------------------------------------
Purpose: This function updates the new files.  Unlike the general
         update function, this strictly updates file pairs.  All
         other incidental nodes are set to RNA_NOTHING.

         In addition, to be safe, we force the update to always
         perform a copy into the briefcase.

         This function releases the twin handles when it is finished.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE UpdateNewTwins(
    CBS  * pcbs,
    LPCTSTR pszInsideDir,
    LPCTSTR pszTargetDir,
    BOOL bCopyIn,
    HDPA hdpa,
    HWND hwndOwner)
    {
    HRESULT hres = E_FAIL;
    int iItem;
    int cItems;

    ASSERT(pcbs);
    ASSERT(hdpa);

    cItems = DPA_GetPtrCount(hdpa);
    if (cItems > 0)
        {
        HTWINLIST htl;
        PRECLIST prl;
        TWINRESULT tr;

        tr = Sync_CreateTwinList(pcbs->hbrf, &htl);

        if (TR_SUCCESS != tr)
            {
            hres = HRESULT_FROM_TR(tr);
            }
        else
            {
            HWND hwndProgress;
            UINT nState = STATE_VERIFY;
            DEBUG_CODE( UINT nCount = 0; )

            // State progression is simple:
            //   STATE_VERIFY --> STATE_UPDATE --> STATE_STOP
            // Any questions?

            hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING, DELAY_UPDBAR,NULL,GUID_NULL);

            for (iItem = 0; iItem < cItems; iItem++)
                {
                HTWIN htwin = DPA_FastGetPtr(hdpa, iItem);

                if (htwin)
                    Sync_AddToTwinList(htl, htwin);
                }

            do
                {
                ASSERT(STATE_VERIFY == nState || STATE_UPDATE == nState);
                ASSERT(2 > nCount++);       // Sanity check for infinite loop

                // Create the reclist
                hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), &prl);

                DEBUG_CODE( Sync_DumpRecList(GET_TR(hres), prl, TEXT("Adding new twins")); )

                if (SUCCEEDED(hres))
                    {
                    ASSERT(prl);

                    switch (nState)
                        {
                    case STATE_VERIFY:
                        hres = VerifyTwins(pcbs, prl, pszTargetDir, hwndOwner);
                        if (S_FALSE == hres)
                            nState = STATE_UPDATE;
                        else if (S_OK == hres)
                            goto Update;
                        else
                            nState = STATE_STOP;
                        break;

                    case STATE_UPDATE:
                        // After recreating the reclist, is there anything
                        // that needs updating?
                        if (0 < CountActionItems(prl))
                            {
                            // Yes
Update:
                            UpdBar_SetAvi(hwndProgress, UB_UPDATEAVI);

                            hres = MassageReclist(pcbs, prl, pszInsideDir, bCopyIn, hwndOwner);
                            if (SUCCEEDED(hres))
                                {
                                // Update these files
                                hres = Sync_ReconcileRecList(prl, Atom_GetName(pcbs->atomBrf),
                                    hwndProgress, RF_ONADD);
                                }
                            }

                        nState = STATE_STOP;
                        break;

                    default:
                        ASSERT(0);
                        break;
                        }

                    Sync_DestroyRecList(prl);
                    }

                } while (SUCCEEDED(hres) && STATE_UPDATE == nState);

            Sync_DestroyTwinList(htl);

            UpdBar_Kill(hwndProgress);
            }
        }
    return hres;
    }


#ifdef WINNT
    // WinNT docking state determination code goes here.
#else
// This struct is used to carry stack data across address spaces
// for the configuration manager service call.
typedef struct tagCM_Get_Profile_Param {
    CMAPI    cmApi;
    ULONG    ulIndex;
    PHWPROFILEINFO pHWProfileInfo;
    ULONG    ulFlags;
}   CM_GET_PROFILE_PARAM;

#define HEAP_SHARED     0x04000000      /* put heap in shared memory */
#define CMHEAPSIZE      4096

/*----------------------------------------------------------
Purpose: Service call to get the profile info from the configuration
         manager.

Returns: CONFIGRET
Cond:    --
*/
CONFIGRET _cdecl CM_Get_Hardware_Profile_Info(
    ULONG ulIndex,
    PHWPROFILEINFO pHWProfileInfo,
    ULONG ulFlags)
    {
    CONFIGRET crRetVal = CR_OUT_OF_MEMORY;
    HANDLE hHeap;

    // Allocate our shared heap.  (This is expensive, but this function
    // is rarely called.)
    if (NULL != (hHeap = HeapCreate(HEAP_SHARED, 1, CMHEAPSIZE)))
        {
        DWORD dwRecipients = BSM_VXDS;
        CM_GET_PROFILE_PARAM * pcm;
        DWORD cbVarSize;

        // Allocate CMAPI from our shared heap
        cbVarSize = sizeof(*pHWProfileInfo);

        pcm = (CM_GET_PROFILE_PARAM *)HeapAlloc(hHeap, HEAP_ZERO_MEMORY,
                sizeof(CM_GET_PROFILE_PARAM) + cbVarSize);
        if (NULL != pcm)
            {
            // Package the parameter list
            pcm->cmApi.dwCMAPIRet      = 0;
            pcm->cmApi.dwCMAPIService  = GetVxDServiceOrdinal(_CONFIGMG_Get_Hardware_Profile_Info);
            pcm->cmApi.pCMAPIStack     = (DWORD)(((LPBYTE)pcm) + sizeof(pcm->cmApi));

            pcm->ulIndex = ulIndex;
            pcm->pHWProfileInfo = (PHWPROFILEINFO)(pcm+1);
            pcm->ulFlags = ulFlags;

            // Do the job!
            // BroadcastSystemMessage(0, &dwRecipients, WM_DEVICECHANGE, 0x22, (LPARAM)pcm);

            // Return values
            crRetVal = (CONFIGRET)pcm->cmApi.dwCMAPIRet;
            *pHWProfileInfo     = *(pcm->pHWProfileInfo);

            HeapFree(hHeap, 0, pcm);
            }

        HeapDestroy(hHeap);
        }

    return crRetVal;
    }
#endif

/*----------------------------------------------------------
Purpose: Return TRUE if the machine is docked

Returns: See above.
Cond:    --
*/
BOOL PRIVATE IsMachineDocked(void)
    {
#ifdef WINNT
#ifndef HANDLEDOCKING   // On NT we don't know how to determine this yet.
    return TRUE;
#endif
#else
    HWPROFILEINFO hwprofileinfo;
    BOOL bDocked;

    if (CR_SUCCESS == CM_Get_Hardware_Profile_Info((ULONG)-1, &hwprofileinfo, 0))
        {
        bDocked = IsFlagSet(hwprofileinfo.HWPI_dwFlags, CM_HWPI_DOCKED);
        }
    else
        {
        // Error
        bDocked = FALSE;
        }

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Machine is %s"), bDocked ? (LPTSTR)TEXT("docked") : (LPTSTR)TEXT("not docked")); )

    return bDocked;
#endif
    }


//---------------------------------------------------------------------------
// IBriefcaseStg member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IBriefcaseStg::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefStg_Release(
    LPBRIEFCASESTG pstg)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);

    DBG_ENTER(TEXT("BriefStg_Release"));

    if (--this->cRef)
        {
        DBG_EXIT_UL(TEXT("BriefStg_Release"), this->cRef);
        return this->cRef;      // Return decremented reference count
        }

    if (this->pcbs)
        {
        // Release this briefcase storage instance
        CloseBriefcaseStorage(this->szFolder);
        }

    if (this->hbrfcaseiter)
        {
        Sync_FindClose(this->hbrfcaseiter);
        }

    GFree(this);

    ENTEREXCLUSIVE()
        {
        DecBriefSemaphore();
        if (IsLastBriefSemaphore())
            {
            CommitIniFile();

            DEBUG_CODE( DumpTables(); )

            TermCacheTables();
            }
        }
    LEAVEEXCLUSIVE()

    DBG_EXIT_UL(TEXT("BriefStg_Release"), 0);

    return 0;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefStg_AddRef(
    LPBRIEFCASESTG pstg)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    UINT cRef;

    DBG_ENTER(TEXT("BriefStg_AddRef"));

    cRef = ++this->cRef;

    DBG_EXIT_UL(TEXT("BriefStg_AddRef"), cRef);

    return cRef;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefStg_QueryInterface(
    LPBRIEFCASESTG pstg,
    REFIID riid,
    LPVOID * ppvOut)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;

    DBG_ENTER_RIID(TEXT("BriefStg_QueryInterface"), riid);

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IBriefcaseStg) ||
        IsEqualIID(riid, &IID_IBriefcaseStg2) 
	)
        {
        // We use the bs field as our IUnknown as well
        *ppvOut = &this->bs;
        this->cRef++;
        hres = NOERROR;
        }
    else
        {
        *ppvOut = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
        }

    DBG_EXIT_HRES(TEXT("BriefStg_QueryInterface"), hres);
    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::Initialize

         Called to initialize a briefcase storage instance.
         The pszFolder indicates the folder we are binding to,
         which is in the briefcase storage (somewhere).

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefStg_Initialize(
    LPBRIEFCASESTG pstg,
    LPCTSTR pszPath,
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = ResultFromScode(E_FAIL);

    DBG_ENTER_SZ(TEXT("BriefStg_Initialize"), pszPath);

    ASSERT(pszPath);

    // Only initialize once per interface instance
    //
    if (pszPath && NULL == this->pcbs)
        {
        BOOL bCancel = FALSE;

        RETRY_BEGIN(FALSE)
            {
            // Unavailable disk?
            if (!PathExists(pszPath))
                {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_OPEN_UNAVAIL_VOL),
                    MAKEINTRESOURCE(IDS_CAP_OPEN), NULL,GUID_NULL,NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                if (IDRETRY == id)
                    RETRY_SET();    // Try again
                else
                    bCancel = TRUE;
                }
            }
        RETRY_END()

        if (!bCancel)
            {
            BrfPathCanonicalize(pszPath, this->szFolder);

            if (PathExists(this->szFolder) && !PathIsDirectory(this->szFolder))
                {
                // (Store this as a path to a folder)
                PathRemoveFileSpec(this->szFolder);
                }

            // Open the briefcase storage for this folder
            //
            hres = OpenBriefcaseStorage(this->szFolder, &this->pcbs, hwndOwner);

            if (SUCCEEDED(hres))
                {
                // Is this folder a sync folder?
                if (HasFolderSyncCopy(this->pcbs->hbrf, this->szFolder))
                    {
                    // Yes
                    SetFlag(this->dwFlags, BSTG_SYNCFOLDER);
                    }
                else
                    {
                    // No (or error, in which case we default to no)
                    ClearFlag(this->dwFlags, BSTG_SYNCFOLDER);
                    }
                }

            // Run the wizard?
            if (SUCCEEDED(hres) && IsFlagSet(this->pcbs->uFlags, CBSF_RUNWIZARD))
                {
                // Yes
                RunDLLThread(hwndOwner, TEXT("SYNCUI.DLL,Briefcase_Intro"), SW_SHOW);
                ClearFlag(this->pcbs->uFlags, CBSF_RUNWIZARD);
                }
            }
        }

    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_Initialize"), hres);
    return hres;
    }


/*----------------------------------------------------------
Purpose: Add an object or objects to the briefcase storage.
         This function does the real work for BriefStg_AddObject.

Returns: standard result
         NOERROR if the object(s) were added
         S_FALSE if the object(s) should be handled by the caller

Cond:    --
*/
HRESULT PRIVATE BriefStg_AddObjectPrivate(
    LPBRIEFCASESTG pstg,
    LPDATAOBJECT pdtobj,
    LPCTSTR pszFolderEx,         // optional (may be NULL)
    UINT uFlags,                // One of AOF_*
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    LPTSTR pszList;
    LPTSTR psz;
    UINT i;
    UINT cFiles;
    TCHAR szCanon[MAX_PATH];
    HDPA hdpa;
    LPCTSTR pszTarget;
    BOOL bMultiFiles;
#pragma data_seg(DATASEG_READONLY)
    static SETbl const c_rgseAdd[] = {
            { E_OUTOFMEMORY,        IDS_OOM_ADD,    MB_ERROR },
            { E_TR_OUT_OF_MEMORY,   IDS_OOM_ADD,    MB_ERROR },
            };
#pragma data_seg()

    ASSERT(pdtobj);

    // Verify that the folder of this briefcase storage is actually inside
    // a briefcase.  (szCanon is used as a dummy here.)
    ASSERT( !PathExists(this->szFolder) || PL_FALSE != PathGetLocality(this->szFolder, szCanon) );

    // Get list of files to add
    hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
    if (SUCCEEDED(hres))
        {
        // Grab the mutex to delay any further calculation in any
        // Briefcase views' secondary threads until we're done
        // processing here.
        Delay_Own();

        // Does the caller want to create sync copies of objects that are
        // already in the briefcase to some other folder?  (Sneakernet)
        if (NULL != pszFolderEx)
            {
            // Yes
            pszTarget = pszFolderEx;
            }
        else
            {
            // No
            pszTarget = this->szFolder;

            // Are the entities already in this briefcase?
            //
            // Based on the success return value of DataObj_QueryFileList,
            // we can tell if the entities are already within a briefcase.
            // Because of the nature of the shell, we assume the file
            // list contains entities which all exist in the same folder,
            // so we consider it an "all or nothing" sort of indicator.
            // If the entities are indeed in a briefcase, we compare the
            // roots of the source and destination briefcases, and BLOCK
            // the addition if they are the same.
            //
            if (S_OK == hres)
                {
                // They are in *a* briefcase.  Which one?
                DataObj_QueryBriefPath(pdtobj, szCanon);
                if (IsSzEqual(szCanon, Atom_GetName(this->pcbs->atomBrf)))
                    {
                    // This same one!  Don't do anything.
                    hres = ResultFromScode(E_FAIL);
                    goto Error1;
                    }
                }
            }

        bMultiFiles = (1 < cFiles);

        // Create the temporary DPA list
        if (NULL == (hdpa = DPA_Create(cFiles)))
            {
            hres = ResultFromScode(E_OUTOFMEMORY);
            }
        else
            {
            UINT uConfirmFlags = 0;

            // Add all the objects to the briefcase storage
            for (i = 0, psz = pszList; i < cFiles; i++)
                {
                // Get file/folder name that was dropped
                BrfPathCanonicalize(psz, szCanon);

                if (PathIsDirectory(szCanon))
                    {
                    hres = CreateTwinOfFolder(this->pcbs, szCanon, pszTarget,
                                              hdpa, uFlags, &uConfirmFlags,
                                              hwndOwner, bMultiFiles);
                    }
                else
                    {
                    hres = CreateTwinOfFile(this->pcbs, szCanon, pszTarget,
                                            hdpa, uFlags, &uConfirmFlags,
                                            hwndOwner, bMultiFiles);
                    }

                if (FAILED(hres))
                    {
                    // An error occurred while attempting to add a twin
                    break;
                    }

                DataObj_NextFile(psz);      // Set psz to next file in list
                }

            if (FAILED(hres))
                {
                // Delete the twins that were added.
                DeleteNewTwins(this->pcbs, hdpa);
                }
            else
                {
                // Update these new twins
                hres = UpdateNewTwins(this->pcbs, this->szFolder, pszTarget, (NULL == pszFolderEx), hdpa, hwndOwner);
                }

            ReleaseNewTwins(hdpa);
            DPA_Destroy(hdpa);
            }
Error1:
        DataObj_FreeList(pszList);

        Delay_Release();
        }

    if (FAILED(hres))
        {
        SEMsgBox(hwndOwner, IDS_CAP_ADD, hres, c_rgseAdd, ARRAYSIZE(c_rgseAdd));
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::AddObject

         Add an object to the briefcase storage.

Returns: standard hresult
Cond:    --
*/
STDMETHODIMP BriefStg_AddObject(
    LPBRIEFCASESTG pstg,
    LPDATAOBJECT pdtobj,
    LPCTSTR pszFolderEx,        // optional
    UINT uFlags,
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = NOERROR;
    LPCTSTR pszFolder;
    UINT ids;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    DBG_ENTER_DTOBJ(TEXT("BriefStg_AddObject"), pdtobj, szDbg);

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    // Is this sneakernet?
    // Is this folder a sync folder?
    if (pszFolderEx)
        {
        // Yes; is the source a sync folder already?
        if (HasFolderSyncCopy(this->pcbs->hbrf, pszFolderEx))
            {
            // Yes; don't allow other sync copies into (or out of) it
            ids = IDS_ERR_ADD_SYNCFOLDER;
            pszFolder = PathFindFileName(pszFolderEx);
            hres = E_FAIL;
            }
        // Is the source folder a sync folder already?
        else if (IsFlagSet(this->dwFlags, BSTG_SYNCFOLDER))
            {
            // Yes; don't allow other sync copies into (or out of) it
            ids = IDS_ERR_ADD_SYNCFOLDER_SRC;
            pszFolder = PathFindFileName(this->szFolder);
            hres = E_FAIL;
            }
        }
    else if (IsFlagSet(this->dwFlags, BSTG_SYNCFOLDER))
        {
        // Yes; don't allow other sync copies into (or out of) it
        ids = IDS_ERR_ADD_SYNCFOLDER;
        pszFolder = PathFindFileName(this->szFolder);
        hres = E_FAIL;
        }

    if (SUCCEEDED(hres))
        {
        hres = BriefStg_AddObjectPrivate(pstg, pdtobj, pszFolderEx, uFlags, hwndOwner);
        }
    else
        {
        MsgBox(hwndOwner,
                MAKEINTRESOURCE(ids),
                MAKEINTRESOURCE(IDS_CAP_ADD),
                NULL,GUID_NULL,NULL,
                MB_WARNING,
                pszFolder);
        }

    DEBUG_CODE( DumpTables(); )
    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_AddObject"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Removes an object or objects from the briefcase storage.

Returns: standard hresult
Cond:    --
*/
HRESULT PRIVATE ReleaseObject(
    CBS * pcbs,
    LPDATAOBJECT pdtobj,
    HWND hwndOwner)
    {
    HRESULT hres;
    LPTSTR pszList;
    UINT cFiles;

    ASSERT(pdtobj);

    hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
    if (SUCCEEDED(hres))
        {
        RETRY_BEGIN(FALSE)
            {
            hres = Sync_Split(pcbs->hbrf, pszList, cFiles, hwndOwner, 0);

            // Unavailable disk?
            if (E_TR_UNAVAILABLE_VOLUME == hres)
                {
                // Yes; ask user to retry/cancel
                int id = MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_ERR_UNAVAIL_VOL),
                    MAKEINTRESOURCE(IDS_CAP_Split),NULL,GUID_NULL,NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                if (IDRETRY == id)
                    RETRY_SET();    // Try again
                }
            }
        RETRY_END()

        DataObj_FreeList(pszList);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::ReleaseObject

         Release an object from the briefcase storage.

Returns: standard hresult
Cond:    --
*/
STDMETHODIMP BriefStg_ReleaseObject(
    LPBRIEFCASESTG pstg,
    LPDATAOBJECT pdtobj,
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    DBG_ENTER_DTOBJ(TEXT("BriefStg_ReleaseObject"), pdtobj, szDbg);

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    hres = ReleaseObject(this->pcbs, pdtobj, hwndOwner);

    DEBUG_CODE( DumpTables(); )
    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_ReleaseObject"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::UpdateObject

         Update an object in the briefcase storage.

Returns: standard hresult
Cond:    --
*/
STDMETHODIMP BriefStg_UpdateObject(
    LPBRIEFCASESTG pstg,
    LPDATAOBJECT pdtobj,
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TCHAR szPath[MAX_PATH];
    DEBUG_CODE( TCHAR szDbg[MAX_PATH]; )

    DBG_ENTER_DTOBJ(TEXT("BriefStg_UpdateObject"), pdtobj, szDbg);

    ASSERT(pdtobj);
    ASSERT(this->pcbs);

    // Determine whether this is an Update Selection or Update All.
    hres = DataObj_QueryPath(pdtobj, szPath);
    if (SUCCEEDED(hres))
        {
        // Is this a briefcase root?
        if (PathIsBriefcase(szPath))
            {
            // Yes; do an Update All
            hres = Upd_DoModal(hwndOwner, this->pcbs, NULL, 0, UF_ALL);
            }
        else
            {
            // No; do an Update Selection
            LPTSTR pszList;
            UINT cFiles;
            hres = DataObj_QueryFileList(pdtobj, &pszList, &cFiles);
            if (SUCCEEDED(hres))
                {
                hres = Upd_DoModal(hwndOwner, this->pcbs, pszList, cFiles, UF_SELECTION);
                DataObj_FreeList(pszList);
                }
            }
        }

    DEBUG_CODE( DumpTables(); )
    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_UpdateObject"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Update a briefcase based on events

Returns: standard hresult
Cond:    --
*/
HRESULT PRIVATE BriefStg_UpdateOnEvent(
    LPBRIEFCASESTG pstg,
    UINT uEvent,
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = NOERROR;

    DBG_ENTER(TEXT("BriefStg_UpdateOnEvent"));

    switch (uEvent)
        {
    case UOE_CONFIGCHANGED:
    case UOE_QUERYCHANGECONFIG:
        // Is the machine docked?
        if (IsMachineDocked())
            {
            // Yes; does the user want to update?
            TCHAR sz[MAX_PATH];
            int ids = (UOE_CONFIGCHANGED == uEvent) ? IDS_MSG_UpdateOnDock : IDS_MSG_UpdateBeforeUndock;
            LPCTSTR pszBrf = Atom_GetName(this->pcbs->atomBrf);
            int id = MsgBox(hwndOwner,
                                MAKEINTRESOURCE(ids),
                                MAKEINTRESOURCE(IDS_CAP_UPDATE),
				NULL,GUID_NULL,
                                LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_UPDATE_DOCK)),
                                MB_QUESTION,
                                PathGetDisplayName(pszBrf, sz));

            if (IDYES == id)
                {
                // Yes; do an Update All
                hres = Upd_DoModal(hwndOwner, this->pcbs, NULL, 0, UF_ALL);
                }
            }
        break;

    default:
        hres = ResultFromScode(E_INVALIDARG);
        break;
        }

    DEBUG_CODE( DumpTables(); )
    hres = MapToOfficialHresult(hres);
    DBG_EXIT_HRES(TEXT("BriefStg_UpdateOnEvent"), hres);

    return hres;
    }

/*----------------------------------------------------------
Purpose: IBriefcaseStg::Notify

         Marks the path dirty in the briefcase storage cache.
         (The path may not exist in the cache, in which case this
         function does nothing.)

Returns: S_OK to force a refresh
         S_FALSE to not force a refresh

Cond:    --
*/
STDMETHODIMP BriefStg_Notify(
    LPBRIEFCASESTG pstg,
    LPCTSTR pszPath,         // may be NULL
    LONG lEvent,            // one of NOE_ flags
    UINT * puFlags,         // returned NF_ flags
    HWND hwndOwner)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres = ResultFromScode(E_OUTOFMEMORY);
    TCHAR szCanon[MAX_PATH];
    int atom;

    DBG_ENTER_SZ(TEXT("BriefStg_Notify"), pszPath);

    ASSERT(this->pcbs);
    ASSERT(puFlags);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Received event %lx for %s"), lEvent, Dbg_SafeStr(pszPath)); )

    *puFlags = 0;

    // Dirty the entire cache?
    if (NOE_DIRTYALL == lEvent)
        {
        // Yes
        TRACE_MSG(TF_GENERAL, TEXT("Marking everything"));

        CRL_DirtyAll(this->pcbs->atomBrf);
        Sync_ClearBriefcaseCache(this->pcbs->hbrf);
        hres = NOERROR;
        }
    else if (pszPath && 0 < lEvent)
        {
        // No
        BrfPathCanonicalize(pszPath, szCanon);
        atom = Atom_Add(szCanon);
        if (ATOM_ERR != atom)
            {
            int atomCab = Atom_Add(this->szFolder);
            if (ATOM_ERR != atomCab)
                {
                // There are two actions we must determine: what gets marked dirty?
                // and does this specific window get forcibly refreshed?
                BOOL bRefresh;
                BOOL bMarked;

                bMarked = CRL_Dirty(atom, atomCab, lEvent, &bRefresh);
                hres = NOERROR;

                if (bMarked)
                    {
                    SetFlag(*puFlags, NF_ITEMMARKED);
                    }
                if (bRefresh)
                    {
#if 0
                    SetFlag(*puFlags, NF_REDRAWWINDOW);
#endif
                    }

#ifdef DEBUG
                if (bMarked && bRefresh)
                    {
                    TRACE_MSG(TF_GENERAL, TEXT("Marked and forcing refresh of window on %s"), (LPTSTR)this->szFolder);
                    }
                else if (bMarked)
                    {
                    TRACE_MSG(TF_GENERAL, TEXT("Marked"));
                    }
#endif

                Atom_Delete(atomCab);
                }
            Atom_Delete(atom);
            }
        }

    DBG_EXIT_HRES(TEXT("BriefStg_Notify"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Gets special info (status and origin) of a path.
Returns: --
Cond:    --
*/
HRESULT PRIVATE BriefStg_GetSpecialInfoOf(
    PBRIEFSTG this,
    LPCTSTR pszName,
    UINT uFlag,
    LPTSTR pszBuf,
    int cchBuf)
    {
    HRESULT hres = E_OUTOFMEMORY;
    TCHAR szPath[MAX_PATH];
    TCHAR szCanon[MAX_PATH];
    int atom;

    ASSERT(this);
    ASSERT(pszName);
    ASSERT(pszBuf);
    ASSERT(this->pcbs);

    *pszBuf = TEXT('\0');

    // Would the path be too long if combined?
    if (PathsTooLong(this->szFolder, pszName))
        {
        // Yes
        hres = E_FAIL;
        }
    else
        {
        PathCombine(szPath, this->szFolder, pszName);
        BrfPathCanonicalize(szPath, szCanon);
        atom = Atom_Add(szCanon);
        if (ATOM_ERR != atom)
            {
            CRL * pcrl;

            // The first CRL_Get call will get the reclist from the cache
            // or get a fresh reclist if the dirty bit is set.  If the cache
            // item doesn't exist, add it.  We add orphans to the cache too
            // but they have no reclist.

            // Does the cached item already exist?
            hres = CRL_Get(atom, &pcrl);
            if (FAILED(hres))
                {
                // No; add it
                hres = CRL_Add(this->pcbs, atom);
                if (SUCCEEDED(hres))
                    {
                    // Do another 'get' to offset the CRL_Delete at the end of
                    // this function.  This will leave this new reclist in the
                    // cache upon exit.  (We don't want to create a new reclist
                    // everytime this functin is called.)  It will all get
                    // cleaned up when the CBS is freed.
                    //
                    hres = CRL_Get(atom, &pcrl);
                    }
                }

            ASSERT(FAILED(hres) || pcrl);

            // Do we have a cache reclist entry to work with?
            if (pcrl)
                {
                // Yes
                if (GEI_ORIGIN == uFlag)
                    {
                    lstrcpyn(pszBuf, Atom_GetName(pcrl->atomOutside), cchBuf);
                    PathRemoveFileSpec(pszBuf);
                    }
                else
                    {
                    ASSERT(GEI_STATUS == uFlag);
                    SzFromIDS(pcrl->idsStatus, pszBuf, cchBuf);
                    }

                CRL_Delete(atom);   // Decrement count
                }
            Atom_Delete(atom);
            }
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::GetExtraInfo

Returns: standard hresult
Cond:    --
*/
STDMETHODIMP BriefStg_GetExtraInfo(
    LPBRIEFCASESTG pstg,
    LPCTSTR pszName,
    UINT uInfo,
    WPARAM wParam,
    LPARAM lParam)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;

    DBG_ENTER_SZ(TEXT("BriefStg_GetExtraInfo"), pszName);

    ASSERT(this->pcbs);

    switch (uInfo)
        {
    case GEI_ORIGIN:
    case GEI_STATUS: {
        LPTSTR pszBuf = (LPTSTR)lParam;
        int cchBuf = wParam;

        ASSERT(pszName);
        ASSERT(pszBuf);

        hres = BriefStg_GetSpecialInfoOf(this, pszName, uInfo, pszBuf, cchBuf);
        }
        break;

    case GEI_DELAYHANDLE: {
        HANDLE * phMutex = (HANDLE *)lParam;

        ASSERT(phMutex);

        *phMutex = g_hMutexDelay;
        hres = NOERROR;
        }
        break;

    case GEI_ROOT: {
        LPTSTR pszBuf = (LPTSTR)lParam;
        int cchBuf = wParam;

        ASSERT(pszBuf);

        lstrcpyn(pszBuf, Atom_GetName(this->pcbs->atomBrf), cchBuf);

#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_PATHS))
            {
            TRACE_MSG(TF_ALWAYS, TEXT("Root is \"%s\""), pszBuf);
            }

#endif
        hres = NOERROR;
        }
        break;

    case GEI_DATABASENAME: {
        LPTSTR pszBuf = (LPTSTR)lParam;
        int cchBuf = wParam;
        LPCTSTR pszDBName;

        ASSERT(pszBuf);

        if (IsFlagSet(this->pcbs->uFlags, CBSF_LFNDRIVE))
            pszDBName = g_szDBName;
        else
            pszDBName = g_szDBNameShort;

        lstrcpyn(pszBuf, pszDBName, cchBuf);

        hres = NOERROR;
        }
        break;

    default:
        hres = E_INVALIDARG;
        break;
        }

    DBG_EXIT_HRES(TEXT("BriefStg_GetExtraInfo"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::FindFirst

         Returns the location of the root of the first briefcase storage
         in the system.

Returns: S_OK if a briefcase was found
         S_FALSE to end enumeration
Cond:    --
*/
STDMETHODIMP BriefStg_FindFirst(
    LPBRIEFCASESTG pstg,
    LPTSTR pszName,
    int cchMaxName)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TWINRESULT tr;
    BRFCASEINFO bcinfo;

    DBG_ENTER(TEXT("BriefStg_FindFirst"));

    ASSERT(pszName);

    bcinfo.ulSize = sizeof(bcinfo);
    tr = Sync_FindFirst(&this->hbrfcaseiter, &bcinfo);
    switch (tr)
        {
    case TR_OUT_OF_MEMORY:
        hres = ResultFromScode(E_OUTOFMEMORY);
        break;

    case TR_SUCCESS:
        hres = ResultFromScode(S_OK);
        lstrcpyn(pszName, bcinfo.rgchDatabasePath, cchMaxName);
        break;

    case TR_NO_MORE:
        hres = ResultFromScode(S_FALSE);
        break;

    default:
        hres = ResultFromScode(E_FAIL);
        break;
        }

    DBG_EXIT_HRES(TEXT("BriefStg_FindFirst"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: IBriefcaseStg::FindNext

         Returns the location of the root of the next briefcase storage
         in the system.

Returns: S_OK if a briefcase was found
         S_FALSE to end enumeration
Cond:    --
*/
STDMETHODIMP BriefStg_FindNext(
    LPBRIEFCASESTG pstg,
    LPTSTR pszName,
    int cchMaxName)
    {
    PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
    HRESULT hres;
    TWINRESULT tr;
    BRFCASEINFO bcinfo;

    DBG_ENTER(TEXT("BriefStg_FindNext"));

    ASSERT(pszName);

    bcinfo.ulSize = sizeof(bcinfo);
    tr = Sync_FindNext(this->hbrfcaseiter, &bcinfo);
    switch (tr)
        {
    case TR_OUT_OF_MEMORY:
        hres = ResultFromScode(E_OUTOFMEMORY);
        break;

    case TR_SUCCESS:
        hres = ResultFromScode(S_OK);
        lstrcpyn(pszName, bcinfo.rgchDatabasePath, cchMaxName);
        break;

    case TR_NO_MORE:
        hres = ResultFromScode(S_FALSE);
        break;

    default:
        hres = ResultFromScode(E_FAIL);
        break;
        }

    DBG_EXIT_HRES(TEXT("BriefStg_FindNext"), hres);

    return hres;
    }



STDMETHODIMP BriefStg__PrepForSync(LPBRIEFCASESTG pstg,
	HWND hwndOwner,LPSYNCMGRSYNCHRONIZECALLBACK pCallback,SYNCMGRITEMID ItemID) 
{
PBRIEFSTG this = IToClass(BriefStg, bs, pstg);
HRESULT hres;


	hres =  Upd_PrepForSync(hwndOwner,this->pcbs,NULL,0,UF_ALL,
		    &this->updcount,&this->prl,&this->uVal,pCallback,ItemID);

	// check the updcount and if that is zero change hres to false

	if (NOERROR != hres
		|| this->updcount.cDoSomething == 0)
	{
	    Sync_DestroyRecList(this->prl);
	    hres = S_FALSE;
	}

	return hres;
}


// perform actual sync

STDMETHODIMP BriefStg__Synchronize(LPBRIEFCASESTG pstg,HWND hwndOwner
			,LPSYNCMGRSYNCHRONIZECALLBACK pCallback,SYNCMGRITEMID ItemID)
{
HRESULT hres;
PBRIEFSTG this = IToClass(BriefStg, bs, pstg);


	hres = Upd_Synchronize(hwndOwner,this->pcbs,UF_ALL,this->uVal,this->prl,pCallback,ItemID);

	if (FAILED(hres) && hres != E_ABORT) // display message box whenever an error occurs.
		this->uVal |= PSC_POSTMSGBOX;


	// review, how should we show errors.
	// Upd_ShowError(hwndOwner,this->uVal,this->updcount,NULL); 

	Sync_DestroyRecList(this->prl); // destroy reclist allocated in PrepForSync


	return hres;
}



STDMETHODIMP BriefStg__ShowError(LPBRIEFCASESTG pstg,HWND hwndOwner,DWORD dwErrorID)
{
PBRIEFSTG this = IToClass(BriefStg, bs, pstg);


	return NOERROR;
}

//---------------------------------------------------------------------------
// BriefStg class : Vtables
//---------------------------------------------------------------------------

#pragma data_seg(DATASEG_READONLY)

IBriefcaseStgVtbl c_BriefStg_BSVtbl =
    {
    BriefStg_QueryInterface,
    BriefStg_AddRef,
    BriefStg_Release,
    BriefStg_Initialize,
    BriefStg_AddObject,
    BriefStg_ReleaseObject,
    BriefStg_UpdateObject,
    BriefStg_UpdateOnEvent,
    BriefStg_GetExtraInfo,
    BriefStg_Notify,
    BriefStg_FindFirst,
    BriefStg_FindNext,
    BriefStg__PrepForSync,
    BriefStg__Synchronize,
    BriefStg__ShowError
    };

#pragma data_seg()


/*----------------------------------------------------------
Purpose: This function is called back from within
         IClassFactory::CreateInstance() of the default class
         factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
*/
HRESULT CALLBACK BriefStg_CreateInstance(
    LPUNKNOWN punkOuter,        // Should be NULL for us
    REFIID riid,
    LPVOID * ppvOut)
    {
    HRESULT hres = E_FAIL;
    PBRIEFSTG this;

    DBG_ENTER_RIID(TEXT("BriefStg_CreateInstance"), riid);

    // Briefcase storage does not support aggregation.
    //
    if (punkOuter)
        {
        hres = CLASS_E_NOAGGREGATION;
        *ppvOut = NULL;
        goto Leave;
        }

    this = GAlloc(sizeof(*this));
    if (!this)
        {
        hres = E_OUTOFMEMORY;
        *ppvOut = NULL;
        goto Leave;
        }
    this->bs.lpVtbl = &c_BriefStg_BSVtbl;
    this->cRef = 1;
    this->pcbs = NULL;
    this->dwFlags = 0;

    // Load the engine if it hasn't already been loaded
    // (this only returns FALSE if something went wrong)
    if (Sync_QueryVTable())
        {
        ENTEREXCLUSIVE()
            {
            // The decrement is in BriefStg_Release()
            IncBriefSemaphore();
            if (IsFirstBriefSemaphore())
                {
                ProcessIniFile();   // Load settings first

                // Initialize cache
                if (InitCacheTables())
                    hres = NOERROR;
                else
                    hres = E_OUTOFMEMORY;
                }
            else
                {
                hres = NOERROR;
                }
            }
        LEAVEEXCLUSIVE()
        }

    if (SUCCEEDED(hres))
        {
        // Note that the Release member will free the object, if
        // QueryInterface failed.
        //
        hres = this->bs.lpVtbl->QueryInterface(&this->bs, riid, ppvOut);
        this->bs.lpVtbl->Release(&this->bs);
        }
    else
        {
        *ppvOut = NULL;
        }

Leave:
    DBG_EXIT_HRES(TEXT("BriefStg_CreateInstance"), hres);

    return hres;        // S_OK or E_NOINTERFACE
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\ibrfext.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: ibrfext.c
//
//  This files contains the IShellExtInit, IShellPropSheetExt and
//  IContextMenu interfaces.
//
// History:
//  02-02-94 ScottH     Moved from iface.c; added new shell interface support
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#include "recact.h"


// Briefcase extension structure.  This is used for IContextMenu
// and PropertySheet binding.
//
typedef struct _BriefExt
    {
    // We use the sxi also as our IUnknown interface
    IShellExtInit       sxi;            // 1st base class
    IContextMenu        ctm;            // 2nd base class
    IShellPropSheetExt  spx;            // 3rd base class
    UINT                cRef;           // reference count
    LPDATAOBJECT        pdtobj;         // data object
    HKEY                hkeyProgID;     // reg. database key to ProgID
    } BriefExt, * PBRIEFEXT;


//---------------------------------------------------------------------------
// IDataObject extraction functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Return TRUE if the IDataObject knows the special
         briefcase file-system object format

Returns: see above
Cond:    --
*/
BOOL PUBLIC DataObj_KnowsBriefObj(
    LPDATAOBJECT pdtobj)
    {
    HRESULT hres;
    FORMATETC fmte = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->QueryGetData(pdtobj, &fmte);
    return (hres == ResultFromScode(S_OK));
    }


/*----------------------------------------------------------
Purpose: Gets the briefcase path from an IDataObject.

Returns: standard
Cond:    --
*/
HRESULT PUBLIC DataObj_QueryBriefPath(
    LPDATAOBJECT pdtobj,
    LPTSTR pszBriefPath)         // Must be size MAX_PATH
    {
    HRESULT hres = ResultFromScode(E_FAIL);
    FORMATETC fmte = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(pszBriefPath);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
    if (SUCCEEDED(hres))
        {
        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);
        LPTSTR psz = BOBriefcasePath(pbo);

        lstrcpy(pszBriefPath, psz);

        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Gets a single path from an IDataObject.

Returns: standard
         S_OK if the object is inside a briefcase
         S_FALSE if not
Cond:    --
*/
HRESULT PUBLIC DataObj_QueryPath(
    LPDATAOBJECT pdtobj,
    LPTSTR pszPath)          // Must be size MAX_PATH
    {
    HRESULT hres = E_FAIL;
    FORMATETC fmteBrief = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteHdrop = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(pszPath);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteBrief, &medium);
    if (SUCCEEDED(hres))
        {
        // Yup

        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);
        LPTSTR psz = BOFileList(pbo);

        // Only get first path in list
        lstrcpy(pszPath, psz);
        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
        hres = S_OK;
        }
    else
        {
        // Or does it support hdrops?
        hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteHdrop, &medium);
        if (SUCCEEDED(hres))
            {
            // Yup
            HDROP hdrop = medium.hGlobal;

            // Only get first path in the file list
            DragQueryFile(hdrop, 0, pszPath, MAX_PATH);

            MyReleaseStgMedium(&medium);
            hres = S_FALSE;
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Gets a file list from an IDataObject.  Allocates
         ppszList to appropriate size and fills it with
         a null-terminated list of paths.  It is double-null
         terminated.

         If ppszList is NULL, then simply get the count of files.

         Call DataObj_FreeList to free the ppszList.

Returns: standard
         S_OK if the objects are inside a briefcase
         S_FALSE if not
Cond:    --
*/
HRESULT PUBLIC DataObj_QueryFileList(
    LPDATAOBJECT pdtobj,
    LPTSTR * ppszList,       // List of files (may be NULL)
    LPUINT puCount)         // Count of files
    {
    HRESULT hres = ResultFromScode(E_FAIL);
    FORMATETC fmteBrief = {g_cfBriefObj, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    FORMATETC fmteHdrop = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    ASSERT(pdtobj);
    ASSERT(puCount);

    // Does this dataobject support briefcase object format?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteBrief, &medium);
    if (SUCCEEDED(hres))
        {
        // Yup
        PBRIEFOBJ pbo = (PBRIEFOBJ)GlobalLock(medium.hGlobal);

        *puCount = BOFileCount(pbo);
        hres = ResultFromScode(S_OK);

        if (ppszList)
            {
            *ppszList = GAlloc(BOFileListSize(pbo));
            if (*ppszList)
                {
                BltByte(*ppszList, BOFileList(pbo), BOFileListSize(pbo));
                }
            else
                {
                hres = ResultFromScode(E_OUTOFMEMORY);
                }
            }

        GlobalUnlock(medium.hGlobal);
        MyReleaseStgMedium(&medium);
        goto Leave;
        }

    // Or does it support hdrops?
    //
    hres = pdtobj->lpVtbl->GetData(pdtobj, &fmteHdrop, &medium);
    if (SUCCEEDED(hres))
        {
        // Yup
        HDROP hdrop = medium.hGlobal;
        UINT cFiles = DragQueryFile(hdrop, (UINT)-1, NULL, 0);
        UINT cchSize = 0;
        UINT i;

        *puCount = cFiles;
        hres = ResultFromScode(S_FALSE);

        if (ppszList)
            {
            // Determine size we need to allocate
            for (i = 0; i < cFiles; i++)
                {
                cchSize += DragQueryFile(hdrop, i, NULL, 0) + 1;
                }
            cchSize++;      // for extra null

            *ppszList = GAlloc(CbFromCch(cchSize));
            if (*ppszList)
                {
                LPTSTR psz = *ppszList;
                UINT cch;

                // Translate the hdrop into our file list format.
                // We know that they really are the same format,
                // but to maintain the abstraction layer, we
                // pretend we don't.
                for (i = 0; i < cFiles; i++)
                    {
                    cch = DragQueryFile(hdrop, i, psz, cchSize) + 1;
                    psz += cch;
                    cchSize -= cch;
                    }
                *psz = TEXT('\0');    // extra null
                }
            else
                {
                hres = ResultFromScode(E_OUTOFMEMORY);
                }
            }
        MyReleaseStgMedium(&medium);
        goto Leave;
        }


Leave:
    return hres;
    }


/*----------------------------------------------------------
Purpose: Frees a file list that was allocated by DataObj_QueryFileList.
Returns: --
Cond:    --
*/
void PUBLIC DataObj_FreeList(
    LPTSTR pszList)
    {
    GFree(pszList);
    }


//---------------------------------------------------------------------------
// BriefExt IUnknown base member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_QueryInterface(
    LPUNKNOWN punk, 
    REFIID riid, 
    LPVOID * ppvOut)
    {
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IUnknown) ||
        IsEqualIID(riid, &IID_IShellExtInit))
        {
        // We use the sxi field as our IUnknown as well
        *ppvOut = &this->sxi;
        this->cRef++;
        hres = NOERROR;
        }
    else if (IsEqualIID(riid, &IID_IContextMenu))
        {
        (LPCONTEXTMENU)*ppvOut = &this->ctm;
        this->cRef++;
        hres = NOERROR;
        }
    else if (IsEqualIID(riid, &IID_IShellPropSheetExt))
        {
        (LPSHELLPROPSHEETEXT)*ppvOut = &this->spx;
        this->cRef++;
        hres = NOERROR;
        }
    else
        {
        *ppvOut = NULL;
        hres = ResultFromScode(E_NOINTERFACE);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: IUnknown::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_AddRef(
    LPUNKNOWN punk)
    {
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);

    return ++this->cRef;
    }


/*----------------------------------------------------------
Purpose: IUnknown::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_Release(
    LPUNKNOWN punk)
    {
    PBRIEFEXT this = IToClass(BriefExt, sxi, punk);

    if (--this->cRef)
        {
        return this->cRef;
        }

    if (this->pdtobj)
        {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
        }

    if (this->hkeyProgID)
        {
        RegCloseKey(this->hkeyProgID);
        }

    GFree(this);
    ENTEREXCLUSIVE()
        {
        DecBusySemaphore();     // Decrement the reference count to the DLL
        }
    LEAVEEXCLUSIVE()

    return 0;
    }


//---------------------------------------------------------------------------
// BriefExt IShellExtInit member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IShellExtInit::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_SXI_QueryInterface(
    LPSHELLEXTINIT psxi,
    REFIID riid, 
    LPVOID * ppvOut)
    {
    return BriefExt_QueryInterface((LPUNKNOWN)psxi, riid, ppvOut);
    }


/*----------------------------------------------------------
Purpose: IShellExtInit::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_SXI_AddRef(
    LPSHELLEXTINIT psxi)
    {
    return BriefExt_AddRef((LPUNKNOWN)psxi);
    }


/*----------------------------------------------------------
Purpose: IShellExtInit::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_SXI_Release(
    LPSHELLEXTINIT psxi)
    {
    return BriefExt_Release((LPUNKNOWN)psxi);
    }


/*----------------------------------------------------------
Purpose: IShellExtInit::Initialize

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_SXI_Initialize(
    LPSHELLEXTINIT psxi,
    LPCITEMIDLIST pidlFolder,
    LPDATAOBJECT pdtobj,
    HKEY hkeyProgID)
    {
    PBRIEFEXT this = IToClass(BriefExt, sxi, psxi);

    // Initialize can be called more than once.
    //
    if (this->pdtobj)
        {
        this->pdtobj->lpVtbl->Release(this->pdtobj);
        }

    if (this->hkeyProgID)
        {
        RegCloseKey(this->hkeyProgID);
        }

    // Duplicate the pdtobj pointer
    if (pdtobj)
        {
        this->pdtobj = pdtobj;
        pdtobj->lpVtbl->AddRef(pdtobj);
        }

    // Duplicate the handle
    if (hkeyProgID)
        {
        RegOpenKeyEx(hkeyProgID, NULL, 0L, MAXIMUM_ALLOWED, &this->hkeyProgID);
        }

    return NOERROR;
    }


//---------------------------------------------------------------------------
// BriefExt IContextMenu member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IContextMenu::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_CM_QueryInterface(
    LPCONTEXTMENU pctm,
    REFIID riid, 
    LPVOID * ppvOut)
    {
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_QueryInterface((LPUNKNOWN)&this->sxi, riid, ppvOut);
    }


/*----------------------------------------------------------
Purpose: IContextMenu::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_CM_AddRef(
    LPCONTEXTMENU pctm)
    {
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_AddRef((LPUNKNOWN)&this->sxi);
    }


/*----------------------------------------------------------
Purpose: IContextMenu::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_CM_Release(
    LPCONTEXTMENU pctm)
    {
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    return BriefExt_Release((LPUNKNOWN)&this->sxi);
    }


/*----------------------------------------------------------
Purpose: IContextMenu::QueryContextMenu

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_CM_QueryContextMenu(
    LPCONTEXTMENU pctm,
    HMENU hmenu,
    UINT indexMenu,
    UINT idCmdFirst,
    UINT idCmdLast,
    UINT uFlags)
    {
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    USHORT cItems = 0;

    // We only want to add items to the context menu if:
    //  1) That's what the caller is asking for; and
    //  2) The object is a briefcase or an object inside
    //     a briefcase
    //
    if (IsFlagClear(uFlags, CMF_DEFAULTONLY))   // check for (1)
        {
        TCHAR szIDS[MAXSHORTLEN];

        // Is the object inside a briefcase?  We know it is if
        // the object understands our special format.
        //
        if (DataObj_KnowsBriefObj(this->pdtobj))
            {
            // Yes
		InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
		    idCmdFirst+cItems, SzFromIDS(IDS_MENU_UPDATE, szIDS, ARRAYSIZE(szIDS)));
		cItems++;

                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems,TEXT("Update This Briefcase"));

		cItems++;
            }
        else
            {
            // No
            TCHAR szPath[MAX_PATH];

            // Is the object a briefcase root?
            if (SUCCEEDED(DataObj_QueryPath(this->pdtobj, szPath)) &&
                PathIsBriefcase(szPath))
                {
                // Yup
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems,TEXT("Update All"));

		cItems++;
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems,TEXT("Update All Briefcases"));

		cItems++;
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems,TEXT("Let Me Choose the Briefcase to Update"));

		cItems++;
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems, TEXT("Update This Briefcase"));

		cItems++;
                InsertMenu(hmenu, indexMenu++, MF_BYPOSITION | MF_STRING,
                    idCmdFirst+cItems, TEXT("Update This Briefcase (Choice)"));

		cItems++;
                }
            }
        }

    return ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, (USHORT)cItems));
    }



/*----------------------------------------------------------
Purpose: IContextMenu::InvokeCommand

Returns: standard
Cond:    --
*/


#include <objbase.h>
#include "syncmgr.h"

DEFINE_GUID(CLSID_OneStopHandler,0x97484ba2, 0x26c7, 0x11d1, 0x9a, 0x39, 0x0, 0x20, 0xaf, 0xda, 0x97, 0xb0);

#include <tchar.h>


STDMETHODIMP BriefExt_CM_InvokeCommand(
    LPCONTEXTMENU pctm,
    LPCMINVOKECOMMANDINFO pici)
    {
    HWND hwnd = pici->hwnd;
        //LPCSTR pszWorkingDir = pici->lpDirectory;
        //LPCSTR pszCmd = pici->lpVerb;
        //LPCSTR pszParam = pici->lpParameters;
        //int iShowCmd = pici->nShow;
    PBRIEFEXT this = IToClass(BriefExt, ctm, pctm);
    HRESULT hres;

    // The only command we have is to update the selection(s).  Create
    // an instance of IBriefcaseStg so we can call its Update
    // member function.
    //

    if (!HIWORD(pici->lpVerb))
    {
    UINT idCmd = LOWORD(pici->lpVerb);
    TCHAR szPath[MAX_PATH];
    LPSYNCMGRSYNCHRONIZEINVOKE pSyncInvoke;
/*
"Update All"
"Update All Briefcases";
"Let Me Choose the Briefcase to Update";
"Update This Briefcase"
*/

	CoInitialize(NULL);

	switch(idCmd) {
	    case 0: /* Update All */

		    hres = CoCreateInstance(&CLSID_SyncMgr,
			NULL,CLSCTX_ALL,&IID_ISyncMgrSynchronizeInvoke,
			(PVOID *) &pSyncInvoke);



		    if (NOERROR == hres)
		    {
			hres = pSyncInvoke->lpVtbl->UpdateAll(pSyncInvoke);
			pSyncInvoke->lpVtbl->Release(pSyncInvoke);
		    }
		break;
	    case 1: // Update All Briefcases
	    case 2: // Let me Choose the Briefcase to Update.
		  hres = CoCreateInstance(&CLSID_SyncMgr,
			NULL,CLSCTX_ALL,&IID_ISyncMgrSynchronizeInvoke,
			(PVOID *) &pSyncInvoke);

		    if (NOERROR == hres)
		    {
			DWORD dwSyncFlag = (1 == idCmd) ? SYNCMGRINVOKE_STARTSYNC : 0;
		    // pass the Path as the cookie data

			hres = pSyncInvoke->lpVtbl->UpdateItems(pSyncInvoke,
			    dwSyncFlag,&CLSID_OneStopHandler,0,NULL);
			
			pSyncInvoke->lpVtbl->Release(pSyncInvoke);
		    }
		break;
	    case 3: /* Update This Briefcase */
		if (SUCCEEDED(DataObj_QueryPath(this->pdtobj, szPath)))
		{

		    hres = CoCreateInstance(&CLSID_SyncMgr,
			NULL,CLSCTX_ALL,&IID_ISyncMgrSynchronizeInvoke,
			(PVOID *) &pSyncInvoke);


		    CoFreeUnusedLibraries();


		    if (NOERROR == hres)
		    {
		    ULONG cbSize;
		    // pass the Path as the cookie data

			cbSize = (_tcslen(szPath) + 1)*sizeof(TCHAR)/sizeof(char); ;

			hres = pSyncInvoke->lpVtbl->UpdateItems(pSyncInvoke,
			    SYNCMGRINVOKE_STARTSYNC,
			    &CLSID_OneStopHandler,cbSize,(BYTE *) szPath);

			
			pSyncInvoke->lpVtbl->Release(pSyncInvoke);
		    }
		    else
		    {
			MessageBox(NULL,TEXT("Failed to create Object"),TEXT("BrfCase"),1);
		    }

		}
	    break;
	    case 4: /* Update This Briefcase (CHOICE DIALG) */
		if (SUCCEEDED(DataObj_QueryPath(this->pdtobj, szPath)))
		{

		    hres = CoCreateInstance(&CLSID_SyncMgr,
			NULL,CLSCTX_ALL,&IID_ISyncMgrSynchronizeInvoke,
			(PVOID *) &pSyncInvoke);


		    CoFreeUnusedLibraries();


		    if (NOERROR == hres)
		    {
		    ULONG cbSize;
		    // pass the Path as the cookie data

			cbSize = (_tcslen(szPath) + 1)*sizeof(TCHAR)/sizeof(char); ;

			hres = pSyncInvoke->lpVtbl->UpdateItems(pSyncInvoke,
			    0,
			    &CLSID_OneStopHandler,cbSize,(BYTE *) szPath);

			
			pSyncInvoke->lpVtbl->Release(pSyncInvoke);
		    }
		    else
		    {
			MessageBox(NULL,TEXT("Failed to create Object"),TEXT("BrfCase"),1);
		    }

		}
	    break;
	default:
	    break;
	}

	CoFreeUnusedLibraries();
	CoUninitialize();
    }





#ifdef _ROGER

    LPBRIEFCASESTG pbrfstg;


    if (SUCCEEDED(BriefStg_CreateInstance(NULL, &IID_IBriefcaseStg, &pbrfstg)))
        {
        TCHAR szPath[MAX_PATH];

        if (SUCCEEDED(DataObj_QueryPath(this->pdtobj, szPath)))
            {

	        MessageBox(NULL,szPath,szPath,1);


            hres = pbrfstg->lpVtbl->Initialize(pbrfstg, szPath, hwnd);
            if (SUCCEEDED(hres))
                {
                hres = pbrfstg->lpVtbl->UpdateObject(pbrfstg, this->pdtobj,
                        hwnd);
                }
            pbrfstg->lpVtbl->Release(pbrfstg);
            }
        }

#endif // _ROGER


    return hres;
}


/*----------------------------------------------------------
Purpose: IContextMenu::GetCommandString

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_CM_GetCommandString(
    LPCONTEXTMENU pctm,
    UINT        idCmd,
    UINT        wReserved,
    UINT  *  pwReserved,
    LPSTR       pszName,
    UINT        cchMax)
    {
    return NOERROR;
    }


//---------------------------------------------------------------------------
// PageData functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Allocates a pagedata.

Returns: TRUE if the allocation/increment was successful

Cond:    --
*/
BOOL PRIVATE PageData_Alloc(
    PPAGEDATA * pppd,
    int atomPath)
    {
    PPAGEDATA this;

    ASSERT(pppd);

    this = GAlloc(sizeof(*this));
    if (this)
        {
        HRESULT hres;
        LPCTSTR pszPath = Atom_GetName(atomPath);
        int  atomBrf;


        // Create an instance of IBriefcaseStg.
        hres = BriefStg_CreateInstance(NULL, &IID_IBriefcaseStg, &this->pbrfstg);
        if (SUCCEEDED(hres))
            {
            hres = this->pbrfstg->lpVtbl->Initialize(this->pbrfstg, pszPath, NULL);
            if (SUCCEEDED(hres))
                {
                TCHAR szBrfPath[MAX_PATH];

                // Request the root path of the briefcase storage
                this->pbrfstg->lpVtbl->GetExtraInfo(this->pbrfstg, NULL, GEI_ROOT,
                    (WPARAM)ARRAYSIZE(szBrfPath), (LPARAM)szBrfPath);

                atomBrf = Atom_Add(szBrfPath);
                hres = (ATOM_ERR != atomBrf) ? NOERROR : E_OUTOFMEMORY;
                }
            }

        if (SUCCEEDED(hres))
            {
            this->pcbs = CBS_Get(atomBrf);
            ASSERT(this->pcbs);

            Atom_AddRef(atomPath);
            this->atomPath = atomPath;

            this->cRef = 1;

            this->bFolder = (FALSE != PathIsDirectory(pszPath));

            Atom_Delete(atomBrf);
            }
        else
            {
            // Failed
            if (this->pbrfstg)
                this->pbrfstg->lpVtbl->Release(this->pbrfstg);

            GFree(this);
            }
        }
    *pppd = this;
    return NULL != this;
    }


/*----------------------------------------------------------
Purpose: Increments the reference count of a pagedata

Returns: Current count
Cond:    --
*/
UINT PRIVATE PageData_AddRef(
    PPAGEDATA this)
    {
    ASSERT(this);

    return ++(this->cRef);
    }


/*----------------------------------------------------------
Purpose: Releases a pagedata struct

Returns: the next reference count
         0 if the struct was freed

Cond:    --
*/
UINT PRIVATE PageData_Release(
    PPAGEDATA this)
    {
    UINT cRef;

    ASSERT(this);
    ASSERT(0 < this->cRef);

    cRef = this->cRef;
    if (0 < this->cRef)
        {
        this->cRef--;
        if (0 == this->cRef)
            {
            if (this->pftl)
                {
                Sync_DestroyFolderList(this->pftl);
                }
            if (this->prl)
                {
                Sync_DestroyRecList(this->prl);
                }

            CBS_Delete(this->pcbs->atomBrf, NULL);

            Atom_Delete(this->atomPath);

            this->pbrfstg->lpVtbl->Release(this->pbrfstg);
            GFree(this);
            return 0;
            }
        }
    return this->cRef;
    }


/*----------------------------------------------------------
Purpose: Sets the data in the pagedata struct to indicate this
         is an orphan.  This function makes no change to the
         database--the caller must do that.

Returns: --
Cond:    --
*/
void PUBLIC PageData_Orphanize(
    PPAGEDATA this)
    {
    this->bOrphan = TRUE;
    if (this->pftl)
        {
        Sync_DestroyFolderList(this->pftl);
        this->pftl = NULL;
        }
    if (this->prl)
        {
        Sync_DestroyRecList(this->prl);
        this->prl = NULL;
        }
    }


/*----------------------------------------------------------
Purpose: Initializes the common page data struct shared between
         the property pages.  Keep in mind that this function may
         be called multiple times, so it must behave properly
         under these conditions (ie, don't blow anything away).

         This function will return S_OK if it is.  S_FALSE means
         the data in question has been invalidated.  This means
         the twin has become an orphan.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC PageData_Init(
    PPAGEDATA this,
    HWND hwndOwner)
    {
    HRESULT hres;
    HBRFCASE hbrf = PageData_GetHbrf(this);
    LPCTSTR pszPath = Atom_GetName(this->atomPath);

    // ** Note: this structure is not serialized because it is
    // assumed that of the pages that are sharing it, only one
    // can access it at a time.

    ASSERT(pszPath);

    // Has this been explicitly marked as an orphan?
    if (FALSE == this->bOrphan)
        {
        // No; is it (still) a twin?
        if (S_OK == Sync_IsTwin(hbrf, pszPath, 0))
            {
            // Yes; has the folder twinlist or reclist been created yet?
            if (NULL == this->prl ||
                (this->bFolder && NULL == this->pftl))
                {
                // No; create it/them
                HTWINLIST htl;
                PFOLDERTWINLIST pftl = NULL;
                PRECLIST prl = NULL;
                HWND hwndProgress;
                TWINRESULT tr;

                ASSERT(NULL == this->prl);
                ASSERT( !this->bFolder || NULL == this->pftl);

                hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING | UB_NOCANCEL, DELAY_UPDBAR,
					NULL,GUID_NULL);

                tr = Sync_CreateTwinList(hbrf, &htl);
                hres = HRESULT_FROM_TR(tr);

                if (SUCCEEDED(hres))
                    {
                    // Add to the twinlist.  Create folder twinlist if
                    // necessary.
                    if (Sync_AddPathToTwinList(hbrf, htl, pszPath, &pftl))
                        {
                        // Does the reclist need creating?
                        if (NULL == this->prl)
                            {
                            // Yes
                            hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), &prl);

                            if (SUCCEEDED(hres))
                                {
                                // The object may have been implicitly
                                // deleted in CreateRecList.  Check again.
                                hres = Sync_IsTwin(hbrf, pszPath, 0);
                                }
                            }
                        }
                    else
                        hres = E_FAIL;

                    // Fill in proper fields
                    if (NULL == this->prl && prl)
                        {
                        this->prl = prl;
                        }
                    if (NULL == this->pftl && pftl)
                        {
                        this->pftl = pftl;
                        }

                    // Clean up twinlist
                    Sync_DestroyTwinList(htl);
                    }

                UpdBar_Kill(hwndProgress);

                // Did the above succeed?
                if (FAILED(hres) || S_FALSE == hres)
                    {
                    // No
                    PageData_Orphanize(this);
                    }
                }
            else
                {
                // Yes; do nothing
                hres = S_OK;
                }
            }
        else
            {
            // No; say the thing is an orphan
            PageData_Orphanize(this);
            hres = S_FALSE;
            }
        }
    else
        {
        // Yes
        hres = S_FALSE;
        }

#ifdef DEBUG
    if (S_OK == hres)
        {
        ASSERT( !this->bFolder || this->pftl );
        ASSERT(this->prl);
        }
    else
        {
        ASSERT(NULL == this->pftl);
        ASSERT(NULL == this->prl);
        }
#endif

    return hres;
    }


/*----------------------------------------------------------
Purpose: Verifies whether the page data shared by the property
         pages is still valid.  This function will return S_OK if
         it is.  S_FALSE means the data in question has been
         invalidated.  This means the twin has become an orphan.

         This function assumes PageData_Init has been previously
         called.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC PageData_Query(
    PPAGEDATA this,
    HWND hwndOwner,
    PRECLIST * pprl,            // May be NULL
    PFOLDERTWINLIST * ppftl)    // May be NULL
    {
    HRESULT hres;
    LPCTSTR pszPath = Atom_GetName(this->atomPath);

    // ** Note: this structure is not serialized because it is
    // assumed that of the pages that are sharing it, only one
    // can access it at a time.

    ASSERT(pszPath);

    // Is a recalc called for?
    if (this->bRecalc)
        {
        // Yes; clear the fields and do again
        PageData_Orphanize(this);       // only temporary
        this->bOrphan = FALSE;          // undo the orphan state
        this->bRecalc = FALSE;

        // Reinit
        hres = PageData_Init(this, hwndOwner);
        if (pprl)
            *pprl = this->prl;
        if (ppftl)
            *ppftl = this->pftl;
        }

    // Are the fields valid?
    else if ( this->prl && (!this->bFolder || this->pftl) )
        {
        // Yes; is it (still) a twin?
        ASSERT(FALSE == this->bOrphan);

        hres = Sync_IsTwin(this->pcbs->hbrf, pszPath, 0);
        if (S_OK == hres)
            {
            // Yes
            if (pprl)
                *pprl = this->prl;
            if (ppftl)
                *ppftl = this->pftl;
            }
        else if (S_FALSE == hres)
            {
            // No; update struct fields
            PageData_Orphanize(this);
            goto OrphanTime;
            }
        }
    else
        {
        // No; say it is an orphan
OrphanTime:
        ASSERT(this->bOrphan);

        if (pprl)
            *pprl = NULL;
        if (ppftl)
            *ppftl = NULL;
        hres = S_FALSE;
        }

    return hres;
    }


//---------------------------------------------------------------------------
// BriefExt IShellPropSheetExt member functions
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::QueryInterface

Returns: standard
Cond:    --
*/
STDMETHODIMP BriefExt_SPX_QueryInterface(
    LPSHELLPROPSHEETEXT pspx,
    REFIID riid, 
    LPVOID * ppvOut)
    {
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_QueryInterface((LPUNKNOWN)&this->sxi, riid, ppvOut);
    }


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddRef

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_SPX_AddRef(
    LPSHELLPROPSHEETEXT pspx)
    {
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_AddRef((LPUNKNOWN)&this->sxi);
    }


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::Release

Returns: new reference count
Cond:    --
*/
STDMETHODIMP_(UINT) BriefExt_SPX_Release(
    LPSHELLPROPSHEETEXT pspx)
    {
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    return BriefExt_Release((LPUNKNOWN)&this->sxi);
    }


/*----------------------------------------------------------
Purpose: Callback when Status property page is done
Returns: --
Cond:    --
*/
UINT CALLBACK StatusPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp)
    {
    if (PSPCB_RELEASE == uMsg)
        {
        PPAGEDATA ppagedata = (PPAGEDATA)ppsp->lParam;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Releasing status page")); )

        PageData_Release(ppagedata);
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Callback when Info property sheet is done
Returns: --
Cond:    --
*/
UINT CALLBACK InfoPageCallback(
    HWND hwnd,
    UINT uMsg,
    LPPROPSHEETPAGE ppsp)
    {
    if (PSPCB_RELEASE == uMsg)
        {
        PPAGEDATA ppagedata = (PPAGEDATA)ppsp->lParam;
        PINFODATA pinfodata = (PINFODATA)ppagedata->lParam;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Releasing info page")); )

        if (pinfodata->hdpaTwins)
            {
            int iItem;
            int cItems = DPA_GetPtrCount(pinfodata->hdpaTwins);
            HTWIN htwin;

            for (iItem = 0; iItem < cItems; iItem++)
                {
                htwin = DPA_FastGetPtr(pinfodata->hdpaTwins, iItem);

                Sync_ReleaseTwin(htwin);
                }
            DPA_Destroy(pinfodata->hdpaTwins);
            }
        GFree(pinfodata);

        PageData_Release(ppagedata);
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Add the status property page
Returns: TRUE on success
         FALSE if out of memory
Cond:    --
*/
BOOL PRIVATE AddStatusPage(
    PPAGEDATA ppd,
    LPFNADDPROPSHEETPAGE pfnAddPage,
    LPARAM lParam)
    {
    BOOL bRet = FALSE;
    HPROPSHEETPAGE hpsp;
    PROPSHEETPAGE psp = {
        sizeof(PROPSHEETPAGE),          // size
        PSP_USECALLBACK,                // PSP_ flags
        g_hinst,                        // hinstance
        MAKEINTRESOURCE(IDD_STATUS),    // pszTemplate
        NULL,                           // icon
        NULL,                           // pszTitle
        Stat_WrapperProc,               // pfnDlgProc
        (LPARAM)ppd,                    // lParam
        StatusPageCallback,             // pfnCallback
        0 };                            // ref count

    ASSERT(ppd);
    ASSERT(pfnAddPage);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding status page")); )

    // Add the status property sheet
    hpsp = CreatePropertySheetPage(&psp);
    if (hpsp)
        {
        bRet = (*pfnAddPage)(hpsp, lParam);
        if (FALSE == bRet)
            {
            // Cleanup on failure
            DestroyPropertySheetPage(hpsp);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Add the info property page.
Returns: TRUE on success
         FALSE if out of memory
Cond:    --
*/
BOOL PRIVATE AddInfoPage(
    PPAGEDATA ppd,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
    {
    BOOL bRet = FALSE;
    HPROPSHEETPAGE hpsp;
    PINFODATA pinfodata;

    ASSERT(lpfnAddPage);

    DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Adding info page")); )

    pinfodata = GAlloc(sizeof(*pinfodata));
    if (pinfodata)
        {
        PROPSHEETPAGE psp = {
            sizeof(PROPSHEETPAGE),          // size
            PSP_USECALLBACK,                // PSP_ flags
            g_hinst,                        // hinstance
            MAKEINTRESOURCE(IDD_INFO),      // pszTemplate
            NULL,                           // icon
            NULL,                           // pszTitle
            Info_WrapperProc,               // pfnDlgProc
            (LPARAM)ppd,                    // lParam
            InfoPageCallback,               // pfnCallback
            0 };                            // ref count

        ppd->lParam = (LPARAM)pinfodata;

        pinfodata->atomTo = ATOM_ERR;       // Not needed for page
        pinfodata->bStandAlone = FALSE;

        if (NULL != (pinfodata->hdpaTwins = DPA_Create(8)))
            {
            hpsp = CreatePropertySheetPage(&psp);
            if (hpsp)
                {
                bRet = (*lpfnAddPage)(hpsp, lParam);
                if (FALSE == bRet)
                    {
                    // Cleanup on failure
                    DestroyPropertySheetPage(hpsp);
                    }
                }
            if (FALSE == bRet)
                {
                // Cleanup on failure
                DPA_Destroy(pinfodata->hdpaTwins);
                }
            }
        if (FALSE == bRet)
            {
            // Cleanup on failure
            GFree(pinfodata);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Does the real work to add the briefcase pages to
         the property sheet.
Returns: --
Cond:    --
*/
void PRIVATE BriefExt_AddPagesPrivate(
    LPSHELLPROPSHEETEXT pspx,
    LPCTSTR pszPath,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
    {
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    HRESULT hres = NOERROR;
    TCHAR szCanonPath[MAX_PATH];
    int atomPath;

    BrfPathCanonicalize(pszPath, szCanonPath);
    atomPath = Atom_Add(szCanonPath);
    if (atomPath != ATOM_ERR)
        {
        PPAGEDATA ppagedata;
        BOOL bVal;

        // Allocate the pagedata
        if (PageData_Alloc(&ppagedata, atomPath))
            {
            // Always add the status page (even for orphans).
            // Add the info page if the object is a folder.
            bVal = AddStatusPage(ppagedata, lpfnAddPage, lParam);
            if (bVal && ppagedata->bFolder)
                {
                PageData_AddRef(ppagedata);
                AddInfoPage(ppagedata, lpfnAddPage, lParam);
                }
            else if (FALSE == bVal)
                {
                // (Cleanup on failure)
                PageData_Release(ppagedata);
                }
            }
        Atom_Delete(atomPath);
        }
    }


/*----------------------------------------------------------
Purpose: IShellPropSheetExt::AddPages

         The shell calls this member function when it is
         time to add pages to a property sheet.

         As the briefcase storage, we only add pages for
         entities inside a briefcase.  Anything outside
         a briefcase is not touched.

         We can quickly determine if the object is inside
         the briefcase by querying the data object that
         we have.  If it knows our special "briefcase object"
         format, then it must be inside a briefcase.  We
         purposely do not add pages for the root folder itself.

Returns: standard hresult
Cond:    --
*/
STDMETHODIMP BriefExt_SPX_AddPages(
    LPSHELLPROPSHEETEXT pspx,
    LPFNADDPROPSHEETPAGE lpfnAddPage,
    LPARAM lParam)
    {
    PBRIEFEXT this = IToClass(BriefExt, spx, pspx);
    LPTSTR pszList;
    UINT cFiles;

    // Questions:
    //  1) Does this know the briefcase object format?
    //  2) Is there only a single object selected?
    //
    if (DataObj_KnowsBriefObj(this->pdtobj) &&      /* (1) */
        SUCCEEDED(DataObj_QueryFileList(this->pdtobj, &pszList, &cFiles)) &&
        cFiles == 1)                                /* (2) */
        {
        // Yes; add the pages
        BriefExt_AddPagesPrivate(pspx, pszList, lpfnAddPage, lParam);

        DataObj_FreeList(pszList);
        }
    return NOERROR;     // Always allow property sheet to appear
    }


//---------------------------------------------------------------------------
// BriefExtMenu class : Vtables
//---------------------------------------------------------------------------


#pragma data_seg(DATASEG_READONLY)

IShellExtInitVtbl c_BriefExt_SXIVtbl =
    {
    BriefExt_SXI_QueryInterface,
    BriefExt_SXI_AddRef,
    BriefExt_SXI_Release,
    BriefExt_SXI_Initialize
    };

IContextMenuVtbl c_BriefExt_CTMVtbl =
    {
    BriefExt_CM_QueryInterface,
    BriefExt_CM_AddRef,
    BriefExt_CM_Release,
    BriefExt_CM_QueryContextMenu,
    BriefExt_CM_InvokeCommand,
    BriefExt_CM_GetCommandString,
    };

IShellPropSheetExtVtbl c_BriefExt_SPXVtbl = {
    BriefExt_SPX_QueryInterface,
    BriefExt_SPX_AddRef,
    BriefExt_SPX_Release,
    BriefExt_SPX_AddPages
    };

#pragma data_seg()


/*----------------------------------------------------------
Purpose: This function is called back from within
         IClassFactory::CreateInstance() of the default class
         factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
*/
HRESULT CALLBACK BriefExt_CreateInstance(
    LPUNKNOWN punkOuter,
    REFIID riid, 
    LPVOID * ppvOut)
    {
    HRESULT hres;
    PBRIEFEXT this;

    DBG_ENTER_RIID(TEXT("BriefExt_CreateInstance"), riid);

    // Shell extentions typically do not support aggregation.
    //
    if (punkOuter)
        {
        hres = ResultFromScode(CLASS_E_NOAGGREGATION);
        *ppvOut = NULL;
        goto Leave;
        }

    this = GAlloc(sizeof(*this));
    if (!this)
        {
        hres = ResultFromScode(E_OUTOFMEMORY);
        *ppvOut = NULL;
        goto Leave;
        }
    this->sxi.lpVtbl = &c_BriefExt_SXIVtbl;
    this->ctm.lpVtbl = &c_BriefExt_CTMVtbl;
    this->spx.lpVtbl = &c_BriefExt_SPXVtbl;
    this->cRef = 1;
    this->pdtobj = NULL;
    this->hkeyProgID = NULL;

    ENTEREXCLUSIVE()
        {
        // The decrement is in BriefExt_Release()
        IncBusySemaphore();
        }
    LEAVEEXCLUSIVE()

    // Note that the Release member will free the object, if QueryInterface
    // failed.
    //
    hres = c_BriefExt_SXIVtbl.QueryInterface(&this->sxi, riid, ppvOut);
    c_BriefExt_SXIVtbl.Release(&this->sxi);

Leave:
    DBG_EXIT_HRES(TEXT("BriefExt_CreateInstance"), hres);

    return hres;        // S_OK or E_NOINTERFACE
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\info.h ===
//
// info.h: Declares data, defines and struct types for twin creation
//          module.
//
//

#ifndef __INFO_H__
#define __INFO_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct
    {
    LPBRIEFCASESTG      pbrfstg;        // IBriefcaseStg instance
    // Params
    //
    CBS  * pcbs;
    int atomPath;
    HDPA   hdpaTwins;    // handle to array of twin handles which will
                         //  be filled by dialog.
                         //  N.b.  Caller must release these twins!
    
    BOOL bStandAlone;    // private: should only be set by Info_DoModal
    } XINFOSTRUCT,  * LPXINFOSTRUCT;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL _export CALLBACK Info_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

int PUBLIC Info_DoModal (HWND hwndParent, LPXINFOSTRUCT lpxinfo);

#endif // __INFO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\init.h ===
//
// init.h: Declares data, defines and struct types for DLL entry point
//          module.
//
//

#ifndef __INIT_H__
#define __INIT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

#define CX_IMG      16
#define CY_IMG      16

// Indexes into our image list
//
#define IMAGE_FOLDER        0       // folder
#define IMAGE_OFOLDER       1       // open folder

#define MyGetTwinResult()           (g_tr)
#define MySetTwinResult(tr)         (g_tr = (tr))

/////////////////////////////////////////////////////  TYPEDEFS


/////////////////////////////////////////////////////  EXPORTED DATA

extern HINSTANCE   g_hinst;
extern TWINRESULT  g_tr;

extern HANDLE      g_hMutexDelay;

extern int g_cxIconSpacing;
extern int g_cyIconSpacing;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxIcon;
extern int g_cyIcon;
extern int g_cxIconMargin;
extern int g_cyIconMargin;
extern int g_cxLabelMargin;
extern int g_cyLabelSpace;
extern int g_cxMargin;

extern COLORREF g_clrHighlightText;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindow;

extern HBRUSH g_hbrHighlight;
extern HBRUSH g_hbrWindow;

extern TCHAR g_szDBName[];
extern TCHAR g_szDBNameShort[];

extern int g_cProcesses;
extern UINT g_cfBriefObj;

extern UINT g_uBreakFlags;       // Controls when to int 3
extern UINT g_uTraceFlags;       // Controls what trace messages are spewed
extern UINT g_uDumpFlags;        // Controls what structs get dumped

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#endif // __INIT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\mem.h ===
#ifndef _INC_MEM
#define _INC_MEM

#ifdef WIN32
//
// These macros are used in our controls, that in 32 bits we simply call
// LocalAlloc as to have the memory associated with the process that created
// it and as such will be cleaned up if the process goes away.
//
#ifdef DEBUG

LPVOID  PUBLIC MemAlloc(HANDLE hheap, DWORD cb);
LPVOID  PUBLIC MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb);
BOOL    PUBLIC MemFree(HANDLE hheap, LPVOID pb);
DWORD   PUBLIC MemSize(HANDLE hheap, LPVOID pb);

#else // DEBUG

#define MemAlloc(hheap, cb)       HeapAlloc((hheap), HEAP_ZERO_MEMORY, (cb))
#define MemReAlloc(hheap, pb, cb) HeapReAlloc((hheap), HEAP_ZERO_MEMORY, (pb),(cb))
#define MemFree(hheap, pb)        HeapFree((hheap), 0, (pb))
#define MemSize(hheap, pb)        HeapSize((hheap), 0, (LPCVOID)(pb))

#endif // DEBUG

#else // WIN32

// In 16 bit code we need the Allocs to go from our heap code as we do not
// want to limit them to 64K of data.  If we have some type of notification of
// 16 bit application termination, We may want to see if we can
// dedicate different heaps for different processes to cleanup...

#define MemAlloc(hheap, cb)       Alloc(cb)  /* calls to verify heap exists */
#define MemReAlloc(hheap, pb, cb) ReAlloc(pb, cb)
#define MemFree(hheap, pb)        Free(pb)
#define MemSize(hheap, pb)        GetSize((LPCVOID)pb)

#endif // WIN32


void PUBLIC Mem_Terminate();

extern HANDLE g_hSharedHeap;

// Shared memory allocation functions.
//
//      void _huge* SharedAlloc(long cb);
//          Alloc a chunk of memory, quickly, with no 64k limit on size of
//          individual objects or total object size.  Initialize to zero.
//
void _huge* PUBLIC SharedAlloc(long cb);                              

//      void _huge* SharedReAlloc(void _huge* pb, long cb);
//          Realloc one of above.  If pb is NULL, then this function will do
//          an alloc for you.  Initializes new portion to zero.
//
void _huge* PUBLIC SharedReAlloc(void _huge* pb, long cb);             

//      BOOL SharedFree(void _huge* FAR * ppb);
//          Free a chunk of memory alloced or realloced with above routines.
//          Sets *ppb to zero.
//
BOOL    PUBLIC SharedFree(void _huge*  * ppb);

//      DWORD SharedGetSize(void _huge* pb);
//          Get the size of a block allocated by Alloc()
//      
DWORD   PUBLIC SharedGetSize(void _huge* pb);                      


//      type _huge * SharedAllocType(type);                    (macro)
//          Alloc some memory the size of <type> and return pointer to <type>.
//
#define SharedAllocType(type)           (type _huge *)SharedAlloc(sizeof(type))

//      type _huge * SharedAllocArray(type, int cNum);         (macro)
//          Alloc an array of data the size of <type>.
//
#define SharedAllocArray(type, cNum)    (type _huge *)SharedAlloc(sizeof(type) * (cNum))

//      type _huge * SharedReAllocArray(type, void _huge * pb, int cNum);
//
#define SharedReAllocArray(type, pb, cNum) (type _huge *)SharedReAlloc(pb, sizeof(type) * (cNum))

#endif  // !_INC_MEM
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\misc.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: misc.c
//
//  This file contains miscellaneous dialog code
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

#include "brfprv.h"     // common headers

#include "res.h"


typedef struct _MB_BUTTONS
    {
    UINT id;        // id
    UINT ids;       // string ID
    } MB_BUTTONS, * PMB_BUTTONS;

typedef struct _BTNSTYLE
    {
    UINT cButtons;
    MB_BUTTONS rgmbb[4];
    } BTNSTYLE;


//---------------------------------------------------------------------------
// Control manipulation stuff
//---------------------------------------------------------------------------


// Flags for SNAPCTL
#define SCF_ANCHOR      0x0001
#define SCF_VCENTER     0x0002
#define SCF_BOTTOM      0x0004
#define SCF_TOP         0x0008
#define SCF_SNAPLEFT    0x0010
#define SCF_SNAPRIGHT   0x0020

typedef struct tagSNAPCTL
    {
    UINT    idc;
    UINT    uFlags;
    } SNAPCTL, * PSNAPCTL;


/*----------------------------------------------------------
Purpose: Moves a control
Returns: HDWP
Cond:    --
*/
HDWP PRIVATE SlideControlPos(
    HDWP hdwp,
    HWND hDlg,
    UINT idc,
    int cx,
    int cy)
    {
    HWND hwndPos = GetDlgItem(hDlg, idc);
    RECT rcPos;

    GetWindowRect(hwndPos, &rcPos);
    ScreenToClient(hDlg, (LPPOINT)&rcPos);
    return DeferWindowPos(hdwp, hwndPos, NULL,
                          rcPos.left + cx, rcPos.top + cy,
                          0, 0,
                          SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
    }


/*----------------------------------------------------------
Purpose: Aligns a list of controls, relative to an "anchor"
         control.

         Only one anchor control is supported; the first control
         designated as anchor in the list is selected.

Returns: --
Cond:    --
*/
void PRIVATE SnapControls(
    HWND hwnd,
    SNAPCTL const * psnap,
    UINT csnap)
    {
    HWND hwndAnchor;
    UINT i;
    SNAPCTL const * psnapStart = psnap;
    HDWP hdwp;
    RECT rcAnchor;
    int yCenter;

    ASSERT(psnap);

    // Find the anchor control
    for (i = 0; i < csnap; i++, psnap++)
        {
        if (IsFlagSet(psnap->uFlags, SCF_ANCHOR))
            {
            hwndAnchor = GetDlgItem(hwnd, psnap->idc);
            break;
            }
        }

    if (i == csnap)
        return;     // No anchor control!

    GetWindowRect(hwndAnchor, &rcAnchor);
    yCenter = rcAnchor.top + (rcAnchor.bottom - rcAnchor.top)/2;

    hdwp = BeginDeferWindowPos(csnap-1);

    if (hdwp)
        {
        RECT rc;
        UINT uFlags;
        HWND hwndPos;

        for (i = 0, psnap = psnapStart; i < csnap; i++, psnap++)
            {
            uFlags = psnap->uFlags;
            if (IsFlagSet(uFlags, SCF_ANCHOR))
                continue;       // skip anchor

            hwndPos = GetDlgItem(hwnd, psnap->idc);
            GetWindowRect(hwndPos, &rc);

            if (IsFlagSet(uFlags, SCF_VCENTER))
                {
                // Vertically match the center of this control with
                // the center of the anchor
                rc.top += yCenter - (rc.top + (rc.bottom - rc.top)/2);
                }
            else if (IsFlagSet(uFlags, SCF_TOP))
                {
                // Vertically match the top of this control with
                // the top of the anchor
                rc.top += rcAnchor.top - rc.top;
                }
            else if (IsFlagSet(uFlags, SCF_BOTTOM))
                {
                // Vertically match the bottom of this control with
                // the bottom of the anchor
                rc.top += rcAnchor.bottom - rc.bottom;
                }

            if (IsFlagSet(uFlags, SCF_SNAPLEFT))
                {
                // Snap the control so it is abut to the left side
                // of the anchor control
                rc.left += rcAnchor.left - rc.right;
                }
            else if (IsFlagSet(uFlags, SCF_SNAPRIGHT))
                {
                // Snap the control so it is abut to the right side
                // of the anchor control
                rc.left += rcAnchor.right - rc.left;
                }

            // Move control
            ScreenToClient(hwnd, (LPPOINT)&rc);
            hdwp = DeferWindowPos(hdwp, hwndPos, NULL,
                                  rc.left, rc.top, 0, 0,
                                  SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOSIZE);
            }
        EndDeferWindowPos(hdwp);
        }
    }


//---------------------------------------------------------------------------
// Abort event stuff
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Creates an abort event.

Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC AbortEvt_Create(
    PABORTEVT * ppabortevt,
    UINT uFlags)
    {
    PABORTEVT this;

    ASSERT(ppabortevt);

    if (IsFlagSet(uFlags, AEF_SHARED))
        this = SharedAllocType(ABORTEVT);
    else
        this = GAllocType(ABORTEVT);

    if (this)
        {
        this->uFlags = uFlags;
        }

    *ppabortevt = this;

    return NULL != this;
    }


/*----------------------------------------------------------
Purpose: Destroys an abort event.

Returns: --
Cond:    --
*/
void PUBLIC AbortEvt_Free(
    PABORTEVT this)
    {
    if (this)
        {
        if (IsFlagSet(this->uFlags, AEF_SHARED))
            SharedFree(&this);
        else
            GFree(this);
        }
    }


/*----------------------------------------------------------
Purpose: Sets the abort event.

Returns: Returns the previous abort event.
Cond:    --
*/
BOOL PUBLIC AbortEvt_Set(
    PABORTEVT this,
    BOOL bAbort)
    {
    BOOL bRet;

    if (this)
        {
        bRet = IsFlagSet(this->uFlags, AEF_ABORT);

        if (bAbort)
            {
            TRACE_MSG(TF_GENERAL, TEXT("Setting abort event"));
            SetFlag(this->uFlags, AEF_ABORT);
            }
        else
            {
            TRACE_MSG(TF_GENERAL, TEXT("Clearing abort event"));
            ClearFlag(this->uFlags, AEF_ABORT);
            }
        }
    else
        bRet = FALSE;

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Queries the abort event

Returns: the current abort event (TRUE or FALSE)
Cond:    --
*/
BOOL PUBLIC AbortEvt_Query(
    PABORTEVT this)
    {
    BOOL bRet;

    if (this)
        {
        bRet = IsFlagSet(this->uFlags, AEF_ABORT);

#ifdef DEBUG
        if (bRet)
            TRACE_MSG(TF_GENERAL, TEXT("Abort is set!"));
#endif
        }
    else
        bRet = FALSE;

    return bRet;
    }


//---------------------------------------------------------------------------
// Progress bar stuff
//---------------------------------------------------------------------------

#define MSECS_PER_SEC   1000

#define WM_QUERYABORT   (WM_APP + 1)


/*----------------------------------------------------------
Purpose: Progress dialog during reconciliations
Returns: varies
Cond:    --
*/
BOOL CALLBACK UpdateProgressProc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
    {
    PUPDBAR this = (PUPDBAR)GetWindowLong(hDlg, DWL_USER);

    switch (wMsg)
        {
    case WM_INITDIALOG:
        SetWindowLong(hDlg, DWL_USER, lParam);
        this = (PUPDBAR)lParam;

        if (IsFlagSet(this->uFlags, UB_NOCANCEL))
            {
            ShowWindow(GetDlgItem(hDlg, IDCANCEL), SW_HIDE);
            EnableWindow(GetDlgItem(hDlg, IDCANCEL), FALSE);
            }
        break;

    case WM_COMMAND:
        switch (wParam)
            {
        case IDCANCEL:
            AbortEvt_Set(this->pabortevt, TRUE);
            break;
            }
        break;

    case WM_QUERYABORT:
        if (GetTickCount() >= this->dwTickShow &&
            0 != this->dwTickShow)
            {
            if (this->hcurSav)
                {
                SetCursor(this->hcurSav);
                this->hcurSav = NULL;
                }

            ShowWindow(hDlg, SW_SHOW);
            UpdateWindow(hDlg);
            this->dwTickShow = 0;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }



/*----------------------------------------------------------
Purpose: Displays the update progress bar dialog

Returns: dialog handle to a modeless dialog
         NULL if dialog couldn't be created

Cond:    Call UpdBar_Kill when finished
*/
HWND PUBLIC UpdBar_Show(
    HWND hwndParent,
    UINT uFlags,        // UB_*
    UINT nSecs,			// Valid only if UB_TIMER set
    LPSYNCMGRSYNCHRONIZECALLBACK pCallback,
    SYNCMGRITEMID ItemID)         
    {
    HWND hdlg = NULL;
    PUPDBAR this;

    // Create and show the progress dialog
    //
    this = GAlloc(sizeof(*this));
    if (this)
        {
        // (It is okay if this fails--it just means we ignore the Cancel button)
        AbortEvt_Create(&this->pabortevt, AEF_DEFAULT);

        this->hwndParent = hwndParent;
	this->pCallback = pCallback;
	this->ItemID = ItemID;

	if (pCallback) {
	    uFlags |= UB_NOSHOW;
	    hwndParent = NULL;
	}

        this->uFlags = uFlags;
        hdlg = CreateDialogParam(g_hinst, MAKEINTRESOURCE(IDD_PROGRESS),
            hwndParent, UpdateProgressProc, (LPARAM)(PUPDBAR)this);

	if (pCallback && this->hwndParent)
	{
	    BringWindowToTop(this->hwndParent);
	    SetFocus(this->hwndParent); 
	}

        if (!hdlg)
            {
            GFree(this);
            }
        else
            {
            UpdBar_SetAvi(hdlg, uFlags);

            if (IsFlagClear(uFlags, UB_NOSHOW))
                EnableWindow(hwndParent, FALSE);

            if (IsFlagSet(uFlags, UB_TIMER))
                {
                this->dwTickShow = GetTickCount() + (nSecs * MSECS_PER_SEC);
                this->hcurSav = SetCursorRemoveWigglies(LoadCursor(NULL, IDC_WAIT));
                }
            else
                {
                this->dwTickShow = 0;
                this->hcurSav = NULL;

                if (IsFlagClear(uFlags, UB_NOSHOW))
                    {
                    ShowWindow(hdlg, SW_SHOW);
                    UpdateWindow(hdlg);
                    }
                }
            }
        }

    return hdlg;
    }


/*----------------------------------------------------------
Purpose: Destroy the update progress bar
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_Kill(
    HWND hdlg)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        PUPDBAR this = (PUPDBAR)GetWindowLong(hdlg, DWL_USER);

        ASSERT(this);
        if (this)
            {
            if (this->hcurSav)
                SetCursor(this->hcurSav);

            if (IsWindow(this->hwndParent))
                EnableWindow(this->hwndParent, TRUE);
            GFree(this);
            }
        DestroyWindow(hdlg);
        }
    }

/**
Called anytime the progress dialog changes to handle if callback is registered

  will set abort if necessary.

*/


HRESULT UpdateProgressCallback(HWND hdlg)
{
HRESULT hres = NOERROR;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
    {
    PUPDBAR this = (PUPDBAR)GetWindowLong(hdlg, DWL_USER);
    LPSYNCMGRSYNCHRONIZECALLBACK pCallback;
    
	if (this && (pCallback = this->pCallback) )
	{
	SYNCMGRPROGRESSITEM progItem;
	PBRANGE pbRange;
	TCHAR szStatusText[256]; //?
#ifndef UNICODE
	WCHAR wcStatusText[256]; // in case have to convert
#endif // _UNICODE

	
		progItem.mask = SYNCMGRPROGRESSITEM_STATUSTYPE;


		progItem.iProgValue  = 0;
		progItem.iMaxValue = 0;
		progItem.dwStatusType = SYNCMGRSTATUS_UPDATING;

		SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_GETRANGE,0, (WPARAM) &pbRange);
		progItem.iMaxValue = pbRange.iHigh - pbRange.iLow;

		progItem.iProgValue  =
			SendDlgItemMessage(hdlg,IDC_PROGRESS,PBM_GETPOS,0,0);

	//	Static_GetText(GetDlgItem(hdlg, IDC_TONAME),szStatusText,256);
	//	Static_GetText(GetDlgItem(hdlg, IDC_TEXT),szStatusText,256);
		Static_GetText(GetDlgItem(hdlg, IDC_NAME),szStatusText,256);


		#ifndef UNICODE
			MultiByteToWideChar(CP_ACP,0,szStatusText,-1,
						wcStatusText,256);

			progItem.lpcStatusText = wcStatusText;
		#else
			// already unicode, just copy it in.
			progItem.lpcStatusText = szStatusText;
		#endif // UNICODE


		if (NULL != progItem.lpcStatusText)
			progItem.mask |= SYNCMGRPROGRESSITEM_STATUSTEXT 
			    | SYNCMGRPROGRESSITEM_STATUSTYPE;

		if (0 != progItem.iMaxValue)
			progItem.mask |= SYNCMGRPROGRESSITEM_PROGVALUE 
			| SYNCMGRPROGRESSITEM_MAXVALUE;

		
		hres =  (pCallback)->lpVtbl->Progress(pCallback,&this->ItemID ,&progItem);

	}

	if (NOERROR != hres)
	{
	    AbortEvt_Set(this->pabortevt,TRUE);
	}

    }


    return hres;
}


/*----------------------------------------------------------
Purpose: Set the progress bar range.  Reset the position to 0
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_SetRange(
    HWND hdlg,
    WORD wRangeMax)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETPOS, 0, 0);
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELONG(0, wRangeMax));

		UpdateProgressCallback(hdlg);
        }
    }


/*----------------------------------------------------------
Purpose: Increment the position of progress bar
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_DeltaPos(
    HWND hdlg,
    WORD wdelta)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_DELTAPOS, wdelta, 0);

		UpdateProgressCallback(hdlg);
        }
    }


/*----------------------------------------------------------
Purpose: Set the position of progress bar
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_SetPos(
    HWND hdlg,
    WORD wPos)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        SendDlgItemMessage(hdlg, IDC_PROGRESS, PBM_SETPOS, wPos, 0);
		UpdateProgressCallback(hdlg);
        }
    }


/*----------------------------------------------------------
Purpose: Set the current name we're updating in the progress
         bar.
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_SetName(
    HWND hdlg,
    LPCTSTR pszName)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        HWND hwndName = GetDlgItem(hdlg, IDC_NAME);

        Static_SetText(hwndName, pszName);
		UpdateProgressCallback(hdlg);
        }
    }


/*----------------------------------------------------------
Purpose: Set the current name we're updating in the progress
         bar.
Returns: --
Cond:    --
*/
void PUBLIC UpdBar_SetDescription(
    HWND hdlg,
    LPCTSTR psz)
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        HWND hwndName = GetDlgItem(hdlg, IDC_TONAME);

        Static_SetText(hwndName, psz);
        }
    }


/*----------------------------------------------------------
Purpose: Get the window handle of the progress status text.
Returns: --
Cond:    --
*/
HWND PUBLIC UpdBar_GetStatusWindow(
    HWND hdlg)
    {
    HWND hwnd;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        hwnd = GetDlgItem(hdlg, IDC_TEXT);
    else
        hwnd = NULL;

    return hwnd;
    }


/*----------------------------------------------------------
Purpose: Returns a pointer to the abort event owned by this
         progress window.

Returns: pointer to abort event or NULL

Cond:    --
*/
PABORTEVT PUBLIC UpdBar_GetAbortEvt(
    HWND hdlg)
    {
    PABORTEVT pabortevt = NULL;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        PUPDBAR this;

        this = (PUPDBAR)GetWindowLong(hdlg, DWL_USER);
        if (this)
            {
            pabortevt = this->pabortevt;
            }
        }

    return pabortevt;
    }


/*----------------------------------------------------------
Purpose: Sets the animate control to play the avi file designated
         by the UB_ flags

Returns: --
Cond:    --
*/
void PUBLIC UpdBar_SetAvi(
    HWND hdlg,
    UINT uFlags)    // UB_*
    {
    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        UINT ida;
        UINT ids;
        HWND hwndAvi = GetDlgItem(hdlg, IDC_ANIMATE);
        TCHAR sz[MAXBUFLEN];
        RECT rc;


        if (IsFlagClear(uFlags, UB_NOSHOW))
            {
            SetWindowRedraw(hdlg, FALSE);

            // Is the window visible yet?
            if (IsFlagSet(GetWindowLong(hdlg, GWL_STYLE), WS_VISIBLE))
                {
                // Yes; select just the upper area of the progress bar to
                // repaint
                int cy;

                GetWindowRect(GetDlgItem(hdlg, IDC_NAME), &rc);
                MapWindowPoints(HWND_DESKTOP, hdlg, (LPPOINT)&rc, 1);
                cy = rc.top;
                GetClientRect(hdlg, &rc);
                rc.bottom = cy;
                }
            else
                {
                // No
                GetWindowRect(hdlg, &rc);
                MapWindowPoints(HWND_DESKTOP, hdlg, (LPPOINT)&rc, 2);
                }
            }

        if (IsFlagSet(uFlags, UB_NOPROGRESS))
            {
            ShowWindow(GetDlgItem(hdlg, IDC_PROGRESS), SW_HIDE);
            }
        else
            {
            ShowWindow(GetDlgItem(hdlg, IDC_PROGRESS), SW_SHOW);
            }

        // Special text when checking?
        if (IsFlagSet(uFlags, UB_CHECKAVI))
            {
            // Yes
            SetDlgItemText(hdlg, IDC_TONAME, SzFromIDS(IDS_MSG_CHECKING, sz, ARRAYSIZE(sz)));
            }
        else
            {
            // No
            SetDlgItemText(hdlg, IDC_TONAME, TEXT(""));
            }

        // Run AVI?
        if (uFlags & (UB_CHECKAVI | UB_UPDATEAVI))
            {
            // Yes
#pragma data_seg(DATASEG_READONLY)
            static const SNAPCTL rgsnap[] = {
                { IDC_ICON1, SCF_BOTTOM | SCF_SNAPLEFT },
                { IDC_ANIMATE, SCF_ANCHOR },
                { IDC_ICON2, SCF_BOTTOM | SCF_SNAPRIGHT },
                };
#pragma data_seg()

            if (IsFlagSet(uFlags, UB_CHECKAVI))
                {
                ida = IDA_CHECK;
                ids = IDS_CAP_CHECKING;
                }
            else if (IsFlagSet(uFlags, UB_UPDATEAVI))
                {
                ida = IDA_UPDATE;
                ids = IDS_CAP_UPDATING;
                }
            else
                ASSERT(0);

            SetWindowText(hdlg, SzFromIDS(ids, sz, ARRAYSIZE(sz)));
            Animate_Open(hwndAvi, MAKEINTRESOURCE(ida));

            // Snap the icons on either side to the animation
            // control
            SnapControls(hdlg, rgsnap, ARRAYSIZE(rgsnap));

            Animate_Play(hwndAvi, 0, -1, -1);
            }

        // Don't bother setting the redraw if we're never going to show
        // the progress bar
        if (IsFlagClear(uFlags, UB_NOSHOW))
            {
            SetWindowRedraw(hdlg, TRUE);
            InvalidateRect(hdlg, &rc, TRUE);
            UpdateWindow(hdlg);
            }

		UpdateProgressCallback(hdlg);
        }
    }


/*----------------------------------------------------------
Purpose: Yield, and check if user aborted
Returns: TRUE to abort
         FALSE to continue
Cond:    --
*/
BOOL PUBLIC UpdBar_QueryAbort(
    HWND hdlg)
    {
    BOOL bAbort = FALSE;

    ASSERT(IsWindow(hdlg));

    if (IsWindow(hdlg))
        {
        MSG msg;
        PUPDBAR this;

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
            }

        /*
         * Don't use SendMessage() here to ask hdlg if reconciliation has been
         * aborted.  hdlg has typically been created in a different thread.
         * hdlg's creator thread may already be blocked in the sync engine.  We
         * must avoid inter-thread SendMessage() to avoid a deadlock on the
         * sync engine's briefcase critical section.  The sync engine is not
         * reentrant.
         */

        PostMessage(hdlg, WM_QUERYABORT, 0, 0);

        this = (PUPDBAR)GetWindowLong(hdlg, DWL_USER);

        if (this)
            {
            bAbort = AbortEvt_Query(this->pabortevt);
            }
        }

    return bAbort;
    }


//---------------------------------------------------------------------------
// Confirm Replace dialog
//---------------------------------------------------------------------------

// This is the private data structure for the dialog
typedef struct
    {
    UINT uFlags;        // CRF_*
    TCHAR szDesc[MAXBUFLEN+MAXPATHLEN];
    TCHAR szInfoExisting[MAXMEDLEN];
    TCHAR szInfoOther[MAXMEDLEN];
    HICON hicon;
    } CONFIRMREPLACE;


/*----------------------------------------------------------
Purpose: Confirm replace dialog
Returns: varies
Cond:    --
*/
BOOL CALLBACK ConfirmReplace_Proc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
    {
    switch (wMsg)
        {
    case WM_INITDIALOG:
        {
        CONFIRMREPLACE * pcr = (CONFIRMREPLACE *)lParam;
        UINT i;
        UINT cButtons;
        MB_BUTTONS const * pmbb;
#pragma data_seg(DATASEG_READONLY)
        static UINT const rgidc[4] = { IDC_BUTTON1, IDC_BUTTON2, IDC_BUTTON3, IDC_BUTTON4 };
        static BTNSTYLE const btnstyleSingle =
                // (List buttons backwards)
                { 2, { { IDNO,  IDS_NO },
                       { IDYES, IDS_YES },
                     } };

        static BTNSTYLE const btnstyleMulti =
                // (List buttons backwards)
                { 4, { { IDCANCEL,      IDS_CANCEL },
                       { IDNO,          IDS_NO },
                       { IDC_YESTOALL,  IDS_YESTOALL },
                       { IDYES,         IDS_YES },
                     } };
#pragma data_seg()

        Static_SetText(GetDlgItem(hDlg, IDC_DESC), pcr->szDesc);

        if (IsFlagClear(pcr->uFlags, CRF_FOLDER))
            {
            Static_SetText(GetDlgItem(hDlg, IDC_EXISTING), pcr->szInfoExisting);
            Static_SetText(GetDlgItem(hDlg, IDC_OTHER), pcr->szInfoOther);

            Static_SetIcon(GetDlgItem(hDlg, IDC_ICON_EXISTING), pcr->hicon);
            Static_SetIcon(GetDlgItem(hDlg, IDC_ICON_OTHER), pcr->hicon);
            }

        // Set the IDs and strings of used buttons
        if (IsFlagSet(pcr->uFlags, CRF_MULTI))
            {
            cButtons = btnstyleMulti.cButtons;
            pmbb = btnstyleMulti.rgmbb;
            }
        else
            {
            cButtons = btnstyleSingle.cButtons;
            pmbb = btnstyleSingle.rgmbb;
            }

        for (i = 0; i < cButtons; i++)
            {
            TCHAR sz[MAXMEDLEN];
            HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

            LoadString(g_hinst, pmbb[i].ids, sz, ARRAYSIZE(sz));
            SetWindowLong(hwnd, GWL_ID, pmbb[i].id);
            SetWindowText(hwnd, sz);
            }
        // Disable unused buttons
        for (; i < ARRAYSIZE(rgidc); i++)
            {
            HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

            EnableWindow(hwnd, FALSE);
            ShowWindow(hwnd, SW_HIDE);
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam)
            {
        case IDCANCEL:
        case IDYES:
        case IDC_YESTOALL:
        case IDNO:
            EndDialog(hDlg, wParam);
            break;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Brings up the replace confirmation dialog.

Returns: IDYES, IDC_YESTOALL, IDNO or IDCANCEL
Cond:    --
*/
int PUBLIC ConfirmReplace_DoModal(
    HWND hwndOwner,
    LPCTSTR pszPathExisting,
    LPCTSTR pszPathOther,
    UINT uFlags)                // CRF_*
    {
    int idRet;
    CONFIRMREPLACE * pcr;

    pcr = GAlloc(sizeof(*pcr));
    if (pcr)
        {
        LPTSTR pszMsg;
        DWORD dwAttrs = GetFileAttributes(pszPathExisting);

        pcr->uFlags = uFlags;

        // Is this replacing a folder?
        if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_DIRECTORY))
            {
            // Yes
            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_MSG_ConfirmFolderReplace),
                PathFindFileName(pszPathOther)))
                {
                lstrcpy(pcr->szDesc, pszMsg);
                GFree(pszMsg);
                }
            else
                *pcr->szDesc = 0;

            SetFlag(pcr->uFlags, CRF_FOLDER);

            idRet = DoModal(hwndOwner, ConfirmReplace_Proc, IDD_REPLACE_FOLDER, (LPARAM)pcr);
            }
        else
            {
            // No
            UINT ids;
            FileInfo * pfi;

            if (SUCCEEDED(FICreate(pszPathExisting, &pfi, FIF_ICON)))
                {
                pcr->hicon = pfi->hicon;

                FIGetInfoString(pfi, pcr->szInfoExisting, ARRAYSIZE(pcr->szInfoExisting));

                pfi->hicon = NULL;      // (keep icon around)
                FIFree(pfi);
                }

            if (SUCCEEDED(FICreate(pszPathOther, &pfi, FIF_DEFAULT)))
                {
                FIGetInfoString(pfi, pcr->szInfoOther, ARRAYSIZE(pcr->szInfoOther));
                FIFree(pfi);
                }

            if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_READONLY))
                {
                ids = IDS_MSG_ConfirmFileReplace_RO;
                }
            else if (IsFlagSet(dwAttrs, FILE_ATTRIBUTE_SYSTEM))
                {
                ids = IDS_MSG_ConfirmFileReplace_Sys;
                }
            else
                {
                ids = IDS_MSG_ConfirmFileReplace;
                }

            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids),
                PathFindFileName(pszPathOther)))
                {
                lstrcpy(pcr->szDesc, pszMsg);
                GFree(pszMsg);
                }
            else
                *pcr->szDesc = 0;

            ClearFlag(pcr->uFlags, CRF_FOLDER);

            idRet = DoModal(hwndOwner, ConfirmReplace_Proc, IDD_REPLACE_FILE, (LPARAM)pcr);

            if (pcr->hicon)
                DestroyIcon(pcr->hicon);
            }
        GFree(pcr);
        }
    else
        {
        idRet = -1;     // Out of memory
        }
    return idRet;
    }


//---------------------------------------------------------------------------
// Introduction dialog
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Intro dialog
Returns: varies
Cond:    --
*/
BOOL CALLBACK Intro_Proc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
    {
    NMHDR  *lpnm;

    switch (wMsg)
        {
    case WM_INITDIALOG:
        break;

    case WM_NOTIFY:
        lpnm = (NMHDR  *)lParam;
        switch(lpnm->code)
            {
        case PSN_SETACTIVE: {
            // Only allow the Finish button.  The user cannot go back and
            // change the settings.
            HWND hwndCancel = GetDlgItem(GetParent(hDlg), IDCANCEL);

            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_FINISH);

            // Hide cancel button
            EnableWindow(hwndCancel, FALSE);
            ShowWindow(hwndCancel, SW_HIDE);
            }
            break;

        case PSN_KILLACTIVE:
        case PSN_HELP:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:
            break;

        default:
            return FALSE;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Invoke the introduction wizard.

Returns: ID of button that terminated dialog
Cond:    --
*/
int PUBLIC Intro_DoModal(
    HWND hwndParent)
    {
    PROPSHEETPAGE psp = {
        sizeof(psp),
        PSP_DEFAULT,
        g_hinst,
        MAKEINTRESOURCE(IDD_INTRO_WIZARD),
        NULL,           // hicon
        NULL,           // caption
        Intro_Proc,
        0,              // lParam
        NULL,           // pfnCallback
        NULL            // pointer to ref count
        };
    PROPSHEETHEADER psh = {
        sizeof(psh),
        PSH_WIZARD | PSH_PROPSHEETPAGE,     // (use ppsp field)
        hwndParent,
        g_hinst,
        0,              // hicon
        0,              // caption
        1,              // number of pages
        0,              // start page
        &psp
        };

    return PropertySheet(&psh);
    }



//---------------------------------------------------------------------------
// MsgBox dialog
//---------------------------------------------------------------------------

typedef struct _MSGBOX
    {
    LPCTSTR pszText;
    LPCTSTR pszCaption;
    HICON  hicon;
    UINT   uStyle;
    } MSGBOX, * PMSGBOX;


/*----------------------------------------------------------
Purpose: Determines whether to resize the dialog and reposition
         the buttons to fit the text.

         The dialog is not resized any smaller than its initial
         size.

         The dialog is only resized vertically.

Returns: --
Cond:    --
*/
void PRIVATE MsgBox_Resize(
    HWND hDlg,
    LPCTSTR pszText,
    UINT cchText)
    {
    HDC hdc;
    HWND hwndText = GetDlgItem(hDlg, IDC_TEXT);

    hdc = GetDC(hwndText);
    if (hdc)
        {
        HFONT hfont = GetStockObject(DEFAULT_GUI_FONT);
        HFONT hfontSav = SelectFont(hdc, hfont);
        RECT rc;
        RECT rcOrg;

        // Determine new dimensions
        GetClientRect(hwndText, &rcOrg);
        rc = rcOrg;
        DrawTextEx(hdc, (LPTSTR)pszText, cchText, &rc, DT_CALCRECT | DT_WORDBREAK | DT_LEFT, NULL);

        SelectFont(hdc, hfontSav);
        ReleaseDC(hwndText, hdc);

        // Is the required size bigger?
        if (rc.bottom > rcOrg.bottom)
            {
            // Yes; resize the windows
            int cy = rc.bottom - rcOrg.bottom;
            int cyFudge = GetSystemMetrics(SM_CYCAPTION) + 2*GetSystemMetrics(SM_CYFIXEDFRAME);
            int cxFudge = 2*GetSystemMetrics(SM_CXFIXEDFRAME);
            HDWP hdwp = BeginDeferWindowPos(4);

            if (hdwp)
                {
                // Move Buttons
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON1, 0, cy);
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON2, 0, cy);
                hdwp = SlideControlPos(hdwp, hDlg, IDC_BUTTON3, 0, cy);

                // Resize Static Text
                hdwp = DeferWindowPos(hdwp, hwndText, GetDlgItem(hDlg, IDC_BUTTON3),
                                      0, 0,
                                      rc.right-rc.left, rc.bottom-rc.top,
                                      SWP_NOACTIVATE | SWP_NOMOVE);

                EndDeferWindowPos(hdwp);
                }

            // Resize Dialog
            GetClientRect(hDlg, &rc);
            SetWindowPos(hDlg, NULL, 0, 0,
                         rc.right-rc.left + cxFudge, rc.bottom-rc.top + cy + cyFudge,
                         SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOMOVE);
            }
        }
    }


/*----------------------------------------------------------
Purpose: MsgBox dialog
Returns: varies
Cond:    --
*/
BOOL CALLBACK MsgBox_Proc(
    HWND hDlg,
    UINT wMsg,
    WPARAM wParam,
    LPARAM lParam)
    {
    switch (wMsg)
        {
    case WM_INITDIALOG:
        {
        PMSGBOX pmsgbox = (PMSGBOX)lParam;
        UINT uStyle = pmsgbox->uStyle;
        UINT i;
        UINT imb = uStyle & MB_TYPEMASK;
        UINT cButtons;
        MB_BUTTONS const * pmbb;
#pragma data_seg(DATASEG_READONLY)
        static UINT const rgidc[3] = { IDC_BUTTON1, IDC_BUTTON2, IDC_BUTTON3 };
        static BTNSTYLE const rgmbstyle[] = {
                // (List buttons backwards)
                // MB_OK
                { 1, { { IDOK,      IDS_OK },
                     } },
                // MB_OKCANCEL
                { 2, { { IDCANCEL,  IDS_CANCEL },
                       { IDOK,      IDS_OK },
                     } },
                // MB_ABORTRETRYIGNORE (not supported)
                { 1, { { IDOK,      IDS_OK },
                     } },
                // MB_YESNOCANCEL
                { 3, { { IDCANCEL,  IDS_CANCEL },
                       { IDNO,      IDS_NO },
                       { IDYES,     IDS_YES },
                     } },
                // MB_YESNO
                { 2, { { IDNO,      IDS_NO },
                       { IDYES,     IDS_YES },
                     } },
                // MB_RETRYCANCEL
                { 2, { { IDCANCEL,  IDS_CANCEL },
                       { IDRETRY,   IDS_RETRY },
                     } },
                };
#pragma data_seg()

        // Set the text
        if (pmsgbox->pszText)
            {
            Static_SetText(GetDlgItem(hDlg, IDC_TEXT), pmsgbox->pszText);

            // Resize and reposition the buttons if necessary
            MsgBox_Resize(hDlg, pmsgbox->pszText, lstrlen(pmsgbox->pszText));
            }
        if (pmsgbox->pszCaption)
            SetWindowText(hDlg, pmsgbox->pszCaption);

        // Use a custom icon?
        if (NULL == pmsgbox->hicon)
            {
            // No; use a system icon
            LPCTSTR pszIcon;

            if (IsFlagSet(uStyle, MB_ICONEXCLAMATION))
                pszIcon = IDI_EXCLAMATION;
            else if (IsFlagSet(uStyle, MB_ICONHAND))
                pszIcon = IDI_HAND;
            else if (IsFlagSet(uStyle, MB_ICONQUESTION))
                pszIcon = IDI_QUESTION;
            else
                pszIcon = IDI_ASTERISK;

            pmsgbox->hicon = LoadIcon(NULL, pszIcon);
            }
        Static_SetIcon(GetDlgItem(hDlg, IDC_MSGICON), pmsgbox->hicon);

        // Set the IDs and strings of used buttons
        cButtons = rgmbstyle[imb].cButtons;
        pmbb = rgmbstyle[imb].rgmbb;
        for (i = 0; i < cButtons; i++)
            {
            TCHAR sz[MAXMEDLEN];
            HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

            LoadString(g_hinst, pmbb[i].ids, sz, ARRAYSIZE(sz));
            SetWindowLong(hwnd, GWL_ID, pmbb[i].id);
            SetWindowText(hwnd, sz);
            }
        // Disable unused buttons
        for (; i < ARRAYSIZE(rgidc); i++)
            {
            HWND hwnd = GetDlgItem(hDlg, rgidc[i]);

            EnableWindow(hwnd, FALSE);
            ShowWindow(hwnd, SW_HIDE);
            }
        }
        break;

    case WM_COMMAND:
        switch (wParam)
            {
        case IDOK:
        case IDCANCEL:
        case IDYES:
        case IDNO:
        case IDRETRY:
            EndDialog(hDlg, wParam);
            break;
            }
        break;

    default:
        return FALSE;
        }

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Invoke the introduction dialog.

Returns: ID of button that terminated dialog
Cond:    --
*/
int PUBLIC MsgBox(
    HWND hwndParent,
    LPCTSTR pszText,
    LPCTSTR pszCaption,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,
    SYNCMGRITEMID ItemID,
    HICON hicon,            // May be NULL
    UINT uStyle, ...)
    {
    int iRet = -1;
    int ids;
    TCHAR szCaption[MAXPATHLEN];
    LPTSTR pszRet;
    va_list ArgList;

    va_start(ArgList, uStyle);

    pszRet = _ConstructMessageString(g_hinst, pszText, &ArgList);

    va_end(ArgList);

    if (pszRet)
    {

	if (NULL != pCallBack)
	{
	HRESULT hres; // bug, don't check for cancel.
	SYNCMGRPROGRESSITEM progItem;
	TCHAR *pStatusText = pszRet;
#ifndef UNICODE
	WCHAR wcStatusText[256]; // in case have to convert
#endif // _UNICODE

	   progItem.mask = 0;	
	   progItem.mask |= SYNCMGRPROGRESSITEM_STATUSTEXT | SYNCMGRPROGRESSITEM_STATUSTYPE;
	   progItem.dwStatusType = SYNCMGRSTATUS_UPDATING;

	    #ifndef UNICODE
		    MultiByteToWideChar(CP_ACP,0,pStatusText,-1,
					    wcStatusText,256);

		    progItem.lpcStatusText = wcStatusText;
	    #else
		    // already unicode, just copy it in.
		    progItem.lpcStatusText = pStatusText;
	    #endif // UNICODE

	    hres =  (pCallBack)->lpVtbl->Progress(pCallBack,&ItemID ,&progItem);
	}
	else
	{

	    // Is pszCaption a resource ID?
	    if (0 == HIWORD(pszCaption))
		{
		// Yes; load it
		ids = LOWORD(pszCaption);
		SzFromIDS(ids, szCaption, ARRAYSIZE(szCaption));
		pszCaption = szCaption;
		}

	    // Invoke dialog
	    if (pszCaption)
		{
		MSGBOX msgbox = { pszRet, pszCaption, hicon, uStyle };
		iRet = DoModal(hwndParent, MsgBox_Proc, IDC_MSGBOX, (LPARAM)&msgbox);
		}
	}

        LocalFree(pszRet);
        
    }

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\oledup.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: oledup.c
//
//  This files contains duplicated code the OLE would provide.
//  We do this so we don't have to link to OLE for M6.
//
// History:
//  02-14-94 ScottH     Created (copied from shell)
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers


HRESULT MyReleaseStgMedium(LPSTGMEDIUM pmedium)
    {
    if (pmedium->pUnkForRelease)
        {
        pmedium->pUnkForRelease->lpVtbl->Release(pmedium->pUnkForRelease);
        }
    else
        {
        switch(pmedium->tymed)
            {
        case TYMED_HGLOBAL:
            GlobalFree(pmedium->hGlobal);
            break;

        default:
            // Not fullly implemented.
            MessageBeep(0);
            break;
            }
        }

    return NOERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\mem.c ===
#include "brfprv.h"

//========== Memory Management =============================================

#ifndef WIN32

#define MAX_WORD    0xffff

DECLARE_HANDLE(HHEAP);

typedef struct {                //  maps to the bottom of a 16bit DS
    WORD reserved[8];
    WORD cAlloc;
    WORD cbAllocFailed;
    HHEAP hhpFirst;
    HHEAP hhpNext;
} HEAP;

#define PHEAP(hhp)          ((HEAP *)MAKELP(hhp, 0))
#define MAKEHP(sel, off)    ((void _huge*)MAKELP((sel), (off)))

#define CBSUBALLOCMAX   0x0000f000L

HHEAP g_hhpFirst = NULL;

BOOL  DestroyHeap(HHEAP hhp);

void Mem_Terminate()
{
    while (g_hhpFirst)
        DestroyHeap(g_hhpFirst);
}

BOOL  CreateHeap(WORD cbInitial)
{
    HHEAP hhp;

    if (cbInitial < 1024)
        cbInitial = 1024;

    hhp = (HHEAP)GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cbInitial);

    if (!hhp)
        return FALSE;

    if (!LocalInit((WORD)hhp, sizeof(HEAP), cbInitial - 1))
    {
        GlobalFree(hhp);
        return FALSE;
    }

    PHEAP(hhp)->cAlloc = 0;
    PHEAP(hhp)->cbAllocFailed = MAX_WORD;
    PHEAP(hhp)->hhpNext = g_hhpFirst;
    g_hhpFirst = hhp;

    DebugMsg(DM_TRACE, TEXT("CreateHeap: added new local heap %x"), hhp);

    return TRUE;
}

#pragma optimize("o", off)              // linked list removals don't optimize correctly
BOOL  DestroyHeap(HHEAP hhp)
{
    ASSERT(hhp);
    ASSERT(g_hhpFirst);

    if (g_hhpFirst == hhp)
    {
        g_hhpFirst = PHEAP(hhp)->hhpNext;
    }
    else
    {
        HHEAP hhpT = g_hhpFirst;

        while (PHEAP(hhpT)->hhpNext != hhp)
        {
            hhpT = PHEAP(hhpT)->hhpNext;
            if (!hhpT)
                return FALSE;
        }

        PHEAP(hhpT)->hhpNext = PHEAP(hhp)->hhpNext;
    }
    if (GlobalFree((HGLOBAL)hhp) != NULL)
        return FALSE;

    return TRUE;
}
#pragma optimize("", on)        // back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...
void *  HeapAlloc(HHEAP hhp, WORD cb)
{
    void * pb;

    _asm {
        push    ds
        mov     ds,hhp
    }

    pb = (void *)LocalAlloc(LMEM_FIXED | LMEM_ZEROINIT, cb);

    if (pb)
        ((HEAP *)0)->cAlloc++;

    _asm {
        pop     ds
    }

    return pb;
}
#pragma optimize("o", off)              // linked list removals don't optimize correctly

void _huge* WINAPI SharedAlloc(long cb)
{
    void * pb;
    HHEAP hhp;
    HHEAP hhpPrev;

    // If this is a big allocation, just do a global alloc.
    //
    if (cb > CBSUBALLOCMAX)
    {
        void * lpb = MAKEHP(GlobalAlloc(GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, cb), 0);
        if (!lpb)
            DebugMsg(DM_ERROR, TEXT("Alloc: out of memory"));
        return lpb;
    }

    hhp = g_hhpFirst;

    while (TRUE)
    {
        if (hhp == NULL)
        {
            if (!CreateHeap(0))
            {
                DebugMsg(DM_ERROR, TEXT("Alloc: out of memory"));
                return NULL;
            }

            hhp = g_hhpFirst;
        }

        pb = HeapAlloc(hhp, (WORD)cb);
        if (pb)
            return MAKEHP(hhp, pb);

        // Record the size of the allocation that failed.
        // Later attempts to allocate more than this amount
        // will not succeed.  This gets reset anytime anything
        // is freed in the heap.
        //
        PHEAP(hhp)->cbAllocFailed = (WORD)cb;

        // First heap is full... see if there's room in any other heap...
        //
        for (hhpPrev = hhp; hhp = PHEAP(hhp)->hhpNext; hhpPrev = hhp)
        {
            // If the last allocation to fail in this heap
            // is not larger than cb, don't even try an allocation.
            //
            if ((WORD)cb >= PHEAP(hhp)->cbAllocFailed)
                continue;

            pb = HeapAlloc(hhp, (WORD)cb);
            if (pb)
            {
                // This heap had room: move it to the front...
                //
                PHEAP(hhpPrev)->hhpNext = PHEAP(hhp)->hhpNext;
                PHEAP(hhp)->hhpNext = g_hhpFirst;
                g_hhpFirst = hhp;

                return MAKEHP(hhp, pb);
            }
            else
            {
                // The alloc failed.  Set cbAllocFailed...
                //
                PHEAP(hhp)->cbAllocFailed = (WORD)cb;
            }
        }
    }
}
#pragma optimize("", on)        // back to default optimizations

#pragma optimize("lge", off) // Suppress warnings associated with use of _asm...

void _huge* WINAPI SharedReAlloc(void _huge* pb, long cb)
{
    void * pbNew;
    void _huge* lpbNew;
    UINT cbOld;

    if (!pb)
        return SharedAlloc(cb);

    if (OFFSETOF(pb) == 0)
        return MAKEHP(GlobalReAlloc((HGLOBAL)SELECTOROF(pb), cb, GMEM_MOVEABLE | GMEM_ZEROINIT), 0);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    pbNew = (void *)LocalReAlloc((HLOCAL)OFFSETOF(pb), (int)cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
    if (!pbNew)
        cbOld = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    if (pbNew)
        return MAKEHP(SELECTOROF(pb), pbNew);

    lpbNew = SharedAlloc(cb);
    if (lpbNew)
    {
        hmemcpy((void *)lpbNew, (void *)pb, cbOld);
        Free(pb);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("ReAlloc: out of memory"));
    }
    return lpbNew;
}

BOOL WINAPI SharedFree(void _huge*  * ppb)
{
    BOOL fSuccess;
    UINT cAlloc;
    void _huge * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    if (OFFSETOF(pb) == 0)
        return (GlobalFree((HGLOBAL)SELECTOROF(pb)) == NULL);

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    fSuccess = (LocalFree((HLOCAL)OFFSETOF(pb)) ? FALSE : TRUE);

    cAlloc = 1;
    if (fSuccess)
    {
        cAlloc = --((HEAP *)0)->cAlloc;
        ((HEAP *)0)->cbAllocFailed = MAX_WORD;
    }

    _asm {
        pop     ds
    }

    if (cAlloc == 0)
        DestroyHeap((HHEAP)SELECTOROF(pb));

    return fSuccess;
}


DWORD WINAPI SharedGetSize(void _huge* pb)
{
    WORD wSize;

    if (OFFSETOF(pb) == 0)
        return GlobalSize((HGLOBAL)SELECTOROF(pb));

    _asm {
        push    ds
        mov     ds,word ptr [pb+2]
    }

    wSize = LocalSize((HLOCAL)OFFSETOF(pb));

    _asm {
        pop     ds
    }

    return (DWORD)wSize;
}


#if 0
// hmemcpy() is faster (says davidds)

void WINAPI MemCopy(void * pTo, const void * pFrom, UINT cb)
{
    _asm {
        mov     cx,cb
        jcxz    mcexit

;;      push    si
;;      push    di
        mov     dx,ds

        lds     si,pFrom
        les     di,pTo

        cmp     si,di
        jae     mccopyup

        mov     ax,cx
        dec     ax
        dec     ax
        add     si,ax
        add     di,ax

        std
        shr     cx,1
        rep     movsw
        jnc     mc100
        inc     si
        inc     di
        movsb
mc100:
        cld
        jmp     short mcexit

mccopyup:
        cld
        shr     cx,1
        rep     movsw
        jnc     mc200
        movsb
mc200:

mcexit:
        mov     ds,dx
;;      pop     di
;;      pop     si
    }
}
#endif

#pragma optimize("", on)

#else // WIN32

// Define a Global Shared Heap that we use allocate memory out of that we
// Need to share between multiple instances.
HANDLE g_hSharedHeap = NULL;
#define MAXHEAPSIZE 2097152
#define HEAP_SHARED     0x04000000              /* put heap in shared memory */

//----------------------------------------------------------------------------
void PUBLIC Mem_Terminate()
{
    // Assuming that everything else has exited
    //
    if (g_hSharedHeap != NULL)
        HeapDestroy(g_hSharedHeap);
    g_hSharedHeap = NULL;
}

//----------------------------------------------------------------------------
void * WINAPI SharedAlloc(long cb)
{
    // I will assume that this is the only one that needs the checks to
    // see if the heap has been previously created or not

    if (g_hSharedHeap == NULL)
    {
        ENTEREXCLUSIVE()
        if (g_hSharedHeap == NULL)
        {
#ifdef WINNT
              g_hSharedHeap = HeapCreate(0, 1, MAXHEAPSIZE);
#else
              g_hSharedHeap = HeapCreate(HEAP_SHARED, 1, MAXHEAPSIZE);
#endif

        }
        LEAVEEXCLUSIVE()

        // If still NULL we have problems!
        if (g_hSharedHeap == NULL)
            return(NULL);
    }

    return HeapAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, cb);
}

//----------------------------------------------------------------------------
void * WINAPI SharedReAlloc(void * pb, long cb)
{
    if (pb==NULL)
    {
        return SharedAlloc(cb);
    }
    return HeapReAlloc(g_hSharedHeap, HEAP_ZERO_MEMORY, pb, cb);
}

//----------------------------------------------------------------------------
BOOL WINAPI SharedFree(void ** ppb)
{
    void * pb = *ppb;

    if (!pb)
        return FALSE;

    *ppb = 0;

    return HeapFree(g_hSharedHeap, 0, pb);
}

//----------------------------------------------------------------------------
DWORD WINAPI SharedGetSize(void * pb)
{
    return HeapSize(g_hSharedHeap, 0, pb);
}

//----------------------------------------------------------------------------
// The following functions are for debug only and are used to try to
// calculate memory usage.
//
#ifdef DEBUG
typedef struct _HEAPTRACE
{
    DWORD   cAlloc;
    DWORD   cFailure;
    DWORD   cReAlloc;
    DWORD   cbMaxTotal;
    DWORD   cCurAlloc;
    DWORD   cbCurTotal;
} HEAPTRACE;

HEAPTRACE g_htSync = {0};      // Start of zero...

LPVOID WINAPI MemAlloc(HANDLE hheap, DWORD cb)
{
    LPVOID lp;

    lp = HeapAlloc(hheap, HEAP_ZERO_MEMORY, cb);
    if (lp == NULL)
    {
        g_htSync.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htSync.cAlloc++;
    g_htSync.cCurAlloc++;
    g_htSync.cbCurTotal += cb;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

    return lp;
}

LPVOID WINAPI MemReAlloc(HANDLE hheap, LPVOID pb, DWORD cb)
{
    LPVOID lp;
    DWORD cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    lp = HeapReAlloc(hheap, HEAP_ZERO_MEMORY, pb,cb);
    if (lp == NULL)
    {
        g_htSync.cFailure++;
        return NULL;
    }

    // Update counts.
    g_htSync.cReAlloc++;
    g_htSync.cbCurTotal += cb - cbOld;
    if (g_htSync.cbCurTotal > g_htSync.cbMaxTotal)
        g_htSync.cbMaxTotal = g_htSync.cbCurTotal;

    return lp;
}

BOOL  WINAPI MemFree(HANDLE hheap, LPVOID pb)
{
    BOOL fRet;

    DWORD cbOld;

    cbOld = HeapSize(hheap, 0, pb);

    fRet = HeapFree(hheap, 0, pb);
    if (fRet)
    {
        // Update counts.
        g_htSync.cCurAlloc--;
        g_htSync.cbCurTotal -= cbOld;
    }

    return(fRet);
}

DWORD WINAPI MemSize(HANDLE hheap, LPVOID pb)
{
    return HeapSize(hheap, 0, pb);
}
#endif


#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\init.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: init.c
//
//  This file contains the library entry points
//
// Usage and assumptions used in this DLL.
//
//  1) Message crackers are used.  See windowsx.h and windowsx.txt.
//
//  2) Many functions are considered "member functions" of a
//     particular class.  Because this is not C++, the function
//     names follow a special naming convention: "Class_Name".
//     In addition, it is common practice that the first
//     argument for these type of functions is a "this" pointer
//     to the particular object.
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include <oleguid.h>
#include <coguid.h>
#include <shlguid.h>

#include <initguid.h>
#define INITGUID            // Initialize GUIDs
#include "syncmgr.h"
#include <shguidp.h>        // Contains CLSID_Briefcase
#include <brfcasep.h>

DEFINE_GUID(IID_IBriefcaseStg2, 0x8BCE1FA1L, 0x1921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);


DEFINE_GUID(CLSID_SyncMgr,0x6295df27, 0x35ee, 0x11d1, 0x87, 0x7, 0x0, 0xc0, 0x4f, 0xd9, 0x33, 0x27);
DEFINE_GUID(IID_ISyncMgrSynchronizeInvoke,0x6295df2c, 0x35ee, 0x11d1, 0x87, 0x7, 0x0, 0xc0, 0x4f, 0xd9, 0x33, 0x27);
DEFINE_GUID(CLSID_BriefCase,0x85BBD920,0x42A0,0x1069,0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_OneStopHandler,0x97484ba2, 0x26c7, 0x11d1, 0x9a, 0x39, 0x0, 0x20, 0xaf, 0xda, 0x97, 0xb0);

#include "res.h"
#include "recact.h"

#ifdef DEBUG
#include <debugstr.h>
#endif


//---------------------------------------------------------------------------
// Per instance data
//---------------------------------------------------------------------------

#pragma data_seg(DATASEG_PERINSTANCE)

HINSTANCE   g_hinst = 0;
TWINRESULT  g_tr = TR_SUCCESS;

IShellFolder * g_psfDesktop = NULL;

// Debugging variables
UINT g_uBreakFlags = 0;         // Controls when to int 3
UINT g_uTraceFlags = 0;         // Controls what trace messages are spewed
UINT g_uDumpFlags = 0;          // Controls what structs get dumped

// The delay mutex and the cs that protects the cRef is per-instance
HANDLE g_hMutexDelay = NULL;
static UINT g_cRefMutex = 0;
static CRITICAL_SECTION s_csDelay = { 0 };

#pragma data_seg()


//---------------------------------------------------------------------------
// Global data
//---------------------------------------------------------------------------

int g_cProcesses = 0;
CRITICAL_SECTION g_csSyncUI = { 0 };
DEBUG_CODE( UINT g_cRefSyncUI = 0; )
UINT g_cfBriefObj = 0;

// Use the helper macros in brfprv.h
UINT g_cBusyRef = 0;            // Semaphore
UINT g_cBriefRef = 0;           // Semaphore

// Metrics
int g_cxIconSpacing = 0;
int g_cyIconSpacing = 0;
int g_cxBorder = 0;
int g_cyBorder = 0;
int g_cxIcon = 0;
int g_cyIcon = 0;
int g_cxIconMargin = 0;
int g_cyIconMargin = 0;
int g_cxLabelMargin = 0;
int g_cyLabelSpace = 0;
int g_cxMargin = 0;

// System colors
COLORREF g_clrHighlightText = 0;
COLORREF g_clrHighlight = 0;
COLORREF g_clrWindowText = 0;
COLORREF g_clrWindow = 0;

HBRUSH g_hbrHighlight = 0;
HBRUSH g_hbrWindow = 0;

// Strings
TCHAR g_szDBName[MAXPATHLEN];
TCHAR g_szDBNameShort[MAXPATHLEN];


/*----------------------------------------------------------
Purpose: Returns an IShellFolder interface to the shell's desktop.
         The interface is cached in g_psfDesktop for speed.

         The shell is guaranteed to have a desktop IShellFolder.

Returns: psfDesktop
Cond:    --
*/
LPSHELLFOLDER PUBLIC GetDesktopShellFolder(void)
    {
    ENTEREXCLUSIVE()
        {
        if (NULL == g_psfDesktop)
            {
            IShellFolder * psfDesktop;

            LEAVEEXCLUSIVE();
            SHCoCreateInstance(NULL, &CLSID_ShellDesktop, NULL, &IID_IShellFolder, &psfDesktop);
            ENTEREXCLUSIVE();

            g_psfDesktop = psfDesktop;
            }
        }
    LEAVEEXCLUSIVE()

    return g_psfDesktop;
    }


/*----------------------------------------------------------
Purpose: Releases the cached desktop IShellFolder interface.
Returns: --
Cond:    --
*/
void PRIVATE ReleaseDesktopShellFolder(void)
    {
    ENTEREXCLUSIVE()
        {
        if (NULL != g_psfDesktop)
            {
            g_psfDesktop->lpVtbl->Release(g_psfDesktop);
            g_psfDesktop = NULL;
            }
        }
    LEAVEEXCLUSIVE()
    }


/*----------------------------------------------------------
Purpose: Get the system metrics we need
Returns: --
Cond:    --
*/
void PRIVATE GetMetrics(
    WPARAM wParam)      // wParam from WM_WININICHANGE
    {
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
        {
        g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
        g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);

        g_cxIcon = GetSystemMetrics(SM_CXICON);
        g_cyIcon = GetSystemMetrics(SM_CYICON);

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyBorder * 2;
        g_cyLabelSpace = g_cyIconMargin + (g_cyBorder * 2);
        g_cxLabelMargin = (g_cxBorder * 2);
        g_cxMargin = g_cxBorder * 5;
        }
    }


/*----------------------------------------------------------
Purpose: Initializes colors
Returns: --
Cond:    --
*/
void PRIVATE InitGlobalColors()
    {
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);

    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    }


/*----------------------------------------------------------
Purpose: Initialize global strings
Returns: --
Cond:    --
*/
void PRIVATE InitGlobalStrings()
    {
    SzFromIDS(IDS_BC_DATABASE, g_szDBName, ARRAYSIZE(g_szDBName));
    SzFromIDS(IDS_BC_DATABASE_SHORT, g_szDBNameShort, ARRAYSIZE(g_szDBNameShort));
    }


/*----------------------------------------------------------
Purpose: Initialize the DLL on the first PROCESS_ATTACH

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE InitializeFirstTime(void)
    {
    BOOL bRet = FALSE;

    InitCommonControls();

    GetMetrics(0);

    CPATH_InitCS();
    CBS_InitCS();
    CRL_InitCS();

    if (!Atom_Init())
        goto Init_Cleanup;

    if (!CPATH_Init())
        goto Init_Cleanup;

    // We do not load the engine DLL until we really need it.

    // Initialize our global imagelist
    //
    g_cfBriefObj = RegisterClipboardFormat(CFSTR_BRIEFOBJECT);
    if (g_cfBriefObj == 0)
        goto Init_Cleanup;

    bRet = TRUE;

Init_Cleanup:
    if (bRet == FALSE)
        {
        Atom_Term();
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Register window classes per process

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE InitWindowClasses(
    HINSTANCE hinst)
    {
    if (!RecAct_Init(hinst))
        return FALSE;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Terminate DLL on the last PROCESS_DETACH

Returns: --
Cond:    --
*/
void PRIVATE FinalTerminate(
    HINSTANCE hinst)
    {
    CPATH_Term();
    Atom_Term();

    CRL_DeleteCS();
    CBS_DeleteCS();
    CPATH_DeleteCS();

    Mem_Terminate();
    }


/*----------------------------------------------------------
Purpose: Unregister window classes per process
Returns: --
Cond:    --
*/
void PRIVATE TermWindowClasses(
    HINSTANCE hinst)
    {
    RecAct_Term(hinst);
    }


/*----------------------------------------------------------
Purpose: Obtain ownership of the delay-calculation mutex

Returns: reference count
Cond:    --
*/
UINT PUBLIC Delay_Own(void)
    {
    UINT cRef;

    EnterCriticalSection(&s_csDelay);
        {
        if (0 == g_cRefMutex++)
            {
            // Obtain ownership of the mutex.  This will get released
            // when Delay_Release is called.
            LeaveCriticalSection(&s_csDelay);
                {
                MsgWaitObjectsSendMessage(1, &g_hMutexDelay, INFINITE);
                }
            EnterCriticalSection(&s_csDelay);

            TRACE_MSG(TF_GENERAL, TEXT("Set delay mutex"));
            }
        cRef = g_cRefMutex;
        }
    LeaveCriticalSection(&s_csDelay);

    return cRef;
    }


/*----------------------------------------------------------
Purpose: Release ownership of the delay-calculation mutex

Returns: reference count
Cond:    --
*/
UINT PUBLIC Delay_Release(void)
    {
    UINT cRef;

    EnterCriticalSection(&s_csDelay);
        {
        ASSERT(0 < g_cRefMutex);

        if (0 < g_cRefMutex)
            {
            if (0 == --g_cRefMutex)
                {
                ReleaseMutex(g_hMutexDelay);

                TRACE_MSG(TF_GENERAL, TEXT("Release delay mutex"));
                }
            }
        cRef = g_cRefMutex;
        }
    LeaveCriticalSection(&s_csDelay);

    return cRef;
    }


/*----------------------------------------------------------
Purpose: Enter a critical section
Returns: --
Cond:    --
*/
void PUBLIC Brief_EnterExclusive(void)
    {
    EnterCriticalSection(&g_csSyncUI); 
#ifdef DEBUG
    g_cRefSyncUI++;
#endif
    }


/*----------------------------------------------------------
Purpose: Leave a critical section
Returns: --
Cond:    --
*/
void PUBLIC Brief_LeaveExclusive(void)
    {
#ifdef DEBUG
    g_cRefSyncUI--;
#endif
    LeaveCriticalSection(&g_csSyncUI);
    }


/*----------------------------------------------------------
Purpose: Attach a process to this DLL
Returns: --
Cond:    --
*/
BOOL ProcessAttach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

    // It's okay to use a critical section in Chicago because (unlike
    //  NT) they work across processes. (See NT case below)

	if (0) // rogerg ReInitialize is undefined.
	{

#ifdef WINNT
   // InitializeCriticalSection(&g_csSyncUI);
#else
  //  ReinitializeCriticalSection(&g_csSyncUI);
#endif
	}
	else
	{
		InitializeCriticalSection(&g_csSyncUI);
	}


    ASSERT(0 != *((LPDWORD)&g_csSyncUI));

    InitializeCriticalSection(&s_csDelay);
    ASSERT(0 != *((LPDWORD)&s_csDelay));

    ENTEREXCLUSIVE()
        {
        g_hinst = hDll;

#ifdef DEBUG

        // We do this simply to load the debug .ini flags
        //
        ProcessIniFile();

        TRACE_MSG(TF_GENERAL, TEXT("Process Attach [%d] (hDll = %lx)"), g_cProcesses, hDll);
        DEBUG_BREAK(BF_ONPROCESSATT);

#endif

        // Under NT, we need to initialize on every process attach, not just the first

#ifdef WINNT
        g_cProcesses++;
        bSuccess = InitializeFirstTime();
#else
        if (0 == g_cProcesses++)
        {
            bSuccess = InitializeFirstTime();
        }
#endif

        if (bSuccess)
            {
#pragma data_seg(DATASEG_READONLY)
            const static TCHAR c_szSyncUI[] = TEXT("SYNCUI");
#pragma data_seg()

            g_hMutexDelay = CreateMutex(NULL, FALSE, c_szSyncUI);
            bSuccess = (NULL != g_hMutexDelay);
            }
        }
    LEAVEEXCLUSIVE()

    if (bSuccess)
        {
        // (Only do this if we succeeded above)
        //
        // Do the following for every process
        bSuccess = InitWindowClasses(hDll);
        }

    InitGlobalColors();
    InitGlobalStrings();

    return bSuccess;
    }


/*----------------------------------------------------------
Purpose: Detach a process from the DLL
Returns: --
Cond:    --
*/
BOOL ProcessDetach(HINSTANCE hDll)
    {
    BOOL bSuccess = TRUE;

    ENTEREXCLUSIVE()
        {
        ASSERT(hDll == g_hinst);

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Process Detach [%d] (hDll = %lx)"),
            g_cProcesses, hDll-1); )

        DEBUG_CODE( DEBUG_BREAK(BF_ONPROCESSDET); )

        ASSERT(0 == g_cRefMutex);

        if (g_hMutexDelay)
            {
            CloseHandle(g_hMutexDelay);
            g_hMutexDelay = NULL;
            }

        if (0 == --g_cProcesses)
            {
            FinalTerminate(g_hinst);
            }

        ReleaseDesktopShellFolder();

        Sync_ReleaseVTable();
        }
    LEAVEEXCLUSIVE()

    if (g_cProcesses == 0)
        {
        DeleteCriticalSection(&g_csSyncUI);
        }

    DeleteCriticalSection(&s_csDelay);

    TermWindowClasses(hDll);

    return bSuccess;
    }


/*----------------------------------------------------------
Purpose: Win32 Libmain
Returns: --
Cond:    --
*/
BOOL APIENTRY LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
    {


    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:
        ProcessAttach(hDll);
#ifndef DEBUG
        DisableThreadLibraryCalls(hDll);
#endif
        break;

    case DLL_PROCESS_DETACH:
        ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:

#ifdef DEBUG

        ENTEREXCLUSIVE()
            {
            // We do this simply to load the debug .ini flags
            //
            ProcessIniFile();

            TRACE_MSG(TF_GENERAL, TEXT("Thread Attach [%d] (hDll = %lx)"),
                      g_cProcesses, hDll);
            }
        LEAVEEXCLUSIVE()

        DEBUG_BREAK(BF_ONTHREADATT);

#endif

        break;

    case DLL_THREAD_DETACH:

#ifdef DEBUG

        ENTEREXCLUSIVE()
            {
            TRACE_MSG(TF_GENERAL, TEXT("Thread Detach [%d] (hDll = %lx)"),
                g_cProcesses, hDll);
            }
        LEAVEEXCLUSIVE()

        DEBUG_BREAK(BF_ONTHREADDET);

#endif

        break;

    default:
        break;
        }

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Registers property sheet and context menu extensions
         for the briefcase.

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RegisterShellExtension(void)
    {
#pragma data_seg(DATASEG_READONLY)
    const static TCHAR c_szPage[] = STRREG_SHEX_PROPSHEET TEXT("\\BriefcasePage");
    const static TCHAR c_szCM[] = STRREG_SHEX_MENUHANDLER TEXT("\\BriefcaseMenu");
    const static TCHAR c_szFolder[] = TEXT("Folder");
    const static TCHAR c_szStar[] = TEXT("*");
    const static TCHAR c_szFmt[] = TEXT("SOFTWARE\\Classes\\%s\\%s");
#pragma data_seg(DATASEG_PERINSTANCE)
    // This must be per instance, else it will cause a fixup in
    // shared data segment.
    const static LPCTSTR rgpsz[2] = { c_szFolder, c_szStar };
#pragma data_seg()
    TCHAR sz[MAXBUFLEN];
    int i;

    for (i = 0; i < ARRAYSIZE(rgpsz); i++)
        {
        // Add briefcase page extension
        wsprintf(sz, c_szFmt, (LPCTSTR)rgpsz[i], (LPCTSTR)c_szPage);
        RegSetValue(HKEY_LOCAL_MACHINE, sz, REG_SZ, c_szCLSID, lstrlen(c_szCLSID));

        // Add briefcase context menu extension
        wsprintf(sz, c_szFmt, (LPCTSTR)rgpsz[i], (LPCTSTR)c_szCM);
        RegSetValue(HKEY_LOCAL_MACHINE, sz, REG_SZ, c_szCLSID, lstrlen(c_szCLSID));
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Create a briefcase at the specified location.

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE CreateTheBriefcase(
    HWND hwnd,
    LPCTSTR pszNewPath)
    {
    BOOL bRet = FALSE;
    TCHAR szParent[MAX_PATH];
    TCHAR szTmp[MAX_PATH];

    DEBUG_CODE( TRACE_MSG(TF_ALWAYS, TEXT("Creating %s"), (LPCTSTR)pszNewPath); )

    // We do not allow briefcases to be created inside other briefcases.

    lstrcpy(szParent, pszNewPath);
    PathRemoveFileSpec(szParent);

    // Is this inside another briefcase?
    if (PL_FALSE != PathGetLocality(szParent, szTmp))
        {
        // Yes; don't do it!
        MsgBox(hwnd,
                MAKEINTRESOURCE(IDS_ERR_CREATE_INANOTHER),
                MAKEINTRESOURCE(IDS_CAP_CREATE),
                NULL,GUID_NULL,NULL,
                MB_WARNING);
        }
    else if (CreateDirectory(pszNewPath, NULL))
        {
        // Mark the briefcase as a system directory
        //
        if (!SetFileAttributes(pszNewPath, FILE_ATTRIBUTE_READONLY))
            {
            TRACE_MSG(TF_ALWAYS, TEXT("Cannot make %s a system directory"), (LPCTSTR)pszNewPath);
            RemoveDirectory(pszNewPath);

            MsgBox(hwnd,
                    MAKEINTRESOURCE(IDS_ERR_CANTCREATEBC),
                    MAKEINTRESOURCE(IDS_CAP_CREATE),
                    NULL,GUID_NULL,NULL,
                    MB_ERROR,
                    pszNewPath);
            }
        else
            {
#pragma data_seg(DATASEG_READONLY)
            const static TCHAR c_szConfirmFileOp[] = TEXT("ConfirmFileOp");
#pragma data_seg()
            HBRFCASE hbrf;
            TWINRESULT tr;
            LPCTSTR pszDBName;
            DECLAREHOURGLASS;

            if (PathsTooLong(pszNewPath, c_szDesktopIni) ||
                PathsTooLong(pszNewPath, g_szDBName) ||
                PathsTooLong(pszNewPath, g_szDBNameShort))
                {
                MsgBox(hwnd,
                        MAKEINTRESOURCE(IDS_ERR_CREATE_TOOLONG),
                        MAKEINTRESOURCE(IDS_CAP_CREATE),
                        NULL,GUID_NULL,NULL,
                        MB_ERROR);
                }
            else
                {
                // Write in the desktop.ini the briefcase class ID
                PathCombine(szTmp, pszNewPath, c_szDesktopIni);
                // (First, flush the cache to make sure the desktop.ini
                // file is really created.)
                WritePrivateProfileString(NULL, NULL, NULL, szTmp);
                WritePrivateProfileString(STRINI_CLASSINFO, c_szIniKeyCLSID, c_szCLSID, szTmp);
                WritePrivateProfileString(STRINI_CLASSINFO, c_szConfirmFileOp, TEXT("0"), szTmp);

                // Make wizard run the first time it is opened.
                WritePrivateProfileString(STRINI_CLASSINFO, c_szRunWizard, TEXT("1"), szTmp);

                // Hide the desktop.ini since the shell does not selectively
                // hide it.
                if (!SetFileAttributes(szTmp, FILE_ATTRIBUTE_HIDDEN))
                    {
                    TRACE_MSG(TF_ALWAYS, TEXT("Cannot hide %s"), (LPCTSTR)szTmp);
                    }

                RegisterShellExtension();

                PathNotifyShell(pszNewPath, NSE_MKDIR, TRUE);

                // Create the database file
                SetHourglass();

                if (IsLFNDrive(pszNewPath))
                    pszDBName = g_szDBName;
                else
                    pszDBName = g_szDBNameShort;

                PathCombine(szTmp, pszNewPath, pszDBName);
                if (Sync_QueryVTable())
                    {
                    tr = Sync_OpenBriefcase(szTmp,
                                            OB_FL_OPEN_DATABASE | OB_FL_TRANSLATE_DB_FOLDER | OB_FL_ALLOW_UI,
                                            hwnd,
                                            &hbrf);
                    if (TR_SUCCESS == tr)
                        {
                        // (Don't really care about errors here)
                        Sync_SaveBriefcase(hbrf);
                        Sync_CloseBriefcase(hbrf);
                        }
                    }
                ResetHourglass();

                bRet = TRUE;
                }
            }
        }
    else
        {
        // Could not create the directory.  Is it because a briefcase
        // already exists at this location?
        if (PathExists(pszNewPath))
            {
            // Yes
            TRACE_MSG(TF_ALWAYS, TEXT("Briefcase already exists at this location: %s"), (LPCTSTR)pszNewPath);
            }
        else
            {
            // No
            MsgBox(hwnd,
                    MAKEINTRESOURCE(IDS_ERR_CANTCREATEBC),
                    MAKEINTRESOURCE(IDS_CAP_CREATE),
                    NULL,GUID_NULL,NULL,
                    MB_ERROR,
                    pszNewPath);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Adds the briefcase at pszPath to the SendTo folder

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE AddBriefcaseToSendToFolder(
    HWND hwnd,
    LPCTSTR pszPath)
    {
    HRESULT hres = E_OUTOFMEMORY;
    LPDATAOBJECT pdtobj;
    LPITEMIDLIST pidl;
    TCHAR szSendTo[MAX_PATH];

    Shell_GetImageLists( NULL, NULL ); // make sure icon cache is around

    if (SHGetSpecialFolderPath(hwnd, szSendTo, CSIDL_SENDTO, FALSE))
        {
        pidl = ILCreateFromPath(pszPath);
        if (pidl)
            {
            LPITEMIDLIST pidlParent = ILClone(pidl);
            if (pidlParent)
                {
                IShellFolder * psf;
                IShellFolder * psfDesktop;

                ILRemoveLastID(pidlParent);

                psfDesktop = GetDesktopShellFolder();
                hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlParent,
                            NULL, &IID_IShellFolder, &psf);

                if (SUCCEEDED(hres))
                    {
                    LPCITEMIDLIST pidlName = ILFindLastID(pidl);

                    hres = psf->lpVtbl->GetUIObjectOf(psf, hwnd, 1,
                                  &pidlName, &IID_IDataObject, NULL, &pdtobj);
                    if (SUCCEEDED(hres))
                        {
                        SHCreateLinks(hwnd, szSendTo, pdtobj, 0, NULL);
                        pdtobj->lpVtbl->Release(pdtobj);
                        }
                    psf->lpVtbl->Release(psf);
                    }
                ILFree(pidlParent);
                }
            ILFree(pidl);
            }
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a briefcase folder on the desktop.
Returns: --
Cond:    --
*/
void WINAPI _export Briefcase_Create_Common(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPTSTR pszCmdLine,
    int nCmdShow)
    {
    DEBUG_CODE( DEBUG_BREAK(BF_ONRUNONCE); )

    // Command line should be of format "xxxx path" where <path>
    // is the fully qualified pathname of the briefcase to create,
    // and <xxxx> is the explorer hwnd.

    if (pszCmdLine && *pszCmdLine)
        {
        LPTSTR psz;
        HWND hwndCabinet;

        // Get hwnd
        hwndCabinet = (HWND)AnsiToInt(pszCmdLine);
        psz = StrChr(pszCmdLine, TEXT(' '));
        psz = CharNext(psz);        // skip over space token

        if (CreateTheBriefcase(hwnd, psz))
            {
            // Select the newly created item to edit it
            LPITEMIDLIST pidl;

            pidl = ILCreateFromPath(psz);
            if (pidl)
                {
                SelectItemInCabinet(hwndCabinet, ILFindLastID(pidl), TRUE);
                ILFree(pidl);
                }
            }
        }
    else
        {
        // Place it on the desktop
        TCHAR szPath[MAX_PATH];

        if (SHGetSpecialFolderPath(hwnd, szPath, CSIDL_DESKTOPDIRECTORY, FALSE))
            {
            int cch;
            UINT ids;

            if (IsLFNDrive(szPath))
                ids = IDS_BC_NAME;
            else
                ids = IDS_BC_NAME_SHORT;

            lstrcat(szPath, TEXT("\\"));
            cch = lstrlen(szPath);
            LoadString(g_hinst, ids, &szPath[cch], ARRAYSIZE(szPath)-cch);
            if (CreateTheBriefcase(hwnd, szPath))
                {
                // Add a shortcut of this briefcase to the SendTo folder
                AddBriefcaseToSendToFolder(hwnd, szPath);
                }
            }
        }
    }

void WINAPI _export Briefcase_Create(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPSTR pszCmdLine,
    int nCmdShow)
    {
#ifdef UNICODE
    UINT iLength = lstrlenA(pszCmdLine)+1;
    LPWSTR lpwszCmdLine;

    lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR, iLength *SIZEOF(TCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            pszCmdLine, -1,
                            lpwszCmdLine, iLength);

        Briefcase_Create_Common(hwnd, hAppInstance, lpwszCmdLine, nCmdShow);
        LocalFree((HANDLE)lpwszCmdLine);
    }
#else
    Briefcase_Create_Common(hwnd, hAppInstance, pszCmdLine, nCmdShow);
#endif
    }

void WINAPI _export Briefcase_CreateW(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPWSTR pwszCmdLine,
    int nCmdShow)
    {
#ifdef UNICODE
    Briefcase_Create_Common(hwnd, hAppInstance, pwszCmdLine, nCmdShow);
#else
    UINT iLength = WideCharToMultiByte(CP_ACP, 0,
                                       pwszCmdLine, -1,
                                       NULL, 0, 0, 0)+1;
    LPSTR lpszCmdLine;

    lpszCmdLine = (LPSTR)LocalAlloc(LPTR, iLength);
    if (lpszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            pwszCmdLine, -1,
                            lpszCmdLine, iLength);

        Briefcase_Create_Common(hwnd, hAppInstance, lpszCmdLine, nCmdShow);
        LocalFree((HANDLE)lpszCmdLine);
    }
#endif
    }




/*----------------------------------------------------------
Purpose: Display the introduction "wizard".  (It's really not
         a wizard since it is not making anything for us.)

  NOTE: This function serves double duty for both the ansi and unicode
        versions. It never uses the command line.

Returns: --
Cond:    --
*/
void WINAPI _export Briefcase_Intro(
    HWND hwnd,
    HINSTANCE hAppInstance,
    LPTSTR lpszCmdLine,
    int nCmdShow)
    {
    Intro_DoModal(hwnd);
    }


//---------------------------------------------------------------------------
// DLL entry-points
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: This function is called back from within
         IClassFactory::CreateInstance() of the default class
         factory object, which is created by SHCreateClassObject.

Returns: standard
Cond:    --
*/
HRESULT CALLBACK DllFactoryCallback(
    LPUNKNOWN punkOuter,        // Should be NULL for us
    REFIID riid,
    LPVOID * ppvOut)
    {
    HRESULT hres;

    if (IsEqualIID(riid, &IID_IShellExtInit))
        {
        hres = BriefExt_CreateInstance(punkOuter, riid, ppvOut);
        }
    else if (IsEqualIID(riid, &IID_IBriefcaseStg) || 
		IsEqualIID(riid, &IID_IBriefcaseStg2))
        {
        hres = BriefStg_CreateInstance(punkOuter, riid, ppvOut);
        }
    else
        {
        hres = ResultFromScode(E_NOINTERFACE);
        *ppvOut = NULL;
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Standard OLE 2.0 entry-point

Returns: standard
Cond:    --
*/
STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppvOut)
    {
    HRESULT hres;

    if (IsEqualIID(rclsid, &CLSID_Briefcase))
        {
        // We are supposed return the class object for this class. Instead
        // of fully implementing it in this DLL, we just call a helper
        // function in the shell DLL which creates a default class factory
        // object for us. When its CreateInstance member is called, it
        // will call back our create instance function.
        hres = SHCreateDefClassObject(
                    riid,                   // Interface ID
                    ppvOut,                 // Non-null to aggregate
                    DllFactoryCallback,     // callback function
                    &g_cBusyRef,            // reference count of this DLL
                    NULL);                  // init interface
        }
    else
        {
        hres = ResultFromScode(REGDB_E_CLASSNOTREG);
        *ppvOut = NULL;
        }

    return hres;
    }




/*----------------------------------------------------------
Purpose: "Can Unload Now" entry point.  Called by the shell DLL
          task handler list.
Returns: S_OK to unload
Cond:    --
*/
STDAPI DllCanUnloadNow(void)
    {
    HRESULT hr;

    // We only unload when:
    //  2) We are not busy processing anything else *and*
    //  3) No briefcases are currently open
    //
    ENTEREXCLUSIVE()
        {
        if (!IsBusySemaphore() &&
            !IsOpenBriefSemaphore())
            {
            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("DllCanUnloadNow says OK (Busy=%d, Brief=%d)"),
                g_cBusyRef, g_cBriefRef); )

            hr = ResultFromScode(S_OK);
            }
        else
            {
            DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("DllCanUnloadNow says FALSE (Busy=%d, Brief=%d)"),
                g_cBusyRef, g_cBriefRef); )

            hr = ResultFromScode(S_FALSE);
            }
        }
    LEAVEEXCLUSIVE()

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\path.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: path.c
//
//  This files contains the path whacking code.
//
// History:
//  01-31-94 ScottH     Moved from shellext.c
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "res.h"




/*----------------------------------------------------------
Purpose: Removes the trailing backslash from a path.

         A:\            -->     A:\
         C:\foo\        -->     C:\foo
         \\Pyrex\User\  -->     \\Pyrex\User

Returns: pointer to NULL that replaced the backslash or
         the pointer to the last character if it isn't 
         a backslash

Cond:    pimped this code from the shell
*/
LPTSTR PUBLIC MyPathRemoveBackslash(
    LPTSTR lpszPath)
    {
    int len = lstrlen(lpszPath)-1;
    if (IsDBCSLeadByte(*CharPrev(lpszPath,lpszPath+len+1)))
        len--;

    if (!PathIsRoot(lpszPath) && lpszPath[len] == TEXT('\\'))
        lpszPath[len] = TEXT('\0');

    return lpszPath + len;
    }


#ifdef NOTUSED
/*----------------------------------------------------------
Purpose: copies the path without the extension into the buffer

Returns: new path
Cond:    --
*/
LPTSTR PUBLIC PathRemoveExt(
    LPCTSTR pszPath,
    LPTSTR pszBuf)
    {
    LPTSTR psz;
    LPTSTR pszMark = NULL;

    ASSERT(pszPath);
    ASSERT(pszBuf);

    psz = pszBuf;
    while (*pszPath)
        {
        *psz = *pszPath;
        pszPath = CharNext(pszPath);
        if (TEXT('.') == *psz)
            pszMark = psz;
        else if (TEXT('\\') == *psz)
            pszMark = NULL;
        psz = CharNext(psz);
        }
    *psz = TEXT('\0');

    if (pszMark)
        *pszMark = TEXT('\0');

    return pszBuf;
    }
#endif


/*----------------------------------------------------------
Purpose: Convert a file spec to make it look a bit better
         if it is all upper case chars.

Returns: --
Cond:    --
*/
BOOL PRIVATE PathMakeComponentPretty(LPTSTR lpPath)
{
    LPTSTR lp;

    // REVIEW: INTL need to deal with lower case chars in (>127) range?

    // check for all uppercase
    for (lp = lpPath; *lp; lp = CharNext(lp)) {
        if ((*lp >= TEXT('a')) && (*lp <= TEXT('z')))
            return FALSE;       // this is a LFN, dont mess with it
    }

    CharLower(lpPath);
    CharUpperBuff(lpPath, 1);
    return TRUE;        // did the conversion
}


//---------------------------------------------------------------------------
// Given a pointer to a point in a path - return a ptr the start of the
// next path component. Path components are delimted by slashes or the
// null at the end.
// There's special handling for UNC names.
// This returns NULL if you pass in a pointer to a NULL ie if you're about
// to go off the end of the  path.
LPTSTR PUBLIC PathFindNextComponentI(LPCTSTR lpszPath)
{
    LPTSTR lpszLastSlash;

    // Are we at the end of a path.
    if (!*lpszPath)
    {
        // Yep, quit.
        return NULL;
    }
    // Find the next slash.
    // REVIEW UNDONE - can slashes be quoted?
    lpszLastSlash = StrChr(lpszPath, TEXT('\\'));
    // Is there a slash?
    if (!lpszLastSlash)
    {
        // No - Return a ptr to the NULL.
        return (LPTSTR) (lpszPath+lstrlen(lpszPath));
    }
    else
    {
        // Is it a UNC style name?
        if (TEXT('\\') == *(lpszLastSlash+1))
        {
            // Yep, skip over the second slash.
            return lpszLastSlash+2;
        }
        else
        {
            // Nope. just skip over one slash.
            return lpszLastSlash+1;
        }
    }
}


/*----------------------------------------------------------
Purpose: Takes the path and makes it presentable.

         The rules are:
            If the LFN name is simply the short name (all caps),
             then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
*/
void PUBLIC PathMakePresentable(
    LPTSTR pszPath)
    {
    LPTSTR pszComp;          // pointers to begining and
    LPTSTR pszEnd;           //  end of path component
    LPTSTR pch;
    int cComponent = 0;
    BOOL bUNCPath;
    TCHAR ch;

    bUNCPath = PathIsUNC(pszPath);

    pszComp = pszPath;
    while (pszEnd = PathFindNextComponentI(pszComp))
        {
        // pszEnd may be pointing to the right of the backslash
        //  beyond the path component, so back up one
        //
        ch = *pszEnd;
        *pszEnd = 0;        // temporary null

        // pszComp points to the path component
        //
        pch = CharNext(pszComp);
        if (TEXT(':') == *pch)
            {
            // Simply capitalize the drive-portion of the path
            //
            CharUpper(pszComp);
            }
        else if (bUNCPath && cComponent++ < 3)
            {
            // Network server or share name
            //
            CharUpper(pszComp);
            PathMakeComponentPretty(pszComp);
            }
        else
            {
            // Normal path component
            //
            PathMakeComponentPretty(pszComp);
            }

        *pszEnd = ch;
        pszComp = pszEnd;
        }
    }


#ifdef NOTUSED
/*----------------------------------------------------------
Purpose: Takes the path and pretties up each component of
         the path.

         The rules are:
            Use the LFN name of the component
            If the LFN name is simply the short name (all caps),
             then convert to lowercase with first letter capitalized

Returns: --
Cond:    --
*/
void PRIVATE PathGetCompleteLFN(
    LPCTSTR pszPath,
    LPTSTR pszLong,
    int cbLong)
    {
    TCHAR sz[MAX_PATH];
    TCHAR szPath[MAX_PATH+1];
    LPTSTR pszComp;         // pointers to begining and end of path component
    LPTSTR pszEnd;
    int cbPath;
    int cb;
    BOOL bAtEnd = FALSE;
    int cComponent = 0;
    BOOL bUNCPath;
    TCHAR ch;


    // For each component in string, get the LFN and add it to
    //  the pszLong buffer.
    //

    cbPath = lstrlen(pszPath) * sizeof(TCHAR);
    ASSERT(cbPath+1 <= sizeof(szPath));
    lstrcpy(szPath, pszPath);

    bUNCPath = PathIsUNC(szPath);

    *pszLong = NULL_CHAR;
    cb = 0;

    pszComp = szPath;
    while (pszEnd = PathFindNextComponentI(pszComp))
        {
        // pszEnd may be pointing to the right of the backslash beyond the
        //  path component, so back up one
        //
        if (0 == *pszEnd)
            bAtEnd = TRUE;
        else
            {
            if (!bUNCPath || cComponent > 0)
                pszEnd--;       // not the server or share portions of a UNC path
            ch = *pszEnd;
            *pszEnd = 0;        // temporary null
            }

        // pszComp points to the path component now
        //
        if (TEXT(':') == *(pszEnd-1) || TEXT(':') == *(pszEnd-2))
            {
            // Simply capitalize the drive-portion of the path
            //
            CharUpper(szPath);
            }
        else if (bUNCPath && cComponent++ < 3)
            {
            // Network server or share name
            //
            CharUpper(pszComp);
            PathMakeComponentPretty(pszComp);
            }
        else
            {
            int ib;

            // Try to get the LFN
            //
            *sz = NULL_CHAR;
            PathGetLongName(szPath, sz, ARRAYSIZE(sz));

            // If an LFN does not exist, keep the path component
            //  as it is. (Sometimes the path component can be
            //  something like "Link to Foo.txt")
            //
            if (*sz)
                {
                // Make pszComp point to the same offset in sz now
                //  (the components in each are the same offsets)
                //
                ib = pszComp - (LPTSTR)szPath;
                pszComp = &sz[ib];
                }
            PathMakeComponentPretty(pszComp);
            }

        // Save new LFN-ized component to buffer
        //
        cb += lstrlen(pszComp) * sizeof(TCHAR);
        if (cbLong <= cb)
            break;      // reached end of pszLong buffer
        lstrcat(pszLong, pszComp);
        if (!bAtEnd)
            {
            PathAddBackslash(pszLong);
            *pszEnd = ch;
            if (bUNCPath && 1 == cComponent)
                pszComp = pszEnd;   // pointing to share portion of path
            else
                pszComp = pszEnd+1; // Move component pointer to next part
            }
        else
            pszComp = pszEnd;
        }
    }
#endif


/*----------------------------------------------------------
Purpose: Returns TRUE if the combined path of pszFolder and
         pszName is greater than MAX_PATH.

Returns: see above
Cond:    --
*/
BOOL PUBLIC PathsTooLong(
    LPCTSTR pszFolder,
    LPCTSTR pszName)
    {
    // +1 for possible '\' between the two path components
    return lstrlen(pszFolder) + lstrlen(pszName) + 1 >= MAX_PATH;
    }


/*----------------------------------------------------------
Purpose: Fully qualifies a path
Returns: --
Cond:    --
*/
void PUBLIC BrfPathCanonicalize(
    LPCTSTR pszPath,
    LPTSTR pszBuf)           // Must be sizeof(MAX_PATH)
    {
    DWORD dwcPathLen;

    dwcPathLen = GetFullPathName(pszPath, MAX_PATH, pszBuf, NULL);

    if (! dwcPathLen || dwcPathLen >= MAX_PATH)
        lstrcpy(pszBuf, pszPath);

    // If pszBuf won't cover losslessly to ANSI, use the short name instead

    #if defined(UNICODE) 
    {
        CHAR szAnsi[MAX_PATH];
        WCHAR szUnicode[MAX_PATH];
        szUnicode[0] = L'\0';
 
        WideCharToMultiByte(CP_ACP, 0, pszBuf, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
        MultiByteToWideChar(CP_ACP, 0, szAnsi,   -1, szUnicode, ARRAYSIZE(szUnicode));
        if (lstrcmp(szUnicode, pszBuf))
        {
            // Cannot convert losslessly from Unicode -> Ansi, so get the short path

            lstrcpy(szUnicode, pszBuf);
            SheShortenPath(szUnicode, TRUE);
            lstrcpy(pszBuf, szUnicode);
        }
   }
   #endif

    PathMakePresentable(pszBuf);

    ASSERT(lstrlen(pszBuf) < MAX_PATH);
    }


/*----------------------------------------------------------
Purpose: Gets the displayable filename of the path.  The filename 
         is placed in the provided buffer.  
         
Returns: pointer to buffer
Cond:    --
*/
LPTSTR PUBLIC PathGetDisplayName(
    LPCTSTR pszPath,
    LPTSTR pszBuf)
    {
    SHFILEINFO sfi;

    if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME))
        lstrcpy(pszBuf, sfi.szDisplayName);
    else
        lstrcpy(pszBuf, PathFindFileName(pszPath));

    return pszBuf;
    }


/*----------------------------------------------------------
Purpose: Checks if the attributes of the path.  If it is a
         directory and has the system bit set, and if the brfcase.dat
         file exists in the directory, then return TRUE.

         Worst case: performs two GetFileAttributes.

Returns: see above
Cond:    --
*/
BOOL PUBLIC PathCheckForBriefcase(
    LPCTSTR pszPath,
    DWORD dwAttrib)     // if -1, then function gets the attributes
    {
    ASSERT(pszPath);

    if (0xFFFFFFFF == dwAttrib)
        {
        dwAttrib = GetFileAttributes(pszPath);
        if (0xFFFFFFFF == dwAttrib)
            return FALSE;
        }

    if (IsFlagSet(dwAttrib, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_READONLY) ||
        IsFlagSet(dwAttrib, FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM))
        {
        TCHAR szT[MAX_PATH];
        LPCTSTR pszDBName;

        // Check for the existence of the brfcase.dat file.
        //
        if (IsLFNDrive(pszPath))
            pszDBName = g_szDBName;
        else
            pszDBName = g_szDBNameShort;

        if (PathsTooLong(pszPath, pszDBName))
            return FALSE;
        else
            {
            PathCombine(szT, pszPath, pszDBName);
            return PathExists(szT);
            }
        }

    return FALSE;
    }


/*----------------------------------------------------------
Purpose: Returns TRUE if the path is to a briefcase root.

         This function may hit the file-system to achieve
         its goal.

         Worst case: performs two GetFileAttributes.

Returns: TRUE if the path refers to a briefcase root.
Cond:    --
*/
BOOL PUBLIC PathIsBriefcase(
    LPCTSTR pszPath)
    {
    UINT uRet;

    ASSERT(pszPath);

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, NULL);
    if (PL_FALSE == uRet)
        {
        uRet = PathCheckForBriefcase(pszPath, (DWORD)-1) ? PL_ROOT : PL_FALSE;

        if (PL_ROOT == uRet)
            {
            int atom;

            // Add this path to the briefcase path cache.
            //
            atom = Atom_Add(pszPath);
            if (ATOM_ERR != atom)
                CPATH_Replace(atom);
            }
        }

    return PL_ROOT == uRet;
    }


/*----------------------------------------------------------
Purpose: Gets the locality of the path, relative to any
         briefcase.  If PL_ROOT or PL_INSIDE is returned,
         pszBuf will contain the path to the root of the
         briefcase.

         This function may hit the file-system to achieve
         its goal.

         Worst case: performs 2*n GetFileAttributes, where
         n is the number of components in pszPath.

Returns: Path locality (PL_FALSE, PL_ROOT, PL_INSIDE)

Cond:    --
*/
UINT PUBLIC PathGetLocality(
    LPCTSTR pszPath,
    LPTSTR pszBuf)       // Buffer for root path
    {
    UINT uRet;

    ASSERT(pszPath);
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;

    // pszPath may be:
    //  1) a path to the briefcase folder itself
    //  2) a path to a file or folder beneath the briefcase
    //  3) a path to something unrelated to a briefcase

    // We perform our search by first looking in our cache
    // of known briefcase paths (CPATH).  If we don't find
    // anything, then we proceed to iterate thru each
    // component of the path, checking for these two things:
    //
    //   1) A directory with the system attribute
    //   2) The existence of a brfcase.dat file in the directory.
    //
    uRet = CPATH_GetLocality(pszPath, pszBuf);
    if (PL_FALSE == uRet)
        {
        int cnt = 0;

        lstrcpy(pszBuf, pszPath);
        do
            {
            if (PathCheckForBriefcase(pszBuf, (DWORD)-1))
                {
                int atom;

                uRet = cnt > 0 ? PL_INSIDE : PL_ROOT;

                // Add this briefcase path to our cache
                //
                atom = Atom_Add(pszBuf);
                if (ATOM_ERR != atom)
                    CPATH_Replace(atom);

                break;      // Done
                }

            cnt++;

            } while (PathRemoveFileSpec(pszBuf));

        if (PL_FALSE == uRet)
            *pszBuf = NULL_CHAR;
        }

    return uRet;
    }


/*----------------------------------------------------------
Purpose: Returns TRUE if the file/directory exists.

Returns: see above
Cond:    --
*/
BOOL PUBLIC PathExists(
    LPCTSTR pszPath)
    {
    return GetFileAttributes(pszPath) != 0xFFFFFFFF;
    }


/*----------------------------------------------------------
Purpose: Finds the end of the root specification in a path.

           input path                    output string
           ----------                    -------------
           c:                            <empty string>
           c:\                           <empty string>
           c:\foo                        foo
           c:\foo\bar                    foo\bar
           \\pyrex\user                  <empty string>
           \\pyrex\user\                 <empty string>
           \\pyrex\user\foo              foo
           \\pyrex\user\foo\bar          foo\bar

Returns: pointer to first character after end of root spec.

Cond:    --
*/
LPCTSTR PUBLIC PathFindEndOfRoot(
    LPCTSTR pszPath)
    {
    LPCTSTR psz;

    ASSERT(pszPath);

    if (TEXT(':') == pszPath[1])
        {
        if (TEXT('\\') == pszPath[2])
            psz = &pszPath[3];
        else
            psz = &pszPath[2];
        }
    else if (PathIsUNC(pszPath))
        {
        psz = PathFindNextComponentI(pszPath);  // hop double-slash
        psz = PathFindNextComponentI(psz);      // hop server name
        if (psz)
            psz = PathFindNextComponentI(psz);  // hop share name

        if (!psz)
            {
            ASSERT(0);      // There is no share name
            psz = pszPath;
            }
        }
    else
        {
        ASSERT(0);
        psz = pszPath;
        }

    return psz;
    }


/*----------------------------------------------------------
Purpose: Determines whether or not one path is a prefix of another.
         Stole this from DavidDi's twincore.
Returns: TRUE if second path is a prefix of the first path
Cond:    --
*/
BOOL PUBLIC PathIsPrefix(
    LPCTSTR lpcszInPath1,      // whole path (longer or same length)
    LPCTSTR lpcszInPath2)      // prefix path (shorter or same length)
    {
    BOOL bIsPrefix = FALSE;
    int nLen1;
    int nLen2;
    TCHAR szPath1[MAX_PATH];
    TCHAR szPath2[MAX_PATH];

    ASSERT(lpcszPath1);
    ASSERT(lpcszPath2);

    // We could wind up comparing a short path to an LFN path here,
    // yielding erronerous results, so convert both to short paths
    // to ensure we're comparing apples to apples.

    lstrcpyn(szPath1, lpcszInPath1, MAX_PATH);
    SheShortenPath(szPath1, TRUE);
    lstrcpyn(szPath2, lpcszInPath2, MAX_PATH);
    SheShortenPath(szPath2, TRUE);

    nLen1 = lstrlen(szPath1);
    nLen2 = lstrlen(szPath2);

    /* Is the prefix string shorter or the same length? */

    if (nLen1 >= nLen2)
        {
        /*
        * Yes.  Do the two strings match through the length of the prefix
        * string?
        */

        if (! lstrnicmp(szPath1, szPath2, nLen2))
            {
            /*
             * Yes.  Is the prefix of the longer string followed immediately by
             * a null terminator or a path separator?
             */

            if (! szPath1[nLen2] ||
                szPath1[nLen2] == TEXT('\\') ||
                *(CharPrev(szPath2, szPath2 + lstrlen(szPath2))) == TEXT('\\'))
                /* Yes. */
                bIsPrefix = TRUE;
            }
        }

    return(bIsPrefix);
    }


/*----------------------------------------------------------
Purpose: Sends a notify message to the shell regarding a file-status
         change.
Returns: --
Cond:    --
*/
void PUBLIC PathNotifyShell(
    LPCTSTR pszPath,
    NOTIFYSHELLEVENT nse,
    BOOL bDoNow)        // TRUE: force the event to be processed right away
    {
#pragma data_seg(DATASEG_READONLY)

    static LONG const rgShEvents[] = 
      { SHCNE_CREATE, SHCNE_MKDIR, SHCNE_UPDATEITEM, SHCNE_UPDATEDIR };

#pragma data_seg()

    ASSERT(pszPath);
    ASSERT(nse < ARRAYSIZE(rgShEvents));

    SHChangeNotify(rgShEvents[nse], SHCNF_PATH, pszPath, NULL);

    if (bDoNow)
        {
        SHChangeNotify(0, SHCNF_FLUSHNOWAIT, NULL, NULL);
        }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\res.h ===
//
// res.h: Declares data, defines and struct types for common code
//                                module.
//
// This file contains only #define directives, thus it can be
// included in the resource script.
//

#ifndef __RES_H__
#define __RES_H__

/////////////////////////////////////////////////////  DIALOG CONSTANTS
//
// IDD_ naming conventions: IDD_xxdd*
//
// where xx defines the control type:
//   ST: static text            
//   LB: listbox
//   CB: combobox
//   CH: checkbox
//   PB: pushbutton
//   ED: edit control
//   GB: group box
//   RB: radio button
//   IC: icon
//
// and dd is a two-letter initial for the dialog;
// and * is any other qualifier to better explain the name of control.
//


#include "resids.h"
#include "dlgids.h"


#endif // __RES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define _huge
#define _export
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY    TEXT(".text")
#define DATASEG_PERINSTANCE TEXT(".instanc")
#define DATASEG_SHARED      TEXT(".data")

#define GetWindowInt    GetWindowLong
#define SetWindowInt    SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)
#define MCopyIconEx(hinst, hicon, cx, cy, flags) CopyIconEx(hicon, cx, cy, flags)
#define MLoadIconEx(hinst1, hinst2, lpsz, cx, cy, flags) LoadIconEx(hinst2, lpsz, cx, cy, flags)

// This should really be in windowsx.h
//

/* void Cls_OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y) */
#ifndef HANDLE_WM_CONTEXTMENU
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (int)(short)LOWORD(lParam), (int)(short)HIWORD(lParam)), 0L)
#endif 

#ifndef FORWARD_WM_CONTEXTMENU
#define FORWARD_WM_CONTEXTMENU(hwnd, hwndClick, x, y, fn) \
    (void)(fn)((hwnd), WM_CONTEXTMENU, (WPARAM)(HWND)(hwndClick), MAKELPARAM((x), (y)))
#endif

#else  // WIN32

#define ISLPTR(pv)      (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    TEXT("_TEXT")
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED

#define GetWindowInt    GetWindowWord
#define SetWindowInt    SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)

#define MAKEPOINTS(l)     (*((POINTS *)&(l)))

#define MCopyIconEx     CopyIconEx
#define MLoadIconEx     LoadIconEx

// This should really be in windowsx.h
//

/* void Cls_OnContextMenu(HWND hwnd, HWND hwndClick, int x, int y) */
#define HANDLE_WM_CONTEXTMENU(hwnd, wParam, lParam, fn) \
    ((fn)((hwnd), (HWND)(wParam), (int)LOWORD(lParam), (int)HIWORD(lParam)), 0L)
#define FORWARD_WM_CONTEXTMENU(hwnd, hwndClick, x, y, fn) \
    (void)(fn)((hwnd), WM_CONTEXTMENU, (WPARAM)(HWND)(hwndClick), MAKELPARAM((x), (y)))


#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\resids.h ===
//---------------------------------------------------------------------------
// Base values
//---------------------------------------------------------------------------

#define ID_BASE         0x1000
#define IDS_BASE        (ID_BASE + 0x0000)

//---------------------------------------------------------------------------
// Strings
//---------------------------------------------------------------------------

// Range of indexes are 0x000 - 0x7ff
#define IDS_ERR_BASE                    (IDS_BASE + 0x0000)
#define IDS_OOM_BASE                    (IDS_BASE + 0x0800)
#define IDS_MSG_BASE                    (IDS_BASE + 0x1000)
#define IDS_RANDO_BASE                  (IDS_BASE + 0x1800)

// Error strings
#define IDS_ERR_READONLY                (IDS_ERR_BASE + 0x000)
#define IDS_ERR_ADD_SUBTREECYCLE        (IDS_ERR_BASE + 0x003)
#define IDS_ERR_CORRUPTDB               (IDS_ERR_BASE + 0x004)
#define IDS_ERR_SAMEGUYIDIOT            (IDS_ERR_BASE + 0x005)
#define IDS_ERR_BOGUSVOLUME             (IDS_ERR_BASE + 0x006)
#define IDS_ERR_FULLDISK                (IDS_ERR_BASE + 0x007)
#define IDS_ERR_FULLDISKSAVE            (IDS_ERR_BASE + 0x008)
#define IDS_ERR_CANTADDBRIEFCASE        (IDS_ERR_BASE + 0x009)
#define IDS_ERR_BCALREADYEXISTS         (IDS_ERR_BASE + 0x00a)
#define IDS_ERR_CANTCREATEBC            (IDS_ERR_BASE + 0x00b)
#define IDS_ERR_BRIEFCASE_LOCKED        (IDS_ERR_BASE + 0x00c)
#define IDS_ERR_UPD_UNAVAIL_VOL         (IDS_ERR_BASE + 0x00d)
#define IDS_ERR_FILE_CHANGED            (IDS_ERR_BASE + 0x00e)
#define IDS_ERR_SOURCE_FILE             (IDS_ERR_BASE + 0x00f)
#define IDS_ERR_ADDFILE_UNAVAIL_VOL     (IDS_ERR_BASE + 0x010)
#define IDS_ERR_ADDFOLDER_UNAVAIL_VOL   (IDS_ERR_BASE + 0x011)
#define IDS_ERR_NEWER_BRIEFCASE         (IDS_ERR_BASE + 0x012)
#define IDS_ERR_ADD_READONLY            (IDS_ERR_BASE + 0x013)
#define IDS_ERR_ADD_FULLDISK            (IDS_ERR_BASE + 0x014)
#define IDS_ERR_ADD_SOURCE_FILE         (IDS_ERR_BASE + 0x015)
#define IDS_ERR_ADD_UNAVAIL_VOL         (IDS_ERR_BASE + 0x016)
#define IDS_ERR_SAVE_UNAVAIL_VOL        (IDS_ERR_BASE + 0x017)
#define IDS_ERR_CLOSE_UNAVAIL_VOL       (IDS_ERR_BASE + 0x018)
#define IDS_ERR_OPEN_UNAVAIL_VOL        (IDS_ERR_BASE + 0x019)
#define IDS_ERR_UNAVAIL_VOL             (IDS_ERR_BASE + 0x01a)
#define IDS_ERR_OPEN_SUBTREECYCLE       (IDS_ERR_BASE + 0x01b)
#define IDS_ERR_OPEN_ACCESS_DENIED      (IDS_ERR_BASE + 0x01c)
#define IDS_ERR_NO_MERGE_HANDLER        (IDS_ERR_BASE + 0x01d)
#define IDS_ERR_ADDFILE_TOOLONG         (IDS_ERR_BASE + 0x01e)
#define IDS_ERR_ADDFOLDER_TOOLONG       (IDS_ERR_BASE + 0x01f)
#define IDS_ERR_OPEN_TOOLONG            (IDS_ERR_BASE + 0x020)
#define IDS_ERR_CREATE_TOOLONG          (IDS_ERR_BASE + 0x021)
#define IDS_ERR_ADDFILE_TOOMANY         (IDS_ERR_BASE + 0x022)
#define IDS_ERR_ADDFOLDER_TOOMANY       (IDS_ERR_BASE + 0x023)
#define IDS_ERR_ADD_SYNCFOLDER          (IDS_ERR_BASE + 0x024)
#define IDS_ERR_ADD_SYNCFOLDER_SRC      (IDS_ERR_BASE + 0x025)
#define IDS_ERR_CREATE_INANOTHER        (IDS_ERR_BASE + 0x026)

#define IDS_ERR_F_CantSplit             (IDS_ERR_BASE + 0x100)
#define IDS_ERR_1_CantSplit             (IDS_ERR_BASE + 0x101)
#define IDS_ERR_2_CantSplit             (IDS_ERR_BASE + 0x102)

#define IDS_ERR_F_CorruptDB             (IDS_ERR_BASE + 0x104)
#define IDS_ERR_1_CorruptDB             (IDS_ERR_BASE + 0x105)
#define IDS_ERR_2_CorruptDB             (IDS_ERR_BASE + 0x106)

#define IDS_ERR_F_FullDiskSave          (IDS_ERR_BASE + 0x108)
#define IDS_ERR_1_FullDiskSave          (IDS_ERR_BASE + 0x109)
#define IDS_ERR_2_FullDiskSave          (IDS_ERR_BASE + 0x10a)


// Out-of-memory strings
#define IDS_OOM_ADD                     (IDS_OOM_BASE + 0x000)
#define IDS_OOM_CHANGETYPES             (IDS_OOM_BASE + 0x001)
#define IDS_OOM_STATUS                  (IDS_OOM_BASE + 0x002)
#define IDS_OOM_INFO                    (IDS_OOM_BASE + 0x003)
#define IDS_OOM_FILLTYPES               (IDS_OOM_BASE + 0x004)
#define IDS_OOM_UPDATEDIALOG            (IDS_OOM_BASE + 0x005)
#define IDS_OOM_OPENBRIEFCASE           (IDS_OOM_BASE + 0x006)
#define IDS_OOM_UPDATE                  (IDS_OOM_BASE + 0x007)
#define IDS_OOM_ADDFOLDER               (IDS_OOM_BASE + 0x008)


// Messages
#define IDS_MSG_SPECIFYTYPE             (IDS_MSG_BASE + 0x010)
#define IDS_MSG_ONDESKTOP               (IDS_MSG_BASE + 0x011)
#define IDS_MSG_ATPATH                  (IDS_MSG_BASE + 0x012)
#define IDS_MSG_CantFindOriginal        (IDS_MSG_BASE + 0x013)
#define IDS_MSG_ConfirmFileSplit        (IDS_MSG_BASE + 0x014)
#define IDS_MSG_ConfirmFolderSplit      (IDS_MSG_BASE + 0x015)
#define IDS_MSG_ConfirmMultiSplit       (IDS_MSG_BASE + 0x016)
#define IDS_MSG_FileAlreadyOrphan       (IDS_MSG_BASE + 0x017)
#define IDS_MSG_FolderAlreadyOrphan     (IDS_MSG_BASE + 0x018)
#define IDS_MSG_FileTombstone           (IDS_MSG_BASE + 0x019)
#define IDS_MSG_FolderTombstone         (IDS_MSG_BASE + 0x01a)
#define IDS_MSG_UpdateOnDock            (IDS_MSG_BASE + 0x01b)
#define IDS_MSG_UpdateBeforeUndock      (IDS_MSG_BASE + 0x01c)
#define IDS_MSG_NoMatchingFiles         (IDS_MSG_BASE + 0x01d)
#define IDS_MSG_CHECKING                (IDS_MSG_BASE + 0x01e)

#define IDS_MSG_NoFiles                 (IDS_MSG_BASE + 0x040)
#define IDS_MSG_AllOrphans              (IDS_MSG_BASE + 0x041)
#define IDS_MSG_AllUptodate             (IDS_MSG_BASE + 0x042)
#define IDS_MSG_AllSomeUnavailable      (IDS_MSG_BASE + 0x043)

// The file/folder ids below must be interleaved, with the
// folder id = the file id + 1.
#define IDS_MSG_FileOrphan              (IDS_MSG_BASE + 0x044)
#define IDS_MSG_FolderOrphan            (IDS_MSG_BASE + 0x045)
#define IDS_MSG_FileUptodate            (IDS_MSG_BASE + 0x046)
#define IDS_MSG_FolderUptodate          (IDS_MSG_BASE + 0x047)
#define IDS_MSG_FileUnavailable         (IDS_MSG_BASE + 0x048)
#define IDS_MSG_FolderUnavailable       (IDS_MSG_BASE + 0x049)
#define IDS_MSG_FolderSubfolder         (IDS_MSG_BASE + 0x04a)

#define IDS_MSG_MultiOrphans            (IDS_MSG_BASE + 0x050)
#define IDS_MSG_MultiUptodate           (IDS_MSG_BASE + 0x051)
#define IDS_MSG_MultiUptodateOrphan     (IDS_MSG_BASE + 0x052)
#define IDS_MSG_MultiUnavailable        (IDS_MSG_BASE + 0x053)
#define IDS_MSG_MultiSubfolder          (IDS_MSG_BASE + 0x054)


// Menu strings
#define IDS_MENU_REPLACE                (IDS_RANDO_BASE + 0x000)
#define IDS_MENU_CREATE                 (IDS_RANDO_BASE + 0x001)
#define IDS_MENU_WHATSTHIS              (IDS_RANDO_BASE + 0x002)
//#define IDS_MENU_HELPFINDER             (IDS_RANDO_BASE + 0x003)
#define IDS_MENU_UPDATE                 (IDS_RANDO_BASE + 0x004)
#define IDS_MENU_UPDATEALL              (IDS_RANDO_BASE + 0x005)
#define IDS_MENU_SKIP                   (IDS_RANDO_BASE + 0x006)
#define IDS_MENU_MERGE                  (IDS_RANDO_BASE + 0x007)
#define IDS_MENU_DELETE                 (IDS_RANDO_BASE + 0x008)
#define IDS_MENU_DONTDELETE             (IDS_RANDO_BASE + 0x009)

// Captions                             
#define IDS_CAP_ADD                     (IDS_RANDO_BASE + 0x010)
#define IDS_CAP_UPDATE                  (IDS_RANDO_BASE + 0x011)
#define IDS_CAP_INFO                    (IDS_RANDO_BASE + 0x012)
#define IDS_CAP_OPEN                    (IDS_RANDO_BASE + 0x013)
#define IDS_CAP_STATUS                  (IDS_RANDO_BASE + 0x014)
#define IDS_CAP_SAVE                    (IDS_RANDO_BASE + 0x015)
#define IDS_CAP_CREATE                  (IDS_RANDO_BASE + 0x016)
#define IDS_CAP_ReplaceFile             (IDS_RANDO_BASE + 0x017)    // Old
#define IDS_CAP_ReplaceFolder           (IDS_RANDO_BASE + 0x018)
#define IDS_CAP_ConfirmSplit            (IDS_RANDO_BASE + 0x019)
#define IDS_CAP_ConfirmMultiSplit       (IDS_RANDO_BASE + 0x01a)
#define IDS_CAP_Split                   (IDS_RANDO_BASE + 0x01b)
#define IDS_CAP_UpdateFmt               (IDS_RANDO_BASE + 0x01c)
#define IDS_CAP_UPDATING                (IDS_RANDO_BASE + 0x01d)
#define IDS_CAP_CHECKING                (IDS_RANDO_BASE + 0x01e)

// Random stuff
#define IDS_YES                         (IDS_RANDO_BASE + 0x100)
#define IDS_NO                          (IDS_RANDO_BASE + 0x101)
#define IDS_OK                          (IDS_RANDO_BASE + 0x102)
#define IDS_CANCEL                      (IDS_RANDO_BASE + 0x103)
#define IDS_RETRY                       (IDS_RANDO_BASE + 0x104)
#define IDS_YESTOALL                    (IDS_RANDO_BASE + 0x105)

//#define IDS_NoOriginal                  (IDS_RANDO_BASE + 0x110)    // old
#define IDS_InLocation                  (IDS_RANDO_BASE + 0x111)
#define IDS_InBriefcase                 (IDS_RANDO_BASE + 0x112)
#define IDS_BYTES                       (IDS_RANDO_BASE + 0x113)
#define IDS_BOGUSDBTEMPLATE             (IDS_RANDO_BASE + 0x114)
#define IDS_BC_DATABASE                 (IDS_RANDO_BASE + 0x115)
#define IDS_BC_NAME                     (IDS_RANDO_BASE + 0x116)
#define IDS_DATESIZELINE                (IDS_RANDO_BASE + 0x117)
#define IDS_ORDERKB                     (IDS_RANDO_BASE + 0x118)
#define IDS_ORDERMB                     (IDS_RANDO_BASE + 0x119)
#define IDS_ORDERGB                     (IDS_RANDO_BASE + 0x11a)
#define IDS_ORDERTB                     (IDS_RANDO_BASE + 0x11b)
#define IDS_BC_DATABASE_SHORT           (IDS_RANDO_BASE + 0x11c)
#define IDS_BC_NAME_SHORT               (IDS_RANDO_BASE + 0x11d)
#define IDS_ALTNAME                     (IDS_RANDO_BASE + 0x11e)

// Status Property sheet
#define IDS_STATPROP_SubfolderTwin      (IDS_RANDO_BASE + 0x300)
#define IDS_STATPROP_OrphanFolder       (IDS_RANDO_BASE + 0x301)
#define IDS_STATPROP_OrphanFile         (IDS_RANDO_BASE + 0x302)
#define IDS_STATPROP_Uptodate           (IDS_RANDO_BASE + 0x303)
#define IDS_STATPROP_PressButton        (IDS_RANDO_BASE + 0x304)
#define IDS_STATPROP_Unavailable        (IDS_RANDO_BASE + 0x305)
#define IDS_STATPROP_Update             (IDS_RANDO_BASE + 0x306)
#define IDS_STATPROP_Conflict           (IDS_RANDO_BASE + 0x307)

// Confirm Replace dialog
//#define IDS_REPLACE_ReplaceFile         (IDS_RANDO_BASE + 0x340)    // Old
//#define IDS_REPLACE_ReplaceFolder       (IDS_RANDO_BASE + 0x341)    // Old
//#define IDS_REPLACE_WithFile            (IDS_RANDO_BASE + 0x342)    // Old
//#define IDS_REPLACE_WithFolder          (IDS_RANDO_BASE + 0x343)    // Old
//#define IDS_REPLACE_ReplaceOrphan       (IDS_RANDO_BASE + 0x344)    // Old
#define IDS_MSG_ConfirmFileReplace      (IDS_RANDO_BASE + 0x345)
#define IDS_MSG_ConfirmFileReplace_RO   (IDS_RANDO_BASE + 0x346)
#define IDS_MSG_ConfirmFileReplace_Sys  (IDS_RANDO_BASE + 0x347)
#define IDS_MSG_ConfirmFolderReplace    (IDS_RANDO_BASE + 0x348)

// Update progress dialog
#define IDS_UPDATE_Copy                 (IDS_RANDO_BASE + 0x380)
#define IDS_UPDATE_Merge                (IDS_RANDO_BASE + 0x381)
#define IDS_UPDATE_Delete               (IDS_RANDO_BASE + 0x382)

// States of sync copies
#define IDS_STATE_Creates               (IDS_RANDO_BASE + 0x400)
#define IDS_STATE_Replaces              (IDS_RANDO_BASE + 0x401)
#define IDS_STATE_Skip                  (IDS_RANDO_BASE + 0x402)
#define IDS_STATE_Conflict              (IDS_RANDO_BASE + 0x403)
#define IDS_STATE_Merge                 (IDS_RANDO_BASE + 0x404)
#define IDS_STATE_Uptodate              (IDS_RANDO_BASE + 0x405)
#define IDS_STATE_NeedToUpdate          (IDS_RANDO_BASE + 0x406)
#define IDS_STATE_Orphan                (IDS_RANDO_BASE + 0x407)
#define IDS_STATE_Subfolder             (IDS_RANDO_BASE + 0x408)
#define IDS_STATE_Changed               (IDS_RANDO_BASE + 0x409)
#define IDS_STATE_Unchanged             (IDS_RANDO_BASE + 0x40a)
#define IDS_STATE_NewFile               (IDS_RANDO_BASE + 0x40b)
#define IDS_STATE_Unavailable           (IDS_RANDO_BASE + 0x40c)
#define IDS_STATE_UptodateInBrf         (IDS_RANDO_BASE + 0x40d)
#define IDS_STATE_SystemFile            (IDS_RANDO_BASE + 0x40e)
#define IDS_STATE_Delete                (IDS_RANDO_BASE + 0x40f)
#define IDS_STATE_DontDelete            (IDS_RANDO_BASE + 0x410)
#define IDS_STATE_DoesNotExist          (IDS_RANDO_BASE + 0x411)
#define IDS_STATE_Deleted               (IDS_RANDO_BASE + 0x412)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\state.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: state.c
//
//  This file contains the state & .ini file routines 
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"     // common headers

/////////////////////////////////////////////////////  TYPEDEFS

#ifdef DEBUG

// Some of the .ini processing code was pimped from the sync engine.
//

typedef struct _INIKEYHEADER
    {
    LPCTSTR pszSectionName;
    LPCTSTR pszKeyName;
    LPCTSTR pszDefaultRHS;
    } INIKEYHEADER;

typedef struct _BOOLINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    DWORD dwFlag;
    } BOOLINIKEY;

typedef struct _INTINIKEY
    {
    INIKEYHEADER ikh;
    LPUINT puStorage;
    } INTINIKEY;

#endif


// Some of these macros taken from prefs.h in Pen project...
//
#define PutIniIntCmp(idsSection, idsKey, nNewValue, nSave) \
    if ((nNewValue) != (nSave)) PutIniInt(idsSection, idsKey, nNewValue)

#define WritePrivateProfileInt(szApp, szKey, i, lpFileName) \
    {TCHAR sz[7]; \
    WritePrivateProfileString(szApp, szKey, SzFromInt(sz, i), lpFileName);}


/////////////////////////////////////////////////////  MODULE DATA

#ifdef DEBUG

#pragma data_seg(DATASEG_PERINSTANCE)

// Array of keys with Integer RHSs to be processed by ProcessIniFile() 

static INTINIKEY s_rgiik[] = 
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyTraceFlags, c_szZero },
        &g_uTraceFlags
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyDumpFlags, c_szZero },
        &g_uDumpFlags
        },

    };

// Array of keys with Boolean RHSs to be processed by ProcessIniFile() 

static BOOLINIKEY s_rgbik[] =
    {
        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnOpen, c_szZero },
        &g_uBreakFlags,
        BF_ONOPEN
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnClose, c_szZero },
        &g_uBreakFlags,
        BF_ONCLOSE
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnRunOnce, c_szZero },
        &g_uBreakFlags,
        BF_ONRUNONCE
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnValidate, c_szZero },
        &g_uBreakFlags,
        BF_ONVALIDATE
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnThreadAtt, c_szZero },
        &g_uBreakFlags,
        BF_ONTHREADATT
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnThreadDet, c_szZero },
        &g_uBreakFlags,
        BF_ONTHREADDET
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnProcessAtt, c_szZero },
        &g_uBreakFlags,
        BF_ONPROCESSATT
        },

        {
        { c_szIniSecDebugUI,    c_szIniKeyBreakOnProcessDet, c_szZero },
        &g_uBreakFlags,
        BF_ONPROCESSDET
        },
    };

#pragma data_seg()


/* Boolean TRUE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszTrue[] =
    {
    TEXT("1"),
    TEXT("On"),
    TEXT("True"),
    TEXT("Y"),
    TEXT("Yes")
    };

/* Boolean FALSE strings used by IsIniYes() (comparison is case-insensitive) */

static LPCTSTR s_rgpszFalse[] =
    {
    TEXT("0"),
    TEXT("Off"),
    TEXT("False"),
    TEXT("N"),
    TEXT("No")
    };

#endif  // DEBUG


/////////////////////////////////////////////////////  PROCEDURES


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Determines whether a string corresponds to a boolean
          TRUE value.
Returns: The boolean value (TRUE or FALSE)
Cond:    --
*/
BOOL PRIVATE IsIniYes(
    LPCTSTR psz)
    {
    int i;
    BOOL bNotFound = TRUE;
    BOOL bResult;

    ASSERT(psz); 

    /* Is the value TRUE? */

    for (i = 0; i < ARRAYSIZE(s_rgpszTrue); i++)
        {
        if (IsSzEqual(psz, s_rgpszTrue[i]))
            {
            bResult = TRUE;
            bNotFound = FALSE;
            break;
            }
        }

    /* Is the value FALSE? */

    if (bNotFound)
        {
        for (i = 0; i < ARRAYSIZE(s_rgpszFalse); i++)
            {
            if (IsSzEqual(psz, s_rgpszFalse[i]))
                {
                bResult = FALSE;
                bNotFound = FALSE;
                break;
                }
            }

        /* Is the value a known string? */

        if (bNotFound)
            {
            /* No.  Whine about it. */

            DEBUG_MSG(TF_WARNING, TEXT("IsIniYes() called on unknown Boolean RHS '%s'."), psz);
            bResult = FALSE;
            }
        }

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Process keys with boolean RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessBooleans(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgbik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAXBUFLEN];
        BOOLINIKEY * pbik = &(s_rgbik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(pbik->ikh.pszSectionName,
                                   pbik->ikh.pszKeyName, TEXT(""), szRHS,
                                   ARRAYSIZE(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = pbik->ikh.pszDefaultRHS;

        if (IsIniYes(lpcszRHS))
            {
            if (IsFlagClear(*(pbik->puStorage), pbik->dwFlag))
                DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s set in %s![%s]."),
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            SetFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        else
            {
            if (IsFlagSet(*(pbik->puStorage), pbik->dwFlag))
                DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s cleared in %s![%s]."),
                         pbik->ikh.pszKeyName,
                         c_szIniFile,
                         pbik->ikh.pszSectionName);

            ClearFlag(*(pbik->puStorage), pbik->dwFlag);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Process keys with integer RHSs.
Returns: --
Cond:    --
*/
void PRIVATE ProcessIntegers(void)
    {
    int i;

    for (i = 0; i < ARRAYSIZE(s_rgiik); i++)
        {
        DWORD dwcbKeyLen;
        TCHAR szRHS[MAXBUFLEN];
        INTINIKEY * piik = &(s_rgiik[i]);
        LPCTSTR lpcszRHS;

        /* Look for key. */

        dwcbKeyLen = GetPrivateProfileString(piik->ikh.pszSectionName,
                                   piik->ikh.pszKeyName, TEXT(""), szRHS,
                                   ARRAYSIZE(szRHS), c_szIniFile);

        if (dwcbKeyLen)
            lpcszRHS = szRHS;
        else
            lpcszRHS = piik->ikh.pszDefaultRHS;

        *(piik->puStorage) = AnsiToInt(lpcszRHS);

        DEBUG_MSG(TF_GENERAL, TEXT("ProcessIniFile(): %s set to %#04x."), 
                 piik->ikh.pszKeyName, *(piik->puStorage));
        }
    }

#endif

#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Process initialization file
Returns: TRUE if initialization is successful
Cond:    --
*/
BOOL PUBLIC ProcessIniFile(void)
    {
    BOOL bResult = TRUE;

    // Currently, all integer keys are for DEBUG use only.
    //
    ProcessIntegers();

    // Currently, all boolean keys are for DEBUG use only.
    //
    ProcessBooleans();

    return bResult;
    }


/*----------------------------------------------------------
Purpose: Copy user settings to the .ini file
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC CommitIniFile(void)
    {
    return TRUE;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\recact.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: recact.c
//
//  This file contains the reconciliation-action control class code
//
//
// History:
//  08-12-93 ScottH     Created.
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#ifdef WINNT
#include <help.h>
#else
#include <help.h>   // help IDs
#endif

#include "res.h"
#include "recact.h"
#include "dobj.h"

/////////////////////////////////////////////////////  CONTROLLING DEFINES


/////////////////////////////////////////////////////  DEFINES

// Manifest constants
#define SIDE_INSIDE     0
#define SIDE_OUTSIDE    1

// These should be changed if the bitmap sizes change!!
#define CX_ACTIONBMP    26
#define CY_ACTIONBMP    26

#define RECOMPUTE       (-1)

#define X_INCOLUMN      (g_cxIcon*2)

// Image indexes
#define II_RIGHT        0
#define II_LEFT         1
#define II_CONFLICT     2
#define II_SKIP         3
#define II_MERGE        4
#define II_SOMETHING    5
#define II_UPTODATE     6
#define II_DELETE       7

// Menu items
//
#define IDM_ACTIONFIRST     100
#define IDM_TOOUT           100
#define IDM_TOIN            101
#define IDM_SKIP            102
#define IDM_MERGE           103
#define IDM_DELETEOUT       104
#define IDM_DELETEIN        105
#define IDM_DONTDELETE      106
#define IDM_ACTIONLAST      106

#define IDM_WHATSTHIS       107


/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagRECACT
    {
    HWND        hwnd;

    HWND        hwndLB;
    HWND        hwndTip;
    HDC         hdcOwn;             // Own DC
    HMENU       hmenu;              // Action and help context menu
    HFONT       hfont;
    WNDPROC     lpfnLBProc;         // Default LB proc
    HIMAGELIST  himlAction;         // imagelist for actions
    HIMAGELIST  himlCache;          // control imagelist cache
    HBITMAP     hbmpBullet;
    HDSA        hdsa;

    HBRUSH      hbrBkgnd;
    COLORREF    clrBkgnd;

    LONG        lStyle;             // Window style flags
    UINT        cTipID;             // Tip IDs are handed out 2 per item

    // Metrics
    int         cxItem;             // Generic width of an item
    int         cxMenuCheck;
    int         cyMenuCheck;
    int         cyText;
    int         cxEllipses;

    } RECACT,  * LPRECACT;

#define RecAct_IsNoIcon(this)   IsFlagSet((this)->lStyle, RAS_SINGLEITEM)

// Internal item data struct
//
typedef struct tagRA_PRIV
    {
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    FileInfo * pfi;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM  lParam;

    DOBJ    rgdobj[4];      // Array of Draw object info
    int     cx;             // Bounding width and height
    int     cy;

    } RA_PRIV,  * LPRA_PRIV;

#define IDOBJ_FILE      0
#define IDOBJ_ACTION    1
#define IDOBJ_INSIDE    2
#define IDOBJ_OUTSIDE   3

// RecAction menu item definition structure.  Used to define the
//  context menu brought up in this control.
//
typedef struct tagRAMID
    {
    UINT    idm;               // Menu ID (for MENUITEMINFO struct)
    UINT    uAction;           // One of RAIA_* flags
    UINT    ids;               // Resource string ID
    int     iImage;            // Index into himlAction
    RECT    rcExtent;          // Extent rect of string
    } RAMID,  * LPRAMID;   // RecAction Menu Item Definition

// Help menu item definition structure.  Used to define the help
//  items in the context menu.
//
typedef struct tagHMID
    {
    UINT idm;
    UINT ids;
    } HMID;

/////////////////////////////////////////////////////  MACROS

#define RecAct_DefProc      DefWindowProc
#define RecActLB_DefProc    CallWindowProc


// Instance data pointer macros
//
#define RecAct_GetPtr(hwnd)     (LPRECACT)GetWindowLong(hwnd, 0)
#define RecAct_SetPtr(hwnd, lp) (LPRECACT)SetWindowLong(hwnd, 0, (LONG)(lp))

#define RecAct_GetCount(this)   ListBox_GetCount((this)->hwndLB)

LPCTSTR PRIVATE SkipDisplayJunkHack(LPSIDEITEM psi);

/////////////////////////////////////////////////////  MODULE DATA

#ifdef SAVE_FOR_RESIZE
static TCHAR const c_szDateDummy[] = TEXT("99/99/99 99:99PM");
#endif

// Map RAIA_* values to image indexes
//
static UINT const c_mpraiaiImage[] =
    { II_RIGHT,
      II_LEFT,
      II_SKIP,
      II_CONFLICT,
      II_MERGE,
      II_SOMETHING,
      II_UPTODATE,
      0,
#ifdef NEW_REC
      II_DELETE,
      II_DELETE,
      II_SKIP
#endif
      };

// Map RAIA_* values to menu command positions
//
static UINT const c_mpraiaidmMenu[] =
    { IDM_TOOUT,
      IDM_TOIN,
      IDM_SKIP,
      IDM_SKIP,
      IDM_MERGE,
      0, 0, 0,
#ifdef NEW_REC
      IDM_DELETEOUT,
      IDM_DELETEIN,
      IDM_DONTDELETE
#endif
      };

// Define the context menu layout
//
static RAMID const c_rgramid[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_REPLACE,   II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_REPLACE,   II_LEFT,    0 },
    { IDM_SKIP,     RAIA_SKIP,  IDS_MENU_SKIP,      II_SKIP,    0 },
    // Merge must be the last item!
    { IDM_MERGE,    RAIA_MERGE, IDS_MENU_MERGE,     II_MERGE,   0 },
    };

static RAMID const c_rgramidCreates[] = {
    { IDM_TOOUT,    RAIA_TOOUT, IDS_MENU_CREATE,    II_RIGHT,   0 },
    { IDM_TOIN,     RAIA_TOIN,  IDS_MENU_CREATE,    II_LEFT,    0 },
    };

#ifdef NEW_REC
static RAMID const c_rgramidDeletes[] = {
    { IDM_DELETEOUT,   RAIA_DELETEOUT, IDS_MENU_DELETE,    II_DELETE,  0 },
    { IDM_DELETEIN,    RAIA_DELETEIN,  IDS_MENU_DELETE,    II_DELETE,  0 },
    { IDM_DONTDELETE,  RAIA_DONTDELETE,IDS_MENU_DONTDELETE,II_SKIP,    0 },
    };
#endif

// Indexes into c_rgramidCreates
//
#define IRAMID_CREATEOUT    0
#define IRAMID_CREATEIN     1

// Indexes into c_rgramidDeletes
//
#define IRAMID_DELETEOUT    0
#define IRAMID_DELETEIN     1
#define IRAMID_DONTDELETE   2

static HMID const c_rghmid[] = {
    { IDM_WHATSTHIS, IDS_MENU_WHATSTHIS },
    };

/////////////////////////////////////////////////////  LOCAL PROCEDURES

LRESULT _export CALLBACK RecActLB_LBProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);

/////////////////////////////////////////////////////  PRIVATE FUNCTIONS



#ifdef DEBUG
LPCTSTR PRIVATE DumpRecAction(
    UINT uAction)        // RAIA_
    {
    switch (uAction)
        {
    DEBUG_CASE_STRING( RAIA_TOOUT );
    DEBUG_CASE_STRING( RAIA_TOIN );
    DEBUG_CASE_STRING( RAIA_SKIP );
    DEBUG_CASE_STRING( RAIA_CONFLICT );
    DEBUG_CASE_STRING( RAIA_MERGE );
    DEBUG_CASE_STRING( RAIA_SOMETHING );
    DEBUG_CASE_STRING( RAIA_NOTHING );
    DEBUG_CASE_STRING( RAIA_ORPHAN );
    DEBUG_CASE_STRING( RAIA_DELETEOUT );
    DEBUG_CASE_STRING( RAIA_DELETEIN );
    DEBUG_CASE_STRING( RAIA_DONTDELETE );

    default:        return TEXT("Unknown");
        }
    }


LPCTSTR PRIVATE DumpSideItemState(
    UINT uState)        // SI_
    {
    switch (uState)
        {
    DEBUG_CASE_STRING( SI_UNCHANGED );
    DEBUG_CASE_STRING( SI_CHANGED );
    DEBUG_CASE_STRING( SI_NEW );
    DEBUG_CASE_STRING( SI_NOEXIST );
    DEBUG_CASE_STRING( SI_UNAVAILABLE );
    DEBUG_CASE_STRING( SI_DELETED );

    default:        return TEXT("Unknown");
        }
    }


/*----------------------------------------------------------
Purpose: Dumps a twin pair
Returns: --
Cond:    --
*/
void PUBLIC DumpTwinPair(
    LPRA_ITEM pitem)
    {
    if (pitem)
        {
        TCHAR szBuf[MAXMSGLEN];

        #define szDump   TEXT("Dump TWINPAIR: ")
        #define szBlank  TEXT("               ")

        if (IsFlagClear(g_uDumpFlags, DF_TWINPAIR))
            {
            return;
            }

        wsprintf(szBuf, TEXT("%s.pszName = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->pszName));
        OutputDebugString(szBuf);
        wsprintf(szBuf, TEXT("%s.uStyle = %lx\r\n"), (LPTSTR)szBlank, pitem->uStyle);
        OutputDebugString(szBuf);
        wsprintf(szBuf, TEXT("%s.uAction = %s\r\n"), (LPTSTR)szBlank, DumpRecAction(pitem->uAction));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   TEXT("       Inside: ")
        wsprintf(szBuf, TEXT("%s.pszDir = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->siInside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, TEXT("%s.uState = %s\r\n"), (LPTSTR)szBlank, DumpSideItemState(pitem->siInside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #define szDump   TEXT("      Outside: ")
        wsprintf(szBuf, TEXT("%s.pszDir = %s\r\n"), (LPTSTR)szDump, Dbg_SafeStr(pitem->siOutside.pszDir));
        OutputDebugString(szBuf);
        wsprintf(szBuf, TEXT("%s.uState = %s\r\n"), (LPTSTR)szBlank, DumpSideItemState(pitem->siOutside.uState));
        OutputDebugString(szBuf);

        #undef szDump
        #undef szBlank
        }
    }


#endif


/*----------------------------------------------------------
Purpose: Create a monochrome bitmap of the bullet, so we can
         play with the colors later.
Returns: handle to bitmap
Cond:    Caller must delete bitmap
*/
HBITMAP PRIVATE CreateBulletBitmap(
    LPSIZE psize)
    {
    HDC hdcMem;
    HBITMAP hbmp = NULL;

    hdcMem = CreateCompatibleDC(NULL);
    if (hdcMem)
        {
        hbmp = CreateCompatibleBitmap(hdcMem, psize->cx, psize->cy);
        if (hbmp)
            {
            HBITMAP hbmpOld;
            RECT rc;

            // hbmp is monochrome

            hbmpOld = SelectBitmap(hdcMem, hbmp);
            rc.left = 0;
            rc.top = 0;
            rc.right = psize->cx;
            rc.bottom = psize->cy;
            DrawFrameControl(hdcMem, &rc, DFC_MENU, DFCS_MENUBULLET);

            SelectBitmap(hdcMem, hbmpOld);
            }
        DeleteDC(hdcMem);
        }
    return hbmp;
    }


/*----------------------------------------------------------
Purpose: Returns the top and bottom indexes of the visible
         entries in the listbox

Returns: --
Cond:    --
*/
void PRIVATE GetVisibleRange(
    HWND hwndLB,
    int * piTop,
    int * piBottom)
    {
    int i;
    int cel;
    int cyMac;
    RECT rc;

    *piTop = ListBox_GetTopIndex(hwndLB);

    cel = ListBox_GetCount(hwndLB);
    GetClientRect(hwndLB, &rc);
    cyMac = 0;

    for (i = *piTop; i < cel; i++)
        {
        if (cyMac > rc.bottom)
            break;

        cyMac += ListBox_GetItemHeight(hwndLB, i);
        }

    *piBottom = i-1;;
    }


/*----------------------------------------------------------
Purpose: Returns the top and bottom indexes of the visible
         entries in the listbox

Returns: --
Cond:    --
*/
int PRIVATE GetHitIndex(
    HWND hwndLB,
    POINT pt)
    {
    int i;
    int iTop;
    int cel;
    int cyMac;
    int cy;
    RECT rc;

    iTop = ListBox_GetTopIndex(hwndLB);

    cel = ListBox_GetCount(hwndLB);
    GetClientRect(hwndLB, &rc);
    cyMac = 0;

    for (i = iTop; i < cel; i++)
        {
        cy = ListBox_GetItemHeight(hwndLB, i);

        if (InRange(pt.y, cyMac, cyMac + cy))
            break;

        cyMac += cy;
        }

    if (i == cel)
        return LB_ERR;

    return i;
    }


/*----------------------------------------------------------
Purpose: Returns the resource ID string given the action
         flag.
Returns: IDS_ value
Cond:    --
*/
UINT PRIVATE GetActionText(
    LPRA_PRIV ppriv)
    {
    UINT ids;

    ASSERT(ppriv);

    switch (ppriv->uAction)
        {
    case RAIA_TOOUT:
        if (SI_NEW == ppriv->siInside.uState ||
            SI_DELETED == ppriv->siOutside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

    case RAIA_TOIN:
        if (SI_NEW == ppriv->siOutside.uState ||
            SI_DELETED == ppriv->siInside.uState)
            {
            ids = IDS_STATE_Creates;
            }
        else
            {
            ids = IDS_STATE_Replaces;
            }
        break;

#ifdef NEW_REC
    case RAIA_DONTDELETE:
        ASSERT(SI_DELETED == ppriv->siInside.uState ||
               SI_DELETED == ppriv->siOutside.uState);

        ids = IDS_STATE_DontDelete;
        break;
#endif

    case RAIA_SKIP:
        // Can occur if the user explicitly wants to skip, or if
        // one side is unavailable.
        ids = IDS_STATE_Skip;
        break;

    case RAIA_CONFLICT:     ids = IDS_STATE_Conflict;       break;
    case RAIA_MERGE:        ids = IDS_STATE_Merge;          break;
    case RAIA_NOTHING:      ids = IDS_STATE_Uptodate;       break;
    case RAIA_SOMETHING:    ids = IDS_STATE_NeedToUpdate;   break;

#ifdef NEW_REC
    case RAIA_DELETEOUT:    ids = IDS_STATE_Delete;         break;
    case RAIA_DELETEIN:     ids = IDS_STATE_Delete;         break;
#endif

    default:                ids = 0;                        break;
        }

    return ids;
    }


/*----------------------------------------------------------
Purpose: Repaint an item in the listbox
Returns: --
Cond:    --
*/
void PRIVATE ListBox_RepaintItemNow(
    HWND hwnd,
    int iItem,
    LPRECT prc,         // Relative to individual entry rect.  May be NULL
    BOOL bEraseBk)
    {
    RECT rc;
    RECT rcItem;

    ListBox_GetItemRect(hwnd, iItem, &rcItem);
    if (prc)
        {
        OffsetRect(prc, rcItem.left, rcItem.top);
        IntersectRect(&rc, &rcItem, prc);
        }
    else
        rc = rcItem;

    InvalidateRect(hwnd, &rc, bEraseBk);
    UpdateWindow(hwnd);
    }


/*----------------------------------------------------------
Purpose: Determine which DOBJ of the item is going to get the caret.

Returns: pointer to DOBJ
Cond:    --
*/
LPDOBJ PRIVATE RecAct_ChooseCaretDobj(
    LPRECACT this,
    LPRA_PRIV ppriv)
    {
    // Focus rect on file icon?
    if (!RecAct_IsNoIcon(this))
        return ppriv->rgdobj;                   // Yes
    else
        return &ppriv->rgdobj[IDOBJ_ACTION];    // No
    }


/*----------------------------------------------------------
Purpose: Returns the tool tip ID for the visible rectangle
         that the given item is currently occupying.

Returns: see above
Cond:    --
*/
UINT PRIVATE RecAct_GetTipIDFromItemID(
    LPRECACT this,
    int itemID)
    {
    int iTop;
    int iBottom;
    int idsa;
    UINT uID;

    GetVisibleRange(this->hwndLB, &iTop, &iBottom);
    ASSERT(iTop <= itemID);
    ASSERT(itemID <= iBottom);

    idsa = itemID - iTop;
    if ( !DSA_GetItem(this->hdsa, idsa, &uID) )
        {
        // This region has not been added yet
        uID = this->cTipID;

        if (-1 != DSA_SetItem(this->hdsa, idsa, &uID))
            {
            TOOLINFO ti;

            ti.cbSize = sizeof(ti);
            ti.uFlags = 0;
            ti.hwnd = this->hwndLB;
            ti.uId = uID;
            ti.lpszText = LPSTR_TEXTCALLBACK;
            ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0;
            SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

            ti.uId++;
            SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

            this->cTipID += 2;
            }
        }

    return uID;
    }


/*----------------------------------------------------------
Purpose: Finds a listbox item given the tip ID.

Returns: item index
Cond:    --
*/
int PRIVATE RecAct_FindItemFromTipID(
    LPRECACT this,
    UINT uTipID,
    BOOL * pbInside)
    {
    int iTop;
    int iBottom;
    int iVisibleItem = uTipID / 2;
    int iItem;

    ASSERT(0 <= iVisibleItem);

    GetVisibleRange(this->hwndLB, &iTop, &iBottom);
    if (iVisibleItem <= iBottom - iTop)
        {
        iItem = iTop + iVisibleItem;

        if (uTipID % 2)
            *pbInside = FALSE;
        else
            *pbInside = TRUE;
        }
    else
        iItem = LB_ERR;

    return iItem;
    }


/*----------------------------------------------------------
Purpose: Send selection change notification
Returns:
Cond:    --
*/
BOOL PRIVATE RecAct_SendSelChange(
    LPRECACT this,
    int isel)
    {
    NM_RECACT nm;

    nm.iItem = isel;
    nm.mask = 0;

    if (isel != -1)
        {
        LPRA_ITEM pitem;

        ListBox_GetText(this->hwndLB, isel, &pitem);
        if (!pitem)
            return FALSE;

        nm.lParam = pitem->lParam;
        nm.mask |= RAIF_LPARAM;
        }

    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_SELCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Send an action change notification
Returns:
Cond:    --
*/
BOOL PRIVATE RecAct_SendItemChange(
    LPRECACT this,
    int iEntry,
    UINT uActionOld)
    {
    NM_RECACT nm;

    nm.iItem = iEntry;
    nm.mask = 0;

    if (iEntry != -1)
        {
        LPRA_PRIV ppriv;

        ListBox_GetText(this->hwndLB, iEntry, &ppriv);
        if (!ppriv)
            return FALSE;

        nm.mask |= RAIF_LPARAM | RAIF_ACTION;
        nm.lParam = ppriv->lParam;
        nm.uAction = ppriv->uAction;
        nm.uActionOld = uActionOld;
        }

    return !(BOOL)SendNotify(GetParent(this->hwnd), this->hwnd, RN_ITEMCHANGED, &nm.hdr);
    }


/*----------------------------------------------------------
Purpose: Create the action context menu
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateMenu(
    LPRECACT this)
    {
    HMENU hmenu;

    hmenu = CreatePopupMenu();
    if (hmenu)
        {
        TCHAR sz[MAXSHORTLEN];
        MENUITEMINFO mii;
        int i;

        // Add the help menu items now, since these will be standard
        //
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;

        for (i = 0; i < ARRAYSIZE(c_rghmid); i++)
            {
            mii.wID = c_rghmid[i].idm;
            mii.dwTypeData = SzFromIDS(c_rghmid[i].ids, sz, ARRAYSIZE(sz));
            InsertMenuItem(hmenu, i, TRUE, &mii);
            }

        this->hmenu = hmenu;
        }

    return hmenu != NULL;
    }


/*----------------------------------------------------------
Purpose: Add the action menu items to the context menu
Returns: --
Cond:    --
*/
void PRIVATE AddActionsToContextMenu(
    HMENU hmenu,
    UINT idmCheck,      // menu item to checkmark
    LPRA_PRIV ppriv)
    {
    MENUITEMINFO mii;
    int i;
    int cItems = ARRAYSIZE(c_rgramid);

    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID | MIIM_DATA;
    mii.fType = MFT_OWNERDRAW;
    mii.fState = MFS_ENABLED;

    // Is merge supported?
    if (IsFlagClear(ppriv->uStyle, RAIS_CANMERGE))
        {
        // No
        --cItems;
        }

    for (i = 0; i < cItems; i++)
        {
        mii.wID = c_rgramid[i].idm;
        mii.dwItemData = (DWORD)&c_rgramid[i];

        InsertMenuItem(hmenu, i, TRUE, &mii);
        }

    // Add the separator
    mii.fMask = MIIM_TYPE;
    mii.fType = MFT_SEPARATOR;
    InsertMenuItem(hmenu, i, TRUE, &mii);

    // Set the initial checkmark.
    CheckMenuRadioItem(hmenu, IDM_ACTIONFIRST, IDM_ACTIONLAST, idmCheck,
        MF_BYCOMMAND | MF_CHECKED);

    // Is the file or its sync copy unavailable?
    if (SI_UNAVAILABLE == ppriv->siInside.uState ||
        SI_UNAVAILABLE == ppriv->siOutside.uState)
        {
        // Yes
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, IDM_TOIN, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_TOOUT, FALSE, &mii);
        SetMenuItemInfo(hmenu, IDM_MERGE, FALSE, &mii);
        }

    // Is the file being created?
    else if (ppriv->siInside.uState == SI_NEW ||
        ppriv->siOutside.uState == SI_NEW)
        {
        // Yes; disable the replace-in-opposite direction
        UINT idmDisable;
        UINT idmChangeVerb;

        if (ppriv->siInside.uState == SI_NEW)
            {
            idmDisable = IDM_TOIN;
            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_CREATEOUT;
            }
        else
            {
            idmDisable = IDM_TOOUT;
            idmChangeVerb = IDM_TOIN;
            i = IRAMID_CREATEIN;
            }

        // Disable one of the directions
        mii.fMask = MIIM_STATE;
        mii.fState = MFS_GRAYED | MFS_DISABLED;
        SetMenuItemInfo(hmenu, idmDisable, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD)&c_rgramidCreates[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);
        }

#ifdef NEW_REC
    // Is the file being deleted?
    else if (SI_DELETED == ppriv->siInside.uState ||
        SI_DELETED == ppriv->siOutside.uState)
        {
        // Yes;
        UINT idmCreate;
        UINT idmChangeVerb;
        UINT iCreate;

        if (SI_DELETED == ppriv->siInside.uState)
            {
            idmCreate = IDM_TOIN;
            iCreate = IRAMID_CREATEIN;

            idmChangeVerb = IDM_TOOUT;
            i = IRAMID_DELETEOUT;
            }
        else
            {
            ASSERT(SI_DELETED == ppriv->siOutside.uState);

            idmCreate = IDM_TOOUT;
            iCreate = IRAMID_CREATEOUT;

            idmChangeVerb = IDM_TOIN;
            i = IRAMID_DELETEIN;
            }

        // Change one of the directions to be create
        mii.fMask = MIIM_DATA;
        mii.dwItemData = (DWORD)&c_rgramidCreates[iCreate];
        SetMenuItemInfo(hmenu, idmCreate, FALSE, &mii);

        // Change the verb of the other direction
        mii.fMask = MIIM_DATA | MIIM_ID;
        mii.wID = c_rgramidDeletes[i].idm;
        mii.dwItemData = (DWORD)&c_rgramidDeletes[i];

        SetMenuItemInfo(hmenu, idmChangeVerb, FALSE, &mii);

        // Change the skip verb to be "Don't Delete"
        mii.fMask = MIIM_DATA | MIIM_ID;
        mii.wID = c_rgramidDeletes[IRAMID_DONTDELETE].idm;
        mii.dwItemData = (DWORD)&c_rgramidDeletes[IRAMID_DONTDELETE];

        SetMenuItemInfo(hmenu, IDM_SKIP, FALSE, &mii);
        }
#endif
    }


/*----------------------------------------------------------
Purpose: Clear out the context menu
Returns: --
Cond:    --
*/
void PRIVATE ResetContextMenu(
    HMENU hmenu)
    {
    int cnt;

    // If there is more than just the help items, remove them
    //  (but leave the help items)
    //
    cnt = GetMenuItemCount(hmenu);
    if (cnt > ARRAYSIZE(c_rghmid))
        {
        int i;

        cnt -= ARRAYSIZE(c_rghmid);
        for (i = 0; i < cnt; i++)
            {
            DeleteMenu(hmenu, 0, MF_BYPOSITION);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Do the context menu
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DoContextMenu(
    LPRECACT this,
    int x,              // in screen coords
    int y,
    int iEntry,
    BOOL bHelpOnly)     // TRUE: only show the help items
    {
    UINT idCmd;

    if (this->hmenu)
        {
        LPRA_PRIV ppriv;
        RECT rc;
        int idmCheck;
        UINT uActionOld;

        // Only show help-portion of context menu?
        if (bHelpOnly)
            {
            // Yes
            ppriv = NULL;
            }
        else
            {
            // No
            ListBox_GetText(this->hwndLB, iEntry, &ppriv);

            // Determine if this is a help-context menu only.
            //  It is if this is a folder-item or if there is no action
            //  to take.
            //
            ASSERT(ppriv->uAction < ARRAYSIZE(c_mpraiaidmMenu));
            idmCheck = c_mpraiaidmMenu[ppriv->uAction];

            // Build the context menu
            //
            if (IsFlagClear(ppriv->uStyle, RAIS_FOLDER) && idmCheck != 0)
                {
                AddActionsToContextMenu(this->hmenu, idmCheck, ppriv);
                }
            }

        // Show context menu
        //
        SendMessage(this->hwndTip, TTM_ACTIVATE, FALSE, 0L);

        idCmd = TrackPopupMenu(this->hmenu,
                    TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                    x, y, 0, this->hwnd, NULL);

        SendMessage(this->hwndTip, TTM_ACTIVATE, TRUE, 0L);

        // Clear menu
        //
        ResetContextMenu(this->hmenu);

        if (ppriv)
            {
            // Save the old action
            uActionOld = ppriv->uAction;
            }

        // Act on whatever the user chose
        switch (idCmd)
            {
        case IDM_TOOUT:
            ppriv->uAction = RAIA_TOOUT;
            break;

        case IDM_TOIN:
            ppriv->uAction = RAIA_TOIN;
            break;

        case IDM_SKIP:
            ppriv->uAction = RAIA_SKIP;
            break;

        case IDM_MERGE:
            ppriv->uAction = RAIA_MERGE;
            break;

#ifdef NEW_REC
        case IDM_DELETEOUT:
            ppriv->uAction = RAIA_DELETEOUT;
            break;

        case IDM_DELETEIN:
            ppriv->uAction = RAIA_DELETEIN;
            break;

        case IDM_DONTDELETE:
            ppriv->uAction = RAIA_DONTDELETE;
            break;
#endif

        case IDM_WHATSTHIS:
            WinHelp(this->hwnd, c_szWinHelpFile, HELP_CONTEXTPOPUP, IDH_BFC_UPDATE_SCREEN);
            return;         // Return now

        default:
            return;         // Return now
            }

        // Repaint action portion of entry
        ppriv->cx = RECOMPUTE;
        rc = ppriv->rgdobj[IDOBJ_ACTION].rcBounding;
        ListBox_RepaintItemNow(this->hwndLB, iEntry, &rc, TRUE);

        // Send a notify message
        ASSERT(NULL != ppriv);      // uActionOld should be valid
        RecAct_SendItemChange(this, iEntry, uActionOld);
        }
    }


/*----------------------------------------------------------
Purpose: Create the windows for this control
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_CreateWindows(
    LPRECACT this,
    CREATESTRUCT  * lpcs)
    {
    HWND hwnd = this->hwnd;
    HWND hwndLB;
    RECT rc;
    int cxEdge = GetSystemMetrics(SM_CXEDGE);
    int cyEdge = GetSystemMetrics(SM_CYEDGE);
    TOOLINFO ti;

    // Create listbox
    hwndLB = CreateWindowEx(
                0,
                TEXT("listbox"),
                TEXT(""),
                WS_CHILD | WS_CLIPSIBLINGS | LBS_SORT | LBS_OWNERDRAWVARIABLE |
                WS_VSCROLL | WS_TABSTOP | WS_VISIBLE | LBS_NOINTEGRALHEIGHT |
                LBS_NOTIFY,
                0, 0, lpcs->cx, lpcs->cy,
                hwnd,
                NULL,
                lpcs->hInstance,
                0L);
    if (!hwndLB)
        return FALSE;

    SetWindowFont(hwndLB, this->hfont, FALSE);

    this->hwndLB = hwndLB;

    // Determine layout of window
    GetClientRect(hwnd, &rc);
    InflateRect(&rc, -cxEdge, -cyEdge);
    SetWindowPos(hwndLB, NULL, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
        SWP_NOACTIVATE | SWP_SHOWWINDOW | SWP_NOZORDER);

    GetClientRect(hwndLB, &rc);
    this->cxItem = rc.right - rc.left;

    this->hwndTip = CreateWindow(
                TOOLTIPS_CLASS,
                c_szNULL,
                WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP,
                CW_USEDEFAULT, CW_USEDEFAULT,
                CW_USEDEFAULT, CW_USEDEFAULT,
                hwnd,
                NULL,
                lpcs->hInstance,
                0L);

    // Add a dummy tool so the delay is shorter between other tools
    ti.cbSize = sizeof(ti);
    ti.uFlags = TTF_IDISHWND;
    ti.hwnd = this->hwndLB;
    ti.uId = (UINT)this->hwndLB;
    ti.lpszText = (LPTSTR)c_szNULL;
    ti.rect.left = ti.rect.top = ti.rect.bottom = ti.rect.right = 0;
    SendMessage(this->hwndTip, TTM_ADDTOOL, 0, (LPARAM)&ti);

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set the colors of the control
Returns: --
Cond:    --
*/
void PRIVATE RecAct_SetColors(
    LPRECACT this)
    {
    int cr;

    if (IsFlagClear(this->lStyle, RAS_SINGLEITEM))
        {
        cr = COLOR_WINDOW;
        }
    else
        {
        cr = COLOR_3DFACE;
        }

    this->clrBkgnd = GetSysColor(cr);

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    this->hbrBkgnd = CreateSolidBrush(this->clrBkgnd);
    }


/*----------------------------------------------------------
Purpose: Creates an imagelist of the action images

Returns: TRUE on success

Cond:    --
*/
BOOL PRIVATE CreateImageList(
    HIMAGELIST * phiml,
    HDC hdc,
    UINT idb,
    int cxBmp,
    int cyBmp,
    int cImage)
    {
    BOOL bRet;
    HIMAGELIST himl;

    himl = ImageList_Create(cxBmp, cyBmp, TRUE, cImage, 1);

    if (himl)
        {
        COLORREF clrMask;
        HBITMAP hbm;

        hbm = LoadBitmap(g_hinst, MAKEINTRESOURCE(idb));
        ASSERT(hbm);

        if (hbm)
            {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
                {
                HBITMAP hbmSav = SelectBitmap(hdcMem, hbm);

                clrMask = GetPixel(hdcMem, 0, 0);
                SelectBitmap(hdcMem, hbmSav);

                bRet = (0 == ImageList_AddMasked(himl, hbm, clrMask));

                DeleteDC(hdcMem);
                }
            else
                bRet = FALSE;

            DeleteBitmap(hbm);
            }
        else
            bRet = FALSE;
        }
    else
        bRet = FALSE;

    *phiml = himl;
    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_CREATE handler
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnCreate(
    LPRECACT this,
    CREATESTRUCT  * lpcs)
    {
    BOOL bRet = FALSE;
    HWND hwnd = this->hwnd;
    HDC hdc;
    TEXTMETRIC tm;
    RECT rcT;
    LOGFONT lf;

    this->lStyle = GetWindowLong(hwnd, GWL_STYLE);
    RecAct_SetColors(this);

    // Determine some font things

    SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
    this->hfont = CreateFontIndirect(&lf);

    // This window is registered with the CS_OWNDC flag
    this->hdcOwn = GetDC(hwnd);
    ASSERT(this->hdcOwn);

    hdc = this->hdcOwn;

    SelectFont(hdc, this->hfont);
    GetTextMetrics(hdc, &tm);
    this->cyText = tm.tmHeight;

    // Calculate text extent for sideitems (use the listbox font)
    //
    SetRectFromExtent(hdc, &rcT, c_szEllipses);
    this->cxEllipses = rcT.right - rcT.left;

    // Create windows used by control
    if (RecAct_CreateWindows(this, lpcs))
        {
        this->lpfnLBProc = SubclassWindow(this->hwndLB, RecActLB_LBProc);

        this->hdsa = DSA_Create(sizeof(int), 16);
        if (this->hdsa)
            {
            // Get the system imagelist cache
            this->himlCache = ImageList_Create(g_cxIcon, g_cyIcon, TRUE, 8, 8);
            if (this->himlCache)
                {
                if (CreateImageList(&this->himlAction, hdc, IDB_ACTIONS,
                    CX_ACTIONBMP, CY_ACTIONBMP, 8))
                    {
                    SIZE size;

                    // Get some metrics
                    this->cxMenuCheck = GetSystemMetrics(SM_CXMENUCHECK);
                    this->cyMenuCheck = GetSystemMetrics(SM_CYMENUCHECK);

                    size.cx = this->cxMenuCheck;
                    size.cy = this->cyMenuCheck;
                    this->hbmpBullet = CreateBulletBitmap(&size);
                    if (this->hbmpBullet)
                        {
                        bRet = RecAct_CreateMenu(this);
                        }
                    }
                }
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: WM_DESTROY Handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnDestroy(
    LPRECACT this)
    {
    if (this->himlCache)
        {
        ImageList_Destroy(this->himlCache);
        this->himlCache = NULL;
        }

    if (this->himlAction)
        {
        ImageList_Destroy(this->himlAction);
        this->himlAction = NULL;
        }

    if (this->hbmpBullet)
        {
        DeleteBitmap(this->hbmpBullet);
        this->hbmpBullet = NULL;
        }

    if (this->hmenu)
        {
        DestroyMenu(this->hmenu);
        this->hmenu = NULL;
        }

    if (this->hbrBkgnd)
        DeleteBrush(this->hbrBkgnd);

    if (this->hfont)
        DeleteFont(this->hfont);

    if (this->hdsa)
        DSA_Destroy(this->hdsa);
    }


/*----------------------------------------------------------
Purpose: WM_COMMAND Handler
Returns: --
Cond:    --
*/
VOID PRIVATE RecAct_OnCommand(
    LPRECACT this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    if (hwndCtl == this->hwndLB)
        {
        switch (uNotifyCode)
            {
        case LBN_SELCHANGE:
            break;
            }
        }
    }


/*----------------------------------------------------------
Purpose: Handles WM_SYSKEYDOWN

Returns: 0 if we processed it

Cond:    --
*/
int PRIVATE RecAct_OnSysKeyDown(
    LPRECACT this,
    UINT vkey,
    LPARAM lKeyData)
    {
    int nRet = -1;

    // Context menu invoked by the keyboard?
    if (VK_F10 == vkey && 0 > GetKeyState(VK_SHIFT))
        {
        // Yes; forward the message
        HWND hwndLB = this->hwndLB;
        int iCaret = ListBox_GetCurSel(hwndLB);

        // Is this in a property page?
        if (RecAct_IsNoIcon(this) && 0 > iCaret)
            {
            // Yes; don't require the item to be selected
            iCaret = 0;
            }

        if (0 <= iCaret)
            {
            LPRA_PRIV ppriv;
            LPDOBJ pdobj;
            POINT pt;
            RECT rc;

            // Determine where to show the context menu
            ListBox_GetText(hwndLB, iCaret, &ppriv);
            pdobj = RecAct_ChooseCaretDobj(this, ppriv);

            ListBox_GetItemRect(hwndLB, iCaret, &rc);
            pt.x = pdobj->x + (g_cxIcon / 2) + rc.left;
            pt.y = pdobj->y + (g_cyIcon / 2) + rc.top;
            ClientToScreen(hwndLB, &pt);

            PostMessage(this->hwnd, WM_CONTEXTMENU, (WPARAM)hwndLB, MAKELPARAM(pt.x, pt.y));
            }
        nRet = 0;
        }

    return nRet;
    }

// ( (4+1) is for ellipses )
#define MAX_HALF    (ARRAYSIZE(pttt->szText)/2 - (4+1))

/*----------------------------------------------------------
Purpose: Handles TTN_NEEDTEXT

Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnNeedTipText(
    LPRECACT this,
    LPTOOLTIPTEXT pttt)
    {
    // Find the visible listbox item associated with this tip ID.
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV ppriv;
    int iItem;
    BOOL bInside;
    SIDEITEM * psi;

    iItem = RecAct_FindItemFromTipID(this, pttt->hdr.idFrom, &bInside);

    if (LB_ERR != iItem)
        {
        int cb;

        ListBox_GetText(hwndLB, iItem, &ppriv);
        if (bInside)
            psi = &ppriv->siInside;
        else
            psi = &ppriv->siOutside;

        // Need ellipses?
        cb = CbFromCch(lstrlen(psi->pszDir));
        if (cb >= sizeof(pttt->szText))
            {
            // Yes
            LPTSTR pszLastHalf;
            LPTSTR psz;
            LPTSTR pszStart = psi->pszDir;
            LPTSTR pszEnd = psi->pszDir[lstrlen(psi->pszDir)];

            for (psz = pszEnd;
                psz != pszStart && (pszEnd - psz) < MAX_HALF;
                psz = CharPrev(pszStart, psz))
                ;

            pszLastHalf = CharNext(psz);
            lstrcpyn(pttt->szText, psi->pszDir, MAX_HALF);
            lstrcat(pttt->szText, c_szEllipses);
            lstrcat(pttt->szText, pszLastHalf);
            }
        else
            lstrcpyn(pttt->szText, psi->pszDir, ARRAYSIZE(pttt->szText));
        }
    else
        *pttt->szText = 0;
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE RecAct_OnNotify(
    LPRECACT this,
    int idFrom,
    NMHDR  * lpnmhdr)
    {
    LRESULT lRet = 0;

    switch (lpnmhdr->code)
        {
    case HDN_BEGINTRACK:
        lRet = TRUE;       // prevent tracking
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: WM_CONTEXTMENU handler
Returns: --
Cond:    --
*/
void PRIVATE RecAct_OnContextMenu(
    LPRECACT this,
    HWND hwnd,
    int x,
    int y)
    {
    if (hwnd == this->hwndLB)
        {
        POINT pt;
        int iHitEntry;
        BOOL bHelpOnly;

        pt.x = x;
        pt.y = y;
        ScreenToClient(hwnd, &pt);

        iHitEntry = GetHitIndex(hwnd, pt);
        if (LB_ERR != iHitEntry)
            {
            ASSERT(iHitEntry < ListBox_GetCount(hwnd));

            ListBox_SetCurSel(hwnd, iHitEntry);
            ListBox_RepaintItemNow(hwnd, iHitEntry, NULL, FALSE);

            bHelpOnly = FALSE;
            }
        else
            bHelpOnly = TRUE;

        // Bring up the context menu for the listbox
        RecAct_DoContextMenu(this, x, y, iHitEntry, bHelpOnly);
        }
    }


/*----------------------------------------------------------
Purpose: Calculate the rectangle boundary of a sideitem

Returns: calculated rect
Cond:    --
*/
void PRIVATE RecAct_CalcSideItemRect(
    LPRECACT this,
    int nSide,          // SIDE_INSIDE or SIDE_OUTSIDE
    int cxFile,
    int cxAction,
    LPRECT prcOut)
    {
    int x;
    int y = g_cyIconMargin*2;
    int cx = ((this->cxItem - cxFile - cxAction) / 2);

    switch (nSide)
        {
    case SIDE_INSIDE:
        if (RecAct_IsNoIcon(this))
            x = 0;
        else
            x = cxFile;
        break;

    case SIDE_OUTSIDE:
        if (RecAct_IsNoIcon(this))
            x = cx + cxAction;
        else
            x = cxFile + cx + cxAction;
        break;

    default:
        ASSERT(0);
        break;
        }

    x += g_cxMargin;

    prcOut->left   = x + g_cxMargin;
    prcOut->top    = y;
    prcOut->right  = prcOut->left + (cx - 2*g_cxMargin);
    prcOut->bottom = y + (this->cyText * 3);
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_RecomputeItemMetrics(
    LPRECACT this,
    LPRA_PRIV ppriv)
    {
    HDC hdc = this->hdcOwn;
    LPDOBJ pdobj = ppriv->rgdobj;
    RECT rcT;
    RECT rcUnion;
    TCHAR szIDS[MAXBUFLEN];
    UINT ids;
    int cyText = this->cyText;
    int dx;
    int cxFile;
    int cxAction;
    POINT pt;

    // Compute the metrics and dimensions of each of the draw objects
    // and store back into the item.

    // File icon and label

    pt.x = 0;
    pt.y = 0;
    ComputeImageRects(FIGetDisplayName(ppriv->pfi), hdc, &pt, &rcT,
        &pdobj->rcLabel, g_cxIcon, g_cyIcon, g_cxIconSpacing, cyText);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = FIGetDisplayName(ppriv->pfi);
    pdobj->uFlags = DOF_DIFFER | DOF_CENTER;
    if (RecAct_IsNoIcon(this))
        {
        SetFlag(pdobj->uFlags, DOF_NODRAW);
        cxFile = 0;
        }
    else
        {
        cxFile = rcT.right - rcT.left;
        }
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlCache;
    pdobj->iImage = (UINT)ppriv->pfi->lParam;
    pdobj->rcBounding = rcT;

    rcUnion = pdobj->rcBounding;

    // Action image

    ASSERT(ppriv->uAction <= ARRAYSIZE(c_mpraiaiImage));

    pdobj++;

    ids = GetActionText(ppriv);
    pt.x = 0;       // (we'll adjust this after the call)
    pt.y = 0;
    ComputeImageRects(SzFromIDS(ids, szIDS, ARRAYSIZE(szIDS)), hdc, &pt,
        &rcT, &pdobj->rcLabel, CX_ACTIONBMP, CY_ACTIONBMP,
        g_cxIconSpacing, cyText);

    // (Adjust pt and the two rects to be centered in the remaining space)
    cxAction = rcT.right - rcT.left;
    dx = cxFile + (((this->cxItem - cxFile) / 2) - (cxAction / 2));
    pt.x += dx;
    OffsetRect(&rcT, dx, 0);
    OffsetRect(&pdobj->rcLabel, dx, 0);

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)ids;
    pdobj->uFlags = DOF_CENTER | DOF_USEIDS;
    if (!RecAct_IsNoIcon(this))
        SetFlag(pdobj->uFlags, DOF_IGNORESEL);
    pdobj->x = pt.x;
    pdobj->y = pt.y;
    pdobj->himl = this->himlAction;
    pdobj->iImage = c_mpraiaiImage[ppriv->uAction];
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &pdobj->rcBounding);

    // Sideitem Info (Inside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_INSIDE, cxFile, cxAction, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siInside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    // Sideitem Info (Outside Briefcase)

    RecAct_CalcSideItemRect(this, SIDE_OUTSIDE, cxFile, cxAction, &rcT);

    pdobj++;
    pdobj->uKind = DOK_SIDEITEM;
    pdobj->lpvObject = &ppriv->siOutside;
    pdobj->uFlags = DOF_LEFT;
    pdobj->x = rcT.left;
    pdobj->y = rcT.top;
    pdobj->rcClip = rcT;
    pdobj->rcBounding = rcT;

    UnionRect(&rcUnion, &rcUnion, &rcT);

    // Set the bounding rect of this item.
    ppriv->cx = rcUnion.right - rcUnion.left;
    ppriv->cy = max((rcUnion.bottom - rcUnion.top), g_cyIconSpacing);
    }


/*----------------------------------------------------------
Purpose: WM_MEASUREITEM handler
Returns: --
Cond:    --
*/
BOOL PRIVATE RecAct_OnMeasureItem(
    LPRECACT this,
    LPMEASUREITEMSTRUCT lpmis)
    {
    HDC hdc = this->hdcOwn;

    switch (lpmis->CtlType)
        {
    case ODT_LISTBOX: {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpmis->itemData;

        // Recompute item metrics?
        if (RECOMPUTE == ppriv->cx)
            {
            RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
            }

        lpmis->itemHeight = ppriv->cy;
        }
        return TRUE;

    case ODT_MENU:
        {
        int i;
        int cxMac = 0;
        RECT rc;
        TCHAR sz[MAXBUFLEN];

        // Calculate based on font and image dimensions.
        //
        SelectFont(hdc, this->hfont);

        cxMac = 0;
        for (i = 0; i < ARRAYSIZE(c_rgramid); i++)
            {
            SzFromIDS(c_rgramid[i].ids, sz, ARRAYSIZE(sz));
            SetRectFromExtent(hdc, &rc, sz);
            cxMac = max(cxMac,
                        g_cxMargin + CX_ACTIONBMP + g_cxMargin +
                        (rc.right-rc.left) + g_cxMargin);
            }

        lpmis->itemHeight = max(this->cyText, CY_ACTIONBMP);
        lpmis->itemWidth = cxMac;
        }
        return TRUE;
        }
    return FALSE;
    }


/*----------------------------------------------------------
Purpose: Draw a reconciliation listbox entry
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawLBItem(
    LPRECACT this,
    const DRAWITEMSTRUCT  * lpcdis)
    {
    LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    POINT ptSav;
    LPDOBJ pdobj;
    UINT cdobjs;

    if (!ppriv)
        {
        // Empty listbox and we're getting the focus
        return;
        }

    SetBkMode(hdc, TRANSPARENT);        // required for Shell_DrawText
    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);

    // The Chicago-look mandates that icon and filename are selected,
    // the rest of the entry is normal.

    // Recompute item metrics?
    if (RECOMPUTE == ppriv->cx)
        {
        RecAct_RecomputeItemMetrics(this, ppriv);   // Yes
        }

    // Do we need to redraw everything?
    if (IsFlagSet(lpcdis->itemAction, ODA_DRAWENTIRE))
        {
        // Yes
        TOOLINFO ti;

        cdobjs = ARRAYSIZE(ppriv->rgdobj);
        pdobj = ppriv->rgdobj;

        // Get the tooltip ID given this ith visible entry
        ti.cbSize = sizeof(ti);
        ti.uFlags = 0;
        ti.hwnd = this->hwndLB;
        ti.lpszText = LPSTR_TEXTCALLBACK;
        ti.uId = RecAct_GetTipIDFromItemID(this, lpcdis->itemID);
        ti.rect = ppriv->rgdobj[IDOBJ_INSIDE].rcBounding;
        OffsetRect(&ti.rect, lpcdis->rcItem.left, lpcdis->rcItem.top);
        SendMessage(this->hwndTip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);

        ti.uId++;
        ti.rect = ppriv->rgdobj[IDOBJ_OUTSIDE].rcBounding;
        OffsetRect(&ti.rect, lpcdis->rcItem.left, lpcdis->rcItem.top);
        SendMessage(this->hwndTip, TTM_NEWTOOLRECT, 0, (LPARAM)&ti);
        }
    else
        {
        // No; should we even draw the file icon or action icon?
        if (lpcdis->itemAction & (ODA_FOCUS | ODA_SELECT))
            {
            cdobjs = 1;     // Yes
            pdobj = RecAct_ChooseCaretDobj(this, ppriv);
            }
        else
            {
            cdobjs = 0;     // No
            pdobj = ppriv->rgdobj;
            }
        }

    Dobj_Draw(hdc, pdobj, cdobjs, lpcdis->itemState, this->cxEllipses, this->cyText,
        this->clrBkgnd);

    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: Draw an action menu item
Returns: --
Cond:    --
*/
void PRIVATE RecAct_DrawMenuItem(
    LPRECACT this,
    const DRAWITEMSTRUCT  * lpcdis)
    {
    LPRAMID pramid = (LPRAMID)lpcdis->itemData;
    HDC hdc = lpcdis->hDC;
    RECT rc = lpcdis->rcItem;
    DOBJ dobj;
    LPDOBJ pdobj;
    POINT ptSav;
    MENUITEMINFO mii;
    int cx;
    int cy;
    UINT uFlags;
    UINT uFlagsChecked;

    ASSERT(pramid);

    if (lpcdis->itemID == -1)
        return;

    SetViewportOrgEx(hdc, rc.left, rc.top, &ptSav);
    OffsetRect(&rc, -rc.left, -rc.top);

    cx = rc.right - rc.left;
    cy = rc.bottom - rc.top;

    // Get the menu state
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STATE | MIIM_CHECKMARKS;
    GetMenuItemInfo(this->hmenu, lpcdis->itemID, FALSE, &mii);
    uFlagsChecked = IsFlagClear(mii.fState, MFS_CHECKED) ? DOF_NODRAW : 0;

    uFlags = DOF_DIFFER | DOF_MENU | DOF_USEIDS;
    if (IsFlagSet(mii.fState, MFS_GRAYED))
        SetFlag(uFlags, DOF_DISABLED);

    // Build the array of DObjs that we want to draw.

    // Action image

    pdobj = &dobj;

    pdobj->uKind = DOK_IMAGE;
    pdobj->lpvObject = (LPVOID)pramid->ids;
    pdobj->himl = this->himlAction;
    pdobj->iImage = pramid->iImage;
    pdobj->uFlags = uFlags;
    pdobj->x = g_cxMargin;
    pdobj->y = (cy - CY_ACTIONBMP) / 2;
    pdobj->rcLabel.left = 0;
    pdobj->rcLabel.right = cx;
    pdobj->rcLabel.top = 0;
    pdobj->rcLabel.bottom = cy;

    // Draw the entry...
    //
    Dobj_Draw(hdc, &dobj, 1, lpcdis->itemState, 0, this->cyText, this->clrBkgnd);

    // Clean up
    //
    SetViewportOrgEx(hdc, ptSav.x, ptSav.y, NULL);
    }


/*----------------------------------------------------------
Purpose: WM_DRAWITEM handler
Returns: --
Cond:    --
*/
BOOL PRIVATE RecAct_OnDrawItem(
    LPRECACT this,
    const DRAWITEMSTRUCT  * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        RecAct_DrawLBItem(this, lpcdis);
        return TRUE;

    case ODT_MENU:
        RecAct_DrawMenuItem(this, lpcdis);
        return TRUE;
        }
    return FALSE;
    }


/*----------------------------------------------------------
Purpose: WM_COMPAREITEM handler
Returns: -1 (item 1 precedes item 2), 0 (equal), 1 (item 2 precedes item 1)
Cond:    --
*/
int PRIVATE RecAct_OnCompareItem(
    LPRECACT this,
    const COMPAREITEMSTRUCT  * lpcis)
    {
    LPRA_PRIV ppriv1 = (LPRA_PRIV)lpcis->itemData1;
    LPRA_PRIV ppriv2 = (LPRA_PRIV)lpcis->itemData2;

    // We sort based on name of file
    //
    return lstrcmpi(FIGetPath(ppriv1->pfi), FIGetPath(ppriv2->pfi));
    }


/*----------------------------------------------------------
Purpose: WM_DELETEITEM handler
Returns: --
Cond:    --
*/
void RecAct_OnDeleteLBItem(
    LPRECACT this,
    const DELETEITEMSTRUCT  * lpcdis)
    {
    switch (lpcdis->CtlType)
        {
    case ODT_LISTBOX:
        {
        LPRA_PRIV ppriv = (LPRA_PRIV)lpcdis->itemData;

        ASSERT(ppriv);

        if (ppriv)
            {
            FIFree(ppriv->pfi);

            GFree(ppriv->siInside.pszDir);
            GFree(ppriv->siOutside.pszDir);
            GFree(ppriv);
            }
        }
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_CTLCOLORLISTBOX handler
Returns: --
Cond:    --
*/
HBRUSH PRIVATE RecAct_OnCtlColorListBox(
    LPRECACT this,
    HDC hdc,
    HWND hwndLB,
    int nType)
    {
    return this->hbrBkgnd;
    }


/*----------------------------------------------------------
Purpose: WM_PAINT handler
Returns: --
Cond:    --
*/
void RecAct_OnPaint(
    LPRECACT this)
    {
    HWND hwnd = this->hwnd;
    PAINTSTRUCT ps;
    RECT rc;
    HDC hdc;

    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    if (IsFlagSet(this->lStyle, RAS_SINGLEITEM))
        {
        DrawEdge(hdc, &rc, BDR_SUNKENINNER, BF_TOPLEFT);
        DrawEdge(hdc, &rc, BDR_SUNKENOUTER, BF_BOTTOMRIGHT);
        }
    else
        {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT);
        }

    EndPaint(hwnd, &ps);
    }


/*----------------------------------------------------------
Purpose: WM_SETFONT handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFont(
    LPRECACT this,
    HFONT hfont,
    BOOL bRedraw)
    {
    this->hfont = hfont;
    FORWARD_WM_SETFONT(this->hwnd, hfont, bRedraw, RecAct_DefProc);
    }


/*----------------------------------------------------------
Purpose: WM_SETFOCUS handler
Returns: --
Cond:    --
*/
void RecAct_OnSetFocus(
    LPRECACT this,
    HWND hwndOldFocus)
    {
    SetFocus(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: WM_SYSCOLORCHANGE handler
Returns: --
Cond:    --
*/
void RecAct_OnSysColorChange(
    LPRECACT this)
    {
    RecAct_SetColors(this);
    InvalidateRect(this->hwnd, NULL, TRUE);
    }


/*----------------------------------------------------------
Purpose: Insert item
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnInsertItem(
    LPRECACT this,
    const LPRA_ITEM pitem)
    {
    HWND hwndLB = this->hwndLB;
    LPRA_PRIV pprivNew;
    TCHAR szPath[MAXPATHLEN];
    int iRet = -1;
    int iItem = LB_ERR;

    ASSERT(pitem);
    ASSERT(pitem->siInside.pszDir);
    ASSERT(pitem->siOutside.pszDir);
    ASSERT(pitem->pszName);

    pprivNew = GAlloc(sizeof(*pprivNew));
    if (pprivNew)
        {
        SetWindowRedraw(hwndLB, FALSE);

        // Fill the prerequisite fields first
        //
        pprivNew->uStyle = pitem->uStyle;
        pprivNew->uAction = pitem->uAction;

        // Set the fileinfo stuff and large icon system-cache index.
        //  If we can't get the fileinfo of the inside file, get the outside
        //  file.  If neither can be found, then we fail
        //
        lstrcpy(szPath, SkipDisplayJunkHack(&pitem->siInside));
        if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
            PathAppend(szPath, pitem->pszName);

        if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
            {
            // Try the outside file
            //
            lstrcpy(szPath, SkipDisplayJunkHack(&pitem->siOutside));
            if (IsFlagClear(pitem->uStyle, RAIS_FOLDER))
                PathAppend(szPath, pitem->pszName);

            if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON)))
                {
                // Don't try to touch the file
                if (FAILED(FICreate(szPath, &pprivNew->pfi, FIF_ICON | FIF_DONTTOUCH)))
                    goto Insert_Cleanup;
                }
            }
        ASSERT(pprivNew->pfi);

        pprivNew->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, pprivNew->pfi->hicon);

        // Fill in the rest of the fields
        //
        lstrcpy(szPath, pitem->siInside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        if (!GSetString(&pprivNew->siInside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siInside.uState = pitem->siInside.uState;
        pprivNew->siInside.fs = pitem->siInside.fs;
        pprivNew->siInside.ichRealPath = pitem->siInside.ichRealPath;

        lstrcpy(szPath, pitem->siOutside.pszDir);
        if (IsFlagSet(pitem->uStyle, RAIS_FOLDER))
            PathRemoveFileSpec(szPath);
        if (!GSetString(&pprivNew->siOutside.pszDir, szPath))
            goto Insert_Cleanup;

        pprivNew->siOutside.uState = pitem->siOutside.uState;
        pprivNew->siOutside.fs = pitem->siOutside.fs;
        pprivNew->siOutside.ichRealPath = pitem->siOutside.ichRealPath;

        pprivNew->lParam = pitem->lParam;

        pprivNew->cx = RECOMPUTE;

        // We know we're doing a redundant sorted add if the element
        //  needs to be inserted at the end of the list, but who cares.
        //
        if (pitem->iItem >= RecAct_GetCount(this))
            iItem = ListBox_AddString(hwndLB, pprivNew);
        else
            iItem = ListBox_InsertString(hwndLB, pitem->iItem, pprivNew);

        if (iItem == LB_ERR)
            goto Insert_Cleanup;

        SetWindowRedraw(hwndLB, TRUE);

        iRet = iItem;
        }
    goto Insert_End;

Insert_Cleanup:
    // Have DeleteString handler clean up field allocations
    //  of pitem.
    //
    if (iItem != LB_ERR)
        ListBox_DeleteString(hwndLB, iItem);
    else
        {
        FIFree(pprivNew->pfi);
        GFree(pprivNew);
        }
    SetWindowRedraw(hwndLB, TRUE);

Insert_End:

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Delete item
Returns: count of items left
Cond:    --
*/
int PRIVATE RecAct_OnDeleteItem(
    LPRECACT this,
    int i)
    {
    HWND hwndLB = this->hwndLB;

    return ListBox_DeleteString(hwndLB, i);
    }


/*----------------------------------------------------------
Purpose: Delete all items
Returns: TRUE
Cond:    --
*/
BOOL PRIVATE RecAct_OnDeleteAllItems(
    LPRECACT this)
    {
    ListBox_ResetContent(this->hwndLB);

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnGetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;

    iItem = pitem->iItem;
    uMask = pitem->mask;

    ListBox_GetText(hwndLB, iItem, &ppriv);

    if (uMask & RAIF_ACTION)
        pitem->uAction = ppriv->uAction;

    if (uMask & RAIF_NAME)
        pitem->pszName = FIGetPath(ppriv->pfi);

    if (uMask & RAIF_STYLE)
        pitem->uStyle = ppriv->uStyle;

    if (uMask & RAIF_INSIDE)
        pitem->siInside = ppriv->siInside;

    if (uMask & RAIF_OUTSIDE)
        pitem->siOutside = ppriv->siOutside;

    if (uMask & RAIF_LPARAM)
        pitem->lParam = ppriv->lParam;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Set item
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE RecAct_OnSetItem(
    LPRECACT this,
    LPRA_ITEM pitem)
    {
    LPRA_PRIV ppriv;
    HWND hwndLB = this->hwndLB;
    UINT uMask;
    int iItem;

    if (!pitem)
        return FALSE;

    uMask = pitem->mask;
    iItem = pitem->iItem;

    ListBox_GetText(hwndLB, iItem, &ppriv);

    if (uMask & RAIF_ACTION)
        ppriv->uAction = pitem->uAction;

    if (uMask & RAIF_STYLE)
        ppriv->uStyle = pitem->uStyle;

    if (uMask & RAIF_NAME)
        {
        if (!FISetPath(&ppriv->pfi, pitem->pszName, FIF_ICON))
            return FALSE;

        ppriv->pfi->lParam = (LPARAM)ImageList_AddIcon(this->himlCache, ppriv->pfi->hicon);
        }

    if (uMask & RAIF_INSIDE)
        {
        if (!GSetString(&ppriv->siInside.pszDir, pitem->siInside.pszDir))
            return FALSE;
        ppriv->siInside.uState = pitem->siInside.uState;
        ppriv->siInside.fs = pitem->siInside.fs;
        ppriv->siInside.ichRealPath = pitem->siInside.ichRealPath;
        }

    if (uMask & RAIF_OUTSIDE)
        {
        if (!GSetString(&ppriv->siOutside.pszDir, pitem->siOutside.pszDir))
            return FALSE;
        ppriv->siOutside.uState = pitem->siOutside.uState;
        ppriv->siOutside.fs = pitem->siOutside.fs;
        ppriv->siOutside.ichRealPath = pitem->siOutside.ichRealPath;
        }

    if (uMask & RAIF_LPARAM)
        ppriv->lParam = pitem->lParam;

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Get the current selection
Returns: index
Cond:    --
*/
int PRIVATE RecAct_OnGetCurSel(
    LPRECACT this)
    {
    return ListBox_GetCurSel(this->hwndLB);
    }


/*----------------------------------------------------------
Purpose: Set the current selection
Returns: --
Cond:    --
*/
int PRIVATE RecAct_OnSetCurSel(
    LPRECACT this,
    int i)
    {
    int iRet = ListBox_SetCurSel(this->hwndLB, i);

    if (iRet != LB_ERR)
        RecAct_SendSelChange(this, i);

    return iRet;
    }


/*----------------------------------------------------------
Purpose: Find an item
Returns: TRUE on success
Cond:    --
*/
int PRIVATE RecAct_OnFindItem(
    LPRECACT this,
    int iStart,
    const RA_FINDITEM  * prafi)
    {
    HWND hwndLB = this->hwndLB;
    UINT uMask = prafi->flags;
    LPRA_PRIV ppriv;
    BOOL bPass;
    int i;
    int cItems = ListBox_GetCount(hwndLB);

    for (i = iStart+1; i < cItems; i++)
        {
        bPass = TRUE;       // assume we pass

        ListBox_GetText(hwndLB, i, &ppriv);

        if (uMask & RAFI_NAME &&
            !IsSzEqual(FIGetPath(ppriv->pfi), prafi->psz))
            bPass = FALSE;

        if (uMask & RAFI_ACTION && ppriv->uAction != prafi->uAction)
            bPass = FALSE;

        if (uMask & RAFI_LPARAM && ppriv->lParam != prafi->lParam)
            bPass = FALSE;

        if (bPass)
            break;          // found it
        }

    return i == cItems ? -1 : i;
    }


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS


/*----------------------------------------------------------
Purpose: RecAct window proc
Returns: varies
Cond:    --
*/
LRESULT CALLBACK RecAct_WndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
    {
    LPRECACT this = RecAct_GetPtr(hwnd);

    if (this == NULL)
        {
        if (msg == WM_NCCREATE)
            {
            this = GAlloc(sizeof(*this));
            ASSERT(this);
            if (!this)
                return 0L;      // OOM failure

            this->hwnd = hwnd;
            RecAct_SetPtr(hwnd, this);
            }
        else
            {
            return RecAct_DefProc(hwnd, msg, wParam, lParam);
            }
        }

    if (msg == WM_NCDESTROY)
        {
        GFree(this);
        RecAct_SetPtr(hwnd, NULL);
        }

    switch (msg)
        {
        HANDLE_MSG(this, WM_CREATE, RecAct_OnCreate);
        HANDLE_MSG(this, WM_DESTROY, RecAct_OnDestroy);

        HANDLE_MSG(this, WM_SETFONT, RecAct_OnSetFont);
        HANDLE_MSG(this, WM_COMMAND, RecAct_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, RecAct_OnNotify);
        HANDLE_MSG(this, WM_MEASUREITEM, RecAct_OnMeasureItem);
        HANDLE_MSG(this, WM_DRAWITEM, RecAct_OnDrawItem);
        HANDLE_MSG(this, WM_COMPAREITEM, RecAct_OnCompareItem);
        HANDLE_MSG(this, WM_DELETEITEM, RecAct_OnDeleteLBItem);
        HANDLE_MSG(this, WM_CONTEXTMENU, RecAct_OnContextMenu);
        HANDLE_MSG(this, WM_SETFOCUS, RecAct_OnSetFocus);
        HANDLE_MSG(this, WM_CTLCOLORLISTBOX, RecAct_OnCtlColorListBox);
        HANDLE_MSG(this, WM_PAINT, RecAct_OnPaint);
        HANDLE_MSG(this, WM_SYSCOLORCHANGE, RecAct_OnSysColorChange);

        case RAM_GETITEMCOUNT:
                return (LRESULT)RecAct_GetCount(this);

        case RAM_GETITEM:
                return (LRESULT)RecAct_OnGetItem(this, (LPRA_ITEM)lParam);

        case RAM_SETITEM:
                return (LRESULT)RecAct_OnSetItem(this, (const LPRA_ITEM)lParam);

        case RAM_INSERTITEM:
                return (LRESULT)RecAct_OnInsertItem(this, (const LPRA_ITEM)lParam);

        case RAM_DELETEITEM:
                return (LRESULT)RecAct_OnDeleteItem(this, (int)wParam);

        case RAM_DELETEALLITEMS:
                return (LRESULT)RecAct_OnDeleteAllItems(this);

        case RAM_GETCURSEL:
                return (LRESULT)RecAct_OnGetCurSel(this);

        case RAM_SETCURSEL:
                return (LRESULT)RecAct_OnSetCurSel(this, (int)wParam);

        case RAM_FINDITEM:
                return (LRESULT)RecAct_OnFindItem(this, (int)wParam, (const RA_FINDITEM  *)lParam);

        case RAM_REFRESH:
                RedrawWindow(this->hwndLB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);

        default:
                return RecAct_DefProc(hwnd, msg, wParam, lParam);
                }
        }


/////////////////////////////////////////////////////  PUBLIC FUNCTIONS


/*----------------------------------------------------------
Purpose: Initialize the reconciliation-action window class
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC RecAct_Init(
    HINSTANCE hinst)
    {
    WNDCLASSEX wc;

    wc.cbSize       = sizeof(WNDCLASSEX);
    wc.style        = CS_DBLCLKS | CS_OWNDC;
    wc.lpfnWndProc  = RecAct_WndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LPRECACT);
    wc.hInstance    = hinst;
    wc.hIcon        = NULL;
    wc.hCursor      = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground= NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName= WC_RECACT;
    wc.hIconSm      = NULL;

    return RegisterClassEx(&wc) != 0;
    }


/*----------------------------------------------------------
Purpose: Clean up RecAct window class
Returns: --
Cond:    --
*/
void PUBLIC RecAct_Term(
    HINSTANCE hinst)
    {
    UnregisterClass(WC_RECACT, hinst);
    }


/*----------------------------------------------------------
Purpose: Special sub-class listbox proc
Returns: varies
Cond:    --
*/
LRESULT _export CALLBACK RecActLB_LBProc(
    HWND hwnd,          // window handle
    UINT uMsg,           // window message
    WPARAM wparam,      // varies
    LPARAM lparam)      // varies
    {
    LRESULT lRet;
    LPRECACT lpra = NULL;

    // Get the instance data for the control
    lpra = RecAct_GetPtr(GetParent(hwnd));
    ASSERT(lpra);

    switch (uMsg)
        {
    case WM_NOTIFY: {
        NMHDR * pnmhdr = (NMHDR *)lparam;

        if (TTN_NEEDTEXT == pnmhdr->code)
            {
            RecAct_OnNeedTipText(lpra, (LPTOOLTIPTEXT)pnmhdr);
            }
        }
        break;

    case WM_SYSKEYDOWN: {
        lRet = RecAct_OnSysKeyDown(lpra, (UINT)wparam, lparam);

        if (0 != lRet)
            lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
        }
        break;

    case WM_MOUSEMOVE: {
        MSG msg;

        ASSERT(hwnd == lpra->hwndLB);

        msg.lParam = lparam;
        msg.wParam = wparam;
        msg.message = uMsg;
        msg.hwnd = hwnd;
        SendMessage(lpra->hwndTip, TTM_RELAYEVENT, 0, (LPARAM)&msg);

        lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
        }
        break;

    default:
        lRet = RecActLB_DefProc(lpra->lpfnLBProc, hwnd, uMsg, wparam, lparam);
        break;
        }

    return lRet;
    }


//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Converts a recnode state to a sideitem state

Returns: see above
Cond:    --
*/
UINT PRIVATE SiFromRns(
    RECNODESTATE rnstate)
    {
    switch (rnstate)
        {
#ifdef NEW_REC
    case RNS_NEVER_RECONCILED:      return SI_CHANGED;
#endif

    case RNS_UNAVAILABLE:           return SI_UNAVAILABLE;
    case RNS_DOES_NOT_EXIST:        return SI_NOEXIST;
    case RNS_DELETED:               return SI_DELETED;
    case RNS_NOT_RECONCILED:        return SI_UNCHANGED;
    case RNS_UP_TO_DATE:            return SI_UNCHANGED;
    case RNS_CHANGED:               return SI_CHANGED;

    default:
        ASSERT(0);
        return SI_UNCHANGED;
        }
    }


/*----------------------------------------------------------
Purpose: Hack to skip potential volume name.

Returns: pointer to beginning of pathname in sideitem
Cond:    --
*/
LPCTSTR PRIVATE SkipDisplayJunkHack(
    LPSIDEITEM psi)
    {
    UINT ich;

    ASSERT(psi);
    ASSERT(psi->pszDir);
    ASSERT(TEXT('(') == *psi->pszDir && 0 < psi->ichRealPath ||
           0 == psi->ichRealPath);
    ASSERT(psi->ichRealPath <= (UINT)lstrlen(psi->pszDir));

    // Paranoid checking here.  This function is being added close
    // to RTM, so as an added safety net, we're adding this min()
    // check.  For Nashville, after we're sure that there is no
    // problem with ichRealPath, we can remove the min() function.
    ich = min(psi->ichRealPath, (UINT)lstrlen(psi->pszDir));
    return &psi->pszDir[ich];
    }


/*----------------------------------------------------------
Purpose: Returns a path that uses the share name of the hvid,
         or the machine name if that is not available.

Returns: Pointer to buffer
Cond:    --
*/
LPTSTR PRIVATE GetAlternativePath(
    LPTSTR pszBuf,           // Must be MAX_PATH in length
    LPCTSTR pszPath,
    HVOLUMEID hvid,
    LPUINT pichRealPath)
    {
    TWINRESULT tr;
    VOLUMEDESC vd;

    ASSERT(pichRealPath);

    *pichRealPath = 0;

    vd.ulSize = sizeof(vd);
    tr = Sync_GetVolumeDescription(hvid, &vd);
    if (TR_SUCCESS == tr)
        {
        // Is a share name available?
        if (IsFlagSet(vd.dwFlags, VD_FL_NET_RESOURCE_VALID))
            {
            // Yes; use that
            lstrcpy(pszBuf, vd.rgchNetResource);
            PathAppend(pszBuf, PathFindEndOfRoot(pszPath));
            PathMakePresentable(pszBuf);
            }
        else if (IsFlagSet(vd.dwFlags, VD_FL_VOLUME_LABEL_VALID))
            {
            // No; use volume label
            LPTSTR pszMsg;

            PathMakePresentable(vd.rgchVolumeLabel);
            if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(IDS_ALTNAME),
                vd.rgchVolumeLabel, pszPath))
                {
                lstrcpy(pszBuf, pszMsg);
                GFree(pszMsg);
                }
            else
                lstrcpy(pszBuf, pszPath);

            *pichRealPath = 3 + lstrlen(vd.rgchVolumeLabel);
            PathMakePresentable(&pszBuf[*pichRealPath]);
            }
        else
            {
            lstrcpy(pszBuf, pszPath);
            PathMakePresentable(pszBuf);
            }
        }
    else
        {
        lstrcpy(pszBuf, pszPath);
        PathMakePresentable(pszBuf);
        }

    return pszBuf;
    }


/*----------------------------------------------------------
Purpose: Constructs a path that would be appropriate for
         the sideitem structure.  The path is placed in the
         provided buffer.

         Typically the path will simply be the folder path in
         the recnode.  In cases when the recnode is unavailable,
         this function prepends the machine name (or share name)
         to the path.

Returns: --
Cond:    --
*/
void PRIVATE PathForSideItem(
    LPTSTR pszBuf,           // Must be MAX_PATH in length
    HVOLUMEID hvid,
    LPCTSTR pszFolder,
    RECNODESTATE rns,
    LPUINT pichRealPath)
    {
    ASSERT(pszBuf);
    ASSERT(pszFolder);
    ASSERT(pichRealPath);

    if (RNS_UNAVAILABLE == rns)
        GetAlternativePath(pszBuf, pszFolder, hvid, pichRealPath);
    else
        {
        lstrcpy(pszBuf, pszFolder);
        PathMakePresentable(pszBuf);
        *pichRealPath = 0;
        }
    MyPathRemoveBackslash(pszBuf);
    }


/*----------------------------------------------------------
Purpose: Determines the recact action based on the combination
         of the inside and outside recnode actions

Returns: FALSE if this pair seems like an unlikely match.

         (This can occur if there are two recnodes inside the
         briefcase and we choose the wrong one such that the
         pair consists of two destinations but no source.)

Cond:    --
*/
BOOL PRIVATE DeriveFileAction(
    RA_ITEM * pitem,
    RECNODEACTION rnaInside,
    RECNODEACTION rnaOutside)
    {
    BOOL bRet = TRUE;

    if (RNA_COPY_FROM_ME == rnaInside &&
        RNA_COPY_TO_ME == rnaOutside)
        {
        pitem->uAction = RAIA_TOOUT;
        }
    else if (RNA_COPY_TO_ME == rnaInside &&
        RNA_COPY_FROM_ME == rnaOutside)
        {
        pitem->uAction = RAIA_TOIN;
        }

#ifdef NEW_REC
    else if (RNA_DELETE_ME == rnaInside)
        {
        pitem->uAction = RAIA_DELETEIN;
        }
    else if (RNA_DELETE_ME == rnaOutside)
        {
        pitem->uAction = RAIA_DELETEOUT;
        }
#endif

    else if (RNA_MERGE_ME == rnaInside &&
        RNA_MERGE_ME == rnaOutside)
        {
        pitem->uAction = RAIA_MERGE;
        }
    else if (RNA_COPY_TO_ME == rnaInside &&
        RNA_MERGE_ME == rnaOutside)
        {
        // (This is the merge-first-then-copy to third
        // file case.  We sorta punt because we're not
        // showing the implicit merge.)
        pitem->uAction = RAIA_TOIN;
        }
    else if (RNA_MERGE_ME == rnaInside &&
        RNA_COPY_TO_ME == rnaOutside)
        {
        // (This is the merge-first-then-copy to third
        // file case.  We sorta punt because we're not
        // showing the implicit merge.)
        pitem->uAction = RAIA_TOOUT;
        }
    else if (RNA_NOTHING == rnaInside)
        {
        // Is one side unavailable?
        if (SI_UNAVAILABLE == pitem->siInside.uState ||
            SI_UNAVAILABLE == pitem->siOutside.uState)
            {
            // Yes; force a skip
            pitem->uAction = RAIA_SKIP;
            }
        else if (SI_DELETED == pitem->siOutside.uState)
            {
            // No; the outside was deleted and the user had previously
            // said don't delete, so it is an orphan now.
            pitem->uAction = RAIA_ORPHAN;
            }
        else
            {
            // No; it is up-to-date or both sides don't exist
            pitem->uAction = RAIA_NOTHING;
            }
        }
    else
        {
        pitem->uAction = RAIA_TOIN;

        bRet = FALSE;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Determines the action and possibly a better inside
         path if there are multiple nodes to pick from.

Returns: better (or same) inside path
Cond:    --
*/
PCHOOSESIDE PRIVATE DeriveFileActionAndSide(
    RA_ITEM * pitem,
    HDSA hdsa,
    PCHOOSESIDE pchsideInside,
    PCHOOSESIDE pchsideOutside,     // May be NULL
    BOOL bKeepFirstChoice)
    {
    ASSERT(pchsideInside);

    if (pchsideOutside)
        {
        PRECNODE prnInside = pchsideInside->prn;
        PRECNODE prnOutside = pchsideOutside->prn;
        PRECITEM pri = prnInside->priParent;

#ifndef NEW_REC
        // Was the original deleted?
        if (RNS_DELETED == prnOutside->rnstate)
            {
            // Yes; make this an orphan
            TRACE_MSG(TF_GENERAL, TEXT("Found outside path to be deleted"));

            pitem->uAction = RAIA_ORPHAN;
            }
        else
#endif
            {
            // No
            BOOL bDoAgain;
            PCHOOSESIDE pchside = pchsideInside;

            // Determine the action based on the currently
            // chosen inside and outside pair.  If DeriveFileAction
            // determines that the current inside selection is
            // unlikely, we get the next best choice and try
            // again.

            do
                {
                BOOL bGetNextBest = !DeriveFileAction(pitem,
                                            pchside->prn->rnaction,
                                            prnOutside->rnaction);

                bDoAgain = FALSE;
                if (!bKeepFirstChoice)
                    {
                    if (bGetNextBest &&
                        2 < pri->ulcNodes)
                        {
                        TRACE_MSG(TF_GENERAL, TEXT("Getting next best node"));

                        if (!ChooseSide_GetNextBest(hdsa, &pchside))
                            break;

                        bDoAgain = TRUE;
                        }
                    else if (!bGetNextBest)
                        pchsideInside = pchside;
                    else
                        ASSERT(0);
                    }

                } while (bDoAgain);

            // Is this a broken merge?
            if (RIA_BROKEN_MERGE == pri->riaction)
                {
                // Yes; override and say it is a conflict
                pitem->uAction = RAIA_CONFLICT;
                }
            }
        }
    else
        {
        TRACE_MSG(TF_GENERAL, TEXT("Outside path doesn't exist in recitem"));

        pitem->uAction = RAIA_ORPHAN;
        }
    return pchsideInside;
    }


/*----------------------------------------------------------
Purpose: Updates *prns and *prna based on given pchside, or
         leaves them alone.

Returns: --
Cond:    --
*/
void PRIVATE DeriveFolderStateAndAction(
    PCHOOSESIDE pchside,
    RECNODESTATE * prns,
    UINT * puAction)
    {
    PRECNODE prn;

    ASSERT(pchside);
    ASSERT(prns);
    ASSERT(puAction);
    ASSERT(RAIA_SOMETHING == *puAction || RAIA_NOTHING == *puAction ||
           RAIA_SKIP == *puAction);

    prn = pchside->prn;
    ASSERT(prn);

    switch (prn->rnstate)
        {
    case RNS_UNAVAILABLE:
        *prns = RNS_UNAVAILABLE;
        *puAction = RAIA_SKIP;      // (Always takes precedence)
        break;

#ifdef NEW_REC
    case RNS_NEVER_RECONCILED:
#endif
    case RNS_CHANGED:
        *prns = RNS_CHANGED;
        if (RAIA_NOTHING == *puAction)
            *puAction = RAIA_SOMETHING;
        break;

    case RNS_DELETED:
#ifdef NEW_REC
        if (RNA_DELETE_ME == prn->rnaction)
            {
            *prns = RNS_CHANGED;
            if (RAIA_NOTHING == *puAction)
                *puAction = RAIA_SOMETHING;
            }
#else
        // Leave the state as it is
#endif
        break;

    case RNS_DOES_NOT_EXIST:
    case RNS_UP_TO_DATE:
    case RNS_NOT_RECONCILED:
        switch (prn->rnaction)
            {
        case RNA_COPY_TO_ME:
#ifdef NEW_REC
            if (RAIA_NOTHING == *puAction)
                *puAction = RAIA_SOMETHING;

#else
            // Poor man's tombstoning.  Don't say the folder
            // needs updating if files have been deleted or
            // the whole folder has been deleted.
            //
            if (!PathExists(prn->pcszFolder))
                {
                // Folder is gone.  Say this is an orphan now.
                *prns = RNS_DELETED;
                }
            else if (RAIA_NOTHING == *puAction)
                {
                *puAction = RAIA_SOMETHING;
                }
#endif
            break;

#ifdef NEW_REC
        case RNA_DELETE_ME:
#endif
        case RNA_MERGE_ME:
            if (RAIA_NOTHING == *puAction)
                *puAction = RAIA_SOMETHING;
            break;
            }
        break;

    default:
        ASSERT(0);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: Determine the recnode state of a folder that has
         no intersecting recnodes.

Returns: recnode state
Cond:    --
*/
RECNODESTATE PRIVATE DeriveFolderState(
    PCHOOSESIDE pchside)
    {
    UINT uStatus;
    RECNODESTATE rns;

    Sync_GetFolderTwinStatus((HFOLDERTWIN)pchside->htwin, NULL, 0, &uStatus);
    if (FTS_UNAVAILABLE == uStatus)
        rns = RNS_UNAVAILABLE;
    else
        rns = RNS_UP_TO_DATE;
    return rns;
    }


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
         is a file.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE RAI_InitAsRecItem(
    LPRA_ITEM pitem,
    LPCTSTR pszBrfPath,
    LPCTSTR pszPath,              // May be NULL
    PRECITEM pri,
    BOOL bKeepFirstChoice)
    {
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pri);

    hres = ChooseSide_CreateAsFile(&hdsa, pri);
    if (SUCCEEDED(hres))
        {
        TCHAR sz[MAX_PATH];
        PCHOOSESIDE pchside;
        PCHOOSESIDE pchsideOutside;
        UINT ichRealPath;

        DEBUG_CODE( Sync_DumpRecItem(TR_SUCCESS, pri, TEXT("RAI_InitAsFile")); )

        pitem->mask = RAIF_ALL & ~RAIF_LPARAM;
        if (!GSetString(&pitem->pszName, pri->pcszName))
            goto Error;
        PathMakePresentable(pitem->pszName);

        // Default style
        if (RIA_MERGE == pri->riaction)
            pitem->uStyle = RAIS_CANMERGE;
        else
            pitem->uStyle = 0;

        // Is there an outside file?
        if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
            {
            // Yes
            RECNODESTATE rns = pchside->prn->rnstate;

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

            pitem->siOutside.uState = SiFromRns(rns);
            PathForSideItem(sz, pchside->hvid, pchside->pszFolder, rns, &ichRealPath);
            if (!GSetString(&pitem->siOutside.pszDir, sz))
                goto Error;
            pitem->siOutside.fs = pchside->prn->fsCurrent;
            pitem->siOutside.ichRealPath = ichRealPath;
            }
        else
            {
            // No; this is an orphan
            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

            if (!GSetString(&pitem->siOutside.pszDir, c_szNULL))
                goto Error;
            pitem->siOutside.uState = SI_NOEXIST;
            pitem->siOutside.ichRealPath = 0;
            }
        pchsideOutside = pchside;

        // Make sure we have some fully qualified folder on which
        // to base our decision for an inside path
        if (pszPath)
            {
            lstrcpy(sz, pszPath);
            PathRemoveFileSpec(sz);
            }
        else
            lstrcpy(sz, pszBrfPath);    // (best we can do...)

        // Get the inside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, sz, &pchside))
            {
            RECNODESTATE rns;

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )

            pchside = DeriveFileActionAndSide(pitem, hdsa, pchside, pchsideOutside, bKeepFirstChoice);

            // Determine status of inside file
            rns = pchside->prn->rnstate;

            pitem->siInside.uState = SiFromRns(rns);
            PathForSideItem(sz, pchside->hvid, pchside->pszFolder, rns, &ichRealPath);
            GSetString(&pitem->siInside.pszDir, sz);
            pitem->siInside.fs = pchside->prn->fsCurrent;
            pitem->siInside.ichRealPath = ichRealPath;

            // Is there a node for the outside?
            if (pchsideOutside)
                {
                // Yes; special case.  If a single side does not exist
                // then say the existing side is new.
                if (SI_NOEXIST == pitem->siInside.uState &&
                    SI_NOEXIST == pitem->siOutside.uState)
                    ;       // Do nothing special
                else if (SI_NOEXIST == pitem->siInside.uState)
                    {
                    ASSERT(SI_NOEXIST != pitem->siOutside.uState);
                    pitem->siOutside.uState = SI_NEW;
                    }
                else if (SI_NOEXIST == pitem->siOutside.uState)
                    {
                    ASSERT(SI_NOEXIST != pitem->siInside.uState);
                    pitem->siInside.uState = SI_NEW;
                    }
                }

            // Save away twin handle.  Use the inside htwin because
            // we want to always delete from inside the briefcase
            // (it's all in your perspective...)
            pitem->htwin = (HTWIN)pchside->prn->hObjectTwin;
            }
        else
            {
            // It is relatively bad to be here

            DEBUG_CODE( ChooseSide_DumpList(hdsa); )
            ASSERT(0);

            hres = E_FAIL;
            }

        DEBUG_CODE( DumpTwinPair(pitem); )

        ChooseSide_Free(hdsa);
        hdsa = NULL;
        }
    else
        {
        hdsa = NULL;

Error:
        hres = E_OUTOFMEMORY;
        }

    if (FAILED(hres))
        {
        ChooseSide_Free(hdsa);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Choose a recitem whose name matches the given name.

Returns: A pointer to the recitem in the given reclist
         NULL if filespec is not found

Cond:    --
*/
PRECITEM PRIVATE ChooseRecItem(
    PRECLIST prl,
    LPCTSTR pszName)
    {
    PRECITEM pri;

    for (pri = prl->priFirst; pri; pri = pri->priNext)
        {
        if (IsSzEqual(pri->pcszName, pszName))
            return pri;
        }
    return NULL;
    }


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
         is a file.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE RAI_InitAsFile(
    LPRA_ITEM pitem,
    LPCTSTR pszBrfPath,
    LPCTSTR pszPath,
    PRECLIST prl)
    {
    HRESULT hres;
    PRECITEM pri;
    LPCTSTR pszFile;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pszPath);
    ASSERT(prl);

    pszFile = PathFindFileName(pszPath);
    pri = ChooseRecItem(prl, pszFile);
    ASSERT(pri);

    if (pri)
        {
        hres = RAI_InitAsRecItem(pitem, pszBrfPath, pszPath, pri, TRUE);
        }
    else
        {
        hres = E_OUTOFMEMORY;
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Initialize a paired-twin structure assuming pszPath
         is a file.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE RAI_InitAsFolder(
    LPRA_ITEM pitem,
    LPCTSTR pszBrfPath,
    LPCTSTR pszPath,              // Should be inside the briefcase
    PRECLIST prl,
    PFOLDERTWINLIST pftl)
    {
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pitem);
    ASSERT(pszBrfPath);
    ASSERT(pszPath);
    ASSERT(prl);
    ASSERT(pftl);
    ASSERT(0 < pftl->ulcItems);

    pitem->mask = RAIF_ALL & ~RAIF_LPARAM;

    DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("RAI_InitAsFolder")); )
    DEBUG_CODE( Sync_DumpFolderTwinList(pftl, NULL); )

    // We only need to flag RAIS_FOLDER for the folder case.
    // (Context menu isn't available for folders, so RAIS_CANMERGE is
    //  unnecessary.)
    //
    pitem->uStyle = RAIS_FOLDER;

    hres = ChooseSide_CreateEmpty(&hdsa);
    if (SUCCEEDED(hres))
        {
        PRECITEM pri;
        RECNODESTATE rnsInside;
        RECNODESTATE rnsOutside;
        PCHOOSESIDE pchside;

        // Set starting defaults
        pitem->uAction = RAIA_NOTHING;
        rnsInside = RNS_UP_TO_DATE;
        rnsOutside = RNS_UP_TO_DATE;

        // Iterate thru reclist, choosing recnode pairs and dynamically
        // updating rnsInside, rnsOutside and pitem->uAction.
        for (pri = prl->priFirst; pri; pri = pri->priNext)
            {
            ChooseSide_InitAsFile(hdsa, pri);

            // Get the inside item
            if (ChooseSide_GetBest(hdsa, pszBrfPath, pszPath, &pchside))
                {
                DeriveFolderStateAndAction(pchside, &rnsInside, &pitem->uAction);
                }
            else
                ASSERT(0);

            // Get the outside item
            if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
                {
                DeriveFolderStateAndAction(pchside, &rnsOutside, &pitem->uAction);
                }
            else
                ASSERT(0);
            }
        ChooseSide_Free(hdsa);

        // Finish up
        hres = ChooseSide_CreateAsFolder(&hdsa, pftl);
        if (SUCCEEDED(hres))
            {
            TCHAR sz[MAX_PATH];
            UINT ichRealPath;

            // Name
            if (!GSetString(&pitem->pszName, PathFindFileName(pszPath)))
                goto Error;
            PathMakePresentable(pitem->pszName);

            // Get the inside folder
            if (ChooseSide_GetBest(hdsa, pszBrfPath, pszPath, &pchside))
                {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                // Are there any intersecting files in this folder twin?
                if (0 == prl->ulcItems)
                    rnsInside = DeriveFolderState(pchside);     // No

                pitem->siInside.uState = SiFromRns(rnsInside);
                PathForSideItem(sz, pchside->hvid, pchside->pszFolder, rnsInside, &ichRealPath);
                if (!GSetString(&pitem->siInside.pszDir, sz))
                    goto Error;
                // (Hack to avoid printing bogus time/date)
                pitem->siInside.fs.fscond = FS_COND_UNAVAILABLE;
                pitem->siInside.ichRealPath = ichRealPath;
                }
            else
                {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )
                ASSERT(0);
                }

            // Get the outside folder
            if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
                {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )

                // Are there any intersecting files in this folder twin?
                if (0 == prl->ulcItems)
                    rnsOutside = DeriveFolderState(pchside);     // No

                pitem->siOutside.uState = SiFromRns(rnsOutside);
                PathForSideItem(sz, pchside->hvid, pchside->pszFolder, rnsOutside, &ichRealPath);
                if (!GSetString(&pitem->siOutside.pszDir, sz))
                    goto Error;
                // (Hack to avoid printing bogus time/date)
                pitem->siOutside.fs.fscond = FS_COND_UNAVAILABLE;
                pitem->siOutside.ichRealPath = ichRealPath;

                // Save away twin handle.  Use the outside handle
                // for folders.
                pitem->htwin = pchside->htwin;
                }
            else
                {
                DEBUG_CODE( ChooseSide_DumpList(hdsa); )
                ASSERT(0);
                }

            DEBUG_CODE( DumpTwinPair(pitem); )

            ChooseSide_Free(hdsa);
            }
        }

    if (FAILED(hres))
        {
Error:
        if (SUCCEEDED(hres))
            hres = E_OUTOFMEMORY;

        ChooseSide_Free(hdsa);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a paired-twin structure given a path name.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC RAI_Create(
    LPRA_ITEM * ppitem,
    LPCTSTR pszBrfPath,
    LPCTSTR pszPath,              // Should be inside the briefcase
    PRECLIST prl,
    PFOLDERTWINLIST pftl)       // NULL if pszPath is a file
    {
    HRESULT hres;
    LPRA_ITEM pitem;

    ASSERT(ppitem);
    ASSERT(pszPath);
    ASSERT(pszBrfPath);
    ASSERT(prl);

    DBG_ENTER_SZ(TEXT("RAI_Create"), pszPath);

    if (PathExists(pszPath))
        {
        pitem = GAlloc(sizeof(*pitem));
        if (pitem)
            {
            if (PathIsDirectory(pszPath))
                hres = RAI_InitAsFolder(pitem, pszBrfPath, pszPath, prl, pftl);
            else
                hres = RAI_InitAsFile(pitem, pszBrfPath, pszPath, prl);

            if (FAILED(hres))
                {
                // Cleanup
                RAI_Free(pitem);
                pitem = NULL;
                }
            }
        else
            hres = E_OUTOFMEMORY;
        }
    else
        {
        pitem = NULL;
        hres = E_FAIL;
        }

    *ppitem = pitem;

    DBG_EXIT_HRES(TEXT("RAI_Create"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a paired-twin structure given a recitem.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC RAI_CreateFromRecItem(
    LPRA_ITEM * ppitem,
    LPCTSTR pszBrfPath,
    PRECITEM pri)
    {
    HRESULT hres;
    LPRA_ITEM pitem;

    ASSERT(ppitem);
    ASSERT(pszBrfPath);
    ASSERT(pri);

    DBG_ENTER(TEXT("RAI_CreateFromRecItem"));

    pitem = GAlloc(sizeof(*pitem));
    if (pitem)
        {
        hres = RAI_InitAsRecItem(pitem, pszBrfPath, NULL, pri, FALSE);

        if (FAILED(hres))
            {
            // Cleanup
            RAI_Free(pitem);
            pitem = NULL;
            }
        }
    else
        hres = E_OUTOFMEMORY;

    *ppitem = pitem;

    DBG_EXIT_HRES(TEXT("RAI_CreateFromRecItem"), hres);

    return hres;
    }


/*----------------------------------------------------------
Purpose: Free a paired item structure

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC RAI_Free(
    LPRA_ITEM pitem)
    {
    HRESULT hres;

    if (pitem)
        {
        GFree(pitem->pszName);
        GFree(pitem->siInside.pszDir);
        GFree(pitem->siOutside.pszDir);
        GFree(pitem);
        hres = NOERROR;
        }
    else
        hres = E_FAIL;

    return hres;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\recact.h ===
//
// recact.h: Declares data, defines and struct types for RecAct
//                                module.
//
//

#ifndef __RECACT_H__
#define __RECACT_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

// RecAct message ranges
//
#define RAM_FIRST       (WM_USER+1)
#define RAM_LAST        (WM_USER+20)
#define RN_FIRST        (0U-700U)
#define RN_LAST         (0U-799U)

// Window class name
//
#define WC_RECACT       TEXT("RecAction")



// BOOL RecAct_Enable(HWND hwnd, BOOL fEnable);
//
#define RecAct_Enable(hwnd, fEnable) \
        EnableWindow((hwnd), (fEnable))

// int RecAct_GetItemCount(HWND hwnd);
//
#define RAM_GETITEMCOUNT                (RAM_FIRST + 0)
#define RecAct_GetItemCount(hwnd) \
                (int)SendMessage(hwnd, RAM_GETITEMCOUNT, 0, 0L)

// Side item structure
//
#define SI_UNCHANGED    0
#define SI_CHANGED      1
#define SI_NEW          2
#define SI_NOEXIST      3
#define SI_UNAVAILABLE  4
#define SI_DELETED      5

typedef struct tagSIDE_ITEM
    {
    LPTSTR pszDir;
    UINT uState;        // One of SI_* flags
    FILESTAMP fs;
    UINT ichRealPath;   // index to beginning of real path
    } SIDEITEM,  * LPSIDEITEM;

// RecAction Item structure
//
#define RAIF_ACTION      0x0001     // Mask codes
#define RAIF_NAME        0x0002
#define RAIF_STYLE       0x0004
#define RAIF_INSIDE      0x0008
#define RAIF_OUTSIDE     0x0010
#define RAIF_LPARAM      0x0020
#define RAIF_HTWIN       0x0040

#define RAIF_ALL         0x007f


typedef struct tagRA_ITEM
    {
    UINT mask;          // One of RAIF_
    int iItem;
    UINT uStyle;        // One of RAIS_
    UINT uAction;       // One of RAIA_

    LPTSTR pszName;

    SIDEITEM siInside;
    SIDEITEM siOutside;

    LPARAM lParam;
    HTWIN htwin;

    } RA_ITEM,  * LPRA_ITEM;


// RecAct item styles
//
#define RAIS_CANMERGE   0x0001
#define RAIS_FOLDER     0x0002

// RecAct actions
//
#define RAIA_TOOUT      0       // Don't change these values without changing
#define RAIA_TOIN       1       //  the order of the bitmaps in s_rgidAction
#define RAIA_SKIP       2
#define RAIA_CONFLICT   3
#define RAIA_MERGE      4
#define RAIA_SOMETHING  5       // These two require RAIS_FOLDER
#define RAIA_NOTHING    6
#define RAIA_ORPHAN     7
#define RAIA_DELETEOUT  8
#define RAIA_DELETEIN   9
#define RAIA_DONTDELETE 10

// Insert item at specified index.  Item is inserted at end if
// i is greater than or equal to the number of items in the twinview.
// Returns the index of the inserted item, or -1 on error.
//
// int RecAct_InsertItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_INSERTITEM              (RAM_FIRST + 1)
#define RecAct_InsertItem(hwnd, pitem) \
                (int)SendMessage((hwnd), RAM_INSERTITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Delete an item at the specified index.
//
// int RecAct_DeleteItem(HWND hwnd, int i);
//
#define RAM_DELETEITEM                  (RAM_FIRST + 2)
#define RecAct_DeleteItem(hwnd, i) \
                (int)SendMessage((hwnd), RAM_DELETEITEM, (WPARAM)(int)(i), 0L)

// Deletes all items in the control
//
// BOOL RecAct_DeleteAllItems(HWND hwnd);
//
#define RAM_DELETEALLITEMS              (RAM_FIRST + 3)
#define RecAct_DeleteAllItems(hwnd) \
                (BOOL)SendMessage((hwnd), RAM_DELETEALLITEMS, 0, 0L)

// BOOL RecAct_GetItem(HWND hwnd, LPRA_ITEM pitem);
//
#define RAM_GETITEM                             (RAM_FIRST + 4)
#define RecAct_GetItem(hwnd, pitem) \
                (BOOL)SendMessage((hwnd), RAM_GETITEM, 0, (LPARAM)(LPRA_ITEM)(pitem))

// BOOL RecAct_SetItem(HWND hwnd, const LPRA_ITEM pitem);
//
#define RAM_SETITEM                             (RAM_FIRST + 5)
#define RecAct_SetItem(hwnd, pitem) \
                (BOOL)SendMessage((hwnd), RAM_SETITEM, 0, (LPARAM)(const LPRA_ITEM)(pitem))

// Get the current selection by index.  -1 if nothing is selected.
//
// int RecAct_GetCurSel(HWND hwnd);
//
#define RAM_GETCURSEL                   (RAM_FIRST + 6)
#define RecAct_GetCurSel(hwnd) \
                (int)SendMessage((hwnd), RAM_GETCURSEL, (WPARAM)0, 0L)

// Set the current selection by index.  -1 to deselect.
//
// int RecAct_SetCurSel(HWND hwnd, int i);
//
#define RAM_SETCURSEL                   (RAM_FIRST + 7)
#define RecAct_SetCurSel(hwnd, i) \
                (int)SendMessage((hwnd), RAM_SETCURSEL, (WPARAM)(i), 0L)

// RecAct_FindItem flags
//
#define RAFI_NAME       0x0001
#define RAFI_LPARAM     0x0002
#define RAFI_ACTION     0x0004

typedef struct tagRA_FINDITEM
    {
    UINT    flags;      // One of RAFI_* flags
    UINT    uAction;    // One of RAIA_* flags
    LPCTSTR  psz;
    LPARAM  lParam;
    
    } RA_FINDITEM;

// Find an item according to RA_FINDITEM struct.  iStart = -1 to
//  start at beginning.
//
// int RecAct_FindItem(HWND hwnd, int iStart, const RA_FINDITEM FAR* prafi);
#define RAM_FINDITEM                            (RAM_FIRST + 8)
#define RecAct_FindItem(hwnd, iStart, prafi) \
                (int)SendMessage((hwnd), RAM_FINDITEM, (WPARAM)(int)(iStart), (LPARAM)(const RA_FINDINFO *)(prafi))

// Refresh the control.
//
// void RecAct_Refresh(HWND hwnd);
#define RAM_REFRESH                             (RAM_FIRST + 9)
#define RecAct_Refresh(hwnd) \
                SendMessage((hwnd), RAM_REFRESH, 0, 0L)


// Notification codes
//
#define RN_SELCHANGED   (RN_FIRST-0)
#define RN_ITEMCHANGED  (RN_FIRST-1)

typedef struct tagNM_RECACT
    {
    NMHDR   hdr;
    int     iItem;
    UINT    mask;           // One of RAIF_* 
    UINT    uAction;        // One of RAIA_*
    UINT    uActionOld;     // One of RAIA_*
    LPARAM  lParam;
    
    } NM_RECACT;

// Window styles
#define RAS_SINGLEITEM  0x0001L


/////////////////////////////////////////////////////  EXPORTED DATA


/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL PUBLIC RecAct_Init (HINSTANCE hinst);
void PUBLIC RecAct_Term(HINSTANCE hinst);

HRESULT PUBLIC RAI_Create(LPRA_ITEM * ppitem, LPCTSTR pszBrfPath, LPCTSTR pszPath, PRECLIST prl, PFOLDERTWINLIST pftl);
HRESULT PUBLIC RAI_CreateFromRecItem(LPRA_ITEM * ppitem, LPCTSTR pszBrfPath, PRECITEM pri);
HRESULT PUBLIC RAI_Free(LPRA_ITEM pitem);

#endif // __RECACT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\state.h ===
//
// state.h: Declares data, defines and struct types for user state code
//          module.
//
//

#ifndef __STATE_H__
#define __STATE_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagUSERSTATE
    {
    }
    CState,  * LPState;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

#ifdef DEBUG

BOOL PUBLIC ProcessIniFile(void);
BOOL PUBLIC CommitIniFile(void);

#else

#define ProcessIniFile()
#define CommitIniFile()

#endif

#endif // __STATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\status.h ===
//
// status.h: Declares data, defines and struct types for twin property
//                                module.
//
//

#ifndef __STATUS_H__
#define __STATUS_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

/////////////////////////////////////////////////////  MACROS

/////////////////////////////////////////////////////  TYPEDEFS

typedef struct tagXSTAT
    {
    LPBRIEFCASESTG      pbrfstg;        // IBriefcaseStg instance

    CBS  * pcbs;
    int atomPath;

    } XSTATSTRUCT,  * LPXSTATSTRUCT;


/////////////////////////////////////////////////////  EXPORTED DATA

/////////////////////////////////////////////////////  PUBLIC PROTOTYPES

BOOL _export CALLBACK Stat_WrapperProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);


#endif // __STATUS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\strings.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: string.c
//
//  This files contains common string routines
//
// History:
//  10-09-93 ScottH     Created
//
//---------------------------------------------------------------------------

/////////////////////////////////////////////////////  INCLUDES

#include "brfprv.h"         // common headers
#include "strings.h"


#ifdef NOTUSED      
#pragma data_seg(DATASEG_PERINSTANCE)

static LPTSTR s_pszNextToken = NULL;        

#pragma data_seg()
#endif // NOTUSED


// Some of these are replacements for the C runtime routines.
//  This is so we don't have to link to the CRT libs.
//

// WARNING: all of these APIs do not setup DS, so you can not access
// any data in the default data seg of this DLL.
//
// do not create any global variables... talk to chrisg if you don't
// understand this


/*----------------------------------------------------------
Purpose: Case sensitive character comparison for DBCS

Returns: FALSE if they match, TRUE if no match
Cond:    --
*/
BOOL ChrCmp(
    WORD w1, 
    WORD wMatch)
    {
    /* Most of the time this won't match, so test it first for speed.
    */
    if (LOBYTE(w1) == LOBYTE(wMatch))
        {
        if (IsDBCSLeadByte(LOBYTE(w1)))
            {
            return(w1 != wMatch);
            }
        return FALSE;
        }
    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Case insensitive character comparison for DBCS

Returns: FALSE if match, TRUE if not
Cond:    --
*/
BOOL ChrCmpI(
    WORD w1, 
    WORD wMatch)
    {
    TCHAR sz1[3], sz2[3];

    if (IsDBCSLeadByte(sz1[0] = LOBYTE(w1)))
        {
        sz1[1] = HIBYTE(w1);
        sz1[2] = TEXT('\0');
        }
    else
        sz1[1] = TEXT('\0');

    *(WORD  *)sz2 = wMatch;
    sz2[2] = TEXT('\0');
    return lstrcmpi(sz1, sz2);
    }


#ifdef NOTUSED     
/*----------------------------------------------------------
Purpose: strtok

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
LPTSTR PUBLIC StrTok(
    LPTSTR psz,
    LPCTSTR rgchTokens)
    {
    TUCHAR map[32];
    LPTSTR pszToken;
    
    ZeroInit(map, map);

    do 
        {
        map[*rgchTokens >> 3] |= (1 << (*rgchTokens & 7));
        } while (*rgchTokens++);

    if (!psz)
        {
        ENTEREXCLUSIVE()
            {
            psz = s_pszNextToken;
            }
        LEAVEEXCLUSIVE()
        }

    while (map[*psz >> 3] & (1 << (*psz & 7)) && *psz)
        psz++;
    pszToken = psz;
    for (;; psz++)
        {
        if (map[*psz >> 3] & (1 << (*psz & 7)))
            {
            if (!*psz && psz == pszToken)
                return(NULL);
            if (*psz)
                *psz++ = TEXT('\0');

            ENTEREXCLUSIVE()
                {
                g_pszNextToken = psz;
                }
            LEAVEEXCLUSIVE()
            return pszToken;
            }
        }
    }
#endif


#if 0
/*----------------------------------------------------------
Purpose: Find first occurrence of character in string

Returns: Pointer to the first occurrence of ch in 
Cond:    --
*/
LPTSTR PUBLIC StrChr(
    LPCTSTR psz, 
    WORD wMatch)
    {
    for ( ; *psz; psz = CharNext(psz))
        {
        if (!ChrCmp(*(WORD  *)psz, wMatch))
            return (LPTSTR)psz;
        }
    return NULL;
    }
#endif


/*----------------------------------------------------------
Purpose: strnicmp

         Swiped from the C 7.0 runtime sources.

Returns: 
Cond:    
*/
int PUBLIC lstrnicmp(
    LPCTSTR psz1,
    LPCTSTR psz2,
    UINT count)
    {
    int ch1;
    int ch2;
    int result = 0;
    
    if (count) 
        {
        do      
            {
            ch1 = (int)CharLower((LPTSTR)MAKELONG(*psz1, 0));
            ch2 = (int)CharLower((LPTSTR)MAKELONG(*psz2, 0));
            psz1 = CharNext(psz1);
            psz2 = CharNext(psz2);
            } while (--count && ch1 && ch2 && !ChrCmp((WORD)ch1, (WORD)ch2));
        result = ch1 - ch2;
        }
    return(result);
    }


/*----------------------------------------------------------
Purpose: Get a string from the resource string table.  Returned
         ptr is a ptr to static memory.  The next call to this
         function will wipe out the prior contents.
Returns: Ptr to string
Cond:    --
*/
LPTSTR PUBLIC SzFromIDS(
    UINT ids,               // resource ID
    LPTSTR pszBuf,
    UINT cchBuf)           
    {
    ASSERT(pszBuf);

    *pszBuf = NULL_CHAR;
    LoadString(g_hinst, ids, pszBuf, cchBuf);
    return pszBuf;
    }


/*----------------------------------------------------------
Purpose: Formats a string by allocating a buffer and loading
         the given resource strings to compose the string.

Returns: the count of characters 

Cond:    Caller should free the allocated buffer using GFree.
*/
BOOL PUBLIC FmtString(
    LPCTSTR  * ppszBuf,
    UINT idsFmt,
    LPUINT rgids,
    UINT cids)
    {
    UINT cch = 0;
    UINT cchMax;
    LPTSTR pszBuf;

    ASSERT(ppszBuf);
    ASSERT(rgids);
    ASSERT(cids > 0);

    cchMax = (1+cids) * MAXPATHLEN;
    pszBuf = GAlloc(CbFromCch(cchMax));
    if (pszBuf)
        {
        // The first cids DWORDS are the addresses of the offset strings
        // in the buffer (passed to wvsprintf)
        LPTSTR pszMsgs = GAlloc((cids * sizeof(DWORD)) + (cids * CbFromCch(MAXPATHLEN)));
        if (pszMsgs)
            {
            TCHAR szFmt[MAXPATHLEN];
            LPDWORD rgpsz = (LPDWORD)pszMsgs;
            LPTSTR pszT = pszMsgs + (cids * sizeof(DWORD));
            UINT i;

            // Load the series of strings
            for (i = 0; i < cids; i++, pszT += MAXPATHLEN)
                {
                rgpsz[i] = (DWORD)pszT;
                SzFromIDS(rgids[i], pszT, MAXPATHLEN);
                }

            // Compose the string
            SzFromIDS(idsFmt, szFmt, ARRAYSIZE(szFmt));
            cch = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
                          szFmt, 0, 0, pszBuf, cchMax, (va_list *)&rgpsz);
            ASSERT(cch <= cchMax);

            GFree(pszMsgs);
            }
        // pszBuf is freed by caller
        }

    *ppszBuf = pszBuf;
    return cch;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\status.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: status.c
//
//  This file contains the dialog code for the Status property sheet
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers
#include <brfcasep.h>

#include "res.h"
#include "recact.h"
#ifdef WINNT
#include <help.h>
#else
#include <help.h>   // help IDs
#endif


typedef struct tagSTAT
    {
    HWND        hwnd;              // dialog handle
    PPAGEDATA   ppagedata;
    FileInfo *  pfi;
    TCHAR        szFolder[MAX_PATH];
    BOOL        bInit;
    } STAT, * PSTAT;

#define Stat_Pcbs(this)         ((this)->ppagedata->pcbs)
#define Stat_AtomBrf(this)      ((this)->ppagedata->pcbs->atomBrf)
#define Stat_GetPtr(hwnd)       (PSTAT)GetWindowLong(hwnd, DWL_USER)
#define Stat_SetPtr(hwnd, lp)   (PSTAT)SetWindowLong(hwnd, DWL_USER, (LONG)(lp))

#define LNKM_ACTIVATEOTHER      (WM_USER + 0)

/*----------------------------------------------------------
Purpose: Disable all the controls in the property page
Returns: --
Cond:    --
*/
void PRIVATE Stat_DisableAll(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;
    HWND hwndFocus = GetFocus();

    RecAct_DeleteAllItems(GetDlgItem(hwnd, IDC_UPDATEACTIONS));
    RecAct_Enable(GetDlgItem(hwnd, IDC_UPDATEACTIONS), FALSE);
        
    Button_Enable(GetDlgItem(hwnd, IDC_PBTSRECON), FALSE);
    Button_Enable(GetDlgItem(hwnd, IDC_PBTSFIND), FALSE);
    Button_Enable(GetDlgItem(hwnd, IDC_PBTSSPLIT), FALSE);

    if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
        {
        SetFocus(GetDlgItem(GetParent(hwnd), IDOK));
        SendMessage(GetParent(hwnd), DM_SETDEFID, IDOK, 0);
        }
    }


/*----------------------------------------------------------
Purpose: Set the directions static text
Returns: --
Cond:    --
*/
void PRIVATE Stat_SetDirections(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(this->hwnd, IDC_UPDATEACTIONS);
    RA_ITEM item;
    TCHAR sz[MAXBUFLEN];

    *sz = 0;

    // This function shouldn't be called if this is an orphan
    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    item.mask = RAIF_INSIDE | RAIF_OUTSIDE | RAIF_ACTION;
    item.iItem = 0;

    ASSERT(RecAct_GetItemCount(hwndRA) == 1);

    if (RecAct_GetItem(hwndRA, &item))
        {
        UINT ids;

        ASSERT(IsFlagSet(item.mask, RAIF_INSIDE | RAIF_OUTSIDE));

        switch (item.uAction)
            {
        case RAIA_TOIN:
        case RAIA_TOOUT:
        case RAIA_DELETEOUT:
        case RAIA_DELETEIN:
        case RAIA_MERGE:
        case RAIA_SOMETHING:
            // Instructions to update
            if (this->ppagedata->bFolder)
                ids = IDS_STATPROP_PressButton;
            else
                ids = IDS_STATPROP_Update;
            break;

        case RAIA_CONFLICT:
            ids = IDS_STATPROP_Conflict;
            break;

        default:
            if (SI_UNAVAILABLE == item.siOutside.uState)
                {
                // The original file is unavailable.  We don't know if 
                // everything is up-to-date.
                ids = IDS_STATPROP_Unavailable;
                }
            else
                {
                // They are up-to-date
                ids = IDS_STATPROP_Uptodate;
                }
            break;
            }

        SzFromIDS(ids, sz, ARRAYSIZE(sz));
        }
    Static_SetText(GetDlgItem(hwnd, IDC_STTSDIRECT), sz);
    }


/*----------------------------------------------------------
Purpose: Sets the reconciliation action control

Returns: standard result
         S_OK if the item is still a twin
         S_FALSE if the item is an orphan

Cond:    --
*/
HRESULT PRIVATE Stat_SetRecAct(
    PSTAT this,
    PRECLIST prl,
    PFOLDERTWINLIST pftl)
    {
    HRESULT hres;
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);
    RA_ITEM * pitem;

    // This function shouldn't be called if this is an orphan
    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    hres = RAI_Create(&pitem, Atom_GetName(Stat_AtomBrf(this)), pszPath, 
        prl, pftl);

    if (SUCCEEDED(hres))
        {
        if (RAIA_ORPHAN == pitem->uAction)
            {
            // This is a pending orphan
            PageData_Orphanize(this->ppagedata);
            hres = S_FALSE;
            }
        else if ( !this->ppagedata->bFolder )
            {
            pitem->mask |= RAIF_LPARAM;
            pitem->lParam = (DWORD)(LPVOID)prl->priFirst;
            }

        if (S_OK == hres)
            {
            BOOL bEnable;
            HWND hwndFocus = GetFocus();

            // Add the item to the recact control.
            RecAct_InsertItem(hwndRA, pitem);

            // Determine the state of the buttons
            bEnable = !(pitem->uAction == RAIA_SKIP ||
                        pitem->uAction == RAIA_CONFLICT || 
                        pitem->uAction == RAIA_NOTHING);
            Button_Enable(GetDlgItem(hwnd, IDC_PBTSRECON), bEnable);

            bEnable = (SI_UNAVAILABLE != pitem->siOutside.uState);
            Button_Enable(GetDlgItem(hwnd, IDC_PBTSFIND), bEnable);

            if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
                {
                SetFocus(GetDlgItem(hwnd, IDC_PBTSSPLIT));
                SendMessage(hwnd, DM_SETDEFID, IDC_PBTSSPLIT, 0);
                }
            }
        RAI_Free(pitem);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Sets the controls in the status property page.

Returns: --
Cond:    --
*/
void PRIVATE Stat_SetControls(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;
    HRESULT hres;
    PRECLIST prl;
    PFOLDERTWINLIST pftl;

    // Is this a twin?
    hres = PageData_Query(this->ppagedata, hwnd, &prl, &pftl);
    if (S_OK == hres)
        {
        // Yes
        RecAct_DeleteAllItems(GetDlgItem(hwnd, IDC_UPDATEACTIONS));

        // Is it still a twin?
        hres = Stat_SetRecAct(this, prl, pftl);
        if (S_OK == hres)
            {
            // Yes
            Stat_SetDirections(this);
            }
        else if (S_FALSE == hres)
            {
            // No
            goto WipeOut;
            }
        }
    else if (S_FALSE == hres)
        {
        // No; disable the controls
        TCHAR sz[MAXBUFLEN];
WipeOut:

        Stat_DisableAll(this);

        // Is this a subfolder twin?
        if (IsSubfolderTwin(PageData_GetHbrf(this->ppagedata), 
            Atom_GetName(this->ppagedata->atomPath)))
            {
            // Yes; use subfolder twin message.
            SzFromIDS(IDS_STATPROP_SubfolderTwin, sz, ARRAYSIZE(sz));
            }
        else
            {
            // No; use orphan message.
            if (this->ppagedata->bFolder)
                SzFromIDS(IDS_STATPROP_OrphanFolder, sz, ARRAYSIZE(sz));
            else
                SzFromIDS(IDS_STATPROP_OrphanFile, sz, ARRAYSIZE(sz));
            }
        Static_SetText(GetDlgItem(hwnd, IDC_STTSDIRECT), sz);
        }
    }


/*----------------------------------------------------------
Purpose: Gets the icon of the file

Returns: HICON
Cond:    --
*/
HICON PRIVATE GetIconHelper(
    LPCTSTR pszPath)
    {
    SHFILEINFO sfi;

    if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_ICON))
        {
        return sfi.hIcon;
        }
    return NULL;
    }


/*----------------------------------------------------------
Purpose: Stat WM_INITDIALOG Handler

Returns: FALSE when we assign the control focus
Cond:    --
*/
BOOL PRIVATE Stat_OnInitDialog(
    PSTAT this,
    HWND hwndFocus,
    LPARAM lParam)              // expected to be LPPROPSHEETPAGE
    {
    HWND hwnd = this->hwnd;
    LPCTSTR pszPath;
    
    this->ppagedata = (PPAGEDATA)((LPPROPSHEETPAGE)lParam)->lParam;

    // Set up the display of the dialog
    pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (SUCCEEDED(FICreate(pszPath, &this->pfi, FIF_ICON)))
        {
        Static_SetIcon(GetDlgItem(hwnd, IDC_ICTSMAIN), this->pfi->hicon);
        Static_SetText(GetDlgItem(hwnd, IDC_NAME), FIGetDisplayName(this->pfi));
        }

    // Save the folder of the twin away.
    lstrcpy(this->szFolder, pszPath);
    if (!this->ppagedata->bFolder)
        PathRemoveFileSpec(this->szFolder);

    this->bInit = TRUE;

    return FALSE;   // we set the initial focus
    }


/*----------------------------------------------------------
Purpose: PSN_SETACTIVE handler
Returns: --
Cond:    --
*/
void PRIVATE Stat_OnSetActive(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;

    // Cause the page to be painted right away 
    HideCaret(NULL);
    SetWindowRedraw(hwnd, TRUE);
    InvalidateRect(hwnd, NULL, TRUE);
    UpdateWindow(hwnd);

    if (this->bInit)
        {
        PageData_Init(this->ppagedata, GetParent(this->hwnd));
        this->bInit = FALSE;
        }

    ShowCaret(NULL);

    Stat_SetControls(this);
    }


/*----------------------------------------------------------
Purpose: Reconcile the twins in this property sheet.  
          For folder twins, we invoke the Update dialog.  
          For object twins, we reconcile from here.

Returns: --
Cond:    --
*/
void PRIVATE Stat_OnUpdate(
    PSTAT this,
    PRECLIST prl)
    {
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    // Is this a folder?
    if (this->ppagedata->bFolder)
        {
        // Yes; let the Update dialog do the work
        Upd_DoModal(hwnd, Stat_Pcbs(this), pszPath, 1, UF_SELECTION);
        }
    else
        {
        // No; we do the work.  
        HWND hwndProgress;

        hwndProgress = UpdBar_Show(hwnd, UB_UPDATING, 0,NULL,GUID_NULL);
            
        Sync_ReconcileRecList(prl, Atom_GetName(Stat_AtomBrf(this)), 
            hwndProgress, RF_DEFAULT);

        UpdBar_Kill(hwndProgress);
        }

    this->ppagedata->bRecalc = TRUE;

    PropSheet_CancelToClose(GetParent(hwnd));
    }


/*----------------------------------------------------------
Purpose: Separate the twins.  
Returns: --
Cond:    --
*/
void PRIVATE Stat_OnSplit(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    LPCTSTR pszPath = Atom_GetName(this->ppagedata->atomPath);

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    // Was the twin successfully deleted?
    if (S_OK == Sync_Split(PageData_GetHbrf(this->ppagedata), pszPath, 1, hwnd, 0))
        {
        // Yes; remove the cache references
        CRL_Nuke(this->ppagedata->atomPath);
        Stat_DisableAll(this);

        PropSheet_CancelToClose(GetParent(hwnd));

        // Notify the shell of the change
        PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
        }
    }


/*----------------------------------------------------------
Purpose: Attempt to bind to an object to see if it exists.

Returns: TRUE if the object exists
Cond:    --
*/
BOOL PRIVATE VerifyExists(
    LPCITEMIDLIST pidlParent,
    LPCITEMIDLIST pidl)
    {
    BOOL bRet = FALSE;
    LPSHELLFOLDER psfDesktop;

    ASSERT(pidlParent);
    ASSERT(pidl);

    psfDesktop = GetDesktopShellFolder();
    if (psfDesktop)
        {
        LPSHELLFOLDER psf;
        HRESULT hres;

        hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlParent, NULL, &IID_IShellFolder, &psf);
        if (SUCCEEDED(hres))
            {
            ULONG rgfAttr = SFGAO_VALIDATE;
            bRet = SUCCEEDED(psf->lpVtbl->GetAttributesOf(psf, 1, &pidl, &rgfAttr));
            psf->lpVtbl->Release(psf);
            }
        }
    return bRet;
    }


/*----------------------------------------------------------
Purpose: Open a file (taken from ShellExecFile)

Returns: value of ShellExecuteEx

Cond:    --
*/
BOOL PUBLIC ExecFile(
    HWND hwnd, 
    LPCTSTR pszVerb, 
    LPCTSTR pszFile,        // Fully qualified and fully resolved path to the file
    LPCTSTR pszParams,
    LPCTSTR pszDir,         // If NULL then working dir is derived from lpszFile (except for UNC's)
    LPCITEMIDLIST pidl,
    int nShow)
    {
    SHELLEXECUTEINFO execinfo;

    execinfo.cbSize          = sizeof(execinfo);
    execinfo.hwnd            = hwnd;
    execinfo.lpVerb          = pszVerb;
    execinfo.lpFile          = pszFile;
    execinfo.lpParameters    = pszParams;
    execinfo.lpDirectory     = pszDir;
    execinfo.nShow           = nShow;
    execinfo.fMask           = 0;
    execinfo.lpIDList        = (LPITEMIDLIST)pidl;

    if (pidl)
        {
        execinfo.fMask |= SEE_MASK_IDLIST;
        }

    return ShellExecuteEx(&execinfo);
    }


/*----------------------------------------------------------
Purpose: Selects an item in the given cabinet window.  Optionally
         sets it to be renamed.

         This function does not verify if the window is really
         a cabinet window.

Returns: --
Cond:    --
*/
void PUBLIC SelectItemInCabinet(
    HWND hwndCabinet,
    LPCITEMIDLIST pidl,
    BOOL bEdit)
    {
    if (IsWindow(hwndCabinet)) 
        {
        if (pidl)
            {
            LPITEMIDLIST pidlItem;

            // we need to global clone this because hwndCabinet might be
            // in a different process...  could happen with common dialog
            pidlItem = ILGlobalClone(pidl);
            if (pidlItem) 
                {
                UINT uFlagsEx;

                if (bEdit)
                    uFlagsEx = SVSI_EDIT;
                else
                    uFlagsEx = 0;

				#define CWM_SELECTITEM          (WM_USER + 5)    // ROGERG, HACK SHOULD BE IN SHLOBJ.H

                SendMessage(hwndCabinet, CWM_SELECTITEM, 
                    uFlagsEx | SVSI_SELECT | SVSI_ENSUREVISIBLE | 
                    SVSI_FOCUSED | SVSI_DESELECTOTHERS, 
                    (LPARAM)pidlItem);
                ILGlobalFree(pidlItem);
                }
            }
        }
    }


/*----------------------------------------------------------
Purpose: Open a cabinet window and set the focus on the object.

Returns: --
Cond:    --
*/
void PUBLIC OpenCabinet(
    HWND hwnd,
    LPCITEMIDLIST pidlFolder,
    LPCITEMIDLIST pidl,
    BOOL bEdit)             // TRUE: set the focus to edit the label
    {
    if (!VerifyExists(pidlFolder, pidl))
        {
        MsgBox(hwnd, MAKEINTRESOURCE(IDS_MSG_CantFindOriginal), MAKEINTRESOURCE(IDS_CAP_STATUS),
               NULL,GUID_NULL,NULL, MB_INFO);
        }
    else
        {
        HWND hwndCabinet;

        SHWaitForFileToOpen(pidlFolder, WFFO_ADD, 0L);
        if (ExecFile(hwnd, c_szOpen, NULL, NULL, NULL, pidlFolder, SW_NORMAL))
            {
            // This will wait for the window to open or time out
            // We need to disable the dialog box while we are waiting.
            DECLAREHOURGLASS;

            SetHourglass();
            EnableWindow(hwnd, FALSE);
            SHWaitForFileToOpen(pidlFolder, WFFO_REMOVE | WFFO_WAIT, WFFO_WAITTIME);
            EnableWindow(hwnd, TRUE);
            ResetHourglass();

            hwndCabinet = FindWindow(c_szCabinetClass, NULL);
            }
        else
            {
            // If it failed clear out our wait
            hwndCabinet = NULL;
            SHWaitForFileToOpen(pidlFolder, WFFO_REMOVE, 0L);
            }

        if (hwndCabinet)
            {
            SelectItemInCabinet(hwndCabinet, pidl, bEdit);

            // we need to post to the other because we can't activate another
            // thread from within a button's callback
            PostMessage(hwnd, LNKM_ACTIVATEOTHER, 0, (LPARAM)hwndCabinet);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Opens the cabinet with the item pointed to by the twin.
         (copied and modified from link.c in shelldll)
Returns: --
Cond:    --
*/
void PRIVATE Stat_OnFind(
    PSTAT this)
    {
    HWND hwnd = this->hwnd;
    HWND hwndRA = GetDlgItem(hwnd, IDC_UPDATEACTIONS);
    RA_ITEM item;

    if (0 == RecAct_GetItemCount(hwndRA))
        return;

    ASSERT(S_OK == PageData_Query(this->ppagedata, hwnd, NULL, NULL));

    item.mask = RAIF_OUTSIDE | RAIF_NAME;
    item.iItem = 0;

    if (RecAct_GetItem(hwndRA, &item))
        {
        TCHAR szCanon[MAX_PATH];
        LPITEMIDLIST pidlFolder;
        LPITEMIDLIST pidl;

        // Use UNC name to find it on the net
        BrfPathCanonicalize(item.siOutside.pszDir, szCanon);
        pidlFolder = ILCreateFromPath(szCanon);
        if (pidlFolder)
            {
            pidl = ILCreateFromPath(item.pszName);
            if (pidl)
                {
                OpenCabinet(hwnd, pidlFolder, ILFindLastID(pidl), FALSE);
                ILFree(pidl);
                }
            ILFree(pidlFolder);
            }
        }
    }


/*----------------------------------------------------------
Purpose: Stat WM_COMMAND Handler
Returns: --
Cond:    --
*/
void PRIVATE Stat_OnCommand(
    PSTAT this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    PRECLIST prl;
    HRESULT hres;

    switch (id)
        {
    case IDC_PBTSRECON:
    case IDC_PBTSFIND:
    case IDC_PBTSSPLIT: 
        RETRY_BEGIN(FALSE)
            {
            hres = PageData_Query(this->ppagedata, this->hwnd, &prl, NULL);
            if (FAILED(hres))
                {
                // Error

                // Unavailable disk?
                if (E_TR_UNAVAILABLE_VOLUME == hres)
                    {
                    // Yes; ask user to retry/cancel
                    int id = MsgBox(this->hwnd, MAKEINTRESOURCE(IDS_ERR_UNAVAIL_VOL),
                        MAKEINTRESOURCE(IDS_CAP_STATUS), NULL,GUID_NULL,NULL, MB_RETRYCANCEL | MB_ICONWARNING);

                    if (IDRETRY == id)
                        RETRY_SET();    // Try again
                    }
                }
            }
        RETRY_END()
        
        // Is this a twin?
        if (S_OK == hres)
            {
            // Yes; do the operation
            switch (id)
                {
            case IDC_PBTSRECON:
                Stat_OnUpdate(this, prl);
                break;
            
            case IDC_PBTSFIND:
                Stat_OnFind(this);
                break;
            
            case IDC_PBTSSPLIT:
                Stat_OnSplit(this);
                break;
                }
            Stat_SetControls(this);
            }
        else if (S_FALSE == hres)
            {
            Stat_SetControls(this);
            }

        break;
        }
    }


/*----------------------------------------------------------
Purpose: Handle RN_ITEMCHANGED
Returns: --
Cond:    --
*/
void PRIVATE Stat_HandleItemChange(
    PSTAT this,
    NM_RECACT  * lpnm)
    {
    PRECITEM pri;

    ASSERT((lpnm->mask & RAIF_LPARAM) != 0);

    pri = (PRECITEM)lpnm->lParam;

    // The action has changed, update the recnode accordingly
    //
    if (lpnm->mask & RAIF_ACTION)
        {
        BOOL bEnable;
        HWND hwndFocus = GetFocus();

        Sync_ChangeRecItemAction(pri, Atom_GetName(Stat_AtomBrf(this)), 
            this->szFolder, lpnm->uAction);

        bEnable = (RAIA_SKIP != lpnm->uAction && RAIA_CONFLICT != lpnm->uAction);
        Button_Enable(GetDlgItem(this->hwnd, IDC_PBTSRECON), bEnable);

        if ( !hwndFocus || !IsWindowEnabled(hwndFocus) )
            {
            SetFocus(GetDlgItem(this->hwnd, IDC_PBTSSPLIT));
            SendMessage(this->hwnd, DM_SETDEFID, IDC_PBTSSPLIT, 0);
            }
        }
    }    


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE Stat_OnNotify(
    PSTAT this,
    int idFrom,
    NMHDR  * lpnmhdr)
    {
    LRESULT lRet = PSNRET_NOERROR;
    
    switch (lpnmhdr->code)
        {
    case RN_ITEMCHANGED:
        Stat_HandleItemChange(this, (NM_RECACT  *)lpnmhdr);
        break;

    case PSN_SETACTIVE:
        Stat_OnSetActive(this);
        break;

    case PSN_KILLACTIVE:
        // N.b. This message is not sent if user clicks Cancel!
        // N.b. This message is sent prior to PSN_APPLY
        //
        break;

    case PSN_APPLY:
        break;

    default:
        break;
        }

    return lRet;
    }


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE Stat_OnDestroy(
    PSTAT this)
    {
    FIFree(this->pfi);
    }


/////////////////////////////////////////////////////  EXPORTED FUNCTIONS

static BOOL s_bStatRecurse = FALSE;

LRESULT INLINE Stat_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
    {
    ENTEREXCLUSIVE()
        {
        s_bStatRecurse = TRUE;
        }
    LEAVEEXCLUSIVE()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
    }


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
*/
LRESULT Stat_DlgProc(
    PSTAT this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
#pragma data_seg(DATASEG_READONLY)
    const static DWORD rgHelpIDs_File[] = {
        IDC_ICTSMAIN,       IDH_BFC_PROP_FILEICON,
        IDC_NAME,           IDH_BFC_PROP_FILEICON,
        IDC_UPDATEACTIONS,  IDH_BFC_UPDATE_SCREEN,      // different
        IDC_PBTSRECON,      IDH_BFC_UPDATE_BUTTON,
        IDC_PBTSSPLIT,      IDH_BFC_PROP_SPLIT_BUTTON,
        IDC_PBTSFIND,       IDH_BFC_PROP_FINDORIG_BUTTON,
        0, 0 };

    const static DWORD rgHelpIDs_Folder[] = {
        IDC_ICTSMAIN,       IDH_BFC_PROP_FILEICON,
        IDC_NAME,           IDH_BFC_PROP_FILEICON,
        IDC_UPDATEACTIONS,  IDH_BFC_UPDATE_SCREEN,      // different
        IDC_PBTSRECON,      IDH_BFC_UPDATE_BUTTON,
        IDC_PBTSSPLIT,      IDH_BFC_PROP_SPLIT_BUTTON,
        IDC_PBTSFIND,       IDH_BFC_PROP_FINDORIG_BUTTON,
        0, 0 };
#pragma data_seg()
    DWORD dw;

    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, Stat_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, Stat_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, Stat_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, Stat_OnDestroy);

    case WM_HELP:
        dw = this->ppagedata->bFolder ? (DWORD)(LPVOID)rgHelpIDs_Folder : 
                                        (DWORD)(LPVOID)rgHelpIDs_File;

        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, dw);
        return 0;

    case WM_CONTEXTMENU:
        dw = this->ppagedata->bFolder ? (DWORD)(LPVOID)rgHelpIDs_Folder : 
                                        (DWORD)(LPVOID)rgHelpIDs_File;

        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, dw);
        return 0;

    case LNKM_ACTIVATEOTHER:
      //   SwitchToThisWindow(GetLastActivePopup((HWND)lParam), TRUE); // ROGERG
        SetForegroundWindow((HWND)lParam);
        break;
        
    default:
        return Stat_DefProc(this->hwnd, message, wParam, lParam);
        }
    }


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
*/
BOOL CALLBACK Stat_WrapperProc(
    HWND hDlg,          // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    PSTAT this;

    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE()
        {
        if (s_bStatRecurse)
            {
            s_bStatRecurse = FALSE;
            LEAVEEXCLUSIVE()
            return FALSE;
            }
        }
    LEAVEEXCLUSIVE()

    this = Stat_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = GAlloc(sizeof(*this));
            if (!this)
                {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_STATUS), MAKEINTRESOURCE(IDS_CAP_STATUS),
                       NULL,GUID_NULL,NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)Stat_DefProc(hDlg, message, wParam, lParam);
                }
            this->hwnd = hDlg;
            Stat_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)Stat_DefProc(hDlg, message, wParam, lParam);
            }
        }

    if (message == WM_DESTROY)
        {
        Stat_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Stat_SetPtr(hDlg, NULL);
        return 0;
        }

    return SetDlgMsgResult(hDlg, message, Stat_DlgProc(this, message, wParam, lParam));
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\strings.h ===
//
// string.h: Declares data, defines and struct types for string code
//
//

#ifndef __STRING_H__
#define __STRING_H__


#define Bltbyte(rgbSrc,rgbDest,cb)  _fmemmove(rgbDest, rgbSrc, cb)

// Model independent, language-independent (DBCS aware) macros
//  taken from rcsys.h in Pen project and modified.
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsCaseSzEqual(sz1, sz2)     (BOOL)(lstrcmp(sz1, sz2) == 0)
#define SzFromInt(sz, n)            (wsprintf((LPTSTR)sz, (LPTSTR)TEXT("%d"), n), (LPTSTR)sz)

int     PUBLIC lstrnicmp(LPCTSTR first, LPCTSTR last, UINT count);

LPTSTR   PUBLIC SzFromIDS (UINT ids, LPTSTR pszBuf, UINT cchBuf);

BOOL    PUBLIC FmtString(LPCTSTR  * ppszBuf, UINT idsFmt, LPUINT rgids, UINT cids);

#endif // __STRING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\update.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: update.c
//
// This files contains code for the Update UI and dialog.
//
// History:
//  08-17-93 ScottH     Created.
//
//---------------------------------------------------------------------------



#include "brfprv.h"     // common headers

#include "res.h"
#include "recact.h"
#ifdef WINNT
#include <help.h>
#else
#include <help.h>  // help IDs
#endif

#include "update.h"

//---------------------------------------------------------------------------
// Some comments
//---------------------------------------------------------------------------

// There are several special cases and conditions which must be 
// handled.  Lets break them down now.  The case numbers on on the far
// right, and are referenced in comments thru out this file.
//
// There are two user actions: Update All and Update Selection.
//
// Update All:
// 
//               Case                                     What to do
//         -----------------                            --------------
//  A1.  * No files in the briefcase                --->  MB (messagebox)
//  A2.  * All files are orphans                    --->  MB
//       * Some files are twins and...
//          * they are all available and...
//  A3.        * they are all up-to-date            --->  MB
//  A4.        * some of them need updating         --->  Update dialog
//          * some are unavailable and...
//  A5.        * the available ones are up-to-date  --->  MB then Update 
//  A6.        * some need updating                 --->  MB then Update 
// 
//
// Update Selection:
//
//               Case                                     What to do
//         -----------------                            --------------
//       * Single selection and...
//  S1.     * is an orphan                          --->  MB
//          * is available and...
//  S2.        * up-to-date                         --->  MB
//  S3.        * needs updating                     --->  Update 
//  S4.     * is unavailable                        --->  MB then Update 
//       * Multi selection and...
//  S5.     * all are orphans                       --->  MB
//          * some (non-orphans) are unavailable and...
//             * some need updating and...
//  S6.           * none are orphans                --->  MB then Update 
//  S7.           * some are orphans                --->  MB then Update then MB
//             * the available ones are up-to-date and...
//  S8.           * none are orphans                --->  MB then Update 
//  S9.           * some are orphans                --->  MB then Update then MB
//          * all (non-orphans) are available and...
//             * some need updating and...
// S10.           * none are orphans                --->  Update 
// S11.           * some are orphans                --->  Update then MB
//             * all up-to-date and...
// S12.           * none are orphans                --->  MB
// S13.           * some are orphans                --->  MB



//---------------------------------------------------------------------------
// Dialog code
//---------------------------------------------------------------------------

/*----------------------------------------------------------
Purpose: Fill the reconciliation action listbox
Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE Upd_FillList(
    PUPD this)
    {
    HWND hwndCtl = GetDlgItem(this->hwnd, IDC_UPDATEACTIONS);
    HDPA hdpa = this->pxupd->hdpa;
    int cItems;
    int i;

    cItems = DPA_GetPtrCount(hdpa);
    for (i = 0; i < cItems; i++)
        {
        RA_ITEM * pitem = DPA_FastGetPtr(hdpa, i);
        RecAct_InsertItem(hwndCtl, pitem);
        RAI_Free(pitem);
        }

    return TRUE;
    }


/*----------------------------------------------------------
Purpose: Sets the Update and Cancel buttons according to the
         bDisableUpdate parameter.

Returns: --
Cond:    --
*/
void PRIVATE Upd_SetExitButtons(
    PUPD this,
    BOOL bDisableUpdate)
    {
    HWND hwndOK = GetDlgItem(this->hwnd, IDOK);

    // Disable the update button?
    if (bDisableUpdate)
        {
        // Yes
        if (GetFocus() == hwndOK)
            {
            SetFocus(GetDlgItem(this->hwnd, IDCANCEL));
            }
        Button_Enable(hwndOK, FALSE);
        }
    else
        {
        // No
        Button_Enable(hwndOK, TRUE);
        }
    }
    

/*----------------------------------------------------------
Purpose: WM_INITDIALOG Handler
Returns: 
Cond:    --
*/
BOOL PRIVATE Upd_OnInitDialog(
    PUPD this,
    HWND hwndFocus,
    LPARAM lParam)
    {
    HWND hwnd = this->hwnd;
    TCHAR szFmt[MAXBUFLEN];
    TCHAR sz[MAXMSGLEN];

    ASSERT(lParam != 0L);

    this->pxupd = (LPXUPDSTRUCT)lParam;

    if (Upd_FillList(this))
        {
        // Set the title caption
        wsprintf(sz, SzFromIDS(IDS_CAP_UpdateFmt, szFmt, ARRAYSIZE(szFmt)),
                 PathFindFileName(Upd_GetBrfPtr(this)));
        SetWindowText(hwnd, sz);

        // Do any files need updating?
        if (0 == this->pxupd->cDoSomething)
            {
            // No
            Upd_SetExitButtons(this, TRUE);
            }
        }
    else
        {
        // Failed
        EndDialog(hwnd, -1);
        }
    return(TRUE);
    }


/*----------------------------------------------------------
Purpose: Handle RN_ITEMCHANGED
Returns: --
Cond:    --
*/
void PRIVATE Upd_HandleItemChange(
    PUPD this,
    NM_RECACT  * lpnm)
    {
    PRECITEM lpri;

    ASSERT((lpnm->mask & RAIF_LPARAM) != 0);

    lpri = (PRECITEM)lpnm->lParam;

    // The action has changed, update the recnode accordingly
    if (lpnm->mask & RAIF_ACTION)
        {
        LPCTSTR pszDir = Upd_GetBrfPtr(this);
        Sync_ChangeRecItemAction(lpri, pszDir, pszDir, lpnm->uAction);

        switch (lpnm->uActionOld)
            {
        case RAIA_TOOUT:
        case RAIA_TOIN:
        case RAIA_MERGE:
            // Is this a change from "do something" to "skip"?
            if (RAIA_SKIP == lpnm->uAction)
                {
                // Yes
                ASSERT(0 < this->pxupd->cDoSomething);
                this->pxupd->cDoSomething--;
                }
            break;

        case RAIA_SKIP:
        case RAIA_CONFLICT:
            // Is this a change from "skip"/"conflict" to "do something"?
            if (RAIA_TOOUT == lpnm->uAction ||
                RAIA_TOIN == lpnm->uAction ||
                RAIA_MERGE == lpnm->uAction)
                {
                // Yes
                this->pxupd->cDoSomething++;
                }
            break;
            }

        Upd_SetExitButtons(this, 0 == this->pxupd->cDoSomething);
        }
    }


/*----------------------------------------------------------
Purpose: WM_NOTIFY handler
Returns: varies
Cond:    --
*/
LRESULT PRIVATE Upd_OnNotify(
    PUPD this,
    int idFrom,
    NMHDR  * lpnmhdr)
    {
    LRESULT lRet = 0;
    
    switch (lpnmhdr->code)
        {
    case RN_ITEMCHANGED:
        Upd_HandleItemChange(this, (NM_RECACT  *)lpnmhdr);
        break;
        
    default:
        break;
        }
    
    return lRet;
    }


/*----------------------------------------------------------
Purpose: Info WM_COMMAND Handler
Returns: --
Cond:    --
*/
VOID PRIVATE Upd_OnCommand(
    PUPD this,
    int id,
    HWND hwndCtl,
    UINT uNotifyCode)
    {
    HWND hwnd = this->hwnd;
    
    switch (id)
        {
    case IDOK:
    case IDCANCEL:
        EndDialog(hwnd, id);
        break;
        }
    }


/*----------------------------------------------------------
Purpose: WM_DESTROY handler
Returns: --
Cond:    --
*/
void PRIVATE Upd_OnDestroy(
    PUPD this)
    {
    }


static BOOL s_bUpdRecurse = FALSE;

LRESULT INLINE Upd_DefProc(
    HWND hDlg, 
    UINT msg,
    WPARAM wParam,
    LPARAM lParam) 
    {
    ENTEREXCLUSIVE()
        {
        s_bUpdRecurse = TRUE;
        }
    LEAVEEXCLUSIVE()

    return DefDlgProc(hDlg, msg, wParam, lParam); 
    }


/*----------------------------------------------------------
Purpose: Real Create Folder Twin dialog proc
Returns: varies
Cond:    --
*/
LRESULT Upd_DlgProc(
    PUPD this,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
#pragma data_seg(DATASEG_READONLY)
    const static DWORD rgHelpIDs[] = {
        IDC_UPDATEACTIONS,  IDH_BFC_UPDATE_SCREEN,      // different
        IDOK,               IDH_BFC_UPDATE_BUTTON,
        0, 0 };
#pragma data_seg()

    switch (message)
        {
        HANDLE_MSG(this, WM_INITDIALOG, Upd_OnInitDialog);
        HANDLE_MSG(this, WM_COMMAND, Upd_OnCommand);
        HANDLE_MSG(this, WM_NOTIFY, Upd_OnNotify);
        HANDLE_MSG(this, WM_DESTROY, Upd_OnDestroy);

    case WM_HELP:
        WinHelp(((LPHELPINFO)lParam)->hItemHandle, c_szWinHelpFile, HELP_WM_HELP, (DWORD)(LPVOID)rgHelpIDs);
        return 0;

    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, c_szWinHelpFile, HELP_CONTEXTMENU, (DWORD)(LPVOID)rgHelpIDs);
        return 0;

    default:
        return Upd_DefProc(this->hwnd, message, wParam, lParam);
        }
    }


/*----------------------------------------------------------
Purpose: Create Folder Twin Dialog Wrapper
Returns: varies
Cond:    --
*/
BOOL _export CALLBACK Upd_WrapperProc(
    HWND hDlg,      // std params
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
    {
    PUPD this;
    
    // Cool windowsx.h dialog technique.  For full explanation, see
    //  WINDOWSX.TXT.  This supports multiple-instancing of dialogs.
    //
    ENTEREXCLUSIVE()
        {
        if (s_bUpdRecurse)
            {
            s_bUpdRecurse = FALSE;
            LEAVEEXCLUSIVE()
            return FALSE;
            }
        }
    LEAVEEXCLUSIVE()

    this = Upd_GetPtr(hDlg);
    if (this == NULL)
        {
        if (message == WM_INITDIALOG)
            {
            this = GAlloc(sizeof(*this));
            if (!this)
                {
                MsgBox(hDlg, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                       NULL,GUID_NULL,NULL, MB_ERROR);
                EndDialog(hDlg, IDCANCEL);
                return (BOOL)Upd_DefProc(hDlg, message, wParam, lParam);
                }
            this->hwnd = hDlg;
            Upd_SetPtr(hDlg, this);
            }
        else
            {
            return (BOOL)Upd_DefProc(hDlg, message, wParam, lParam);
            }
        }
    
    if (message == WM_DESTROY)
        {
        Upd_DlgProc(this, message, wParam, lParam);
        GFree(this);
        Upd_SetPtr(hDlg, NULL);
        return 0;
        }
    
    return SetDlgMsgResult(hDlg, message, Upd_DlgProc(this, message, wParam, lParam));
    }


//---------------------------------------------------------------------------
// Update detection code
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Checks if the briefcase is empty.  This function skips the
         "desktop.ini" and "Briefcase Database" files.

Returns: TRUE if the briefcase is empty

Cond:    --
*/
BOOL PRIVATE IsBriefcaseEmpty(
    LPCTSTR pszPath)
    {
    BOOL bRet = FALSE;

    ASSERT(pszPath);

    if (pszPath)
        {
        // Enumerate thru folder
        TCHAR szSearch[MAXPATHLEN];
        WIN32_FIND_DATA fd;
        HANDLE hfile;
#pragma data_seg(DATASEG_PERINSTANCE)
        // This must be per instance, else it will cause a fixup in 
        // shared data segment.
        const static LPCTSTR s_rgszIgnore[] = { TEXT("."), TEXT(".."), g_szDBName, g_szDBNameShort, c_szDesktopIni };
#pragma data_seg()

        PathCombine(szSearch, pszPath, TEXT("*.*"));
        hfile = FindFirstFile(szSearch, &fd);
        if (INVALID_HANDLE_VALUE != hfile)
            {
            BOOL bCont = TRUE;

            bRet = TRUE;        // Default to empty folder
            while (bCont)
                {
                int bIgnore = FALSE;
                int i;

                // Is this file one of the files to ignore?
                for (i = 0; i < ARRAYSIZE(s_rgszIgnore); i++)
                    {
                    if (IsSzEqual(fd.cFileName, s_rgszIgnore[i]))
                        {
                        // Yes
                        bIgnore = TRUE;
                        break;
                        }
                    }

                // Is this a valid file/folder?
                if (FALSE == bIgnore)
                    {
                    // Yes; return the briefcase is not empty
                    bRet = FALSE;
                    bCont = FALSE;  // stop the enumeration
                    }
                else
                    {
                    bCont = FindNextFile(hfile, &fd);
                    }
                }

            FindClose(hfile);
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Create a DSA of RA_ITEMs

         Sets the cDoSomething, cUnavailable, cConflict and 
         cTombstone fields of pupdcount.

Returns: TRUE on success
Cond:    --
*/
HDPA PRIVATE ComposeUpdateList(
    PCBS pcbs,
    PRECLIST prl,
    UPDCOUNT * pupdcount,
    HWND hwndOwner)
    {
    HRESULT hres;
    HDPA hdpa;

    ASSERT(prl);

    hdpa = DPA_Create(20);
    if (NULL != hdpa)
        {
        LPRA_ITEM pitem;
        PRECITEM pri;
        LPCTSTR pszBrf = Atom_GetName(pcbs->atomBrf);

        ASSERT(pszBrf);

        DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("ComposeUpdateList")); )

        pupdcount->cUnavailable = 0;
        pupdcount->cDoSomething = 0;
        pupdcount->cTombstone = 0;
        pupdcount->cConflict = 0;
        
        for (pri = prl->priFirst; pri; pri = pri->priNext)
            {
            hres = RAI_CreateFromRecItem(&pitem, pszBrf, pri);
            if (SUCCEEDED(hres))
                {
                // Is this a NOP?
                if (RAIA_NOTHING == pitem->uAction ||
                    RAIA_ORPHAN == pitem->uAction)
                    {
                    // Yes; skip these guys altogether
                    }
                else
                    {
                    pitem->mask |= RAIF_LPARAM;
                    pitem->lParam = (DWORD)(LPVOID)pri;

#ifndef NEW_REC
                    // Has the file inside or outside the briefcase been deleted?
                    if (SI_DELETED == pitem->siInside.uState ||
                        SI_DELETED == pitem->siOutside.uState)
                        {
                        // Yes
                        pupdcount->cTombstone++;
                        }
                    else
#endif
                    // Is this a file entry?
                    if (IsFileRecItem(pri))
                        {
                        // Yes; add the item to the list.  
                        pitem->iItem = 0x7fff;
                        DPA_InsertPtr(hdpa, DPA_APPEND, pitem);

                        // Is this unavailable?
                        if (RAIA_SKIP == pitem->uAction)
                            {
                            // Yes
                            ASSERT(SI_UNAVAILABLE == pitem->siInside.uState ||
                                   SI_UNAVAILABLE == pitem->siOutside.uState ||
                                   SI_NOEXIST == pitem->siInside.uState ||
                                   SI_NOEXIST == pitem->siOutside.uState);
                            pupdcount->cUnavailable++;
                            }
                        else if (RAIA_CONFLICT == pitem->uAction)
                            {
                            pupdcount->cConflict++;
                            }
                        else 
                            {
                            pupdcount->cDoSomething++;
                            }

                        // (prevent pitem from being freed until 
                        // the dialog fills its list in Upd_FillList)
                        pitem = NULL;
                        }
                    }

                RAI_Free(pitem);
                }
            }
        }

    return hdpa;
    }


/*----------------------------------------------------------
Purpose: Displays a messagebox error specific to updating files

Returns: id of button
Cond:    --
*/
int PRIVATE DoUpdateMsg(
    HWND hwndOwner,
    LPCTSTR pszPath,
    UINT cFiles,
    UINT uFlags,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,
    SYNCMGRITEMID ItemID)            // DUM_ flags
    {
    UINT ids;
    UINT idi;
    int idRet;

    // Is this for Update All?
    if (IsFlagSet(uFlags, DUM_ALL))
        {
        // Yes
        idi = IDI_UPDATE_MULT;
        if (IsFlagSet(uFlags, DUM_ORPHAN))
            {
            // In this case, pszPath should be the briefcase root
            ASSERT(pszPath);

            if (IsBriefcaseEmpty(pszPath))
                ids = IDS_MSG_NoFiles;
            else
                ids = IDS_MSG_AllOrphans;
            }
        else if (IsFlagSet(uFlags, DUM_UPTODATE))
            ids = IDS_MSG_AllUptodate;
        else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
            ids = IDS_MSG_AllSomeUnavailable;
        else
            {
            ASSERT(0);  // should never get here
            ids = (UINT)-1;
            }

        idRet = MsgBox(hwndOwner, 
                    MAKEINTRESOURCE(ids), 
                    MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                    pCallBack,ItemID,LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                    MB_INFO);
        }
    else
        {
        // No
        TCHAR sz[MAX_PATH];

        ASSERT(0 != cFiles);
        ASSERT(pszPath);

        // Is this a single selection?
        if (1 == cFiles)
            {
            // Yes; assume it is a folder, then decrement the count
            // of the ids it is a file 
            if (IsFlagSet(uFlags, DUM_ORPHAN))
                ids = IDS_MSG_FolderOrphan;
            else if (IsFlagSet(uFlags, DUM_UPTODATE))
                ids = IDS_MSG_FolderUptodate;
            else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
                ids = IDS_MSG_FolderUnavailable;
            else if (IsFlagSet(uFlags, DUM_SUBFOLDER_TWIN))
                ids = IDS_MSG_FolderSubfolder;
            else
                {
                ASSERT(0);  // should never get here
                ids = (UINT)-1;
                }

            if (FALSE == PathIsDirectory(pszPath))
                {
                ASSERT(IsFlagClear(uFlags, DUM_SUBFOLDER_TWIN));
                ids--;      // use file-oriented messages
                idi = IDI_UPDATE_FILE;
                }
            else
                {
                idi = IDI_UPDATE_FOLDER;
                }

            idRet = MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(ids), 
                        MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                        pCallBack,ItemID,LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                        MB_INFO,
                        PathGetDisplayName(pszPath, sz));
            }
        else
            {
            // No; multi selection
            idi = IDI_UPDATE_MULT;

            if (IsFlagSet(uFlags, DUM_UPTODATE))
                {
                if (IsFlagSet(uFlags, DUM_ORPHAN))
                    ids = IDS_MSG_MultiUptodateOrphan;
                else
                    ids = IDS_MSG_MultiUptodate;
                }
            else if (IsFlagSet(uFlags, DUM_ORPHAN))
                ids = IDS_MSG_MultiOrphans;
            else if (IsFlagSet(uFlags, DUM_UNAVAILABLE))
                ids = IDS_MSG_MultiUnavailable;
            else if (IsFlagSet(uFlags, DUM_SUBFOLDER_TWIN))
                ids = IDS_MSG_MultiSubfolder;
            else
                {
                ASSERT(0);  // should never get here
                ids = (UINT)-1;
                }

            idRet = MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(ids), 
                        MAKEINTRESOURCE(IDS_CAP_UPDATE), 
                        pCallBack,ItemID,LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                        MB_INFO,
                        cFiles);
            }
        }

    return idRet;
    }


/*----------------------------------------------------------
Purpose: This function does some preliminary checks to determine
         whether the dialog box needs to be invoked at all.

         Sets the cOrphans and cSubfolders fields of pupdcount.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE PrepForUpdateAll(
    PCBS pcbs,
    PRECLIST * pprl,
    UPDCOUNT * pupdcount,
    HWND hwndProgress,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,
    SYNCMGRITEMID ItemID)
    {
    HRESULT hres = E_FAIL;
    TWINRESULT tr;
    HWND hwndOwner = GetParent(hwndProgress);
    BOOL bAnyTwins;

    pupdcount->cSubfolders = 0;

    // Are there any twins in the database?

    tr = Sync_AnyTwins(pcbs->hbrf, &bAnyTwins);
    if (TR_SUCCESS == tr)
        {
        if (FALSE == bAnyTwins)
            {
            // No
			// rogerg, pump to progress
            DoUpdateMsg(hwndOwner, Atom_GetName(pcbs->atomBrf), 1, DUM_ALL | DUM_ORPHAN
		,pCallBack,ItemID);
            hres = S_FALSE;
            }

        // Can we get a fresh reclist?
        else 
            {
            pupdcount->cOrphans = 0;
            hres = Sync_CreateCompleteRecList(pcbs->hbrf, UpdBar_GetAbortEvt(hwndProgress), pprl);
            if (FAILED(hres))
                {
                // No
                if (E_TR_ABORT != hres)
                    {
					// rogerg, pump to progress
                    //MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), 
                    //    MAKEINTRESOURCE(IDS_CAP_UPDATE), NULL, MB_ERROR);
                    }
                }
            else
                {
                // Yes
                if (*pprl)
                    {
                    hres = S_OK;
                    }
                else
                    {
                    hres = E_UNEXPECTED;
                    }
                // (reclist is freed inFinishUpdate())
                }
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: This function does some preliminary checks to determine
         whether the dialog box needs to be invoked at all.

         Sets the cOrphans and cSubfolders fields of pupdcount.

Returns: standard result
Cond:    --
*/
HRESULT PRIVATE PrepForUpdateSelection(
    PCBS pcbs,
    PRECLIST  * pprl,
    LPCTSTR pszList,
    UINT cFiles,
    UPDCOUNT * pupdcount,
    HWND hwndProgress,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,
    SYNCMGRITEMID ItemID)
    {
    HRESULT hres;
    TWINRESULT tr;
    HTWINLIST htl;
    HWND hwndOwner = GetParent(hwndProgress);

    pupdcount->cSubfolders = 0;

    // Create a twin list
    tr = Sync_CreateTwinList(pcbs->hbrf, &htl);

    if (TR_SUCCESS != tr)
        {
        // Failure
        MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
               pCallBack,ItemID,NULL, MB_ERROR);
        hres = E_OUTOFMEMORY;
        }
    else
        {
        LPCTSTR psz;
        UINT cOrphans = 0;
        UINT cSubfolders = 0;
        UINT i;

        for (i = 0, psz = pszList; i < cFiles; i++)
            {
            // Is this object really a twin?
            if (S_FALSE == Sync_IsTwin(pcbs->hbrf, psz, 0) )
                {
                // No; is this a subfolder twin?
                if (IsSubfolderTwin(pcbs->hbrf, psz))
                    {
                    // Yes
                    cSubfolders++;
                    }
                else
                    {
                    // No
                    cOrphans++;
                    }
                }
            else 
                {
                // Yes; add it to the twin list
                Sync_AddPathToTwinList(pcbs->hbrf, htl, psz, NULL);
                }

            DataObj_NextFile(psz);      // Set psz to next file in list
            }

        // Are all the selected objects orphans?
        if (cOrphans < cFiles)
            {
            // No; create the reclist 
            hres = Sync_CreateRecListEx(htl, UpdBar_GetAbortEvt(hwndProgress), pprl);
            }
        else
            {
            // Yes
            DoUpdateMsg(hwndOwner, pszList, cFiles, DUM_SELECTION | DUM_ORPHAN,pCallBack,ItemID);
            hres = S_FALSE;
            }
        pupdcount->cOrphans = cOrphans;
        pupdcount->cSubfolders = cSubfolders;
        Sync_DestroyTwinList(htl);          // Don't need this anymore
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Checks for the special cases that are listed at the top 
         of this file.

Returns: PSC_ flags

Cond:    --
*/
UINT PRIVATE PassedSpecialCases(
    HWND hwndOwner,
    LPCTSTR pszList,
    UPDCOUNT * pupdcount,
    UINT uFlags,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,
    SYNCMGRITEMID ItemID)
    {
    UINT uRet = 0;
    UINT dum = 0;
    UINT cSomeAction = pupdcount->cDoSomething + pupdcount->cConflict;

    // Is this Update All?
    if (IsFlagSet(uFlags, UF_ALL))
        {
        // Yes
        if (0 < pupdcount->cOrphans)
            {
            // Case A2
            dum = DUM_ALL | DUM_ORPHAN;
            }
        else if (0 == pupdcount->cUnavailable)
            {
            if (0 == cSomeAction)
                {
                // Case A3
                dum = DUM_ALL | DUM_UPTODATE;
                }
            else
                {
                // Case A4
                uRet = PSC_SHOWDIALOG;
                }
            }
        else
            {
            // Cases A5 and A6
            dum = DUM_ALL | DUM_UNAVAILABLE;
            uRet = PSC_SHOWDIALOG;
            }

#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_UPDATECOUNT))
            {
            TRACE_MSG(TF_ALWAYS, TEXT("Update All counts: files = %u, orphans = %u, unavailable = %u, dosomething = %u, conflict = %u, subfolders = %u"),
                        pupdcount->cFiles, pupdcount->cOrphans, 
                        pupdcount->cUnavailable, pupdcount->cDoSomething,
                        pupdcount->cConflict, pupdcount->cSubfolders);
            }

#endif
        }
    else
        {
        // No; single selection?

        // Take caution in the comparisons below.  The counts do not
        // have a 1-to-1 correspondence.  They are split into two 
        // groups:        cFiles <---> cOrphans  <---> cSubfolders
        //          cUnavailable <---> cDoSomething
        //
        // This means comparing cFiles with cDoSomething or cUnavailable
        // will produce bogus results in the case when folders are 
        // selected.
        //
        // As long as the comparisons below do not break these limits,
        // everything is okay.

        if (1 == pupdcount->cFiles)
            {
            // Yes
            ASSERT(2 > pupdcount->cOrphans);
            ASSERT(2 > pupdcount->cSubfolders);
            if (1 == pupdcount->cOrphans)
                {
                // Case S1
                dum = DUM_SELECTION | DUM_ORPHAN;
                }
            else if (0 == pupdcount->cUnavailable)
                {
                if (0 == cSomeAction)
                    {
                    if (0 == pupdcount->cSubfolders)
                        {
                        // Case S2
                        dum = DUM_SELECTION | DUM_UPTODATE;
                        }
                    else
                        {
                        dum = DUM_SELECTION | DUM_SUBFOLDER_TWIN;
                        }
                    }
                else
                    {
                    // Case S3
                    uRet = PSC_SHOWDIALOG;
                    }
                }
            else 
                {
                // Case S4
                dum = DUM_SELECTION | DUM_UNAVAILABLE;
                uRet = PSC_SHOWDIALOG;
                }
            }
        else
            {
            // No; this is a multi selection

            if (0 < pupdcount->cSubfolders)
                {
				// rogerg, pump to progress
                DoUpdateMsg(hwndOwner, pszList, pupdcount->cSubfolders,
		    DUM_SELECTION | DUM_SUBFOLDER_TWIN,pCallBack,ItemID);
                goto Leave;  // HACK
                }

            if (pupdcount->cFiles == pupdcount->cOrphans)
                {
                // Case S5
                dum = DUM_SELECTION | DUM_ORPHAN;
                }
            else if (0 < pupdcount->cUnavailable)
                {
                if (0 < cSomeAction)
                    {
                    if (0 == pupdcount->cOrphans)
                        {
                        // Case S6
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG;
                        }
                    else
                        {
                        // Case S7
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                        }
                    }
                else 
                    {
                    if (0 == pupdcount->cOrphans)
                        {
                        // Case S8
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG;
                        }
                    else
                        {
                        // Case S9
                        dum = DUM_SELECTION | DUM_UNAVAILABLE;
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                        }
                    }
                }
            else
                {
                if (0 < cSomeAction)
                    {
                    if (0 == pupdcount->cOrphans)
                        {
                        // Case S10
                        uRet = PSC_SHOWDIALOG;
                        }
                    else
                        {
                        // Case S11
                        uRet = PSC_SHOWDIALOG | PSC_POSTMSGBOX;
                        }
                    }
                else 
                    {
                    if (0 == pupdcount->cOrphans)
                        {
                        // Case S12
                        dum = DUM_SELECTION | DUM_UPTODATE;
                        }
                    else
                        {
                        // Case S13
                        dum = DUM_SELECTION | DUM_UPTODATE | DUM_ORPHAN;
                        }
                    }
                }
            }

Leave:
        ;
#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_UPDATECOUNT))
            {
            TRACE_MSG(TF_ALWAYS, TEXT("Update selection counts: files = %u, orphans = %u, unavailable = %u, dosomething = %u, conflict = %u, subfolders = %u"),
                        pupdcount->cFiles, pupdcount->cOrphans, 
                        pupdcount->cUnavailable, pupdcount->cDoSomething,
                        pupdcount->cConflict, pupdcount->cSubfolders);
            }

#endif
        }

    if (0 != dum)
        {

		// rogerg, pump to progress
        DoUpdateMsg(hwndOwner, pszList, pupdcount->cFiles, dum,pCallBack,ItemID);
        }

    return uRet;
    }


/*----------------------------------------------------------
Purpose: Show the update dialog and perform the reconcilation
         if the user chooses OK

Returns: standard result
Cond:    --
*/


// Rogerg changed code

HRESULT Upd_PrepForSync(HWND hwndOwner,
    CBS * pcbs,
    LPCTSTR pszList,         // May be NULL if uFlags == UF_ALL
    UINT cFiles,
    UINT uFlags,
	UPDCOUNT *updcount,
	PRECLIST *prl,
	UINT *uVal,
	LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,SYNCMGRITEMID ItemID) 
{
int nRet;
HRESULT hres;
HWND hwndProgress;

    *prl = NULL;
    hwndProgress = UpdBar_Show(hwndOwner, UB_CHECKING, DELAY_UPDBAR,pCallBack,ItemID);

    // Get a reclist and other useful information
    updcount->cFiles = cFiles;

    if (IsFlagSet(uFlags, UF_ALL))
     {
        hres = PrepForUpdateAll(pcbs, prl, updcount, hwndProgress,pCallBack,ItemID);
    }
    else
    {
        hres = PrepForUpdateSelection(pcbs, prl, pszList, cFiles, updcount, 
		hwndProgress,pCallBack,ItemID);
     }

    UpdBar_Kill(hwndProgress);

    if (S_OK == GetScode(hres))
    {
        XUPDSTRUCT xupd;
        xupd.lprl = *prl;
        xupd.pcbs = pcbs;
        xupd.uFlags = uFlags;
        xupd.hdpa = ComposeUpdateList(pcbs,*prl, updcount, hwndOwner);
        xupd.cDoSomething = updcount->cDoSomething;

        if (NULL == xupd.hdpa)
            {
            hres = E_OUTOFMEMORY;
            MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                  pCallBack,ItemID,NULL, MB_ERROR);
            }
        else
            {
            // Check for some of those special cases listed at top of file
            *uVal = PassedSpecialCases(hwndOwner, pszList, updcount, uFlags,
					pCallBack,ItemID);

            // Show the update dialog?
            if (IsFlagSet(*uVal, PSC_SHOWDIALOG))
                {
                // Yes
                nRet = DoModal(hwndOwner, Upd_WrapperProc, IDD_UPDATE, (LPARAM)&xupd);

                switch (nRet)
                    {
                case IDOK:
				   hres = S_OK;
				   break;
                case IDCANCEL:
                    hres = S_FALSE;
                    break;

                case -1:
                    MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_OOM_UPDATEDIALOG), MAKEINTRESOURCE(IDS_CAP_UPDATE),
                           pCallBack,ItemID,NULL, MB_ERROR);
                    hres = E_OUTOFMEMORY;
                    break;

                default:
					Assert(0);
                    hres = S_FALSE;
                    break;
                    }
                }
			}

		  DPA_Destroy(xupd.hdpa);
	}

    return hres;
}


// perform actual sync

HRESULT Upd_Synchronize(HWND hwndOwner, CBS * pcbs,UINT uFlags,UINT uVal,PRECLIST prl,
		LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,SYNCMGRITEMID ItemID)
{
HRESULT hres = NOERROR;
HWND hwndProgress;

    hwndProgress = UpdBar_Show(hwndOwner, UB_UPDATING, 0,pCallBack,ItemID);

    hres = Sync_ReconcileRecList(prl, Atom_GetName(pcbs->atomBrf),
        hwndProgress, RF_DEFAULT);

    UpdBar_Kill(hwndProgress);


    return hres;
}


HRESULT Upd_ShowError(HWND hwndOwner,UINT uVal,UPDCOUNT updcount,LPCTSTR pszList)
{

	// Show a summary messagebox?
	if (IsFlagSet(uVal, PSC_POSTMSGBOX))
	{
	// Yes
		DoUpdateMsg(hwndOwner, pszList, updcount.cOrphans,
		    DUM_SELECTION | DUM_ORPHAN,NULL,GUID_NULL);
	}

	return NOERROR;
}

HRESULT PUBLIC Upd_DoModal(
    HWND hwndOwner,
    CBS * pcbs,
    LPCTSTR pszList,         // May be NULL if uFlags == UF_ALL
    UINT cFiles,
    UINT uFlags)
{
int nRet;
HRESULT hres;

// these need to be saved between calls.
PRECLIST prl;
UPDCOUNT updcount;
UINT uVal;


    if (NOERROR == Upd_PrepForSync(hwndOwner,pcbs,pszList,cFiles,uFlags,
			    &updcount,&prl,&uVal,NULL,GUID_NULL) )
    {

	    hres = Upd_Synchronize(hwndOwner,pcbs,uFlags,uVal,prl,NULL,GUID_NULL);

	    Upd_ShowError(hwndOwner,uVal,updcount,pszList);

	    Sync_DestroyRecList(prl); // destroy reclist allocated in PrepForSync
    }

    return hres;
}



// end of rogerg changing code
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\twin.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: twin.c
//
//  This file contains special twin handling functions.
//
//   (Even though we've moved to a briefcase metaphor,
//    we still refer to twins internally...)
//
// History:
//  08-06-93 ScottH     Transferred from twin code
//
//---------------------------------------------------------------------------


#include "brfprv.h"         // common headers

#include "res.h"
#include "recact.h"

#define SHChangeNotifyHandleEvents() SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL)  

#pragma data_seg(DATASEG_PERINSTANCE)
VTBLENGINE g_vtblEngine[1] = { { 0 } };    // per-instance v-table
#pragma data_seg()

#define GetFunction(rgtable, name, type)     \
            ((rgtable).##name = (type)GetProcAddress((rgtable).hinst, #name)); \
            ASSERT((rgtable).##name)

#ifdef DEBUG
#define SzTR(tr)    #tr,
#endif

#define MAX_RANGE       0x7fff

// Recitem dwUser values
#define RIU_CHANGED     1
#define RIU_SKIP        2
#define RIU_SHOWSTATUS  3


/*----------------------------------------------------------
Purpose: Compare two structures by folder name
Returns: -1 if <, 0 if ==, 1 if >
Cond:    --
*/
int CALLBACK _export NCompareFolders(
    LPVOID lpv1,
    LPVOID lpv2,
    LPARAM lParam)      // One of: CMP_RECNODES, CMP_FOLDERTWINS
    {
    switch (lParam)
        {
    case CMP_RECNODES:
        return lstrcmpi(((PRECNODE)lpv1)->pcszFolder, ((PRECNODE)lpv2)->pcszFolder);

    case CMP_FOLDERTWINS:
        return lstrcmpi(((PCFOLDERTWIN)lpv1)->pcszOtherFolder, ((PCFOLDERTWIN)lpv2)->pcszOtherFolder);

    default:
        ASSERT(0);      // should never get here
        }
    }


//---------------------------------------------------------------------------
// Choose side functions
//---------------------------------------------------------------------------


#ifdef DEBUG

/*----------------------------------------------------------
Purpose: Dump a CHOOSESIDE structure
Returns: --
Cond:    --
*/
void PRIVATE ChooseSide_Dump(
    PCHOOSESIDE pchside)
    {
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    ASSERT(pchside);

    #define szDumpLabel     TEXT("             *** ")
    #define szDumpMargin    TEXT("                 ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CHOOSESIDE);
        }
    LEAVEEXCLUSIVE()

    if (bDump)
        {
        wsprintf(szBuf, TEXT("%s.pszFolder = {%s}\r\n"), (LPTSTR)szDumpLabel, pchside->pszFolder);
        OutputDebugString(szBuf);

        wsprintf(szBuf, TEXT("%s.dwFlags = 0x%lx\r\n"), (LPTSTR)szDumpMargin, pchside->dwFlags);
        OutputDebugString(szBuf);

        wsprintf(szBuf, TEXT("%s.nRank = %ld\r\n"), (LPTSTR)szDumpMargin, pchside->nRank);
        OutputDebugString(szBuf);
        }

    #undef szDumpLabel
    #undef szDumpMargin
    }


/*----------------------------------------------------------
Purpose: Dump a CHOOSESIDE list
Returns: --
Cond:    --
*/
void PUBLIC ChooseSide_DumpList(
    HDSA hdsa)
    {
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    ASSERT(hdsa);

    #define szDumpLabel     TEXT("Dump CHOOSESIDE list: ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CHOOSESIDE);
        }
    LEAVEEXCLUSIVE()

    if (bDump)
        {
        int i;
        int cel = DSA_GetItemCount(hdsa);
        PCHOOSESIDE pchside;

        wsprintf(szBuf, TEXT("%s.count = %lu\r\n"), (LPTSTR)szDumpLabel, cel);
        OutputDebugString(szBuf);

        if (NULL != (pchside = DSA_GetItemPtr(hdsa, 0)))
            {
            if (IsFlagSet(pchside->dwFlags, CSF_INSIDE))
                OutputDebugString(TEXT("Rank for inside\r\n"));
            else
                OutputDebugString(TEXT("Rank for outside\r\n"));
            }
            
        for (i = 0; i < cel; i++)
            {
            pchside = DSA_GetItemPtr(hdsa, i);

            ChooseSide_Dump(pchside);
            }
        }

    #undef szDumpLabel
    }

#endif


/*----------------------------------------------------------
Purpose: Initialize an array of CHOOSESIDE elements from a 
         recitem list.  Array is unsorted.

Returns: --

Cond:    The contents of the array are safe as long as the 
         recitem list lives.

*/
void PUBLIC ChooseSide_InitAsFile(
    HDSA hdsa,
    PRECITEM pri)
    {
    CHOOSESIDE chside;
    PRECNODE prn;

    ASSERT(hdsa);
    ASSERT(pri);

    DSA_DeleteAllItems(hdsa);

    // All entries start with these values
    chside.dwFlags = 0;
    chside.nRank = 0;

    // Add each recnode
    for (prn = pri->prnFirst; prn; prn = prn->prnNext)
        {
        chside.htwin = (HTWIN)prn->hObjectTwin;
        chside.hvid = prn->hvid;
        chside.pszFolder = prn->pcszFolder;
        chside.prn = prn;

        DSA_InsertItem(hdsa, 0x7fff, &chside);
        }
    }


/*----------------------------------------------------------
Purpose: Create an array of CHOOSESIDE elements from a recitem
         list.  Array is unsorted.

Returns: standard result

Cond:    The contents of the array are safe as long as the 
         recitem list lives.

*/
HRESULT PUBLIC ChooseSide_CreateAsFile(
    HDSA * phdsa,
    PRECITEM pri)
    {
    HRESULT hres;
    HDSA hdsa;

    ASSERT(phdsa);
    ASSERT(pri);

    hdsa = DSA_Create(sizeof(CHOOSESIDE), (int)pri->ulcNodes);
    if (hdsa)
        {
        ChooseSide_InitAsFile(hdsa, pri);
        hres = NOERROR;
        }
    else
        hres = E_OUTOFMEMORY;

    *phdsa = hdsa;

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create an empty array of CHOOSESIDE elements.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC ChooseSide_CreateEmpty(
    HDSA * phdsa)
    {
    HRESULT hres;
    HDSA hdsa;

    ASSERT(phdsa);

    hdsa = DSA_Create(sizeof(CHOOSESIDE), 4);
    if (hdsa)
        {
        hres = NOERROR;
        }
    else
        hres = E_OUTOFMEMORY;

    *phdsa = hdsa;

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create an array of CHOOSESIDE elements from a foldertwin
         list.  Array is unsorted.

Returns: standard result

Cond:    The contents of the array are safe as long as the 
         foldertwin list lives.

*/
HRESULT PUBLIC ChooseSide_CreateAsFolder(
    HDSA * phdsa,
    PFOLDERTWINLIST pftl)
    {
    HRESULT hres;
    HDSA hdsa;
    CHOOSESIDE chside;

    ASSERT(pftl);

    hdsa = DSA_Create(sizeof(chside), (int)pftl->ulcItems);
    if (hdsa)
        {
        PCFOLDERTWIN pft;
        LPCTSTR pszFolderLast = NULL;

        // All entries start with these values
        chside.dwFlags = CSF_FOLDER;
        chside.nRank = 0;
        chside.prn = NULL;

        // Special case the source folder
        chside.htwin = (HTWIN)pftl->pcftFirst->hftSrc;
        chside.hvid = pftl->pcftFirst->hvidSrc;
        chside.pszFolder = pftl->pcftFirst->pcszSrcFolder;

        // (Don't care if this fails)
        DSA_InsertItem(hdsa, 0x7fff, &chside);

        // Add the other folders (duplicates skipped)
        for (pft = pftl->pcftFirst; pft; pft = pft->pcftNext)
            {
            // Duplicate?
            if (pszFolderLast && IsSzEqual(pszFolderLast, pft->pcszOtherFolder))
                continue;   // Yes (hack: the engine gives us a sorted list)

            chside.htwin = (HTWIN)pft->hftOther;
            chside.hvid = pft->hvidOther;
            chside.pszFolder = pft->pcszOtherFolder;

            DSA_InsertItem(hdsa, 0x7fff, &chside);

            pszFolderLast = pft->pcszOtherFolder;
            }
        *phdsa = hdsa;
        hres = NOERROR;
        }
    else
        hres = E_OUTOFMEMORY;

    return hres;
    }


/*----------------------------------------------------------
Purpose: Reset the ranks

Returns: --
Cond:    --
*/
void PRIVATE ChooseSide_ResetRanks(
    HDSA hdsa)
    {
    int i;
    int cel;

    ASSERT(hdsa);

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
        {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);

        pchside->nRank = 0;
        }
    }


/*----------------------------------------------------------
Purpose: Determine ranks based on whether each element in the
         array is inside the briefcase.

Returns: --
Cond:    --
*/
void PRIVATE ChooseSide_RankForInside(
    HDSA hdsa,
    LPCTSTR pszBrfPath,      // Root path of briefcase
    LPCTSTR pszFolder)       // If NULL, choose best outside element
    {
    int i;
    int cel;
    int cchLast = 0;
    PCHOOSESIDE pchsideLast;

    ASSERT(hdsa);
    ASSERT(pszBrfPath);
    ASSERT(pszFolder);
    ASSERT(PathIsPrefix(pszFolder, pszBrfPath));

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
        {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);

        DEBUG_CODE( SetFlag(pchside->dwFlags, CSF_INSIDE); )

        // Is this item inside this briefcase?
        if (PathIsPrefix(pchside->pszFolder, pszBrfPath))
            pchside->nRank++;       // Yes

        // Is this item inside this folder?
        if (PathIsPrefix(pchside->pszFolder, pszFolder))
            {
            int cch = lstrlen(pchside->pszFolder);

            pchside->nRank++;       // Yes; even better

            if (0 == cchLast)
                {
                cchLast = cch;
                pchsideLast = pchside;
                }
            else 
                {
                // Is this path deeper than the last prefix-matching path?
                // (the path closer to the top is better)
                if (cch > cchLast)
                    {
                    // Yes; demote this one 
                    pchside->nRank--;
                    }
                else
                    {
                    // No; demote previous one
                    ASSERT(pchsideLast);
                    pchsideLast->nRank--;

                    cchLast = cch;
                    pchsideLast = pchside;
                    }
                }
            }
        }
    }


/*----------------------------------------------------------
Purpose: Determine ranks based on whether each element in the
         array is outside the briefcase.

Returns: --
Cond:    --
*/
void PRIVATE ChooseSide_RankForOutside(
    HDSA hdsa,
    LPCTSTR pszBrfPath)      // Root path of briefcase
    {
    int i;
    int cel;

    ASSERT(hdsa);
    ASSERT(pszBrfPath);

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
        {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);

        DEBUG_CODE( ClearFlag(pchside->dwFlags, CSF_INSIDE); )

        // Is this item NOT in this briefcase?
        if ( !PathIsPrefix(pchside->pszFolder, pszBrfPath) )
            {
            // Yes
            int ndrive = PathGetDriveNumber(pchside->pszFolder);
            int nDriveType = DriveType(ndrive);

            pchside->nRank += 2;

            if (IsFlagClear(pchside->dwFlags, CSF_FOLDER))
                {
                // Is the file unavailable?
                if (RNS_UNAVAILABLE == pchside->prn->rnstate ||
                    FS_COND_UNAVAILABLE == pchside->prn->fsCurrent.fscond)
                    {
                    // Yes; demote
                    pchside->nRank--;
                    }
                }
            else
                {
                // Is the folder unavailable?
                UINT uStatus;

                Sync_GetFolderTwinStatus((HFOLDERTWIN)pchside->htwin, NULL, 0, 
                    &uStatus);
                if (FTS_UNAVAILABLE == uStatus)
                    {
                    // Yes; demote
                    pchside->nRank--;
                    }
                }

            // Rank on locality of disk (the closer the better)
            if (DRIVE_REMOVABLE == nDriveType || DRIVE_CDROM == nDriveType)
                ;                       // Floppy/removable (do nothing)
            else if (PathIsUNC(pchside->pszFolder) || IsNetDrive(ndrive))
                pchside->nRank++;       // Net
            else
                pchside->nRank += 2;    // Fixed disk
            }
        }
    }


/*----------------------------------------------------------
Purpose: Choose the element with the highest rank.

Returns: TRUE if any element distinguished itself

Cond:    --
*/
BOOL PRIVATE ChooseSide_GetBestRank(
    HDSA hdsa,
    PCHOOSESIDE * ppchside)
    {
    BOOL bRet;
    int i;
    int cel;
    int nRankCur = 0;       // (start at 0 since 0 is not good enough to pass muster)
    DEBUG_CODE( BOOL bDbgDup = FALSE; )

    ASSERT(hdsa);
    ASSERT(ppchside);

    *ppchside = NULL;

    cel = DSA_GetItemCount(hdsa);
    for (i = 0; i < cel; i++)
        {
        PCHOOSESIDE pchside = DSA_GetItemPtr(hdsa, i);

#ifdef DEBUG
        if (0 < nRankCur && nRankCur == pchside->nRank)
            bDbgDup = TRUE;
#endif

        if (nRankCur < pchside->nRank)
            {
            *ppchside = pchside;
            nRankCur = pchside->nRank;

            DEBUG_CODE( bDbgDup = FALSE; )      // Reset
            }
        }

#ifdef DEBUG
    // We shouldn't get duplicate highest ranks
    if (bDbgDup)
        {
        // Dump the chooseside list if there are duplicate highest ranks
        ChooseSide_DumpList(hdsa);
        }
    ASSERT(FALSE == bDbgDup);
#endif

    bRet = 0 < nRankCur;
    ASSERT(bRet && *ppchside || !bRet && !*ppchside);

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Get the best candidate element (inside or outside).
         If the pszFolder is NULL, this function gets the best
         outside path.  

Returns: TRUE if an element was found

Cond:    --
*/
BOOL PUBLIC ChooseSide_GetBest(
    HDSA hdsa,
    LPCTSTR pszBrfPath,      // Root path of briefcase
    LPCTSTR pszFolder,       // If NULL, choose best outside element
    PCHOOSESIDE * ppchside)
    {
    ASSERT(hdsa);
    ASSERT(0 < DSA_GetItemCount(hdsa));
    ASSERT(pszBrfPath);
    ASSERT(ppchside);

    ChooseSide_ResetRanks(hdsa);

    // Are we ranking for inside paths?
    if (pszFolder)
        {
        // Yes; inside wins
        ChooseSide_RankForInside(hdsa, pszBrfPath, pszFolder);
        }
    else
        {
        // No; outside wins
        ChooseSide_RankForOutside(hdsa, pszBrfPath);
        }

    return ChooseSide_GetBestRank(hdsa, ppchside);
    }


/*----------------------------------------------------------
Purpose: Get the next best candidate element (inside or outside).
         ChooseSide_GetBest must have been previously called.

Returns: TRUE if an element was found

Cond:    --
*/
BOOL PUBLIC ChooseSide_GetNextBest(
    HDSA hdsa,
    PCHOOSESIDE * ppchside)
    {
    PCHOOSESIDE pchside;

    ASSERT(hdsa);
    ASSERT(0 < DSA_GetItemCount(hdsa));
    ASSERT(ppchside);

    // Get the best rank and reset it
    ChooseSide_GetBestRank(hdsa, &pchside);
    pchside->nRank = 0;

    // Now get the next best rank
    return ChooseSide_GetBestRank(hdsa, ppchside);
    }


/*----------------------------------------------------------
Purpose: Frees an array of CHOOSESIDE elements.

Returns: --
Cond:    --
*/
void PUBLIC ChooseSide_Free(
    HDSA hdsa)
    {
    if (hdsa)
        {
        DSA_Destroy(hdsa);
        }
    }


//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------


/*----------------------------------------------------------
Purpose: Determine which node is inside and outside a briefcase.

         This function takes a list of recnodes and determines
         which node is "inside" a briefcase and which one is
         "outside" a briefcase.  "Inside" means the file exists 
         somewhere underneath the briefcase path indicated by 
         atomBrf.  "Outside" is anywhere else (but may be in 
         a different briefcase as well).

Returns: --
Cond:    --
*/
HRESULT PUBLIC Sync_GetNodePair(
    PRECITEM pri,
    LPCTSTR pszBrfPath,
    LPCTSTR pszInsideDir,            // Which folder inside the briefcase to consider
    PRECNODE  * pprnInside,
    PRECNODE  * pprnOutside)     
    {
    HRESULT hres;
    HDSA hdsa;

    ASSERT(pri);
    ASSERT(pszBrfPath);
    ASSERT(pszInsideDir);
    ASSERT(pprnInside);
    ASSERT(pprnOutside);
    ASSERT(PathIsPrefix(pszInsideDir, pszBrfPath));

    hres = ChooseSide_CreateAsFile(&hdsa, pri);
    if (SUCCEEDED(hres))
        {
        PCHOOSESIDE pchside;

        // Get inside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, pszInsideDir, &pchside))
            {
            *pprnInside = pchside->prn;
            }
        else
            ASSERT(0);

        // Get outside folder
        if (ChooseSide_GetBest(hdsa, pszBrfPath, NULL, &pchside))
            {
            *pprnOutside = pchside->prn;
            }
        else
            ASSERT(0);

#ifdef DEBUG

        if (IsFlagSet(g_uDumpFlags, DF_PATHS))
            {
            TRACE_MSG(TF_ALWAYS, TEXT("Choosing pairs: %s and %s"), (*pprnInside)->pcszFolder,
                (*pprnOutside)->pcszFolder);
            }

#endif

        ChooseSide_Free(hdsa);
        }
    else
        {
        *pprnInside = NULL;
        *pprnOutside = NULL;
        }
    return hres;
    }



/*----------------------------------------------------------
Purpose: Checks if we've loaded the sync engine
Returns: TRUE if loaded
Cond:    --
*/
BOOL PUBLIC Sync_IsEngineLoaded()
    {
    BOOL bRet;

    ENTEREXCLUSIVE() 
        {
        bRet = g_vtblEngine[0].hinst != NULL;
        }
    LEAVEEXCLUSIVE()

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Load the SYNCENG.DLL and initialize the v-table.
Returns: TRUE on success
Cond:    --
*/
BOOL PUBLIC Sync_QueryVTable(void)
    {
    BOOL bRet = TRUE;
    HINSTANCE hinst;

    ENTEREXCLUSIVE()
        {
        hinst = g_vtblEngine[0].hinst;
        }
    LEAVEEXCLUSIVE()

    // We want to assure that the engine is loaded the same
    //  number of times that SYNCUI is (by a process).  This prevents
    //  Kernel from nuking the engine prematurely (if a
    //  process is terminated).
    //
    // We go thru these hoops simply because SYNCUI does not
    //  load SYNCENG immediately upon PROCESS_ATTACH.  We wait
    //  until we *really* need to load it the first time.
    //  Once we finally do load it, we need to keep the load
    //  count current.
    //
    // Kernel frees SYNCUI and SYNCENG for us.
    //
    if (NULL == hinst)
        {
        VTBLENGINE vtbl;

        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Loading %s (cProcess = %d)"),
            (LPCTSTR)c_szEngineDLL, g_cProcesses); )

        ZeroInit(&vtbl, sizeof(VTBLENGINE));

        // Don't be in the critical section when we load the DLL
        // or call GetProcAddress, since our LibMain can block on
        // this critical section.
        ASSERT_NOT_EXCLUSIVE();

        hinst = LoadLibrary(c_szEngineDLL);

        if ( ISVALIDHINSTANCE(hinst) )
            {
            // We are loading for the first time.  Fill the vtable.
            //
            vtbl.hinst = hinst;

            // Get all the function addresses
            //

            GetFunction(vtbl, OpenBriefcase, OPENBRIEFCASEINDIRECT);
            GetFunction(vtbl, SaveBriefcase, SAVEBRIEFCASEINDIRECT);
            GetFunction(vtbl, CloseBriefcase, CLOSEBRIEFCASEINDIRECT);
            GetFunction(vtbl, ClearBriefcaseCache, CLEARBRIEFCASECACHEINDIRECT);
            GetFunction(vtbl, DeleteBriefcase, DELETEBRIEFCASEINDIRECT);
            GetFunction(vtbl, GetOpenBriefcaseInfo, GETOPENBRIEFCASEINFOINDIRECT);
            GetFunction(vtbl, FindFirstBriefcase, FINDFIRSTBRIEFCASEINDIRECT);
            GetFunction(vtbl, FindNextBriefcase, FINDNEXTBRIEFCASEINDIRECT);
            GetFunction(vtbl, FindBriefcaseClose, FINDBRIEFCASECLOSEINDIRECT);

            GetFunction(vtbl, AddObjectTwin, ADDOBJECTTWININDIRECT);
            GetFunction(vtbl, AddFolderTwin, ADDFOLDERTWININDIRECT);
            GetFunction(vtbl, ReleaseTwinHandle, RELEASETWINHANDLEINDIRECT);
            GetFunction(vtbl, DeleteTwin, DELETETWININDIRECT);
            GetFunction(vtbl, GetObjectTwinHandle, GETOBJECTTWINHANDLEINDIRECT);
            GetFunction(vtbl, IsFolderTwin, ISFOLDERTWININDIRECT);
            GetFunction(vtbl, CreateFolderTwinList, CREATEFOLDERTWINLISTINDIRECT);
            GetFunction(vtbl, DestroyFolderTwinList, DESTROYFOLDERTWINLISTINDIRECT);
            GetFunction(vtbl, GetFolderTwinStatus, GETFOLDERTWINSTATUSINDIRECT);
            GetFunction(vtbl, IsOrphanObjectTwin, ISORPHANOBJECTTWININDIRECT);
            GetFunction(vtbl, CountSourceFolderTwins, COUNTSOURCEFOLDERTWINSINDIRECT);
            GetFunction(vtbl, AnyTwins, ANYTWINSINDIRECT);

            GetFunction(vtbl, CreateTwinList, CREATETWINLISTINDIRECT);
            GetFunction(vtbl, DestroyTwinList, DESTROYTWINLISTINDIRECT);
            GetFunction(vtbl, AddTwinToTwinList, ADDTWINTOTWINLISTINDIRECT);
            GetFunction(vtbl, AddAllTwinsToTwinList, ADDALLTWINSTOTWINLISTINDIRECT);
            GetFunction(vtbl, RemoveTwinFromTwinList, REMOVETWINFROMTWINLISTINDIRECT);
            GetFunction(vtbl, RemoveAllTwinsFromTwinList, REMOVEALLTWINSFROMTWINLISTINDIRECT);

            GetFunction(vtbl, CreateRecList, CREATERECLISTINDIRECT);
            GetFunction(vtbl, DestroyRecList, DESTROYRECLISTINDIRECT);
            GetFunction(vtbl, ReconcileItem, RECONCILEITEMINDIRECT);
            GetFunction(vtbl, BeginReconciliation, BEGINRECONCILIATIONINDIRECT);
            GetFunction(vtbl, EndReconciliation, ENDRECONCILIATIONINDIRECT);

            GetFunction(vtbl, IsPathOnVolume, ISPATHONVOLUMEINDIRECT);
            GetFunction(vtbl, GetVolumeDescription, GETVOLUMEDESCRIPTIONINDIRECT);
            }
        else
            {
            bRet = FALSE;
            }

        ENTEREXCLUSIVE()
            {
            g_vtblEngine[0] = vtbl;
            }
        LEAVEEXCLUSIVE()
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Free the engine DLL if it is loaded
Returns: --
Cond:    --
*/
void PUBLIC Sync_ReleaseVTable()
    {
    HINSTANCE hinst;

    ENTEREXCLUSIVE()
        {
        hinst = g_vtblEngine[0].hinst;
        }
    LEAVEEXCLUSIVE()

    if (NULL != hinst)
        {
        DEBUG_CODE( TRACE_MSG(TF_GENERAL, TEXT("Freeing %s (cProcess = %d)"),
            (LPCTSTR)c_szEngineDLL, g_cProcesses); )

        // We must call FreeLibrary() on the sync engine even during a
        //  PROCESS_DETACH.  We may be getting detached from a process even
        //  though the process isn't being terminated.  If we don't unload
        //  the sync engine now, it won't be unloaded until the process is
        //  terminated.
        //
        FreeLibrary(hinst);

        ENTEREXCLUSIVE()
            {
            ZeroInit(&g_vtblEngine[0], sizeof(VTBLENGINE));
            }
        LEAVEEXCLUSIVE()
        }

#ifdef DEBUG

    ENTEREXCLUSIVE()
        {
        ASSERT(g_vtblEngine[0].hinst == NULL);
        }
    LEAVEEXCLUSIVE()

#endif
    }


/*----------------------------------------------------------
Purpose: Set the last sync error.
Returns: same twinresult
Cond:    --
*/
TWINRESULT PUBLIC Sync_SetLastError(
    TWINRESULT tr)
    {
    ENTEREXCLUSIVE()
        {
        ASSERTEXCLUSIVE();

        MySetTwinResult(tr);
        }
    LEAVEEXCLUSIVE()

    return tr;
    }


/*----------------------------------------------------------
Purpose: Get the last sync error.
Returns: twinresult
Cond:    --
*/
TWINRESULT PUBLIC Sync_GetLastError()
    {
    TWINRESULT tr;

    ENTEREXCLUSIVE()
        {
        ASSERTEXCLUSIVE();

        tr = MyGetTwinResult();
        }
    LEAVEEXCLUSIVE()

    return tr;
    }


/*----------------------------------------------------------
Purpose: Returns the number of recitems that would require 
         some reconciliation.

Returns: see above
Cond:    --
*/
ULONG PUBLIC CountActionItems(
    PRECLIST prl)
    {
    PRECITEM pri;
    ULONG ulc;

    for (pri = prl->priFirst, ulc = 0; pri; pri = pri->priNext)
        {
        if (IsFileRecItem(pri) &&
            RIU_SKIP != pri->dwUser &&
            RIA_NOTHING != pri->riaction &&
            RIA_BROKEN_MERGE != pri->riaction)
            {
            ulc++;
            pri->dwUser = RIU_SHOWSTATUS;
            }
        }


    return ulc;
    }


/*----------------------------------------------------------
Purpose: Displays appropriate error message on update errors
Returns: --
Cond:    --
*/
void PRIVATE HandleUpdateErrors(
    HWND hwndOwner,
    HRESULT hres,
    UINT uFlags)        // RF_*
    {
    // Is this an update while adding files?
    if (IsFlagSet(uFlags, RF_ONADD))
        {
        // Yes
#pragma data_seg(DATASEG_READONLY)  
        static SETbl const c_rgseUpdateOnAdd[] = {
                // The out of memory message should be handled by caller
                { E_TR_DEST_OPEN_FAILED,    IDS_ERR_ADD_READONLY,    MB_WARNING },
                { E_TR_DEST_WRITE_FAILED,   IDS_ERR_ADD_FULLDISK,    MB_WARNING },
                { E_TR_UNAVAILABLE_VOLUME,  IDS_ERR_ADD_UNAVAIL_VOL, MB_WARNING },
                { E_TR_SRC_OPEN_FAILED,     IDS_ERR_ADD_SOURCE_FILE, MB_WARNING },
                };
#pragma data_seg()

        SEMsgBox(hwndOwner, IDS_CAP_ADD, hres, c_rgseUpdateOnAdd, ARRAYSIZE(c_rgseUpdateOnAdd));
        }
    else
        {
        // No
#pragma data_seg(DATASEG_READONLY)  
        static SETbl const c_rgseUpdate[] = {
                { E_TR_OUT_OF_MEMORY,       IDS_OOM_UPDATE,         MB_ERROR },
                { E_TR_DEST_OPEN_FAILED,    IDS_ERR_READONLY,       MB_INFO },
                { E_TR_DEST_WRITE_FAILED,   IDS_ERR_FULLDISK,       MB_WARNING },
                { E_TR_UNAVAILABLE_VOLUME,  IDS_ERR_UPD_UNAVAIL_VOL,MB_WARNING },
                { E_TR_FILE_CHANGED,        IDS_ERR_FILE_CHANGED,   MB_INFO },
                { E_TR_SRC_OPEN_FAILED,     IDS_ERR_SOURCE_FILE,    MB_WARNING },
                };
#pragma data_seg()

        SEMsgBox(hwndOwner, IDS_CAP_UPDATE, hres, c_rgseUpdate, ARRAYSIZE(c_rgseUpdate));
        }
    }


typedef struct tagPROGPARAM
    {
    HWND hwndProgress;
    WORD wPosMax;
    WORD wPosBase;
    WORD wPosPrev;
    BOOL bSkip;
    } PROGPARAM, * PPROGPARAM;

/*----------------------------------------------------------
Purpose: Status procedure that is called during a single 
         ReconcileItem call.

Returns: varies
Cond:    --
*/
BOOL CALLBACK RecStatusProc(
    RECSTATUSPROCMSG msg,
    LPARAM lParam,
    LPARAM lParamUser)
    {
    BOOL bRet;
    PRECSTATUSUPDATE prsu = (PRECSTATUSUPDATE)lParam;
    PPROGPARAM pprogparam = (PPROGPARAM)lParamUser;
    HWND hwndProgress = pprogparam->hwndProgress;
    WORD wPos;

    bRet = !UpdBar_QueryAbort(hwndProgress);

    switch (msg)
        {
    case RS_BEGIN_COPY:
    case RS_DELTA_COPY:
    case RS_END_COPY:
    case RS_BEGIN_MERGE:
    case RS_DELTA_MERGE:
    case RS_END_MERGE:
#ifdef NEW_REC
    case RS_BEGIN_DELETE:
    case RS_DELTA_DELETE:
    case RS_END_DELETE:
#endif
        TRACE_MSG(TF_PROGRESS, TEXT("Reconcile progress = %lu of %lu"), prsu->ulProgress, prsu->ulScale);
        ASSERT(prsu->ulProgress <= prsu->ulScale);

        if (0 < prsu->ulScale && !pprogparam->bSkip)
            {
            wPos = LOWORD(LODWORD( (((__int64)pprogparam->wPosMax * prsu->ulProgress) / prsu->ulScale) ));

            TRACE_MSG(TF_PROGRESS, TEXT("Max wPos = %u,  new wPos = %u,  old wPos = %u"), 
                pprogparam->wPosMax, wPos, pprogparam->wPosPrev);

            if (wPos > pprogparam->wPosPrev && wPos < pprogparam->wPosMax)
                {
                WORD wPosReal = pprogparam->wPosBase + wPos;

                TRACE_MSG(TF_PROGRESS, TEXT("Setting real position = %u"), wPosReal);

                UpdBar_SetPos(hwndProgress, wPosReal);
                pprogparam->wPosPrev = wPos;
                }
            }
        break;

    default:
        ASSERT(0);
        break;
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Decides the description string while updating.  The
         string is something like "Copying from 'Foo' to 'Bar'"
         or "Merging files in 'Foo' and 'Bar'"

Returns: string in pszBuf

Cond:    --
*/
void PRIVATE DecideDescString(
    LPCTSTR pszBrfPath,
    PRECITEM pri,
    LPTSTR pszBuf,
    int cbBuf,
    LPTSTR pszPathBuf)
    {
    HRESULT hres;
    RA_ITEM * pitem;

    ASSERT(pszBrfPath);
    ASSERT(pri);
    ASSERT(pszBuf);

    hres = RAI_CreateFromRecItem(&pitem, pszBrfPath, pri);
    if (SUCCEEDED(hres))
        {
        UINT ids;
        LPTSTR pszMsg;
        LPCTSTR pszFrom;
        LPCTSTR pszTo;

        lstrcpy(pszPathBuf, pitem->siInside.pszDir);
        PathAppend(pszPathBuf, pitem->pszName);

        switch (pitem->uAction)
            {
        case RAIA_TOOUT:
            ids = IDS_UPDATE_Copy;
            pszFrom = PathFindFileName(pitem->siInside.pszDir);
            pszTo = PathFindFileName(pitem->siOutside.pszDir);
            break;

        case RAIA_TOIN:
            ids = IDS_UPDATE_Copy;
            pszFrom = PathFindFileName(pitem->siOutside.pszDir);
            pszTo = PathFindFileName(pitem->siInside.pszDir);
            break;

        case RAIA_MERGE:
            ids = IDS_UPDATE_Merge;
            // (Arbitrary)
            pszFrom = PathFindFileName(pitem->siInside.pszDir);
            pszTo = PathFindFileName(pitem->siOutside.pszDir);
            break;

        case RAIA_DELETEOUT:
            ids = IDS_UPDATE_Delete;
            pszFrom = PathFindFileName(pitem->siOutside.pszDir);
            pszTo = NULL;
            break;

        case RAIA_DELETEIN:
            ids = IDS_UPDATE_Delete;
            pszFrom = PathFindFileName(pitem->siInside.pszDir);
            pszTo = NULL;
            break;

        default:
            ASSERT(0);
            ids = 0;
            break;
            }

        if (ConstructMessage(&pszMsg, g_hinst, MAKEINTRESOURCE(ids), 
            pszFrom, pszTo))
            {
            lstrcpyn(pszBuf, pszMsg, cbBuf);
            GFree(pszMsg);
            }
        else
            *pszBuf = 0;
        }
    else
        *pszBuf = 0;
    }


/*----------------------------------------------------------
Purpose: Reconcile a given reclist

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC Sync_ReconcileRecList(
    PRECLIST prl,       // ptr to reclist
    LPCTSTR pszBrfPath,
    HWND hwndProgress,
    UINT uFlags)        // RF_*
    {
    HRESULT hres;

    if (prl)
        {
        HWND hwndOwner = GetParent(hwndProgress);
        HWND hwndStatusText = UpdBar_GetStatusWindow(hwndProgress);
        TCHAR szPath[MAX_PATH];
        TCHAR sz[MAXBUFLEN];
        TWINRESULT tr;
        PRECITEM pri;
        PROGPARAM progparam;
        ULONG ulcItems;
        WORD wDelta;

        DEBUG_CODE( Sync_DumpRecList(TR_SUCCESS, prl, TEXT("Updating")); )

        hres = NOERROR;     // assume success

        // Grab the mutex to delay any further calculation in any
        // Briefcase views' secondary threads until we're done 
        // processing here.
        Delay_Own();

        // Determine the range of the progress bar
        UpdBar_SetRange(hwndProgress, MAX_RANGE);

        ulcItems = CountActionItems(prl);
        if (0 < ulcItems)
            wDelta = (WORD)(MAX_RANGE / ulcItems);
        else
            wDelta = 0;

        progparam.hwndProgress = hwndProgress;

        // Start updating
        Sync_BeginRec(prl->hbr);

        ulcItems = 0;           
        for (pri = prl->priFirst; pri; pri = pri->priNext)
            {
            // Did the user explicitly skip this recitem or
            // is this a broken merge?
            if (RIU_SKIP == pri->dwUser ||
                RIA_BROKEN_MERGE == pri->riaction)
                {
                // Yes; don't call ReconcileItem
                continue;
                }

            // Is something going to be done to this recitem?
            if (RIU_SHOWSTATUS == pri->dwUser)
                {
                // Yes; update the name of the file we're updating
                UpdBar_SetName(hwndProgress, pri->pcszName);
                DecideDescString(pszBrfPath, pri, sz, ARRAYSIZE(sz), szPath);
                UpdBar_SetDescription(hwndProgress, sz);

                ASSERT(0 < wDelta);
                progparam.wPosBase = (WORD)(wDelta * ulcItems);
                progparam.wPosMax = wDelta;
                progparam.wPosPrev = 0;
                progparam.bSkip = FALSE;
                }
            else
                {
                progparam.bSkip = TRUE;
                }

            // Call ReconcileItem even for nops, so the recnode states
            // will be updated by the engine.
            tr = Sync_ReconcileItem(pri, RecStatusProc, (LPARAM)&progparam, 
                RI_FL_FEEDBACK_WINDOW_VALID, hwndProgress, hwndStatusText);
            if (TR_SUCCESS != tr &&
                IsFileRecItem(pri))     // ignore folder recitem errors
                {
                // On some conditions, stop updating completely
                hres = HRESULT_FROM_TR(tr);

                switch (hres)
                    {
                case E_TR_OUT_OF_MEMORY:
                case E_TR_RH_LOAD_FAILED: {
                    // Couldn't load the merge handler.  Tell the user but
                    // continue on...
                    int id = MsgBox(hwndOwner, 
                                MAKEINTRESOURCE(IDS_ERR_NO_MERGE_HANDLER), 
                                MAKEINTRESOURCE(IDS_CAP_UPDATE),
                                NULL,GUID_NULL,NULL,
                                MB_WARNING | MB_OKCANCEL,
                                PathGetDisplayName(szPath, sz));

                    if (IDOK == id)
                        break;      // continue updating other files
                    }

                    goto StopUpdating;

                case E_TR_DELETED_TWIN:
                    // Allow the updating to continue.
                    break;

                case E_TR_DEST_OPEN_FAILED:
                case E_TR_FILE_CHANGED:
                    if (IsFlagClear(uFlags, RF_ONADD))
                        {
                        // Allow the updating to continue.  Remember the
                        // latest error for the end.
                        break;
                        }
                    // Fall thru
                    //   |   |
                    //   v   v

                default:
                    goto StopUpdating;
                    }
                }

            // Was something done to this recitem?
            if (RIU_SHOWSTATUS == pri->dwUser)
                {
                // Yes; update the progress bar
                UpdBar_SetPos(hwndProgress, (WORD)(wDelta * ++ulcItems));
                }

            // Check if the Cancel button was pressed
            if (UpdBar_QueryAbort(hwndProgress))
                {
                hres = E_ABORT;
                break;
                }
            }

StopUpdating:
        if (FAILED(hres))
            {
            Sync_DumpRecItem(tr, pri, NULL);
            HandleUpdateErrors(hwndOwner, hres, uFlags);

            if (IsFlagSet(uFlags, RF_ONADD))
                {
                // Hack: since the caller also handles some error messages,
                // return a generic failure code to prevent repeated
                // error messages.
                hres = E_FAIL;
                }
            }
        // Were there any items at all?
        else if (0 == prl->ulcItems)
            {
            // No
            MsgBox(hwndOwner, MAKEINTRESOURCE(IDS_MSG_NoMatchingFiles), 
                MAKEINTRESOURCE(IDS_CAP_UPDATE),NULL,GUID_NULL, NULL, MB_INFO);
            }

        Sync_EndRec(prl->hbr);

        Delay_Release();
        }
    else
        hres = E_INVALIDARG;

    return hres;
    }


/*----------------------------------------------------------
Purpose: Status procedure that is called during a single 
         ReconcileItem call.

Returns: varies
Cond:    --
*/
BOOL CALLBACK CreateRecListProc(
    CREATERECLISTPROCMSG msg,
    LPARAM lParam,
    LPARAM lParamUser)
    {
    return !AbortEvt_Query((PABORTEVT)lParamUser);
    }


/*----------------------------------------------------------
Purpose: Creates a reclist and optionally shows a progress
         bar during the creation.

Returns: standard result
Cond:    --
*/
HRESULT PUBLIC Sync_CreateRecListEx(
    HTWINLIST htl,
    PABORTEVT pabortevt,
    PRECLIST * pprl)
    {
    TWINRESULT tr;

    ASSERT(pprl);

    tr = Sync_CreateRecList(htl, CreateRecListProc, (LPARAM)pabortevt, pprl);
    return HRESULT_FROM_TR(tr);
    }


/*----------------------------------------------------------
Purpose: Return true if the file or folder is a twin.

         There are some cases when this function cannot successfully
         determine this unless the caller first tells it explicitly 
         whether the object is a file or folder.  Otherwise this
         function will attempt to determine this on its own.

Returns: S_OK if it is a twin
         S_FALSE if it is not
         any other is an error

Cond:    --
*/
HRESULT PUBLIC Sync_IsTwin(
    HBRFCASE hbrfcase,
    LPCTSTR pszPath,
    UINT uFlags)        // SF_* flags
    {
    HRESULT hres;
    TWINRESULT tr;

    ASSERT(pszPath);

    // The caller may already know whether this is a twin or not.
    // Remind him.
    if (IsFlagSet(uFlags, SF_ISTWIN))
        return S_OK;
    else if (IsFlagSet(uFlags, SF_ISNOTTWIN))
        return S_FALSE;

    // Is this a folder?
    if (IsFlagSet(uFlags, SF_ISFOLDER) ||
        PathIsDirectory(pszPath))
        {
        // Yes; is it a twin?
        BOOL bRet;
    
        tr = Sync_IsFolder(hbrfcase, pszPath, &bRet);
        if (TR_SUCCESS == tr)
            {
            // Yes/no
            hres = bRet ? S_OK : S_FALSE;
            }
        else
            {
            // Error
            hres = HRESULT_FROM_TR(tr);
            }
        }
    else
        {
        // No
        HOBJECTTWIN hot;
        TCHAR szDir[MAX_PATH];

        lstrcpy(szDir, pszPath);
        PathRemoveFileSpec(szDir);
        tr = Sync_GetObject(hbrfcase, szDir, PathFindFileName(pszPath), &hot);
        if (TR_SUCCESS == tr)
            {
            // Is it a twin?
            if (NULL != hot)
                {
                // Yes
                Sync_ReleaseTwin(hot);
                hres = S_OK;
                }
            else
                {
                // No; (no need to release a null handle)
                hres = S_FALSE;
                }
            }
        else
            {
            // Error
            hres = HRESULT_FROM_TR(tr);
            }
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Create a reclist with everything in it.

Returns: standard result

Cond:    Caller must destroy the reclist
*/
HRESULT PUBLIC Sync_CreateCompleteRecList(
    HBRFCASE hbrf,
    PABORTEVT pabortevt,
    PRECLIST * pprl)
    {
    HRESULT hres = E_OUTOFMEMORY;
    HTWINLIST htl;

    ASSERT(pprl);

    *pprl = NULL;

    if (TR_SUCCESS == Sync_CreateTwinList(hbrf, &htl))
        {
        Sync_AddAllToTwinList(htl);

        hres = Sync_CreateRecListEx(htl, pabortevt, pprl);
        Sync_DestroyTwinList(htl);
        }

    return hres;
    }


/*----------------------------------------------------------
Purpose: Add a twin to the twinlist given the pathname.  If the
         pathname is not a twin, we don't add it.

Returns: TRUE on success, even when this isn't a twin

Cond:    Caller must destroy the folder list if lplpftl is not NULL
*/
BOOL PUBLIC Sync_AddPathToTwinList(
    HBRFCASE hbrf,
    HTWINLIST htl,
    LPCTSTR lpcszPath,               // Path
    PFOLDERTWINLIST  * lplpftl)  // May be NULL
    {
    BOOL bRet = FALSE;

    ASSERT(lpcszPath);
    ASSERT(htl);

    if (lplpftl)
        *lplpftl = NULL;

    if (lpcszPath)
        {
        if (PathIsDirectory(lpcszPath))
            {
            BOOL fIsTwin = FALSE;
            PFOLDERTWINLIST lpftl;

            // We only want to return false if we couldn't mark something
            //  that should have been marked.  If this isn't a twin,
            //  we still succeed.

            bRet = TRUE;

            Sync_IsFolder(hbrf, lpcszPath, &fIsTwin);
            if (fIsTwin)        // Is this actually twinned?
                {
                // This is a folder twin.  Add to reclist "the folder way".
                //
                if (Sync_CreateFolderList(hbrf, lpcszPath, &lpftl) != TR_SUCCESS)
                    bRet = FALSE;
                else
                    {
                    PCFOLDERTWIN lpcfolder;

                    ASSERT(lpftl->pcftFirst);

                    lpcfolder = lpftl->pcftFirst;
                    while (lpcfolder)
                        {
                        Sync_AddToTwinList(htl, lpcfolder->hftOther);

                        lpcfolder = lpcfolder->pcftNext;
                        }

                    if (lplpftl)
                        *lplpftl = lpftl;
                    else
                        Sync_DestroyFolderList(lpftl);
                    }
                }
            }
        else
            {
            HOBJECTTWIN hot = NULL;
            TCHAR szDir[MAX_PATH];

            // Add the twins to the reclist "the object way"
            //
            lstrcpy(szDir, lpcszPath);
            PathRemoveFileSpec(szDir);
            Sync_GetObject(hbrf, szDir, PathFindFileName(lpcszPath), &hot);

            if (hot)                // Is this actually a twin?
                {
                // yep
                Sync_AddToTwinList(htl, hot);
                Sync_ReleaseTwin(hot);
                }
            if (lplpftl)
                *lplpftl = NULL;
            bRet = TRUE;
            }
        }

    return bRet;
    }


/*----------------------------------------------------------
Purpose: Asks the user to confirm splitting one or more files.

Returns: IDYES or IDNO
Cond:    --
*/
int PRIVATE ConfirmSplit(
    HWND hwndOwner,
    LPCTSTR pszPath,
    UINT cFiles)
    {
    int idRet;

    ASSERT(pszPath);
    ASSERT(1 <= cFiles);

    // Multiple files?
    if (1 < cFiles)
        {
        // Yes
        idRet = MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(IDS_MSG_ConfirmMultiSplit), 
                        MAKEINTRESOURCE(IDS_CAP_ConfirmMultiSplit), 
                        NULL,GUID_NULL,LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_MULT)), 
                        MB_QUESTION,
                        cFiles);
        }
    else
        {
        // No
        UINT ids;
        UINT idi;
        TCHAR szName[MAX_PATH];

        if (PathIsDirectory(pszPath))
            {
            ids = IDS_MSG_ConfirmFolderSplit;
            idi = IDI_SPLIT_FOLDER;
            }
        else
            {
            ids = IDS_MSG_ConfirmFileSplit;
            idi = IDI_SPLIT_FILE;
            }

        idRet = MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(ids), 
                        MAKEINTRESOURCE(IDS_CAP_ConfirmSplit), 
                        NULL,GUID_NULL,LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                        MB_QUESTION,
                        PathGetDisplayName(pszPath, szName));
        }
    return idRet;
    }


/*----------------------------------------------------------
Purpose: Splits a path from its sync copy.  Private function
         called by Sync_Split.

Returns: standard result
         S_OK if it is split

Cond:    --
*/
HRESULT PRIVATE SplitPath(
    HBRFCASE hbrf,
    LPCTSTR pszPath,
    HWND hwndOwner,
    UINT uFlags)            // SF_* flags
    {
    HRESULT hres;
    TWINRESULT tr;
    TCHAR sz[MAX_PATH];

    if (pszPath)
        {
        // Is the object a folder?
        if (IsFlagSet(uFlags, SF_ISFOLDER) || 
            PathIsDirectory(pszPath))
            {
            // Yup
            BOOL bIsTwin;

            if (IsFlagSet(uFlags, SF_ISTWIN))           // Optimization
                {
                tr = TR_SUCCESS;
                bIsTwin = TRUE;
                }
            else if (IsFlagSet(uFlags, SF_ISNOTTWIN))   // Optimization
                {
                tr = TR_SUCCESS;
                bIsTwin = FALSE;
                }
            else
                {
                tr = Sync_IsFolder(hbrf, pszPath, &bIsTwin);
                }

            // Is this folder a twin?
            if (TR_SUCCESS == tr)
                {
                if (bIsTwin)
                    {
                    // Yes; delete all the twin handles associated with it
                    PFOLDERTWINLIST lpftl;

                    tr = Sync_CreateFolderList(hbrf, pszPath, &lpftl);
                    if (TR_SUCCESS == tr)
                        {
                        PCFOLDERTWIN lpcfolder;

                        ASSERT(lpftl);

                        for (lpcfolder = lpftl->pcftFirst; lpcfolder; 
                            lpcfolder = lpcfolder->pcftNext)
                            {
                            Sync_DeleteTwin(lpcfolder->hftOther);
                            }

                        Sync_DestroyFolderList(lpftl);

                        if (IsFlagClear(uFlags, SF_QUIET))
                            {
                            // Send a notification so it is redrawn.
                            PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
                            }
                        hres = NOERROR;
                        }
                    }
                else if (IsFlagClear(uFlags, SF_QUIET))
                    {
                    // No
                    MsgBox(hwndOwner, 
                            MAKEINTRESOURCE(IDS_MSG_FolderAlreadyOrphan),
                            MAKEINTRESOURCE(IDS_CAP_Split), 
                            NULL,GUID_NULL,LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FOLDER)), 
                            MB_INFO,
                            PathGetDisplayName(pszPath, sz));

                    hres = S_FALSE;
                    }
                }
            }
        else
            {
            // No; it is a file
            HOBJECTTWIN hot;
            ULONG ulc;

            lstrcpy(sz, pszPath);
            PathRemoveFileSpec(sz);

            // Is this file a twin?
            // (We need the twin handle below, so we cannot take 
            // advantage of SF_ISTWIN or SF_ISNOTTWIN.)
            tr = Sync_GetObject(hbrf, sz, PathFindFileName(pszPath), &hot);

            if (TR_SUCCESS == tr)
                {
                if (hot)
                    {
                    // Yes; is this inside a folder twin?
                    // (If we remove this check, the engine needs to be able
                    // to exclude specific files from a folder twin.)
                    tr = Sync_CountSourceFolders(hot, &ulc);
                    if (TR_SUCCESS == tr)
                        {
                        if (0 < ulc)
                            {
                            // Yes; can't do it
                            if (IsFlagClear(uFlags, SF_QUIET))
                                {
                                UINT rgids[2] = { IDS_ERR_1_CantSplit, IDS_ERR_2_CantSplit };
                                LPTSTR psz;

                                if (FmtString(&psz, IDS_ERR_F_CantSplit, rgids, ARRAYSIZE(rgids)))
                                    {
                                    // This object twin belongs to a folder twin.  We can't
                                    //  allow this action.
                                    MsgBox(hwndOwner, psz, MAKEINTRESOURCE(IDS_CAP_STATUS), 
                                       NULL,GUID_NULL, LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FILE)), MB_ERROR);
                                    GFree(psz);
                                    }
                                }
                            hres = S_FALSE;
                            }
                        else
                            {
                            // No; delete the twin
                            Sync_DeleteTwin(hot);
            
                            if (IsFlagClear(uFlags, SF_QUIET))
                                {
                                // Send a notification so it's redrawn immediately.
                                PathNotifyShell(pszPath, NSE_UPDATEITEM, FALSE);
                                }
                            hres = NOERROR;
                            }
                        }

                    Sync_ReleaseTwin(hot);
                    }
                else if (IsFlagClear(uFlags, SF_QUIET))
                    {
                    // No
                    MsgBox(hwndOwner, 
                            MAKEINTRESOURCE(IDS_MSG_FileAlreadyOrphan), 
                            MAKEINTRESOURCE(IDS_CAP_Split), 
                            NULL,GUID_NULL,LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SPLIT_FILE)), 
                            MB_INFO,
                            PathGetDisplayName(pszPath, sz));

                    hres = S_FALSE;
                    }
                }
            }

        if (TR_SUCCESS != tr)
            hres = HRESULT_FROM_TR(tr);
        }
    else
        hres = S_FALSE;

    return hres;
    }


/*----------------------------------------------------------
Purpose: Deletes a series of twins from the engine database.
         The user is optionally asked to confirm the action.

         If a file is an orphan, the user is optionally 
         notified.  The user is also optionally notified
         of any errors.

Returns: standard result
         S_OK if anything was deleted

Cond:    --
*/
HRESULT PUBLIC Sync_Split(
    HBRFCASE hbrf,
    LPCTSTR pszList,
    UINT cFiles,
    HWND hwndOwner,
    UINT uFlags)
    {
    HRESULT hres;
    UINT id;
    TCHAR szCanon[MAX_PATH];
    TCHAR sz[MAX_PATH];

    ASSERT(pszList);
    ASSERT(0 < cFiles);

    // Special precondition: is it a single file?
    if (1 == cFiles)
        {
        // Yes; is it a twin?
        BrfPathCanonicalize(pszList, szCanon);
        hres = Sync_IsTwin(hbrf, szCanon, uFlags);
        if (S_FALSE == hres)
            {
            // No; tell the user.  Don't bother confirming the action first.
            if (IsFlagClear(uFlags, SF_QUIET))
                {
                UINT ids;
                UINT idi;

                if (IsFlagSet(uFlags, SF_ISFOLDER) || 
                    PathIsDirectory(szCanon))
                    {
                    ids = IDS_MSG_FolderAlreadyOrphan;
                    idi = IDI_SPLIT_FOLDER;
                    }
                else
                    {
                    ids = IDS_MSG_FileAlreadyOrphan;
                    idi = IDI_SPLIT_FILE;
                    }

                MsgBox(hwndOwner, 
                        MAKEINTRESOURCE(ids), 
                        MAKEINTRESOURCE(IDS_CAP_Split), 
                        NULL,GUID_NULL,LoadIcon(g_hinst, MAKEINTRESOURCE(idi)), 
                        MB_INFO,
                        PathGetDisplayName(szCanon, sz));
                }
            }
        else if (S_OK == hres)
            {
            // Yes
            if (IsFlagClear(uFlags, SF_NOCONFIRM))
                id = ConfirmSplit(hwndOwner, szCanon, 1);
            else
                id = IDYES;

            if (IDYES == id)
                {
                hres = SplitPath(hbrf, szCanon, hwndOwner, uFlags);
                if (IsFlagClear(uFlags, SF_QUIET))
                    {
                    SHChangeNotifyHandleEvents();
                    }
                }
            else
                hres = S_FALSE;
            }
        }

    // Multiselection: ask the user first
    else
        {
        if (IsFlagClear(uFlags, SF_NOCONFIRM))
            id = ConfirmSplit(hwndOwner, pszList, cFiles);
        else
            id = IDYES;

        if (IDYES == id)
            {
            // Remove all the files from the engine database
            LPCTSTR psz;
            UINT i;
            HRESULT hresT;

            hres = S_FALSE;     // assume success but nothing done

            for (i = 0, psz = pszList; i < cFiles; i++)
                {
                // Get dragged file/folder name
                //
                BrfPathCanonicalize(psz, szCanon);

                hresT = SplitPath(hbrf, szCanon, hwndOwner, uFlags);
                if (S_OK == hresT)
                    hres = S_OK;  // (Don't set back to FALSE once it is TRUE)
                else if (FAILED(hresT))
                    {
                    hres = hresT;
                    break;
                    }

                DataObj_NextFile(psz);      // Set psz to next file in list
                }

            if (IsFlagClear(uFlags, SF_QUIET))
                {
                SHChangeNotifyHandleEvents();    // (Do this after the loop)
                }
            }
        else
            hres = S_FALSE;
        }
    return hres;
    }


/*----------------------------------------------------------
Purpose: Change the recitem action and the two recnodes of
         importance to the specified action.
Returns: --
Cond:    --
*/
void PUBLIC Sync_ChangeRecItemAction(
    PRECITEM pri,
    LPCTSTR pszBrfPath,
    LPCTSTR pszInsideDir,     // Folder inside the briefcase
    UINT riaction)           // One of RAIA_* values to change to
    {
    HRESULT hres;
    PRECNODE prnInside;
    PRECNODE prnOutside;

    // Determine which node is inside the briefcase and which one is
    //  outside.
    //
    hres = Sync_GetNodePair(pri, pszBrfPath, pszInsideDir, &prnInside, &prnOutside);
    if (SUCCEEDED(hres))
        {
        ASSERT(prnInside);
        ASSERT(prnOutside);

        switch(riaction)
            {
        case RAIA_TOIN:
            pri->dwUser = RIU_CHANGED;
            pri->riaction = RIA_COPY;
            prnInside->rnaction = RNA_COPY_TO_ME;
            prnOutside->rnaction = RNA_COPY_FROM_ME;
            break;

        case RAIA_TOOUT:
            pri->dwUser = RIU_CHANGED;
            pri->riaction = RIA_COPY;
            prnInside->rnaction = RNA_COPY_FROM_ME;
            prnOutside->rnaction = RNA_COPY_TO_ME;
            break;

        case RAIA_SKIP:
            pri->dwUser = RIU_SKIP;
            break;

        case RAIA_MERGE:
            pri->dwUser = RIU_CHANGED;
            pri->riaction = RIA_MERGE;
            prnInside->rnaction = RNA_MERGE_ME;
            prnOutside->rnaction = RNA_MERGE_ME;
            break;

#ifdef NEW_REC
        case RAIA_DONTDELETE:
            if (RNA_DELETE_ME == prnInside->rnaction)
                {
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_NOTHING;
                prnInside->rnaction = RNA_NOTHING;
                }
            else if (RNA_DELETE_ME == prnOutside->rnaction)
                {
                pri->dwUser = RIU_CHANGED;
                pri->riaction = RIA_NOTHING;
                prnOutside->rnaction = RNA_NOTHING;
                }
            break;
        
        case RAIA_DELETEIN:
            pri->dwUser = RIU_CHANGED;
            pri->riaction = RIA_DELETE;
            prnInside->rnaction = RNA_DELETE_ME;
            prnOutside->rnaction = RNA_NOTHING;
            break;

        case RAIA_DELETEOUT:
            pri->dwUser = RIU_CHANGED;
            pri->riaction = RIA_DELETE;
            prnInside->rnaction = RNA_NOTHING;
            prnOutside->rnaction = RNA_DELETE_ME;
            break;
#endif

        default:
            // (The other values don't make sense here)
            ASSERT(0);
            break;
            }
        }
    }


/////////////////////////////////////////////////////  PRIVATE FUNCTIONS


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dumps the contents of the given twin structure to
         to debug out
Returns: --
Cond:    --
*/
void PUBLIC Sync_FnDump(
    LPVOID lpvBuf,
    UINT cbBuf)
    {
    int bDump;

    #define szDumpTwin  TEXT("Dump TWIN: ")
    #define szDumpSp    TEXT("           ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_CREATETWIN);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    if (cbBuf == sizeof(NEWOBJECTTWIN))
        {
        PNEWOBJECTTWIN lpnot = (PNEWOBJECTTWIN)lpvBuf;

        TRACE_MSG(TF_ALWAYS, TEXT("%s.Folder1 = {%s}\r\n%s.Folder2 = {%s}\r\n%s.Name = {%s}\r\n"),
            (LPTSTR)szDumpTwin, lpnot->pcszFolder1,
            (LPTSTR)szDumpSp, lpnot->pcszFolder2,
            (LPTSTR)szDumpSp, lpnot->pcszName);
        }
    else if (cbBuf == sizeof(NEWFOLDERTWIN))
        {
        PNEWFOLDERTWIN lpnft = (PNEWFOLDERTWIN)lpvBuf;

        TRACE_MSG(TF_ALWAYS, TEXT("%s.Folder1 = {%s}\r\n%s.Folder2 = {%s}\r\n%s.Name = {%s}\r\n%s.dwFlags = 0x%04lx\r\n"),
            (LPTSTR)szDumpTwin, lpnft->pcszFolder1,
            (LPTSTR)szDumpSp, lpnft->pcszFolder2,
            (LPTSTR)szDumpSp, lpnft->pcszName,
            (LPTSTR)szDumpSp, (DWORD)lpnft->dwFlags);
        }
    }


/*----------------------------------------------------------
Purpose: Return English form of RIA_ flags
Returns:
Cond:    --
*/
LPTSTR PRIVATE LpszFromItemAction(
    ULONG riaction)
    {
    switch (riaction)
        {
    DEBUG_CASE_STRING( RIA_NOTHING );
    DEBUG_CASE_STRING( RIA_COPY );
    DEBUG_CASE_STRING( RIA_MERGE );
    DEBUG_CASE_STRING( RIA_BROKEN_MERGE );

#ifdef NEW_REC
    DEBUG_CASE_STRING( RIA_DELETE );
#endif

    default:        return TEXT("RIA unknown");
        }
    }


/*----------------------------------------------------------
Purpose: Return English form of RNA_ flags
Returns:
Cond:    --
*/
LPTSTR PRIVATE LpszFromNodeAction(
    ULONG rnaction)
    {
    switch (rnaction)
        {
    DEBUG_CASE_STRING( RNA_NOTHING );
    DEBUG_CASE_STRING( RNA_COPY_TO_ME );
    DEBUG_CASE_STRING( RNA_COPY_FROM_ME );
    DEBUG_CASE_STRING( RNA_MERGE_ME );

#ifdef NEW_REC
    DEBUG_CASE_STRING( RNA_DELETE_ME );
#endif

    default:    return TEXT("RNA unknown");
        }
    }


/*----------------------------------------------------------
Purpose: Return English form of RNS_ flags
Returns:
Cond:    --
*/
LPTSTR PRIVATE LpszFromNodeState(
    ULONG rnstate)
    {
    switch (rnstate)
        {
#ifdef NEW_REC
    DEBUG_CASE_STRING( RNS_NEVER_RECONCILED );
#endif

    DEBUG_CASE_STRING( RNS_UNAVAILABLE );
    DEBUG_CASE_STRING( RNS_DOES_NOT_EXIST );
    DEBUG_CASE_STRING( RNS_DELETED );
    DEBUG_CASE_STRING( RNS_NOT_RECONCILED );
    DEBUG_CASE_STRING( RNS_UP_TO_DATE );
    DEBUG_CASE_STRING( RNS_CHANGED );

    default: return TEXT("RNS unknown");
        }
    }


/*----------------------------------------------------------
Purpose: Dump the RECNODE
Returns:
Cond:    --
*/
void PUBLIC Sync_DumpRecNode(
    TWINRESULT tr,
    PRECNODE lprn)
    {
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    #define szDumpLabel     TEXT("\tDump RECNODE: ")
    #define szDumpMargin    TEXT("\t              ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECNODE);
        }
    LEAVEEXCLUSIVE()

    if (!bDump || lprn == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    wsprintf(szBuf, TEXT("%s.Folder = {%s}\r\n"), (LPTSTR)szDumpLabel, lprn->pcszFolder);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.hObjectTwin = %lx\r\n"), (LPTSTR)szDumpMargin, lprn->hObjectTwin);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.rnstate = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromNodeState(lprn->rnstate));
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.rnaction = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromNodeAction(lprn->rnaction));
    OutputDebugString(szBuf);
    OutputDebugString(TEXT("\r\n"));

    #undef szDumpLabel
    #undef szDumpMargin
    }


/*----------------------------------------------------------
Purpose: Dump the RECITEM
Returns:
Cond:    --
*/
void PUBLIC Sync_DumpRecItem(
    TWINRESULT tr,
    PRECITEM lpri,
    LPCTSTR pszMsg)
    {
    BOOL bDump;
    PRECNODE lprn;
    TCHAR szBuf[MAXMSGLEN];

    #define szDumpLabel     TEXT("Dump RECITEM: ")
    #define szDumpMargin    TEXT("              ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECITEM);
        }
    LEAVEEXCLUSIVE()

    if (!bDump || lpri == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    wsprintf(szBuf, TEXT("tr = %s\r\n"), (LPTSTR)SzFromTR(tr));
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.Name = {%s}\r\n"), (LPTSTR)szDumpLabel, lpri->pcszName);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.hTwinFamily = %lx\r\n"), (LPTSTR)szDumpMargin, lpri->hTwinFamily);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.ulcNodes = %lu\r\n"), (LPTSTR)szDumpMargin, lpri->ulcNodes);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.riaction = %s\r\n"), (LPTSTR)szDumpMargin, LpszFromItemAction(lpri->riaction));
    OutputDebugString(szBuf);

    lprn = lpri->prnFirst;
    while (lprn)
        {
        Sync_DumpRecNode(tr, lprn);
        lprn = lprn->prnNext;
        }

    #undef szDumpLabel
    #undef szDumpMargin
    }


/*----------------------------------------------------------
Purpose: Dump the RECLIST
Returns:
Cond:    --
*/
void PUBLIC Sync_DumpRecList(
    TWINRESULT tr,
    PRECLIST lprl,
    LPCTSTR pszMsg)
    {
    BOOL bDump;
    PRECITEM lpri;
    TCHAR szBuf[MAXMSGLEN];

    #define szDumpLabel   TEXT("Dump RECLIST: ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_RECLIST);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    // Note we only dump on TR_SUCCESS
    //
    wsprintf(szBuf, TEXT("tr = %s\r\n"), (LPTSTR)SzFromTR(tr));
    OutputDebugString(szBuf);

    if (lprl == NULL || tr == TR_OUT_OF_MEMORY || tr == TR_INVALID_PARAMETER)
        return ;

    wsprintf(szBuf, TEXT("%s.ulcItems = %lu\r\n"), (LPTSTR)szDumpLabel, lprl->ulcItems);
    OutputDebugString(szBuf);

    lpri = lprl->priFirst;
    while (lpri)
        {
        Sync_DumpRecItem(TR_SUCCESS, lpri, NULL);
        lpri = lpri->priNext;
        }

    #undef szDumpLabel
    }


/*----------------------------------------------------------
Purpose: Dump the FOLDERTWIN
Returns: --
Cond:    --
*/
void PUBLIC Sync_DumpFolderTwin(
    PCFOLDERTWIN pft)
    {
    BOOL bDump;
    TCHAR szBuf[MAXMSGLEN];

    #define szDumpLabel      TEXT("Dump FOLDERTWIN: ")
    #define szDumpMargin     TEXT("                 ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_FOLDERTWIN);
        }
    LEAVEEXCLUSIVE()

    if (!bDump || pft == NULL)
        return ;

    wsprintf(szBuf, TEXT("%s.Name = {%s}\r\n"), (LPTSTR)szDumpLabel, pft->pcszName);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.pszSrcFolder = {%s}\r\n"), (LPTSTR)szDumpMargin, pft->pcszSrcFolder);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.pszOtherFolder = {%s}\r\n"), (LPTSTR)szDumpMargin, pft->pcszOtherFolder);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.dwFlags = %lx\r\n"), (LPTSTR)szDumpMargin, pft->dwFlags);
    OutputDebugString(szBuf);

    wsprintf(szBuf, TEXT("%s.dwUser = %lx\r\n"), (LPTSTR)szDumpMargin, pft->dwUser);
    OutputDebugString(szBuf);

    #undef szDumpLabel
    #undef szDumpMargin
    }


/*----------------------------------------------------------
Purpose: Dump the FOLDERTWINLIST
Returns: --
Cond:    --
*/
void PUBLIC Sync_DumpFolderTwinList(
    PFOLDERTWINLIST pftl,
    LPCTSTR pszMsg)
    {
    BOOL bDump;
    PCFOLDERTWIN pft;
    TCHAR szBuf[MAXMSGLEN];

    #define szDumpLabel   TEXT("Dump FOLDERTWINLIST: ")

    ENTEREXCLUSIVE()
        {
        bDump = IsFlagSet(g_uDumpFlags, DF_FOLDERTWIN);
        }
    LEAVEEXCLUSIVE()

    if (!bDump)
        return ;

    if (pszMsg)
        TRACE_MSG(TF_ALWAYS, pszMsg);

    if (pftl == NULL)
        return ;

    wsprintf(szBuf, TEXT("%s.ulcItems = %lu\r\n"), (LPTSTR)szDumpLabel, pftl->ulcItems);
    OutputDebugString(szBuf);

    for (pft = pftl->pcftFirst; pft; pft = pft->pcftNext)
        {
        Sync_DumpFolderTwin(pft);
        }

    #undef szDumpLabel
    }



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\twin.h ===
//
// twin.h: Declares data, defines and struct types for twin handling
//          module.
//
//

#ifndef __TWIN_H__
#define __TWIN_H__


/////////////////////////////////////////////////////  INCLUDES

/////////////////////////////////////////////////////  DEFINES

#define CMP_RECNODES        1L
#define CMP_FOLDERTWINS     2L

#define OBJECT_TWIN_ATTRIBUTES   (FILE_ATTRIBUTE_NORMAL | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY)

/////////////////////////////////////////////////////  MACROS

#ifdef DEBUG

#define Sync_Dump(lpvBuf, type)     Sync_FnDump((LPVOID)lpvBuf, sizeof(type))

extern CONST LPCTSTR rgcpcszTwinResult[];
#define SzFromTR(tr)                (rgcpcszTwinResult[(tr)])

#else

#define Sync_Dump(lpvBuf, type)
#define Sync_DumpRecItem(tr, lpri, pszMsg)
#define Sync_DumpRecNode(tr, lprn)
#define Sync_DumpRecList(tr, lprl, pszMsg)
#define SzFromTR(tr)                (tr)

#endif

// Global v-table to the engine
//

typedef struct 
    {
    HINSTANCE   hinst;

    OPENBRIEFCASEINDIRECT           OpenBriefcase;
    SAVEBRIEFCASEINDIRECT           SaveBriefcase;
    CLOSEBRIEFCASEINDIRECT          CloseBriefcase;
    DELETEBRIEFCASEINDIRECT         DeleteBriefcase;
    GETOPENBRIEFCASEINFOINDIRECT    GetOpenBriefcaseInfo;
    CLEARBRIEFCASECACHEINDIRECT     ClearBriefcaseCache;
    FINDFIRSTBRIEFCASEINDIRECT      FindFirstBriefcase;
    FINDNEXTBRIEFCASEINDIRECT       FindNextBriefcase;
    FINDBRIEFCASECLOSEINDIRECT      FindBriefcaseClose;

    ADDOBJECTTWININDIRECT           AddObjectTwin;
    ADDFOLDERTWININDIRECT           AddFolderTwin;
    RELEASETWINHANDLEINDIRECT       ReleaseTwinHandle;
    DELETETWININDIRECT              DeleteTwin;
    GETOBJECTTWINHANDLEINDIRECT     GetObjectTwinHandle;
    ISFOLDERTWININDIRECT            IsFolderTwin;
    CREATEFOLDERTWINLISTINDIRECT    CreateFolderTwinList;
    DESTROYFOLDERTWINLISTINDIRECT   DestroyFolderTwinList;
    GETFOLDERTWINSTATUSINDIRECT     GetFolderTwinStatus;
    ISORPHANOBJECTTWININDIRECT      IsOrphanObjectTwin;
    COUNTSOURCEFOLDERTWINSINDIRECT  CountSourceFolderTwins;
    ANYTWINSINDIRECT                AnyTwins;

    CREATETWINLISTINDIRECT          CreateTwinList;
    DESTROYTWINLISTINDIRECT         DestroyTwinList;
    ADDTWINTOTWINLISTINDIRECT       AddTwinToTwinList;
    ADDALLTWINSTOTWINLISTINDIRECT   AddAllTwinsToTwinList;
    REMOVETWINFROMTWINLISTINDIRECT  RemoveTwinFromTwinList;
    REMOVEALLTWINSFROMTWINLISTINDIRECT RemoveAllTwinsFromTwinList;

    CREATERECLISTINDIRECT           CreateRecList;
    DESTROYRECLISTINDIRECT          DestroyRecList;
    RECONCILEITEMINDIRECT           ReconcileItem;
    BEGINRECONCILIATIONINDIRECT     BeginReconciliation;
    ENDRECONCILIATIONINDIRECT       EndReconciliation;

    ISPATHONVOLUMEINDIRECT          IsPathOnVolume;
    GETVOLUMEDESCRIPTIONINDIRECT    GetVolumeDescription;

    } VTBLENGINE, * PVTBLENGINE;


// Function wrappers
//
//      TWINRESULT Sync_Verify(fn, args)
//          Returns the twinresult of the function that is called
//
#ifdef DEBUG
#define Sync_Verify(fn, args)  \
    (Sync_SetLastError(g_vtblEngine[0].##fn args), VERIFYSZ2(TR_SUCCESS == Sync_GetLastError(), TEXT("Assert  ") TEXT(#fn) TEXT(": %s (LastError=%ldL)"), SzFromTR(Sync_GetLastError()), GetLastError()), Sync_GetLastError())
#else
// Optimized version for retail
//
#define Sync_Verify(fn, args)  \
    Sync_SetLastError(g_vtblEngine[0].##fn args)
#endif

//      BOOL Sync_IsEngineLoaded();
//          Returns TRUE if the engine is loaded.
//
BOOL PUBLIC Sync_IsEngineLoaded();

//      TWINRESULT Sync_SetLastError(TWINRESULT tr);
//
TWINRESULT PUBLIC Sync_SetLastError(TWINRESULT tr);

//      TWINRESULT Sync_GetLastError();
//
TWINRESULT PUBLIC Sync_GetLastError(void);

//      TWINRESULT Sync_OpenBriefcase(LPCSTR pszPath, DWORD dwFlags, HWND hwndOwner, HBRFCASE FAR * lphbrf);
//
#define Sync_OpenBriefcase(lpcsz, dwflags, hwnd, lphbrf)           \
    Sync_Verify(OpenBriefcase, (lpcsz, dwflags, hwnd, lphbrf))

//      TWINRESULT Sync_SaveBriefcase(HBRFCASE hbrf);
//
#define Sync_SaveBriefcase(hbrf)             \
    Sync_Verify(SaveBriefcase, (hbrf))

//      TWINRESULT Sync_DeleteBriefcase(LPCSTR pszPath);
//
#define Sync_DeleteBriefcase(lpcsz)                 \
    Sync_Verify(DeleteBriefcase, (lpcsz))

//      TWINRESULT Sync_CloseBriefcase(HBRFCASE hbrf);
//
#define Sync_CloseBriefcase(hbrf)                   \
    Sync_Verify(CloseBriefcase, (hbrf))

//      TWINRESULT Sync_GetOpenBriefcaseInfo(HBRFCASE hbrf, POPENBRFCASEINFO pinfo);
//
#define Sync_GetOpenBriefcaseInfo(hbrf, pinfo)          \
    Sync_Verify(GetOpenBriefcaseInfo, (hbrf, pinfo))

//      TWINRESULT Sync_ClearBriefcaseCache(HBRFCASE hbrf);
//
#define Sync_ClearBriefcaseCache(hbrf)                   \
    Sync_Verify(ClearBriefcaseCache, (hbrf))

//      TWINRESULT Sync_FindFirst(PHBRFCASEITER phbrfiter, PBRFCASEINFO pinfo);
//
#define Sync_FindFirst(phbrfiter, pinfo)            \
    Sync_Verify(FindFirstBriefcase, (phbrfiter, pinfo))

//      TWINRESULT Sync_FindNext(HBRFCASEITER hbrfiter, PBRFCASEINFO pinfo);
//
#define Sync_FindNext(hbrfiter, pinfo)            \
    Sync_Verify(FindNextBriefcase, (hbrfiter, pinfo))

//      TWINRESULT Sync_FindClose(HBRFCASEITER hbrfiter);
//
#define Sync_FindClose(hbrfiter)            \
    Sync_Verify(FindBriefcaseClose, (hbrfiter))

//      TWINRESULT Sync_AddObject(HBRFCASE hbrf, LPNEWOBJECTTWIN lpnot, HTWIN FAR * lphtfam);
//
#define Sync_AddObject(hbrf, lpnot, lphtfam)        \
    Sync_Verify(AddObjectTwin, (hbrf, lpnot, lphtfam))

//      TWINRESULT Sync_AddFolder(HBRFCASE hbrf, LPNEWFOLDERTWIN lpnft, HTWIN FAR * lphft);
//
#define Sync_AddFolder(hbrf, lpnft, lphft)          \
    Sync_Verify(AddFolderTwin, (hbrf, lpnft, lphft))

//      TWINRESULT Sync_ReleaseTwin(HTWIN htwin);
//
#define Sync_ReleaseTwin(htwin)                     \
    Sync_Verify(ReleaseTwinHandle, ((HTWIN)htwin))

//      TWINRESULT Sync_DeleteTwin(HTWIN htwin);
//
#define Sync_DeleteTwin(htwin)                      \
    Sync_Verify(DeleteTwin, ((HTWIN)htwin))

//      TWINRESULT Sync_AnyTwins(HBRFCASE hbrf, BOOL FAR * lpb);
//
#define Sync_AnyTwins(hbrf, lpb)                    \
    Sync_Verify(AnyTwins, (hbrf, lpb))

//      TWINRESULT Sync_CountSourceFolders(HOBJECTTWIN hot, ULONG FAR * lpulcSource);
//
#define Sync_CountSourceFolders(hot, lpulcSource)   \
    Sync_Verify(CountSourceFolderTwins, (hot, lpulcSource))

//      TWINRESULT Sync_IsExplicitObject(HOBJECTTWIN hot, BOOL FAR * lpb);
//
#define Sync_IsExplicitObject(hot, lpb)               \
    Sync_Verify(IsOrphanObjectTwin, (hot, lpb))

//      TWINRESULT Sync_GetObject(HBRFCASE hbrf, LPCSTR pszDir, LPCSTR pszName, HOBJECTTWIN FAR * lphot);
//
#define Sync_GetObject(hbrf, lpszFolder, lpszName, lphot)   \
    Sync_Verify(GetObjectTwinHandle, (hbrf, lpszFolder, lpszName, lphot))

//      TWINRESULT Sync_IsFolder(HBRFCASE hbrf, LPCSTR pszFolder, BOOL FAR * lpb);
//
#define Sync_IsFolder(hbrf, lpszFolder, lpb)        \
    Sync_Verify(IsFolderTwin, (hbrf, lpszFolder, lpb))

//      TWINRESULT Sync_GetFolderTwinStatus(HFOLDERTWIN hft, CREATERECLISTPROC crlp, LPARAM lpCallbackData, PFOLDERTWINSTATUS pfts);
//
#ifdef NEW_REC

#define Sync_GetFolderTwinStatus(hft, crlp, lpcb, pfts)        \
    Sync_Verify(GetFolderTwinStatus, (hft, crlp, lpcb, pfts))

#else

#define Sync_GetFolderTwinStatus(hft, crlp, lpcb, pfts)        \
    Sync_Verify(GetFolderTwinStatus, (hft, crlp, lpcb, CRL_FLAGS, pfts))

#endif

//      TWINRESULT Sync_CreateFolderList(HBRFCASE hbrf, LPCSTR pszDir, LPFOLDERTWINLIST FAR * lplpftl);
//
#define Sync_CreateFolderList(hbrf, lpszFolder, lplpftl)    \
    Sync_Verify(CreateFolderTwinList, (hbrf, lpszFolder, lplpftl))

//      TWINRESULT Sync_DestroyFolderList(LPFOLDERTWINLIST lpftl);
//
#define Sync_DestroyFolderList(lpftl)               \
    Sync_Verify(DestroyFolderTwinList, (lpftl))

//      TWINRESULT Sync_CreateTwinList(HBRFCASE hbrf, LPHTWINLIST lphtl);
//
#define Sync_CreateTwinList(hbrf, lphtl)            \
    Sync_Verify(CreateTwinList, (hbrf, lphtl))

//      TWINRESULT Sync_DestroyTwinList(HTWINLIST htl);
//
#define Sync_DestroyTwinList(htl)                   \
    Sync_Verify(DestroyTwinList, (htl))

//      TWINRESULT Sync_AddToTwinList(HTWINLIST htl, HTWIN htwin);
//
#define Sync_AddToTwinList(htl, htwin)              \
    Sync_Verify(AddTwinToTwinList, (htl, (HTWIN)htwin))

//      TWINRESULT Sync_AddAllToTwinList(HTWINLIST htl);
//
#define Sync_AddAllToTwinList(htl)                  \
    Sync_Verify(AddAllTwinsToTwinList, (htl))

//      TWINRESULT Sync_RemoveFromTwinList(HTWINLIST htl, HTWIN htwin);
//
#define Sync_RemoveFromTwinList(htl, htwin)         \
    Sync_Verify(RemoveTwinFromTwinList, (htl, (HTWIN)htwin))

//      TWINRESULT Sync_RemoveAllFromTwinList(HTWINLIST htl);
//
#define Sync_RemoveAllFromTwinList(htl)             \
    Sync_Verify(RemoveAllTwinsFromTwinList, (htl))

//      TWINRESULT Sync_CreateRecList(HTWINLIST htl, CREATERECLISTPROC crlp, LPARAM lpcb, LPRECLIST FAR * lplprl);
//
#ifdef NEW_REC

#define Sync_CreateRecList(htl, crlp, lpcb, lplprl)            \
    Sync_Verify(CreateRecList, (htl, crlp, lpcb, lplprl))

#else

#define Sync_CreateRecList(htl, crlp, lpcb, lplprl)            \
    Sync_Verify(CreateRecList, (htl, crlp, lpcb, CRL_FLAGS, lplprl))

#endif

//      TWINRESULT Sync_DestroyRecList(LPRECLIST lprl);
//
#define Sync_DestroyRecList(lprl)                   \
    Sync_Verify(DestroyRecList, (lprl))

//      TWINRESULT Sync_BeginRec(HBRFCASE hbrf);
//
#define Sync_BeginRec(hbrf)                         \
    Sync_Verify(BeginReconciliation, (hbrf))

//      TWINRESULT Sync_EndRec(HBRFCASE hbrf);
//
#define Sync_EndRec(hbrf)                           \
    Sync_Verify(EndReconciliation, (hbrf))

//      TWINRESULT Sync_ReconcileItem(LPRECITEM lpri, RECSTATUSPROC rsp, LPARAM lpCallbackData, DWORD dwFlags, HWND hwndOwner, HWND hwndStatusText);
//
#define Sync_ReconcileItem(lpri, rsp, lpcb, flags, hwnd, hwndStatusText)    \
    Sync_Verify(ReconcileItem, (lpri, rsp, lpcb, flags, hwnd, hwndStatusText))

//      BOOL Sync_IsPathOnVolume(LPCSTR pszPath, HVOLUMEID hvid);
//
#define Sync_IsPathOnVolume(pszPath, hvid, pbool)      \
    Sync_Verify(IsPathOnVolume, (pszPath, hvid, pbool))

//      BOOL Sync_GetVolumeDecription(HVOLUMEID hvid, PVOLUMEDESC pvd);
//
#define Sync_GetVolumeDescription(hvid, pvd)      \
    Sync_Verify(GetVolumeDescription, (hvid, pvd))


#ifdef NEW_REC

// Returns TRUE if the recitem is referring to a file (not a folder)
#define IsFileRecItem(pri)    (0 != *(pri)->pcszName)

#else

#define IsFileRecItem(pri)    TRUE

#endif


extern const TCHAR szAll[];

extern VTBLENGINE g_vtblEngine[1];

int CALLBACK _export NCompareFolders (LPVOID lpv1, LPVOID lpv2, LPARAM lParam);

// Structure for the ChooseSide functions
typedef struct tagCHOOSESIDE
    {
    DWORD       dwFlags;        // CSF_* flags
    int         nRank;          // Higher means better choice

    HTWIN       htwin;
    HVOLUMEID   hvid;
    LPCTSTR      pszFolder;
    PRECNODE    prn;            // Only if CSF_FOLDER is clear
    } CHOOSESIDE, * PCHOOSESIDE;

#define CSF_FOLDER      0x0001
#define CSF_INSIDE      0x0002      // Ranking for inside

#ifdef DEBUG
void    PUBLIC ChooseSide_DumpList(HDSA hdsa);
#endif

void    PUBLIC ChooseSide_InitAsFile(HDSA hdsa, PRECITEM pri);
HRESULT PUBLIC ChooseSide_CreateEmpty(HDSA * phdsa);
HRESULT PUBLIC ChooseSide_CreateAsFile(HDSA * phdsa, PRECITEM pri);
HRESULT PUBLIC ChooseSide_CreateAsFolder(HDSA * phdsa, PFOLDERTWINLIST pftl);
BOOL    PUBLIC ChooseSide_GetBest(HDSA hdsa, LPCTSTR pszBrfPath, LPCTSTR pszFolder, PCHOOSESIDE * ppchside);
BOOL    PUBLIC ChooseSide_GetNextBest(HDSA hdsa, PCHOOSESIDE * ppchside);
void    PUBLIC ChooseSide_Free(HDSA hdsa);


HRESULT PUBLIC Sync_GetNodePair(PRECITEM pri, LPCTSTR pszBrfPath, LPCTSTR pszFolder, PRECNODE  * pprnInside, PRECNODE  * pprnOutside);
void    PUBLIC Sync_ChangeRecItemAction(PRECITEM pri, LPCTSTR pszBrfPath, LPCTSTR pszInsideDir, UINT uAction);

BOOL PUBLIC Sync_QueryVTable();
void PUBLIC Sync_ReleaseVTable();

BOOL PUBLIC Sync_AddPathToTwinList(HBRFCASE hbrf, HTWINLIST htl, LPCTSTR lpcszPath, PFOLDERTWINLIST  * lplpftl);

HRESULT PUBLIC Sync_CreateCompleteRecList(HBRFCASE hbrf, PABORTEVT pabortevt, PRECLIST * pprl);
HRESULT PUBLIC Sync_CreateRecListEx(HTWINLIST htl, PABORTEVT pabortevt, PRECLIST * pprl);

// Flags for Sync_ReconcileRecList
#define RF_DEFAULT      0x0000
#define RF_ONADD        0x0001

HRESULT PUBLIC Sync_ReconcileRecList (PRECLIST lprl, LPCTSTR pszPathBrf, HWND hwndParent, UINT uFlags);

// Flags for Sync_Split
#define SF_NOCONFIRM    0x0001
#define SF_QUIET        0x0002

// Flags for Sync_IsTwin and Sync_Split
#define SF_ISFOLDER     0x1000
#define SF_ISFILE       0x2000
#define SF_ISTWIN       0x4000
#define SF_ISNOTTWIN    0x8000

HRESULT PUBLIC Sync_IsTwin (HBRFCASE hbrf, LPCTSTR lpcszPath, UINT uFlags);
HRESULT PUBLIC Sync_Split (HBRFCASE hbrf, LPCTSTR pszList, UINT cFiles, HWND hwndOwner, UINT uFlags);

ULONG   PUBLIC CountActionItems(PRECLIST prl);

#ifdef DEBUG
void PUBLIC Sync_FnDump (LPVOID lpvBuf, UINT cbBuf);
void PUBLIC Sync_DumpRecItem (TWINRESULT tr, PRECITEM lpri, LPCTSTR pszMsg);
void PUBLIC Sync_DumpRecNode (TWINRESULT tr, PRECNODE lprn);
void PUBLIC Sync_DumpRecList(TWINRESULT tr, PRECLIST lprl, LPCTSTR pszMsg);
void PUBLIC Sync_DumpFolderTwin(PCFOLDERTWIN pft);
void PUBLIC Sync_DumpFolderTwinList(PFOLDERTWINLIST pftl, LPCTSTR pszMsg);
#endif

#endif // __TWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\thread.c ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: thread.c
//
//  This files contains the thread creation routines.  (These routines
//  were swiped from the shell.)
//
//  Public API is RunDLLThread().
//
//---------------------------------------------------------------------------

#include "brfprv.h"

#pragma data_seg(DATASEG_READONLY)
static const TCHAR c_szStubWindowClass[] = TEXT("BrfStubWindow32");
#pragma data_seg()

// SHOpenPropSheet uses these messages.  It is unclear if
// we need to support this or not.  
#define STUBM_SETDATA   (WM_USER)
#define STUBM_GETDATA   (WM_USER+1)

typedef void (WINAPI * NEWTHREADPROC)(HWND hwndStub,                      
        HINSTANCE hAppInstance,                                           
        LPTSTR lpszCmdLine, int nCmdShow);                                 

typedef struct  // dlle
    {
    HINSTANCE  hinst;
    NEWTHREADPROC lpfn;
    } DLLENTRY;


typedef struct _NEWTHREAD_NOTIFY                                             
    {                                                                         
    NMHDR   hdr;                                                      
    HICON   hIcon;                                                    
    LPCTSTR  lpszTitle;                                                
    } NEWTHREAD_NOTIFY;                                                          
                                                                          


/*----------------------------------------------------------
Purpose: Parses a command line entry into a DLLENTRY struct.

Returns: TRUE on success
Cond:    --
*/
BOOL PRIVATE InitializeDLLEntry(
    LPTSTR lpszCmdLine, 
    DLLENTRY * pdlle)
    {
    LPTSTR lpStart, lpEnd, lpFunction;

    TRACE_MSG(TF_GENERAL, TEXT("RunDLLThread(%s)"), lpszCmdLine);

    for (lpStart=lpszCmdLine; ; )
        {
        // Skip leading blanks
        //
        while (*lpStart == TEXT(' '))
            {
            ++lpStart;
            }

        // Check if there are any switches
        //
        if (*lpStart != TEXT('/'))
            {
            break;
            }

        // Look at all the switches; ignore unknown ones
        //
        for (++lpStart; ; ++lpStart)
            {
            switch (*lpStart)
                {
            case TEXT(' '):
            case TEXT('\0'):
                goto EndSwitches;
                break;

            // Put any switches we care about here
            //

            default:
                break;
                }
            }
EndSwitches:
            ;
        }

    // We have found the DLL,FN parameter
    //
    lpEnd = StrChr(lpStart, TEXT(' '));
    if (lpEnd)
        {
        *lpEnd++ = TEXT('\0');
        }

    // There must be a DLL name and a function name
    //
    lpFunction = StrChr(lpStart, TEXT(','));
    if (!lpFunction)
        {
        return(FALSE);
        }
    *lpFunction++ = TEXT('\0');

    // Load the library and get the procedure address
    // Note that we try to get a module handle first, so we don't need
    // to pass full file names around
    //
    pdlle->hinst = GetModuleHandle(lpStart);
    if (pdlle->hinst)
        {
        TCHAR szName[MAXPATHLEN];

        GetModuleFileName(pdlle->hinst, szName, ARRAYSIZE(szName));
        LoadLibrary(szName);
        }
    else
        {
        pdlle->hinst = LoadLibrary(lpStart);
        if (!ISVALIDHINSTANCE(pdlle->hinst))
            {
            return(FALSE);
            }
        }

#ifdef UNICODE
{
    CHAR szFunction[MAX_PATH] = "";
    WideCharToMultiByte(CP_ACP, 0, lpFunction, -1, szFunction, MAX_PATH, NULL, NULL);
    pdlle->lpfn = (NEWTHREADPROC)GetProcAddress(pdlle->hinst, szFunction);
}
#else
{
    pdlle->lpfn = (NEWTHREADPROC)GetProcAddress(pdlle->hinst, lpFunction);
}
#endif

    if (!pdlle->lpfn)
        {
        FreeLibrary(pdlle->hinst);
        return(FALSE);
        }

    // Copy the rest of the command parameters down
    //
    if (lpEnd)
        {
        lstrcpy(lpszCmdLine, lpEnd);
        }
    else
        {
        *lpszCmdLine = TEXT('\0');
        }

    return(TRUE);
    }


/*----------------------------------------------------------
Purpose: Handles WM_NOTIFY messages for stub window
Returns: varies
Cond:    --
*/
LRESULT PRIVATE StubNotify(
    HWND hWnd, 
    WPARAM wParam, 
    NEWTHREAD_NOTIFY  *lpn)
    {
    switch (lpn->hdr.code)
        {
#ifdef COOLICON
    case RDN_TASKINFO:
        SetWindowText(hWnd, lpn->lpszTitle ? lpn->lpszTitle : TEXT(""));
        g_hIcon = lpn->hIcon ? lpn->hIcon :
                LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT));
        break;
#endif

    default:
        return(DefWindowProc(hWnd, WM_NOTIFY, wParam, (LPARAM)lpn));
        }
    }


/*----------------------------------------------------------
Purpose: Window proc for thread

Returns: varies
Cond:    --
*/
LRESULT CALLBACK WndProc(
    HWND hWnd, 
    UINT iMessage, 
    WPARAM wParam, 
    LPARAM lParam)
    {
    switch(iMessage)
        {
    case WM_CREATE:
#ifdef COOLICON
        g_hIcon = LoadIcon(hInst, MAKEINTRESOURCE(IDI_DEFAULT));
#endif
        break;

    case WM_DESTROY:
        break;

    case WM_NOTIFY:
        return(StubNotify(hWnd, wParam, (NEWTHREAD_NOTIFY  *)lParam));

#ifdef COOLICON
    case WM_QUERYDRAGICON:
        return(MAKELRESULT(g_hIcon, 0));
#endif
        
    case STUBM_SETDATA:
        SetWindowLong(hWnd, 0, wParam);
        SetWindowLong(hWnd, 4, lParam);
        break;
        
    case  STUBM_GETDATA:
        *((LONG *)lParam) = GetWindowLong(hWnd, 4);
        return GetWindowLong(hWnd, 0);

    default:
        return DefWindowProc(hWnd, iMessage, wParam, lParam) ;
        break;
        }

    return 0L;
    }


/*----------------------------------------------------------
Purpose: Creates a stub window to handle the thread

Returns: handle to window
Cond:    --
*/
HWND PRIVATE CreateStubWindow(void)
    {
    WNDCLASS wndclass;

    if (!GetClassInfo(g_hinst, c_szStubWindowClass, &wndclass))
        {
        wndclass.style         = 0 ;
        wndclass.lpfnWndProc   = (WNDPROC)WndProc ;
        wndclass.cbClsExtra    = 0 ;
        wndclass.cbWndExtra    = sizeof(DWORD) * 2 ;
        wndclass.hInstance     = g_hinst;
        wndclass.hIcon         = NULL ;
        wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
        wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
        wndclass.lpszMenuName  = NULL ;
        wndclass.lpszClassName = c_szStubWindowClass ;

        if (!RegisterClass(&wndclass))
            {
            return NULL;
            }
        }

    return CreateWindowEx(WS_EX_TOOLWINDOW, c_szStubWindowClass, c_szNULL, 
                        0, 0, 0, 0, 0, NULL, NULL, g_hinst, NULL);
    }


/*----------------------------------------------------------
Purpose: Initializes a new thread in our DLL

Returns: 0
Cond:    --
*/


DWORD WINAPI ThreadInitDLL(
    LPVOID pszCmdLine)
    {
    DLLENTRY dlle;

    if (InitializeDLLEntry((LPTSTR)pszCmdLine, &dlle))
        {
        HWND hwndStub = CreateStubWindow();
        if (hwndStub)
            {
            SetForegroundWindow(hwndStub);
            dlle.lpfn(hwndStub, g_hinst, pszCmdLine, SW_NORMAL);
            DestroyWindow(hwndStub);
            }
        FreeLibrary(dlle.hinst);
        }

    GFree(pszCmdLine);

    return 0;
    }


/*----------------------------------------------------------
Purpose: Start a new thread

         This code was swiped from the shell.

Returns: TRUE if the thread was created successfully
Cond:    --
*/
BOOL PUBLIC RunDLLThread(
    HWND hwnd, 
    LPCTSTR pszCmdLine, 
    int nCmdShow)
    {
    BOOL fSuccess=FALSE; // assume error
    LPTSTR pszCopy = GAlloc(CbFromCch(lstrlen(pszCmdLine)+1));

    if (pszCopy)
        {
        DWORD idThread;
        HANDLE hthread;
        lstrcpy(pszCopy, pszCmdLine);

        if (hthread=CreateThread(NULL, 0, ThreadInitDLL, pszCopy, 0, &idThread))
            {
            // We don't need to communicate with this thread any more.
            // Close the handle and let it run and terminate itself.
            //
            // Notes: In this case, pszCopy will be freed by the thread.
            //
            CloseHandle(hthread);
            fSuccess=TRUE;
            }
        else
            {
            // Thread creation failed, we should free the buffer.
            GFree(pszCopy);
            }
        }

    return fSuccess;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\apwizhlp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1994
*
*  TITLE:	APWIZHLP.H
*
*  VERSION:	1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/8/94
*
*  Help IDs for Add/Remove Programs.
*  NOTE:  These IDs are reserved in the HELP.H file.  The IDs refer to entries
*	  in the main windows help file.
*
*******************************************************************************/


#ifndef _INC_APWIZHLP
#define _INC_APWIZHLP

//  Net install page
#define IDH_APPWIZ_NETINSTALL_INSTRUCT	5600
#define IDH_APPWIZ_NETINSTALL_LIST	5601
#define IDH_APPWIZ_NETINTALLL_BUTTON	5602

// Install/Uninstall Page
#define IDH_APPWIZ_DISKINSTALL_INSTRUCT 5610
#define IDH_APPWIZ_DISKINTALLL_BUTTON	5611
#define IDH_APPWIZ_UNINSTALL_INSTRUCT	5612
#define IDH_APPWIZ_UNINSTALL_LIST	5613
#define IDH_APPWIZ_UNINSTALL_BUTTON	5614

// Windows Setup page
#define IDH_APPWIZ_WINSETUP_INSTRUCT	5620
#define IDH_APPWIZ_WINSETUP_LIST	5621

// Startup Disk page
#define IDH_APPWIZ_STARTDISK_INSTRUCT	5630
#define IDH_APPWIZ_STARTDISK_BUTTON	5631

#endif // _INC_APWIZHLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\apperr.h ===
// Help IDs for Windows 95 incompatibility errors.

#define IDH_HDC			1000
#define IDH_DOIT		1001
#define IDH_SCREENCAM		1002
#define IDH_PEACHTREE		1003
#define IDH_PHOTOSHOP		1004
//#define IDH_UNUSED		1005
//#define IDH_SIMPLYMONEY	1006
#define IDH_STAC		1007
#define IDH_CRYSTALWALLS	1008
#define IDH_GEN_DISKUTIL	1009
#define IDH_GEN_VIRUS		1010
#define IDH_ADT20		1011
#define IDH_VBSETUP		1012
// #define IDH_UNUSED		1013
#define IDH_MPCWIZ20		1014
#define IDH_WIN31SHELL		1015
#define IDH_WINNT		1016
#define IDH_WSS20SETUP		1017
#define IDH_TABWORKS		1018
#define IDH_CPANTIVIRUS         1019
#define IDH_DAVINCI             1020
#define IDH_DIRECTORLAB         1021
#define IDH_FAMILYTREE          1022
#define IDH_ICONHEARIT          1023
#define IDH_MAXTIME             1024
#define IDH_MSMAIL              1025
#define IDH_NTNETTOOL           1026
// no longer used #define IDH_OUTPOST             1027 
#define IDH_PCANYWHERE          1028
#define IDH_PCXWARE             1029
#define IDH_PFSWW               1030
#define IDH_PRINTCACHE          1031
#define IDH_TDWIN               1032
#define IDH_TRUEEFFECTS         1033
#define IDH_UNCPRINT            1034
#define IDH_WIRED               1035
#define IDH_WORDVIEW            1036
#define IDH_THUMBELINA		1037
#define IDH_APPMAN		1038
#define	IDH_REMINDME		1039
#define	IDH_ACROREAD		1040
#define	IDH_BSTONE		1041
#define	IDH_RACKMNT		1042
#define	IDH_REBEL2		1043
#define	IDH_SECURE		1044
#define	IDH_SPACEMAN		1045
#define	IDH_SUPERPCK		1046
#define	IDH_TYPESTRY		1047
#define	IDH_WINPROBE		1048
#define	IDH_PCTOOLS		1049
#define IDH_SSTOR		1050
#define IDH_DBLTOOLS		1051
#define IDH_WINHOST		1052
#define IDH_RAVEN		1053
#define IDH_ADOBEVUE		1054
#define CHANGE_VIDEO_DRIVER	1055
#define IDH_EARTHC		1056
#define EARTH_CARE_RUN_COMMAND	1057
#define EARTH_CARE_PROGRAMS_MENU	1058
// no longer used #define IDH_ADMINWIN		1059
#define IDH_3DHOME		1060
#define IDH_MSFONT		1061
#define IDH_TIMELINE		1062
#define IDH_CINSTALL		1063
// no longer used #define IDH_ALDSETUP            1064
#define IDH_HUMONGOUS           1065
#define IDH_SCW                 1066
#define IDH_UPFRONT             1067
#define IDH_PROXY               1068
#define IDH_WANDERLINK          1069
#define IDH_PIM                 1070
#define IDH_WFSOUND             1071
#define IDH_PERFORMPRO          1072
#define IDH_RPSHOST             1073
#define IDH_AMIPRO              1074
#define IDH_STACOPTM            1075
#define IDH_BOUNDS              1076
#define IDH_CLWORKS             1077
#define IDH_NORTONAVIRUS        1078
#define IDH_NDESKTOPW           1079
#define IDH_NORTUTIL            1080
#define IDH_NORTONCMDR          1081
#define IDH_GENSAVEWORK        1082
#define IDH_GENPRINTWIZ         1083
#define IDH_GENBROKEN           1084
#define IDH_GENHIGHCOLOR        1085
#define IDH_GENHIGHRESOLUTION   1086
#define IDH_GENREALMODENET      1087
#define IDH_GENOLDDRIVER        1088
#define IDH_GENOLDCONFIGUTIL    1089
#define IDH_GENRELNOTES         1090
#define IDH_GENMSDOSMODE        1091
#define IDH_GENUNSTABLE         1092
#define IDH_GENLONGPRINTERNAME  1093
#define IDH_GENEMSMEMORY        1094
#define IDH_FAMOUSPLACES        1095
#define IDH_TREKMANUALINSTALL   1096
#define IDH_LANDSOFLOREINSTALL  1097
#define IDH_MARTIANMEMORANDUM   1098
#define IDH_GUARDIANSOFEDEN     1099
#define IDH_CAMERAMAN           1100
#define IDH_DRAGONSLAIRCD       1101
#define IDH_SHADOWCASTER        1102
#define IDH_TIMEACTIVATORINSTALL 1103
#define IDH_ALISTAIRINSTALL     1104
#define IDH_INTELPROSHARE       1105
#define IDH_IBMWINSETUP         1106
#define IDH_SOUNDSET            1107
#define IDH_SIERRA              1108
#define IDH_CCMail              1109
#define IDH_CLICKBOOKS          1110
#define IDH_LIGHTNING           1111
#define IDH_MSMOUSE             1112
#define IDH_DBWDEBUG            1113
#define IDH_RIBBIT              1114
#define IDH_PPOCR               1115
#define IDH_FORTRAN77           1116
#define IDH_EXECUVOICE          1117
#define IDH_AYS                 1118
// no longer used #define IDH_MOREPCXWARE         1119
#define IDH_GROUPWISE           1120
#define IDH_LANDESK             1121
#define IDH_NOVELL_NETWARE_USER_TOOLS             1122
#define IDH_QUICKTIME           1123
#define IDH_EXCEL               1124
#define IDH_PLACE_HOLDER_ONE    1125
#define IDH_PLACE_HOLDER_TWO    1126
#define IDH_PLACE_HOLDER_THREE  1127
#define IDH_PLACE_HOLDER_FOUR   1128
#define IDH_PLACE_HOLDER_FIVE   1129
#define IDH_PLACE_HOLDER_SIX    1130
#define IDH_PLACE_HOLDER_SEVEN  1131
#define IDH_PLACE_HOLDER_EIGHT  1132
#define IDH_PLACE_HOLDER_NINE   1133
#define IDH_PLACE_HOLDER_TEN    1134
#define IDH_PLACE_HOLDER_ELEVEN 1135
#define IDH_PLACE_HOLDER_TWELVE 1136
#define IDH_PLACE_HOLDER_THIRTEEN                1137
#define IDH_PLACE_HOLDER_FOURTEEN                1138
#define IDH_PLACE_HOLDER_FIFTEEN                 1139
#define IDH_PLACE_HOLDER_SIXTEEN                 1140
#define IDH_PLACE_HOLDER_SEVENTEEN               1141
#define IDH_PLACE_HOLDER_EIGHTEEN                1142
#define IDH_PLACE_HOLDER_NINETEEN                1143
#define IDH_PLACE_HOLDER_TWENTY                  1144
#define IDH_PLACE_HOLDER_TWENTYONE               1145
#define IDH_PLACE_HOLDER_TWENTYTWO               1146
#define IDH_GENPRINTERDRIVER                     1147
#define IDH_LD_CP_EXE                            1148
#define IDH_LAPLINK				 1149
#define IDH_GENTRAY				 1150
#define IDH_PROSHARE				 1151
#define IDH_GENNOPIF				 1152
#define IDH_GEN_BACKUP				 1153
#define IDH_CPBACKUP				 1154
#define IDH_QUICKBOOKS                           1155
#define IDH_GENNOPIF                             1156
#define IDH_FORTRANPS                            1157
#define IDH_GEN_DSHELL                           1158
#define IDH_GEN_DSHELL	                         1159
#define	IDH_NAVIGATOR	                         1160
#define IDH_REFLECTION_X                         1161
#define IDH_POINTER_EXE                          1162
#define IDH_QUALITYPE                            1163
#define IDH_MS_SOUND_SYS_20C                     1164
#define IDH_UNINSTALLER	                         1165
#define IDH_WINMODE                              1166
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\brfcasep.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: brfcasep.h
//
//  Internal header shared between SHELL232 and SYNCUI
//
// History:
//  01-27-94 ScottH     Copied from brfcase.h
//
//---------------------------------------------------------------------------

#ifndef _BRFCASEP_H_
#define _BRFCASEP_H_

//===========================================================================
//
// IBriefcaseStg Interface
//
//  This is a private interface for use between the shell and the briefcase.
//
//  This interface is used by the Shell's IShellFolder implementation
// when it is bound to a folder that is (in) a briefcase.  The IShellView
// of the particular folder binds to this interface to open the briefcase
// database storage and optionally make modifications.  File-objects that
// are added to a folder in a briefcase are not added to the storage
// database until IBriefcaseStg::AddObject is called.  Keep in mind the
// difference between IBriefcaseStg and IShellFolder.  IBriefcaseStg
// simply provides access to the briefcase storage database--the file-system
// objects are only affected upon subsequent reconciliation using
// IBriefcaseStg::UpdateObject, unless otherwise noted.
//
//
// [Member functions]
//
//
// IBriefcaseStg::Initialize(pszFolder, hwndOwner)
//
//   Initializes the interface by specifying the folder for this storage
//   instance.  If the folder does not exist somewhere in a briefcase
//   storage hierarchy, then a briefcase database is created for this
//   folder.
//
// IBriefcaseStg::AddObject(pdtobj, pszFolderEx, uFlags, hwndOwner)
//
//   Adds a file-object(s) to the briefcase storage.  This function also
//   performs an update of the specific files to immediately make them
//   up-to-date.
//
//   Typically pdtobj refers to a file-object(s) outside the
//   briefcase.  Calling this function implies adding the object(s) to
//   the briefcase storage database in the folder that was specified by
//   IBriefcaseStg::Initialize().  This rule holds unless pszFolderEx is
//   non-NULL, in which case pdtobj is sync-associated to pszFolderEx
//   instead.
//
//   AddObject() returns NOERROR if the object(s) were added.  S_FALSE
//   is returned if the caller should handle the action (eg, moving
//   files from folder-to-folder within the briefcase).
//
// IBriefcaseStg::ReleaseObject(pdtobj, hwndOwner)
//
//   Releases a file-object(s) from the briefcase storage database.  This
//   does not delete the file from the file-system.
//
// IBriefcaseStg::UpdateObject(pdtobj, hwndOwner)
//
//   Performs a file-synchronization update to pdtobj.  If pdtobj refers to
//   the root of a briefcase storage hierarchy, the entire storage is updated.
//
// IBriefcaseStg::UpdateOnEvent(uEvent, hwndOwner)
//
//   Performs a complete update of the briefcase storage based on the
//   indicated event.  The event ordinals may be:
//
//      UOE_CONFIGCHANGED       Indicates a PnP DBT_CONFIGCHANGED message wants
//                              to be processed.  This occurs when a machine
//                              hot-docks.
//
//      UOE_QUERYCHANGECONFIG   Indicates a PnP DBT_QUERYCHANGECONFIG message
//                              wants to be processed.  This occurs when a
//                              machine is about to hot-undock.
//
// IBriefcaseStg::GetExtraInfo(pszName, uInfo, wParam, lParam)
//
//   Gets some specified extra info from the briefcase storage.  The
//   info is determined by uInfo, which is one of GEI_* values.
//
// IBriefcaseStg::Notify(pszPath, lEvent, puFlags, hwndOwner)
//
//   Sends a notify event to the briefcase storage, so it can mark
//   cached items stale.  If lEvent is NOE_RENAME, pszPath must be a double
//   null-terminated string, where the first is the old pathname, and the
//   second is the new pathname.  *puFlags is filled with flags pertaining
//   to what the member function did.  NF_REDRAWWINDOW means the window
//   needs to be redrawn.  NF_ITEMMARKED means the cached item in the
//   briefcase storage associated with pszPath was marked stale.
//
// IBriefcaseStg::GetRootOf(pszBuffer, cbBuffer)
//
//   Queries the briefcase storage for the root of the briefcase storage
//   hierarchy.
//
// IBriefcaseStg::FindFirst(pszBuffer, cbBuffer)
//
//   Finds the root of the first briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
// IBriefcaseStg::FindNext(pszBuffer, cbBuffer)
//
//   Finds the root of the next briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
//
//
//===========================================================================


#undef  INTERFACE
#define INTERFACE   IBriefcaseStg

DECLARE_INTERFACE_(IBriefcaseStg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBriefcaseStg methods ***
    STDMETHOD(Initialize) (THIS_ LPCTSTR pszFolder, HWND hwnd) PURE;
    STDMETHOD(AddObject) (THIS_ LPDATAOBJECT lpdobj, LPCTSTR pszFolderEx, UINT uFlags, HWND hwnd) PURE;
    STDMETHOD(ReleaseObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateOnEvent) (THIS_ UINT uEvent, HWND hwnd) PURE;
    STDMETHOD(GetExtraInfo) (THIS_ LPCTSTR pszName, UINT uInfo, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Notify) (THIS_ LPCTSTR pszPath, LONG lEvent, UINT * puFlags, HWND hwndOwner) PURE;
    STDMETHOD(FindFirst) (THIS_ LPTSTR pszPath, int cchMax) PURE;
    STDMETHOD(FindNext) (THIS_ LPTSTR pszPath, int cchMax) PURE;

   // IBriefcaseStg2 methods, should be different IID
    STDMETHOD(PrepForSync) (THIS_ HWND hwndOwner, LPSYNCMGRSYNCHRONIZECALLBACK pCallback,SYNCMGRITEMID dwItemID) PURE;
    STDMETHOD(Synchronize) (THIS_ HWND hwndOwner, LPSYNCMGRSYNCHRONIZECALLBACK pCallback,SYNCMGRITEMID dwItemID) PURE;
    STDMETHOD(ShowError) (THIS_ HWND hwndOwner,DWORD dwErrorID) PURE;

};

// Events for UpdateOnEvent member function
#define UOE_CONFIGCHANGED       1
#define UOE_QUERYCHANGECONFIG   2

// Flags for AddObject
#define AOF_DEFAULT             0x0000
#define AOF_UPDATEONREPLACE     0x0001
#define AOF_FILTERPROMPT        0x0002

// Notify events
#define NOE_RENAME              1L
#define NOE_RENAMEFOLDER        2L
#define NOE_CREATE              3L
#define NOE_CREATEFOLDER        4L
#define NOE_DELETE              5L
#define NOE_DELETEFOLDER        6L
#define NOE_DIRTY               7L
#define NOE_DIRTYFOLDER         8L
#define NOE_DIRTYALL            9L

// Flags that are returned by Notify member function
#define NF_REDRAWWINDOW     0x0001
#define NF_ITEMMARKED       0x0002

// Flags for GetExtraInfo                wParam        lParam
#define GEI_ROOT            1       //   cchBuf         pszBuf
#define GEI_ORIGIN          2       //   cchBuf         pszBuf
#define GEI_STATUS          3       //   cchBuf         pszBuf
#define GEI_DELAYHANDLE     4       //     --           phandle
#define GEI_DATABASENAME    5       //   cchBuf         pszBuf

typedef IBriefcaseStg FAR*   LPBRIEFCASESTG;

// Special briefcase object struct
//
typedef struct _BriefObj
    {
    UINT    cbSize;             // size of allocated struct
    UINT    ibFileList;         // offset of file list in struct
    UINT    ibBriefPath;        // offset of briefcase path in struct
    UINT    cItems;             // count of file-system objects
    UINT    cbListSize;         // size of file list
    TCHAR   data[1];            // data
    } BriefObj, * PBRIEFOBJ;

// Helper macros for briefcase object struct
#define BOBriefcasePath(pbo)    ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibBriefPath))
#define BOFileList(pbo)         ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibFileList))
#define BOFileCount(pbo)        ((pbo)->cItems)
#define BOFileListSize(pbo)     ((pbo)->cbListSize)

// Clipboard format for above struct
//
#define CFSTR_BRIEFOBJECT  TEXT("Briefcase File Object")

#endif // _BRFCASEP_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\update.h ===
//
// update.h: Declares data, defines and struct types for twin creation
//          module.
//
//

#ifndef __UPDATE_H__
#define __UPDATE_H__

// Flags for Upd_DoModal
#define UF_SELECTION    0x0001
#define UF_ALL          0x0002


// This structure contains all the important counts
// that determine the specific course of action when
// the user wants to update something.
typedef struct
    {
    // These are 1 to 1
    UINT    cFiles;
    UINT    cOrphans;
    UINT    cSubfolders;

    // These are 1 to 1
    UINT    cUnavailable;
    UINT    cDoSomething;
    UINT    cConflict;
    UINT    cTombstone;
    } UPDCOUNT;

// This is the structure passed to the dialog at WM_INITDIALOG
typedef struct
    {
    PRECLIST lprl;              // Supplied reclist
    CBS *    pcbs;
    UINT     uFlags;            // UF_ Flags
    HDPA     hdpa;              // List of RA_ITEMs
    UINT     cDoSomething;
    } XUPDSTRUCT,  * LPXUPDSTRUCT;


typedef struct tagUPD
    {
    HWND hwnd;              // dialog handle

    LPXUPDSTRUCT pxupd;

    } UPD, * PUPD;

#define Upd_Prl(this)           ((this)->pxupd->lprl)
#define Upd_AtomBrf(this)       ((this)->pxupd->pcbs->atomBrf)
#define Upd_GetBrfPtr(this)     Atom_GetName(Upd_AtomBrf(this))

#define Upd_GetPtr(hwnd)        (PUPD)GetWindowLong(hwnd, DWL_USER)
#define Upd_SetPtr(hwnd, lp)    (PUPD)SetWindowLong(hwnd, DWL_USER, (LONG)(lp))

// These flags are used for DoUpdateMsg
#define DUM_ALL             0x0001
#define DUM_SELECTION       0x0002
#define DUM_ORPHAN          0x0004
#define DUM_UPTODATE        0x0008
#define DUM_UNAVAILABLE     0x0010
#define DUM_SUBFOLDER_TWIN  0x0020

// These flags are returned by PassedSpecialCases
#define PSC_SHOWDIALOG      0x0001
#define PSC_POSTMSGBOX      0x0002



HRESULT Upd_PrepForSync(HWND hwndOwner,
    CBS * pcbs,
    LPCTSTR pszList,         // May be NULL if uFlags == UF_ALL
    UINT cFiles,
    UINT uFlags,
    UPDCOUNT *updcount,
    PRECLIST *prl,
    UINT *uVal,
    LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,SYNCMGRITEMID ItemID) ;

HRESULT Upd_Synchronize(HWND hwndOwner, CBS * pcbs,UINT uFlags,UINT uVal,PRECLIST prl,
						LPSYNCMGRSYNCHRONIZECALLBACK pCallBack,SYNCMGRITEMID ItemID);

HRESULT Upd_ShowError(HWND hwndOwner,UINT uVal,UPDCOUNT updcount,LPCTSTR pszList);


int PUBLIC Upd_DoModal(HWND hwndOwner, CBS * pcbs, LPCTSTR pszList, UINT cFiles, UINT uFlags);


#endif // __UPDATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense
   that part of the GUID range owned by OLE was used to define them.

   NOTE: The second byte of all of these GUIDs is 0.
*/


DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\configmg.h ===
/*****************************************************************************
 *
 *	(C) Copyright MICROSOFT Corp., 1993
 *
 *	Title:		CONFIGMG.H - Configuration manager header file
 *
 *	Version:	1.00
 *
 *	Date:		02-Feb-1993
 *
 *	Authors:	PYS & RAL
 *
 *------------------------------------------------------------------------------
 *
 *	Change log:
 *
 *	   DATE     REV DESCRIPTION
 *	----------- --- -----------------------------------------------------------
 *	02-Feb-1993 PYS Original
 *****************************************************************************/

#ifndef _CONFIGMG_H
#define	_CONFIGMG_H

#define	CONFIGMG_VERSION	0x0400

#define	PNPDRVS_Major_Ver	0x0004
#define	PNPDRVS_Minor_Ver	0x0000

#ifdef	MAXDEBUG
#define	CM_PERFORMANCE_INFO
#endif

#ifdef	GOLDEN	
#ifdef	RETAIL
#define	CM_GOLDEN_RETAIL
#endif
#endif

/*XLATOFF*/
#pragma	pack(1)
/*XLATON*/

#ifndef	NORESDES

/****************************************************************************
 *
 *			EQUATES FOR RESOURCE DESCRIPTOR
 *
 *	The equates for resource descriptor work the exact same way as those
 *	for VxD IDs, which is:
 *
 *	Device ID's are a combination of OEM # and device # in the form:
 *
 *		xOOOOOOOOOODDDDD
 *
 *	The high bit of the device ID is reserved for future use.  The next
 *	10 bits are the OEM # which is assigned by Microsoft.  The last 5 bits
 *	are the device #.  This allows each OEM to create 32 unique devices.
 *	If an OEM is creating a replacement for a standard device, then it
 *	should re-use the standard ID listed below.  Microsoft reserves the
 *	first 16 OEM #'s (0 thru 0Fh)
 *
 *	To make your resource ID, you must use the same 10 OEMs bit that
 *	have been given by Microsoft as OEM VxD ID range. You can then tag
 *	any of the 32 unique number in that range (it does not have to be
 *	the same as the VxD as some VxD may have mupltiple arbitrators).
 *
 *	If the ResType_Ignored_Bit is set, the resource is not arbitrated.
 *	You cannot register a handler for such a resource.
 *
 ***************************************************************************/
#define	ResType_All		0x00000000	// Return all resource types.
#define	ResType_None		0x00000000	// Arbitration always succeeded.
#define	ResType_Mem		0x00000001	// Physical address resource.
#define	ResType_IO		0x00000002	// Physical IO address resource.
#define	ResType_DMA		0x00000003	// DMA channels 0-7 resource.
#define	ResType_IRQ		0x00000004	// IRQ 0-15 resource.
#define	ResType_Max		0x00000004	// Max KNOWN ResType (for DEBUG).
#define	ResType_Ignored_Bit	0x00008000	// This resource is to be ignored.

#define	DEBUG_RESTYPE_NAMES \
char	CMFAR *lpszResourceName[ResType_Max+1]= \
{ \
	"All/None", \
	"Mem     ", \
	"IO      ", \
	"DMA     ", \
	"IRQ     ", \
};

/************************************************************************
 *									*
 *	OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,  		*
 *	PLEASE CONTACT MICROSOFT PRODUCT SUPPORT 			*
 *									*
 ************************************************************************/

/****************************************************************************
 *
 * RESOURCE DESCRIPTORS
 *
 *	Each resource descriptor consists of an array of resource requests.
 *	Exactly one element of the array must be satisfied. The data
 *	of each array element is resource specific an described below.
 *	The data may specify one or more resource requests. At least
 *	one element of a Res_Des must be satisfied to satisfy the request
 *	represented by the Res_Des. The values allocated to the Res_Des
 *	are stored within the Res_Des.
 *	Each subarray (OR element) is a single Res_Des followed
 *	by data specific to the type of resource. The data includes the
 *	allocated resource (if any) followed by resource requests (which
 *	will include the values indicated by the allocated resource.
 *
 ***************************************************************************/

/****************************************************************************
 * Memory resource requests consist of ranges of pages
 ***************************************************************************/
#define	MType_Range		sizeof(struct Mem_Range_s)

#define	fMD_MemoryType		1		// Memory range is ROM/RAM
#define	fMD_ROM			0		// Memory range is ROM
#define	fMD_RAM			1		// Memory range is RAM
#define	fMD_32_24		2		// Memory range is 32/24 (for ISAPNP only)
#define	fMD_24			0		// Memory range is 24
#define	fMD_32			2		// Memory range is 32

/* Memory Range descriptor data
 */
struct	Mem_Range_s {
	ULONG			MR_Align;	// Mask for base alignment
	ULONG			MR_nBytes;	// Count of bytes
	ULONG			MR_Min;		// Min Address
	ULONG			MR_Max;		// Max Address
	WORD			MR_Flags;	// Flags
	WORD			MR_Reserved;
};

typedef	struct Mem_Range_s	MEM_RANGE;

/* Mem Resource descriptor header structure
 *	MD_Count * MD_Type bytes of data follow header in an
 *	array of MEM_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the MD_Alloc_... variables.
 *
 *	Example for memory Resource Description:
 *		Mem_Des_s {
 *			MD_Count = 1;
 *			MD_Type = MTypeRange;
 *			MD_Alloc_Base = 0;
 *			MD_Alloc_End = 0;
 *			MD_Flags = 0;
 *			MD_Reserved = 0;
 *			};
 *		Mem_Range_s {
 *			MR_Align = 0xFFFFFF00;	// 256 byte alignment
 *			MR_nBytes = 32;		// 32 bytes needed
 *			MR_Min = 0;
 *			MR_Max = 0xFFFFFFFF;	// Any place in address space
 *			MR_Flags = 0;
 *			MR_Reserved = 0;
 *			};
 */
struct	Mem_Des_s {
	WORD			MD_Count;
	WORD			MD_Type;
	ULONG			MD_Alloc_Base;
	ULONG			MD_Alloc_End;
	WORD			MD_Flags;
	WORD			MD_Reserved;
};

typedef	struct Mem_Des_s 	MEM_DES;

/****************************************************************************
 * IO resource allocations consist of fixed ranges or variable ranges
 *	The Alias and Decode masks provide additional flexibility
 *	in specifying how the address is handled. They provide a convenient
 *	method for specifying what port aliases a card responds to. An alias
 *	is a port address that is responded to as if it were another address.
 *	Additionally, some cards will actually use additional ports for
 *	different purposes, but use a decoding scheme that makes it look as
 *	though it were using aliases. E.G., an ISA card may decode 10 bits
 *	and require port 03C0h. It would need to specify an Alias offset of
 *	04h and a Decode of 3 (no aliases are used as actual ports). For
 *	convenience, the alias field can be set to zero indicate no aliases
 *	are required and then decode is ignored.
 *	If the card were to use the ports at 7C0h, 0BC0h and 0FC0h, where these
 *	ports have different functionality, the Alias would be the same and the
 *	the decode would be 0Fh indicating bits 11 and 12 of the port address
 *	are significant. Thus, the allocation is for all of the ports
 *	(PORT[i] + (n*Alias*256)) & (Decode*256 | 03FFh), where n is
 *	any integer and PORT is the range specified by the nPorts, Min and
 *	Max fields. Note that the minimum Alias is 4 and the minimum
 *	Decode is 3.
 *	Because of the history of the ISA bus, all ports that can be described
 *	by the formula PORT = n*400h + zzzz, where "zzzz" is a port in the
 *	range 100h - 3FFh, will be checked for compatibility with the port
 *	zzzz, assuming that the port zzzz is using a 10 bit decode. If a card
 *	is on a local bus that can prevent the IO address from appearing on
 *	the ISA bus (e.g. PCI), then the logical configuration should specify
 *	an alias of IOA_Local which will prevent the arbitrator from checking
 *	for old ISA bus compatibility.
 */
#define	IOType_Range		sizeof(struct IO_Range_s) // Variable range

/* IO Range descriptor data */
struct	IO_Range_s {
	WORD			IOR_Align;	// Mask for base alignment
	WORD			IOR_nPorts;	// Number of ports
	WORD			IOR_Min;	// Min port address
	WORD			IOR_Max;	// Max port address
	WORD			IOR_RangeFlags;	// Flags
	BYTE			IOR_Alias;	// Alias offset
	BYTE			IOR_Decode;	// Address specified
};

typedef	struct IO_Range_s	IO_RANGE;

/* IO Resource descriptor header structure
 *	IOD_Count * IOD_Type bytes of data follow header in an
 *	array of IO_RANGE structures. When an allocation is made,
 *	the allocated value is stored in the IOD_Alloc_... variables.
 *
 *	Example for IO Resource Description:
 *		IO_Des_s {
 *			IOD_Count = 1;
 *			IOD_Type = IOType_Range;
 *			IOD_Alloc_Base = 0;
 *			IOD_Alloc_End = 0;
 *			IOD_Alloc_Alias = 0;
 *			IOD_Alloc_Decode = 0;
 *			IOD_DesFlags = 0;
 *			IOD_Reserved = 0;
 *			};
 *		IO_Range_s {
 *			IOR_Align = 0xFFF0;	// 16 byte alignment
 *			IOR_nPorts = 16;	// 16 ports required
 *			IOR_Min = 0x0100;
 *			IOR_Max = 0x03FF;	// Anywhere in ISA std ports
 *			IOR_RangeFlags = 0;
 *			IOR_Alias = 0004;	// Standard ISA 10 bit aliasing
 *			IOR_Decode = 0x000F;	// Use first 3 aliases (e.g. if
 *						// 0x100 were base port, 0x500
 *						// 0x900, and 0xD00 would
 *						// also be allocated)
 *			};
 */
struct	IO_Des_s {
	WORD			IOD_Count;
	WORD			IOD_Type;
	WORD			IOD_Alloc_Base;
	WORD			IOD_Alloc_End;
	WORD			IOD_DesFlags;
	BYTE			IOD_Alloc_Alias;
	BYTE			IOD_Alloc_Decode;
};

typedef	struct IO_Des_s 	IO_DES;

/* Definition for special alias value indicating card on PCI or similar local bus
 *  This value should used for the IOR_Alias and IOD_Alias fields
 */
#define	IOA_Local		0xff

/****************************************************************************
 * DMA channel resource allocations consist of one WORD channel bit masks.
 *	The mask indcates alternative channel allocations,
 *	one bit for each alternative (only one is allocated per mask).
 */

/*DMA flags
 *First two are DMA channel width: BYTE, WORD or DWORD
 */
#define	mDD_Width		0003h		// Mask for channel width
#define	fDD_BYTE		0
#define	fDD_WORD		1
#define	fDD_DWORD		2
#define	szDMA_Des_Flags		"WD"

/* DMA Resource descriptor structure
 *
 *	Example for DMA Resource Description:
 *
 *		DMA_Des_s {
 *			DD_Flags = fDD_Byte;	// Byte transfer
 *			DD_Alloc_Chan = 0;
 *			DD_Req_Mask = 0x60;	// Channel 5 or 6
 *			DD_Reserved = 0;
 *			};
 */
struct	DMA_Des_s {
	BYTE			DD_Flags;
	BYTE			DD_Alloc_Chan;	// Channel number allocated
	BYTE			DD_Req_Mask;	// Mask of possible channels
	BYTE			DD_Reserved;
};


typedef	struct DMA_Des_s 	DMA_DES;

/****************************************************************************
 * IRQ resource allocations consist of two WORD IRQ bit masks.
 *	The first mask indcates alternatives for IRQ allocation,
 *	one bit for each alternative (only one is allocated per mask). The
 *	second mask is used to specify that the IRQ can be shared.
 */

/*
 * IRQ flags
 */
#define	fIRQD_Share		1			// IRQ can be shared
#define	cIRQ_Des_Flags		'S'

/* IRQ Resource descriptor structure
 *
 *	Example for IRQ Resource Description:
 *
 *		IRQ_Des_s {
 *			IRQD_Flags = fIRQD_Share	// IRQ can be shared
 *			IRQD_Alloc_Num = 0;
 *			IRQD_Req_Mask = 0x18;		// IRQ 3 or 4
 *			IRQD_Reserved = 0;
 *			};
 */
struct	IRQ_Des_s {
	WORD			IRQD_Flags;
	WORD			IRQD_Alloc_Num;		// Allocated IRQ number
	WORD			IRQD_Req_Mask;		// Mask of possible IRQs
	WORD			IRQD_Reserved;
};

typedef	struct IRQ_Des_s 	IRQ_DES;

/*XLATOFF*/

/****************************************************************************
 *
 * 'C'-only defined total resource structure. Since a resource consists of
 * one resource header followed by an undefined number of resource data
 * structure, we use the undefined array size [] on the *_DATA structure
 * member. Unfortunately, this does not H2INC since the total size of the
 * array cannot be computed from the definition.
 *
 ***************************************************************************/

#pragma warning (disable:4200)			// turn off undefined array size

typedef	MEM_DES			*PMEM_DES;
typedef	MEM_RANGE		*PMEM_RANGE;
typedef	IO_DES			*PIO_DES;
typedef	IO_RANGE		*PIO_RANGE;
typedef	DMA_DES			*PDMA_DES;
typedef	IRQ_DES			*PIRQ_DES;

struct	MEM_Resource_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data[];
};

typedef	struct MEM_Resource_s	MEM_RESOURCE;
typedef	MEM_RESOURCE		*PMEM_RESOURCE;

struct	MEM_Resource1_s {
	MEM_DES			MEM_Header;
	MEM_RANGE		MEM_Data;
};

typedef	struct MEM_Resource1_s	MEM_RESOURCE1;
typedef	MEM_RESOURCE1		*PMEM_RESOURCE1;

#define	SIZEOF_MEM(x)		(sizeof(MEM_DES)+(x)*sizeof(MEM_RANGE))

struct	IO_Resource_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data[];
};

typedef	struct IO_Resource_s	IO_RESOURCE;
typedef	IO_RESOURCE		*PIO_RESOURCE;

struct	IO_Resource1_s {
	IO_DES			IO_Header;
	IO_RANGE		IO_Data;
};

typedef	struct IO_Resource1_s	IO_RESOURCE1;
typedef	IO_RESOURCE1		*PIO_RESOURCE1;

#define	SIZEOF_IORANGE(x)	(sizeof(IO_DES)+(x)*sizeof(IO_RANGE))

struct	DMA_Resource_s {
	DMA_DES			DMA_Header;
};

typedef	struct DMA_Resource_s	DMA_RESOURCE;

#define	SIZEOF_DMA		sizeof(DMA_DES)

struct	IRQ_Resource_s {
	IRQ_DES			IRQ_Header;
};

typedef	struct IRQ_Resource_s	IRQ_RESOURCE;

#define	SIZEOF_IRQ		sizeof(IRQ_DES)

#pragma warning (default:4200)			// turn on undefined array size

/*XLATON*/

#endif	// ifndef NORESDES

#define	LCPRI_FORCECONFIG	0x00000000	// Logical configuration priorities.
#define	LCPRI_BOOTCONFIG	0x00000001
#define	LCPRI_HARDWIRED		0x00001000
#define	LCPRI_DESIRED		0x00002000
#define	LCPRI_NORMAL		0x00003000
#define	LCPRI_LASTBESTCONFIG	0x00003FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_SUBOPTIMAL	0x00005000
#define	LCPRI_LASTSOFTCONFIG	0x00007FFF	// CM ONLY, DO NOT USE.
#define	LCPRI_RESTART		0x00008000
#define	LCPRI_REBOOT		0x00009000
#define	LCPRI_POWEROFF		0x0000A000
#define	LCPRI_HARDRECONFIG	0x0000C000
#define	LCPRI_DISABLED		0x0000FFFF
#define	MAX_LCPRI		0x0000FFFF

#define	MAX_MEM_REGISTERS		9
#define	MAX_IO_PORTS			20
#define	MAX_IRQS			7
#define	MAX_DMA_CHANNELS		7

struct Config_Buff_s {
WORD	wNumMemWindows;			// Num memory windows
DWORD	dMemBase[MAX_MEM_REGISTERS];	// Memory window base
DWORD	dMemLength[MAX_MEM_REGISTERS];	// Memory window length
WORD	wMemAttrib[MAX_MEM_REGISTERS];	// Memory window Attrib
WORD	wNumIOPorts;			// Num IO ports
WORD	wIOPortBase[MAX_IO_PORTS];	// I/O port base
WORD	wIOPortLength[MAX_IO_PORTS];	// I/O port length
WORD	wNumIRQs;			// Num IRQ info
BYTE	bIRQRegisters[MAX_IRQS];	// IRQ list
BYTE	bIRQAttrib[MAX_IRQS];		// IRQ Attrib list
WORD	wNumDMAs;			// Num DMA channels
BYTE	bDMALst[MAX_DMA_CHANNELS];	// DMA list
WORD	wDMAAttrib[MAX_DMA_CHANNELS];	// DMA Attrib list
BYTE	bReserved1[3];			// Reserved
};

typedef	struct Config_Buff_s	CMCONFIG;	// Config buffer info

#ifndef	CMJUSTRESDES

#define	MAX_DEVICE_ID_LEN	200

#include <vmmreg.h>

/*XLATOFF*/

#ifdef	Not_VxD

#include <dbt.h>

#pragma warning(disable:4001)	// Non-standard extensions
#pragma warning(disable:4505)	// Unreferenced local functions

#ifdef	IS_32

#define	CMFAR

#else

#define	CMFAR	

#endif

#else	// Not_VxD

#define	CMFAR

#endif	// Not_VxD

#ifdef	IS_32

typedef	DWORD			RETURN_TYPE;

#else	// IS_32

typedef	WORD			RETURN_TYPE;

#endif	// IS_32

#define	CONFIGMG_Service	Declare_Service
/*XLATON*/

/*MACROS*/
Begin_Service_Table(CONFIGMG, VxD)
CONFIGMG_Service	(_CONFIGMG_Get_Version, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Initialize, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Locate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Parent, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Child, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Sibling, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_ID, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Depth, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_SubTree, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Deregister_Arbitrator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Arbitrator_Free_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Sort_NodeList, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Yield, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Lock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Unlock, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Empty_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_First_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Modify_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Next_Res_Des, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Performance_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Res_Des_Data, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Process_Events_Now, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Create_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Delete_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Test_Range_Available, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dup_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Free_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Invert_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Intersect_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_First_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Next_Range, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Dump_Range_List, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Load_DLVxDs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DDBs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_CRC_CheckSum, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_DevLoader, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reenumerate_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Setup_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Reset_Children_Marks, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Status, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Remove_Unmarked_Children, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_ISAPNP_To_CM, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Device_Driver, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_CallBack_Enumerator, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Alloc_Log_Conf, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key_Size, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_DevNode_Key, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Write_Registry_Value, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Disable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Enable_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Move_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Bus_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Recompute_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Query_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Device_Driver_Private_DWord, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_HW_Prof_Flags, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Read_Registry_Log_Confs, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Run_Detection, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_At_Appy_Time, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Fail_Change_HW_Prof, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Set_Private_Problem, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Debug_DevNode, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Get_Hardware_Profile_Info, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Register_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Call_Enumerator_Function, VxD_CODE)
CONFIGMG_Service	(_CONFIGMG_Add_ID, VxD_CODE)
End_Service_Table(CONFIGMG, VxD)

/*ENDMACROS*/

/*XLATOFF*/

#define	NUM_CM_SERVICES		((WORD)(Num_CONFIGMG_Services & 0xFFFF))

#define	DEBUG_SERVICE_NAMES \
char	CMFAR *lpszServiceName[NUM_CM_SERVICES]= \
{ \
	"Get_Version", \
	"Initialize", \
	"Locate_DevNode", \
	"Get_Parent", \
	"Get_Child", \
	"Get_Sibling", \
	"Get_Device_ID_Size", \
	"Get_Device_ID", \
	"Get_Depth", \
	"Get_Private_DWord", \
	"Set_Private_DWord", \
	"Create_DevNode", \
	"Query_Remove_SubTree", \
	"Remove_SubTree", \
	"Register_Device_Driver", \
	"Register_Enumerator", \
	"Register_Arbitrator", \
	"Deregister_Arbitrator", \
	"Query_Arbitrator_Free_Size", \
	"Query_Arbitrator_Free_Data", \
	"Sort_NodeList", \
	"Yield", \
	"Lock", \
	"Unlock", \
	"Add_Empty_Log_Conf", \
	"Free_Log_Conf", \
	"Get_First_Log_Conf", \
	"Get_Next_Log_Conf", \
	"Add_Res_Des", \
	"Modify_Res_Des", \
	"Free_Res_Des", \
	"Get_Next_Res_Des", \
	"Get_Performance_Info", \
	"Get_Res_Des_Data_Size", \
	"Get_Res_Des_Data", \
	"Process_Events_Now", \
	"Create_Range_List", \
	"Add_Range", \
	"Delete_Range", \
	"Test_Range_Available", \
	"Dup_Range_List", \
	"Free_Range_List", \
	"Invert_Range_List", \
	"Intersect_Range_List", \
	"First_Range", \
	"Next_Range", \
	"Dump_Range_List", \
	"Load_DLVxDs", \
	"Get_DDBs", \
	"Get_CRC_CheckSum", \
	"Register_DevLoader", \
	"Reenumerate_DevNode", \
	"Setup_DevNode", \
	"Reset_Children_Marks", \
	"Get_DevNode_Status", \
	"Remove_Unmarked_Children", \
	"ISAPNP_To_CM", \
	"CallBack_Device_Driver", \
	"CallBack_Enumerator", \
	"Get_Alloc_Log_Conf", \
	"Get_DevNode_Key_Size", \
	"Get_DevNode_Key", \
	"Read_Registry_Value", \
	"Write_Registry_Value", \
	"Disable_DevNode", \
	"Enable_DevNode", \
	"Move_DevNode", \
	"Set_Bus_Info", \
	"Get_Bus_Info", \
	"Set_HW_Prof", \
	"Recompute_HW_Prof", \
	"Query_Change_HW_Prof", \
	"Get_Device_Driver_Private_DWord", \
	"Set_Device_Driver_Private_DWord", \
	"Get_HW_Prof_Flags", \
	"Set_HW_Prof_Flags", \
	"Read_Registry_Log_Confs", \
	"Run_Detection", \
	"Call_At_Appy_Time", \
	"Fail_Change_HW_Prof", \
	"Set_Private_Problem", \
	"Debug_DevNode", \
	"Get_Hardware_Profile_Info", \
	"Register_Enumerator_Function", \
	"Call_Enumerator_Function", \
	"Add_ID", \
};

/*XLATON*/

/****************************************************************************
 *
 *				GLOBALLY DEFINED TYPEDEFS
 *
 ***************************************************************************/
typedef	RETURN_TYPE		CONFIGRET;	// Standardized return value.
typedef	PPVMMDDB		*PPPVMMDDB;	// Too long to describe.
typedef	VOID		CMFAR	*PFARVOID;	// Pointer to a VOID.
typedef	ULONG		CMFAR	*PFARULONG;	// Pointer to a ULONG.
typedef	char		CMFAR	*PFARCHAR;	// Pointer to a string.
typedef	VMMHKEY		CMFAR	*PFARHKEY;	// Pointer to a HKEY.
typedef	char		CMFAR	*DEVNODEID;	// Device ID ANSI name.
typedef	DWORD			LOG_CONF;	// Logical configuration.
typedef	LOG_CONF	CMFAR	*PLOG_CONF;	// Pointer to logical configuration.
typedef	DWORD			RES_DES;	// Resource descriptor.
typedef	RES_DES		CMFAR	*PRES_DES;	// Pointer to resource descriptor.
typedef	DWORD			DEVNODE;	// Devnode.
typedef	DEVNODE		CMFAR	*PDEVNODE;	// Pointer to devnode.
typedef	DWORD			NODELIST;	// Pointer to a nodelist element.
typedef	DWORD			NODELIST_HEADER;// Pointer to a nodelist header.
typedef	DWORD			REGISTERID;	// Arbitartor registration.
typedef	REGISTERID	CMFAR	*PREGISTERID;	// Pointer to arbitartor registration.
typedef	ULONG			RESOURCEID;	// Resource type ID.
typedef	RESOURCEID	CMFAR	*PRESOURCEID;	// Pointer to resource type ID.
typedef	ULONG			PRIORITY;	// Priority number.
typedef	DWORD			RANGE_LIST;	// Range list handle.
typedef	RANGE_LIST	CMFAR	*PRANGE_LIST;	// Pointer to a range list handle.
typedef	DWORD			RANGE_ELEMENT;	// Range list element handle.
typedef	RANGE_ELEMENT	CMFAR	*PRANGE_ELEMENT;// Pointer to a range element handle.
typedef	DWORD			LOAD_TYPE;	// For the loading function.
typedef	CMCONFIG	CMFAR	*PCMCONFIG;	// Pointer to a config buffer info.
typedef	DWORD			CMBUSTYPE;	// Type of the bus.
typedef	CMBUSTYPE	CMFAR	*PCMBUSTYPE;	// Pointer to a bus type.
typedef	double			VMM_TIME;	// Time in microticks.
#define	LODWORD(x)		((DWORD)(x))
#define	HIDWORD(x)		(*(PDWORD)(PDWORD(&x)+1))

typedef	ULONG			CONFIGFUNC;
typedef	ULONG			SUBCONFIGFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMCONFIGHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, ULONG, ULONG);
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMHANDLER)(CONFIGFUNC, SUBCONFIGFUNC, DEVNODE, DEVNODE, ULONG);
typedef	VOID			(CMFAR _cdecl *CMAPPYCALLBACKHANDLER)(ULONG);

typedef	ULONG			ENUMFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMENUMFUNCTION)(ENUMFUNC, ULONG, DEVNODE, PFARVOID, ULONG);

typedef	ULONG			ARBFUNC;
typedef	CONFIGRET		(CMFAR _cdecl *CMARBHANDLER)(ARBFUNC, ULONG, DEVNODE, NODELIST_HEADER);

/****************************************************************************
 *
 *				CONFIGURATION MANAGER BUS TYPE
 *
 ***************************************************************************/
#define	BusType_None		0x00000000
#define	BusType_ISA		0x00000001
#define	BusType_EISA		0x00000002
#define	BusType_PCI		0x00000004
#define	BusType_PCMCIA		0x00000008
#define	BusType_ISAPNP		0x00000010
#define	BusType_MCA		0x00000020

/****************************************************************************
 *
 *				CONFIGURATION MANAGER RETURN VALUES
 *
 ***************************************************************************/
#define	CR_SUCCESS		0x00000000
#define	CR_DEFAULT		0x00000001
#define	CR_OUT_OF_MEMORY	0x00000002
#define	CR_INVALID_POINTER	0x00000003
#define	CR_INVALID_FLAG		0x00000004
#define	CR_INVALID_DEVNODE	0x00000005
#define	CR_INVALID_RES_DES	0x00000006
#define	CR_INVALID_LOG_CONF	0x00000007
#define	CR_INVALID_ARBITRATOR	0x00000008
#define	CR_INVALID_NODELIST	0x00000009
#define	CR_DEVNODE_HAS_REQS	0x0000000A
#define	CR_INVALID_RESOURCEID	0x0000000B
#define	CR_DLVXD_NOT_FOUND	0x0000000C
#define	CR_NO_SUCH_DEVNODE	0x0000000D
#define	CR_NO_MORE_LOG_CONF	0x0000000E
#define	CR_NO_MORE_RES_DES	0x0000000F
#define	CR_ALREADY_SUCH_DEVNODE	0x00000010
#define	CR_INVALID_RANGE_LIST	0x00000011
#define	CR_INVALID_RANGE	0x00000012
#define	CR_FAILURE		0x00000013
#define	CR_NO_SUCH_LOGICAL_DEV	0x00000014
#define	CR_CREATE_BLOCKED	0x00000015
#define	CR_NOT_SYSTEM_VM	0x00000016
#define	CR_REMOVE_VETOED	0x00000017
#define	CR_APM_VETOED		0x00000018
#define	CR_INVALID_LOAD_TYPE	0x00000019
#define	CR_BUFFER_SMALL		0x0000001A
#define	CR_NO_ARBITRATOR	0x0000001B
#define	CR_NO_REGISTRY_HANDLE	0x0000001C
#define	CR_REGISTRY_ERROR	0x0000001D
#define	CR_INVALID_DEVICE_ID	0x0000001E
#define	CR_INVALID_DATA		0x0000001F
#define	CR_INVALID_API		0x00000020
#define	CR_DEVLOADER_NOT_READY	0x00000021
#define	CR_NEED_RESTART		0x00000022
#define	CR_INTERRUPTS_DISABLED	0x00000023
#define	CR_DEVICE_NOT_THERE	0x00000024
#define	CR_NO_SUCH_VALUE	0x00000025
#define	CR_WRONG_TYPE		0x00000026
#define	CR_INVALID_PRIORITY	0x00000027
#define	CR_NOT_DISABLEABLE	0x00000028
#define	CR_NO_MORE_HW_PROFILES	0x00000029
#define	NUM_CR_RESULTS		0x0000002A

/*XLATOFF*/

#define	DEBUG_RETURN_CR_NAMES \
char	CMFAR *lpszReturnCRName[NUM_CR_RESULTS]= \
{ \
	"CR_SUCCESS", \
	"CR_DEFAULT", \
	"CR_OUT_OF_MEMORY", \
	"CR_INVALID_POINTER", \
	"CR_INVALID_FLAG", \
	"CR_INVALID_DEVNODE", \
	"CR_INVALID_RES_DES", \
	"CR_INVALID_LOG_CONF", \
	"CR_INVALID_ARBITRATOR", \
	"CR_INVALID_NODELIST", \
	"CR_DEVNODE_HAS_REQS", \
	"CR_INVALID_RESOURCEID", \
	"CR_DLVXD_NOT_FOUND", \
	"CR_NO_SUCH_DEVNODE", \
	"CR_NO_MORE_LOG_CONF", \
	"CR_NO_MORE_RES_DES", \
	"CR_ALREADY_SUCH_DEVNODE", \
	"CR_INVALID_RANGE_LIST", \
	"CR_INVALID_RANGE", \
	"CR_FAILURE", \
	"CR_NO_SUCH_LOGICAL_DEVICE", \
	"CR_CREATE_BLOCKED", \
	"CR_NOT_SYSTEM_VM", \
	"CR_REMOVE_VETOED", \
	"CR_APM_VETOED", \
	"CR_INVALID_LOAD_TYPE", \
	"CR_BUFFER_SMALL", \
	"CR_NO_ARBITRATOR", \
	"CR_NO_REGISTRY_HANDLE", \
	"CR_REGISTRY_ERROR", \
	"CR_INVALID_DEVICE_ID", \
	"CR_INVALID_DATA", \
	"CR_INVALID_API", \
	"CR_DEVLOADER_NOT_READY", \
	"CR_NEED_RESTART", \
	"CR_INTERRUPTS_DISABLED", \
	"CR_DEVICE_NOT_THERE", \
	"CR_NO_SUCH_VALUE", \
	"CR_WRONG_TYPE", \
	"CR_INVALID_PRIORITY", \
	"CR_NOT_DISABLEABLE", \
	"CR_NO_MORE_HW_PROFILES", \
};

/*XLATON*/

#define	CM_PROB_NOT_CONFIGURED			0x00000001
#define	CM_PROB_DEVLOADER_FAILED		0x00000002
#define	CM_PROB_OUT_OF_MEMORY			0x00000003
#define	CM_PROB_ENTRY_IS_WRONG_TYPE		0x00000004
#define	CM_PROB_LACKED_ARBITRATOR		0x00000005
#define	CM_PROB_BOOT_CONFIG_CONFLICT		0x00000006
#define	CM_PROB_FAILED_FILTER			0x00000007
#define	CM_PROB_DEVLOADER_NOT_FOUND		0x00000008
#define	CM_PROB_INVALID_DATA			0x00000009
#define	CM_PROB_FAILED_START			0x0000000A
#define	CM_PROB_LIAR				0x0000000B
#define	CM_PROB_NORMAL_CONFLICT			0x0000000C
#define	CM_PROB_NOT_VERIFIED			0x0000000D
#define	CM_PROB_NEED_RESTART			0x0000000E
#define	CM_PROB_REENUMERATION			0x0000000F
#define	CM_PROB_PARTIAL_LOG_CONF		0x00000010
#define	CM_PROB_UNKNOWN_RESOURCE		0x00000011
#define	CM_PROB_REINSTALL			0x00000012
#define	CM_PROB_REGISTRY			0x00000013
#define	CM_PROB_VXDLDR				0x00000014
#define	CM_PROB_WILL_BE_REMOVED			0x00000015
#define	CM_PROB_DISABLED			0x00000016
#define	CM_PROB_DEVLOADER_NOT_READY		0x00000017
#define	CM_PROB_DEVICE_NOT_THERE		0x00000018
#define	CM_PROB_MOVED				0x00000019
#define	CM_PROB_TOO_EARLY			0x0000001A
#define	CM_PROB_NO_VALID_LOG_CONF		0x0000001B
#define	NUM_CM_PROB				0x0000001C

/*XLATOFF*/

#define	DEBUG_CM_PROB_NAMES \
char	CMFAR *lpszCMProbName[NUM_CM_PROB]= \
{ \
	"No Problem", \
	"No ConfigFlags (not configured)", \
	"Devloader failed", \
	"Run out of memory", \
	"Devloader/StaticVxD/Configured is of wrong type", \
	"Lacked an arbitrator", \
	"Boot config conflicted", \
	"Filtering failed", \
	"Devloader not found", \
	"Invalid data in registry", \
	"Device failed to start", \
	"Device failed something not failable", \
	"Was normal conflicting", \
	"Did not verified", \
	"Need restart", \
	"Is probably reenumeration", \
	"Was not fully detected", \
	"Resource number was not found", \
	"Reinstall", \
	"Registry returned unknown result", \
	"VxDLdr returned unknown result", \
	"Will be removed", \
	"Disabled", \
	"Devloader was not ready", \
	"Device not there", \
	"Was moved", \
	"Too early", \
	"No valid log conf", \
};

/*XLATON*/

#define	CM_INITIALIZE_VMM			0x00000000
#define	CM_INITIALIZE_VXDLDR			0x00000001
#define	CM_INITIALIZE_BITS			0x00000001

#define	CM_YIELD_NO_RESUME_EXEC			0x00000000
#define	CM_YIELD_RESUME_EXEC			0x00000001
#define	CM_YIELD_BITS				0x00000001

#define	CM_CREATE_DEVNODE_NORMAL		0x00000000
#define	CM_CREATE_DEVNODE_NO_WAIT_INSTALL	0x00000001
#define	CM_CREATE_DEVNODE_BITS			0x00000001

#define	CM_REGISTER_DEVICE_DRIVER_STATIC	0x00000000
#define	CM_REGISTER_DEVICE_DRIVER_DISABLEABLE	0x00000001
#define	CM_REGISTER_DEVICE_DRIVER_REMOVABLE	0x00000002
#define	CM_REGISTER_DEVICE_DRIVER_BITS		0x00000003

#define	CM_REGISTER_ENUMERATOR_SOFTWARE		0x00000000
#define	CM_REGISTER_ENUMERATOR_HARDWARE		0x00000001
#define	CM_REGISTER_ENUMERATOR_BITS		0x00000001

#define	CM_SETUP_DEVNODE_READY			0x00000000
#define	CM_SETUP_DOWNLOAD			0x00000001
#define	CM_SETUP_BITS				0x00000001

#define	CM_ADD_RANGE_ADDIFCONFLICT		0x00000000
#define	CM_ADD_RANGE_DONOTADDIFCONFLICT		0x00000001
#define	CM_ADD_RANGE_BITS			0x00000001

#define	CM_ISAPNP_ADD_RES_DES			0x00000000
#define	CM_ISAPNP_SETUP				0x00000001
#define	CM_ISAPNP_ADD_BOOT_RES_DES		0x00000002
#define	CM_ISAPNP_INVALID			0x00000003
#define	CM_ISAPNP_BITS				0x00000003

#define	CM_GET_PERFORMANCE_INFO_DATA		0x00000000
#define	CM_GET_PERFORMANCE_INFO_RESET		0x00000001
#define	CM_GET_PERFORMANCE_INFO_START		0x00000002
#define	CM_GET_PERFORMANCE_INFO_STOP		0x00000003
#define	CM_RESET_HIT_DATA			0x00000004
#define	CM_GET_HIT_DATA 			0x00000005
#define	CM_GET_PERFORMANCE_INFO_BITS		0x0000000F
#define	CM_HIT_DATA_FILES			0xFFFF0000
#define	CM_HIT_DATA_SIZE			((256*8)+8)  // magic number!

#define	CM_GET_ALLOC_LOG_CONF_ALLOC		0x00000000
#define	CM_GET_ALLOC_LOG_CONF_BOOT_ALLOC	0x00000001
#define	CM_GET_ALLOC_LOG_CONF_BITS		0x00000001

#define	CM_REGISTRY_HARDWARE			0x00000000	// Select hardware branch if NULL subkey
#define	CM_REGISTRY_SOFTWARE			0x00000001	// Select software branch if NULL subkey
#define	CM_REGISTRY_USER			0x00000100	// Use HKEY_CURRENT_USER
#define	CM_REGISTRY_CONFIG			0x00000200	// Use HKEY_CURRENT_CONFIG
#define	CM_REGISTRY_BITS			0x00000301	// The bits for the registry functions

#define	CM_DISABLE_POLITE			0x00000000	// Ask the driver
#define	CM_DISABLE_ABSOLUTE			0x00000001	// Don't ask the driver
#define	CM_DISABLE_BITS				0x00000001	// The bits for the disable function

#define	CM_HW_PROF_UNDOCK			0x00000000	// Computer not in a dock.
#define	CM_HW_PROF_DOCK				0x00000001	// Computer in a docking station
#define	CM_HW_PROF_RECOMPUTE_BITS		0x00000001	// RecomputeConfig
#define	CM_HW_PROF_DOCK_KNOWN			0x00000002	// Computer in a known docking station
#define	CM_HW_PROF_QUERY_CHANGE_BITS		0x00000003	// QueryChangeConfig

#define	CM_DETECT_NEW_PROFILE			0x00000001	// run detect for a new profile
#define	CM_DETECT_CRASHED			0x00000002	// detection crashed before
#define	CM_DETECT_HWPROF_FIRST_BOOT		0x00000004	// first boot in a new profile
#define	CM_DETECT_RUN				0x80000000	// run detection for new hardware

#define	CM_ADD_ID_HARDWARE			0x00000000
#define	CM_ADD_ID_COMPATIBLE			0x00000001
#define	CM_ADD_ID_BITS				0x00000001

#define	CM_REENUMERATE_NORMAL			0x00000000
#define	CM_REENUMERATE_SYNCHRONOUS		0x00000001
#define	CM_REENUMERATE_BITS			0x00000001

/****************************************************************************
 *
 *				CONFIGURATION MANAGER FUNCTIONS
 *
 ****************************************************************************
 * 
 *	Each devnode has a config handler field and a enum handler field
 *	which are getting called every time Configuration Manager wants a
 *	devnode to perform some configuration related function. The handler
 *	is registered with CM_Register_Device_Driver or
 *	CM_Register_Enumerator, depending if the handler is for the device
 *	itself or for one of the children of the devnode.
 *
 *	The registered handler is called with:
 *
 *	result=dnToDevNode->dn_Config(if dnToDevNode==dnAboutDevNode)
 *	result=dnToDevNode->dn_Enum(if dnToDevNode!=dnAboutDevNode)
 *					(	FuncName,
 *					 	SubFuncName,
 *						dnToDevNode,
 *						dnAboutDevNode, (if enum)
 *						dwRefData, (if driver)
 *						ulFlags);
 *	Where:
 *
 *	FuncName is one of CONFIG_FILTER, CONFIG_START, CONFIG_STOP,
 *	CONFIG_TEST, CONFIG_REMOVE, CONFIG_ENUMERATE, CONFIG_SETUP or
 *	CONFIG_CALLBACK.
 *
 *	SubFuncName is the specific CONFIG_xxxx_* that further describe
 *	we START, STOP or TEST.
 *
 *	dnToDevNode is the devnode we are calling. This is given so that
 *	a signle handler can handle multiple devnodes.
 *
 *	dnAboutDevNode specifies which devnode the function is about. For
 *	a config handler, this is necessarily the same as dnToDevNode. For
 *	an enumerator handler, this devnode is necessarily different as it
 *	is a child of the dnToDevNode (special case: CONFIG_ENUMERATE
 *	necessarily has dnAboutDevNode==NULL). For instance, when starting
 *	a COM devnode under a BIOS enumerator, we would make the following
 *	two calls:
 *
 *		To BIOS with (CONFIG_START, ?, BIOS, COM, ?, 0).
 *
 *		To COM with (CONFIG_START, ?, COM, COM, ?, 0).
 *
 *	dwRefData is a dword of reference data. For a config handler, it is
 *	the DWORD passed on the CONFIGMG_Register_Device_Driver call. For an
 *	enumerator, it is the same as CONFIGMG_Get_Private_DWord(?,
 *	dnToDevNode, dnToDevNode, 0).
 *
 *	ulFlags is 0 and is reserved for future extensions.
 *
 *	Here is the explanation of each event, in parenthesis I put the
 *	order the devnodes will be called:
 *
 *	CONFIG_FILTER (BRANCH GOING UP) is the first thing called when a new
 *	insertion or change of configuration need to be processed. First
 *	CM copies the requirement list (BASIC_LOG_CONF) onto the filtered
 *	requirement list (FILTER_LOG_CONF) so that they are originally
 *	the same. CM then calls every node up, giving them the chance to
 *	patch the requirement of the dnAboutDevNode (they can also
 *	alter their own requirement). Examples are PCMCIA which would
 *	remove some IRQ that the adapter can't do, prealloc some IO
 *	windows and memory windows. ISA which would limit address space
 *	to being <16Meg. A device driver should look only at
 *	FILTER_LOG_CONF during this call.
 *
 *	CONFIG_START (BRANCH GOING DOWN) are called to change the
 *	configuration. A config handler/enumerator hander should look
 *	only at the allocated list (ALLOC_LOG_CONF).
 *
 *	CONFIG_STOP (WHOLE TREE BUT ONLY DEVNODES THAT CHANGE
 *	CONFIGURATION (FOR EACH DEVNODE, BRANCH GOING UP)) is called
 *	for two reasons:
 *
 *		1) Just after the rebalance algorithm came up with a
 *		solution and we want to stop all devnodes that will be
 *		rebalance. This is to avoid the problem of having two cards
 *		that can respond to 110h and 220h and that need to toggle
 *		their usage. We do not want two people responding to 220h,
 *		even for a brief amount of time. This is the normal call
 *		though.
 *
 *		2) There was a conflict and the user selected this device
 *		to kill.
 *
 *	CONFIG_TEST (WHOLE TREE) is called before starting the rebalance
 *	algorithm. Device drivers that fail this call will be considered
 *	worst than jumpered configured for the reminder of this balancing
 *	process. 
 *
 *	CONFIG_REMOVE (FOR EACH SUB TREE NODE, DOING BRANCH GOING UP), is
 *	called when someone notify CM via CM_Remove_SubTree that a devnode
 *	is not needed anymore. A static VxD probably has nothing to do. A
 *	dynamic VxD should check whether it should unload itself (return
 *	CR_SUCCESS_UNLOAD) or not (CR_SUCCESS).
 *
 *	Note, failing any of CONFIG_START, or CONFIG_STOP is really bad,
 *	both in terms of performance and stability. Requirements for a
 *	configuration to succeed should be noted/preallocated during
 *	CONFIG_FILTER. Failing CONFIG_TEST is less bad as what basically
 *	happens is that the devnode is considered worst than jumpered
 *	configured for the reminder of this pass of the balancing algorithm.
 *
 *	COMFIG_ENUMERATE, the called node should create children devnodes
 *	using CM_Create_DevNode (but no need for grand children) and remove
 *	children using CM_Remove_SubTree as appropriate. Config Manager
 *	will recurse calling the children until nothing new appears. During
 *	this call, dnAboutDevNode will be NULL. Note that there is an easy
 *	way for buses which do not have direct children accessibility to
 *	detect (ISAPNP for instance will isolate one board at a time and
 *	there is no way to tell one specific board not to participate in
 *	the isolation sequence):
 *
 *	If some children have soft-eject capability, check those first.
 *	If the user is pressing the eject button, call Query_Remove_SubTree
 *	and if that succeed, call Remove_SubTree.
 *
 *	Do a CM_Reset_Children_Marks on the bus devnode.
 *
 *	Do the usual sequence doing CM_Create_DevNode calls. If a devnode
 *	was already there, CR_ALREADY_SUCH_DEVNODE is returned and this
 *	devnode's DN_HAS_MARK will be set. There is nothing more to do with
 *	this devnode has it should just continue running. If the devnode
 *	was not previously there, CR_SUCCESS will be return, in which case
 *	the enumerator should add the logical configurations.
 *
 *	Once all the devnode got created. The enumerator can call
 *	CM_Remove_Unmarked_Children to remove the devnode that are now gone.
 *	Essentially, this is a for loop thru all the children of the bus
 *	devnode, doing Remove_SubTree on the the devnode which have their
 *	mark cleared. Alternatively, an enumerator can use CM_Get_Child,
 *	CM_Get_Sibling, CM_Remove_SubTree and CM_Get_DevNode_Status.
 *
 *	For CONFIG_SETUP, the called node should install drivers if it
 *	know out to get them. This is mostly for drivers imbeded in the
 *	cards (ISA_RTR, PCI or PCMCIA). For most old cards/driver, this
 *	should return CR_NO_DRIVER.
 *
 *	WARNING: For any non-defined service, the enumertor / device
 *	driver handler should return CR_DEFAULT. This will be treated
 *	as the compatibility case in future version.
 *
 *	So normally what happens is as follows:
 *
 *	- Some detection code realize there is a new device. This can be at
 *	initialization time or at run-time (usually during a media_change
 *	interrupt). The code does a CM_Reenumerate_DevNode(dnBusDevNode)
 *	asynchronous call.
 *
 *	- During appy time event, CM gets notified.
 *
 *	- CM calls the enumerator with:
 *
 *		BusEnumHandler(CONFIG_ENUMERATE, 0, dnBusDevNode, NULL, ?, 0);
 *
 *	- The parent uses CM_Create_DevNode and CM_Remove_SubTree as
 *	appropriate, usually for only its immediate children.
 *
 *	- The parent return to CM from the enumerator call.
 *
 *	- CM walks the children, first loading their device driver if
 *	needed, then calling their enumerators. Thus the whole process
 *	will terminate only when all grand-...-grand-children have stopped
 *	using CM_Create_DevNode.
 *
 *	If rebalance is called (a new devnode is conflicting):
 *
 *	- All devnode receives the CONFIG_TEST. Devnodes that
 *	fail it are considered worst than jumpered configured.
 *
 *	- CM does the rebalance algorithm.
 *
 *	- All affected devnodes that where previously loaded get the
 *	CONFIG_STOP event.
 *
 *	- All affected devnode and the new devnodes receives a CONFIG_START.
 *
 *	If rebalancing failed (couldn't make one or more devnodes work):
 *
 *	- Device installer is called which will present the user with a
 *	choice of devnode to kill.
 *
 *	- Those devnodes will received a CONFIG_STOP message.
 *	
 ***************************************************************************/

// Possible CONFIGFUNC FuncNames:

#define	CONFIG_FILTER		0x00000000	// Ancestors must filter requirements.
#define	CONFIG_START		0x00000001	// Devnode dynamic initialization.
#define	CONFIG_STOP		0x00000002	// Devnode must stop using config.
#define	CONFIG_TEST		0x00000003	// Can devnode change state now.
#define	CONFIG_REMOVE		0x00000004	// Devnode must stop using config.
#define	CONFIG_ENUMERATE	0x00000005	// Devnode must enumerated.
#define	CONFIG_SETUP		0x00000006	// Devnode should download driver.
#define	CONFIG_CALLBACK		0x00000007	// Devnode is being called back.
#define	CONFIG_APM		0x00000008	// APM functions.
#define	CONFIG_TEST_FAILED	0x00000009	// Continue as before after a TEST.
#define	CONFIG_TEST_SUCCEEDED	0x0000000A	// Prepare for the STOP/REMOVE.
#define	CONFIG_VERIFY_DEVICE	0x0000000B	// Insure the legacy card is there.
#define	CONFIG_PREREMOVE	0x0000000C	// Devnode must stop using config.
#define	CONFIG_SHUTDOWN		0x0000000D	// We are shutting down.
#define	CONFIG_PREREMOVE2	0x0000000E	// Devnode must stop using config.
#define	CONFIG_READY		0x0000000F	// The devnode has been setup.

#define	NUM_CONFIG_COMMANDS	0x00000010	// For DEBUG.

/*XLATOFF*/

#define	DEBUG_CONFIG_NAMES \
char	CMFAR *lpszConfigName[NUM_CONFIG_COMMANDS]= \
{ \
	"CONFIG_FILTER", \
	"CONFIG_START", \
	"CONFIG_STOP", \
	"CONFIG_TEST", \
	"CONFIG_REMOVE", \
	"CONFIG_ENUMERATE", \
	"CONFIG_SETUP", \
	"CONFIG_CALLBACK", \
	"CONFIG_APM", \
	"CONFIG_TEST_FAILED", \
	"CONFIG_TEST_SUCCEEDED", \
	"CONFIG_VERIFY_DEVICE", \
	"CONFIG_PREREMOVE", \
	"CONFIG_SHUTDOWN", \
	"CONFIG_PREREMOVE2", \
	"CONFIG_READY", \
};

/*XLATON*/

// Possible SUBCONFIGFUNC SubFuncNames:

#define	CONFIG_START_DYNAMIC_START			0x00000000
#define	CONFIG_START_FIRST_START			0x00000001

#define	CONFIG_STOP_DYNAMIC_STOP			0x00000000
#define	CONFIG_STOP_HAS_PROBLEM				0x00000001

//
// For both CONFIG_REMOVE and CONFIG_POSTREMOVE
//
#define	CONFIG_REMOVE_DYNAMIC				0x00000000
#define	CONFIG_REMOVE_SHUTDOWN				0x00000001
#define	CONFIG_REMOVE_REBOOT				0x00000002

#define	CONFIG_TEST_CAN_STOP				0x00000000
#define	CONFIG_TEST_CAN_REMOVE				0x00000001

#define	CONFIG_APM_TEST_STANDBY				0x00000000
#define	CONFIG_APM_TEST_SUSPEND				0x00000001
#define	CONFIG_APM_TEST_STANDBY_FAILED			0x00000002
#define	CONFIG_APM_TEST_SUSPEND_FAILED			0x00000003
#define	CONFIG_APM_TEST_STANDBY_SUCCEEDED		0x00000004
#define	CONFIG_APM_TEST_SUSPEND_SUCCEEDED		0x00000005
#define	CONFIG_APM_RESUME_STANDBY			0x00000006
#define	CONFIG_APM_RESUME_SUSPEND			0x00000007
#define	CONFIG_APM_RESUME_CRITICAL			0x00000008
#define	CONFIG_APM_UI_ALLOWED                  		0x80000000

/****************************************************************************
 *
 *				ARBITRATOR FUNCTIONS
 *
 ****************************************************************************
 *
 *	Each arbitrator has a handler field which is getting called every
 *	time Configuration Manager wants it to perform a function. The
 *	handler is called with:
 *
 *	result=paArbitrator->Arbitrate(	EventName,
 *					paArbitrator->DWordToBePassed,
 *					paArbitrator->dnItsDevNode,
 *					pnlhNodeListHeader);
 *
 *	ENTRY:	NodeListHeader contains a logical configuration for all
 *		devices the configuration manager would like to reconfigure.
 *		DWordToBePassed is the arbitrator reference data.
 *		ItsDevNode is the pointer to arbitrator's devnode.
 *		EventName is one of the following:
 *
 *	ARB_TEST_ALLOC - Test allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. See individual arbitrator for the algorithm
 *		employed. Generally, the arbitration consists
 *		of sorting the list according to most likely succesful
 *		allocation order, making a copy of the current allocation
 *		data strucuture(s), releasing all resource currently
 *		allocated to devnodes on the list from the copy data structure
 *		and then attempting to satisfy allocation requests
 *		by passing through the entire list, trying all possible
 *		combinations of allocations before failing. The arbitrator
 *		saves the resultant successful allocations, both in the node
 *		list per device and the copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_RETEST_ALLOC - Retest allocation of resource
 *
 *	DESC:	The arbitration routine will attempt to satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and attempt to allocate that resource for each allcoation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then attempt to satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_FAILURE if unsuccessful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_FORCE_ALLOC - Retest allocation of resource, always succeed
 *
 *	DESC:	The arbitration routine will satisfy all
 *		allocation requests contained in the nodelist for its
 *		resource. It will take the result of a previous TEST_ALLOC
 *		and allocate that resource for each allocation in
 *		the list. It will not sort the node list. It will make a copy
 *		of the current allocation data strucuture(s), release all
 *		resource currently allocated to devnodes on the list from
 *		the copy data structure and then satisfy the
 *		allocations from the previous TEST_ALLOC. The arbitrator
 *		saves the resultant copy of the allocation data structure.
 *		The configuration manager is expected to subsequently call
 *		either ARB_SET_ALLOC or ARB_RELEASE_ALLOC.
 *
 *	EXIT:	CR_SUCCESS if successful allocation
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_SET_ALLOC - Makes a test allocation the real allocation
 *
 *	DESC:	Makes the copy of the allocation data structure the
 *		current valid allocation.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_RELEASE_ALLOC - Clean up after failed test allocation
 *
 *	DESC:	Free all allocation that were allocated by the previous
 *		ARB_TEST_ALLOC.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	ARB_QUERY_FREE - Add all free resource logical configuration
 *
 *	DESC:	Return resource specific data on the free element. Note
 *		than the pnlhNodeListHeader is a cast of an arbitfree_s.
 *
 *	EXIT:	CR_SUCCESS if successful
 *		CR_FAILURE if the request makles no sense.
 *		CR_OUT_OF_MEMORY if not enough memory.
 *
 *	ARB_REMOVE - The devnode the arbitrator registered with is going away
 *
 *	DESC:	Arbitrator registered with a non-NULL devnode (thus is
 *		normally local), and the devnode is being removed. Arbitrator
 *		should do appropriate cleanup.
 *
 *	EXIT:	CR_SUCCESS
 *
 *	WARNING: For any non-defined service, the arbitrator should return
 *	CR_DEFAULT. This will be treated as the compatibility case in future
 *	version.
 *
 ***************************************************************************/
#define	ARB_TEST_ALLOC		0x00000000	// Check if can make alloc works.
#define	ARB_RETEST_ALLOC	0x00000001	// Check if can take previous alloc.
#define	ARB_SET_ALLOC		0x00000002	// Set the tested allocation.
#define	ARB_RELEASE_ALLOC	0x00000003	// Release the tested allocation.
#define	ARB_QUERY_FREE		0x00000004	// Return free resource.
#define	ARB_REMOVE		0x00000005	// DevNode is gone.
#define	ARB_FORCE_ALLOC		0x00000006	// Force previous TEST_ALLOC
#define	NUM_ARB_COMMANDS	0x00000007	// Number of arb commands

#define	DEBUG_ARB_NAMES \
char	CMFAR *lpszArbFuncName[NUM_ARB_COMMANDS]= \
{ \
	"ARB_TEST_ALLOC",\
	"ARB_RETEST_ALLOC",\
	"ARB_SET_ALLOC",\
	"ARB_RELEASE_ALLOC",\
	"ARB_QUERY_FREE",\
	"ARB_REMOVE",\
	"ARB_FORCE_ALLOC",\
};

/****************************************************************************
 *
 *				DEVNODE STATUS
 *
 ****************************************************************************
 *
 *	These are the bits in the devnode's status that someone can query
 *	with a CM_Get_DevNode_Status. The A/S column tells wheter the flag
 *	cann be change asynchronously or not.
 *
 ***************************************************************************/
#define	DN_ROOT_ENUMERATED	0x00000001	// S: Was enumerated by ROOT
#define	DN_DRIVER_LOADED	0x00000002	// S: Has Register_Device_Driver
#define	DN_ENUM_LOADED		0x00000004	// S: Has Register_Enumerator
#define	DN_STARTED		0x00000008	// S: Is currently configured
#define	DN_MANUAL		0x00000010	// S: Manually installed
#define	DN_NEED_TO_ENUM		0x00000020	// A: May need reenumeration
#define	DN_NOT_FIRST_TIME	0x00000040	// S: Has received a config
#define	DN_HARDWARE_ENUM	0x00000080	// S: Enum generates hardware ID
#define	DN_LIAR 		0x00000100	// S: Lied about can reconfig once
#define	DN_HAS_MARK		0x00000200	// S: Not CM_Create_DevNode lately
#define	DN_HAS_PROBLEM		0x00000400	// S: Need device installer
#define	DN_FILTERED		0x00000800	// S: Is filtered
#define	DN_MOVED		0x00001000	// S: Has been moved
#define	DN_DISABLEABLE		0x00002000	// S: Can be rebalanced
#define	DN_REMOVABLE		0x00004000	// S: Can be removed
#define	DN_PRIVATE_PROBLEM	0x00008000	// S: Has a private problem
#define	DN_MF_PARENT		0x00010000	// S: Multi function parent
#define	DN_MF_CHILD		0x00020000	// S: Multi function child
#define	DN_WILL_BE_REMOVED	0x00040000	// S: Devnode is being removed

/*XLATOFF*/

#define	NUM_DN_FLAG		0x00000013	// DEBUG: maximum flag (number)
#define	DN_FLAG_LEN		0x00000002	// DEBUG: flag length

#define	DEBUG_DN_FLAGS_NAMES \
char	CMFAR lpszDNFlagsName[NUM_DN_FLAG][DN_FLAG_LEN]= \
{ \
	"rt", \
	"dl", \
	"el", \
	"st", \
	"mn", \
	"ne", \
	"fs", \
	"hw", \
	"lr", \
	"mk", \
	"pb", \
	"ft", \
	"mv", \
	"db", \
	"rb", \
	"pp", \
	"mp", \
	"mc", \
	"rm", \
};

struct vmmtime_s {
DWORD		vmmtime_lo;
DWORD		vmmtime_hi;
};

typedef	struct vmmtime_s	VMMTIME;
typedef	VMMTIME			*PVMMTIME;

struct cmtime_s {
DWORD		dwAPICount;
VMMTIME		vtAPITime;
};

typedef	struct cmtime_s		CMTIME;
typedef	CMTIME			*PCMTIME;

struct cm_performance_info_s {
CMTIME		ctBoot;
CMTIME		ctAPI[NUM_CM_SERVICES];
CMTIME		ctRing3;
CMTIME		ctProcessTree;
CMTIME		ctAssignResources;
CMTIME		ctSort;
CMTIME		ctRegistry;
CMTIME		ctVxDLdr;
CMTIME		ctNewDevNode;
CMTIME		ctSendMessage;
CMTIME		ctShell;
CMTIME		ctReceiveMessage;
CMTIME		ctAppyTime;
CMTIME		ctConfigMessage[NUM_CONFIG_COMMANDS];
CMTIME		ctArbTime[ResType_Max+1][NUM_ARB_COMMANDS];
DWORD		dwStackSize;
DWORD		dwMaxProcessTreePasses;
DWORD		dwStackAlloc;
};

typedef	struct	cm_performance_info_s	CMPERFINFO;
typedef	CMPERFINFO		CMFAR	*PCMPERFINFO;

/*XLATON*/

/****************************************************************************
 *
 *				DLVXD FUNCTIONS
 *
 ****************************************************************************
 *
 *	We load a Dynamically loaded VxD when there is a DEVLOADER=... line
 *	in the registry, or when someone calls CM_Load_Device. We then do
 *	a direct system control call (PNP_NEW_DEVNODE) to it, telling the
 *	DLVXD whether we loaded it to be an enumerator, a driver or a
 *	devloader (config manager does only deal with devloaders, but the
 *	default devloaders does CM_Load_Device with DLVXD_LOAD_ENUMERATOR
 *	and DLVXD_LOAD_DRIVER).
 *
 ***************************************************************************/
#define	DLVXD_LOAD_ENUMERATOR	0x00000000	// We loaded DLVxD as an enumerator.
#define	DLVXD_LOAD_DEVLOADER	0x00000001	// We loaded DLVxD as a devloader.
#define	DLVXD_LOAD_DRIVER	0x00000002	// We loaded DLVxD as a device driver.
#define	NUM_DLVXD_LOAD_TYPE	0x00000003	// Number of DLVxD load type.

/****************************************************************************
 *
 *				GLOBALLY DEFINED FLAGS
 *
 ***************************************************************************/
#define	ARB_GLOBAL		0x00000001	// Arbitrator is global.
#define	ARB_LOCAL		0x00000000	// Arbitrator is local.
#define	ARB_SCOPE_BIT		0x00000001	// Arbitrator is global/local bit.

#define	BASIC_LOG_CONF		0x00000000	// Specifies the req list.
#define	FILTERED_LOG_CONF	0x00000001	// Specifies the filtered req list.
#define	ALLOC_LOG_CONF		0x00000002	// Specifies the Alloc Element.
#define	BOOT_LOG_CONF		0x00000003	// Specifies the RM Alloc Element.
#define	FORCED_LOG_CONF		0x00000004	// Specifies the Forced Log Conf
#define	NUM_LOG_CONF		0x00000005	// Number of Log Conf type
#define	LOG_CONF_BITS		0x00000007	// The bits of the log conf type.

#define	DEBUG_LOG_CONF_NAMES \
char	CMFAR *lpszLogConfName[NUM_LOG_CONF]= \
{ \
	"BASIC_LOG_CONF",\
	"FILTERED_LOG_CONF",\
	"ALLOC_LOG_CONF",\
	"BOOT_LOG_CONF",\
	"FORCED_LOG_CONF",\
};

#define	PRIORITY_EQUAL_FIRST	0x00000008	// Same priority, new one is first.
#define	PRIORITY_EQUAL_LAST	0x00000000	// Same priority, new one is last.
#define	PRIORITY_BIT		0x00000008	// The bit of priority.

#ifndef	Not_VxD

/****************************************************************************
 *
 * Arbitration list structures
 *
 ***************************************************************************/
struct	nodelist_s {
	struct nodelist_s	*nl_Next;		// Next node element
	struct nodelist_s	*nl_Previous;		// Previous node element
	struct devnode_s	*nl_ItsDevNode;		// The dev node it represent

	// You can add fields to this structure, but the first three
	// fields must NEVER be changed.

	struct Log_Conf 	*nl_Test_Req;		// Test resource alloc request
	ULONG			nl_ulSortDWord;		// Specifies the sort order
};

struct	nodelistheader_s {
	struct	nodelist_s	*nlh_Head;		// First node element
	struct	nodelist_s	*nlh_Tail;		// Last node element
};

struct	arbitfree_s {
	PVOID			*af_PointerToInfo;	// the arbitrator info
	ULONG			af_SizeOfInfo;		// size of the info
};

#endif

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for memory returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken memory address space.
 */
struct	MEM_Arb_s {
	RANGE_LIST		MEMA_Alloc;
};

typedef	struct MEM_Arb_s	MEMA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for IO returns a Range List (see
 *	configuration manager for APIs to use with Range Lists). The values
 *	in the Range List are ranges of taken IO address space.
 */
struct	IO_Arb_s {
	RANGE_LIST		IOA_Alloc;
};

typedef	struct IO_Arb_s		IOA_ARB;

/****************************************************************************
 * ARB_QUERY_FREE arbitrator function for DMA returns the DMA_Arb_s,
 *	16 bits of allocation bit mask, where DMAA_Alloc is inverted
 *	(set bit indicates free port).
 */
struct	DMA_Arb_s {
	WORD			DMAA_Alloc;
};

typedef	struct DMA_Arb_s	DMA_ARB;

/***************************************************************************
 * ARB_QUERY_FREE arbitrator function for IRQ returns the IRQ_Arb_s,
 *	16 bits of allocation bit mask, 16 bits of share bit mask and 16
 *	BYTES of share count. IRQA_Alloc is inverted (bit set indicates free
 *	port). If port is not free, IRQA_Share bit set indicates port
 *	that is shareable. For shareable IRQs, IRQA_Share_Count indicates
 *	number of devices that are sharing an IRQ.
 */
struct	IRQ_Arb_s {
	WORD			IRQA_Alloc;
	WORD			IRQA_Share;
	BYTE			IRQA_Share_Count[16];
};

typedef	struct IRQ_Arb_s	IRQ_ARB;

/* ASM
DebugCommand	Macro	FuncName
		local	DC_01
ifndef	CM_GOLDEN_RETAIL
ifdef	retail
 	IsDebugOnlyLoaded	DC_01
endif
	Control_Dispatch	DEBUG_QUERY, FuncName, sCall
endif
DC_01:
endm
IFDEF CM_PERFORMANCE_INFO
CM_PAGEABLE_CODE_SEG	TEXTEQU	<VxD_LOCKED_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU	<VxD_LOCKED_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_LOCKED_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_LOCKED_DATA_ENDS>
ELSE
CM_PAGEABLE_CODE_SEG	TEXTEQU <VxD_PNP_CODE_SEG>
CM_PAGEABLE_CODE_ENDS	TEXTEQU <VxD_PNP_CODE_ENDS>
CM_PAGEABLE_DATA_SEG	TEXTEQU	<VxD_PAGEABLE_DATA_SEG>
CM_PAGEABLE_DATA_ENDS	TEXTEQU	<VxD_PAGEABLE_DATA_ENDS>
ENDIF
*/

struct	CM_API_s {
DWORD		pCMAPIStack;
DWORD		dwCMAPIService;
DWORD		dwCMAPIRet;
};

typedef	struct	CM_API_s	CMAPI;

/*XLATOFF*/

#define	CM_VXD_RESULT		int

#define	CM_EXTERNAL		_cdecl
#define	CM_HANDLER		_cdecl
#define	CM_SYSCTRL		_stdcall
#define	CM_GLOBAL_DATA
#define	CM_LOCAL_DATA		static

#define	CM_OFFSET_OF(type, id)	((DWORD)(&(((type)0)->id)))


#if	DEBLEVEL==DEBLEVELRETAIL

#define	CM_WARN(strings)
#define	CM_ERROR(strings)

#else

#if	DEBLEVEL==DEBLEVELNORMAL

#define	CM_WARN(strings)
#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#else

#define	CM_WARN(strings) {\
	_Debug_Printf_Service(WARNNAME " WARNS: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n");}

#define	CM_ERROR(strings) {\
	_Debug_Printf_Service(WARNNAME " ERROR: "); \
	_Debug_Printf_Service##strings; \
	_Debug_Printf_Service("\n"); \
	{_asm	int	3}}
#endif

#endif

#ifdef	DEBUG
#define	CM_DEBUG_CODE		VxD_LOCKED_CODE_SEG
#define	CM_DEBUG_DATA		VxD_LOCKED_DATA_SEG
#else
#define	CM_DEBUG_CODE		VxD_DEBUG_ONLY_CODE_SEG
#define	CM_DEBUG_DATA		VxD_DEBUG_ONLY_DATA_SEG
#endif

#ifdef	CM_PERFORMANCE_INFO

#define	CM_PAGEABLE_CODE	VxD_LOCKED_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_LOCKED_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG
#define	CURSEG()		LCODE

#else

#define	CM_PAGEABLE_CODE	VxD_PNP_CODE_SEG
#define	CM_PAGEABLE_DATA	VxD_PAGEABLE_DATA_SEG
#define	CM_INIT_CODE		VxD_INIT_CODE_SEG
#define	CM_INIT_DATA		VxD_INIT_DATA_SEG

#pragma warning (disable:4005)			// turn off redefinition

#define	CURSEG()		CCODE

#pragma warning (default:4005)			// turn on redefinition

#endif

#ifndef	MAX_PROFILE_LEN
#define	MAX_PROFILE_LEN	80
#endif

struct	HWProfileInfo_s {
ULONG	HWPI_ulHWProfile;			// the profile handle
char	HWPI_szFriendlyName[MAX_PROFILE_LEN];	// the friendly name
DWORD	HWPI_dwFlags;				// CM_HWPI_* flags
};

typedef	struct	HWProfileInfo_s	       HWPROFILEINFO;
typedef	struct	HWProfileInfo_s	      *PHWPROFILEINFO;
typedef	struct	HWProfileInfo_s	CMFAR *PFARHWPROFILEINFO;

#define	CM_HWPI_NOT_DOCKABLE	0x00000000
#define	CM_HWPI_UNDOCKED	0x00000001
#define	CM_HWPI_DOCKED		0x00000002

#ifdef	DEBUG

#define	CM_INTERNAL		_cdecl

#else

#define	CM_INTERNAL		_fastcall

#endif

#define	CM_NAKED		__declspec ( naked )
#define	CM_LOCAL		CM_INTERNAL
#define	CM_UNIQUE		static CM_INTERNAL

#define	CM_BEGIN_CRITICAL {\
_asm	pushfd	\
_asm	cli	\
}

#define	CM_END_CRITICAL \
_asm	popfd\

#define	CM_FOREVER		for (;;)

#ifndef	No_CM_Calls

#ifdef	Not_VxD

/****************************************************************************
 *
 *	CONFIGMG_Get_Entry_Point - Return the address to call to get in
 *				   Config Manager.
 *
 *	Exported.
 *
 *	ENTRY:	None.
 *
 *	EXIT:	None.
 *
 *	On return, the variable CMEntryPoint has been updated with the
 *	proper address to call to get to Configuration Manager.
 *
 ***************************************************************************/
DWORD static
CM_Get_Entry_Point(void)
{
	static	DWORD		CMEntryPoint=NULL;

	if (CMEntryPoint)
		return(CMEntryPoint);

	_asm	push	bx
	_asm	push	es
	_asm	push	di
	_asm	xor	di, di

	_asm	mov	ax, 0x1684
	_asm	mov	bx, 0x33
	_asm	mov	es, di
	_asm	int	0x2f

	_asm	mov	word ptr [CMEntryPoint+2], es
	_asm	mov	word ptr [CMEntryPoint], di

	_asm	pop	di
	_asm	pop	es
	_asm	pop	bx

	return(CMEntryPoint);
}

#define	MAKE_CM_HEADER(Function, Parameters) \
CONFIGRET static _near _cdecl \
CM_##Function##Parameters \
{ \
	CONFIGRET	CMRetValue=0; \
	DWORD		CMEntryPoint; \
	WORD		wCMAPIService=GetVxDServiceOrdinal(_CONFIGMG_##Function); \
	if ((CMEntryPoint=CM_Get_Entry_Point())==0) \
		return(0); \
	_asm	{mov	ax, wCMAPIService};\
	_asm	{call	CMEntryPoint}; \
	_asm	{mov	CMRetValue, ax};\
	return(CMRetValue); \
}

#else	// Not_VxD

#define	MAKE_CM_HEADER(Function, Parameters) \
MAKE_HEADER(CONFIGRET, _cdecl, CAT(_CONFIGMG_, Function), Parameters)

#endif	// Not_VxD

/****************************************************************************
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 * Each of the following functions must match their equivalent service
 * and the parameter table in dos386\vmm\configmg\services.*.
 *
 * Except for the Get_Version, each function return a CR_* result in EAX
 * (AX for non IS_32 app) and can trash ECX and/or EDX as they are 'C'
 * callable.
 *
 * WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING! WARNING!
 *
 ***************************************************************************/

#pragma warning (disable:4100)		// Param not used

#ifdef	Not_VxD

MAKE_CM_HEADER(Get_Version, (VOID))

#else

WORD VXDINLINE
CONFIGMG_Get_Version(VOID)
{
	WORD	w;
	VxDCall(_CONFIGMG_Get_Version);
	_asm mov [w], ax
	return(w);
}

#endif

MAKE_CM_HEADER(Initialize, (ULONG ulFlags))
MAKE_CM_HEADER(Locate_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Parent, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Child, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Sibling, (PDEVNODE pdnDevNode, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID_Size, (PFARULONG pulLen, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_ID, (DEVNODE dnDevNode, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Get_Depth, (PFARULONG pulDepth, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Private_DWord, (PFARULONG pulPrivate, DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_DWord, (DEVNODE dnInDevNode, DEVNODE dnForDevNode, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Create_DevNode, (PDEVNODE pdnDevNode, DEVNODEID pDeviceID, DEVNODE dnParent, ULONG ulFlags))
MAKE_CM_HEADER(Query_Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Remove_SubTree, (DEVNODE dnAncestor, ULONG ulFlags))
MAKE_CM_HEADER(Register_Device_Driver, (DEVNODE dnDevNode, CMCONFIGHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator, (DEVNODE dnDevNode, CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Register_Arbitrator, (PREGISTERID pRid, RESOURCEID id, CMARBHANDLER Handler, ULONG ulDWordToBePassed, DEVNODE dnArbitratorNode, ULONG ulFlags))
MAKE_CM_HEADER(Deregister_Arbitrator, (REGISTERID id, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Size, (PFARULONG pulSize, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Query_Arbitrator_Free_Data, (PFARVOID pData, ULONG DataLen, DEVNODE dnDevNode, RESOURCEID ResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Sort_NodeList, (NODELIST_HEADER nlhNodeListHeader, ULONG ulFlags))
MAKE_CM_HEADER(Yield, (ULONG ulMicroseconds, ULONG ulFlags))
MAKE_CM_HEADER(Lock, (ULONG ulFlags))
MAKE_CM_HEADER(Unlock, (ULONG ulFlags))
MAKE_CM_HEADER(Add_Empty_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, PRIORITY Priority, ULONG ulFlags))
MAKE_CM_HEADER(Free_Log_Conf, (LOG_CONF lcLogConfToBeFreed, ULONG ulFlags))
MAKE_CM_HEADER(Get_First_Log_Conf, (PLOG_CONF plcLogConf, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Log_Conf, (PLOG_CONF plcLogConf, LOG_CONF lcLogConf, ULONG ulFlags))
MAKE_CM_HEADER(Add_Res_Des, (PRES_DES prdResDes, LOG_CONF lcLogConf, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Modify_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, RESOURCEID ResourceID, PFARVOID ResourceData, ULONG ResourceLen, ULONG ulFlags))
MAKE_CM_HEADER(Free_Res_Des, (PRES_DES prdResDes, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Next_Res_Des, (PRES_DES prdResDes, RES_DES CurrentResDesOrLogConf, RESOURCEID ForResource, PRESOURCEID pResourceID, ULONG ulFlags))
MAKE_CM_HEADER(Get_Performance_Info, (PCMPERFINFO pPerfInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data_Size, (PFARULONG pulSize, RES_DES rdResDes, ULONG ulFlags))
MAKE_CM_HEADER(Get_Res_Des_Data, (RES_DES rdResDes, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Process_Events_Now, (ULONG ulFlags))
MAKE_CM_HEADER(Create_Range_List, (PRANGE_LIST prlh, ULONG ulFlags))
MAKE_CM_HEADER(Add_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Delete_Range, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Test_Range_Available, (ULONG ulStartValue, ULONG ulEndValue, RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Dup_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(Free_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Invert_Range_List, (RANGE_LIST rlhOld, RANGE_LIST rlhNew, ULONG ulMaxVal, ULONG ulFlags))
MAKE_CM_HEADER(Intersect_Range_List, (RANGE_LIST rlhOld1, RANGE_LIST rlhOld2, RANGE_LIST rlhNew, ULONG ulFlags))
MAKE_CM_HEADER(First_Range, (RANGE_LIST rlh, PFARULONG pulStart, PFARULONG pulEnd, PRANGE_ELEMENT preElement, ULONG ulFlags))
MAKE_CM_HEADER(Next_Range, (PRANGE_ELEMENT preElement, PFARULONG pulStart, PFARULONG pulEnd, ULONG ulFlags))
MAKE_CM_HEADER(Dump_Range_List, (RANGE_LIST rlh, ULONG ulFlags))
MAKE_CM_HEADER(Load_DLVxDs, (DEVNODE dnDevNode, PFARCHAR FileNames, LOAD_TYPE LoadType, ULONG ulFlags))
MAKE_CM_HEADER(Get_DDBs, (PPPVMMDDB ppDDB, PFARULONG pulCount, LOAD_TYPE LoadType, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_CRC_CheckSum, (PFARVOID pBuffer, ULONG ulSize, PFARULONG pulSeed, ULONG ulFlags))
MAKE_CM_HEADER(Register_DevLoader, (PVMMDDB pDDB, ULONG ulFlags))
MAKE_CM_HEADER(Reenumerate_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Setup_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Reset_Children_Marks, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Status, (PFARULONG pulStatus, PFARULONG pulProblemNumber, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Remove_Unmarked_Children, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(ISAPNP_To_CM, (PFARVOID pBuffer, DEVNODE dnDevNode, ULONG ulLogDev, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Device_Driver, (CMCONFIGHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(CallBack_Enumerator, (CMENUMHANDLER Handler, ULONG ulFlags))
MAKE_CM_HEADER(Get_Alloc_Log_Conf, (PCMCONFIG pccBuffer, DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key_Size, (PFARULONG pulLen, DEVNODE dnDevNode, PFARCHAR pszSubKey, ULONG ulFlags))
MAKE_CM_HEADER(Get_DevNode_Key, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARVOID Buffer, ULONG BufferLen, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulExpectedType, PFARVOID pBuffer, PFARULONG pulLength, ULONG ulFlags))
MAKE_CM_HEADER(Write_Registry_Value, (DEVNODE dnDevNode, PFARCHAR pszSubKey, PFARCHAR pszValueName, ULONG ulType, PFARVOID pBuffer, ULONG ulLength, ULONG ulFlags))
MAKE_CM_HEADER(Disable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Enable_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Move_DevNode, (DEVNODE dnFromDevNode, DEVNODE dnToDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Set_Bus_Info, (DEVNODE dnDevNode, CMBUSTYPE btBusType, ULONG ulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Bus_Info, (DEVNODE dnDevNode, PCMBUSTYPE pbtBusType, PFARULONG pulSizeOfInfo, PFARVOID pInfo, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof, (ULONG ulConfig, ULONG ulFlags))
MAKE_CM_HEADER(Recompute_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Query_Change_HW_Prof, (ULONG ulDock, ULONG ulSerialNo, ULONG ulFlags))
MAKE_CM_HEADER(Get_Device_Driver_Private_DWord, (DEVNODE dnDevNode, PFARULONG pulDWord, ULONG ulFlags))
MAKE_CM_HEADER(Set_Device_Driver_Private_DWord, (DEVNODE dnDevNode, ULONG ulDword, ULONG ulFlags))
MAKE_CM_HEADER(Get_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, PFARULONG pulValue, ULONG ulFlags))
MAKE_CM_HEADER(Set_HW_Prof_Flags, (PFARCHAR szDevNodeName, ULONG ulConfig, ULONG ulValue, ULONG ulFlags))
MAKE_CM_HEADER(Read_Registry_Log_Confs, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Run_Detection, (ULONG ulFlags))
MAKE_CM_HEADER(Call_At_Appy_Time, (CMAPPYCALLBACKHANDLER Handler, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Fail_Change_HW_Prof, (ULONG ulFlags))
MAKE_CM_HEADER(Set_Private_Problem, (DEVNODE dnDevNode, ULONG ulRefData, ULONG ulFlags))
MAKE_CM_HEADER(Debug_DevNode, (DEVNODE dnDevNode, ULONG ulFlags))
MAKE_CM_HEADER(Get_Hardware_Profile_Info, (ULONG ulIndex, PFARHWPROFILEINFO pHWProfileInfo, ULONG ulFlags))
MAKE_CM_HEADER(Register_Enumerator_Function, (DEVNODE dnDevNode, CMENUMFUNCTION Handler, ULONG ulFlags))
MAKE_CM_HEADER(Call_Enumerator_Function, (DEVNODE dnDevNode, ENUMFUNC efFunc, ULONG ulRefData, PFARVOID pBuffer, ULONG ulBufferSize, ULONG ulFlags))
MAKE_CM_HEADER(Add_ID, (DEVNODE dnDevNode, PFARCHAR pszID, ULONG ulFlags))

#pragma warning (default:4100)		// Param not used

#endif	// ifndef No_CM_Calls

/*XLATON*/

#endif	// ifndef CMJUSTRESDES

#endif	// _CONFIGMG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\comctrlp.h ===
/*****************************************************************************\
*                                                                             *
* commctrl.h - - Interface for the Windows Common Controls                    *
*                                                                             *
* Version 1.2                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

/*REVIEW: this stuff needs Windows style in many places; find all REVIEWs. */

#ifndef _INC_COMCTRLP
#define _INC_COMCTRLP
#ifndef NOUSER

#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NOBTNLIST    A control which is a list of bitmap buttons.
//
//=============================================================================

#if defined (WINNT) || defined (WINNT_ENV)
#include <prshtp.h>
#endif
#define ICC_ALL_CLASSES      0x000007FF //
WINCOMMCTRLAPI LRESULT WINAPI SendNotify(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr);
WINCOMMCTRLAPI LRESULT WINAPI SendNotifyEx(HWND hwndTo, HWND hwndFrom, int code, NMHDR FAR* pnmhdr, BOOL bUnicode);
#define NM_STARTWAIT            (NM_FIRST-9)
#define NM_ENDWAIT              (NM_FIRST-10)
#define NM_BTNCLK               (NM_FIRST-11)
// Message Filter Proc codes - These are defined above MSGF_USER
/////                           0x00000001  // don't use because some apps return 1 for all notifies
#define CDRF_VALIDFLAGS         0x000000F6   //


#define SSI_DEFAULT ((UINT)-1)


#define SSIF_SCROLLPROC    0x0001
#define SSIF_MAXSCROLLTIME 0x0002
#define SSIF_MINSCROLL     0x0003

typedef int (CALLBACK *PFNSMOOTHSCROLLPROC)(    HWND hWnd,
    int dx,
    int dy,
    CONST RECT *prcScroll,
    CONST RECT *prcClip ,
    HRGN hrgnUpdate,
    LPRECT prcUpdate,
    UINT flags);


typedef struct tagSSWInfo{
    UINT cbSize;
    DWORD fMask;
    HWND hwnd;
    int dx;
    int dy;
    LPCRECT lprcSrc;
    LPCRECT lprcClip;
    HRGN hrgnUpdate;
    LPRECT lprcUpdate;
    UINT fuScroll;

    UINT uMaxScrollTime;
    UINT cxMinScroll;
    UINT cyMinScroll;

    PFNSMOOTHSCROLLPROC pfnScrollProc;  // we'll call this back instead
} SMOOTHSCROLLINFO, *PSMOOTHSCROLLINFO;

WINCOMMCTRLAPI INT  WINAPI SmoothScrollWindow(PSMOOTHSCROLLINFO pssi);

#define SSW_EX_NOTIMELIMIT      0x00010000
#define SSW_EX_IMMEDIATE        0x00020000
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll



// ================ READER MODE ================

typedef BOOL (CALLBACK *PFNREADERSCROLL)(struct tagReaderModeInfo*, int, int);
typedef BOOL (CALLBACK *PFNREADERTRANSLATEDISPATCH)(LPMSG);
typedef struct tagReaderModeInfo
{
    UINT cbSize;
    HWND hwnd;
    DWORD fFlags;
    LPRECT prc;
    PFNREADERSCROLL pfnScroll;
    PFNREADERTRANSLATEDISPATCH pfnTranslateDispatch;

    LPARAM lParam;
} READERMODEINFO, *PREADERMODEINFO;

#define RMF_ZEROCURSOR          0x00000001
#define RMF_VERTICALONLY        0x00000002
#define RMF_HORIZONTALONLY      0x00000004

#define RM_SCROLLUNIT 20

WINCOMMCTRLAPI void WINAPI DoReaderMode(PREADERMODEINFO prmi);

// Cursors and Bitmaps used by ReaderMode
#ifdef RC_INVOKED
#define IDC_VERTICALONLY        109
#define IDC_HORIZONTALONLY      110
#define IDC_MOVE2D              111
#define IDC_NORTH               112
#define IDC_SOUTH               113
#define IDC_EAST                114
#define IDC_WEST                115
#define IDC_NORTHEAST           116
#define IDC_NORTHWEST           117
#define IDC_SOUTHEAST           118
#define IDC_SOUTHWEST           119

#define IDB_2DSCROLL    132
#define IDB_VSCROLL     133
#define IDB_HSCROLL     134
#else
#define IDC_VERTICALONLY        MAKEINTRESOURCE(109)
#define IDC_HORIZONTALONLY      MAKEINTRESOURCE(110)
#define IDC_MOVE2D              MAKEINTRESOURCE(111)
#define IDC_NORTH               MAKEINTRESOURCE(112)
#define IDC_SOUTH               MAKEINTRESOURCE(113)
#define IDC_EAST                MAKEINTRESOURCE(114)
#define IDC_WEST                MAKEINTRESOURCE(115)
#define IDC_NORTHEAST           MAKEINTRESOURCE(116)
#define IDC_NORTHWEST           MAKEINTRESOURCE(117)
#define IDC_SOUTHEAST           MAKEINTRESOURCE(118)
#define IDC_SOUTHWEST           MAKEINTRESOURCE(119)

#define IDB_2DSCROLL    MAKEINTRESOURCE(132)
#define IDB_VSCROLL     MAKEINTRESOURCE(133)
#define IDB_HSCROLL     MAKEINTRESOURCE(134)
#endif
#define ILC_COLORMASK           0x00FE
#define ILC_SHARED              0x0100      // this is a shareable image list
#define ILC_LARGESMALL          0x0200      // (not implenented) contains both large and small images
#define ILC_UNIQUE              0x0400      // (not implenented) makes sure no dup. image exists in list
#define ILC_VIRTUAL             0x8000      // enables ImageList_SetFilter
#define ILC_VALID   (ILC_MASK | ILC_COLORMASK | ILC_SHARED | ILC_PALETTE | ILC_VIRTUAL)   // legal implemented flags
#define ILD_BLENDMASK           0x000E
#define ILD_BLEND75             0x0008   // not implemented
#define OVERLAYMASKTOINDEX(i)   ((((i) >> 8) & (ILD_OVERLAYMASK >> 8))-1)
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetIconSize(HIMAGELIST himl, int FAR *cx, int FAR *cy);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_GetImageRect(HIMAGELIST himl, int i, RECT FAR* prcImage);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawEx(HIMAGELIST himl, int i, HDC hdcDst, int x, int y, int dx, int dy, COLORREF rgbBk, COLORREF rgbFg, UINT fStyle);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_DrawIndirect(IMAGELISTDRAWPARAMS* pimldp);
WINCOMMCTRLAPI BOOL        WINAPI ImageList_Remove(HIMAGELIST himl, int i);
#define ILCF_VALID  (ILCF_SWAP)
typedef BOOL (CALLBACK *PFNIMLFILTER)(HIMAGELIST *, int *, LPARAM, BOOL);
WINCOMMCTRLAPI BOOL WINAPI ImageList_SetFilter(HIMAGELIST himl, PFNIMLFILTER pfnFilter, LPARAM lParamFilter);
#define HDS_VERT                0x0001  
#define HDS_SHAREDIMAGELISTS    0x0000
#define HDS_PRIVATEIMAGELISTS   0x0010
#define HDS_OWNERDATA           0x0020
#define HDI_ALL                 0x00Bf
/* REVIEW: index, command, flag words, resource ids should be UINT */
/* REVIEW: is this internal? if not, call it TBCOLORMAP, prefix tbc */
#define CMB_DISCARDABLE         0x01    
/*REVIEW: TBSTATE_* should be TBF_* (for Flags) */
/* Messages up to WM_USER+8 are reserved until we define more state bits */
/* Messages up to WM_USER+16 are reserved until we define more state bits */
#define IDB_STD_SMALL_MONO      2       /*  not supported yet */
#define IDB_STD_LARGE_MONO      3       /*  not supported yet */
#define IDB_VIEW_SMALL_MONO     6       /*  not supported yet */
#define IDB_VIEW_LARGE_MONO     7       /*  not supported yet */
#define HIST_LAST               4  //
#define TB_SETBUTTONTYPE        (WM_USER + 34)
#ifdef _WIN32
#define TB_ADDBITMAP32          (WM_USER + 38)
#endif
#define TBBF_MONO               0x0002  /* not supported yet */
#ifndef _WIN32
// for compatibility with the old 16 bit WM_COMMAND hacks
typedef struct _ADJUSTINFO {
    TBBUTTON tbButton;
    char szDescription[1];
} ADJUSTINFO, NEAR* PADJUSTINFO, FAR* LPADJUSTINFO;
#define TBN_BEGINDRAG           0x0201
#define TBN_ENDDRAG             0x0203
#define TBN_BEGINADJUST         0x0204
#define TBN_ADJUSTINFO          0x0205
#define TBN_ENDADJUST           0x0206
#define TBN_RESET               0x0207
#define TBN_QUERYINSERT         0x0208
#define TBN_QUERYDELETE         0x0209
#define TBN_TOOLBARCHANGE       0x020a
#define TBN_CUSTHELP            0x020b
#endif

#define RBS_VALID       (RBS_TOOLTIPS | RBS_VARHEIGHT | RBS_BANDBORDERS)
#define RBBS_DRAGBREAK  0x80000000  //
#define TTF_STRIPACCELS         0x0008       // (this is implicit now)
#define TTF_UNICODE             0x0040       // Unicode Notify's
#define TTF_MEMALLOCED          0x0200
// SBS_* styles need to not overlap with CCS_* values

#define SB_SETBORDERS           (WM_USER+5)
// Warning +11-+13 are used in the unicode stuff above!
/*REVIEW: is this internal? */
/*/////////////////////////////////////////////////////////////////////////*/

#ifndef NOBTNLIST

/*REVIEW: should be BUTTONLIST_CLASS */
#define BUTTONLISTBOX           "ButtonListBox"

/* Button List Box Styles */
#define BLS_NUMBUTTONS          0x00FF
#define BLS_VERTICAL            0x0100
#define BLS_NOSCROLL            0x0200

/* Button List Box Messages */
#define BL_ADDBUTTON            (WM_USER+1)
#define BL_DELETEBUTTON         (WM_USER+2)
#define BL_GETCARETINDEX        (WM_USER+3)
#define BL_GETCOUNT             (WM_USER+4)
#define BL_GETCURSEL            (WM_USER+5)
#define BL_GETITEMDATA          (WM_USER+6)
#define BL_GETITEMRECT          (WM_USER+7)
#define BL_GETTEXT              (WM_USER+8)
#define BL_GETTEXTLEN           (WM_USER+9)
#define BL_GETTOPINDEX          (WM_USER+10)
#define BL_INSERTBUTTON         (WM_USER+11)
#define BL_RESETCONTENT         (WM_USER+12)
#define BL_SETCARETINDEX        (WM_USER+13)
#define BL_SETCURSEL            (WM_USER+14)
#define BL_SETITEMDATA          (WM_USER+15)
#define BL_SETTOPINDEX          (WM_USER+16)
#define BL_MSGMAX               (WM_USER+17)

/* Button listbox notification codes send in WM_COMMAND */
#define BLN_ERRSPACE            (-2)
#define BLN_SELCHANGE           1
#define BLN_CLICKED             2
#define BLN_SELCANCEL           3
#define BLN_SETFOCUS            4
#define BLN_KILLFOCUS           5

/* Message return values */
#define BL_OKAY                 0
#define BL_ERR                  (-1)
#define BL_ERRSPACE             (-2)

/* Create structure for                    */
/* BL_ADDBUTTON and                        */
/* BL_INSERTBUTTON                         */
/*   lpCLB = (LPCREATELISTBUTTON)lParam    */
typedef struct tagCREATELISTBUTTON {
    UINT        cbSize;     /* size of structure */
    DWORD       dwItemData; /* user defined item data */
                            /* for LB_GETITEMDATA and LB_SETITEMDATA */
    HBITMAP     hBitmap;    /* button bitmap */
    LPCSTR      lpszText;   /* button text */

} CREATELISTBUTTON, FAR* LPCREATELISTBUTTON;

#endif /* NOBTNLIST */
//=============================================================================
/*REVIEW: these match the SB_ (scroll bar messages); define them that way? */

//
// Unnecessary to create a A and W version
// of this string since it is only passed
// to RegisterWindowMessage.
//
#define PBS_SHOWPERCENT         0x01
#define PBS_SHOWPOS             0x02


#define CCS_NOHILITE            0x00000010L
#define LVS_PRIVATEIMAGELISTS   0x0000
#define LVS_ALIGNBOTTOM         0x0400
#define LVS_ALIGNRIGHT          0x0c00
#define LVIF_ALL                0x001f
#define LVIF_VALID              0x081f
#define LVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff
#define LVIS_DISABLED           0x0010   // GOING AWAY
#define LVIS_LINK               0x0040
#define LVIS_USERMASK           LVIS_STATEIMAGEMASK  
#define LVIS_ALL                0xFFFF
#define STATEIMAGEMASKTOINDEX(i) ((i & LVIS_STATEIMAGEMASK) >> 12)
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define LVNI_PREVIOUS           0x0020
#define LVFI_SUBSTRING          0x0004
#define LVFI_NOCASE             0x0010
// the following #define's must be packed sequentially.
#define LVIR_MAX                4
#define LVA_ALIGNRIGHT          0x0003
#define LVA_ALIGNBOTTOM         0x0004
#define LVA_ALIGNMASK           0x0007
#define LVA_SORTASCENDING       0x0100
#define LVA_SORTDESCENDING      0x0200
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define LVCF_ALL                0x003f
#define LVN_ENDDRAG             (LVN_FIRST-10)
#define LVN_ENDRDRAG            (LVN_FIRST-12)
#ifdef PW2
#define LVN_PEN                 (LVN_FIRST-20)
#endif
#define TVIF_ALL                0x007F
#define TVIF_RESERVED           0xf000  // all bits in high nibble is for notify specific stuff
#define TVIS_FOCUSED            0x0001  // Never implemented
#define TVIS_DISABLED           0        // GOING AWAY
#define TVIS_ALL                0xFF7E
    // all items above this line were for win95.  don't touch them.
    // all items above this line were for win95.  don't touch them.
#define TVE_ACTIONMASK          0x0003      //  (TVE_COLLAPSE | TVE_EXPAND | TVE_TOGGLE)
#define TV_FINDITEM             (TV_FIRST + 3)  
#define CBEN_ITEMCHANGED        (CBEN_FIRST - 3)  //
#define TCS_SHAREIMAGELISTS     0x0000
#define TCS_PRIVATEIMAGELISTS   0x0000
#define TCM_GETBKCOLOR          (TCM_FIRST + 0)
#define TabCtrl_GetBkColor(hwnd)  (COLORREF)SNDMSG((hwnd), TCM_GETBKCOLOR, 0, 0L)
#define TCM_SETBKCOLOR          (TCM_FIRST + 1)
#define TabCtrl_SetBkColor(hwnd, clrBk)  (BOOL)SNDMSG((hwnd), TCM_SETBKCOLOR, 0, (LPARAM)(COLORREF)(clrBk))
#define TCIF_ALL                0x001f
#define MCSC_COLORCOUNT   6   //
// NOTE: this was MCN_FIRST + 2 but I changed it when I changed the structre //
#define MCS_VALIDBITS       0x000F          //
#define MCS_INVALIDBITS     ((~MCS_VALIDBITS) & 0x0000FFFF) //
#define DTS_VALIDBITS       0x003F //
#define DTS_INVALIDBITS     ((~DTS_VALIDBITS) & 0x0000FFFF) //

#ifndef NO_COMMCTRL_SHLWAPI
#ifdef NO_COMMCTRL_STRFCNS
#define NO_SHLWAPI_STRFCNS
#endif

#define NO_SHLWAPI_PATH

// For backward compatibility, we include shlwapi.h implicitly
// because some components don't know we've moved some things
// to that header.
#include <shlwapi.h>
#if defined(WINNT) || defined(WINNT_ENV)
#include <shlwapip.h>
#endif
#endif

#ifndef NO_COMMCTRL_DA
//====== Dynamic Array routines ==========================================
// Dynamic structure array
typedef struct _DSA FAR* HDSA;

WINCOMMCTRLAPI HDSA   WINAPI DSA_Create(int cbItem, int cItemGrow);
WINCOMMCTRLAPI BOOL   WINAPI DSA_Destroy(HDSA hdsa);
WINCOMMCTRLAPI BOOL   WINAPI DSA_GetItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI LPVOID WINAPI DSA_GetItemPtr(HDSA hdsa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_SetItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI int    WINAPI DSA_InsertItem(HDSA hdsa, int i, void FAR* pitem);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteItem(HDSA hdsa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DSA_DeleteAllItems(HDSA hdsa);
#define       DSA_GetItemCount(hdsa) (*(int FAR*)(hdsa))

// Dynamic pointer array
typedef struct _DPA FAR* HDPA;

WINCOMMCTRLAPI HDPA   WINAPI DPA_Create(int cItemGrow);
WINCOMMCTRLAPI HDPA   WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Destroy(HDPA hdpa);
WINCOMMCTRLAPI HDPA   WINAPI DPA_Clone(HDPA hdpa, HDPA hdpaNew);
WINCOMMCTRLAPI LPVOID WINAPI DPA_GetPtr(HDPA hdpa, int i);
WINCOMMCTRLAPI int    WINAPI DPA_GetPtrIndex(HDPA hdpa, LPVOID p);
WINCOMMCTRLAPI BOOL   WINAPI DPA_Grow(HDPA pdpa, int cp);
WINCOMMCTRLAPI BOOL   WINAPI DPA_SetPtr(HDPA hdpa, int i, LPVOID p);
WINCOMMCTRLAPI int    WINAPI DPA_InsertPtr(HDPA hdpa, int i, LPVOID p);
WINCOMMCTRLAPI LPVOID WINAPI DPA_DeletePtr(HDPA hdpa, int i);
WINCOMMCTRLAPI BOOL   WINAPI DPA_DeleteAllPtrs(HDPA hdpa);
#define       DPA_GetPtrCount(hdpa)   (*(int FAR*)(hdpa))
#define       DPA_GetPtrPtr(hdpa)     (*((LPVOID FAR* FAR*)((BYTE FAR*)(hdpa) + sizeof(int))))
#define       DPA_FastGetPtr(hdpa, i) (DPA_GetPtrPtr(hdpa)[i])

typedef int (CALLBACK *PFNDPACOMPARE)(LPVOID p1, LPVOID p2, LPARAM lParam);

WINCOMMCTRLAPI BOOL   WINAPI DPA_Sort(HDPA hdpa, PFNDPACOMPARE pfnCompare, LPARAM lParam);

// Search array.  If DPAS_SORTED, then array is assumed to be sorted
// according to pfnCompare, and binary search algorithm is used.
// Otherwise, linear search is used.
//
// Searching starts at iStart (-1 to start search at beginning).
//
// DPAS_INSERTBEFORE/AFTER govern what happens if an exact match is not
// found.  If neither are specified, this function returns -1 if no exact
// match is found.  Otherwise, the index of the item before or after the
// closest (including exact) match is returned.
//
// Search option flags
//
#define DPAS_SORTED             0x0001
#define DPAS_INSERTBEFORE       0x0002
#define DPAS_INSERTAFTER        0x0004

WINCOMMCTRLAPI int WINAPI DPA_Search(HDPA hdpa, LPVOID pFind, int iStart,
                      PFNDPACOMPARE pfnCompare,
                      LPARAM lParam, UINT options);

//======================================================================
// String management helper routines

WINCOMMCTRLAPI int  WINAPI Str_GetPtrA(LPCSTR psz, LPSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI int  WINAPI Str_GetPtrW(LPCWSTR psz, LPWSTR pszBuf, int cchBuf);
WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrA(CHAR FAR* UNALIGNED * ppsz, LPCSTR psz);
WINCOMMCTRLAPI BOOL WINAPI Str_SetPtrW(WCHAR FAR* UNALIGNED * ppsz, LPCWSTR psz);

#ifdef UNICODE
#define Str_GetPtr              Str_GetPtrW
#define Str_SetPtr              Str_SetPtrW
#else
#define Str_GetPtr              Str_GetPtrA
#define Str_SetPtr              Str_SetPtrA
#endif

#endif // NO_COMMCTRL_DA

#ifndef NO_COMMCTRL_ALLOCFCNS
//====== Memory allocation functions ===================

#ifdef _WIN32
#define _huge
#endif

WINCOMMCTRLAPI void _huge* WINAPI Alloc(long cb);
WINCOMMCTRLAPI void _huge* WINAPI ReAlloc(void _huge* pb, long cb);
WINCOMMCTRLAPI BOOL        WINAPI Free(void _huge* pb);
WINCOMMCTRLAPI DWORD       WINAPI GetSize(void _huge* pb);

#endif


#ifndef _SIZE_T_DEFINED
#define _SIZE_T_DEFINED
typedef unsigned int size_t;
#endif

#ifdef _WIN32
//===================================================================
typedef int (CALLBACK *MRUCMPPROCA)(LPCSTR, LPCSTR);
typedef int (CALLBACK *MRUCMPPROCW)(LPCWSTR, LPCWSTR);

#ifdef UNICODE
#define MRUCMPPROC              MRUCMPPROCW
#else
#define MRUCMPPROC              MRUCMPPROCA
#endif

// NB This is cdecl - to be compatible with the crts.
typedef int (cdecl FAR *MRUCMPDATAPROC)(const void FAR *, const void FAR *,
                                        size_t);



typedef struct _MRUINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPPROCA lpfnCompare;
} MRUINFOA, FAR *LPMRUINFOA;

typedef struct _MRUINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPPROCW lpfnCompare;
} MRUINFOW, FAR *LPMRUINFOW;

typedef struct _MRUDATAINFOA {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOA, FAR *LPMRUDATAINFOA;

typedef struct _MRUDATAINFOW {
    DWORD cbSize;
    UINT uMax;
    UINT fFlags;
    HKEY hKey;
    LPCWSTR lpszSubKey;
    MRUCMPDATAPROC lpfnCompare;
} MRUDATAINFOW, FAR *LPMRUDATAINFOW;


#ifdef UNICODE
#define MRUINFO                 MRUINFOW
#define LPMRUINFO               LPMRUINFOW
#define MRUDATAINFO             MRUDATAINFOW
#define LPMRUDATAINFO           LPMRUDATAINFOW
#else
#define MRUINFO                 MRUINFOA
#define LPMRUINFO               LPMRUINFOA
#define MRUDATAINFO             MRUDATAINFOA
#define LPMRUDATAINFO           LPMRUDATAINFOA
#endif

#define MRU_BINARY              0x0001
#define MRU_CACHEWRITE          0x0002
#define MRU_ANSI                0x0004


WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListA(LPMRUINFOA lpmi);
WINCOMMCTRLAPI HANDLE WINAPI CreateMRUListW(LPMRUINFOW lpmi);
WINCOMMCTRLAPI void   WINAPI FreeMRUList(HANDLE hMRU);
WINCOMMCTRLAPI int    WINAPI AddMRUStringA(HANDLE hMRU, LPCSTR szString);
WINCOMMCTRLAPI int    WINAPI AddMRUStringW(HANDLE hMRU, LPCWSTR szString);
WINCOMMCTRLAPI int    WINAPI DelMRUString(HANDLE hMRU, int nItem);
WINCOMMCTRLAPI int    WINAPI FindMRUStringA(HANDLE hMRU, LPCSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI FindMRUStringW(HANDLE hMRU, LPCWSTR szString, LPINT lpiSlot);
WINCOMMCTRLAPI int    WINAPI EnumMRUListA(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen);
WINCOMMCTRLAPI int    WINAPI EnumMRUListW(HANDLE hMRU, int nItem, LPVOID lpData, UINT uLen);

WINCOMMCTRLAPI int    WINAPI AddMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData);
WINCOMMCTRLAPI int    WINAPI FindMRUData(HANDLE hMRU, const void FAR *lpData, UINT cbData,
                          LPINT lpiSlot);

#ifdef UNICODE
#define CreateMRUList           CreateMRUListW
#define AddMRUString            AddMRUStringW
#define FindMRUString           FindMRUStringW
#define EnumMRUList             EnumMRUListW
#else
#define CreateMRUList           CreateMRUListA
#define AddMRUString            AddMRUStringA
#define FindMRUString           FindMRUStringA
#define EnumMRUList             EnumMRUListA
#endif

#endif

//=========================================================================
// for people that just gotta use GetProcAddress()

#ifdef _WIN32
#define DPA_CreateORD           328
#define DPA_DestroyORD          329
#define DPA_GrowORD             330
#define DPA_CloneORD            331
#define DPA_GetPtrORD           332
#define DPA_GetPtrIndexORD      333
#define DPA_InsertPtrORD        334
#define DPA_SetPtrORD           335
#define DPA_DeletePtrORD        336
#define DPA_DeleteAllPtrsORD    337
#define DPA_SortORD             338
#define DPA_SearchORD           339
#define DPA_CreateExORD         340
#define SendNotifyORD           341
#define CreatePageORD           163
#define CreateProxyPageORD      164
#endif
#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL) //
//====== SetPathWordBreakProc  ======================================
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet);

#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif

#endif  // _INC_COMMCTRLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#undef Assert
#undef AssertE
#undef AssertMsg
#undef DebugMsg
#undef FullDebugMsg

// Debug mask APIs

// NOTE: You can #define your own DM_* values using bits in the HI BYTE
#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions
#define DM_ALLOC    0x0010      // trace/show allocations
#define DM_REG      0x0020      // Registry calls

// NOTE: Default debug mask is 0x00ff (show everything)
//
// Inside debugger, you can modify wDebugMask variable.
//
// Set debug mask; returning previous.
//
UINT WINAPI SetDebugMask(UINT mask);

// Get debug mask.
//
UINT WINAPI GetDebugMask();

#ifndef WIN32
#if (defined(BUILDDLL) && !defined(ASSERTSEG))
#define ASSERTSEG _based(_segname("_ERRTEXT"))
#endif

#ifndef ASSERTSEG
#define ASSERTSEG _based(_segname("_CODE"))
#endif
#else
#define ASSERTSEG
#endif

// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR ASSERTSEG sz[] = msg;

#ifndef NOSHELLDEBUG    // Others have own versions of these.
#ifdef DEBUG

// Assert(f)  -- Generate "assertion failed in line x of file.c"
//               message if f is NOT true.
//
// AssertMsg(f, msg, args...)  -- Generate wsprintf-formatted msg w/params
//                          if f is NOT true.
//
// DebugMsg(mask, msg, args...) -
//         Generate wsprintf-formatted msg using
//         specified debug mask.  System debug mask
//         governs whether message is output.
//
void WINAPI AssertFailed(LPCTSTR szFile, int line);
#define Assert(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f))                                 \
            AssertFailed(szFile, __LINE__);       \
    }
#define AssertE(f) Assert(f)

void __cdecl _AssertMsg(BOOL f, LPCTSTR pszMsg, ...);
#define AssertMsg   _AssertMsg

void __cdecl _DebugMsg(UINT mask, LPCTSTR psz, ...);
#define DebugMsg    _DebugMsg

#ifdef FULL_DEBUG
#define FullDebugMsg    _DebugMsg
#else
#define FullDebugMsg    1 ? (void)0 : (void)
#endif

#else

#define Assert(f)
#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)
#define FullDebugMsg    1 ? (void)0 : (void)

#endif
#endif // NOSHELLDEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\brfguidp.h ===
//
//  brfguidp.h
//

// Briefcase Extension OLE object class ID.  This is different
// from the CLSID_Briefcase, which is the container CLSID.  We
// have two separate CLSIDs because they exist in two DLLs: 
// SYNCUI and SHELL232.
//
DEFINE_GUID(CLSID_BriefcaseExt, 0x0B399E01L, 0x0129, 0x101B, 0x9A, 0x4B, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\deballoc.c ===
//====================================================================
// Debugging memory problems.
//====================================================================

#undef LocalAlloc
#undef LocalReAlloc
#undef LocalFree

#define CBALLOCEXTRA        (sizeof(LPARAM)+sizeof(UINT))
#define HMEM2PTR(hMem,i)    (((BYTE*)hMem)+i)

void _StoreSigniture(HLOCAL hMem, UINT uByte, LPARAM lParam)
{
    if (hMem)
    {
        UINT uSize = LocalSize(hMem);
        Assert(uSize>=uByte+CBALLOCEXTRA);
        *(UNALIGNED UINT *)HMEM2PTR(hMem, uSize-sizeof(UINT)) = uByte;
        *(UNALIGNED LPARAM *)HMEM2PTR(hMem, uByte) = lParam;
        _DebugMsg( DM_ALLOC, TEXT("_StoreSig: %x ==> uByte = 0x%x, lParam = 0x%x"), hMem, uByte, lParam );
    }
}

UINT _ValidateLocalMem(HLOCAL hMem, LPARAM lParam, LPCTSTR pszText)
{
    UINT uByte = 0;
    if (hMem)
    {
        UINT uSize = LocalSize(hMem);
        if (uSize)
        {
            LPARAM lParamStored;
            uByte = *(UNALIGNED UINT *)HMEM2PTR(hMem, uSize-sizeof(UINT));
            AssertMsg(uByte+CBALLOCEXTRA <= uSize,
                      TEXT("cm ASSERT! Bogus uByte %x (%x, %x) (%s for %x)"),
                      uByte, uByte+CBALLOCEXTRA, uSize, pszText, hMem);
            lParamStored = *(UNALIGNED LPARAM *)HMEM2PTR(hMem, uByte);
            AssertMsg( lParamStored==lParam,
                       TEXT("cm ASSERT! Bad Signiture %x!=%x (%s for %x)"),
                       lParamStored, lParam, pszText, hMem
                      );
        }
        else
        {
            AssertMsg( uSize!=0,
                       TEXT("cm ASSERT! LocalSize is zero (%s for %x)"),
                       pszText, hMem
                      );
        }
    }
    return uByte;
}

HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes)
{
    HLOCAL hMem;
    _DebugMsg(DM_ALLOC,TEXT("DbgLocalAlloc( size=0x%x )..."),uBytes);
    hMem = LocalAlloc(uFlags, (uBytes+CBALLOCEXTRA));
    _StoreSigniture(hMem, uBytes, (LPARAM)hMem);
    _DebugMsg(DM_ALLOC,TEXT("DbgLocalAlloc( size=0x%x ) returning %x, size=0x%x"),uBytes,hMem,(uBytes+CBALLOCEXTRA));
    return hMem;
}

HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags)
{
    HLOCAL hMemSave = hMem;
    _DebugMsg(DM_ALLOC,TEXT("DbgLocalReAlloc( hMem=%x, size=0x%x )..."),hMem,uBytes);
    _ValidateLocalMem(hMem, (LPARAM)hMem, TEXT("LocalReAlloc"));
    hMem = LocalReAlloc(hMem, uBytes+CBALLOCEXTRA, uFlags);
    _StoreSigniture(hMem, uBytes, (LPARAM)hMem);
    _DebugMsg(DM_ALLOC,TEXT("DbgLocalReAlloc( hMem=%x, size=0x%x ) returning %x, size=0x%x"),hMemSave,uBytes,hMem,(uBytes+CBALLOCEXTRA));
    return hMem;
}

HLOCAL WINAPI DebugLocalFree( HLOCAL hMem )
{
    UINT uBytes;
    _DebugMsg(DM_ALLOC,TEXT("DbgLocalFree( hMem=%x )..."),hMem);
    uBytes = _ValidateLocalMem(hMem, (LPARAM)hMem, TEXT("LocalFree"));
    if (uBytes)
    {
        _StoreSigniture(hMem, uBytes, (LPARAM)0xDEADDEAD);
        _fmemset(hMem, 0xE5, uBytes);
    }
    return LocalFree(hMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\deballoc.h ===
#pragma message("### Building FULL_DEBUG version ###")

// Clear out any prior definitions
#ifdef LocalAlloc
#undef LocalAlloc
#endif

#ifdef LocalReAlloc
#undef LocalReAlloc
#endif

#ifdef LocalFree
#undef LocalFree
#endif

//Redefine to be our debug allocators

#define LocalAlloc      DebugLocalAlloc
#define LocalReAlloc    DebugLocalReAlloc
#define LocalFree       DebugLocalFree
HLOCAL WINAPI DebugLocalAlloc(UINT uFlags, UINT uBytes);
HLOCAL WINAPI DebugLocalReAlloc(HLOCAL hMem, UINT uBytes, UINT uFlags);
HLOCAL WINAPI DebugLocalFree( HLOCAL hMem );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\debugstr.h ===
/*
 * debugstr.h - Debug message strings.
 */


#ifdef DEBUG

/* TWINRESULT strings */

/*
 * N.b., this array of strings must match the TWINRESULTs defined in synceng.h.
 * The index of the pointer to the string corresponding to a TWINRESULT tr may
 * be determined as rgcpcszTwinResult[tr].
 */

CONST LPCTSTR rgcpcszTwinResult[] =
{
   TEXT("TR_SUCCESS"),
   TEXT("TR_RH_LOAD_FAILED"),
   TEXT("TR_SRC_OPEN_FAILED"),
   TEXT("TR_SRC_READ_FAILED"),
   TEXT("TR_DEST_OPEN_FAILED"),
   TEXT("TR_DEST_WRITE_FAILED"),
   TEXT("TR_ABORT"),
   TEXT("TR_UNAVAILABLE_VOLUME"),
   TEXT("TR_OUT_OF_MEMORY"),
   TEXT("TR_FILE_CHANGED"),
   TEXT("TR_DUPLICATE_TWIN"),
   TEXT("TR_DELETED_TWIN"),
   TEXT("TR_HAS_FOLDER_TWIN_SRC"),
   TEXT("TR_INVALID_PARAMETER"),
   TEXT("TR_REENTERED"),
   TEXT("TR_SAME_FOLDER"),
   TEXT("TR_SUBTREE_CYCLE_FOUND"),
   TEXT("TR_NO_MERGE_HANDLER"),
   TEXT("TR_MERGE_INCOMPLETE"),
   TEXT("TR_TOO_DIFFERENT"),
   TEXT("TR_BRIEFCASE_LOCKED"),
   TEXT("TR_BRIEFCASE_OPEN_FAILED"),
   TEXT("TR_BRIEFCASE_READ_FAILED"),
   TEXT("TR_BRIEFCASE_WRITE_FAILED"),
   TEXT("TR_CORRUPT_BRIEFCASE"),
   TEXT("TR_NEWER_BRIEFCASE"),
   TEXT("TR_NO_MORE")
};

/* CREATERECLISTPROCMSG strings */

/*
 * N.b., this array of strings must match the CREATERECLISTPROCs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * CREATERECLISTPROCMSG crlpm may be determined as
 * rgcpcszCreateRecListMsg[crlpm].
 */

const LPCTSTR rgcpcszCreateRecListMsg[] =
{
   TEXT("CRLS_BEGIN_CREATE_REC_LIST"),
   TEXT("CRLS_DELTA_CREATE_REC_LIST"),
   TEXT("CRLS_END_CREATE_REC_LIST")
};

/* RECSTATUSPROCMSGs strings */

/*
 * N.b., this array of strings must match the RECSTATUSPROCMSGs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * RECSTATUSPROCMSG rspm may be determined as rgcpcszRecStatusMsg[rspm].
 */

CONST LPCTSTR rgcpcszRecStatusMsg[] =
{
   TEXT("RS_BEGIN_COPY"),
   TEXT("RS_DELTA_COPY"),
   TEXT("RS_END_COPY"),
   TEXT("RS_BEGIN_MERGE"),
   TEXT("RS_DELTA_MERGE"),
   TEXT("RS_END_MERGE"),
   TEXT("RS_BEGIN_DELETE"),
   TEXT("RS_DELTA_DELETE"),
   TEXT("RS_END_DELETE")
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\heapaloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       heapaloc.h
//
//  Contents:   Macros which wrap the standard memory API calls, redirecting
//              them to HeapAlloc.
//
//  Functions:  __inline HLOCAL  HeapLocalAlloc   (fuFlags, cbBytes)
//              __inline HGLOBAL HeapGlobalAlloc  (fuFlags, cbBytes)
//              __inline HGLOBAL HeapGlobalReAlloc(hMem, cbBytes, fuFlags)
//              __inline HLOCAL  HeapLocalReAlloc (hMem, cbBytes, fuFlags)
//              __inline DWORD   HeapGlobalSize   (HGLOBAL hMem)
//              __inline DWORD   HeapLocalSize    (HLOCAL hMem)
//              __inline HLOCAL  HeapLocalFree    (HLOCAL hMem)
//              __inline HGLOBAL HeapGlobalFree   (HLOCAL hMem)
//              __inline void    InvalidMemoryCall()
//
//  History:    2-01-95   davepl   Created
//
//--------------------------------------------------------------------------

// If we are using the debug allocator from ntdll.dll, we set a flag that
// will give us byte-granularity on allocations (ie: you ask for 3 bytes,
// you get it, not 8, 16, etc)

#if ((defined(WINNT) && defined(DEBUG)) || defined(FORCE_DEBUG_ALLOCATOR))
  #define DEF_ALLOC_FLAGS (0x00000800)
#else
  #define DEF_ALLOC_FLAGS (0x00000000)
#endif

// Redefine the standard memory APIs to thunk over to our Heap-based funcs

#define LocalAlloc(fuFlags, cbBytes)          HeapLocalAlloc(fuFlags, cbBytes)
#define LocalReAlloc(hMem, cbBytes, fuFlags)  HeapLocalReAlloc(hMem, cbBytes, fuFlags)
#define LocalSize(hMem)                       HeapLocalSize(hMem)
#define LocalFree(hMem)                       HeapLocalFree(hMem)

//
// These are functions normally in comctl32, but there's no good reason to call
// that dll, so handle them here.  Since Chicago may still want to use these
// shared memory routines, only "forward" them under NT.
//

#ifdef WINNT
#define Alloc(cb)                             HeapLocalAlloc(LMEM_ZEROINIT | LMEM_FIXED, cb)
#define ReAlloc(pb, cb)                       HeapLocalReAlloc(pb, cb, LMEM_ZEROINIT | LMEM_FIXED)
//
//
#define Free(pb)                              (!HeapLocalFree(pb))
#define GetSize(pb)                           HeapLocalSize(pb)
#endif


#if 0

// GlobalAllocs cannot be trivially replaced since they are used for DDE, OLE,
// and GDI operations.  However, on a case-by-case version we can switch them
// over to HeapGlobalAlloc as we identify instances that don't _really_ require
// GlobalAllocs.

#define GlobalAlloc(fuFlags, cbBytes)         HeapGlobalAlloc(fuFlags, cbBytes)
#define GlobalReAlloc(hMem, cbBytes, fuFlags) HeapGlobalReAlloc(hMem, cbBytes, fuFlags)
#define GlobalSize(hMem)                      HeapGlobalSize(hMem)
#define GlobalFree(hMem)                      HeapGlobalFree(hMem)
#define GlobalCompact                         InvalidMemoryCall
#define GlobalDiscard                         InvalidMemoryCall
#define GlobalFlags                           InvalidMemoryCall
#define GlobalHandle                          InvalidMemoryCall
#define GlobalLock                            InvalidMemoryCall
#define GlobalUnlock                          InvalidMemoryCall

#endif

//
// Make sure we're not using any unsupported operations on our "handles"
//

#define LocalCompact  InvalidMemoryCall
#ifdef  LocalDiscard
#undef  LocalDiscard
#endif
#define LocalDiscard  InvalidMemoryCall
#define LocalFlags    InvalidMemoryCall
#define LocalHandle   InvalidMemoryCall
#define LocalLock     InvalidMemoryCall
#define LocalUnlock   InvalidMemoryCall


//
// Pointer to process heap, initialized in LibMain of shell32.dll
//

extern HANDLE g_hProcessHeap;

//+-------------------------------------------------------------------------
//
//  Function:   HeapLocalAlloc  (inline function)
//
//  Synopsis:   Replaces standard LocalAlloc call with a call to HeapAlloc
//
//  Arguments:  [fuFlags] -- LocalAlloc flags to be mapped
//              [cbBytes] -- Number of bytes to allocate
//
//  Returns:    Memory pointer cast to HLOCAL type, NULL on failure
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Only really handles the LMEM_ZEROINIT flag.  If your compiler
//              doesn't fold most of this out, buy a new compiler.
//
//--------------------------------------------------------------------------

__inline HLOCAL HeapLocalAlloc(IN UINT fuFlags, IN UINT cbBytes)
{
    void * pv;
    DWORD  dwFlags;

    // Assert our assumptions

    Assert(g_hProcessHeap);

    // Map LocalAlloc flags to appropriate HeapAlloc flags

    dwFlags =  (fuFlags & LMEM_ZEROINIT ? HEAP_ZERO_MEMORY : 0);
    dwFlags |= DEF_ALLOC_FLAGS;

    // Call heap alloc, then assert that we got a good allocation

    pv = HeapAlloc(g_hProcessHeap, dwFlags, cbBytes);

    Assert(pv);

    return (HLOCAL) pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   HeapLocalFree
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Since HeapFree return a BOOL, we massage it appropriately
//              to emulate LocalFree()
//
//--------------------------------------------------------------------------

__inline HLOCAL HeapLocalFree(HLOCAL hMem)
{
    BOOL fSuccess = HeapFree(g_hProcessHeap, 0, hMem);
    Assert(fSuccess);

    return fSuccess ? NULL : (HGLOBAL) -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   HeapGlobalFree
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Since HeapFree return a BOOL, we massage it appropriately
//              to emulate GlobalFree()
//
//--------------------------------------------------------------------------

__inline HLOCAL HeapGlobalFree(HLOCAL hMem)
{
    BOOL fSuccess = HeapFree(g_hProcessHeap, 0, hMem);
    Assert(fSuccess);

    return fSuccess ? NULL : (HGLOBAL) -1;
}

//+-------------------------------------------------------------------------
//
//  Function:   HeapGlobalAlloc  (inline function)
//
//  Synopsis:   Replaces standard GlobalAlloc call with a call to HeapAlloc
//
//  Arguments:  [fuFlags] -- GlobalAlloc flags to be mapped
//              [cbBytes] -- Number of bytes to allocate
//
//  Returns:    Memory pointer cast to HGLOBAL type, NULL on failure
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Only really handles the GMEM_ZEROINIT flag.
//
//--------------------------------------------------------------------------

__inline HLOCAL HeapGlobalAlloc(IN UINT fuFlags, IN UINT cbBytes)
{
    void * pv;
    DWORD  dwFlags;

    // Assert our assumptions

    Assert(g_hProcessHeap);
    Assert(0 == (fuFlags & GMEM_NOCOMPACT));
    Assert(0 == (fuFlags & GMEM_NODISCARD));
    Assert(0 == (fuFlags & GMEM_DDESHARE));
    Assert(0 == (fuFlags & GMEM_SHARE));

    // Map GlobalAlloc flags to appropriate HeapAlloc flags

    dwFlags =  (fuFlags & GMEM_ZEROINIT ? HEAP_ZERO_MEMORY : 0);
    dwFlags |= DEF_ALLOC_FLAGS;

    // Call heap alloc, then assert that we got a good allocation

    pv = HeapAlloc(g_hProcessHeap, dwFlags, cbBytes);

    Assert(pv);

    return (HGLOBAL) pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   GlobalReAlloc  (inline function)
//
//  Synopsis:   Replaces standard GlobalReAlloc call by a call to HeapReAlloc
//
//  Arguments:  [hMem]    -- Original pointer that is to be realloc'd
//              [fuFlags] -- GlobalReAlloc flags to be mapped
//              [cbBytes] -- Number of bytes to allocate
//
//  Returns:    Memory pointer cast to HGLOBAL type, NULL on failure
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Only really handles the GMEM_ZEROINIT flag.
//              Did you remember to save your original pointer? I hope so...
//
//--------------------------------------------------------------------------

__inline HLOCAL HeapGlobalReAlloc(IN HGLOBAL hMem,
                                  IN UINT    cbBytes,
                                  IN UINT    fuFlags)
{
    void * pv;
    DWORD  dwFlags;

    if (NULL == hMem)
    {
        return HeapGlobalAlloc(fuFlags, cbBytes);
    }

    // Assert our assumptions

    Assert(g_hProcessHeap);
    Assert(0 == (fuFlags & GMEM_NOCOMPACT));
    Assert(0 == (fuFlags & GMEM_NODISCARD));
    Assert(0 == (fuFlags & GMEM_DDESHARE));
    Assert(0 == (fuFlags & GMEM_SHARE));

    // Map GlobalReAlloc flags to appropriate HeapAlloc flags

    dwFlags =  (fuFlags & GMEM_ZEROINIT ? HEAP_ZERO_MEMORY : 0);
    dwFlags |= DEF_ALLOC_FLAGS;

    // Call heap alloc, then assert that we got a good allocation

    pv = HeapReAlloc(g_hProcessHeap, dwFlags, (void *) hMem, cbBytes);

    Assert(pv);

    return (HGLOBAL) pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   LocalReAlloc  (Macro definition)
//
//  Synopsis:   Replaces standard LocalReAlloc call by a call to HeapReAlloc
//
//  Arguments:  [hMem]    -- Original pointer that is to be realloc'd
//              [fuFlags] -- GlobalAlloc flags to be mapped
//              [cbBytes] -- Number of bytes to allocate
//
//  Returns:    Memory pointer cast to HLOCAL type, NULL on failure
//
//  History:    2-01-95   davepl   Created
//
//  Notes:      Only really handles the LMEM_ZEROINIT flag.
//
//--------------------------------------------------------------------------


__inline HLOCAL HeapLocalReAlloc(IN HGLOBAL hMem,
                                 IN UINT    cbBytes,
                                 IN UINT    fuFlags)
{
    void * pv;
    DWORD  dwFlags;


    if (NULL == hMem)
    {
        return HeapLocalAlloc(fuFlags, cbBytes);
    }

    // Assert our assumptions

    Assert(g_hProcessHeap);
    Assert(0 == (fuFlags & LMEM_NOCOMPACT));
    Assert(0 == (fuFlags & LMEM_NODISCARD));

    // Map LocalAlloc flags to appropriate HeapAlloc flags

    dwFlags =  (fuFlags & LMEM_ZEROINIT ? HEAP_ZERO_MEMORY : 0);
    dwFlags |= DEF_ALLOC_FLAGS;

    // Call heap alloc, then assert that we got a good allocation

    pv = HeapReAlloc(g_hProcessHeap, dwFlags, (void *) hMem, cbBytes);

    Assert(pv);

    return (HGLOBAL) pv;
}

//+-------------------------------------------------------------------------
//
//  Function:   HeapGlobalSize (inline function)
//
//  Synopsis:   Passes GlobalSize call through to HeapGlobalSize
//
//  History:    2-01-95   davepl   Created
//
//--------------------------------------------------------------------------

__inline DWORD HeapGlobalSize(HGLOBAL hMem)
{
    Assert(g_hProcessHeap);

    return HeapSize(g_hProcessHeap, 0, (void *) hMem);
}

//+-------------------------------------------------------------------------
//
//  Function:   HeapLocalSize
//
//  Synopsis:   Passes HeapLocalSize call through to HeapGlobalSize
//
//  History:    2-01-95   davepl   Created
//
//--------------------------------------------------------------------------

__inline DWORD HeapLocalSize(HLOCAL hMem)
{
    Assert(g_hProcessHeap);

    return HeapSize(g_hProcessHeap, 0, (void *) hMem);
}

//+-------------------------------------------------------------------------
//
//  Function:   InvalidMemoryCall
//
//  Synopsis:   Dead-end stub for unsupported memory API calls
//
//  History:    2-01-95   davepl   Created
//
//--------------------------------------------------------------------------

__inline void InvalidMemoryCall()
{
    Assert(0 && "Invalid memory API was called");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\fsmenu.h ===
#ifndef _FSMENU_H
#define _FSMENU_H
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

typedef enum
{
        FMF_NONE                = 0x0000,
        FMF_NOEMPTYITEM         = 0x0001,
        FMF_INCLUDEFOLDERS      = 0x0002,
        FMF_NOPROGRAMS          = 0x0004,
        FMF_FILESMASK           = 0x0007,
        FMF_LARGEICONS          = 0x0008,
        FMF_NOBREAK             = 0x0010,
        FMF_NOABORT             = 0x0020,
} FMFLAGS;

#define FMAI_SEPARATOR          0x00000001

typedef void (CALLBACK *PFNFMCALLBACK)(LPITEMIDLIST, LPITEMIDLIST);

WINSHELLAPI UINT        WINAPI FileMenu_ReplaceUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI BOOL        WINAPI FileMenu_InitMenuPopup(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_DrawItem(HWND hwnd, DRAWITEMSTRUCT FAR *lpdi);
WINSHELLAPI LRESULT WINAPI FileMenu_MeasureItem(HWND hwnd, MEASUREITEMSTRUCT FAR *lpmi);
WINSHELLAPI UINT        WINAPI FileMenu_DeleteAllItems(HMENU hmenu);
WINSHELLAPI LRESULT WINAPI FileMenu_HandleMenuChar(HMENU hmenu, TCHAR ch);
WINSHELLAPI BOOL        WINAPI FileMenu_GetLastSelectedItemPidls(HMENU hmenu, LPITEMIDLIST *ppidlFolder, LPITEMIDLIST *ppidlItem);
WINSHELLAPI HMENU       WINAPI FileMenu_FindSubMenuByPidl(HMENU hmenu, LPITEMIDLIST pidl);
WINSHELLAPI UINT        WINAPI FileMenu_InsertUsingPidl(HMENU hmenu, UINT idNewItems,  LPITEMIDLIST pidl, FMFLAGS fmf, UINT fMenuFilter, PFNFMCALLBACK pfncb);
WINSHELLAPI void        WINAPI FileMenu_Invalidate(HMENU hmenu);
WINSHELLAPI HMENU   WINAPI FileMenu_Create(COLORREF clr, int cxBmpGap, HBITMAP hbmp, int cySel, FMFLAGS fmf);
WINSHELLAPI BOOL    WINAPI FileMenu_AppendItem(HMENU hmenu, LPTSTR psz, UINT id, int iImage, HMENU hmenuSub, UINT cyItem);
WINSHELLAPI BOOL    WINAPI FileMenu_TrackPopupMenuEx(HMENU hmenu, UINT Flags, int x, int y, HWND hwndOwner, LPTPMPARAMS lpTpm);
WINSHELLAPI BOOL        WINAPI FileMenu_DeleteItemByCmd(HMENU hmenu, UINT id);
WINSHELLAPI void        WINAPI FileMenu_Destroy(HMENU hmenu);
WINSHELLAPI BOOL        WINAPI FileMenu_EnableItemByCmd(HMENU hmenu, UINT id, BOOL fEnable);
WINSHELLAPI BOOL        WINAPI FileMenu_DeleteSeparator(HMENU hmenu);
WINSHELLAPI BOOL        WINAPI FileMenu_DeleteMenuItemByFirstID(HMENU hmenu, UINT id);
WINSHELLAPI DWORD       WINAPI FileMenu_GetItemExtent(HMENU hmenu, UINT iItem);
WINSHELLAPI BOOL        WINAPI FileMenu_DeleteItemByIndex(HMENU hmenu, UINT iItem);
WINSHELLAPI void        WINAPI FileMenu_AbortInitMenu(void);
WINSHELLAPI UINT        WINAPI FileMenu_AppendFilesForPidl(HMENU hmenu, LPITEMIDLIST pidl, BOOL bInsertSeparator);
WINSHELLAPI UINT        WINAPI FileMenu_AddFilesForPidl(HMENU hmenu, UINT iPos, UINT idNewItems,
                                                        LPITEMIDLIST pidl, FMFLAGS fmf, UINT fMenuFilter, PFNFMCALLBACK pfncb);
#endif //_FSMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\help.h ===
// This file contains help context id's in the master windows.h file.

// Id's over 61440 are reserved and will ALWAYS use windows.hlp when
// used for context-sensitive help.

// Id's from 1-999 are reserved for Object help

// REVIEW: has to be 28440 until new help compiler is available

#define NO_HELP                         ((DWORD) -1) // Disables Help for a control

#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445
#define IDH_COMM_APPLYNOW               28447
#define IDH_FONT_STYLE                  28448
#define IDH_FONT_SIZE                   28449
#define IDH_FONT_SAMPLE                 28450
#define IDH_FONT_EFFECTS                28451
#define IDH_FONT_FONT                   28452
#define IDH_PRINT_SETUP_AVAIL           28453
#define IDH_PRINT_SETUP_OPTIONS         28454
#define IDH_PRINT_SETUP_DETAILS         28455
#define IDH_OPEN_LOCATION               28456
#define IDH_OPEN_FILES                  28457
#define IDH_OPEN_READONLY               28459
#define IDH_OPEN_FILETYPE               28460
#define IDH_OPEN_PATH                   28461
#define IDH_OPEN_FILENAME               28462
#define IDH_FIND_SEARCHTEXT             28463
#define IDH_FIND_NEXT_BUTTON            28464
#define IDH_FIND_WHOLE                  28467
#define IDH_FIND_CASE                   28468
#define IDH_REPLACE_REPLACE             28469
#define IDH_REPLACE_REPLACE_ALL         28470
#define IDH_REPLACE_REPLACEWITH         28471
#define IDH_PRINT_PRINTER               28472
#define IDH_PRINT_PRINTER_SETUP         28473
#define IDH_PRINT_COPIES                28474
#define IDH_PRINT_COLLATE               28475
#define IDH_PRINT_TO_FILE               28476
#define IDH_PRINT_QUALITY               28477
#define IDH_PRINT_RANGE                 28478
#define IDH_PAGE_SAMPLE                 28485
#define IDH_PAGE_ORIENTATION            28486
#define IDH_PAGE_PAPER_SIZE             28487
#define IDH_PAGE_PAPER_SOURCE           28488
#define IDH_PAGE_MARGINS                28489
#define IDH_OPEN_DRIVES                 28490
#define IDH_COMM_DRIVE                  28491
#define IDH_COMM_PASSWDBUTT             28492
#define IDH_COMM_OLDPASSWD              28493
#define IDH_BROWSE                      28496
#define IDH_COLOR_CUSTOM                28497
#define IDH_COLOR_SAMPLE_COLOR          28498
#define IDH_COLOR_HUE                   28500
#define IDH_COLOR_SAT                   28501
#define IDH_COLOR_RED                   28502
#define IDH_COLOR_GREEN                 28503
#define IDH_COLOR_BLUE                  28504
#define IDH_COLOR_LUM                   28505
#define IDH_COLOR_ADD                   28506
#define IDH_COLOR_COLOR_SOLID           28507
#define IDH_COLOR_DEFINE                28508
#define IDH_QUICKINFO                   28509
#define IDH_NO_CROSSREF                 28510
#define IDH_CHARMAP_INSERT              28511
#define IDH_COMM_USER_NAME              28512
#define IDH_COMM_USER_SERVERNAME        28513
#define IDH_COMM_USER_SELECT_FROM       28514
#define IDH_COMM_USER_SELECTED          28515
#define IDH_PRINT32_RANGE               28516
#define IDH_PRINT_PROPERTIES            28517
#define IDH_PRINT_FILENAME              28518
#define IDH_PRINT_CHOOSE_PRINTER        28519
#define IDH_FIND_DIRECTION              28520
#define IDH_FONT_COLOR                  28521
#define IDH_PRINT_SETUP_PAPER           28522
#define IDH_PRINT_SETUP_ORIENT          28523
#define IDH_OPEN_BUTTON                 28529
#define IDH_SAVE_BUTTON                 28531
#define IDH_COLOR_BASIC                 28532
#define IDH_COLOR_CUSTOM_CUSTOM         28533
#define IDH_COLOR_SAMPLE_SCROLL         28534
#define IDH_FONT_SCRIPT                 28535
#define IDH_KERNEL_TASK_LIST            28536
#define IDH_KERNEL_END_TASK             28537
#define IDH_KERNEL_SHUTDOWN             28538
#define IDH_QVIEW_DISPLAY               28539
#define IDH_CHARMAP_COPY                28540
#define IDH_CHARMAP_FONT                28541
#define IDH_CHARMAP_CHARACTERS          28542
#define IDH_CHARMAP_SELECTED_CHARS      28543
#define IDH_CHARMAP_SELECT_BUTTON       28544
#define IDH_CHARMAP_HELP_BUTTON         28545
#define IDH_BOLD                        28546
#define IDH_ITALIC                      28547
#define IDH_COMM_GROUPBOX               28548
#define IDH_OPEN_FILES32                28549
#define IDH_SAVE_FILETYPE               28550
#define IDH_SYSTEM_CFG_OLDNAME          28551
#define IDH_DIAL_WHAT_WRONG             28552
#define IDH_COMCTL_RESET                28553
#define IDH_COMCTL_MOVEUP               28554
#define IDH_COMCTL_MOVEDOWN             28555
#define IDH_COMCTL_BUTTON_LIST          28556
#define IDH_COMCTL_ADD                  28557
#define IDH_COMCTL_REMOVE               28558
#define IDH_COMCTL_AVAIL_BUTTONS        28559
#define IDH_COMCTL_CLOSE                28560
#define IDH_PAGE_PRINTER                28561
#define IDH_DCC_WHAT_WRONG              28562
#define IDH_FILEVIEWER_PREVIEW          28563
#define IDH_PRINT_NETWORK               28564
#define IDH_PRINT_SETUP_DUPLEX          28565

#ifdef JAPAN
#define IDH_CHARMAP_KIND                28566
#define IDH_CHARMAP_READ                28567
#define IDH_CHARMAP_PARTS               28568
#endif

#define IDH_OLEPROP_SUMMARY             28569
#define IDH_OLEPROP_STATISTICS          28570
#define IDH_CONFIGURE_LPT_PORT          28571
#define IDH_ADD_LOCAL_PORT              28572
#define IDH_PRINT_PORT_NAME             28573
#define IDH_PRINT_OUTPUT_FILE           28574
#define IDH_DISKCOPY_START              28575
#define IDH_DISKCOPY_FROM               28576
#define IDH_DISKCOPY_TO                 28577

// ID value for Win 3.1 user transition piece: jump from First experience screen
#define WIN31_TRANSITION_PIECE          30000

// ID values 2100-2199 are reserved for Disk Compression.
// See dos\dos86\dblspace\utility\comphelp.h

// ID values 2200-2299 are reserved for Find File. See findhlp.h.

// ID values 2400-2499 are reserved for MultiMedia control panel. See medhelp.h

// ID values 2500-2699 are reserved for Print Trouble Shooter

// ID values 2700-2799 are reserved for Network control panel. See nethelp.h

// ID values 2800-2899 are reserved for Online Registration.

// ID values 2900-2999 are reserved for Clipbook and Chat.

#define IDH_COMM_NEWPASSWD              3018    // See pwdids.h
#define IDH_COMM_NEWPASSCONF            3019    // See pwdids.h

// Briefcase ids

#define IDH_BFC_UPDATE_SCREEN           3100
#define IDH_BFC_UPDATE_BUTTON           3101
#define IDH_BFC_PROP_FILEICON           3102
#define IDH_BFC_PROP_SPLIT_BUTTON       3103
#define IDH_BFC_PROP_FINDORIG_BUTTON    3104
#define IDH_BFC_FILTER_TYPE             3105
#define IDH_BFC_FILTER_INCLUDE          3106

// ID values 3300-3499 are reserved for international. See intlhlp.h

// ID values for the Keyboard property sheet

#define IDH_DLGKEY_REPDEL               4000
#define IDH_DLGKEY_REPSPEED             4001
#define IDH_DLGKEY_REPTEST              4002
#define IDH_DLGKEY_TYPE                 4008
#define IDH_DLGKEY_CHANGE               4010
#define IDH_DLGKEY_CURSBLNK             4011
#define IDH_DLGKEY_CURSOR_GRAPHIC       4012

#define IDH_KEYB_INPUT_LIST             4028
#define IDH_KEYB_INPUT_ADD              4029
#define IDH_KEYB_INPUT_PROP             4030
#define IDH_KEYB_INPUT_DEL              4031
#define IDH_KEYB_INPUT_DEFAULT          4032
#define IDH_KEYB_INPUT_LANG             4034
#define IDH_KEYB_INPUT_INDICATOR        4035
#define IDH_KEYB_INPUT_ONSCRN_KEYB      4036
#define IDH_KEYB_INPUT_PROP_LANG        4039
#define IDH_KEYB_INPUT_PROP_KEYLAY      4042
#define IDH_KEYB_INPUT_DEF_LANG         4043
#define IDH_KEYB_INPUT_SHORTCUT         4044
#define IDH_KEYB_INDICATOR_ON_TASKBAR   4045

// ID values for Desktop Property sheet

// Background Page

#define IDH_DSKTPBACKGROUND_MONITOR     4100
#define IDH_DSKTPBACKGROUND_PATTLIST    4102
#define IDH_DSKTPBACKGROUND_WALLLIST    4104
#define IDH_DSKTPBACKGROUND_BROWSE      4105
#define IDH_DSKTPBACKGROUND_TILE        4106
#define IDH_DSKTPBACKGROUND_CENTER      4107
#define IDH_DSKTPBACKGROUND_DISPLAY     4108
#define IDH_DSKTPBACKGROUND_EDITPAT     4109

// Screen Saver Page

#define IDH_DSKTPSCRSAVER_LISTBX        4111
#define IDH_DSKTPSCRSAVER_WAIT          4112
#define IDH_DSKTPSCRSAVER_TEST          4113
#define IDH_DSKTPSCRSAVER_SETTINGS      4114
#define IDH_DSKTPSCRSAVER_MONITOR       4115
#define IDH_SCRSAVER_GRAPHIC            4116
#define IDH_SCRSAVER_LOWPOWSTANDBY      4117
#define IDH_SCRSAVER_SHUTOFFPOW         4118

// Appearance Page

#define IDH_APPEAR_SCHEME               4120
#define IDH_APPEAR_SAVEAS               4121
#define IDH_APPEAR_DELETE               4122
#define IDH_APPEAR_GRAPHIC              4123
#define IDH_APPEAR_ITEMSIZE             4124
#define IDH_APPEAR_FONTBOLD             4125
#define IDH_APPEAR_FONTSIZE             4126
#define IDH_APPEAR_FONTCOLOR            4127
#define IDH_APPEAR_FONTITALIC           4128
#define IDH_APPEAR_BACKGRNDCOLOR        4129
#define IDH_APPEAR_ITEM                 4130
#define IDH_APPEAR_FONT                 4131

// Monitor Settings Page




#define IDH_DSKTPMONITOR_CHANGE_DISPLAY 4134
#define IDH_DSKTPMONITOR_COLOR          4135
#define IDH_DSKTPMONITOR_AREA           4136
#define IDH_DSKTPMONITOR_REFRESH        4137
#define IDH_DSKTPMONITOR_LIST_MODES     4138
#define IDH_DSKTPMONITOR_ENERGY         4139
#define IDH_DSKTPMONITOR_MONITOR        4140
#define IDH_DSKTPMONITOR_TEST           4141
#define IDH_DSKTPMONITOR_ADTYPE         4143
#define IDH_DSKTPMONITOR_CHANGE1        4144
#define IDH_DSKTPMONITOR_CHANGE2        4145
#define IDH_DSKTPMONITOR_MONTYPE        4146
#define IDH_DSKTPMONITOR_CUSTOM         4148
#define IDH_DSKTPMONITOR_FONTSIZE       4149
#define IDH_DSKTPMONITOR_AD_FACTS       4150
#define IDH_DSKTPMONITOR_DRIVER         4151
#define IDH_DSKTPMONITOR_DETECT         4152


#define IDH_SAVESCHEME_EDITFIELD        4170
#define IDH_CUSTOMFONTS_FONTSCALE       4171
#define IDH_CUSTOMFONTS_RULER           4172
#define IDH_CUSTOMFONTS_SAMPLE          4173

#define IDH_PATTERN_EDIT_NAME           4174
#define IDH_PATTERN_EDIT_SAMPLE         4175
#define IDH_PATTERN_EDIT_PIXEL_SCREEN   4176
#define IDH_PATTERN_EDIT_EXIT           4177
#define IDH_PATTERN_EDIT_ADD            4178
#define IDH_PATTERN_EDIT_CHANGE         4179
#define IDH_PATTERN_EDIT_REMOVE         4180

// ID values for Defrag

#define IDH_DEFRAG_START                        4200
#define IDH_DEFRAG_STOP                         4201
#define IDH_DEFRAG_PAUSE                        4202
#define IDH_DEFRAG_SHOWDETAILS                  4203
#define IDH_DEFRAG_HIDEDETAILS                  4204
#define IDH_DEFRAG_LEGEND                       4205
#define IDH_DEFRAG_SPARKLESCRN                  4206
#define IDH_DEFRAG_DEFRAGNOW_ANYWY              4207
#define IDH_DEFRAG_SELECTDRIVE                  4208
#define IDH_DEFRAG_ADVANCED                     4209
#define IDH_DEFRAG_EXIT                         4210
#define IDH_DEFRAG_DRIVELIST                    4211
#define IDH_DEFRAG_RESUME                       4212
#define IDH_DEFRAG_FULL                         4213
#define IDH_DEFRAG_FILESONLY                    4214
#define IDH_DEFRAG_FRSPCONLY                    4215
#define IDH_DEFRAG_USEONCE                      4218
#define IDH_DEFRAG_USEALWAYS                    4219
#define IDH_DEFRAG_GASGAUGE                     4220
#define IDH_DEFRAG_CHECK_DRIVE_FOR_ERRORS       4221

// RNA id values

#define IDH_RNA_CONNECT_NAME            4250
#define IDH_RNA_CONNECT_USER            4251
#define IDH_RNA_CONNECT_PASSWORD        4252
#define IDH_RNA_CONNECT_SAVEPW          4253
#define IDH_RNA_CONNECT_FROM            4254
#define IDH_RNA_OUT_PHONE_NUMBER        4255
#define IDH_RNA_OUT_DIALASST            4256
#define IDH_RNA_OUT_COMPLETE_PHONE      4257
#define IDH_RNA_OUT_CONNECT_BUTTON      4258
#define IDH_RNA_CHOOSE_MODEM            4273
#define IDH_RNA_CONFIG_MODEM            4274
#define IDH_RNA_MODEM_SERVER            4275
#define IDH_RNA_SERVERS                 4276
#define IDH_RNA_CONNECTION_LIST         4277
#define IDH_RNA_SERVER_COMPRESS         4278
#define IDH_RNA_SERVER_ENCRYPT          4279
#define IDH_RNA_SERVER_NETLOGON         4280
#define IDH_RNA_SERVER_PROTOCOL         4281
#define IDH_RNA_SERVER_TCPIPSET         4282
#define IDH_RNA_TCPIP_ASSIGNED_IP       4283
#define IDH_RNA_TCPIP_SPECIFY_IP        4284
#define IDH_RNA_TCPIP_ASSIGNED_DNS      4285
#define IDH_RNA_TCPIP_SPECIFY_DNS       4286
#define IDH_RNA_TCPIP_COMPRESS          4287
#define IDH_RNA_TCPIP_GATEWAY           4288
#define IDH_RNA_SETTINGS_REDIAL         4290
#define IDH_RNA_SETTINGS_TIMES          4291
#define IDH_RNA_SETTINGS_MINSEC         4292
#define IDH_RNA_SETTINGS_PROMPT         4293

// ID values for printing property sheets

#define IDH_PRTPROPS_TYPE_LOCATION              4501
#define IDH_PRTPROPS_COMMENT                    4502
#define IDH_PRTPROPS_NAME_STATIC                4505
#define IDH_PRTPROPS_PORT                       4506
#define IDH_PRTPROPS_DRIVER                     4507
#define IDH_PRTPROPS_NEW_PORT                   4508
#define IDH_PRTPROPS_NEW_DRIVER                 4509
#define IDH_PRTPROPS_SEPARATOR                  4510
#define IDH_PRTPROPS_ICON                       4512
#define IDH_PRTPROPS_SPOOL_SETTINGS             4513
#define IDH_PRTPROPS_PORT_SETTINGS              4514
#define IDH_PRTPROPS_SETUP                      4515
#define IDH_PRTPROPS_SEPARATOR_BROWSE           4516
#define IDH_PRTPROPS_TIMEOUT_NOTSELECTED        4517
#define IDH_PRTPROPS_TIMEOUT_TRANSRETRY         4518
#define IDH_PRTPROPS_TEST_PAGE                  4519
#define IDH_SPOOLSETTINGS_SPOOL                 4520
#define IDH_SPOOLSETTINGS_NOSPOOL               4521
#define IDH_SPOOLSETTINGS_PRINT_FASTER          4522
#define IDH_SPOOLSETTINGS_LESS_SPACE            4523
#define IDH_SPOOLSETTINGS_DATA_FORMAT           4524
#define IDH_SPOOLSETTINGS_RESTORE               4525
#define IDH_PRTPROPS_DEL_PORT                   4528
#define IDH_ADDPORT_NETWORK                     4529
#define IDH_ADDPORT_PORTMON                     4530
#define IDH_ADDPORT_NETPATH                     4531
#define IDH_ADDPORT_BROWSE                      4532
#define IDH_ADDPORT_LB                          4533
#define IDH_DELPORT_LB                          4534
#define IDH_PRTPROPS_MAP_PRN_PORT               4535
#define IDH_PRTPROPS_UNMAP_PRN_PORT             4536
#define IDH_SPOOLSETTINGS_ENABLE_BIDI           4537
#define IDH_SPOOLSETTINGS_DISABLE_BIDI          4538

// ID values for System property sheets

#define IDH_SYSTEM_SYSTEM               4600
#define IDH_SYSTEM_RESOURCES            4602
#define IDH_SYSTEM_OWNER                4603
#define IDH_SYSTEM_PRO_COPY             4624
#define IDH_SYSTEM_PRO_RENAME           4625
#define IDH_SYSTEM_PRO_DELETE           4626
#define IDH_SYSTEM_PRO_LIST             4627
#define IDH_SYSTEM_LOGO                 4628
#define IDH_SYSTEM_CFG_EDIT             4629
#define IDH_SYSTEM_PROCESSOR            4630
#define IDH_SYSTEM_VIEW_RESOURCETYPE    4631
#define IDH_SYSTEM_PAGING               4632
#define IDH_SYSTEM_ADVANCED             4633
#define IDH_SYSTEM_VIRTMEM_ADJUST       4634
#define IDH_SYSTEM_VIRTMEM_DISABLE      4635

#define IDH_SYSTEM_RESERVE_PICKONE      4636

#define IDH_SYSTEM_RESERVE_MODIFY       4639
#define IDH_SYSTEM_RESERVE_ADD          4640
#define IDH_SYSTEM_RESERVE_REMOVE       4641
#define IDH_SYSTEM_CLASSLIST            4642
#define IDH_SYS_PERF_GRAPHICS           4643
#define IDH_SYS_PERF_GRAPHICS_SLIDER    4644

#define IDH_SYSTEM_FILESYSTEM           4661
#define IDH_SYSTEM_DISK                 4662
#define IDH_SYSTEM_CDROM                4663
#define IDH_SYSTEM_CACHE                4664
#define IDH_SYSTEM_BALANCE              4665
#define IDH_SYSTEM_TROUBLESHOOT         4666
#define IDH_SYSTEM_FSCHANGE             4667
#define IDH_DEVMGR_REMOVEONE            4671
#define IDH_DEVMGR_REMOVEALL            4672
#define IDH_SYSTEM_VIEW_RESRES          4673
#define IDH_DEVMGR_CLASS                4674
#define IDH_DEVMGR_ENABLE_HEAD          4675
#define IDH_DEVMGR_PRINT_SELECT         4676
#define IDH_DEVMGR_PRINT_FILE           4677
#define IDH_DEVMGR_SCSI_INFO            4678
#define IDH_DEVMGR_DISKOPTIONS          4679
#define IDH_DEVMGR_DISCONNECT           4680
#define IDH_DEVMGR_SYNC                 4681
#define IDH_DEVMGR_AUTOINSERT           4682
#define IDH_DEVMGR_REMOVABLE            4683
#define IDH_DEVMGR_INT13                4684
#define IDH_DEVMGR_DRIVE_LETTER         4685
#define IDH_DEVMGR_DRIVE_RESERVED       4686
#define IDH_NHF_HELP                4687
#define IDH_NHF_WINDOWS             4688
#define IDH_NHF_DISK                4689
#define IDH_NHF_NODRIVER            4690
#define IDH_NHF_SIMILAR             4691
#define IDH_DMA_MEMORY              4692
#define IDH_DMA_ADDRESS             4693
#define IDH_DMA_DEFAULT             4694
#define IDH_SCSIPROP_SETTINGS       4695
#define IDH_PCI_ENUMTYPE            4697
#define IDH_PCI_IRQ_STEERING        4698
#define IDH_PCI_SETDEFAULTS         4699

// ID's for File properties

#define IDH_FPROP_VER_INFO                      4700
#define IDH_FPROP_GEN_COMPRESSED                4701		
#define IDH_FPROP_GEN_COMPRESSED_SIZE           4702
#define IDH_FPROP_SECURITY_PERMISSIONS          4703
#define IDH_FPROP_SECURITY_AUDITING             4704
#define IDH_FPROP_SECURITY_OWNERSHIP            4705
#define IDH_FPROP_GEN_NAME                      4708
#define IDH_FPROP_GEN_TYPE                      4709
#define IDH_FPROP_GEN_SIZE                      4710
#define IDH_FPROP_GEN_LOCATION                  4711
#define IDH_FPROP_GEN_DOSNAME                   4712
#define IDH_FPROP_GEN_LASTCHANGE                4713
#define IDH_FPROP_GEN_LASTACCESS                4714
#define IDH_FPROP_GEN_READONLY                  4715
#define IDH_FPROP_GEN_ARCHIVE                   4716
#define IDH_FPROP_GEN_HIDDEN                    4717
#define IDH_FPROP_GEN_SYSTEM                    4718
#define IDH_FPROP_GEN_PATH                      4719
#define IDH_FPROP_VER_ABOUT                     4720
#define IDH_FCAB_LINK_NAME                      4721
#define IDH_FCAB_LINK_LOCATION                  4723
#define IDH_FCAB_LINK_LINKTO                    4724
#define IDH_FCAB_LINK_LINKTYPE                  4725
#define IDH_FCAB_LINK_SIZE                      4726
#define IDH_FCAB_LINK_WORKING                   4727
#define IDH_FCAB_LINK_HOTKEY                    4728
#define IDH_FCAB_LINK_RUN                       4729
#define IDH_FCAB_LINK_CHANGEICON                4730
#define IDH_FCAB_LINK_FIND                      4731
#define IDH_FCAB_LINK_ICONNAME                  4732
#define IDH_FCAB_LINK_CURRENT_ICON              4733
#define IDH_FCAB_DRV_ICON                       4734
#define IDH_FCAB_DRV_LABEL                      4735
#define IDH_FCAB_DRV_TYPE                       4736
#define IDH_FCAB_DRV_USEDCOLORS                 4737
#define IDH_FCAB_DRV_TOTSEP                     4738
#define IDH_FCAB_DRV_PIE                        4739
#define IDH_FCAB_DRV_LETTER                     4740
#define IDH_FCAB_DRV_FS                         4741
#define IDH_FCAB_DISKTOOLS_CHKNOW               4742
#define IDH_FCAB_DISKTOOLS_BKPNOW               4743
#define IDH_FCAB_DISKTOOLS_OPTNOW               4744
#define IDH_FCAB_DELFILEPROP_DELETED            4745
#define IDH_FCAB_DRV_COMPRESS                   4746		
#define IDH_FPROP_GEN_DATE_CREATED              4747
#define IDH_FCAB_FOLDEROPTIONS_ALWAYS           4748
#define IDH_FCAB_FOLDEROPTIONS_NEVER            4749
#define IDH_FCAB_VIEWOPTIONS_SHOWALL            4750
#define IDH_FCAB_VIEWOPTIONS_HIDDENEXTS         4751
#define IDH_FCAB_VIEWOPTIONS_SHOWFULLPATH       4752
#define IDH_FCAB_VIEWOPTIONS_HIDEEXTS           4753
#define IDH_FCAB_VIEWOPTIONS_SHOWDESCBAR        4754
#define IDH_FCAB_FT_PROP_LV_FILETYPES           4755
#define IDH_FCAB_FT_PROP_NEW                    4756
#define IDH_FCAB_FT_PROP_REMOVE                 4757
#define IDH_FCAB_FT_PROP_EDIT                   4759
#define IDH_FCAB_FT_PROP_DETAILS                4760
#define IDH_FCAB_FT_CMD_ACTION                  4761
#define IDH_FCAB_FT_CMD_EXE                     4762
#define IDH_FCAB_FT_CMD_BROWSE                  4763
#define IDH_FCAB_FT_CMD_USEDDE                  4764
#define IDH_FCAB_FT_CMD_DDEMSG                  4765
#define IDH_FCAB_FT_CMD_DDEAPP                  4766
#define IDH_FCAB_FT_CMD_DDEAPPNOT               4767
#define IDH_FCAB_FT_CMD_DDETOPIC                4768
#define IDH_FCAB_FT_EDIT_DOCICON                4769
#define IDH_FCAB_FT_EDIT_CHANGEICON             4770
#define IDH_FCAB_FT_EDIT_DESC                   4771
#define IDH_FCAB_FT_EDIT_EXT                    4772
#define IDH_FCAB_FT_EDIT_LV_CMDS                4773
#define IDH_FCAB_FT_EDIT_DEFAULT                4774
#define IDH_FCAB_FT_EDIT_NEW                    4775
#define IDH_FCAB_FT_EDIT_EDIT                   4776
#define IDH_FCAB_FT_EDIT_REMOVE                 4777
#define IDH_FCAB_DELFILEPROP_COMPRESSED         4778
#define IDH_FPROP_GEN_ICON                      4779
#define IDH_MULTPROP_NAME                       4780
#define IDH_FPROP_FOLDER_CONTAINS               4781
#define IDH_FCAB_LINK_ICON                      4782
#define IDH_FCAB_DELFILEPROP_LOCATION           4783
#define IDH_FCAB_DELFILEPROP_READONLY           4784
#define IDH_FCAB_DELFILEPROP_HIDDEN             4785
#define IDH_FCAB_DELFILEPROP_ARCHIVE            4786
#define IDH_FCAB_DELFILEPROP_SYSTEM             4787
#define IDH_FCAB_OPENAS_DESCRIPTION             4788
#define IDH_FCAB_OPENAS_APPLIST                 4789
#define IDH_FCAB_OPENAS_OTHER                   4790
#define IDH_FCAB_FT_EDIT_QUICKVIEW              4791
#define IDH_GENDRV_CHKWARN                      4792
#define IDH_GENDRV_MBFREE                       4793
#define IDH_FCAB_OPENAS_MAKEASSOC               4794
#define IDH_FCAB_FT_EDIT_SHOWEXT                4795
#define IDH_FCAB_FT_PROP_CONTTYPERO             4796    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_CONTTYPE               4797    // T.B.D. IExplorer merge
#define IDH_FCAB_FT_EDIT_DEFEXT                 4798    // T.B.D. IExplorer merge
#define IDH_FCAB_VIEWOPTIONS_SHOWCOMPCOLOR      4799


// Screen saver ids

#define IDH_BEZIER_SPEED                4800
#define IDH_BEZIER_LINES                4801
#define IDH_BEZIER_CURVES               4802
#define IDH_BEZIER_DENSITY              4803
#define IDH_BEZIER_ONECOLOR             4804
#define IDH_BEZIER_CHOOSECLR            4805
#define IDH_BEZIER_MULTCOLOR            4806
#define IDH_BEZIER_CLRSCRN              4807
#define IDH_FLYINGWIN_WARP              4808
#define IDH_FLYINGWIN_DENSTY            4809
#define IDH_COMM_PASSWDCHKBOX           4810
#define IDH_MARQUEE_CENTER              4811
#define IDH_MARQUEE_RANDOM              4812
#define IDH_MARQUEE_SPEED               4813
#define IDH_MARQUEE_COLOR               4814
#define IDH_MARQUEE_TEXT                4815
#define IDH_MARQUEE_FORMAT              4817
#define IDH_MYST_SHAPE                  4818
#define IDH_MYST_ACTVBOX                4819
#define IDH_MYST_LINES                  4820
#define IDH_MYST_TWOCOLORS              4821
#define IDH_MYST_MULTIPLE               4822
#define IDH_MYST_CLEARSCRN              4823
#define IDH_STARS_WARP                  4824
#define IDH_STARS_DENSTY                4825
#define IDH_HOP_DELAY                   4826
#define IDH_HOP_SCALE                   4827

// id's for date-time property sheet

#define IDH_DATETIME_MONTH              4901
#define IDH_DATETIME_YEAR               4902
#define IDH_DATETIME_DATE               4903
#define IDH_DATETIME_TIME               4904
#define IDH_DATETIME_TIMEZONE           4907
#define IDH_DATETIME_BITMAP             4908
#define IDH_DATETIME_DAYLIGHT_SAVE      4909
#define IDH_DATETIME_CURRENT_TIME_ZONE  4910

// id's for Modem Setup

#define IDH_MODEM_SELECT                5000
#define IDH_MODEM_DETECT                5001
#define IDH_MODEM_PORT                  5002
#define IDH_MODEM_NAME                  5003
#define IDH_MODEM_INSTALLED             5004
#define IDH_MODEM_PROP                  5005
#define IDH_MODEM_NEW                   5006
#define IDH_MODEM_DELETE                5007

// id's for Unimodem property pages

#define IDH_UNI_GEN_MODEM               5050
#define IDH_UNI_GEN_PORT                5051
#define IDH_UNI_GEN_VOLUME              5052
#define IDH_UNI_GEN_MAX_SPEED           5053
#define IDH_UNI_GEN_THIS_SPEED          5054
#define IDH_UNI_CON_PREFS               5055
#define IDH_UNI_CON_CALL_PREFS          5056
//#define IDH_UNI_CON_TONE                5057      Deleted
#define IDH_UNI_CON_DIALTONE            5058
#define IDH_UNI_CON_CANCEL              5059
#define IDH_UNI_CON_DISCONNECT          5060
#define IDH_UNI_CON_PORT                5061
#define IDH_UNI_CON_ADVANCED            5062
#define IDH_UNI_CON_ADV_ERROR           5063
#define IDH_UNI_CON_ADV_REQUIRED        5064
#define IDH_UNI_CON_ADV_COMPRESS        5065
#define IDH_UNI_CON_ADV_CELLULAR        5066
#define IDH_UNI_CON_ADV_FLOW            5067
#define IDH_UNI_CON_ADV_MODULATION      5068
#define IDH_UNI_CON_ADV_CSITT           5069
#define IDH_UNI_CON_ADV_BELL            5070
#define IDH_UNI_CON_ADV_EXTRA           5071
#define IDH_UNI_CON_ADV_AUDIT           5072
//#define IDH_UNI_OPT_CONNECTION          5073      Deleted
#define IDH_UNI_OPT_PRE_DIAL            5074
#define IDH_UNI_OPT_POST_DIAL           5075
#define IDH_UNI_OPT_MANUAL              5076
#define IDH_UNI_OPT_STATUS              5077
#define IDH_UNI_TERMINAL                5078
#define IDH_UNI_STATUS_TALK             5079
#define IDH_UNI_STATUS_HANGUP           5080
#define IDH_UNI_GEN_PORT_INT            5081
#define IDH_UNI_OPT_WAIT                5082

#define IDH_LIGHTS                      5099

// id's for TAPI Dial Helper (5100-5199)

#define IDH_TAPI_ACCESS_LINE            5100
#define IDH_TAPI_AREA_CODE              5101
#define IDH_TAPI_CALLCARD_ADD           5102
#define IDH_TAPI_CALLCARD_ADV           5103
#define IDH_TAPI_CALLCARD_NUMBER        5104
#define IDH_TAPI_CALLCARD_REMOVE        5105
#define IDH_TAPI_CALLCARD_RULES         5106
#define IDH_TAPI_CALLCARDS              5107
#define IDH_TAPI_COPY_FROM_BUTTON       5108
#define IDH_TAPI_COPYFROM               5109
#define IDH_TAPI_COUNTRY                5110
#define IDH_TAPI_CREATE_CARD            5111
#define IDH_TAPI_CREATE_LOCATION        5112
#define IDH_TAPI_LOCATION_CALL_WAIT     5113
#define IDH_TAPI_LOCATION_CARD          5114
#define IDH_TAPI_LOCATION_CARD_CHANGE   5115
#define IDH_TAPI_LOCATION_NEW           5116
#define IDH_TAPI_LOCATION_PHONE         5117
#define IDH_TAPI_LOCATION_PULSE         5118
#define IDH_TAPI_LOCATION_REMOVE        5119
#define IDH_TAPI_LOCATIONS              5120
#define IDH_TAPI_LONG_DISTANCE          5121

// id's 5200 - 5500 are reserved for DOS

//  Add/Remove Program IDs reserved 5600-5699

// Miscellaneous ids

#define IDH_TRAY_RUN_COMMAND            6002
#define IDH_TRAY_RUN_SEPMEM             6003
#define IDH_TRAY_TASKBAR_ONTOP          6004
#define IDH_TRAY_TASKBAR_AUTOHIDE       6005
#define IDH_TRAY_SHUTDOWN_SHUTDOWN      6007
#define IDH_TRAY_SHUTDOWN_RESTART       6008
#define IDH_TRAY_SHUTDOWN_LOGOFF        6009
#define IDH_STARTMENU_SMALLICONS        6010
#define IDH_MENUCONFIG_CLEAR            6011
#define IDH_TRAY_ADD_PROGRAM            6012
#define IDH_TRAY_REMOVE_PROGRAM         6013
#define IDH_TRAY_ADVANCED               6014
#define IDH_TRAY_SHUTDOWN_HELP          6015
#define IDH_TRAY_SHOW_CLOCK             6016
#define IDH_TRAY_REMOVEDLG_LIST         6017
#define IDH_TRAY_REMOVEDLG_DEL          6018
#define IDH_TASKBAR_OPTIONS_BITMAP      6019

// ID values for Virtual Memory Property sheet

#define IDH_DEVMGR_VIEW_BY              6204
#define IDH_SYSTEM_DM_PRINT             6205
#define IDH_DEVMGR_PATH                 6206

#define IDH_DEVMGR_CONFLICT_TRB         6260
#define IDH_DEVMGR_DRIVERINFO           6261
#define IDH_DEVMGR_CHANGEDRIVER         6262
#define IDH_DEVMGR_DRIVERS              6264
#define IDH_DEVMGR_PRINTER              6265
#define IDH_DEVMGR_PRINTOVERVIEW        6266
#define IDH_DEVMGR_PRINT_SYS            6267
#define IDH_DEVMGR_PRINT_CLASS          6268
#define IDH_DEVMGR_SHOW                 6271
#define IDH_DEVMGR_HAVEDISK             6272
#define IDH_DEVMGR_CHOOSE_DEVICE        6273

//  Ids for the performance page
#define IDH_PERFLOWRES                  6301
#define IDH_PERFLOWMEM                  6302
#define IDH_4MBHELP                     6303
#define IDH_PERFCOMPATVIRTMEM           6304
#define IDH_PERFVIRTMEMOFF              6305
#define IDH_PERFPCMCIAOFF               6306
#define IDH_PERFRMCOMPRESS              6307
#define IDH_PERFNOPMODEDRIVES           6308
#define IDH_PERFMBRHOOK                 6309
#define IDH_PERFREALMODEDRIVE           6310
#define IDH_PERFNOPMODETSR              6311

#define IDH_SYS_PERF_MEMORY             6320
#define IDH_SYS_PERF_SR                 6321
#define IDH_SYS_PERF_FS                 6322
#define IDH_SYS_PERF_VMEM               6323
#define IDH_SYS_PERF_COMPRESS           6324
#define IDH_SYS_PERF_PCMCIA             6325
#define IDH_SYS_PERF_PROBLEM            6326
#define IDH_SYS_PERF_DETAILS            6327


//  sysclass.dll
#define IDH_FPU_DIAGTEXT                6350
#define IDH_FPU_SETTING                 6351
#define IDH_POWERCFG_ENABLE_PM          6352
#define IDH_POWERCFG_FORCE_APM          6353
#define IDH_POWERCFG_DISABLE_INTEL      6354
#define IDH_POWERCFG_POLLING            6355


// More ids for system cpl (ran out of #'s above)
#define IDH_SYSTEM_DMCONFIG_RETRY               6400
#define IDH_SYSTEM_DMCONFIG_IGNORE              6401

#define IDH_SYSTEM_OEMSUPPORT           6407
#define IDH_SYSTEM_DEVGEN_STATUS                6408
#define IDH_SYSTEM_DEGEN_SPECIALMF      6409
#define IDH_SYSTEM_DEVRES_SETTINGS              6410
#define IDH_SYSTEM_USESYSSETTINGS               6411
#define IDH_SYSTEM_DEVRES_CHANGE                6412
#define IDH_SYSTEM_LOGCONFIGLIST                6413
#define IDH_SYSTEM_REGRSTR_RESTORE              6417
#define IDH_SYSTEM_TREE                         6418
#define IDH_SYSTEM_PROPERTIES                   6419
#define IDH_SYSTEM_DM_REFRESH                   6420

#define IDH_SYSTEM_VIRTMEM_ON                   6421
#define IDH_SYSTEM_VIRTMEM_DEFAULT              6422
#define IDH_SYSTEM_VIRTMEM_SWAPDRIVE            6424
#define IDH_SYSTEM_VIRTMEM_MINSIZE              6427
#define IDH_SYSTEM_VIRTMEM_MAXSIZE              6428

#define IDH_SYSTEM_DEVRES_DESC                  6442
#define IDH_SYSTEM_CONFLICT_IO                  6443
#define IDH_SYSTEM_EDITRANGE_STARTVAL           6444
#define IDH_SYSTEM_CONFLICT_USED                6445
#define IDH_SYSTEM_DM_REMOVE                    6446

#define IDH_POWERCFG_ENABLEMETER                        6452
#define IDH_POWERCFG_POWERSTATUSBAR                     6453
#define IDH_POWERCFG_PMLEVELLIST                        6454
#define IDH_POWERCFG_OPTIONS                            6455

#define IDH_PCMCIA_SELECT                               6458
#define IDH_PCMCIA_MEMORY                               6459
#define IDH_PCMCIA_SOUND                                6460
#define IDH_PCMCIA_CARDSERV                             6461

#define IDH_SYSTEM_DEVGEN_DEVDESC                       6462
#define IDH_SYSTEM_DEVRES_MAKEFC                        6463

#define IDH_SYSTEM_DEVRES_LISTCONFLICT                  6474

#define IDH_SYSTEM_VIEW_LIST                            6483
#define IDH_SYSTEM_RCW_LIST                             6485
#define IDH_SYSTEM_RCW_DETAILS                          6488

#define IDH_POWERCFG_STARTMENU          6491
#define IDH_BATMETER_LOWBATWARN         6492

#define IDH_PCMCIA_TRAY                                 6493
#define IDH_PCMCIA_EJECT                                6494
#define IDH_PCMCIA_WARN                                 6495
#define IDH_PCMCIA_LIST                                 6496

// More WinDisk IDs

#define IDH_WINDISK_DDEMDBPB_IGNORE                             7000
#define IDH_WINDISK_DDEMDBPB_REPAIR                             7005
#define IDH_WINDISK_DDERRBOOT_IGNORE                            7010
#define IDH_WINDISK_DDERRBOOT_REPAIR                            7015
#define IDH_WINDISK_DDERRCVFNM_IGNORE                           7020
#define IDH_WINDISK_DDERRCVFNM_REPAIR                           7025
#define IDH_WINDISK_DDERRLSTSQZ_DISCARD                         7030
#define IDH_WINDISK_DDERRLSTSQZ_IGNORE                          7035
#define IDH_WINDISK_DDERRLSTSQZ_KEEP                            7040
#define IDH_WINDISK_DDERRMDFAT_IGNORE                           7045
#define IDH_WINDISK_DDERRMDFAT_REPAIR                           7050
#define IDH_WINDISK_DDERRSIG_IGNORE                             7055
#define IDH_WINDISK_DDERRSIG_REPAIR                             7060
#define IDH_WINDISK_DDERRXLSQZ_COPY                             7065
#define IDH_WINDISK_DDERRXLSQZ_DELETE                           7070
#define IDH_WINDISK_DDERRXLSQZ_IGNORE                           7075
#define IDH_WINDISK_DDESIZE2_IGNORE                             7080
#define IDH_WINDISK_DDESIZE2_REPAIR                             7085
#define IDH_WINDISK_FATERRCDLIMIT_DELETE                        7090
#define IDH_WINDISK_FATERRCDLIMIT_IGNORE                        7095
#define IDH_WINDISK_FATERRCDLIMIT_REPAIR                        7100
#define IDH_WINDISK_FATERRFILE_DELETE_FILE                      7105
#define IDH_WINDISK_FATERRFILE_DELETE_FOLDER                    7107
#define IDH_WINDISK_FATERRFILE_IGNORE                           7110
#define IDH_WINDISK_FATERRFILE_REPAIR                           7115
#define IDH_WINDISK_FATERRLSTCLUS_CONVERT                       7120
#define IDH_WINDISK_FATERRLSTCLUS_DISCARD                       7125
#define IDH_WINDISK_FATERRLSTCLUS_IGNORE                        7130
#define IDH_WINDISK_FATERRMISMAT_DONT_REPAIR                    7135
#define IDH_WINDISK_FATERRMISMAT_REPAIR                         7140
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FILE                    7145
#define IDH_WINDISK_FATERRMXPLEN_DELETE_FOLDER                  7150
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FILE                    7155
#define IDH_WINDISK_FATERRMXPLEN_IGNORE_FOLDER                  7160
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FILE                    7165
#define IDH_WINDISK_FATERRMXPLEN_REPAIR_FOLDER                  7170
#define IDH_WINDISK_FATERRRESVAL_DONT_REPAIR                    7175
#define IDH_WINDISK_FATERRRESVAL_REPAIR                         7180
#define IDH_WINDISK_FATERRXLNK_COPY                             7185
#define IDH_WINDISK_FATERRXLNK_DELETE                           7190
#define IDH_WINDISK_FATERRXLNK_IGNORE                           7195
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_DEL_OTH                 7200
#define IDH_WINDISK_FATERRXLNK_KEEP_SEL_TRUNC_OTH               7205
#define IDH_WINDISK_FATERRXLNK_TRUNCATE_ALL                     7210
#define IDH_WINDISK_ISBAD_COMP_HOST_DONE_REPAIR                 7215
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_REPAIR              7220
#define IDH_WINDISK_ISBAD_COMP_HOST_NOTDONE_RESTART             7225
#define IDH_WINDISK_ISBAD_COMP_RETRY                            7230
#define IDH_WINDISK_ISBAD_IGNORE                                7235
#define IDH_WINDISK_ISBAD_SYSTEM_IGNORE                         7240
#define IDH_WINDISK_ISBAD_SYSTEM_RETRY                          7245
#define IDH_WINDISK_ISBAD_UNCOMP_DATA_REPAIR                    7250
#define IDH_WINDISK_ISBAD_UNCOMP_RETRY                          7255
#define IDH_WINDISK_ISNTBAD_RETRY                               7260
#define IDH_WINDISK_ISNTBAD_CLEAR                               7265
#define IDH_WINDISK_ISNTBAD_LEAVE                               7270
#define IDH_WINDISK_ISTR_FATERRCIRCC_DELETE                     7275
#define IDH_WINDISK_ISTR_FATERRCIRCC_IGNORE                     7280
#define IDH_WINDISK_ISTR_FATERRCIRCC_TRUNCATE                   7285
#define IDH_WINDISK_ISTR_FATERRDIR_DELETE                       7290
#define IDH_WINDISK_ISTR_FATERRDIR_IGNORE                       7295
#define IDH_WINDISK_ISTR_FATERRDIR_REPAIR                       7300
#define IDH_WINDISK_ISTR_FATERRINVCLUS_DELETE                   7305
#define IDH_WINDISK_ISTR_FATERRINVCLUS_IGNORE                   7310
#define IDH_WINDISK_ISTR_FATERRINVCLUS_TRUNCATE                 7315
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_NOTSET      7320
#define IDH_WINDISK_ISTR_FATERRVOLLAB_DELETE_ISFRST_SET         7330
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_NOTSET      7340
#define IDH_WINDISK_ISTR_FATERRVOLLAB_IGNORE_ISFRST_SET         7350
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_NOTSET      7360
#define IDH_WINDISK_ISTR_FATERRVOLLAB_REPAIR_ISFRST_SET         7370
#define IDH_WINDISK_MEMORYERROR_IGNORE                          7380
#define IDH_WINDISK_MEMORYERROR_RETRY                           7385
#define IDH_WINDISK_READERROR_RETRY                             7390
#define IDH_WINDISK_READWRITEERROR_COMP_SYSTEM_IGNORE           7395
#define IDH_WINDISK_READWRITEERROR_COMP_THOROUGH                7400
#define IDH_WINDISK_READWRITEERROR_DATA_IGNORE                  7405
#define IDH_WINDISK_READWRITEERROR_UNCOMP_SYSTEM_IGNORE         7410
#define IDH_WINDISK_READWRITEERROR_UNCOMP_THOROUGH              7415
#define IDH_WINDISK_WRITEERROR_RETRY                            7420
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FILE              7425
#define IDH_WINDISK_FATERRMXPLEN_SHORT_IGNORE_FOLDER            7430
#define IDH_SCANDISK                                            7431
#define IDH_SCANDISK_FINISH                                     7432
#define IDH_SCANDISK_FINISH_SURF_HOST                           7433
#define IDH_SCANDISK_FINISH_SURF                                7434
#define IDH_COMPRESS_CORRECT_SIZE                               7435
#define IDH_COMPRESS_CORRECT_RATIO                              7436
#define IDH_UTILITIES_DEFRAG_DISK_ERROR                         7437
#define IDH_CVF_TOO_SMALL_CHECK_HOST                            7438
#define IDH_THOROUGH_TEST_CHECK_HOST                            7439
#define IDH_DISK_LOGICAL                                        7440
#define IDH_DISK_PHYSICAL                                       7441
#define IDH_WINDISK_DDERRMDFAT_LOST_REPAIR                      7442
#define IDH_WINDISK_DDERRMDFAT_LOST_IGNORE                      7443
#define IDH_WINDISK_ISBAD_NO_FREE_CLUSTER                       7444
#define IDH_WINDISK_MAIN_LIST                                   7445
#define IDH_WINDISK_MAIN_STANDARD                               7446
#define IDH_WINDISK_MAIN_OPTIONS                                7447
#define IDH_WINDISK_MAIN_THOROUGH                               7448
#define IDH_WINDISK_MAIN_AUTOFIX                                7449
#define IDH_WINDISK_MAIN_ADVANCED                               7450
#define IDH_WINDISK_ADV_ALWAYS                                  7451
#define IDH_WINDISK_ADV_NEVER                                   7452
#define IDH_WINDISK_ADV_ONLY_IF_FOUND                           7453
#define IDH_WINDISK_ADV_DELETE                                  7454
#define IDH_WINDISK_ADV_MAKE_COPIES                             7455
#define IDH_WINDISK_ADV_IGNORE                                  7456
#define IDH_WINDISK_ADV_FILENAME                                7457
#define IDH_WINDISK_ADV_DATE_TIME                               7458
#define IDH_WINDISK_ADV_CHECK_HOST                              7459
#define IDH_WINDISK_ADV_FREE                                    7460
#define IDH_WINDISK_ADV_CONVERT                                 7461
#define IDH_WINDISK_OPTIONS_SYS_AND_DATA                        7462
#define IDH_WINDISK_OPTIONS_SYS_ONLY                            7463
#define IDH_WINDISK_OPTIONS_DATA_ONLY                           7464
#define IDH_WINDISK_OPTIONS_NO_WRITE_TEST                       7465
#define IDH_WINDISK_OPTIONS_NO_HID_SYS                          7466
#define IDH_FORMATDLG_CAPACITY                                  7467
#define IDH_FORMATDLG_QUICK                                     7468
#define IDH_FORMATDLG_FULL                                      7469
#define IDH_FORMATDLG_DOSYS                                     7470
#define IDH_FORMATDLG_LABEL                                     7471
#define IDH_FORMATDLG_NOLAB                                     7472
#define IDH_FORMATDLG_REPORT                                    7473
#define IDH_FORMATDLG_MKSYS                                     7474
#define IDH_WINDISK_MAIN_START                                  7475
#define IDH_WINDISK_MAIN_CLOSE                                  7476
#define IDH_WINDISK_OK_FOR_ERRORS                               7477
#define IDH_WINDISK_CANCEL_FOR_ERRORS                           7478
#define IDH_WINDISK_MORE_INFO                                   7479
#define IDH_FORMATDLG_START                                     7480
#define IDH_WINDISK_REPLACE_LOG                                 7481
#define IDH_WINDISK_APPEND_LOG                                  7482
#define IDH_WINDISK_NO_LOG                                      7483
#define IDH_FORMATDLG_FILESYS                                   7484
#define IDH_FORMATDLG_ALLOCSIZE                                 7485
#define IDH_FORMATDLG_QUICKFULL                                 7486
#define IDH_FORMATDLG_COMPRESS                                  7487

#define IDH_CHKDSKDLG_START                                     7488
#define IDH_CHKDSKDLG_FIXERRORS                                 7489
#define IDH_CHKDSKDLG_SCAN                                      7490
#define IDH_CHKDSKDLG_CANCEL                                    7491
#define IDH_CHKDSKDLG_PROGRESS                                  7492
#define IDH_FORMATDLG_PROGRESS                                  7493

// IDs for Port Settings

#define IDH_PORT_BAUD                                           7900
#define IDH_PORT_DATA                                           7901
#define IDH_PORT_PARITY                                         7902
#define IDH_PORT_STOPBITS                                       7903
#define IDH_PORT_FLOW                                           7904
#define IDH_PORT_RESTORE                                        7905

// IDs for Modem Diagnostics

#define IDH_MODEM_DIAG_INSTALLED                                7950
#define IDH_MODEM_DIAG_HELP                                     7951
#define IDH_MODEM_DIAG_MOREINFO                                 7952
#define IDH_MODEM_DIAG_DRIVER                                   7953

// IDs for Wastebasket/Recycle

#define IDH_WASTE_FREEING_DISK_SPACE                            8000
#define IDH_RECYCLE_CONFIG_INDEP                                8001
#define IDH_RECYCLE_CONFIG_ALL                                  8002
#define IDH_RECYCLE_PURGE_ON_DEL                                8003
#define IDH_RECYCLE_MAX_SIZE                                    8004
#define IDH_RECYCLE_DRIVE_SIZE                                  8005
#define IDH_RECYCLE_BIN_SIZE                                    8006
#define IDH_DELETE_CONFIRM_DLG                                  8007

// ID values 8100-8199 are reserved for Font dialog.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1995, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE
   and is included in ole2.h.

   NOTE: The second least significant byte of all of these GUIDs is 1.
*/


DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,                        0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,                          0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\oledbshl.h ===
//+-------------------------------------------------------------------------
//
//  OLEDBSHL
//  Copyright (C) Microsoft, 1995
//
//  File:       oledbshl.h
//
//  Contents:   External exports of functions and types, in C style
//              for consumers like shell32.dll
//
//  History:    6-26-95  Davepl  Created
//
//--------------------------------------------------------------------------

#ifdef __cplusplus
extern "C" {            
#endif                  

HRESULT COFSFolder_CreateFromIDList(LPCITEMIDLIST pidl, REFIID riid, LPVOID * ppvOut);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\linkinfo.h ===
/*
 * linkinfo.h - LinkInfo ADT module description.
 */


#ifndef __LINKINFO_H__
#define __LINKINFO_H__


#ifdef __cplusplus
extern "C" {                     /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct export or import of DLL functions. */

#ifdef _LINKINFO_
#define LINKINFOAPI
#else
#define LINKINFOAPI        DECLSPEC_IMPORT
#endif


/* Types
 ********/

/* LinkInfo structure */

typedef struct _linkinfo
{
   /* size of LinkInfo structure, including ucbSize field */

   UINT ucbSize;
}
LINKINFO;
typedef LINKINFO *PLINKINFO;
typedef const LINKINFO CLINKINFO;
typedef const LINKINFO *PCLINKINFO;

/* input flags to ResolveLinkInfo() */

typedef enum _resolvelinkinfoinflags
{
   /* Set up connection to referent. */

   RLI_IFL_CONNECT      = 0x0001,

   /*
    * Set up temporary connection to referent.  May only be set if
    * RLI_IFL_CONNECT is also set.
    */

   RLI_IFL_TEMPORARY    = 0x0002,

   /* Allow interaction with user. */

   RLI_IFL_ALLOW_UI     = 0x0004,

   /* Resolve to redirected local device path. */

   RLI_IFL_REDIRECT     = 0x0008,

   /* Update source LinkInfo structure if necessary. */

   RLI_IFL_UPDATE       = 0x0010,

   /* Search matching local devices for missing volume. */

   RLI_IFL_LOCAL_SEARCH = 0x0020,

   /* flag combinations */

   ALL_RLI_IFLAGS       = (RLI_IFL_CONNECT |
                           RLI_IFL_TEMPORARY |
                           RLI_IFL_ALLOW_UI |
                           RLI_IFL_REDIRECT |
                           RLI_IFL_UPDATE |
                           RLI_IFL_LOCAL_SEARCH)
}
RESOLVELINKINFOINFLAGS;

/* output flags from ResolveLinkInfo() */

typedef enum _resolvelinkinfooutflags
{
   /*
    * Only set if RLI_IFL_UPDATE was set in dwInFlags.  The source LinkInfo
    * structure needs updating, and *ppliUpdated points to an updated LinkInfo
    * structure.
    */

   RLI_OFL_UPDATED      = 0x0001,

   /*
    * Only set if RLI_IFL_CONNECT was set in dwInFlags.  A connection to a net
    * resource was established to resolve the LinkInfo.  DisconnectLinkInfo()
    * should be called to shut down the connection when the caller is finished
    * with the remote referent.  DisconnectLinkInfo() need not be called if
    * RLI_IFL_TEMPORARY was also set in dwInFlags.
    */

   RLI_OFL_DISCONNECT   = 0x0002,

   /* flag combinations */

   ALL_RLI_OFLAGS       = (RLI_OFL_UPDATED |
                           RLI_OFL_DISCONNECT)
}
RESOLVELINKINFOOUTFLAGS;

/* LinkInfo data types used by GetLinkInfo() */

typedef enum _linkinfodatatype
{
   /* PCDWORD - pointer to volume's serial number */

   LIDT_VOLUME_SERIAL_NUMBER,

   /* PCUINT - pointer to volume's host drive type */

   LIDT_DRIVE_TYPE,

   /* PCSTR - pointer to volume's label */

   LIDT_VOLUME_LABEL,

   /* PCSTR - pointer to local base path */

   LIDT_LOCAL_BASE_PATH,

   /* PCSTR - pointer to parent network resource's name */

   LIDT_NET_RESOURCE,

   /* PCSTR - pointer to last device redirected to parent network resource */

   LIDT_REDIRECTED_DEVICE,

   /* PCSTR - pointer to common path suffix */

   LIDT_COMMON_PATH_SUFFIX,

   /* PCDWORD - pointer to network type */

   LIDT_NET_TYPE,

   /* PCWSTR - pointer to possible unicode volume label */

   LIDT_VOLUME_LABELW,

   /* PCSTR - pointer to possible unicode parent network resource's name */

   LIDT_NET_RESOURCEW,

   /* PCSTR - pointer to possible unicode last device redirected to parent network resource */

   LIDT_REDIRECTED_DEVICEW,

   /* PCWSTR - pointer to possible unicode local base path */

   LIDT_LOCAL_BASE_PATHW,

   /* PCWSTR - pointer to possible unicode common path suffix */

   LIDT_COMMON_PATH_SUFFIXW
}
LINKINFODATATYPE;

/* output flags from GetCanonicalPathInfo() */

typedef enum _getcanonicalpathinfooutflags
{
   /* The path is on a remote volume. */

   GCPI_OFL_REMOTE      = 0x0001,

   /* flag combinations */

   ALL_GCPI_OFLAGS      = GCPI_OFL_REMOTE
}
GETCANONICALPATHINFOOUTFLAGS;


/* Prototypes
 *************/

/* LinkInfo APIs */

LINKINFOAPI BOOL WINAPI CreateLinkInfoA(LPCSTR, PLINKINFO *);
LINKINFOAPI BOOL WINAPI CreateLinkInfoW(LPCWSTR, PLINKINFO *);

#ifdef UNICODE
#define CreateLinkInfo  CreateLinkInfoW
#else
#define CreateLinkInfo  CreateLinkInfoA
#endif

LINKINFOAPI void WINAPI DestroyLinkInfo(PLINKINFO);
LINKINFOAPI int WINAPI CompareLinkInfoReferents(PCLINKINFO, PCLINKINFO);
LINKINFOAPI int WINAPI CompareLinkInfoVolumes(PCLINKINFO, PCLINKINFO);

LINKINFOAPI BOOL WINAPI ResolveLinkInfoA(PCLINKINFO, LPSTR, DWORD, HWND, PDWORD, PLINKINFO *);
LINKINFOAPI BOOL WINAPI ResolveLinkInfoW(PCLINKINFO, LPWSTR, DWORD, HWND, PDWORD, PLINKINFO *);

#ifdef UNICODE
#define ResolveLinkInfo ResolveLinkInfoW
#else
#define ResolveLinkInfo ResolveLinkInfoA
#endif

LINKINFOAPI BOOL WINAPI DisconnectLinkInfo(PCLINKINFO);
LINKINFOAPI BOOL WINAPI GetLinkInfoData(PCLINKINFO, LINKINFODATATYPE, const VOID **);
LINKINFOAPI BOOL WINAPI IsValidLinkInfo(PCLINKINFO);

/* canonical path APIs */

LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoA(LPCSTR, LPSTR, LPDWORD, LPSTR, LPSTR *);
LINKINFOAPI BOOL WINAPI GetCanonicalPathInfoW(LPCWSTR, LPWSTR, LPDWORD, LPWSTR, LPWSTR *);

#ifdef UNICODE
#define GetCanonicalPathInfo    GetCanonicalPathInfoW
#else
#define GetCanonicalPathInfo    GetCanonicalPathInfoA
#endif


#ifdef __cplusplus
}                                /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __LINKINFO_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\indirect.h ===
/*
 * indirect.h - Object synchronization engine API types for type-safe indirect
 *              calling.
 */


/*
 * N.b., these API types must match the function prototypes defined in
 * <synceng.h>.  An API function pointer variable may be declared and called in
 * a type-safe manner as an instance of one of the given types, e.g.,
 *
 * HINSTANCE hinstSyncEng;
 *
 * hinstSyncEng = LoadLibrary("synceng.dll");
 *
 * if (hinstSyncEng > HINSTANCE_ERROR)
 * {
 *    OPENBRIEFCASEINDIRECT OpenBriefcaseIndirect;
 *
 *    OpenBriefcaseIndirect = (OPENBRIEFCASEINDIRECT)GetProcAddress(hinstSyncEng, "OpenBriefcase");
 *
 *    if (OpenBriefcaseIndirect)
 *    {
 *       TWINRESULT tr;
 *       HBRFCASE hbr;
 *
 *       tr = (*OpenBriefcaseIndirect)("c:\\chicago\\desktop\\foo.bfc\\briefcase.bfc", OB_FL_TANSLATE_DB_FOLDER, &hbr);
 *    }
 * }
 */


/* Types
 ********/

/* briefcase interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *OPENBRIEFCASEINDIRECT)(LPCTSTR, DWORD, HWND, PHBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *SAVEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLOSEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETEBRIEFCASEINDIRECT)(LPCTSTR);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOPENBRIEFCASEINFOINDIRECT)(HBRFCASE, POPENBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLEARBRIEFCASECACHEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDFIRSTBRIEFCASEINDIRECT)(PHBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDNEXTBRIEFCASEINDIRECT)(HBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDBRIEFCASECLOSEINDIRECT)(HBRFCASEITER);

/* twin interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ADDOBJECTTWININDIRECT)(HBRFCASE, PCNEWOBJECTTWIN, PHTWINFAMILY);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDFOLDERTWININDIRECT)(HBRFCASE, PCNEWFOLDERTWIN, PHFOLDERTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *RELEASETWINHANDLEINDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETETWININDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOBJECTTWINHANDLEINDIRECT)(HBRFCASE, LPCTSTR, LPCTSTR, PHOBJECTTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISFOLDERTWININDIRECT)(HBRFCASE, LPCTSTR, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *CREATEFOLDERTWINLISTINDIRECT)(HBRFCASE, LPCTSTR, PFOLDERTWINLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYFOLDERTWINLISTINDIRECT)(PFOLDERTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISORPHANOBJECTTWININDIRECT)(HOBJECTTWIN, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *COUNTSOURCEFOLDERTWINSINDIRECT)(HOBJECTTWIN, PULONG);
typedef SYNCENGAPI TWINRESULT (WINAPI *ANYTWINSINDIRECT)(HBRFCASE, PBOOL);

/* twin list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATETWINLISTINDIRECT)(HBRFCASE, PHTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDTWINTOTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDALLTWINSTOTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVETWINFROMTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVEALLTWINSFROMTWINLISTINDIRECT)(HTWINLIST);

/* reconciliation list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATERECLISTINDIRECT)(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYRECLISTINDIRECT)(PRECLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *RECONCILEITEMINDIRECT)(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
typedef SYNCENGAPI TWINRESULT (WINAPI *BEGINRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *ENDRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETFOLDERTWINSTATUSINDIRECT)(HFOLDERTWIN, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

/* file stamp interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *GETFILESTAMPINDIRECT)(LPCTSTR, PFILESTAMP);
typedef SYNCENGAPI TWINRESULT (WINAPI *COMPAREFILESTAMPSINDIRECT)(PCFILESTAMP, PCFILESTAMP, PCOMPARISONRESULT);

/* volume ID interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ISPATHONVOLUMEINDIRECT)(LPCTSTR, HVOLUMEID, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETVOLUMEDESCRIPTIONINDIRECT)(HVOLUMEID, PVOLUMEDESC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((UINT)(x))
#define OFFSETOF(x)     ((UINT)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) ((BOOL)hinst)

#define DATASEG_READONLY    ".text"     // read only data, same as one generated by linker
#define DATASEG_PERINSTANCE "INSTDATA"    // per instance data
#define DATASEG_SHARED                  // default data goes here
#define CODESEG_INIT        ".text"

#define GetWindowInt            GetWindowLong
#define SetWindowInt            SetWindowLong
#define SetWindowID(hwnd,id)    SetWindowLong(hwnd, GWL_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLong(hwnd, GCL_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLong(hwnd, GCL_HICON))

#else  // !WIN32

#define ISLPTR(pv)              (SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT        "_INIT"

#define GetWindowInt            GetWindowWord
#define SetWindowInt            SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\recguids.h ===
/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\prshtp.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHTP_H_
#define _PRSHTP_H_

#ifdef __cplusplus
extern "C" {
#endif

#define PSP_ANSI                0x0100  // Used in Unicode version only
#define PSP_SHPAGE              0x0200  // Used in Unicode version only
#define PSP_ALL                 0x07FF
#define PSP_IS16                0x8000
#define PSH_ALL                 0x0FFF
#ifdef _WIN32
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage32Ex(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreateProxyPage(HPROPSHEETPAGE hpage16, HINSTANCE hinst16);
#endif
// these need to match shell.h's ranges
#define PSN_HASHELP             (PSN_FIRST-4)
#define PropSheet_SetWizButtonsNow(hDlg, dwFlags) PropSheet_SetWizButtons(hDlg, dwFlags)
#ifdef CC_INTERNAL

//
//  Flag values for dwInternalFlags
//

#define PSPI_RESERVED           1

typedef struct _PSP {
#ifdef UNICODE
    DWORD   dwInternalFlags;
    LPVOID  lpANSIPage;
#endif
    PROPSHEETPAGE psp;
    // NOTE: the above member can be variable size so don't add any
    // structure members here
} PSP, FAR *HPROPSHEETPAGE;

typedef struct
{
    HWND hDlg;          // the dialog for this instance data
    PROPSHEETHEADER psh;

    HWND hwndCurPage;   // current page hwnd
    HWND hwndTabs;      // tab control window
    int nCurItem;       // index of current item in tab control
    int idDefaultFallback; // the default id to set as DEFID if page doesn't have one

    int nReturn;
    UINT nRestart;

    int xSubDlg, ySubDlg;       // dimensions of sub dialog
    int cxSubDlg, cySubDlg;

    BOOL fFlags;

} PROPDATA, FAR *LPPROPDATA;
// defines for fFlags
#define PD_NOERASE       0x0001
#define PD_CANCELTOCLOSE 0x0002
#define PD_DESTROY       0x0004

#ifndef _WIN32
//
//
typedef struct
{
        DWORD style;
        BYTE  cdit;
        WORD  x;
        WORD  y;
        WORD  cx;
        WORD  cy;
} DLGTEMPLATE, FAR *LPDLGTEMPLATE;
typedef const DLGTEMPLATE FAR *LPCDLGTEMPLATE;
#endif

#endif // CC_INTERNAL

#ifdef __cplusplus
}
#endif

#endif // _PRSHTP_H_     //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shcompui.h ===
#ifndef __SHCOMPUI_H
#define __SHCOMPUI_H
///////////////////////////////////////////////////////////////////////////////
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995.
//
//  FILE: SHCOMPUI.H
//
//  DESCRIPTION:
//
//    Header for users of SHCOMPUI.DLL.
//
//    REVISIONS:
//
//    Date       Description                                         Programmer
//    ---------- --------------------------------------------------- ----------
//    09/15/95   Initial creation.                                   brianau
//    09/21/95   Changes per first code review.                      brianau
//    09/28/95   Added SCCA_CONTEXT structure.                       brianau
//
///////////////////////////////////////////////////////////////////////////////
#ifdef WINNT

#include <windows.h>

//
// Define a context structure for keeping track of what's going on during the
// compression/uncompression operations.
//
typedef struct {
   BOOL bIgnoreAllErrors;       // User wants to ignore all errors.
   DWORD uCompletionReason;     // Reason operation completed.
   DWORD cErrors;               // Number of errors on last call.
   DWORD cCummErrors;           // Cummulative error count.
} SCCA_CONTEXT, *LPSCCA_CONTEXT;


//
// Values for uCompletionReason member of SCCA_CONTEXT.
//
#define SCCA_REASON_NORMAL         0  // No problems.
#define SCCA_REASON_USERCANCEL     1  // User cancel in confirm dlg.
#define SCCA_REASON_USERABORT      2  // User abort in error dlg.
#define SCCA_REASON_IOERROR        3  // Device IO error.
#define SCCA_REASON_DISKFULL       4  // Disk full on uncompression.

//
// Initialize a new context structure.
// Use address of structure as argument.
//
#define SCCA_CONTEXT_INIT(c)  { memset((LPVOID)c, 0, sizeof(SCCA_CONTEXT)); }

//
// To call this function, create a SCCA_CONTEXT variable, initialize
// it with SCCA_CONTEXT_INIT( ) and pass it's address in the "context"
// argument.  The context structure maintains information that must
// persist between successive calls while processing an Explorer
// selection set.  The structure is also used to collect performance
// data such as error counts and completion status that may be queried
// once the function returns.
//
BOOL ShellChangeCompressionAttribute(HWND hActiveWnd, LPTSTR szNameSpec,
                      LPSCCA_CONTEXT context, BOOL bCompress, BOOL bShowUI);

#define SZ_SHCOMPUI_DLLNAME    __TEXT("SHCOMPUI.DLL")

//
// Note:  This must be an ANSI string for GetProcAddress( ).
//
#define SZ_COMPRESS_PROCNAME   "ShellChangeCompressionAttribute"


#endif  // ifdef WINNT

#endif  // ifdef __SHCOMPUI_H


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\reconcil.h ===
/*
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__


/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shlapip.h ===
#ifndef _SHELAPIP_
#define _SHELAPIP_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#include <pshpack1.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


WINSHELLAPI HICON     APIENTRY DuplicateIcon(HINSTANCE hInst, HICON hIcon);
WINSHELLAPI HICON     APIENTRY ExtractAssociatedIconExA(HINSTANCE hInst,LPSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
WINSHELLAPI HICON     APIENTRY ExtractAssociatedIconExW(HINSTANCE hInst,LPWSTR lpIconPath,LPWORD lpiIconIndex, LPWORD lpiIconId);
#ifdef UNICODE
#define ExtractAssociatedIconEx  ExtractAssociatedIconExW
#else
#define ExtractAssociatedIconEx  ExtractAssociatedIconExA
#endif // !UNICODE
#define ABE_MAX         4
WINSHELLAPI HGLOBAL APIENTRY InternalExtractIconA(HINSTANCE hInst, LPCSTR lpszFile, UINT nIconIndex, UINT nIcons);
WINSHELLAPI HGLOBAL APIENTRY InternalExtractIconW(HINSTANCE hInst, LPCWSTR lpszFile, UINT nIconIndex, UINT nIcons);
#ifdef UNICODE
#define InternalExtractIcon  InternalExtractIconW
#else
#define InternalExtractIcon  InternalExtractIconA
#endif // !UNICODE
WINSHELLAPI HGLOBAL APIENTRY InternalExtractIconListA(HANDLE hInst, LPSTR lpszExeFileName, LPINT lpnIcons);
WINSHELLAPI HGLOBAL APIENTRY InternalExtractIconListW(HANDLE hInst, LPWSTR lpszExeFileName, LPINT lpnIcons);
#ifdef UNICODE
#define InternalExtractIconList  InternalExtractIconListW
#else
#define InternalExtractIconList  InternalExtractIconListA
#endif // !UNICODE
WINSHELLAPI DWORD   APIENTRY DoEnvironmentSubstA(LPSTR szString, UINT cbString);
WINSHELLAPI DWORD   APIENTRY DoEnvironmentSubstW(LPWSTR szString, UINT cbString);
#ifdef UNICODE
#define DoEnvironmentSubst  DoEnvironmentSubstW
#else
#define DoEnvironmentSubst  DoEnvironmentSubstA
#endif // !UNICODE
WINSHELLAPI BOOL    APIENTRY RegisterShellHook(HWND, BOOL);
WINSHELLAPI LPSTR APIENTRY FindEnvironmentStringA(LPSTR szEnvVar);
WINSHELLAPI LPWSTR APIENTRY FindEnvironmentStringW(LPWSTR szEnvVar);
#ifdef UNICODE
#define FindEnvironmentString  FindEnvironmentStringW
#else
#define FindEnvironmentString  FindEnvironmentStringA
#endif // !UNICODE
#define SHGetNameMappingCount(_hnm) DSA_GetItemCount(_hnm)
#define SHGetNameMappingPtr(_hnm, _iItem) (LPSHNAMEMAPPING)DSA_GetItemPtr(_hnm, _iItem)
typedef struct _RUNDLL_NOTIFYA
{
    NMHDR     hdr;
    HICON     hIcon;
    LPSTR     lpszTitle;
} RUNDLL_NOTIFYA;
typedef struct _RUNDLL_NOTIFYW
{
    NMHDR     hdr;
    HICON     hIcon;
    LPWSTR    lpszTitle;
} RUNDLL_NOTIFYW;
#ifdef UNICODE
typedef RUNDLL_NOTIFYW RUNDLL_NOTIFY;
#else
typedef RUNDLL_NOTIFYA RUNDLL_NOTIFY;
#endif // UNICODE
typedef void (WINAPI FAR * RUNDLLPROCA) (HWND      hwndStub,
                                         HINSTANCE hInstance,
                                         LPSTR   lpszCmdLine,
                                         int       nCmdShow);
typedef void (WINAPI FAR * RUNDLLPROCW) (HWND      hwndStub,
                                         HINSTANCE hInstance,
                                         LPWSTR   lpszCmdLine,
                                         int       nCmdShow);
#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif // !UNICODE
#define RDN_FIRST       (0U-500U)
#define RDN_LAST        (0U-509U)
#define RDN_TASKINFO    (RDN_FIRST-0)
#define SEN_DDEEXECUTE (SEN_FIRST-0)
#ifndef NOUSER
typedef struct {
    NMHDR  hdr;
    CHAR   szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
} NMVIEWFOLDERA, FAR * LPNMVIEWFOLDERA;
typedef struct {
    NMHDR  hdr;
    WCHAR  szCmd[MAX_PATH*2];
    DWORD  dwHotKey;
} NMVIEWFOLDERW, FAR * LPNMVIEWFOLDERW;
#ifdef UNICODE
typedef NMVIEWFOLDERW NMVIEWFOLDER;
typedef LPNMVIEWFOLDERW LPNMVIEWFOLDER;
#else
typedef NMVIEWFOLDERA NMVIEWFOLDER;
typedef LPNMVIEWFOLDERA LPNMVIEWFOLDER;
#endif // UNICODE
#endif

HINSTANCE RealShellExecuteA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
HINSTANCE RealShellExecuteW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess);
#ifdef UNICODE
#define RealShellExecute  RealShellExecuteW
#else
#define RealShellExecute  RealShellExecuteA
#endif // !UNICODE
HINSTANCE RealShellExecuteExA(
    HWND hwndParent,
    LPCSTR lpOperation,
    LPCSTR lpFile,
    LPCSTR lpParameters,
    LPCSTR lpDirectory,
    LPSTR lpResult,
    LPCSTR lpTitle,
    LPSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
HINSTANCE RealShellExecuteExW(
    HWND hwndParent,
    LPCWSTR lpOperation,
    LPCWSTR lpFile,
    LPCWSTR lpParameters,
    LPCWSTR lpDirectory,
    LPWSTR lpResult,
    LPCWSTR lpTitle,
    LPWSTR lpReserved,
    WORD nShow,
    LPHANDLE lphProcess,
    DWORD dwFlags);
#ifdef UNICODE
#define RealShellExecuteEx  RealShellExecuteExW
#else
#define RealShellExecuteEx  RealShellExecuteExA
#endif // !UNICODE
//
// RealShellExecuteEx flags
//
#define EXEC_SEPARATE_VDM     0x00000001
#define EXEC_NO_CONSOLE       0x00000002
#define SEE_MASK_FLAG_SHELLEXEC 0x00000800
#define SEE_MASK_FORCENOIDLIST  0x00001000
#define SEE_MASK_NO_HOOKS       0x00002000
#define SEE_MASK_HASLINKNAME    0x00010000
#define SEE_MASK_FLAG_SEPVDM    0x00020000
#define SEE_MASK_RESERVED       0x00040000
#define SEE_MASK_HASTITLE       0x00080000
// All other bits are masked off when we do an InvokeCommand
#define SEE_VALID_CMIC_BITS     0x001F8FF0
#define SEE_VALID_CMIC_FLAGS    0x001F8FC0
// The LPVOID lpIDList parameter is the IDList
WINSHELLAPI void WINAPI WinExecErrorA(HWND hwnd, int error, LPCSTR lpstrFileName, LPCSTR lpstrTitle);
//
// RealShellExecuteEx flags
//
#define EXEC_SEPARATE_VDM     0x00000001
#define EXEC_NO_CONSOLE       0x00000002
#define SEE_MASK_FLAG_SHELLEXEC 0x00000800
#define SEE_MASK_FORCENOIDLIST  0x00001000
#define SEE_MASK_NO_HOOKS       0x00002000
#define SEE_MASK_HASLINKNAME    0x00010000
#define SEE_MASK_FLAG_SEPVDM    0x00020000
#define SEE_MASK_RESERVED       0x00040000
#define SEE_MASK_HASTITLE       0x00080000
// All other bits are masked off when we do an InvokeCommand
#define SEE_VALID_CMIC_BITS     0x001F8FF0
#define SEE_VALID_CMIC_FLAGS    0x001F8FC0
// The LPVOID lpIDList parameter is the IDList
WINSHELLAPI void WINAPI WinExecErrorW(HWND hwnd, int error, LPCWSTR lpstrFileName, LPCWSTR lpstrTitle);
#ifdef UNICODE
#define WinExecError  WinExecErrorW
#else
#define WinExecError  WinExecErrorA
#endif // !UNICODE
typedef struct _TRAYNOTIFYDATAA
{
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA nid;
} TRAYNOTIFYDATAA, *PTRAYNOTIFYDATAA;
typedef struct _TRAYNOTIFYDATAW
{
        DWORD dwSignature;
        DWORD dwMessage;
        NOTIFYICONDATA nid;
} TRAYNOTIFYDATAW, *PTRAYNOTIFYDATAW;
#ifdef UNICODE
typedef TRAYNOTIFYDATAW TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAW PTRAYNOTIFYDATA;
#else
typedef TRAYNOTIFYDATAA TRAYNOTIFYDATA;
typedef PTRAYNOTIFYDATAA PTRAYNOTIFYDATA;
#endif // UNICODE

#define NI_SIGNATURE    0x34753423

#define WNDCLASS_TRAYNOTIFY     "Shell_TrayWnd"
WINSHELLAPI BOOL WINAPI SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL FAR * pfMustCopy, UINT uFlags);
WINSHELLAPI BOOL WINAPI SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL FAR * pfMustCopy, UINT uFlags);
#ifdef UNICODE
#define SHGetNewLinkInfo  SHGetNewLinkInfoW
#else
#define SHGetNewLinkInfo  SHGetNewLinkInfoA
#endif // !UNICODE
//
// Shared memory apis
//

HANDLE SHAllocShared(LPCVOID lpvData, DWORD dwSize, DWORD dwProcessId);
BOOL SHFreeShared(HANDLE hData,DWORD dwProcessId);
LPVOID SHLockShared(HANDLE hData, DWORD dwProcessId);
BOOL SHUnlockShared(LPVOID lpvData);
HANDLE MapHandle(HANDLE h, DWORD dwProcSrc, DWORD dwProcDest, DWORD dwDesiredAccess, DWORD dwFlags);
//
// Old NT Compatibility stuff (remove later)
//
WINSHELLAPI VOID CheckEscapesA(LPSTR lpFileA, DWORD cch);
//
// Old NT Compatibility stuff (remove later)
//
WINSHELLAPI VOID CheckEscapesW(LPWSTR lpFileA, DWORD cch);
#ifdef UNICODE
#define CheckEscapes  CheckEscapesW
#else
#define CheckEscapes  CheckEscapesA
#endif // !UNICODE
WINSHELLAPI LPSTR SheRemoveQuotesA(LPSTR sz);
WINSHELLAPI LPWSTR SheRemoveQuotesW(LPWSTR sz);
#ifdef UNICODE
#define SheRemoveQuotes  SheRemoveQuotesW
#else
#define SheRemoveQuotes  SheRemoveQuotesA
#endif // !UNICODE
WINSHELLAPI WORD ExtractIconResInfoA(HANDLE hInst,LPSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
WINSHELLAPI WORD ExtractIconResInfoW(HANDLE hInst,LPWSTR lpszFileName,WORD wIconIndex,LPWORD lpwSize,LPHANDLE lphIconRes);
#ifdef UNICODE
#define ExtractIconResInfo  ExtractIconResInfoW
#else
#define ExtractIconResInfo  ExtractIconResInfoA
#endif // !UNICODE
WINSHELLAPI int SheSetCurDrive(int iDrive);
WINSHELLAPI int SheChangeDirA(register CHAR *newdir);
WINSHELLAPI int SheChangeDirW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDir  SheChangeDirW
#else
#define SheChangeDir  SheChangeDirA
#endif // !UNICODE
WINSHELLAPI int SheGetDirA(int iDrive, CHAR *str);
WINSHELLAPI int SheGetDirW(int iDrive, WCHAR *str);
#ifdef UNICODE
#define SheGetDir  SheGetDirW
#else
#define SheGetDir  SheGetDirA
#endif // !UNICODE
WINSHELLAPI BOOL SheConvertPathA(LPSTR lpApp, LPSTR lpFile, UINT cchCmdBuf);
WINSHELLAPI BOOL SheConvertPathW(LPWSTR lpApp, LPWSTR lpFile, UINT cchCmdBuf);
#ifdef UNICODE
#define SheConvertPath  SheConvertPathW
#else
#define SheConvertPath  SheConvertPathA
#endif // !UNICODE
WINSHELLAPI BOOL SheShortenPathA(LPSTR pPath, BOOL bShorten);
WINSHELLAPI BOOL SheShortenPathW(LPWSTR pPath, BOOL bShorten);
#ifdef UNICODE
#define SheShortenPath  SheShortenPathW
#else
#define SheShortenPath  SheShortenPathA
#endif // !UNICODE
WINSHELLAPI BOOL RegenerateUserEnvironment(PVOID *pPrevEnv,
                                        BOOL bSetCurrentEnv);
WINSHELLAPI INT SheGetPathOffsetW(LPWSTR lpszDir);
WINSHELLAPI BOOL SheGetDirExW(LPWSTR lpszCurDisk, LPDWORD lpcchCurDir,LPWSTR lpszCurDir);
WINSHELLAPI DWORD ExtractVersionResource16W(LPCWSTR  lpwstrFilename, LPHANDLE lphData);
WINSHELLAPI INT SheChangeDirExA(register CHAR *newdir);
WINSHELLAPI INT SheChangeDirExW(register WCHAR *newdir);
#ifdef UNICODE
#define SheChangeDirEx  SheChangeDirExW
#else
#define SheChangeDirEx  SheChangeDirExA
#endif // !UNICODE
//
// PRINTQ
//
VOID Printer_LoadIconsA(LPCSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
//
// PRINTQ
//
VOID Printer_LoadIconsW(LPCWSTR pszPrinterName, HICON* phLargeIcon, HICON* phSmallIcon);
#ifdef UNICODE
#define Printer_LoadIcons  Printer_LoadIconsW
#else
#define Printer_LoadIcons  Printer_LoadIconsA
#endif // !UNICODE
LPSTR ShortSizeFormatA(DWORD dw, LPSTR szBuf);
LPWSTR ShortSizeFormatW(DWORD dw, LPWSTR szBuf);
#ifdef UNICODE
#define ShortSizeFormat  ShortSizeFormatW
#else
#define ShortSizeFormat  ShortSizeFormatA
#endif // !UNICODE
LPSTR AddCommasA(DWORD dw, LPSTR pszResult);
LPWSTR AddCommasW(DWORD dw, LPWSTR pszResult);
#ifdef UNICODE
#define AddCommas  AddCommasW
#else
#define AddCommas  AddCommasA
#endif // !UNICODE
BOOL Printers_RegisterWindowA(LPCSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
BOOL Printers_RegisterWindowW(LPCWSTR pszPrinter, DWORD dwType, PHANDLE phClassPidl, HWND *phwnd);
#ifdef UNICODE
#define Printers_RegisterWindow  Printers_RegisterWindowW
#else
#define Printers_RegisterWindow  Printers_RegisterWindowA
#endif // !UNICODE
VOID Printers_UnregisterWindow(HANDLE hClassPidl, HWND hwnd);
#define PRINTER_PIDL_TYPE_PROPERTIES       0x1
#define PRINTER_PIDL_TYPE_DOCUMENTDEFAULTS 0x2
#define PRINTER_PIDL_TYPE_JOBID            0x80000000
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#include <poppack.h>
#endif  /* _SHELAPIP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shellp.h ===
#ifndef _SHELLP_H_
#define _SHELLP_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

//
// shell private header
//

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//===========================================================================
#ifndef _SHSEMIP_H_
// Handle to property sheet extension array
DECLARE_HANDLE( HPSXA );
#endif // _SHSEMIP_H_

//===========================================================================
// Shell restrictions. (Parameter for SHRestriction)
typedef enum
{
        REST_NONE                       = 0x00000000,
        REST_NORUN                      = 0x00000001,
        REST_NOCLOSE                    = 0x00000002,
        REST_NOSAVESET                  = 0x00000004,
        REST_NOFILEMENU                 = 0x00000008,
        REST_NOSETFOLDERS               = 0x00000010,
        REST_NOSETTASKBAR               = 0x00000020,
        REST_NODESKTOP                  = 0x00000040,
        REST_NOFIND                     = 0x00000080,
        REST_NODRIVES                   = 0x00000100,
        REST_NODRIVEAUTORUN             = 0x00000200,
        REST_NODRIVETYPEAUTORUN         = 0x00000400,
        REST_NONETHOOD                  = 0x00000800,
        REST_STARTBANNER                = 0x00001000,
        REST_RESTRICTRUN                = 0x00002000,
        REST_NOPRINTERTABS              = 0x00004000,
        REST_NOPRINTERDELETE            = 0x00008000,
        REST_NOPRINTERADD               = 0x00010000,
        REST_NOSTARTMENUSUBFOLDERS      = 0x00020000,
        REST_MYDOCSONNET                = 0x00040000,
        REST_NOEXITTODOS                = 0x00080000,
        REST_ENFORCESHELLEXTSECURITY    = 0x00100000,
	REST_LINKRESOLVEIGNORELINKINFO	= 0x00200000,
        REST_NOCOMMONGROUPS             = 0x00400000,
        REST_SEPARATEDESKTOPPROCESS     = 0x00800000,
} RESTRICTIONS;

WINSHELLAPI HRESULT WINAPI CIDLData_CreateFromIDArray(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[], LPDATAOBJECT * ppdtobj);
WINSHELLAPI BOOL WINAPI SHIsBadInterfacePtr(LPCVOID pv, UINT cbVtbl);
//
// Stream API
//
WINSHELLAPI LPSTREAM WINAPI OpenRegStream(HKEY hkey, LPCTSTR pszSubkey, LPCTSTR pszValue, DWORD grfMode);
WINSHELLAPI LPSTREAM WINAPI OpenFileStream(LPCTSTR szFile, DWORD grfMode);
//
// OLE ripoffs of Drag and Drop related API
//
WINSHELLAPI HRESULT WINAPI SHRegisterDragDrop(HWND hwnd, LPDROPTARGET pdtgt);
WINSHELLAPI HRESULT WINAPI SHRevokeDragDrop(HWND hwnd);
WINSHELLAPI HRESULT WINAPI SHDoDragDrop(HWND hwndOwner, LPDATAOBJECT pdata, LPDROPSOURCE pdsrc, DWORD dwEffect, LPDWORD pdwEffect);
//
// Special folder
//
WINSHELLAPI LPITEMIDLIST WINAPI SHCloneSpecialIDList(HWND hwndOwner, int nFolder, BOOL fCreate);
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);
// DiskFull
WINSHELLAPI void WINAPI SHHandleDiskFull(HWND hwnd, int idDrive);

//
// File Search APIS
//
WINSHELLAPI BOOL WINAPI SHFindFiles(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
WINSHELLAPI BOOL WINAPI SHFindComputer(LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlSaveFile);
//
//
WINSHELLAPI void WINAPI PathGetShortPath(LPTSTR pszLongPath);
WINSHELLAPI BOOL WINAPI PathFindOnPath(LPTSTR szFile, LPCTSTR * ppszOtherDirs);
WINSHELLAPI BOOL WINAPI PathYetAnotherMakeUniqueName(LPTSTR  pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec);
//
WINSHELLAPI BOOL WINAPI Win32CreateDirectory(LPCTSTR lpszPath, LPSECURITY_ATTRIBUTES lpsa);
WINSHELLAPI BOOL WINAPI Win32RemoveDirectory(LPCTSTR lpszPath);
WINSHELLAPI BOOL WINAPI Win32DeleteFile(LPCTSTR lpszPath);

//
// Path processing function
//

#define PPCF_ADDQUOTES               0x00000001        // return a quoted name if required
#define PPCF_ADDARGUMENTS            0x00000003        // appends arguments (and wraps in quotes if required)
#define PPCF_NODIRECTORIES           0x00000010        // don't match to directories
#define PPCF_NORELATIVEOBJECTQUALIFY 0x00000020        // don't return fully qualified relative objects
#define PPCF_FORCEQUALIFY            0x00000040        // qualify even non-relative names

WINSHELLAPI LONG WINAPI PathProcessCommand( LPCTSTR lpSrc, LPTSTR lpDest, int iMax, DWORD dwFlags );

// Convert an IDList into a logical IDList so that desktop folders
// appear at the right spot in the tree
WINSHELLAPI LPITEMIDLIST WINAPI SHLogILFromFSIL(LPCITEMIDLIST pidlFS);

// Convert an ole string.
WINSHELLAPI BOOL WINAPI StrRetToStrN(LPTSTR szOut, UINT uszOut, LPSTRRET pStrRet, LPCITEMIDLIST pidl);

WINSHELLAPI DWORD WINAPI SHWaitForFileToOpen(LPCITEMIDLIST pidl,
                               UINT uOptions, DWORD dwtimeout);
WINSHELLAPI HRESULT WINAPI SHGetRealIDL(LPSHELLFOLDER psf, LPCITEMIDLIST pidlSimple, LPITEMIDLIST * ppidlReal);

WINSHELLAPI void WINAPI SetAppStartingCursor(HWND hwnd, BOOL fSet);

#define DECLAREWAITCURSOR  HCURSOR hcursor_wait_cursor_save
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursor(NULL, IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

WINSHELLAPI DWORD WINAPI SHRestricted(RESTRICTIONS rest);
WINSHELLAPI LPVOID WINAPI SHGetHandlerEntry(LPCTSTR szHandler, LPCSTR szProcName, HINSTANCE *lpModule);

WINSHELLAPI STDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID * lpclsid,
        LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppv);
WINSHELLAPI BOOL  WINAPI SignalFileOpen(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST WINAPI SHSimpleIDListFromPath(LPCTSTR pszPath);
WINSHELLAPI int WINAPI SHCreateDirectory(HWND hwnd, LPCTSTR pszPath);
WINSHELLAPI int WINAPI SHCreateDirectoryEx(HWND hwnd, LPCTSTR pszPath, LPSECURITY_ATTRIBUTES lpsa);

WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );
WINSHELLAPI DWORD SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType) ;
WINSHELLAPI HRESULT SHStartNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType) ;
WINSHELLAPI STDAPI SHLoadOLE(LPARAM lParam);
WINSHELLAPI void WINAPI Desktop_UpdateBriefcaseOnEvent(HWND hwnd, UINT uEvent);

WINSHELLAPI HRESULT WINAPI SHCreateStdEnumFmtEtc(UINT cfmt, const FORMATETC afmt[], LPENUMFORMATETC * ppenumFormatEtc);

// Shell create link API
#define SHCL_USETEMPLATE        0x0001
#define SHCL_USEDESKTOP         0x0002
#define SHCL_CONFIRM            0x0004

WINSHELLAPI HRESULT WINAPI SHCreateLinks(HWND hwnd, LPCTSTR pszDir, IDataObject *pDataObj, UINT fFlags, LPITEMIDLIST* ppidl);

//
// Interface pointer validation
//
#define IsBadInterfacePtr(pitf, ITF)  SHIsBadInterfacePtr(pitf, sizeof(ITF##Vtbl))

//===========================================================================
// Image dragging API (definitely private)
//===========================================================================

// stuff for doing auto scrolling
#define NUM_POINTS      3
typedef struct {        // asd
    int iNextSample;
    DWORD dwLastScroll;
    BOOL bFull;
    POINT pts[NUM_POINTS];
    DWORD dwTimes[NUM_POINTS];
} AUTO_SCROLL_DATA;

#define DAD_InitScrollData(pad) (pad)->bFull = FALSE, (pad)->iNextSample = 0, (pad)->dwLastScroll = 0

WINSHELLAPI BOOL WINAPI DAD_SetDragImage(HIMAGELIST him, POINT * pptOffset);
WINSHELLAPI BOOL WINAPI DAD_DragEnter(HWND hwndTarget);
WINSHELLAPI BOOL WINAPI DAD_DragEnterEx(HWND hwndTarget, const POINT ptStart);
WINSHELLAPI BOOL WINAPI DAD_ShowDragImage(BOOL fShow);
WINSHELLAPI BOOL WINAPI DAD_DragMove(POINT pt);
WINSHELLAPI BOOL WINAPI DAD_DragLeave(void);
WINSHELLAPI BOOL WINAPI DAD_AutoScroll(HWND hwnd, AUTO_SCROLL_DATA *pad, const POINT *pptNow);
WINSHELLAPI BOOL WINAPI DAD_SetDragImageFromListView(HWND hwndLV, POINT ptOffset);

//===========================================================================
// Another block of private API
//===========================================================================

// indexes into the shell image lists (Shell_GetImageList) for default images
// If you add to this list, you also need to update II_LASTSYSICON!

#define II_DOCNOASSOC         0         // document (blank page) (not associated)
#define II_DOCUMENT           1         // document (with stuff on the page)
#define II_APPLICATION        2         // application (exe, com, bat)
#define II_FOLDER             3         // folder (plain)
#define II_FOLDEROPEN         4         // folder (open)
#define II_DRIVE525           5
#define II_DRIVE35            6
#define II_DRIVEREMOVE        7
#define II_DRIVEFIXED         8
#define II_DRIVENET           9
#define II_DRIVENETDISABLED  10
#define II_DRIVECD           11
#define II_DRIVERAM          12
#define II_WORLD             13
#define II_NETWORK           14
#define II_SERVER            15
#define II_PRINTER           16
#define II_MYNETWORK         17
#define II_GROUP             18

// Startmenu images.
#define II_STPROGS           19
#define II_STDOCS            20
#define II_STSETNGS          21
#define II_STFIND            22
#define II_STHELP            23
#define II_STRUN             24
#define II_STSUSPD           25
#define II_STEJECT           26
#define II_STSHUTD           27

#define II_SHARE             28
#define II_LINK              29
#define II_READONLY          30
#define II_RECYCLER          31
#define II_RECYCLERFULL      32
#define II_RNA               33
#define II_DESKTOP           34

// More startmenu image.
#define II_STCPANEL          35
#define II_STSPROGS          36
#define II_STPRNTRS          37
#define II_STFONTS           38
#define II_STTASKBR          39

#define II_CDAUDIO           40
#define II_TREE              41
#define II_STCPROGS          42

#ifdef CITRIX
#define II_CTX_STSECURITY    43
#define II_CTX_STDISCONN     44
#define II_CTX_STLOGOFF      45

// Last system image list icon index - used by icon cache manager
#define II_LASTSYSICON       II_CTX_STLOGOFF
#else
// Last system image list icon index - used by icon cache manager
#define II_LASTSYSICON       II_STCPROGS
#endif

// Overlay indexes
#define II_OVERLAYFIRST      II_SHARE
#define II_OVERLAYLAST       II_READONLY

#define II_NDSCONTAINER      72

WINSHELLAPI BOOL  WINAPI FileIconInit( BOOL fRestoreCache );

WINSHELLAPI BOOL  WINAPI Shell_GetImageLists(HIMAGELIST *phiml, HIMAGELIST *phimlSmall);
WINSHELLAPI void  WINAPI Shell_SysColorChange(void);
WINSHELLAPI int   WINAPI Shell_GetCachedImageIndex(LPCTSTR pszIconPath, int iIconIndex, UINT uIconFlags);

WINSHELLAPI LRESULT WINAPI SHShellFolderView_Message(HWND hwndMain, UINT uMsg, LPARAM lParam);

// A usefull function in Defview for mapping idlist into index into system
// image list.  Optionally it can also look up the index of the selected
// icon.
WINSHELLAPI int WINAPI SHMapPIDLToSystemImageListIndex(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, int *piIndexSel);
//
// OLE string
//
WINSHELLAPI int WINAPI OleStrToStrN(LPTSTR, int, LPCOLESTR, int);
WINSHELLAPI int WINAPI StrToOleStrN(LPOLESTR, int, LPCTSTR, int);
WINSHELLAPI int WINAPI OleStrToStr(LPTSTR, LPCOLESTR);
WINSHELLAPI int WINAPI StrToOleStr(LPOLESTR, LPCTSTR);

//===========================================================================
// Useful macros
//===========================================================================
#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
#define ShortFromResult(r)  (short)SCODE_CODE(GetScode(r))

#ifndef E_PENDING
#define E_PENDING                        _HRESULT_TYPEDEF_(0x8000000AL)
#endif


// Tray CopyData Messages
#define TCDM_APPBAR     0x00000000
#define TCDM_NOTIFY     0x00000001
#define TCDM_LOADINPROC 0x00000002


//===========================================================================
// IShellFolder::UIObject helper
//===========================================================================

STDAPI SHCreateDefExtIconKey(HKEY hkey, LPCTSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON * pxiconOut);
STDAPI SHCreateDefExtIcon(LPCTSTR pszModule, int iIcon, int iIconOpen, UINT uFlags, LPEXTRACTICON * pxiconOut);

//                                  uMsg       wParam       lParam
#define DFM_MERGECONTEXTMENU         1      // uFlags       LPQCMINFO
#define DFM_INVOKECOMMAND            2      // idCmd        pszArgs
#define DFM_ADDREF                   3      // 0            0
#define DFM_RELEASE                  4      // 0            0
#define DFM_GETHELPTEXT              5      // idCmd,cchMax pszText -Ansi
#define DFM_WM_MEASUREITEM           6      // ---from the message---
#define DFM_WM_DRAWITEM              7      // ---from the message---
#define DFM_WM_INITMENUPOPUP         8      // ---from the message---
#define DFM_VALIDATECMD              9      // idCmd        0
#define DFM_MERGECONTEXTMENU_TOP     10     // uFlags       LPQCMINFO
#define DFM_GETHELPTEXTW             11     // idCmd,cchMax pszText -Unicode
#define DFM_MAPCOMMANDNAME           13     // idCmd *      pszCommandName

// Commands from DFM_INVOKECOMMAND when strings are passed in
#define DFM_CMD_DELETE          ((WPARAM)-1)
#define DFM_CMD_MOVE            ((WPARAM)-2)
#define DFM_CMD_COPY            ((WPARAM)-3)
#define DFM_CMD_LINK            ((WPARAM)-4)
#define DFM_CMD_PROPERTIES      ((WPARAM)-5)
#define DFM_CMD_NEWFOLDER       ((WPARAM)-6)
#define DFM_CMD_PASTE           ((WPARAM)-7)
#define DFM_CMD_VIEWLIST        ((WPARAM)-8)
#define DFM_CMD_VIEWDETAILS     ((WPARAM)-9)
#define DFM_CMD_PASTELINK       ((WPARAM)-10)
#define DFM_CMD_PASTESPECIAL    ((WPARAM)-11)
#define DFM_CMD_MODALPROP       ((WPARAM)-12)

typedef struct _QCMINFO // qcm
{
    HMENU       hmenu;          // in
    UINT        indexMenu;      // in
    UINT        idCmdFirst;     // in/out
    UINT        idCmdLast;      // in
} QCMINFO, * LPQCMINFO;

typedef HRESULT (CALLBACK * LPFNDFMCALLBACK)(LPSHELLFOLDER psf,
                                                HWND hwndOwner,
                                                LPDATAOBJECT pdtobj,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

STDAPI CDefFolderMenu_Create(LPCITEMIDLIST pidlFolder,
                             HWND hwndOwner,
                             UINT cidl, LPCITEMIDLIST * apidl,
                             LPSHELLFOLDER psf,
                             LPFNDFMCALLBACK lpfn,
                             HKEY hkeyProgID, HKEY hkeyBaseProgID,
                             LPCONTEXTMENU * ppcm);

void PASCAL CDefFolderMenu_MergeMenu(HINSTANCE hinst, UINT idMainMerge, UINT idPopupMerge,
        LPQCMINFO pqcm);
void PASCAL Def_InitFileCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        BOOL bContext);
void PASCAL Def_InitEditCommands(ULONG dwAttr, HMENU hmInit, UINT idCmdFirst,
        LPDROPTARGET pdtgt, UINT fContext);
void NEAR PASCAL _SHPrettyMenu(HMENU hm);

//===========================================================================
// Default IShellView for IShellFolder
//===========================================================================

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderView(LPSHELLFOLDER pshf, LPCITEMIDLIST pidl, LONG lEvent, LPSHELLVIEW * ppsv);

// Menu ID's
#ifdef BUG_23171_FIXED
#define SFVIDM_FIRST                    (FCIDM_SHVIEWLAST-0x0fff)
#else
// MENUEX currently cannot handle subtraction in the ID's, so we need
// to subtract for it.
#if (FCIDM_SHVIEWLAST != 0x7fff)
#error FCIDM_SHVIEWLAST has changed, so shellp.h needs to also
#endif
#define SFVIDM_FIRST                    (0x7000)
#endif
#define SFVIDM_LAST                     (FCIDM_SHVIEWLAST)

// Popup menu ID's used in merging menus
#define SFVIDM_MENU_ARRANGE     (SFVIDM_FIRST + 0x0001)
#define SFVIDM_MENU_VIEW        (SFVIDM_FIRST + 0x0002)
#define SFVIDM_MENU_SELECT      (SFVIDM_FIRST + 0x0003)

// TBINFO flags
#define TBIF_APPEND     0
#define TBIF_PREPEND    1
#define TBIF_REPLACE    2

typedef struct _TBINFO
{
    UINT        cbuttons;       // out
    UINT        uFlags;         // out (one of TBIF_ flags)
} TBINFO, * LPTBINFO;

typedef struct _COPYHOOKINFO
{
    HWND hwnd;
    DWORD wFunc;
    DWORD wFlags;
    LPCTSTR pszSrcFile;
    DWORD dwSrcAttribs;
    LPCTSTR pszDestFile;
    DWORD dwDestAttribs;
} COPYHOOKINFO, *LPCOPYHOOKINFO;

typedef struct _DETAILSINFO
{
    LPCITEMIDLIST pidl;     // pidl to get details of
    // Note: do not change the order of these fields until IShellDetails
    //       has gone away!
    int fmt;                // LVCFMT_* value (header only)
    int cxChar;             // Number of "average" characters (header only)
    STRRET str;             // String information
} DETAILSINFO, *PDETAILSINFO;

//                               uMsg    wParam         lParam
#define DVM_MERGEMENU            1    // uFlags             LPQCMINFO
#define DVM_INVOKECOMMAND        2    // idCmd              0
#define DVM_GETHELPTEXT          3    // idCmd,cchMax       pszText - Ansi
#define DVM_GETTOOLTIPTEXT       4    // idCmd,cchMax       pszText
#define DVM_GETBUTTONINFO        5    // 0                  LPTBINFO
#define DVM_GETBUTTONS           6    // idCmdFirst,cbtnMax LPTBBUTTON
#define DVM_INITMENUPOPUP        7    // idCmdFirst,nIndex  hmenu
#define DVM_SELCHANGE            8    // idCmdFirst,nItem   PDVSELCHANGEINFO
#define DVM_DRAWITEM             9    // idCmdFirst         pdis
#define DVM_MEASUREITEM         10    // idCmdFirst         pmis
#define DVM_EXITMENULOOP        11    // -                  -
#define DVM_RELEASE             12    // -                  lSelChangeInfo (ShellFolder private)
#define DVM_GETCCHMAX           13    // pidlItem           pcchMax
#define DVM_FSNOTIFY            14    // LPITEMIDLIST*      lEvent
#define DVM_WINDOWCREATED       15    // hwnd               PDVSELCHANGEINFO
#define DVM_WINDOWDESTROY       16    // hwnd               PDVSELCHANGEINFO
#define DVM_REFRESH             17    // -                  lSelChangeInfo
#define DVM_SETFOCUS            18    // -                  lSelChangeInfo
#define DVM_KILLFOCUS           19    // -                  -
#define DVM_QUERYCOPYHOOK       20    // -                  -
#define DVM_NOTIFYCOPYHOOK      21    // -                  LPCOPYHOOKINFO
#define DVM_NOTIFY              22    // idFrom             LPNOTIFY
#define DVM_GETDETAILSOF        23    // iColumn            PDETAILSINFO
#define DVM_COLUMNCLICK         24    // iColumn            -
#define DVM_QUERYFSNOTIFY       25    // -                  FSNotifyEntry *
#define DVM_DEFITEMCOUNT        26    // -                  PINT
#define DVM_DEFVIEWMODE         27    // -                  PFOLDERVIEWMODE
#define DVM_UNMERGEMENU         28    // uFlags
#define DVM_INSERTITEM          29    // pidl               PDVSELCHANGEINFO
#define DVM_DELETEITEM          30    // pidl               PDVSELCHANGEINFO
#define DVM_UPDATESTATUSBAR     31    // -                  lSelChangeInfo
#define DVM_BACKGROUNDENUM      32
#define DVM_GETWORKINGDIR       33
#define DVM_GETCOLSAVESTREAM    34    // flags              IStream **
#define DVM_SELECTALL           35    //                    lSelChangeInfo
#define DVM_DIDDRAGDROP         36    // dwEffect           IDataObject *
#define DVM_SUPPORTSIDENTITY    37    // -                  -
#define DVM_FOLDERISPARENT      38    // -                  pidlChild

typedef struct _DVSELCHANGEINFO {
    UINT uOldState;
    UINT uNewState;
    LPARAM lParamItem;
    LPARAM* plParam;
} DVSELCHANGEINFO, *PDVSELCHANGEINFO;

typedef HRESULT (CALLBACK * LPFNVIEWCALLBACK)(LPSHELLVIEW psvOuter,
                                                LPSHELLFOLDER psf,
                                                HWND hwndMain,
                                                UINT uMsg,
                                                WPARAM wParam,
                                                LPARAM lParam);

// SHCreateShellFolderViewEx struct
typedef struct _CSFV
{
    UINT            cbSize;
    LPSHELLFOLDER   pshf;
    LPSHELLVIEW     psvOuter;
    LPCITEMIDLIST   pidl;
    LONG            lEvents;
    LPFNVIEWCALLBACK pfnCallback;       // No callback if NULL
    FOLDERVIEWMODE  fvm;
} CSFV, * LPCSFV;

// Tell the FolderView to rearrange.  The lParam will be passed to
// IShellFolder::CompareIDs
#define SFVM_REARRANGE          0x00000001
#define ShellFolderView_ReArrange(_hwnd, _lparam) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_REARRANGE, _lparam)

// Get the last sorting parameter given to FolderView
#define SFVM_GETARRANGEPARAM    0x00000002
#define ShellFolderView_GetArrangeParam(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETARRANGEPARAM, 0L)

// Add an OBJECT into the view (May need to add insert also)
#define SFVM_ADDOBJECT         0x00000003
#define ShellFolderView_AddObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_ADDOBJECT, (LPARAM)_pidl)

// Gets the count of objects in the view
#define SFVM_GETOBJECTCOUNT         0x00000004
#define ShellFolderView_GetObjectCount(_hwnd) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECTCOUNT, (LPARAM)0)

// Returns a pointer to the Idlist associated with the specified index
// Returns NULL if at end of list.
#define SFVM_GETOBJECT         0x00000005
#define ShellFolderView_GetObject(_hwnd, _iObject) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETOBJECT, _iObject)

// Remove an OBJECT into the view (This works by pidl, may need index also);
#define SFVM_REMOVEOBJECT         0x00000006
#define ShellFolderView_RemoveObject(_hwnd, _pidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REMOVEOBJECT, (LPARAM)_pidl)

// updates an object by passing in pointer to two PIDLS, the first
// is the old pidl, the second one is the one with update information.
#define SFVM_UPDATEOBJECT         0x00000007
#define ShellFolderView_UpdateObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_UPDATEOBJECT, (LPARAM)_ppidl)

// Sets the redraw mode for the window that is displaying the information
#define SFVM_SETREDRAW           0x00000008
#define ShellFolderView_SetRedraw(_hwnd, fRedraw) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_SETREDRAW, (LPARAM)fRedraw)

// Returns an array of the selected IDS to the caller.
//     lparam is a pointer to receive the idlists into
//     return value is the count of items in the array.
#define SFVM_GETSELECTEDOBJECTS 0x00000009
#define ShellFolderView_GetSelectedObjects(_hwnd, ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDOBJECTS, (LPARAM)ppidl)

// Checks if the current drop is on the view window
//     lparam is unused
//     return value is TRUE if the current drop is upon the background of the
//         view window, FALSE otherwise
#define SFVM_ISDROPONSOURCE     0x0000000a
#define ShellFolderView_IsDropOnSource(_hwnd, _pdtgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISDROPONSOURCE, (LPARAM)_pdtgt)

// Moves the selected icons in the listview
//     lparam is a pointer to a drop target
//     return value is unused
#define SFVM_MOVEICONS          0x0000000b
#define ShellFolderView_MoveIcons(_hwnd, _pdt) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_MOVEICONS, (LPARAM)(LPDROPTARGET)_pdt)

// Gets the start point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDRAGPOINT       0x0000000c
#define ShellFolderView_GetDragPoint(_hwnd, _ppt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETDRAGPOINT, (LPARAM)(LPPOINT)_ppt)

// Gets the end point of a drag-drop
//     lparam is a pointer to a point
//     return value is unused
#define SFVM_GETDROPPOINT       0x0000000d
#define ShellFolderView_GetDropPoint(_hwnd, _ppt) \
        SHShellFolderView_Message(_hwnd, SFVM_GETDROPPOINT, (LPARAM)(LPPOINT)_ppt)

#define ShellFolderView_GetAnchorPoint(_hwnd, _fStart, _ppt) \
        (BOOL)((_fStart) ? ShellFolderView_GetDragPoint(_hwnd, _ppt) : ShellFolderView_GetDropPoint(_hwnd, _ppt))

typedef struct _SFV_SETITEMPOS
{
        LPCITEMIDLIST pidl;
        POINT pt;
} SFV_SETITEMPOS, *LPSFV_SETITEMPOS;

// Sets the position of an item in the viewer
//     lparam is a pointer to a SVF_SETITEMPOS
//     return value is unused
#define SFVM_SETITEMPOS         0x0000000e
#define ShellFolderView_SetItemPos(_hwnd, _pidl, _x, _y) \
{       SFV_SETITEMPOS _sip = {_pidl, {_x, _y}}; \
        SHShellFolderView_Message(_hwnd, SFVM_SETITEMPOS, (LPARAM)(LPSFV_SETITEMPOS)&_sip);}

// Determines if a given drop target interface is the one being used for
// the background of the ShellFolderView (as opposed to an object in the
// view)
//     lparam is a pointer to a drop target interface
//     return value is TRUE if it is the background drop target, FALSE otherwise
#define SFVM_ISBKDROPTARGET     0x0000000f
#define ShellFolderView_IsBkDropTarget(_hwnd, _pdptgt) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_ISBKDROPTARGET, (LPARAM)(LPDROPTARGET)_pdptgt)

//  Notifies a ShellView when one of its objects get put on the clipboard
//  as a result of a menu command.
//
//  called by defcm.c when it does a copy/cut
//
//     lparam is the dwEffect (DROPEFFECT_MOVE, DROPEFFECT_COPY)
//     return value is void.
#define SFVM_SETCLIPBOARD       0x00000010
#define ShellFolderView_SetClipboard(_hwnd, _dwEffect) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETCLIPBOARD, (LPARAM)(DWORD)(_dwEffect))


// sets auto arrange
#define SFVM_AUTOARRANGE        0x00000011
#define ShellFolderView_AutoArrange(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_AUTOARRANGE, 0)

// sets snap to grid
#define SFVM_ARRANGEGRID        0x00000012
#define ShellFolderView_ArrangeGrid(_hwnd) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_ARRANGEGRID, 0)

#define SFVM_GETAUTOARRANGE     0x00000013
#define ShellFolderView_GetAutoArrange(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETAUTOARRANGE, 0)

#define SFVM_GETSELECTEDCOUNT     0x00000014
#define ShellFolderView_GetSelectedCount(_hwnd) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETSELECTEDCOUNT, 0)

typedef struct {
    int cxSmall;
    int cySmall;
    int cxLarge;
    int cyLarge;
} ITEMSPACING, *LPITEMSPACING;

#define SFVM_GETITEMSPACING     0x00000015
#define ShellFolderView_GetItemSpacing(_hwnd, lpis) \
        (BOOL)SHShellFolderView_Message(_hwnd, SFVM_GETITEMSPACING, (LPARAM)lpis)

// Causes an object to be repainted
#define SFVM_REFRESHOBJECT      0x00000016
#define ShellFolderView_RefreshObject(_hwnd, _ppidl) \
        (LPARAM)SHShellFolderView_Message(_hwnd, SFVM_REFRESHOBJECT, (LPARAM)_ppidl)


#define SFVM_SETPOINTS           0x00000017
#define ShellFolderView_SetPoints(_hwnd, _pdtobj) \
        (void)SHShellFolderView_Message(_hwnd, SFVM_SETPOINTS, (LPARAM)_pdtobj)

// SVM_SELECTANDPOSITIONITEM lParam
typedef struct
{
        LPCITEMIDLIST pidl;     // relative pidl to the view
        UINT  uSelectFlags;     // select flags
        BOOL fMove; // if true, we should also move it to point pt
        POINT pt;
} SFM_SAP;

// shell view messages
#define SVM_SELECTITEM                  (WM_USER + 1)
#define SVM_MOVESELECTEDITEMS           (WM_USER + 2)
#define SVM_GETANCHORPOINT              (WM_USER + 3)
#define SVM_GETITEMPOSITION             (WM_USER + 4)
#define SVM_SELECTANDPOSITIONITEM       (WM_USER + 5)

// Heap tracking stuff.
#ifdef MEMMON
#ifndef INC_MEMMON
#define INC_MEMMON
#define LocalAlloc      SHLocalAlloc
#define LocalFree       SHLocalFree
#define LocalReAlloc    SHLocalReAlloc

WINSHELLAPI HLOCAL WINAPI SHLocalAlloc(UINT uFlags, UINT cb);
WINSHELLAPI HLOCAL WINAPI SHLocalReAlloc(HLOCAL hOld, UINT cbNew, UINT uFlags);
WINSHELLAPI HLOCAL WINAPI SHLocalFree(HLOCAL h);
#endif
#endif

//===========================================================================
// CDefShellFolder members (for easy subclassing)
//===========================================================================

// Single instance members
STDMETHODIMP_(ULONG) CSIShellFolder_AddRef(LPSHELLFOLDER psf) ;
STDMETHODIMP_(ULONG) CSIShellFolder_Release(LPSHELLFOLDER psf);

// Default implementation (no dependencies to the instance data)
STDMETHODIMP CDefShellFolder_QueryInterface(LPSHELLFOLDER psf, REFIID riid, LPVOID * ppvObj);
STDMETHODIMP CDefShellFolder_BindToStorage(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc,
                         REFIID riid, LPVOID * ppvOut);
STDMETHODIMP CDefShellFolder_BindToObject(LPSHELLFOLDER psf, LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, LPVOID * ppvOut);
STDMETHODIMP CDefShellFolder_GetAttributesOf(LPSHELLFOLDER psf, UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfOut);
STDMETHODIMP CDefShellFolder_SetNameOf(LPSHELLFOLDER psf, HWND hwndOwner,
        LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwReserved, LPITEMIDLIST * ppidlOut);

// File Search APIS
WINSHELLAPI LPCONTEXTMENU WINAPI SHFind_InitMenuPopup(HMENU hmenu, HWND hwndOwner, UINT idCmdFirst, UINT idCmdLast);

WINSHELLAPI void WINAPI Control_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
WINSHELLAPI void WINAPI Control_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow);

// to add 16 bit pages to 32bit things.  hGlobal can be NULL
WINSHELLAPI UINT WINAPI SHAddPages16(HGLOBAL hGlobal, LPCTSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

WINSHELLAPI HRESULT WINAPI SHCreateShellFolderViewEx(LPCSFV pcsfv, LPSHELLVIEW * ppsv);

//===========================================================================
// Defview related API and interface
//
//  Notes: At this point, we have no plan to publish this mechanism.
//===========================================================================

typedef struct _SHELLDETAILS
{
        int     fmt;            // LVCFMT_* value (header only)
        int     cxChar;         // Number of "average" characters (header only)
        STRRET  str;            // String information
} SHELLDETAILS, *LPSHELLDETAILS;

#undef  INTERFACE
#define INTERFACE   IShellDetails

DECLARE_INTERFACE_(IShellDetails, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellDetails methods ***
    STDMETHOD(GetDetailsOf)(THIS_ LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails) PURE;
    STDMETHOD(ColumnClick)(THIS_ UINT iColumn) PURE;
};

//
// Private QueryContextMenuFlag passed from DefView
//
#define CMF_DVFILE       0x00010000     // "File" pulldown

//
// Functions to help the cabinets sync to each other
//  uOptions parameter to SHWaitForFileOpen
//
#define WFFO_WAITTIME 10000L

#define WFFO_ADD        0x0001
#define WFFO_REMOVE     0x0002
#define WFFO_WAIT       0x0004
#define WFFO_SIGNAL     0x0008

// Common strings
#define STR_DESKTOPCLASS        "Progman"

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
WINSHELLAPI HRESULT WINAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
WINSHELLAPI HRESULT WINAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)  SHFree(pidl)

WINSHELLAPI HRESULT WINAPI SHDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID * ppv);


#include <fsmenu.h>

//===========================================================================

//----------------------------------------------------------------------------
#define IsLFNDriveORD           119
WINSHELLAPI BOOL WINAPI IsLFNDrive(LPCTSTR pszPath);
WINSHELLAPI int WINAPI SHOutOfMemoryMessageBox(HWND hwndOwner, LPTSTR pszTitle, UINT fuStyle);
WINSHELLAPI BOOL WINAPI SHWinHelp(HWND hwndMain, LPCTSTR lpszHelp, UINT usCommand, DWORD ulData);

WINSHELLAPI BOOL WINAPI RLBuildListOfPaths(void);

#ifdef WINNT
// WINSHELLAPI BOOL WINAPI RegenerateUserEnvironment(PVOID *pPrevEnv, BOOL bSetCurrentEnv);
#endif

#define SHValidateUNCORD        173

#define VALIDATEUNC_NOUI        0x0002          // don't bring up stinking UI!
#define VALIDATEUNC_CONNECT     0x0001          // connect a drive letter
#define VALIDATEUNC_PRINT       0x0004          // validate as print share instead of disk share
#define VALIDATEUNC_VALID       0x0007          // valid flags


WINSHELLAPI BOOL WINAPI SHValidateUNC(HWND hwndOwner, LPTSTR pszFile, UINT fConnect);

//----------------------------------------------------------------------------
#define OleStrToStrNORD                         78
#define SHCloneSpecialIDListORD                 89
#define SHDllGetClassObjectORD                 128
#define SHLogILFromFSILORD                      95
#define SHMapPIDLToSystemImageListIndexORD      77
#define SHShellFolderView_MessageORD            73
#define Shell_GetImageListsORD                  71
#define SHGetSpecialFolderPathORD              175
#define StrToOleStrNORD                         79

#define ILCloneORD                              18
#define ILCloneFirstORD                         19
#define ILCombineORD                            25
#define ILCreateFromPathORD                     157
#define ILFindChildORD                          24
#define ILFreeORD                               155
#define ILGetNextORD                            153
#define ILGetSizeORD                            152
#define ILIsEqualORD                            21
#define ILRemoveLastIDORD                       17
#define PathAddBackslashORD                     32
#define PathCombineORD                          37
#define PathIsExeORD                            43
#define PathMatchSpecORD                        46
#define SHGetSetSettingsORD                     68
#define SHILCreateFromPathORD                   28

#define SHFreeORD                               195
#define MemMon_FreeORD                          123

//
// Storage name of a scrap/bookmark item
//
#define WSTR_SCRAPITEM L"\003ITEM000"

//
//  PifMgr Thunked APIs (in SHELL.DLL)
//
extern int  WINAPI PifMgr_OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt);
extern int  WINAPI PifMgr_GetProperties(int hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
extern int  WINAPI PifMgr_SetProperties(int hProps, LPCSTR lpszGroup, const VOID *lpProps, int cbProps, UINT flOpt);
extern int  WINAPI PifMgr_CloseProperties(int hProps, UINT flOpt);

//
// exported from SHSCRAP.DLL
//
#define SCRAP_CREATEFROMDATAOBJECT "Scrap_CreateFromDataObject"
typedef HRESULT (WINAPI * LPFNSCRAPCREATEFROMDATAOBJECT)(LPCTSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPTSTR pszNewFile);
extern HRESULT WINAPI Scrap_CreateFromDataObject(LPCTSTR pszPath, LPDATAOBJECT pDataObj, BOOL fLink, LPTSTR pszNewFile);

WINSHELLAPI void WINAPI SHSetInstanceExplorer(IUnknown *punk);

#ifndef WINNT
// Always usr TerminateThreadEx.
BOOL APIENTRY TerminateThreadEx(HANDLE hThread, DWORD dwExitCode, BOOL bCleanupFlag);
#define TerminateThread(hThread, dwExitCode) TerminateThreadEx(hThread, dwExitCode, TRUE)
#endif

//===========================================================================

//----------------------------------------------------------------------------
// CABINETSTATE holds the global configuration for the Explorer and its cohorts.
//
// Originally the cLength was an 'int', it is now two words, allowing us to
// specify a version number.
//----------------------------------------------------------------------------

typedef struct {
    WORD cLength;
    WORD nVersion;

    BOOL fFullPathTitle : 1;
    BOOL fSaveLocalView : 1;
    BOOL fNotShell : 1;
    BOOL fSimpleDefault : 1;
    BOOL fDontShowDescBar : 1;
    BOOL fNewWindowMode : 1;
    BOOL fUnused                   : 1;
    BOOL fDontPrettyNames          : 1;  // NT: Do 8.3 name conversion, or not!
    BOOL fAdminsCreateCommonGroups : 1;  // NT: Administrators create comon groups
    UINT fUnusedFlags : 7;

    UINT fMenuEnumFilter;

} CABINETSTATE, * LPCABINETSTATE;

#define CABINETSTATE_VERSION 1

// APIs for reading and writing the cabinet state.
WINSHELLAPI BOOL WINAPI ReadCabinetState( LPCABINETSTATE lpState, int iSize );
WINSHELLAPI BOOL WINAPI WriteCabinetState( LPCABINETSTATE lpState );

//===========================================================================
// Security functions.
//

WINSHELLAPI BOOL IsUserAnAdmin(void);

//===========================================================================
#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#ifndef UNICODE

//-------------------------------------------------------------------     /* ;Internal */
// common path whacking routines.                                         /* ;Internal */                                                                      /* ;Internal */
LPSTR WINAPI PathAddBackslash(LPSTR lpszPath);                            /* ;Internal */
LPSTR WINAPI PathRemoveBackslash(LPSTR lpszPath);                         /* ;Internal */
void  WINAPI PathRemoveBlanks(LPSTR lpszString);                          /* ;Internal */
BOOL  WINAPI PathRemoveFileSpec(LPSTR lpszPath);                          /* ;Internal */
LPSTR WINAPI PathFindFileName(LPCSTR pPath);	   /* ;Internal */
                                                                          /* ;Internal */
BOOL  WINAPI PathIsRoot(LPCSTR lpszPath);                                 /* ;Internal */
BOOL  WINAPI PathIsRelative(LPCSTR lpszPath);                             /* ;Internal */
BOOL  WINAPI PathIsUNC(LPCSTR lpsz);                                      /* ;Internal */
BOOL  WINAPI PathIsDirectory(LPCSTR lpszPath);                            /* ;Internal */
// BOOL  WINAPI PathIsExe(LPCSTR lpszPath);                                  /* ;Internal */
int   WINAPI PathGetDriveNumber(LPCSTR lpszPath);                         /* ;Internal */
                                                                          /* ;Internal */
LPSTR WINAPI PathCombine(LPSTR szDest, LPCSTR lpszDir, LPCSTR lpszFile);  /* ;Internal */
                                                                          /* ;Internal */
void  WINAPI PathAppend(LPSTR pPath, LPCSTR pMore);                       /* ;Internal */
LPSTR WINAPI PathBuildRoot(LPSTR szRoot, int iDrive);                     /* ;Internal */
int   WINAPI PathCommonPrefix(LPCSTR pszFile1, LPCSTR pszFile2,           /* ;Internal */
        LPSTR achPath);                                                   /* ;Internal */
//LPSTR WINAPI PathGetExtension(LPCSTR lpszPath);                           /* ;Internal */
// put ellipses in a path so it fits in the dx space                      /* ;Internal */
BOOL  WINAPI PathCompactPath(HDC hDC, LPSTR lpszPath, UINT dx);           /* ;Internal */
BOOL  WINAPI PathFileExists(LPCSTR lpszPath);                             /* ;Internal */
BOOL  WINAPI PathMatchSpec(LPCSTR pszFile, LPCSTR pszSpec);               /* ;Internal */
BOOL  WINAPI PathMakeUniqueName(LPSTR pszUniqueName, UINT cchMax,         /* ;Internal */
        LPCSTR pszTemplate, LPCSTR pszLongPlate, LPCSTR pszDir);          /* ;Internal */
LPSTR WINAPI PathGetArgs(LPCSTR pszPath);                                 /* ;Internal */
BOOL  WINAPI PathGetShortName(LPCSTR lpszLongName, LPSTR lpszShortName,   /* ;Internal */
        UINT cbShortName);                                                /* ;Internal */
BOOL  WINAPI PathGetLongName(LPCSTR lpszShortName, LPSTR lpszLongName,    /* ;Internal */
        UINT cbLongName);                                                 /* ;Internal */
void  WINAPI PathQuoteSpaces(LPSTR lpsz);                                 /* ;Internal */
void  WINAPI PathUnquoteSpaces(LPSTR lpsz);                               /* ;Internal */
BOOL  WINAPI PathDirectoryExists(LPCSTR lpszDir);                         /* ;Internal */
                                                                          /* ;Internal */
// fully qualify a path                                                   /* ;Internal */
void  WINAPI PathQualify(LPSTR lpsz);                                     /* ;Internal */
// PathResolve flags							  /* ;Internal */
#define PRF_VERIFYEXISTS	    0x0001				  /* ;Internal */
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)		  /* ;Internal */
int WINAPI PathResolve(LPSTR lpszPath, LPCSTR FAR dirs[], UINT fFlags);	  /* ;Internal */
                                                                          /* ;Internal */
// LPSTR WINAPI PathGetNextComponent(LPCSTR lpszPath, LPSTR lpszComponent);  /* ;Internal */
LPSTR WINAPI PathFindNextComponent(LPCSTR lpszPath);                      /* ;Internal */
                                                                          /* ;Internal */
BOOL WINAPI PathIsSameRoot(LPCSTR pszPath1, LPCSTR pszPath2);               /* ;Internal */
                                                                          /* ;Internal */
// set a static text field with a path by whacking out parts and replacing/* ;Internal */
// with ellipses                                                          /* ;Internal */

#endif // _UNICODE

#endif // _SHELLP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shguidp.h ===
//
// CLSIDs of shell object classes. They don't have to be in a public header
// unless we decided to let ISVs to create shell objects directly by calling
// OleCreateInstance with one of class IDs.
//
// NOTE: those that are commented out are ready to be used again...
//

DEFINE_GUID(CLSID_ShellNetwork,        	0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D);//208D2C60-3AEA-1069-A2D7-08002B30309D
DEFINE_GUID(CLSID_ShellDrives,         	0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D);//20D04FE0-3AEA-1069-A2D8-08002B30309D

// do this so that we don't break anyone's build by pulling it out
#ifndef NO_CLSID_ShellFolder
DEFINE_GUID(CLSID_ShellFolder,         	0x210A4BA0, 0x3AEA, 0x1069, 0xA2,0xD9,0x08,0x00,0x2B,0x30,0x30,0x9D);//210A4BA0-3AEA-1069-A2D9-08002B30309D
#endif

// DEFINE_GUID(CLSID_,                 	0x21444760, 0x3AEA, 0x1069, 0xA2,0xDA,0x08,0x00,0x2B,0x30,0x30,0x9D);//21444760-3AEA-1069-A2DA-08002B30309D
DEFINE_GUID(CLSID_ShellCopyHook,       	0x217FC9C0, 0x3AEA, 0x1069, 0xA2,0xDB,0x08,0x00,0x2B,0x30,0x30,0x9D);//217FC9C0-3AEA-1069-A2DB-08002B30309D
DEFINE_GUID(CLSID_ShellFileDefExt,     	0x21B22460, 0x3AEA, 0x1069, 0xA2,0xDC,0x08,0x00,0x2B,0x30,0x30,0x9D);//21B22460-3AEA-1069-A2DC-08002B30309D
DEFINE_GUID(CLSID_ShellDrvDefExt,      	0x5F5295E0, 0x429F, 0x1069, 0xA2,0xE2,0x08,0x00,0x2B,0x30,0x30,0x9D);//5F5295E0-429F-1069-A2E2-08002B30309D
DEFINE_GUID(CLSID_ShellNetDefExt,       0x86422020, 0x42A0, 0x1069, 0xA2,0xE5,0x08,0x00,0x2B,0x30,0x30,0x9D);//86422020-42A0-1069-A2E5-08002B30309D
DEFINE_GUID(CLSID_CCommonShellExtInit, 	0xA2AD3100, 0x3B84, 0x1069, 0xA2,0xDF,0x08,0x00,0x2B,0x30,0x30,0x9D);//A2AD3100-3B84-1069-A2DF-08002B30309D
DEFINE_GUID(CLSID_Briefcase,           	0x85BBD920, 0x42A0, 0x1069, 0xA2,0xE4,0x08,0x00,0x2B,0x30,0x30,0x9D);//85BBD920-42A0-1069-A2E4-08002B30309D
//DEFINE_GUID(CLSID_ShellMoniker,        	0x86747AC0, 0x42A0, 0x1069, 0xA2,0xE6,0x08,0x00,0x2B,0x30,0x30,0x9D);//86747AC0-42A0-1069-A2E6-08002B30309D
DEFINE_GUID(CLSID_Clouds,               0x869DADA0, 0x42A0, 0x1069, 0xA2,0xE7,0x08,0x00,0x2B,0x30,0x30,0x9D);//869DADA0-42A0-1069-A2E7-08002B30309D   // secret credits object
//DEFINE_GUID(CLSID_ShellIDMoniker,      	0x86C86720, 0x42A0, 0x1069, 0xA2,0xE8,0x08,0x00,0x2B,0x30,0x30,0x9D);//86C86720-42A0-1069-A2E8-08002B30309D   // shellidmoniker
DEFINE_GUID(CLSID_PifProperties,        0x86F19A00, 0x42A0, 0x1069, 0xA2,0xE9,0x08,0x00,0x2B,0x30,0x30,0x9D);//86F19A00-42A0-1069-A2E9-08002B30309D   // pifprops
DEFINE_GUID(CLSID_ShellFSFolder, 	0xF3364BA0, 0x65B9, 0x11CE, 0xA9,0xBA,0x00,0xAA,0x00,0x4A,0xE8,0x37);// F3364BA0-65B9-11CE-A9BA-00AA004AE837
// DEFINE_GUID(CLSID_, 	               	0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellViewerExt,      	0x84F26EA0, 0x42A0, 0x1069, 0xA2,0xE3,0x08,0x00,0x2B,0x30,0x30,0x9D);//871C5380-42A0-1069-A2EA-08002B30309D   // shelllink
DEFINE_GUID(CLSID_ShellBitBucket,	0x645FF040, 0x5081, 0x101B, 0x9F,0x08,0x00,0xAA,0x00,0x2F,0x95,0x4E);//645FF040-5081-101B-9F08-00AA002F954E
DEFINE_GUID(CLSID_CControls,		0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_CPrinters,		0x2227A280, 0x3AEA, 0x1069, 0xA2,0xDE,0x08,0x00,0x2B,0x30,0x30,0x9D);
DEFINE_GUID(CLSID_Remote,               0x992CFFA0, 0xF557, 0x101A, 0x88,0xEC,0x00,0xDD,0x01,0x0C,0xCC,0x48);
DEFINE_GUID(CLSID_ShellFindExt,         0x61E218E0, 0x65D3, 0x101B, 0x9F,0x08,0x06,0x1C,0xEA,0xC3,0xD5,0x0D);//61E218E0-65D3-101B-9F08-061CEAC3D50D
DEFINE_GUID(CLSID_CFonts,		0xBD84B380, 0x8CA2, 0x1069, 0xAB,0x1D,0x08,0x00,0x09,0x48,0xF5,0x34);//bd84b380-8ca2-1069-ab1d-08000948f534
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shlguidp.h ===
DEFINE_SHLGUID(IID_IShellToolbar,       0x000214E0L, 0, 0);
DEFINE_SHLGUID(IID_IShellDetails,       0x000214ECL, 0, 0);
DEFINE_SHLGUID(IID_IDelayedRelease,     0x000214EDL, 0, 0);
DEFINE_SHLGUID(IID_IRemoteComputerA,    0x000214FDL, 0, 0);
DEFINE_SHLGUID(IID_IRemoteComputerW,    0x000214FEL, 0, 0);
DEFINE_SHLGUID(IID_IShellToolbarSite,   0x000214FFL, 0, 0);

DEFINE_GUID(IID_IBriefcaseStg, 0x8BCE1FA1L, 0x0921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);
DEFINE_GUID(IID_IBriefcaseStg2, 0x8BCE1FA1L, 0x1921, 0x101B, 0xB1, 0xFF, 0x00, 0xDD, 0x01, 0x0C, 0xCC, 0x48);

// 0057D0E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_LargeIcons, 0x0057D0E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 089000C0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_SmallIcons, 0x089000C0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 0E1FA5E0-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_List      , 0x0E1FA5E0L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 137E7700-3573-11CF-AE69-08002B2E1262
DEFINE_GUID(VID_Details   , 0x137E7700L, 0x3573, 0x11CF, 0xAE, 0x69, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
// 5984FFE0-28D4-11CF-AE66-08002B2E1262
DEFINE_GUID(VID_HyperText , 0x5984FFE0L, 0x28D4, 0x11CF, 0xAE, 0x66, 0x08, 0x00, 0x2B, 0x2E, 0x12, 0x62);
#ifdef UNICODE
#define IID_IRemoteComputer     IID_IRemoteComputerW
#else
#define IID_IRemoteComputer     IID_IRemoteComputerA
#endif
#ifndef NO_INTSHCUT_GUIDS
#endif
// 266F5E60-80E6-11CF-A12B-00AA004AE837
DEFINE_GUID(CLSID_CShellTargetFrame, 0x266F5E60L, 0x80E6, 0x11CF, 0xA1, 0x2B, 0x00, 0xAA, 0x00, 0x4A, 0xE8, 0x37);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shlwapip.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHLWAPIP
#define _INC_SHLWAPIP
#ifndef NOSHLWAPI

#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif

#endif  // _INC_SHLWAPIP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shlwapi.h ===
/*****************************************************************************\
*                                                                             *
* shlwapi.h - Interface for the Windows light-weight utility APIs             *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/


#ifndef _INC_SHLWAPI
#define _INC_SHLWAPI

#ifndef NOSHLWAPI


#include <objbase.h>

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHLWAPI
#if !defined(_SHLWAPI_)
#define LWSTDAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define LWSTDAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define LWSTDAPI          STDAPI
#define LWSTDAPI_(type)   STDAPI_(type)
#endif
#endif // WINSHLWAPI

#ifdef _WIN32
#include <pshpack1.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif


//
// Users of this header may define any number of these constants to avoid
// the definitions of each functional group.
//
//    NO_SHLWAPI_STRFCNS    String functions


#ifndef NO_SHLWAPI_STRFCNS
//
//=============== String Routines ===================================
//

LWSTDAPI_(LPSTR)    StrChrA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrW(LPCWSTR lpStart, WORD wMatch);
LWSTDAPI_(LPSTR)    StrRChrA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrW(LPCWSTR lpStart, LPCWSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPSTR)    StrChrIA(LPCSTR lpStart, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrChrIW(LPCWSTR lpStart, WORD wMatch);
LWSTDAPI_(LPSTR)    StrRChrIA(LPCSTR lpStart, LPCSTR lpEnd, WORD wMatch);
LWSTDAPI_(LPWSTR)   StrRChrIW(LPCWSTR lpStart, LPCWSTR lpEnd, WORD wMatch);
LWSTDAPI_(int)      StrCmpNA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIA(LPCSTR lpStr1, LPCSTR lpStr2, int nChar);
LWSTDAPI_(int)      StrCmpNIW(LPCWSTR lpStr1, LPCWSTR lpStr2, int nChar);
LWSTDAPI_(LPSTR)    StrStrA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrCmpW(LPCWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPWSTR)   StrCpyW(LPWSTR psz1, LPCWSTR psz2);
LWSTDAPI_(LPSTR)    StrRStr(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch);
LWSTDAPI_(LPSTR)    StrStrIA(LPCSTR lpFirst, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrStrIW(LPCWSTR lpFirst, LPCWSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrDupW(LPCWSTR lpSrch);
LWSTDAPI_(LPSTR)    StrDupA(LPCSTR lpSrch);
LWSTDAPI_(LPSTR)    StrRStrIA(LPCSTR lpSource, LPCSTR lpLast, LPCSTR lpSrch);
LWSTDAPI_(LPWSTR)   StrRStrIW(LPCWSTR lpSource, LPCWSTR lpLast, LPCWSTR lpSrch);
LWSTDAPI_(int)      StrCSpnA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrCSpnIA(LPCSTR lpStr, LPCSTR lpSet);
LWSTDAPI_(int)      StrCSpnIW(LPCWSTR lpStr, LPCWSTR lpSet);
LWSTDAPI_(int)      StrSpnW(LPCWSTR psz, LPCWSTR pszSet);
LWSTDAPI_(int)      StrSpnA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(int)      StrToIntA(LPCSTR lpSrc);
LWSTDAPI_(int)      StrToIntW(LPCWSTR lpSrc);
LWSTDAPI_(LPSTR)    StrPBrkA(LPCSTR psz, LPCSTR pszSet);
LWSTDAPI_(LPWSTR)   StrPBrkW(LPCWSTR psz, LPCWSTR pszSet);

LWSTDAPI_(BOOL)     StrToIntExA(LPCSTR pszString, DWORD dwFlags, int FAR * piRet);
LWSTDAPI_(BOOL)     StrToIntExW(LPCWSTR pszString, DWORD dwFlags, int FAR * piRet);
LWSTDAPI_(int)      StrFromTimeIntervalW(LPWSTR pwszOut, UINT cchMax, DWORD dwTimeMS, int digits);
LWSTDAPI_(int)      StrFromTimeIntervalA(LPSTR pszOut, UINT cchMax, DWORD dwTimeMS, int digits);

LWSTDAPI_(BOOL)     IntlStrEqWorkerA(BOOL fCaseSens, LPCSTR lpString1, LPCSTR lpString2, int nChar);
LWSTDAPI_(BOOL)     IntlStrEqWorkerW(BOOL fCaseSens, LPCWSTR lpString1, LPCWSTR lpString2, int nChar);

#define IntlStrEqNA( s1, s2, nChar) IntlStrEqWorkerA( TRUE, s1, s2, nChar)
#define IntlStrEqNIA(s1, s2, nChar) IntlStrEqWorkerA(FALSE, s1, s2, nChar)

#define IntlStrEqNW( s1, s2, nChar) IntlStrEqWorkerW( TRUE, s1, s2, nChar)
#define IntlStrEqNIW(s1, s2, nChar) IntlStrEqWorkerW(FALSE, s1, s2, nChar)

// Flags for StrToIntEx
#define STIF_DEFAULT        0x00000000L
#define STIF_SUPPORT_HEX    0x00000001L


#ifdef UNICODE
#define StrSpn                  StrSpnW
#define StrPBrk                 StrPBrkW
#define StrToIntEx              StrToIntExW
#define StrToInt                StrToIntW
#define StrChr                  StrChrW
#define StrRChr                 StrRChrW
#define StrChrI                 StrChrIW
#define StrRChrI                StrRChrIW
#define StrCSpn                 StrCSpnW
#define StrCSpnI                StrCSpnIW
#define StrCmpN                 StrCmpNW
#define StrCmpNI                StrCmpNIW
#define StrStr                  StrStrW
#define StrStrI                 StrStrIW
#define StrRStrI                StrRStrIW
#define StrDup                  StrDupW
#define StrCmp                  StrCmpW
#define StrFromTimeInterval     StrFromTimeIntervalW
#define IntlStrEqN              IntlStrEqNW
#define IntlStrEqNI             IntlStrEqNIW
#else
#define StrSpn                  StrSpnA
#define StrPBrk                 StrPBrkA
#define StrToIntEx              StrToIntExA
#define StrToInt                StrToIntA
#define StrChr                  StrChrA
#define StrRChr                 StrRChrA
#define StrChrI                 StrChrIA
#define StrRChrI                StrRChrIA
#define StrCSpn                 StrCSpnA
#define StrCSpnI                StrCSpnIA
#define StrCmpN                 StrCmpNA
#define StrCmpNI                StrCmpNIA
#define StrStr                  StrStrA
#define StrStrI                 StrStrIA
#define StrRStrI                StrRStrIA
#define StrDup                  StrDupA
#define StrFromTimeInterval     StrFromTimeIntervalA
#define IntlStrEqN              IntlStrEqNA
#define IntlStrEqNI             IntlStrEqNIA
#endif

#define StrToLong               StrToInt
#define StrNCmp                 StrCmpN
#define StrNCmpI                StrCmpNI
#define StrNCpy                 lstrcpyn
#define StrCpyN                 lstrcpyn

#endif //  NO_SHLWAPI_STRFCNS


//
//====== DllGetVersion  =======================================================
//

typedef struct _DllVersionInfo
{
        DWORD cbSize;
        DWORD dwMajorVersion;                   // Major version
        DWORD dwMinorVersion;                   // Minor version
        DWORD dwBuildNumber;                    // Build number
        DWORD dwPlatformID;                     // DLLVER_PLATFORM_*
} DLLVERSIONINFO;

// Platform IDs for DLLVERSIONINFO
#define DLLVER_PLATFORM_WINDOWS         0x00000001      // Windows 95
#define DLLVER_PLATFORM_NT              0x00000002      // Windows NT

//
// The caller should always GetProcAddress("DllGetVersion"), not
// implicitly link to it.
//

typedef HRESULT (CALLBACK* DLLGETVERSIONPROC)(DLLVERSIONINFO *);



#ifdef __cplusplus
}
#endif

#ifdef _WIN32
#include <poppack.h>
#endif

#endif


#endif  // _INC_SHLWAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\synceng.h ===
/*
 * synceng.h - File synchronization engine API description.
 */


#ifndef __SYNCENG_H__
#define __SYNCENG_H__


#ifdef __cplusplus
extern "C" {                     /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* Define API decoration for direct import of DLL functions. */

#ifdef _SYNCENG_
#define SYNCENGAPI
#else
#define SYNCENGAPI         DECLSPEC_IMPORT
#endif


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif


/* Types
 ********/

/* return codes */

typedef enum _twinresult
{
   TR_SUCCESS,
   TR_RH_LOAD_FAILED,
   TR_SRC_OPEN_FAILED,
   TR_SRC_READ_FAILED,
   TR_DEST_OPEN_FAILED,
   TR_DEST_WRITE_FAILED,
   TR_ABORT,
   TR_UNAVAILABLE_VOLUME,
   TR_OUT_OF_MEMORY,
   TR_FILE_CHANGED,
   TR_DUPLICATE_TWIN,
   TR_DELETED_TWIN,
   TR_HAS_FOLDER_TWIN_SRC,
   TR_INVALID_PARAMETER,
   TR_REENTERED,
   TR_SAME_FOLDER,
   TR_SUBTREE_CYCLE_FOUND,
   TR_NO_MERGE_HANDLER,
   TR_MERGE_INCOMPLETE,
   TR_TOO_DIFFERENT,
   TR_BRIEFCASE_LOCKED,
   TR_BRIEFCASE_OPEN_FAILED,
   TR_BRIEFCASE_READ_FAILED,
   TR_BRIEFCASE_WRITE_FAILED,
   TR_CORRUPT_BRIEFCASE,
   TR_NEWER_BRIEFCASE,
   TR_NO_MORE
}
TWINRESULT;
DECLARE_STANDARD_TYPES(TWINRESULT);

/* handles */

DECLARE_HANDLE(HBRFCASE);
DECLARE_STANDARD_TYPES(HBRFCASE);

DECLARE_HANDLE(HBRFCASEITER);
DECLARE_STANDARD_TYPES(HBRFCASEITER);

DECLARE_HANDLE(HTWIN);
DECLARE_STANDARD_TYPES(HTWIN);

DECLARE_HANDLE(HOBJECTTWIN);
DECLARE_STANDARD_TYPES(HOBJECTTWIN);

DECLARE_HANDLE(HFOLDERTWIN);
DECLARE_STANDARD_TYPES(HFOLDERTWIN);

DECLARE_HANDLE(HTWINFAMILY);
DECLARE_STANDARD_TYPES(HTWINFAMILY);

DECLARE_HANDLE(HTWINLIST);
DECLARE_STANDARD_TYPES(HTWINLIST);

DECLARE_HANDLE(HVOLUMEID);
DECLARE_STANDARD_TYPES(HVOLUMEID);

/* OpenBriefcase() flags */

typedef enum _openbriefcaseflags
{
   OB_FL_OPEN_DATABASE           = 0x0001,
   OB_FL_TRANSLATE_DB_FOLDER     = 0x0002,
   OB_FL_ALLOW_UI                = 0x0004,
   OB_FL_LIST_DATABASE           = 0x0008,
   ALL_OB_FLAGS                  = (OB_FL_OPEN_DATABASE |
                                    OB_FL_TRANSLATE_DB_FOLDER |
                                    OB_FL_ALLOW_UI |
                                    OB_FL_LIST_DATABASE)
}
OPENBRIEFCASEFLAGS;

/* open briefcase information returned by GetOpenBriefcaseInfo() */

typedef struct _openbrfcaseinfo
{
   ULONG ulSize;
   DWORD dwFlags;
   HWND hwndOwner;
   HVOLUMEID hvid;
   TCHAR rgchDatabasePath[MAX_PATH];
}
OPENBRFCASEINFO;
DECLARE_STANDARD_TYPES(OPENBRFCASEINFO);

/*
 * briefcase information returned by FindFirstBriefcase() and
 * FindNextBriefcase()
 */

typedef struct _brfcaseinfo
{
   ULONG ulSize;
   TCHAR rgchDatabasePath[MAX_PATH];
}
BRFCASEINFO;
DECLARE_STANDARD_TYPES(BRFCASEINFO);

/* new object twin */

typedef struct _newobjecttwin
{
   ULONG ulSize;
   LPCTSTR pcszFolder1;
   LPCTSTR pcszFolder2;
   LPCTSTR pcszName;
}
NEWOBJECTTWIN;
DECLARE_STANDARD_TYPES(NEWOBJECTTWIN);

/* NEWFOLDERTWIN flags */

typedef enum _newfoldertwinflags
{
   NFT_FL_SUBTREE                = 0x0001,
   ALL_NFT_FLAGS                 = NFT_FL_SUBTREE
}
NEWFOLDERTWINFLAGS;

/* new folder twin */

typedef struct _newfoldertwin
{
   ULONG ulSize;
   LPCTSTR pcszFolder1;
   LPCTSTR pcszFolder2;
   LPCTSTR pcszName;
   DWORD dwAttributes;
   DWORD dwFlags;
}
NEWFOLDERTWIN;
DECLARE_STANDARD_TYPES(NEWFOLDERTWIN);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison results */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER              = -1,
   CR_EQUAL                      = 0,
   CR_FIRST_LARGER               = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

/* file stamp conditions */

typedef enum _filestampcondition
{
   FS_COND_UNAVAILABLE,
   FS_COND_DOES_NOT_EXIST,
   FS_COND_EXISTS
}
FILESTAMPCONDITION;
DECLARE_STANDARD_TYPES(FILESTAMPCONDITION);

/* file stamp */

typedef struct _filestamp
{
   FILESTAMPCONDITION fscond;
   FILETIME ftMod;
   DWORD dwcbLowLength;
   DWORD dwcbHighLength;
   FILETIME ftModLocal;
}
FILESTAMP;
DECLARE_STANDARD_TYPES(FILESTAMP);

/* volume description flags */

typedef enum _volumedescflags
{
   /* dwSerialNumber is valid. */

   VD_FL_SERIAL_NUMBER_VALID  = 0x0001,

   /* rgchVolumeLabel is valid. */

   VD_FL_VOLUME_LABEL_VALID   = 0x0002,

   /* rgchNetResource is valid. */

   VD_FL_NET_RESOURCE_VALID   = 0x0004,

   /* flag combinations */

   ALL_VD_FLAGS               = (VD_FL_SERIAL_NUMBER_VALID |
                                 VD_FL_VOLUME_LABEL_VALID |
                                 VD_FL_NET_RESOURCE_VALID)
}
VOLUMEDESCFLAGS;

/* volume description */

typedef struct _volumedesc
{
   ULONG ulSize;
   DWORD dwFlags;
   DWORD dwSerialNumber;
   TCHAR rgchVolumeLabel[MAX_PATH];
   TCHAR rgchNetResource[MAX_PATH];
}
VOLUMEDESC;
DECLARE_STANDARD_TYPES(VOLUMEDESC);

/* RECNODE states */

typedef enum _recnodestate
{
   RNS_NEVER_RECONCILED,
   RNS_UNAVAILABLE,
   RNS_DOES_NOT_EXIST,
   RNS_DELETED,
   RNS_NOT_RECONCILED,
   RNS_UP_TO_DATE,
   RNS_CHANGED
}
RECNODESTATE;
DECLARE_STANDARD_TYPES(RECNODESTATE);

/* RECNODE actions */

typedef enum _recnodeaction
{
   RNA_NOTHING,
   RNA_COPY_FROM_ME,
   RNA_COPY_TO_ME,
   RNA_MERGE_ME,
   RNA_DELETE_ME
}
RECNODEACTION;
DECLARE_STANDARD_TYPES(RECNODEACTION);

/* RECNODE flags */

typedef enum _recnodeflags
{
   RN_FL_FROM_OBJECT_TWIN        = 0x0001,
   RN_FL_FROM_FOLDER_TWIN        = 0x0002,
   RN_FL_DELETION_SUGGESTED      = 0x0004,
   ALL_RECNODE_FLAGS             = (RN_FL_FROM_OBJECT_TWIN |
                                    RN_FL_FROM_FOLDER_TWIN |
                                    RN_FL_DELETION_SUGGESTED)
}
RECNODEFLAGS;

/* reconciliation node */

typedef struct _recnode
{
   struct _recnode *prnNext;
   HVOLUMEID hvid;
   LPCTSTR pcszFolder;
   HOBJECTTWIN hObjectTwin;
   struct _recitem *priParent;
   FILESTAMP fsLast;
   FILESTAMP fsCurrent;
   RECNODESTATE rnstate;
   RECNODEACTION rnaction;
   DWORD dwFlags;
   DWORD dwUser;
}
RECNODE;
DECLARE_STANDARD_TYPES(RECNODE);

/* RECITEM actions */

typedef enum _recitemaction
{
   RIA_NOTHING,
   RIA_DELETE,
   RIA_COPY,
   RIA_MERGE,
   RIA_BROKEN_MERGE
}
RECITEMACTION;
DECLARE_STANDARD_TYPES(RECITEMACTION);

/* reconciliation item */

typedef struct _recitem
{
   struct _recitem *priNext;
   LPCTSTR pcszName;
   HTWINFAMILY hTwinFamily;
   ULONG ulcNodes;
   PRECNODE prnFirst;
   RECITEMACTION riaction;
   DWORD dwUser;
}
RECITEM;
DECLARE_STANDARD_TYPES(RECITEM);

/* reconciliation list */

typedef struct _reclist
{
   ULONG ulcItems;
   PRECITEM priFirst;
   HBRFCASE hbr;
}
RECLIST;
DECLARE_STANDARD_TYPES(RECLIST);

/* ReconcileItem() flags */

typedef enum _reconcileitemflags
{
   RI_FL_ALLOW_UI                = 0x0001,
   RI_FL_FEEDBACK_WINDOW_VALID   = 0x0002,
   ALL_RI_FLAGS                  = (RI_FL_ALLOW_UI |
                                    RI_FL_FEEDBACK_WINDOW_VALID)
}
RECONCILEITEMFLAGS;

/* reconciliation status update information */

typedef struct _recstatusupdate
{
   ULONG ulProgress;
   ULONG ulScale;
}
RECSTATUSUPDATE;
DECLARE_STANDARD_TYPES(RECSTATUSUPDATE);

/* CREATERECLISTPROC messages */

typedef enum _createreclistprocmsg
{
   CRLS_BEGIN_CREATE_REC_LIST,
   CRLS_DELTA_CREATE_REC_LIST,
   CRLS_END_CREATE_REC_LIST
}
CREATERECLISTPROCMSG;
DECLARE_STANDARD_TYPES(CREATERECLISTPROCMSG);

/* CreateRecList() status callback function */

typedef BOOL (CALLBACK *CREATERECLISTPROC)(CREATERECLISTPROCMSG, LPARAM, LPARAM);

/* RECSTATUSPROC messages */

typedef enum _recstatusprocmsg
{
   RS_BEGIN_COPY,
   RS_DELTA_COPY,
   RS_END_COPY,
   RS_BEGIN_MERGE,
   RS_DELTA_MERGE,
   RS_END_MERGE,
   RS_BEGIN_DELETE,
   RS_DELTA_DELETE,
   RS_END_DELETE
}
RECSTATUSPROCMSG;
DECLARE_STANDARD_TYPES(RECSTATUSPROCMSG);

/* ReconcileItem() status callback function */

typedef BOOL (CALLBACK *RECSTATUSPROC)(RECSTATUSPROCMSG, LPARAM, LPARAM);

/* FOLDERTWIN flags */

typedef enum _foldertwinflags
{
   FT_FL_SUBTREE                 = 0x0001,
   ALL_FT_FLAGS                  = FT_FL_SUBTREE
}
FOLDERTWINFLAGS;

/* folder twin */

typedef struct _foldertwin
{
   const struct _foldertwin *pcftNext;
   HFOLDERTWIN hftSrc;
   HVOLUMEID hvidSrc;
   LPCTSTR pcszSrcFolder;
   HFOLDERTWIN hftOther;
   HVOLUMEID hvidOther;
   LPCTSTR pcszOtherFolder;
   LPCTSTR pcszName;
   DWORD dwFlags;
   DWORD dwUser;
}
FOLDERTWIN;
DECLARE_STANDARD_TYPES(FOLDERTWIN);

/* folder twin list */

typedef struct _foldertwinlist
{
   ULONG ulcItems;
   PCFOLDERTWIN pcftFirst;
   HBRFCASE hbr;
}
FOLDERTWINLIST;
DECLARE_STANDARD_TYPES(FOLDERTWINLIST);

/* FOLDERTWIN status codes */

typedef enum _foldertwinstatus
{
   FTS_DO_NOTHING,
   FTS_DO_SOMETHING,
   FTS_UNAVAILABLE
}
FOLDERTWINSTATUS;
DECLARE_STANDARD_TYPES(FOLDERTWINSTATUS);


/* Prototypes
 *************/

/* briefcase interface */

SYNCENGAPI TWINRESULT WINAPI OpenBriefcase(LPCTSTR, DWORD, HWND, PHBRFCASE);
SYNCENGAPI TWINRESULT WINAPI SaveBriefcase(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI CloseBriefcase(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI DeleteBriefcase(LPCTSTR);
SYNCENGAPI TWINRESULT WINAPI GetOpenBriefcaseInfo(HBRFCASE, POPENBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI ClearBriefcaseCache(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI FindFirstBriefcase(PHBRFCASEITER, PBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI FindNextBriefcase(HBRFCASEITER, PBRFCASEINFO);
SYNCENGAPI TWINRESULT WINAPI FindBriefcaseClose(HBRFCASEITER);

/* twin interface */

SYNCENGAPI TWINRESULT WINAPI AddObjectTwin(HBRFCASE, PCNEWOBJECTTWIN, PHTWINFAMILY);
SYNCENGAPI TWINRESULT WINAPI AddFolderTwin(HBRFCASE, PCNEWFOLDERTWIN, PHFOLDERTWIN);
SYNCENGAPI TWINRESULT WINAPI ReleaseTwinHandle(HTWIN);
SYNCENGAPI TWINRESULT WINAPI DeleteTwin(HTWIN);
SYNCENGAPI TWINRESULT WINAPI GetObjectTwinHandle(HBRFCASE, LPCTSTR, LPCTSTR, PHOBJECTTWIN);
SYNCENGAPI TWINRESULT WINAPI IsFolderTwin(HBRFCASE, LPCTSTR, PBOOL);
SYNCENGAPI TWINRESULT WINAPI CreateFolderTwinList(HBRFCASE, LPCTSTR, PFOLDERTWINLIST *);
SYNCENGAPI TWINRESULT WINAPI DestroyFolderTwinList(PFOLDERTWINLIST);
SYNCENGAPI TWINRESULT WINAPI IsOrphanObjectTwin(HOBJECTTWIN, PBOOL);
SYNCENGAPI TWINRESULT WINAPI CountSourceFolderTwins(HOBJECTTWIN, PULONG);
SYNCENGAPI TWINRESULT WINAPI AnyTwins(HBRFCASE, PBOOL);

/* twin list interface */

SYNCENGAPI TWINRESULT WINAPI CreateTwinList(HBRFCASE, PHTWINLIST);
SYNCENGAPI TWINRESULT WINAPI DestroyTwinList(HTWINLIST);
SYNCENGAPI TWINRESULT WINAPI AddTwinToTwinList(HTWINLIST, HTWIN);
SYNCENGAPI TWINRESULT WINAPI AddAllTwinsToTwinList(HTWINLIST);
SYNCENGAPI TWINRESULT WINAPI RemoveTwinFromTwinList(HTWINLIST, HTWIN);
SYNCENGAPI TWINRESULT WINAPI RemoveAllTwinsFromTwinList(HTWINLIST);

/* reconciliation list interface */

SYNCENGAPI TWINRESULT WINAPI CreateRecList(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST *);
SYNCENGAPI TWINRESULT WINAPI DestroyRecList(PRECLIST);
SYNCENGAPI TWINRESULT WINAPI ReconcileItem(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
SYNCENGAPI TWINRESULT WINAPI BeginReconciliation(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI EndReconciliation(HBRFCASE);
SYNCENGAPI TWINRESULT WINAPI GetFolderTwinStatus(HFOLDERTWIN, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

/* file stamp interface */

SYNCENGAPI TWINRESULT WINAPI GetFileStamp(LPCTSTR, PFILESTAMP);
SYNCENGAPI TWINRESULT WINAPI CompareFileStamps(PCFILESTAMP, PCFILESTAMP, PCOMPARISONRESULT);

/* volume ID interface */

SYNCENGAPI TWINRESULT WINAPI IsPathOnVolume(LPCTSTR, HVOLUMEID, PBOOL);
SYNCENGAPI TWINRESULT WINAPI GetVolumeDescription(HVOLUMEID, PVOLUMEDESC);


#ifdef __cplusplus
}                                /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __SYNCENG_H__ */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shsemip.h ===
#ifndef _SHSEMIP_H_
#define _SHSEMIP_H_

#if (defined(UNICODE) && (defined(_MIPS_) || defined(_ALPHA_) || defined(_PPC_)))

#define ALIGNMENT_SCENARIO

#endif

typedef UNALIGNED const WCHAR * LPNCWSTR;
typedef UNALIGNED WCHAR *       LPNWSTR;

#ifdef UNICODE
#define LPNCTSTR        LPNCWSTR
#define LPNTSTR         LPNWSTR
#else
#define LPNCTSTR        LPCSTR
#define LPNTSTR         LPSTR
#endif


//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
#if !defined(_SHELL32_)
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#ifndef DONT_WANT_SHELLDEBUG

#ifndef DebugMsg                                                                /* ;Internal */
#define DM_TRACE    0x0001      // Trace messages                               /* ;Internal */
#define DM_WARNING  0x0002      // Warning                                      /* ;Internal */
#define DM_ERROR    0x0004      // Error                                        /* ;Internal */
#define DM_ASSERT   0x0008      // Assertions                                   /* ;Internal */
#define Assert(f)                                                               /* ;Internal */
#define AssertE(f)      (f)                                                     /* ;Internal */
#define AssertMsg   1 ? (void)0 : (void)                                        /* ;Internal */
#define DebugMsg    1 ? (void)0 : (void)                                        /* ;Internal */
#endif                                                                          /* ;Internal */
                                                                                /* ;Internal */
#endif


//====== Ranges for WM_NOTIFY codes ==================================
// If a new set of codes is defined, make sure the range goes   /* ;Internal */
// here so that we can keep them distinct                       /* ;Internal */
// Note that these are defined to be unsigned to avoid compiler warnings
// since NMHDR.code is declared as UINT.
//
// NM_FIRST - NM_LAST defined in commctrl.h (0U-0U) - (OU-99U)
//
// LVN_FIRST - LVN_LAST defined in commctrl.h (0U-100U) - (OU-199U)
//
// PSN_FIRST - PSN_LAST defined in prsht.h (0U-200U) - (0U-299U)
//
// HDN_FIRST - HDN_LAST defined in commctrl.h (0U-300U) - (OU-399U)
//
// TVN_FIRST - TVN_LAST defined in commctrl.h (0U-400U) - (OU-499U)

// TTN_FIRST - TTN_LAST defined in commctrl.h (0U-520U) - (OU-549U)

#define RFN_FIRST       (0U-510U) // run file dialog notify
#define RFN_LAST        (0U-519U)

#define SEN_FIRST       (0U-550U)       // ;Internal
#define SEN_LAST        (0U-559U)       // ;Internal


#define MAXPATHLEN      MAX_PATH        // ;Internal




//===========================================================================
// ITEMIDLIST
//===========================================================================

// flags for ILGetDisplayNameEx
#define ILGDN_FULLNAME  0
#define ILGDN_ITEMONLY  1
#define ILGDN_INFOLDER  2

#ifndef USE_SHLWAPI_IDLIST
WINSHELLAPI LPITEMIDLIST  WINAPI ILGetNext(LPCITEMIDLIST pidl);
WINSHELLAPI UINT          WINAPI ILGetSize(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindLastID(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILRemoveLastID(LPITEMIDLIST pidl);

#define ILIsEmpty(pidl)     ((pidl)->mkid.cb==0)
#endif

WINSHELLAPI LPITEMIDLIST  WINAPI ILCreate(void);
WINSHELLAPI LPITEMIDLIST  WINAPI ILAppendID(LPITEMIDLIST pidl, LPCSHITEMID pmkid, BOOL fAppend);
WINSHELLAPI void          WINAPI ILFree(LPITEMIDLIST pidl);
WINSHELLAPI void          WINAPI ILGlobalFree(LPITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILGetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName);
WINSHELLAPI BOOL          WINAPI ILGetDisplayNameEx(LPSHELLFOLDER psfRoot, LPCITEMIDLIST pidl, LPTSTR pszName, int fType);
WINSHELLAPI LPITEMIDLIST  WINAPI ILClone(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCloneFirst(LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI ILGlobalClone(LPCITEMIDLIST pidl);
WINSHELLAPI BOOL          WINAPI ILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI BOOL          WINAPI ILIsParent(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fImmediate);
WINSHELLAPI LPITEMIDLIST  WINAPI ILFindChild(LPCITEMIDLIST pidlParent, LPCITEMIDLIST pidlChild);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
WINSHELLAPI HRESULT       WINAPI ILLoadFromStream(LPSTREAM pstm, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToStream(LPSTREAM pstm, LPCITEMIDLIST pidl);
WINSHELLAPI HRESULT       WINAPI ILLoadFromFile(HFILE hfile, LPITEMIDLIST *pidl);
WINSHELLAPI HRESULT       WINAPI ILSaveToFile(HFILE hfile, LPCITEMIDLIST pidl);
WINSHELLAPI LPITEMIDLIST  WINAPI _ILCreate(UINT cbSize);

WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPathA(LPCSTR pszPath);
WINSHELLAPI LPITEMIDLIST  WINAPI ILCreateFromPathW(LPCWSTR pszPath);
#ifdef UNICODE
#define ILCreateFromPath        ILCreateFromPathW
#else
#define ILCreateFromPath        ILCreateFromPathA
#endif

WINSHELLAPI HRESULT       WINAPI SHILCreateFromPath(LPCTSTR szPath, LPITEMIDLIST *ppidl, DWORD *rgfInOut);

// helper macros
#define ILCreateFromID(pmkid)   ILAppendID(NULL, pmkid, TRUE)

// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define _ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

/*
 * The SHObjectProperties API provides an easy way to invoke
 *   the Properties context menu command on shell objects.
 *
 *   PARAMETERS
 *
 *     hwndOwner    The window handle of the window which will own the dialog
 *     dwType       A SHOP_ value as defined below
 *     lpObject     Name of the object, see SHOP_ values below
 *     lpPage       The name of the property sheet page to open to or NULL.
 *
 *   RETURN
 *
 *     TRUE if the Properties command was invoked
 */
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCTSTR lpObject, LPCTSTR lpPage);

#define SHOP_PRINTERNAME 1  // lpObject points to a printer friendly name
#define SHOP_FILEPATH    2  // lpObject points to a fully qualified path+file name
#define SHOP_TYPEMASK   0x00000003
#define SHOP_MODAL      0x80000000




//===================================================================
// Smart tiling API's
WINSHELLAPI WORD WINAPI ArrangeWindows(HWND hwndParent, WORD flags, LPCRECT lpRect, WORD chwnd, const HWND FAR *ahwnd);

//
// for SHGetNetResource
//
typedef HANDLE HNRES;

//
// For SHCreateDefClassObject
//
typedef HRESULT (CALLBACK *LPFNCREATEINSTANCE)(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID *ppvObject);

typedef void (WINAPI FAR* RUNDLLPROCA)(HWND hwndStub,
        HINSTANCE hAppInstance,
        LPSTR lpszCmdLine, int nCmdShow);

typedef void (WINAPI FAR* RUNDLLPROCW)(HWND hwndStub,
        HINSTANCE hAppInstance,
        LPWSTR lpszCmdLine, int nCmdShow);

#ifdef UNICODE
#define RUNDLLPROC  RUNDLLPROCW
#else
#define RUNDLLPROC  RUNDLLPROCA
#endif


//=======================================================================
// String constants for
//  1. Registration database keywords       (prefix STRREG_)
//  2. Exported functions from handler dlls (prefix STREXP_)
//  3. .INI file keywords                   (prefix STRINI_)
//  4. Others                               (prefix STR_)
//=======================================================================
#define STRREG_SHELLUI          TEXT("ShellUIHandler")
#define STRREG_SHELL            TEXT("Shell")
#define STRREG_DEFICON          TEXT("DefaultIcon")
#define STRREG_SHEX             TEXT("shellex")
#define STRREG_SHEX_PROPSHEET   STRREG_SHEX TEXT("\\PropertySheetHandlers")
#define STRREG_SHEX_DDHANDLER   STRREG_SHEX TEXT("\\DragDropHandlers")
#define STRREG_SHEX_MENUHANDLER STRREG_SHEX TEXT("\\ContextMenuHandlers")
#define STRREG_SHEX_COPYHOOK    TEXT("Directory\\") STRREG_SHEX TEXT("\\CopyHookHandlers")
#define STRREG_SHEX_PRNCOPYHOOK TEXT("Printers\\") STRREG_SHEX TEXT("\\CopyHookHandlers")

#define STREXP_CANUNLOAD        "DllCanUnloadNow"       // From OLE 2.0

#define STRINI_CLASSINFO        TEXT(".ShellClassInfo")       // secton name
#define STRINI_SHELLUI          TEXT("ShellUIHandler")
#define STRINI_OPENDIRICON      TEXT("OpenDirIcon")
#define STRINI_DIRICON          TEXT("DirIcon")

#define STR_DESKTOPINI          TEXT("desktop.ini")
#define STR_DESKTOPINIA         "desktop.ini"



// Maximum length of a path string
#define CCHPATHMAX      MAX_PATH
#define MAXSPECLEN      MAX_PATH
#define MAX_PATH_URL    INTERNET_MAX_URL_LENGTH
#define DRIVEID(path)   ((path[0] - 'A') & 31)
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifndef SIZEOF
#define SIZEOF(a)       sizeof(a)
#endif

#define PATH_CCH_EXT    64
// PathResolve flags
#define PRF_VERIFYEXISTS            0x0001
#define PRF_TRYPROGRAMEXTENSIONS    (0x0002 | PRF_VERIFYEXISTS)
#define PRF_FIRSTDIRDEF             0x0004
#define PRF_DONTFINDLNK             0x0008      // if PRF_TRYPROGRAMEXTENSIONS is specified


//
// For CallCPLEntry16
//
DECLARE_HANDLE(FARPROC16);

#ifdef RFN_FIRST
#define RFN_EXECUTE             (RFN_FIRST - 0)
typedef struct {
    NMHDR hdr;
    LPCTSTR lpszCmd;
    LPCTSTR lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEA, FAR *LPNMRUNFILEA;

typedef struct {
    NMHDR hdr;
    LPCWSTR lpszCmd;
    LPCWSTR lpszWorkingDir;
    int nShowCmd;
} NMRUNFILEW, FAR *LPNMRUNFILEW;

#ifdef UNICODE
#define NMRUNFILE       NMRUNFILEW
#define LPNMRUNFILE     LPNMRUNFILEW
#else
#define NMRUNFILE       NMRUNFILEA
#define LPNMRUNFILE     LPNMRUNFILEA
#endif


#endif

// RUN FILE RETURN values from notify message
#define RFR_NOTHANDLED 0
#define RFR_SUCCESS 1
#define RFR_FAILURE 2

#define PathRemoveBlanksORD     33
#define PathFindFileNameORD     34
#define PathGetExtensionORD     158
#define PathFindExtensionORD    31

#ifdef OVERRIDE_SHLWAPI_PATH_FUNCTIONS
// SHLWAPI provides the majority of the Path functions.  There are
// some cases where the shell code (shell32 and explorer) need to
// call a different variation of these calls.  Because of this, we
// have OVERRIDE_SHLWAPI_PATH_FUNCTIONS.  Components such as shdocvw
// should strive to *not* have this defined.
//
// Some reasons why something like shell32 would need this:
//   1)  Shell32 calls some WNet APIs due to the NT merge.  Shlwapi
//       cannot take these.
//   2)  Shell32 needs the unaligned version PathBuildRoot,
//       PathCombine, etc.
//

#undef PathIsDirectory
#undef PathFileExists
#undef PathMakePretty

WINSHELLAPI BOOL  WINAPI PathIsDirectory(LPCTSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathFileExists(LPCTSTR lpszPath);
WINSHELLAPI BOOL  WINAPI PathMakePretty(LPTSTR lpszPath);

// Need to use the unaligned versions for non-Intel platforms
//
#undef PathBuildRoot
#undef PathCombine
#undef PathAppend
#undef PathIsUNC
#undef PathGetDriveNumber
#undef PathIsRelative

WINSHELLAPI LPNTSTR WINAPI PathBuildRoot(LPNTSTR szRoot, int iDrive);
WINSHELLAPI LPTSTR  WINAPI PathCombine(LPTSTR szDest, LPCTSTR lpszDir, LPNCTSTR lpszFile);
WINSHELLAPI BOOL    WINAPI PathAppend(LPTSTR pPath, LPNCTSTR pMore);
WINSHELLAPI BOOL    WINAPI PathIsUNC(LPNCTSTR lpsz);
WINSHELLAPI int     WINAPI PathGetDriveNumber(LPNCTSTR lpszPath);
WINSHELLAPI BOOL    WINAPI PathIsRelative(LPNCTSTR lpszPath);

#endif // OVERRIDE_SHLWAPI_PATH_FUNCTIONS

WINSHELLAPI LPTSTR WINAPI PathGetExtension(LPCTSTR lpszPath, LPTSTR lpszExtension, int cchExt);
WINSHELLAPI BOOL  WINAPI PathMakeUniqueName(LPTSTR pszUniqueName, UINT cchMax, LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir);
WINSHELLAPI BOOL  WINAPI PathGetShortName(LPCTSTR lpszLongName, LPTSTR lpszShortName, UINT cbShortName);
WINSHELLAPI BOOL  WINAPI PathGetLongName(LPCTSTR lpszShortName, LPTSTR lpszLongName, UINT cbLongName);
WINSHELLAPI BOOL  WINAPI PathDirectoryExists(LPCTSTR lpszDir);
WINSHELLAPI void  WINAPI PathQualify(LPTSTR lpsz);
WINSHELLAPI LPTSTR WINAPI PathGetNextComponent(LPCTSTR lpszPath, LPTSTR lpszComponent);
WINSHELLAPI BOOL  WINAPI PathIsExe(LPCTSTR lpszPath);

//
//  Return codes from PathCleanupSpec.  Negative return values are
//  unrecoverable errors
//
#define PCS_FATAL           0x80000000
#define PCS_REPLACEDCHAR    0x00000001
#define PCS_REMOVEDCHAR     0x00000002
#define PCS_TRUNCATED       0x00000004
#define PCS_PATHTOOLONG     0x00000008  // Always combined with FATAL

STDAPI_(int) PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec);

WINSHELLAPI int   WINAPI PathResolve(LPTSTR lpszPath, LPCTSTR FAR dirs[], UINT fFlags);
WINSHELLAPI BOOL  WINAPI ParseField(LPCTSTR szData, int n, LPTSTR szBuf, int iBufLen);
WINSHELLAPI LPNTSTR WINAPI uaPathFindFileName(LPNCTSTR pPath);

WINSHELLAPI int   WINAPI RestartDialog(HWND hwnd, LPCTSTR lpPrompt, DWORD dwReturn);
WINSHELLAPI void  WINAPI ExitWindowsDialog(HWND hwnd);
WINSHELLAPI void  WINAPI LogoffWindowsDialog(HWND hwnd);
WINSHELLAPI BOOL  WINAPI IsSuspendAllowed(void);

WINSHELLAPI void  WINAPI SHWaitForShutdown(void);

// Needed for RunFileDlg
#define RFD_NOBROWSE            0x00000001
#define RFD_NODEFFILE           0x00000002
#define RFD_USEFULLPATHDIR      0x00000004
#define RFD_NOSHOWOPEN          0x00000008
#define RFD_WOW_APP             0x00000010
#define RFD_NOSEPMEMORY_BOX     0x00000020


WINSHELLAPI int   WINAPI RunFileDlg(HWND hwndParent, HICON hIcon, LPCTSTR lpszWorkingDir, LPCTSTR lpszTitle,
                                    LPCTSTR lpszPrompt, DWORD dwFlags);
WINSHELLAPI int   WINAPI PickIconDlg(HWND hwnd, LPTSTR pszIconPath, UINT cbIconPath, int FAR *piIconIndex);
WINSHELLAPI BOOL  WINAPI GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cbFilePath, LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle);

WINSHELLAPI int  WINAPI DriveType(int iDrive);
WINSHELLAPI int  WINAPI RealDriveTypeFlags(int iDrive, BOOL fOKToHitNet);
WINSHELLAPI int  WINAPI RealDriveType(int iDrive, BOOL fOKToHitNet);
WINSHELLAPI void WINAPI InvalidateDriveType(int iDrive);
WINSHELLAPI int  WINAPI IsNetDrive(int iDrive);

WINSHELLAPI UINT WINAPI Shell_MergeMenus(HMENU hmDst, HMENU hmSrc, UINT uInsert, UINT uIDAdjust, UINT uIDAdjustMax, ULONG uFlags);

WINSHELLAPI void WINAPI SHRefreshSettings(void);
WINSHELLAPI LRESULT WINAPI SHRenameFile(HWND hwndParent, LPCTSTR pszDir, LPCTSTR pszOldName, LPCTSTR pszNewName, BOOL bRetainExtension);

WINSHELLAPI UINT WINAPI SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnres, UINT cbMax);

WINSHELLAPI STDAPI SHCreateDefClassObject(REFIID riid, LPVOID FAR* ppv, LPFNCREATEINSTANCE lpfn, UINT FAR * pcRefDll, REFIID riidInstance);

WINSHELLAPI LRESULT WINAPI CallCPLEntry16(HINSTANCE hinst, FARPROC16 lpfnEntry, HWND hwndCPL, UINT msg, DWORD lParam1, DWORD lParam2);
WINSHELLAPI BOOL    WINAPI SHRunControlPanel(LPCTSTR lpcszCmdLine, HWND hwndMsgParent);

WINSHELLAPI STDAPI SHCLSIDFromString(LPCTSTR lpsz, LPCLSID lpclsid);

WINSHELLAPI INT WINAPI LargeIntegerToString(LARGE_INTEGER *pN, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);
WINSHELLAPI INT WINAPI Int64ToString(_int64 n, LPTSTR szOutStr, UINT nSize, BOOL bFormat, NUMBERFMT *pFmt, DWORD dwNumFmtFlags);

//
// Constants used for dwNumFmtFlags argument in Int64ToString and LargeIntegerToString.
//
#define NUMFMT_IDIGITS    0x00000001
#define NUMFMT_ILZERO     0x00000002
#define NUMFMT_SGROUPING  0x00000004
#define NUMFMT_SDECIMAL   0x00000008
#define NUMFMT_STHOUSAND  0x00000010
#define NUMFMT_INEGNUMBER 0x00000020
#define NUMFMT_ALL        0xFFFFFFFF

#define SHObjectPropertiesORD   178
WINSHELLAPI BOOL WINAPI SHObjectProperties(HWND hwndOwner, DWORD dwType, LPCTSTR lpObject, LPCTSTR lpPage);


//===================================================================
// Shell_MergeMenu parameter
//
#define MM_ADDSEPARATOR         0x00000001L
#define MM_SUBMENUSHAVEIDS      0x00000002L

//-------- drive type identification --------------
// iDrive      drive index (0=A, 1=B, ...)
//
#define DRIVE_CDROM     5           // extended DriveType() types
#define DRIVE_RAMDRIVE  6
#define DRIVE_TYPE      0x000F      // type masek
#define DRIVE_SLOW      0x0010      // drive is on a slow link
#define DRIVE_LFN       0x0020      // drive supports LFNs
#define DRIVE_AUTORUN   0x0040      // drive has AutoRun.inf in root.
#define DRIVE_AUDIOCD   0x0080      // drive is a AudioCD
#define DRIVE_AUTOOPEN  0x0100      // should *always* auto open on insert
#define DRIVE_NETUNAVAIL 0x0200     // Network drive that is not available
#define DRIVE_SHELLOPEN  0x0400     // should auto open on insert, if shell has focus
#define DRIVE_SECURITY   0x0800     // Supports ACLs
#define DRIVE_COMPRESSED 0x1000     // Root of volume is compressed
#define DRIVE_ISCOMPRESSIBLE 0x2000 // Drive supports compression (not nescesarrily compressed)

#define DriveTypeFlags(iDrive)      DriveType('A' + (iDrive))
#define DriveIsSlow(iDrive)         (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SLOW)
#define DriveIsLFN(iDrive)          (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_LFN)
#define DriveIsAutoRun(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTORUN)
#define DriveIsAutoOpen(iDrive)     (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUTOOPEN)
#define DriveIsShellOpen(iDrive)    (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_SHELLOPEN)
#define DriveIsAudioCD(iDrive)      (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_AUDIOCD)
#define DriveIsNetUnAvail(iDrive)   (RealDriveTypeFlags(iDrive, FALSE) & DRIVE_NETUNAVAIL)
#define DriveIsSecure(iDrive)       (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_SECURITY)
#define DriveIsCompressed(iDrive)   (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_COMPRESSED)
#define DriveIsCompressible(iDrive) (RealDriveTypeFlags(iDrive, TRUE)  & DRIVE_ISCOMPRESSIBLE)

#define IsCDRomDrive(iDrive)        (RealDriveType(iDrive, FALSE) == DRIVE_CDROM)
#define IsRamDrive(iDrive)          (RealDriveType(iDrive, FALSE) == DRIVE_RAMDRIVE)
#define IsRemovableDrive(iDrive)    (RealDriveType(iDrive, FALSE) == DRIVE_REMOVABLE)
#define IsRemoteDrive(iDrive)       (RealDriveType(iDrive, FALSE) == DRIVE_REMOTE)


//-------- file engine stuff ----------

// "current directory" management routines.  used to set parameters
// that paths are qualfied against in MoveCopyDeleteRename()

WINSHELLAPI int  WINAPI GetDefaultDrive();
WINSHELLAPI int  WINAPI SetDefaultDrive(int iDrive);
WINSHELLAPI int  WINAPI SetDefaultDirectory(LPCTSTR lpPath);
WINSHELLAPI void WINAPI GetDefaultDirectory(int iDrive, LPSTR lpPath);

//
// NOTES: No reason to have this one here, but I don't want to break the build.
//
#ifndef WINCOMMCTRLAPI
int WINAPI StrToInt(LPCTSTR lpSrc);  // atoi()
#endif

#define POSINVALID  32767       // values for invalid position

#define IDCMD_SYSTEMFIRST       0x8000
#define IDCMD_SYSTEMLAST        0xbfff
#define IDCMD_CANCELED          0xbfff
#define IDCMD_PROCESSED         0xbffe
#define IDCMD_DEFAULT           0xbffe

/* timedate.c */

// **********************************************************************
//  DATE is a structure with a date packed into a WORD size value. It
//  is compatible with a file date in a directory entry structure.
// **********************************************************************

#ifndef DATE_DEFINED
typedef struct
{
    WORD    Day     :5; // Day number 1 - 31
    WORD    Month   :4; // Month number 1 - 12
    WORD    Year    :7; // Year subtracted from 1980, 0-127
} WORD_DATE;

typedef union
{
    WORD            wDate;
    WORD_DATE       sDate;
} WDATE;

#define DATE_DEFINED
#endif

// **********************************************************************
//  TIME is a structure with a 24 hour time packed into a WORD size value.
//  It is compatible with a file time in a directory entry structure.
// **********************************************************************

#ifndef TIME_DEFINED

typedef struct
{
        WORD    Sec     :5;     // Seconds divided by 2 (0 - 29).
        WORD    Min     :6;     // Minutes 0 - 59
        WORD    Hour    :5;     // Hours 0 - 24
} WORD_TIME;

typedef union
{
        WORD        wTime;
        WORD_TIME   sTime;
} WTIME;

#define TIME_DEFINED
#endif

WINSHELLAPI WORD WINAPI Shell_GetCurrentDate(void);
WINSHELLAPI WORD WINAPI Shell_GetCurrentTime(void);

//====== SEMI-PRIVATE API ===============================
DECLARE_HANDLE( HPSXA );
WINSHELLAPI HPSXA SHCreatePropSheetExtArray( HKEY hKey, LPCTSTR pszSubKey, UINT max_iface );
WINSHELLAPI void SHDestroyPropSheetExtArray( HPSXA hpsxa );
WINSHELLAPI UINT SHAddFromPropSheetExtArray( HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam );
WINSHELLAPI UINT SHReplaceFromPropSheetExtArray( HPSXA hpsxa, UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam );

//====== SEMI-PRIVATE API ORDINALS ===============================
// This is the list of semi-private ordinals we semi-publish.
#define SHAddFromPropSheetExtArrayORD           167
#define SHCreatePropSheetExtArrayORD            168
#define SHDestroyPropSheetExtArrayORD           169
#define SHReplaceFromPropSheetExtArrayORD       170
#define SHCreateDefClassObjectORD                70
#define SHGetNetResourceORD                      69

#define SHEXP_SHADDFROMPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHAddFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEPROPSHEETEXTARRAY         MAKEINTRESOURCE(SHCreatePropSheetExtArrayORD)
#define SHEXP_SHDESTROYPROPSHEETEXTARRAY        MAKEINTRESOURCE(SHDestroyPropSheetExtArrayORD)
#define SHEXP_SHREPLACEFROMPROPSHEETEXTARRAY    MAKEINTRESOURCE(SHReplaceFromPropSheetExtArrayORD)
#define SHEXP_SHCREATEDEFCLASSOBJECT            MAKEINTRESOURCE(SHCreateDefClassObjectORD)
#define SHEXP_SHGETNETRESOURCE                  MAKEINTRESOURCE(SHGetNetResourceORD)


/*
 * The SHFormatDrive API provides access to the Shell
 *   format dialog. This allows apps which want to format disks
 *   to bring up the same dialog that the Shell does to do it.
 *
 *   This dialog is not sub-classable. You cannot put custom
 *   controls in it. If you want this ability, you will have
 *   to write your own front end for the DMaint_FormatDrive
 *   engine.
 *
 *   NOTE that the user can format as many diskettes in the specified
 *   drive, or as many times, as he/she wishes to. There is no way to
 *   force any specififc number of disks to format. If you want this
 *   ability, you will have to write your own front end for the
 *   DMaint_FormatDrive engine.
 *
 *   NOTE also that the format will not start till the user pushes the
 *   start button in the dialog. There is no way to do auto start. If
 *   you want this ability, you will have to write your own front end
 *   for the DMaint_FormatDrive engine.
 *
 *   PARAMETERS
 *
 *     hwnd    = The window handle of the window which will own the dialog
 *               NOTE that unlike SHCheckDrive, hwnd == NULL does not cause
 *               this dialog to come up as a "top level application" window.
 *               This parameter should always be non-null, this dialog is
 *               only designed to be the child of another window, not a
 *               stand-alone application.
 *     drive   = The 0 based (A: == 0) drive number of the drive to format
 *     fmtID   = The ID of the physical format to format the disk with
 *               NOTE: The special value SHFMT_ID_DEFAULT means "use the
 *                     default format specified by the DMaint_FormatDrive
 *                     engine". If you want to FORCE a particular format
 *                     ID "up front" you will have to call
 *                     DMaint_GetFormatOptions yourself before calling
 *                     this to obtain the valid list of phys format IDs
 *                     (contents of the PhysFmtIDList array in the
 *                     FMTINFOSTRUCT).
 *     options = There is currently only two option bits defined
 *
 *                SHFMT_OPT_FULL
 *                SHFMT_OPT_SYSONLY
 *
 *               The normal defualt in the Shell format dialog is
 *               "Quick Format", setting this option bit indicates that
 *               the caller wants to start with FULL format selected
 *               (this is useful for folks detecting "unformatted" disks
 *               and wanting to bring up the format dialog).
 *
 *               The SHFMT_OPT_SYSONLY initializes the dialog to
 *               default to just sys the disk.
 *
 *               All other bits are reserved for future expansion and
 *               must be 0.
 *
 *               Please note that this is a bit field and not a value
 *               and treat it accordingly.
 *
 *   RETURN
 *      The return is either one of the SHFMT_* values, or if the
 *      returned DWORD value is not == to one of these values, then
 *      the return is the physical format ID of the last succesful
 *      format. The LOWORD of this value can be passed on subsequent
 *      calls as the fmtID parameter to "format the same type you did
 *      last time".
 *
 */
DWORD WINAPI SHFormatDrive(HWND hwnd, UINT drive, UINT fmtID, UINT options);

DWORD WINAPI SHChkDskDrive(HWND hwnd, UINT drive);

//
// Special value of fmtID which means "use the default format"
//
#define SHFMT_ID_DEFAULT    0xFFFF

//
// Option bits for options parameter
//
#define SHFMT_OPT_FULL     0x0001
#define SHFMT_OPT_SYSONLY  0x0002

//
// Special return values. PLEASE NOTE that these are DWORD values.
//
#define SHFMT_ERROR     0xFFFFFFFFL     // Error on last format, drive may be formatable
#define SHFMT_CANCEL    0xFFFFFFFEL     // Last format was canceled
#define SHFMT_NOFORMAT  0xFFFFFFFDL     // Drive is not formatable


#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHSEMIP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\shlobj.h ===
//===========================================================================
//
// Copyright (c) Microsoft Corporation 1991-1996
//
// File: shlobj.h
//
// History:							 /* ;Internal */
//  12-30-92 SatoNa Created.                                     /* ;Internal */
//  01-06-93 SatoNa Added this comment block.                    /* ;Internal */
//  01-13-93 SatoNa Added DragFilesOver & DropFiles              /* ;Internal */
//  01-27-93 SatoNa Created by combining shellui.h and handler.h /* ;Internal */
//  01-28-93 SatoNa OLE 2.0 beta 2                               /* ;Internal */
//  03-12-93 SatoNa Removed IFileDropTarget (we use IDropTarget) /* ;Internal */
//  07-30-94 SatoNa Updating comments after many changes         /* ;Internal */
//                                                               /* ;Internal */
//===========================================================================

#ifndef _SHLOBJ_H_
#define _SHLOBJ_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINSHELLAPI
//$ MAIL #if !defined(_SHELL32_)
#ifdef NEVER //$ MAIL
#define WINSHELLAPI DECLSPEC_IMPORT
#else
#define WINSHELLAPI
#endif
#endif // WINSHELLAPI

#define NO_MONIKER	/* ;Internal */

#include <ole2.h>
#ifndef _PRSHT_H_
#include <prsht.h>
#endif
#ifndef _INC_COMMCTRL
#include <commctrl.h>	// for LPTBBUTTON
#endif

#ifndef INITGUID
#include <shlguid.h>
#endif /* !INITGUID */

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//===========================================================================
//
// Object identifiers in the explorer's name space (ItemID and IDList)
//
//  All the items that the user can browse with the explorer (such as files,
// directories, servers, work-groups, etc.) has an identifier which is unique
// among items within the parent folder. Those identifiers are called item
// IDs (SHITEMID). Since all its parent folders have their own item IDs,
// any items can be uniquely identified by a list of item IDs, which is called
// an ID list (ITEMIDLIST).
//
//  ID lists are almost always allocated by the task allocator (see some
// description below as well as OLE 2.0 SDK) and may be passed across
// some of shell interfaces (such as IShellFolder). Each item ID in an ID list
// is only meaningful to its parent folder (which has generated it), and all
// the clients must treat it as an opaque binary data except the first two
// bytes, which indicates the size of the item ID.
//
//  When a shell extension -- which implements the IShellFolder interace --
// generates an item ID, it may put any information in it, not only the data
// with that it needs to identifies the item, but also some additional
// information, which would help implementing some other functions efficiently.
// For example, the shell's IShellFolder implementation of file system items
// stores the primary (long) name of a file or a directory as the item
// identifier, but it also stores its alternative (short) name, size and date
// etc.
//
//  When an ID list is passed to one of shell APIs (such as SHGetPathFromIDList),
// it is always an absolute path -- relative from the root of the name space,
// which is the desktop folder. When an ID list is passed to one of IShellFolder
// member function, it is always a relative path from the folder (unless it
// is explicitly specified).
//
//===========================================================================

//
// SHITEMID -- Item ID
//
typedef struct _SHITEMID	// mkid
{
    USHORT	cb;		// Size of the ID (including cb itself)
    BYTE	abID[1];	// The item ID (variable length)
} SHITEMID, * LPSHITEMID;
typedef const SHITEMID  * LPCSHITEMID;

//
// ITEMIDLIST -- List if item IDs (combined with 0-terminator)
//
typedef struct _ITEMIDLIST	// idl
{
    SHITEMID	mkid;
} ITEMIDLIST, * LPITEMIDLIST;
typedef const ITEMIDLIST * LPCITEMIDLIST;


//===========================================================================
//
// Task allocator API
//
//  All the shell extensions MUST use the task allocator (see OLE 2.0
// programming guild for its definition) when they allocate or free
// memory objects (mostly ITEMIDLIST) that are returned across any
// shell interfaces. There are two ways to access the task allocator
// from a shell extension depending on whether or not it is linked with
// OLE32.DLL or not (purely for efficiency).
//
// (1) A shell extension which calls any OLE API (i.e., linked with
//  OLE32.DLL) should call OLE's task allocator (by retrieving
//  the task allocator by calling CoGetMalloc API).
//
// (2) A shell extension which does not call any OLE API (i.e., not linked
//  with OLE32.DLL) should call the shell task allocator API (defined
//  below), so that the shell can quickly loads it when OLE32.DLL is not
//  loaded by any application at that point.
//
// Notes:
//  In next version of Windowso release, SHGetMalloc will be replaced by
// the following macro.
//
// #define SHGetMalloc(ppmem)	CoGetMalloc(MEMCTX_TASK, ppmem)
//
//===========================================================================

WINSHELLAPI HRESULT WINAPI SHGetMalloc(LPMALLOC * ppMalloc);

WINSHELLAPI LPVOID WINAPI SHAlloc(ULONG cb);			/* ;Internal */
WINSHELLAPI LPVOID WINAPI SHRealloc(LPVOID pv, ULONG cbNew);        /* ;Internal */
WINSHELLAPI ULONG  WINAPI SHGetSize(LPVOID pv);                     /* ;Internal */
WINSHELLAPI void   WINAPI SHFree(LPVOID pv);                        /* ;Internal */


//===========================================================================
//
// IContextMenu interface
//
// [OverView]
//
//  The shell uses the IContextMenu interface in following three cases.
//
// case-1: The shell is loading context menu extensions.
//
//   When the user clicks the right mouse button on an item within the shell's
//  name space (i.g., file, directory, server, work-group, etc.), it creates
//  the default context menu for its type, then loads context menu extensions
//  that are registered for that type (and its base type) so that they can
//  add extra menu items. Those context menu extensions are registered at
//  HKCR\{ProgID}\shellex\ContextMenuHandlers.
//
// case-2: The shell is retrieving a context menu of sub-folders in extended
//   name-space.
//
//   When the explorer's name space is extended by name space extensions,
//  the shell calls their IShellFolder::GetUIObjectOf to get the IContextMenu
//  objects when it creates context menus for folders under those extended
//  name spaces.
//
// case-3: The shell is loading non-default drag and drop handler for directories.
//
//   When the user performed a non-default drag and drop onto one of file
//  system folders (i.e., directories), it loads shell extensions that are
//  registered at HKCR\{ProgID}\DragDropHandlers.
//
//
// [Member functions]
//
//
// IContextMenu::QueryContextMenu
//
//   This member function may insert one or more menuitems to the specified
//  menu (hmenu) at the specified location (indexMenu which is never be -1).
//  The IDs of those menuitem must be in the specified range (idCmdFirst and
//  idCmdLast). It returns the maximum menuitem ID offset (ushort) in the
//  'code' field (low word) of the scode.
//
//   The uFlags specify the context. It may have one or more of following
//  flags.
//
//  CMF_DEFAULTONLY: This flag is passed if the user is invoking the default
//   action (typically by double-clicking, case 1 and 2 only). Context menu
//   extensions (case 1) should not add any menu items, and returns NOERROR.
//
//  CMF_VERBSONLY: The explorer passes this flag if it is constructing
//   a context menu for a short-cut object (case 1 and case 2 only). If this
//   flag is passed, it should not add any menu-items that is not appropriate
//   from a short-cut.
//    A good example is the "Delete" menuitem, which confuses the user
//   because it is not clear whether it deletes the link source item or the
//   link itself.
//
//  CMF_EXPLORER: The explorer passes this flag if it has the left-side pane
//   (case 1 and 2 only). Context menu extensions should ignore this flag.
//
//   High word (16-bit) are reserved for context specific communications
//  and the rest of flags (13-bit) are reserved by the system.
//
//
// IContextMenu::InvokeCommand
//
//   This member is called when the user has selected one of menuitems that
//  are inserted by previous QueryContextMenu member. In this case, the
//  LOWORD(lpici->lpVerb) contains the menuitem ID offset (menuitem ID -
//  idCmdFirst).
//
//   This member function may also be called programmatically. In such a case,
//  lpici->lpVerb specifies the canonical name of the command to be invoked,
//  which is typically retrieved by GetCommandString member previously.
//
//  Parameters in lpci:
//    cbSize -- Specifies the size of this structure (sizeof(*lpci))
//    hwnd   -- Specifies the owner window for any message/dialog box.
//    fMask  -- Specifies whether or not dwHotkey/hIcon paramter is valid.
//    lpVerb -- Specifies the command to be invoked.
//    lpParameters -- Parameters (optional)
//    lpDirectory  -- Working directory (optional)
//    nShow -- Specifies the flag to be passed to ShowWindow (SW_*).
//    dwHotKey -- Hot key to be assigned to the app after invoked (optional).
//    hIcon -- Specifies the icon (optional).
//
//
// IContextMenu::GetCommandString
//
//   This member function is called by the explorer either to get the
//  canonical (language independent) command name (uFlags == GCS_VERB) or
//  the help text ((uFlags & GCS_HELPTEXT) != 0) for the specified command.
//  The retrieved canonical string may be passed to its InvokeCommand
//  member function to invoke a command programmatically. The explorer
//  displays the help texts in its status bar; therefore, the length of
//  the help text should be reasonably short (<40 characters).
//
//  Parameters:
//   idCmd -- Specifies menuitem ID offset (from idCmdFirst)
//   uFlags -- Either GCS_VERB or GCS_HELPTEXT
//   pwReserved -- Reserved (must pass NULL when calling, must ignore when called)
//   pszName -- Specifies the string buffer.
//   cchMax -- Specifies the size of the string buffer.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IContextMenu

// QueryContextMenu uFlags
#define CMF_NORMAL	 	0x00000000
#define CMF_DEFAULTONLY  	0x00000001
#define CMF_VERBSONLY    	0x00000002
#define CMF_EXPLORE     	0x00000004
#define CMF_NOVERBS	 	0x00000008	/* ;Internal */
#define CMF_CANRENAME	 	0x00000010	/* ;Internal */
#define CMF_NODEFAULT    	0x00000020	/* ;Internal */
#define CMF_INCLUDESTATIC	0x00000040	/* ;Internal */
#define CMF_RESERVED	 	0xffff0000	// View specific

// GetCommandString uFlags
#define GCS_VERB         0x00000000     // canonical verb
#define GCS_HELPTEXT     0x00000001	// help text (for status bar)
#define GCS_VALIDATE     0x00000002	// validate command exists

#define CMDSTR_NEWFOLDER     "NewFolder"
#define CMDSTR_VIEWLIST      "ViewList"
#define CMDSTR_VIEWDETAILS   "ViewDetails"

#define CMIC_MASK_HOTKEY	SEE_MASK_HOTKEY
#define CMIC_MASK_ICON		SEE_MASK_ICON
#define CMIC_MASK_FLAG_NO_UI	SEE_MASK_FLAG_NO_UI
#define CMIC_MASK_MODAL         0x80000000				/* ; Internal */

#define CMIC_VALID_SEE_FLAGS	SEE_VALID_CMIC_FLAGS			/* ; Internal */

typedef struct _CMInvokeCommandInfo {
    DWORD cbSize;	 // must be sizeof(CMINVOKECOMMANDINFO)
    DWORD fMask;	 // any combination of CMIC_MASK_*
    HWND hwnd;		 // might be NULL (indicating no owner window)
    LPCSTR lpVerb;	 // either a string of MAKEINTRESOURCE(idOffset)
    LPCSTR lpParameters; // might be NULL (indicating no parameter)
    LPCSTR lpDirectory;	 // might be NULL (indicating no specific directory)
    int nShow;		 // one of SW_ values for ShowWindow() API

    DWORD dwHotKey;
    HANDLE hIcon;
} CMINVOKECOMMANDINFO,  *LPCMINVOKECOMMANDINFO;

#undef  INTERFACE
#define INTERFACE   IContextMenu

DECLARE_INTERFACE_(IContextMenu, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(QueryContextMenu)(THIS_
                                HMENU hmenu,
                                UINT indexMenu,
                                UINT idCmdFirst,
                                UINT idCmdLast,
                                UINT uFlags) PURE;

    STDMETHOD(InvokeCommand)(THIS_
                             LPCMINVOKECOMMANDINFO lpici) PURE;

    STDMETHOD(GetCommandString)(THIS_
                                UINT        idCmd,
                                UINT        uType,
                                UINT      * pwReserved,
                                LPSTR       pszName,
                                UINT        cchMax) PURE;
};

typedef IContextMenu *	LPCONTEXTMENU;

// IContextMenu2 (IContextMenu with one new member)				/* ;Internal */
										/* ;Internal */
#undef  INTERFACE								/* ;Internal */
#define INTERFACE   IContextMenu2						/* ;Internal */
										/* ;Internal */
DECLARE_INTERFACE_(IContextMenu2, IUnknown)					/* ;Internal */
{										/* ;Internal */
    // *** IUnknown methods ***							/* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;	/* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;					/* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;					/* ;Internal */
										/* ;Internal */
    STDMETHOD(QueryContextMenu)(THIS_						/* ;Internal */
                                HMENU hmenu,					/* ;Internal */
                                UINT indexMenu,					/* ;Internal */
                                UINT idCmdFirst,				/* ;Internal */
                                UINT idCmdLast,					/* ;Internal */
                                UINT uFlags) PURE;				/* ;Internal */
										/* ;Internal */
    STDMETHOD(InvokeCommand)(THIS_						/* ;Internal */
                             LPCMINVOKECOMMANDINFO lpici) PURE;			/* ;Internal */
										/* ;Internal */
    STDMETHOD(GetCommandString)(THIS_						/* ;Internal */
                                UINT        idCmd,				/* ;Internal */
                                UINT        uType,				/* ;Internal */
                                UINT      * pwReserved,				/* ;Internal */
                                LPSTR       pszName,				/* ;Internal */
                                UINT        cchMax) PURE;			/* ;Internal */
    STDMETHOD(HandleMenuMsg)(THIS_ 						/* ;Internal */
    			     UINT uMsg, 					/* ;Internal */
    			     WPARAM wParam, 					/* ;Internal */
    			     LPARAM lParam) PURE;				/* ;Internal */
};										/* ;Internal */
										/* ;Internal */
typedef IContextMenu2 *	LPCONTEXTMENU2;						/* ;Internal */


//----------------------------------------------------------------------------        /* ;Internal */
// Internal helper macro                                              	              /* ;Internal */
//---------------------------------------------------------------------------- 	      /* ;Internal */
										      /* ;Internal */
#define _IOffset(class, itf)         ((UINT)&(((class *)0)->itf))                     /* ;Internal */
#define IToClass(class, itf, pitf)   ((class  *)(((LPSTR)pitf)-_IOffset(class, itf))) /* ;Internal */
#define IToClassN(class, itf, pitf)  IToClass(class, itf, pitf)                       /* ;Internal */
                                                                                      /* ;Internal */
//                                                                    /* ;Internal */
// Helper macro definitions                                           /* ;Internal */
//                                                                    /* ;Internal */
#define S_BOOL(f)   MAKE_SCODE(SEVERITY_SUCCESS, 0, f)		      /* ;Internal */
                                                                      /* ;Internal */
#ifdef DEBUG                                                          /* ;Internal */
#define ReleaseAndAssert(punk) Assert(punk->lpVtbl->Release(punk)==0) /* ;Internal */
#else                                                                 /* ;Internal */
#define ReleaseAndAssert(punk) (punk->lpVtbl->Release(punk))          /* ;Internal */
#endif                                                                /* ;Internal */


//===========================================================================
//
// Interface: IShellExtInit
//
//  The IShellExtInit interface is used by the explorer to initialize shell
// extension objects. The explorer (1) calls CoCreateInstance (or equivalent)
// with the registered CLSID and IID_IShellExtInit, (2) calls its Initialize
// member, then (3) calls its QueryInterface to a particular interface (such
// as IContextMenu or IPropSheetExt and (4) performs the rest of operation.
//
//
// [Member functions]
//
// IShellExtInit::Initialize
//
//  This member function is called when the explorer is initializing either
// context menu extension, property sheet extension or non-default drag-drop
// extension.
//
//  Parameters: (context menu or property sheet extension)
//   pidlFolder -- Specifies the parent folder
//   lpdobj -- Spefifies the set of items selected in that folder.
//   hkeyProgID -- Specifies the type of the focused item in the selection.
//
//  Parameters: (non-default drag-and-drop extension)
//   pidlFolder -- Specifies the target (destination) folder
//   lpdobj -- Specifies the items that are dropped (see the description
//    about shell's clipboard below for clipboard formats).
//   hkeyProgID -- Specifies the folder type.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellExtInit

DECLARE_INTERFACE_(IShellExtInit, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellExtInit methods ***
    STDMETHOD(Initialize)(THIS_ LPCITEMIDLIST pidlFolder,
		          LPDATAOBJECT lpdobj, HKEY hkeyProgID) PURE;
};
									
typedef IShellExtInit *	LPSHELLEXTINIT;


//===========================================================================
//
// Interface: IShellPropSheetExt
//
//  The explorer uses the IShellPropSheetExt to allow property sheet
// extensions or control panel extensions to add additional property
// sheet pages.
//
//
// [Member functions]
//
// IShellPropSheetExt::AddPages
//
//  The explorer calls this member function when it finds a registered
// property sheet extension for a particular type of object. For each
// additional page, the extension creates a page object by calling
// CreatePropertySheetPage API and calls lpfnAddPage.
//
//  Parameters:
//   lpfnAddPage -- Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//
// IShellPropSheetExt::ReplacePage
//
//  The explorer never calls this member of property sheet extensions. The
// explorer calls this member of control panel extensions, so that they
// can replace some of default control panel pages (such as a page of
// mouse control panel).
//
//  Parameters:
//   uPageID -- Specifies the page to be replaced.
//   lpfnReplace Specifies the callback function.
//   lParam -- Specifies the opaque handle to be passed to the callback function.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IShellPropSheetExt

DECLARE_INTERFACE_(IShellPropSheetExt, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellPropSheetExt methods ***
    STDMETHOD(AddPages)(THIS_ LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam) PURE;
    STDMETHOD(ReplacePage)(THIS_ UINT uPageID, LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam) PURE;
};

typedef IShellPropSheetExt * LPSHELLPROPSHEETEXT;


/* BEGIN_B_LIST_API */ /* ;Internal */
//=========================================================================== /* ;Internal */
//                                                                            /* ;Internal */
// IPersistFolder Interface (private)                                         /* ;Internal */
//                                                                            /* ;Internal */
//  The IPersistFolder interface is used by the file system implementation of /* ;Internal */
// IShellFolder::BindToObject when it is initializing a shell folder object.  /* ;Internal */
//                                                                            /* ;Internal */
//                                                                            /* ;Internal */
// [Member functions]                                                         /* ;Internal */
//                                                                            /* ;Internal */
// IPersistFolder::Initialize                                                 /* ;Internal */
//                                                                            /* ;Internal */
//  This member function is called when the explorer is initializing a        /* ;Internal */
// shell folder object.                                                       /* ;Internal */
//                                                                            /* ;Internal */
//  Parameters:                                                               /* ;Internal */
//   pidl -- Specifies the absolute location of the folder.                   /* ;Internal */
//                                                                            /* ;Internal */
//=========================================================================== /* ;Internal */
                                                                              /* ;Internal */
#undef  INTERFACE                                                             /* ;Internal */
#define INTERFACE   IPersistFolder                                            /* ;Internal */
                                                                              /* ;Internal */
DECLARE_INTERFACE_(IPersistFolder, IPersist)	// fld                        /* ;Internal */
{                                                                             /* ;Internal */
    // *** IUnknown methods ***                                               /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;      /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                    /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                    /* ;Internal */
                                                                              /* ;Internal */
    // *** IPersist methods ***                                               /* ;Internal */
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;                     /* ;Internal */
                                                                              /* ;Internal */
    // *** IPersistFolder methods ***                                         /* ;Internal */
    STDMETHOD(Initialize) (THIS_                                              /* ;Internal */
			   LPCITEMIDLIST pidl) PURE;                          /* ;Internal */
};                                                                            /* ;Internal */
                                                                              /* ;Internal */
typedef IPersistFolder *	LPPERSISTFOLDER;                              /* ;Internal */
                                                                              /* ;Internal */
/* END_B_LIST_API */ /* ;Internal */

//===========================================================================
//
// IExtractIcon interface
//
//  This interface is used in two different places in the shell.
//
// Case-1: Icons of sub-folders for the scope-pane of the explorer.
//
//  It is used by the explorer to get the "icon location" of
// sub-folders from each shell folders. When the user expands a folder
// in the scope pane of the explorer, the explorer does following:
//  (1) binds to the folder (gets IShellFolder),
//  (2) enumerates its sub-folders by calling its EnumObjects member,
//  (3) calls its GetUIObjectOf member to get IExtractIcon interface
//     for each sub-folders.
//  In this case, the explorer uses only IExtractIcon::GetIconLocation
// member to get the location of the appropriate icon. An icon location
// always consists of a file name (typically DLL or EXE) and either an icon
// resource or an icon index.
//
//
// Case-2: Extracting an icon image from a file
//
//  It is used by the shell when it extracts an icon image
// from a file. When the shell is extracting an icon from a file,
// it does following:
//  (1) creates the icon extraction handler object (by getting its CLSID
//     under the {ProgID}\shell\ExtractIconHanler key and calling
//     CoCreateInstance requesting for IExtractIcon interface).
//  (2) Calls IExtractIcon::GetIconLocation.
//  (3) Then, calls IExtractIcon::Extract with the location/index pair.
//  (4) If (3) returns NOERROR, it uses the returned icon.
//  (5) Otherwise, it recursively calls this logic with new location
//     assuming that the location string contains a fully qualified path name.
//
//  From extension programmer's point of view, there are only two cases
// where they provide implementations of IExtractIcon:
//  Case-1) providing explorer extensions (i.e., IShellFolder).
//  Case-2) providing per-instance icons for some types of files.
//
// Because Case-1 is described above, we'll explain only Case-2 here.
//
// When the shell is about display an icon for a file, it does following:
//  (1) Finds its ProgID and ClassID.
//  (2) If the file has a ClassID, it gets the icon location string from the
//    "DefaultIcon" key under it. The string indicates either per-class
//    icon (e.g., "FOOBAR.DLL,2") or per-instance icon (e.g., "%1,1").
//  (3) If a per-instance icon is specified, the shell creates an icon
//    extraction handler object for it, and extracts the icon from it
//    (which is described above).
//
//  It is important to note that the shell calls IExtractIcon::GetIconLocation
// first, then calls IExtractIcon::Extract. Most application programs
// that support per-instance icons will probably store an icon location
// (DLL/EXE name and index/id) rather than an icon image in each file.
// In those cases, a programmer needs to implement only the GetIconLocation
// member and it Extract member simply returns S_FALSE. They need to
// implement Extract member only if they decided to store the icon images
// within files themselved or some other database (which is very rare).
//
//
//
// [Member functions]
//
//
// IExtractIcon::GetIconLocation
//
//  This function returns an icon location.
//
//  Parameters:
//   uFlags     [in]  -- Specifies if it is opened or not (GIL_OPENICON or 0)
//   szIconFile [out] -- Specifies the string buffer buffer for a location name.
//   cchMax     [in]  -- Specifies the size of szIconFile (almost always MAX_PATH)
//   piIndex    [out] -- Sepcifies the address of UINT for the index.
//   pwFlags    [out] -- Returns GIL_* flags
//  Returns:
//   NOERROR, if it returns a valid location; S_FALSE, if the shell use a
//   default icon.
//
//  Notes: The location may or may not be a path to a file. The caller can
//   not assume anything unless the subsequent Extract member call returns
//   S_FALSE.
//
//   if the returned location is not a path to a file, GIL_NOTFILENAME should
//   be set in the returned flags.
//
// IExtractIcon::Extract
//
//  This function extracts an icon image from a specified file.
//
//  Parameters:
//   pszFile [in] -- Specifies the icon location (typically a path to a file).
//   nIconIndex [in] -- Specifies the icon index.
//   phiconLarge [out] -- Specifies the HICON variable for large icon.
//   phiconSmall [out] -- Specifies the HICON variable for small icon.
//   nIconSize [in] -- Specifies the size icon required (size of large icon)
//                     LOWORD is the requested large icon size
//                     HIWORD is the requested small icon size
//  Returns:
//   NOERROR, if it extracted the from the file.
//   S_FALSE, if the caller should extract from the file specified in the
//           location.
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IExtractIcon

// GetIconLocation() input flags

#define GIL_OPENICON     0x0001      // allows containers to specify an "open" look
#define GIL_FORSHELL     0x0002      // icon is to be displayed in a ShellFolder

// GetIconLocation() return flags

#define GIL_SIMULATEDOC  0x0001      // simulate this document icon for this
#define GIL_PERINSTANCE  0x0002      // icons from this class are per instance (each file has its own)
#define GIL_PERCLASS     0x0004      // icons from this class per class (shared for all files of this type)
#define GIL_NOTFILENAME  0x0008      // location is not a filename, must call ::Extract
#define GIL_DONTCACHE    0x0010      // this icon should not be cached

DECLARE_INTERFACE_(IExtractIcon, IUnknown)	// exic
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExtractIcon methods ***
    STDMETHOD(GetIconLocation)(THIS_
                         UINT   uFlags,
                         LPSTR  szIconFile,
                         UINT   cchMax,
                         int   * piIndex,
                         UINT  * pwFlags) PURE;

    STDMETHOD(Extract)(THIS_
                           LPCSTR pszFile,
			   UINT	  nIconIndex,
			   HICON   *phiconLarge,
                           HICON   *phiconSmall,
                           UINT    nIconSize) PURE;
};

typedef IExtractIcon *  LPEXTRACTICON;

//=========================================================================== /* ;Internal */
//                                                                            /* ;Internal */
// IShellIcon Interface                                                       /* ;Internal */
//                                                                            /* ;Internal */
// used to get a icon index for a IShellFolder object.                        /* ;Internal */
//                                                                            /* ;Internal */
// this interface can be implemented by a IShellFolder, as a quick way to     /* ;Internal */
// return the icon for a object in the folder.                                /* ;Internal */
//                                                                            /* ;Internal */
// a instance of this interface is only created once for the folder, unlike   /* ;Internal */
// IExtractIcon witch is created once for each object.                        /* ;Internal */
//                                                                            /* ;Internal */
// if a ShellFolder does not implement this interface, the standard           /* ;Internal */
// GetUIObject(....IExtractIcon) method will be used to get a icon            /* ;Internal */
// for all objects.                                                           /* ;Internal */
//                                                                            /* ;Internal */
// the following standard imagelist indexs can be returned:                   /* ;Internal */
//                                                                            /* ;Internal */
//      0   document (blank page) (not associated)                            /* ;Internal */
//      1   document (with stuff on the page)                                 /* ;Internal */
//      2   application (exe, com, bat)                                       /* ;Internal */
//      3   folder (plain)                                                    /* ;Internal */
//      4   folder (open)                                                     /* ;Internal */
//                                                                            /* ;Internal */
// IShellIcon:GetIconOf(pidl, flags, lpIconIndex)                             /* ;Internal */
//                                                                            /* ;Internal */
//      pidl            object to get icon for.                               /* ;Internal */
//      flags           GIL_* input flags (GIL_OPEN, ...)                     /* ;Internal */
//      lpIconIndex     place to return icon index.                           /* ;Internal */
//                                                                            /* ;Internal */
//  returns:                                                                  /* ;Internal */
//      NOERROR, if lpIconIndex contains the correct system imagelist index.  /* ;Internal */
//      S_FALSE, if unable to get icon for this object, go through            /* ;Internal */
//               GetUIObject, IExtractIcon, methods.                          /* ;Internal */
//                                                                            /* ;Internal */
// History:		 				      /* ;Internal */ /* ;Internal */
//  --/--/94 ToddLa Created                                   /* ;Internal */ /* ;Internal */
//                                                            /* ;Internal */ /* ;Internal */
//=========================================================================== /* ;Internal */
                                                                              /* ;Internal */
#undef  INTERFACE                                                             /* ;Internal */
#define INTERFACE   IShellIcon                                                /* ;Internal */
                                                                              /* ;Internal */
DECLARE_INTERFACE_(IShellIcon, IUnknown)      // shi                          /* ;Internal */
{                                                                             /* ;Internal */
    // *** IUnknown methods ***                                               /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;      /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                    /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                    /* ;Internal */
                                                                              /* ;Internal */
    // *** IShellIcon methods ***                                             /* ;Internal */
    STDMETHOD(GetIconOf)(THIS_ LPCITEMIDLIST pidl, UINT flags,		      /* ;Internal */ 	
		    LPINT lpIconIndex) PURE;                                  /* ;Internal */
};                                                                            /* ;Internal */
                                                                              /* ;Internal */
typedef IShellIcon *LPSHELLICON;                                              /* ;Internal */
                                                                              /* ;Internal */
//===========================================================================
//
// IShellLink Interface
//
// History:		 				      /* ;Internal */
//  --/--/94 ChrisG Created                                   /* ;Internal */
//                                                            /* ;Internal */
//===========================================================================

// IShellLink::Resolve fFlags
typedef enum {
    SLR_NO_UI		= 0x0001,
    SLR_ANY_MATCH	= 0x0002,
    SLR_UPDATE          = 0x0004,
} SLR_FLAGS;

// IShellLink::GetPath fFlags
typedef enum {
    SLGP_SHORTPATH	= 0x0001,
    SLGP_UNCPRIORITY	= 0x0002,
} SLGP_FLAGS;

#undef  INTERFACE
#define INTERFACE   IShellLink

DECLARE_INTERFACE_(IShellLink, IUnknown)	// sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(GetPath)(THIS_ LPSTR pszFile, int cchMaxPath, WIN32_FIND_DATA *pfd, DWORD fFlags) PURE;

    STDMETHOD(GetIDList)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(SetIDList)(THIS_ LPCITEMIDLIST pidl) PURE;

    STDMETHOD(GetDescription)(THIS_ LPSTR pszName, int cchMaxName) PURE;
    STDMETHOD(SetDescription)(THIS_ LPCSTR pszName) PURE;

    STDMETHOD(GetWorkingDirectory)(THIS_ LPSTR pszDir, int cchMaxPath) PURE;
    STDMETHOD(SetWorkingDirectory)(THIS_ LPCSTR pszDir) PURE;

    STDMETHOD(GetArguments)(THIS_ LPSTR pszArgs, int cchMaxPath) PURE;
    STDMETHOD(SetArguments)(THIS_ LPCSTR pszArgs) PURE;

    STDMETHOD(GetHotkey)(THIS_ WORD *pwHotkey) PURE;
    STDMETHOD(SetHotkey)(THIS_ WORD wHotkey) PURE;

    STDMETHOD(GetShowCmd)(THIS_ int *piShowCmd) PURE;
    STDMETHOD(SetShowCmd)(THIS_ int iShowCmd) PURE;

    STDMETHOD(GetIconLocation)(THIS_ LPSTR pszIconPath, int cchIconPath, int *piIcon) PURE;
    STDMETHOD(SetIconLocation)(THIS_ LPCSTR pszIconPath, int iIcon) PURE;

    STDMETHOD(SetRelativePath)(THIS_ LPCSTR pszPathRel, DWORD dwReserved) PURE;

    STDMETHOD(Resolve)(THIS_ HWND hwnd, DWORD fFlags) PURE;

    STDMETHOD(SetPath)(THIS_ LPCSTR pszFile) PURE;
};

//=========================================================================== /* ;Internal */
//                                                                            /* ;Internal */
// IShellExecuteHook Interface                                                /* ;Internal */
//                                                                            /* ;Internal */
// History:                                                                   /* ;Internal */
//  11/18/94 DavidDi Created                                                  /* ;Internal */
//                                                                            /* ;Internal */
//=========================================================================== /* ;Internal */
                                                                              /* ;Internal */
#undef  INTERFACE                                                             /* ;Internal */
#define INTERFACE   IShellExecuteHook                                         /* ;Internal */
                                                                              /* ;Internal */
DECLARE_INTERFACE_(IShellExecuteHook, IUnknown) // shexhk                     /* ;Internal */
{                                                                             /* ;Internal */
    // *** IUnknown methods ***                                               /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;      /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                    /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                    /* ;Internal */
                                                                              /* ;Internal */
    // *** IShellExecuteHook methods ***                                      /* ;Internal */
    STDMETHOD(Execute)(THIS_ HWND hwndParent, LPCSTR lpcszVerb,               /* ;Internal */
                       LPCSTR lpcszFile, LPCSTR lpcszArgs,                    /* ;Internal */
                       LPCSTR lpcszInitialDir, int nShow) PURE;               /* ;Internal */
};                                                                            /* ;Internal */

//===========================================================================
//
// ICopyHook Interface
//
// History:		 				      /* ;Internal */
//  --/--/94 CheeChew Created                                 /* ;Internal */
//                                                            /* ;Internal */
//
//  The copy hook is called whenever file system directories are
//  copy/moved/deleted/renamed via the shell.  It is also called by the shell
//  on changes of status of printers.
//
//  Clients register their id under STRREG_SHEX_COPYHOOK for file system hooks
//  and STRREG_SHEx_PRNCOPYHOOK for printer hooks.
//  the CopyCallback is called prior to the action, so the hook has the chance
//  to allow, deny or cancel the operation by returning the falues:
//     IDYES  -  means allow the operation
//     IDNO   -  means disallow the operation on this file, but continue with
//              any other operations (eg. batch copy)
//     IDCANCEL - means disallow the current operation and cancel any pending
//              operations
//
//   arguments to the CopyCallback
//      hwnd - window to use for any UI
//      wFunc - what operation is being done
//      wFlags - and flags (FOF_*) set in the initial call to the file operation
//      pszSrcFile - name of the source file
//      dwSrcAttribs - file attributes of the source file
//      pszDestFile - name of the destiation file (for move and renames)
//      dwDestAttribs - file attributes of the destination file
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   ICopyHook

#ifndef FO_MOVE //these need to be kept in sync with the ones in shellapi.h

// file operations

#define FO_MOVE           0x0001
#define FO_COPY           0x0002
#define FO_DELETE         0x0003
#define FO_RENAME         0x0004

#define FOF_MULTIDESTFILES         0x0001
#define FOF_CONFIRMMOUSE           0x0002
#define FOF_SILENT                 0x0004  // don't create progress/report
#define FOF_RENAMEONCOLLISION      0x0008
#define FOF_NOCONFIRMATION         0x0010  // Don't prompt the user.
#define FOF_WANTMAPPINGHANDLE      0x0020  // Fill in SHFILEOPSTRUCT.hNameMappings
                                      // Must be freed using SHFreeNameMappings
#define FOF_ALLOWUNDO              0x0040
#define FOF_FILESONLY              0x0080  // on *.*, do only files
#define FOF_SIMPLEPROGRESS         0x0100  // means don't show names of files
#define FOF_NOCONFIRMMKDIR         0x0200  // don't confirm making any needed dirs

typedef UINT FILEOP_FLAGS;

// printer operations

#define PO_DELETE	0x0013  // printer is being deleted
#define PO_RENAME	0x0014  // printer is being renamed
#define PO_PORTCHANGE	0x0020  // port this printer connected to is being changed
				// if this id is set, the strings received by
				// the copyhook are a doubly-null terminated
				// list of strings.  The first is the printer
				// name and the second is the printer port.
#define PO_REN_PORT	0x0034  // PO_RENAME and PO_PORTCHANGE at same time.

// no POF_ flags currently defined

typedef UINT PRINTEROP_FLAGS;

#endif // FO_MOVE								

DECLARE_INTERFACE_(ICopyHook, IUnknown)	// sl
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD_(UINT,CopyCallback) (THIS_ HWND hwnd, UINT wFunc, UINT wFlags, LPCSTR pszSrcFile, DWORD dwSrcAttribs,
                                   LPCSTR pszDestFile, DWORD dwDestAttribs) PURE;
};

typedef ICopyHook *	LPCOPYHOOK;



//===========================================================================
//
// IFileViewerSite Interface
//
// History:		 				      /* ;Internal */
//  --/--/94 KurtE Created                                    /* ;Internal */
//                                                            /* ;Internal */
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewerSite

DECLARE_INTERFACE(IFileViewerSite)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(SetPinnedWindow) (THIS_ HWND hwnd) PURE;
    STDMETHOD(GetPinnedWindow) (THIS_ HWND *phwnd) PURE;
};

typedef IFileViewerSite * LPFILEVIEWERSITE;


//===========================================================================
//
// IFileViewer Interface
//
// Implemented in a FileViewer component object.  Used to tell a
// FileViewer to PrintTo or to view, the latter happening though
// ShowInitialize and Show.  The filename is always given to the
// viewer through IPersistFile.
//
// History:		 				      /* ;Internal */
//  3/4/94 kraigb Created                                     /* ;Internal */
//                                                            /* ;Internal */
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IFileViewer

typedef struct
{
    // Stuff passed into viewer (in)
    DWORD cbSize;           // Size of structure for future expansion...
    HWND hwndOwner;         // who is the owner window.
    int iShow;              // The show command

    // Passed in and updated  (in/Out)
    DWORD dwFlags;          // flags
    RECT rect;              // Where to create the window may have defaults
    LPUNKNOWN punkRel;      // Relese this interface when window is visible

    // Stuff that might be returned from viewer (out)
    OLECHAR strNewFile[MAX_PATH];   // New File to view.

} FVSHOWINFO, *LPFVSHOWINFO;

    // Define File View Show Info Flags.
#define FVSIF_RECT      0x00000001      // The rect variable has valid data.
#define FVSIF_PINNED    0x00000002      // We should Initialize pinned

#define FVSIF_NEWFAILED 0x08000000      // The new file passed back failed
                                        // to be viewed.

#define FVSIF_NEWFILE   0x80000000      // A new file to view has been returned
#define FVSIF_CANVIEWIT 0x40000000      // The viewer can view it.

DECLARE_INTERFACE(IFileViewer)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(ShowInitialize) (THIS_ LPFILEVIEWERSITE lpfsi) PURE;
    STDMETHOD(Show) (THIS_ LPFVSHOWINFO pvsi) PURE;
    STDMETHOD(PrintTo) (THIS_ LPSTR pszDriver, BOOL fSuppressUI) PURE;
};

typedef IFileViewer * LPFILEVIEWER;

/* BEGIN_B_LIST_API */ /* ;Internal */
//========================================================================== /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser/IShellView/IShellFolder interface                           /* ;Internal */
//                                                                           /* ;Internal */
//  These three interfaces are used when the shell communicates with         /* ;Internal */
// name space extensions. The shell (explorer) provides IShellBrowser        /* ;Internal */
// interface, and extensions implements IShellFolder and IShellView          /* ;Internal */
// interfaces.                                                               /* ;Internal */
//                                                                           /* ;Internal */
//========================================================================== /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
//                                                                           /* ;Internal */
// Command/menuitem IDs                                                      /* ;Internal */
//                                                                           /* ;Internal */
//  The explorer dispatches WM_COMMAND messages based on the range of        /* ;Internal */
// command/menuitem IDs. All the IDs of menuitems that the view (right       /* ;Internal */
// pane) inserts must be in FCIDM_SHVIEWFIRST/LAST (otherwise, the explorer  /* ;Internal */
// won't dispatch them). The view should not deal with any menuitems         /* ;Internal */
// in FCIDM_BROWSERFIRST/LAST (otherwise, it won't work with the future      /* ;Internal */
// version of the shell).                                                    /* ;Internal */
//                                                                           /* ;Internal */
//  FCIDM_SHVIEWFIRST/LAST	for the right pane (IShellView)              /* ;Internal */
//  FCIDM_BROWSERFIRST/LAST	for the explorer frame (IShellBrowser)       /* ;Internal */
//  FCIDM_GLOBAL/LAST		for the explorer's submenu IDs               /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
                                                                             /* ;Internal */
#define FCIDM_SHVIEWFIRST           0x0000                                   /* ;Internal */
#define FCIDM_SHVIEWLAST            0x7fff                                   /* ;Internal */
#define FCIDM_BROWSERFIRST          0xa000                                   /* ;Internal */
#define FCIDM_BROWSERLAST           0xbf00                                   /* ;Internal */
#define FCIDM_GLOBALFIRST           0x8000                                   /* ;Internal */
#define FCIDM_GLOBALLAST            0x9fff                                   /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// Global submenu IDs and separator IDs                                      /* ;Internal */
//                                                                           /* ;Internal */
#define FCIDM_MENU_FILE		    (FCIDM_GLOBALFIRST+0x0000)               /* ;Internal */
#define FCIDM_MENU_EDIT		    (FCIDM_GLOBALFIRST+0x0040)               /* ;Internal */
#define FCIDM_MENU_VIEW		    (FCIDM_GLOBALFIRST+0x0080)               /* ;Internal */
#define FCIDM_MENU_VIEW_SEP_OPTIONS (FCIDM_GLOBALFIRST+0x0081)               /* ;Internal */
#define FCIDM_MENU_TOOLS	    (FCIDM_GLOBALFIRST+0x00c0)               /* ;Internal */
#define FCIDM_MENU_TOOLS_SEP_GOTO   (FCIDM_GLOBALFIRST+0x00c1)               /* ;Internal */
#define FCIDM_MENU_HELP		    (FCIDM_GLOBALFIRST+0x0100)               /* ;Internal */
#define FCIDM_MENU_FIND             (FCIDM_GLOBALFIRST+0x0140)               /* ;Internal */
                                                                             /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
// control IDs known to the view                                             /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
                                                                             /* ;Internal */
#define FCIDM_TOOLBAR      (FCIDM_BROWSERFIRST + 0)	                     /* ;Internal */
#define FCIDM_STATUS       (FCIDM_BROWSERFIRST + 1)	                     /* ;Internal */
#define FCIDM_DRIVELIST    (FCIDM_BROWSERFIRST + 2) /* NOT_EVEN_IN_B_LIST */ /* ;Internal */
#define FCIDM_TREE         (FCIDM_BROWSERFIRST + 3) /* NOT_EVEN_IN_B_LIST */ /* ;Internal */
#define FCIDM_TABS         (FCIDM_BROWSERFIRST + 4) /* NOT_EVEN_IN_B_LIST */ /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
//                                                                           /* ;Internal */
// FOLDERSETTINGS                                                            /* ;Internal */
//                                                                           /* ;Internal */
//  FOLDERSETTINGS is a data structure that explorer passes from one folder  /* ;Internal */
// view to another, when the user is browsing. It calls ISV::GetCurrentInfo  /* ;Internal */
// member to get the current settings and pass it to ISV::CreateViewWindow   /* ;Internal */
// to allow the next folder view "inherit" it. These settings assumes a      /* ;Internal */
// particular UI (which the shell's folder view has), and shell extensions   /* ;Internal */
// may or may not use those settings.                                        /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
                                                                             /* ;Internal */
typedef LPBYTE LPVIEWSETTINGS;                                               /* ;Internal */
                                                                             /* ;Internal */
// NB Bitfields.                                                             /* ;Internal */
typedef enum                                                                 /* ;Internal */
    {                                                                        /* ;Internal */
    FWF_AUTOARRANGE =       0x0001,                                          /* ;Internal */
    FWF_ABBREVIATEDNAMES =  0x0002,                                          /* ;Internal */
    FWF_SNAPTOGRID =	    0x0004,                                          /* ;Internal */
    // FWF_UNUSED =	    0x0008,                                          /* ;Internal */
    FWF_BESTFITWINDOW =     0x0010,                                          /* ;Internal */
    FWF_DESKTOP =	    0x0020,                                          /* ;Internal */
    FWF_SINGLESEL =	    0x0040,                                          /* ;Internal */
    FWF_NOSUBFOLDERS = 	    0x0080                                           /* ;Internal */
    } FOLDERFLAGS;                                                           /* ;Internal */
                                                                             /* ;Internal */
typedef enum                                                                 /* ;Internal */
    {                                                                        /* ;Internal */
    FVM_ICON =              1,                                               /* ;Internal */
    FVM_SMALLICON =         2,                                               /* ;Internal */
    FVM_LIST =              3,                                               /* ;Internal */
    FVM_DETAILS =           4,                                               /* ;Internal */
    } FOLDERVIEWMODE;                                                        /* ;Internal */
                                                                             /* ;Internal */
typedef struct                                                               /* ;Internal */
    {                                                                        /* ;Internal */
    UINT ViewMode;       // View mode (FOLDERVIEWMODE values)                /* ;Internal */
    UINT fFlags;         // View options (FOLDERFLAGS bits)                  /* ;Internal */
    } FOLDERSETTINGS, *LPFOLDERSETTINGS;                                     /* ;Internal */
                                                                             /* ;Internal */
typedef const FOLDERSETTINGS * LPCFOLDERSETTINGS;                            /* ;Internal */
typedef FOLDERSETTINGS *PFOLDERSETTINGS;		/* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//-------------------------------------------------------------------------- /* ;Internal */
//                                                                           /* ;Internal */
// Interface:   IShellBrowser                                                /* ;Internal */
//                                                                           /* ;Internal */
// History:					/* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//  01-08-93 GeorgeP     Created.               /* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//                                              /* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//                                                                           /* ;Internal */
//  IShellBrowser interface is the interface that is provided by the shell   /* ;Internal */
// explorer/folder frame window. When it creates the "contents pane" of      /* ;Internal */
// a shell folder (which provides IShellFolder interface), it calls its      /* ;Internal */
// CreateViewObject member function to create an IShellView object. Then,    /* ;Internal */
// it calls its CreateViewWindow member to create the "contents pane"        /* ;Internal */
// window. The pointer to the IShellBrowser interface is passed to           /* ;Internal */
// the IShellView object as a parameter to this CreateViewWindow member      /* ;Internal */
// function call.                                                            /* ;Internal */
//                                                                           /* ;Internal */
//    +--------------------------+  <-- Explorer window                      /* ;Internal */
//    | [] Explorer              |	                                     /* ;Internal */
//    |--------------------------+	 IShellBrowser                       /* ;Internal */
//    | File Edit View ..        |                                           /* ;Internal */
//    |--------------------------|                                           /* ;Internal */
//    |        |                 |                                           /* ;Internal */
//    |        |              <-------- Content pane                         /* ;Internal */
//    |        |                 |                                           /* ;Internal */
//    |        |                 |	 IShellView                          /* ;Internal */
//    |        |                 |	                                     /* ;Internal */
//    |        |                 |                                           /* ;Internal */
//    +--------------------------+                                           /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// [Member functions]                                                        /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::GetWindow(phwnd)                                           /* ;Internal */
//                                                                           /* ;Internal */
//   Inherited from IOleWindow::GetWindow.                                   /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::ContextSensitiveHelp(fEnterMode)                           /* ;Internal */
//                                                                           /* ;Internal */
//   Inherited from IOleWindow::ContextSensitiveHelp.                        /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::InsertMenusSB(hmenuShared, lpMenuWidths)                   /* ;Internal */
//                                                                           /* ;Internal */
//   Similar to the IOleInPlaceFrame::InsertMenus. The explorer will put     /* ;Internal */
//  "File" and "Edit" pulldown in the File menu group, "View" and "Tools"    /* ;Internal */
//  in the Container menu group and "Help" in the Window menu group. Each    /* ;Internal */
//  pulldown menu will have a uniqu ID, FCIDM_MENU_FILE/EDIT/VIEW/TOOLS/HELP./* ;Internal */
//  The view is allowed to insert menuitems into those sub-menus by those    /* ;Internal */
//  IDs must be between FCIDM_SHVIEWFIRST and FCIDM_SHVIEWLAST.              /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::SetMenuSB(hmenuShared, holemenu, hwndActiveObject)         /* ;Internal */
//                                                                           /* ;Internal */
//   Similar to the IOleInPlaceFrame::SetMenu. The explorer ignores the      /* ;Internal */
//  holemenu parameter (reserved for future enhancement)  and performs       /* ;Internal */
//  menu-dispatch based on the menuitem IDs (see the description above).     /* ;Internal */
//  It is important to note that the explorer will add different             /* ;Internal */
//  set of menuitems depending on whether the view has a focus or not.       /* ;Internal */
//  Therefore, it is very important to call ISB::OnViewWindowActivate        /* ;Internal */
//  whenever the view window (or its children) gets the focus.               /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::RemoveMenusSB(hmenuShared)                                 /* ;Internal */
//                                                                           /* ;Internal */
//   Same as the IOleInPlaceFrame::RemoveMenus.                              /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::SetStatusTextSB(lpszStatusText)                            /* ;Internal */
//                                                                           /* ;Internal */
//   Same as the IOleInPlaceFrame::SetStatusText. It is also possible to     /* ;Internal */
//  send messages directly to the status window via SendControlMsg.          /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::EnableModelessSB(fEnable)                                  /* ;Internal */
//                                                                           /* ;Internal */
//   Same as the IOleInPlaceFrame::EnableModeless.                           /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::TranslateAcceleratorSB(lpmsg, wID)                         /* ;Internal */
//                                                                           /* ;Internal */
//   Same as the IOleInPlaceFrame::TranslateAccelerator, but will be         /* ;Internal */
//  never called because we don't support EXEs (i.e., the explorer has       /* ;Internal */
//  the message loop). This member function is defined here for possible     /* ;Internal */
//  future enhancement.                                                      /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::BrowseObject(pidl, wFlags)                                 /* ;Internal */
//                                                                           /* ;Internal */
//   The view calls this member to let shell explorer browse to another      /* ;Internal */
//  folder. The pidl and wFlags specifies the folder to be browsed.          /* ;Internal */
//                                                                           /* ;Internal */
//  Following three flags specifies whether it creates another window or not./* ;Internal */
//   SBSP_SAMEBROWSER  -- Browse to another folder with the same window.     /* ;Internal */
//   SBSP_NEWBROWSER   -- Creates another window for the specified folder.   /* ;Internal */
//   SBSP_DEFBROWSER   -- Default behavior (respects the view option).       /* ;Internal */
//                                                                           /* ;Internal */
//  Following three flags specifies open, explore, or default mode. These   ./* ;Internal */
//  are ignored if SBSP_SAMEBROWSER or (SBSP_DEFBROWSER && (single window   ./* ;Internal */
//  browser || explorer)).                                                  ./* ;Internal */
//   SBSP_OPENMODE     -- Use a normal folder window                         /* ;Internal */
//   SBSP_EXPLOREMODE  -- Use an explorer window                             /* ;Internal */
//   SBSP_DEFMODE      -- Use the same as the current window                 /* ;Internal */
//                                                                           /* ;Internal */
//  Following three flags specifies the pidl.                                /* ;Internal */
//   SBSP_ABSOLUTE -- pidl is an absolute pidl (relative from desktop)       /* ;Internal */
//   SBSP_RELATIVE -- pidl is relative from the current folder.              /* ;Internal */
//   SBSP_PARENT   -- Browse the parent folder (ignores the pidl)            /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::GetViewStateStream(grfMode, ppstm)                         /* ;Internal */
//                                                                           /* ;Internal */
//   The browser returns an IStream interface as the storage for view        /* ;Internal */
//  specific state information.                                              /* ;Internal */
//                                                                           /* ;Internal */
//   grfMode -- Specifies the read/write access (STGM_READ/WRITE/READWRITE)  /* ;Internal */
//   ppstm   -- Specifies the LPSTREAM variable to be filled.                /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::GetControlWindow(id, phwnd)                                /* ;Internal */
//                                                                           /* ;Internal */
//   The shell view may call this member function to get the window handle   /* ;Internal */
//  of Explorer controls (toolbar or status winodw -- FCW_TOOLBAR or         /* ;Internal */
//  FCW_STATUS).                                                             /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::SendControlMsg(id, uMsg, wParam, lParam, pret)             /* ;Internal */
//                                                                           /* ;Internal */
//   The shell view calls this member function to send control messages to   /* ;Internal */
//  one of Explorer controls (toolbar or status window -- FCW_TOOLBAR or     /* ;Internal */
//  FCW_STATUS).                                                             /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::QueryActiveShellView(IShellView * ppshv)                   /* ;Internal */
//                                                                           /* ;Internal */
//   This member returns currently activated (displayed) shellview object.   /* ;Internal */
//  A shellview never need to call this member function.                     /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::OnViewWindowActive(pshv)                                   /* ;Internal */
//                                                                           /* ;Internal */
//   The shell view window calls this member function when the view window   /* ;Internal */
//  (or one of its children) got the focus. It MUST call this member before  /* ;Internal */
//  calling IShellBrowser::InsertMenus, because it will insert different     /* ;Internal */
//  set of menu items depending on whether the view has the focus or not.    /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellBrowser::SetToolbarItems(lpButtons, nButtons, uFlags)               /* ;Internal */
//                                                                           /* ;Internal */
//   The view calls this function to add toolbar items to the exporer's      /* ;Internal */
//  toolbar. "lpButtons" and "nButtons" specifies the array of toolbar       /* ;Internal */
//  items. "uFlags" must be one of FCT_MERGE, FCT_CONFIGABLE, FCT_ADDTOEND.  /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------  /* ;Internal */
                                                                             /* ;Internal */
#undef  INTERFACE                                                            /* ;Internal */
#define INTERFACE   IShellBrowser                                            /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// Values for wFlags parameter of ISB::BrowseObject() member.                /* ;Internal */
//                                                                           /* ;Internal */
#define SBSP_DEFBROWSER  0x0000                                              /* ;Internal */
#define SBSP_SAMEBROWSER 0x0001                                              /* ;Internal */
#define SBSP_NEWBROWSER  0x0002                                              /* ;Internal */

#define SBSP_DEFMODE     0x0000                                              /* ;Internal */
#define SBSP_OPENMODE    0x0010                                              /* ;Internal */
#define SBSP_EXPLOREMODE 0x0020                                              /* ;Internal */

#define SBSP_ABSOLUTE	 0x0000                                              /* ;Internal */
#define SBSP_RELATIVE	 0x1000                                              /* ;Internal */
#define SBSP_PARENT	 0x2000                                              /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// Values for id parameter of ISB::GetWindow/SendControlMsg members.         /* ;Internal */
//                                                                           /* ;Internal */
#define FCW_STATUS      0x0001                                               /* ;Internal */
#define FCW_TOOLBAR     0x0002                                               /* ;Internal */
#define FCW_TREE        0x0003	/* NOT_EVEN_IN_B_LIST */ /* ;Internal */
#define FCW_VIEW        0x0004	/* NOT_EVEN_IN_B_LIST */ /* ;Internal */
#define FCW_BROWSER     0x0005  /* NOT_EVEN_IN_B_LIST */ /* ;Internal */
#define FCW_TABS	0x0006	/* NOT_EVEN_IN_B_LIST */ /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// Values for uFlags paremeter of ISB::SetToolbarItems member.               /* ;Internal */
//                                                                           /* ;Internal */
#define FCT_MERGE       0x0001                                               /* ;Internal */
#define FCT_CONFIGABLE  0x0002                                               /* ;Internal */
#define FCT_ADDTOEND    0x0004                                               /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
DECLARE_INTERFACE_(IShellBrowser, IOleWindow)                                /* ;Internal */
{                                                                            /* ;Internal */
    // *** IUnknown methods ***                                              /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;     /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                   /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                   /* ;Internal */
                                                                             /* ;Internal */
    // *** IOleWindow methods ***                                            /* ;Internal */
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;                         /* ;Internal */
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;            /* ;Internal */
                                                                             /* ;Internal */
    // *** IShellBrowser methods *** (same as IOleInPlaceFrame)              /* ;Internal */
    STDMETHOD(InsertMenusSB) (THIS_ HMENU hmenuShared,                       /* ;Internal */
				LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;     /* ;Internal */
    STDMETHOD(SetMenuSB) (THIS_ HMENU hmenuShared, HOLEMENU holemenuReserved,/* ;Internal */
		HWND hwndActiveObject) PURE;                                 /* ;Internal */
    STDMETHOD(RemoveMenusSB) (THIS_ HMENU hmenuShared) PURE;                 /* ;Internal */
    STDMETHOD(SetStatusTextSB) (THIS_ LPCOLESTR lpszStatusText) PURE;        /* ;Internal */
    STDMETHOD(EnableModelessSB) (THIS_ BOOL fEnable) PURE;                   /* ;Internal */
    STDMETHOD(TranslateAcceleratorSB) (THIS_ LPMSG lpmsg, WORD wID) PURE;    /* ;Internal */
                                                                             /* ;Internal */
    // *** IShellBrowser methods ***                                         /* ;Internal */
    STDMETHOD(BrowseObject)(THIS_ LPCITEMIDLIST pidl, UINT wFlags) PURE;     /* ;Internal */
    STDMETHOD(GetViewStateStream)(THIS_ DWORD grfMode,                       /* ;Internal */
		LPSTREAM  *ppStrm) PURE;                                     /* ;Internal */
    STDMETHOD(GetControlWindow)(THIS_ UINT id, HWND * lphwnd) PURE;          /* ;Internal */
    STDMETHOD(SendControlMsg)(THIS_ UINT id, UINT uMsg, WPARAM wParam,       /* ;Internal */
		LPARAM lParam, LRESULT * pret) PURE;                         /* ;Internal */
    STDMETHOD(QueryActiveShellView)(THIS_ struct IShellView ** ppshv) PURE;  /* ;Internal */
    STDMETHOD(OnViewWindowActive)(THIS_ struct IShellView * ppshv) PURE;     /* ;Internal */
    STDMETHOD(SetToolbarItems)(THIS_ LPTBBUTTON lpButtons, UINT nButtons,    /* ;Internal */
		UINT uFlags) PURE;                                           /* ;Internal */
};                                                                           /* ;Internal */
                                                                             /* ;Internal */
typedef IShellBrowser * LPSHELLBROWSER;                                      /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//-------------------------------------------------------------------------  /* ;Internal */
// ICommDlgBrowser interface                                                 /* ;Internal */
//                                                                           /* ;Internal */
//  ICommDlgBrowser interface is the interface that is provided by the new   /* ;Internal */
// common dialog window to hook and modify the behavior of IShellView.  When /* ;Internal */
// a default view is created, it queries its parent IShellBrowser for the    /* ;Internal */
// ICommDlgBrowser interface.  If supported, it calls out to that interface  /* ;Internal */
// in several cases that need to behave differently in a dialog.             /* ;Internal */
//                                                                           /* ;Internal */
// Member functions:                                                         /* ;Internal */
//                                                                           /* ;Internal */
//  ICommDlgBrowser::OnDefaultCommand()                                      /* ;Internal */
//    Called when the user double-clicks in the view or presses Enter.  The  /* ;Internal */
//   browser should return S_OK if it processed the action itself, S_FALSE   /* ;Internal */
//   to let the view perform the default action.                             /* ;Internal */
//                                                                           /* ;Internal */
//  ICommDlgBrowser::OnStateChange(ULONG uChange)                            /* ;Internal */
//    Called when some states in the view change.  'uChange' is one of the   /* ;Internal */
//   CDBOSC_* values.  This call is made after the state (selection, focus,  /* ;Internal */
//   etc) has changed.  There is no return value.                            /* ;Internal */
//                                                                           /* ;Internal */
//  ICommDlgBrowser::IncludeObject(LPCITEMIDLIST pidl)                       /* ;Internal */
//    Called when the view is enumerating objects.  'pidl' is a relative     /* ;Internal */
//   IDLIST.  The browser should return S_OK to include the object in the    /* ;Internal */
//   view, S_FALSE to hide it                                                /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------  /* ;Internal */
                                                                             /* ;Internal */
#undef  INTERFACE                                                            /* ;Internal */
#define INTERFACE   ICommDlgBrowser                                          /* ;Internal */
                                                                             /* ;Internal */
#define CDBOSC_SETFOCUS     0x00000000                                       /* ;Internal */
#define CDBOSC_KILLFOCUS    0x00000001                                       /* ;Internal */
#define CDBOSC_SELCHANGE    0x00000002                                       /* ;Internal */
#define CDBOSC_RENAME       0x00000003                                       /* ;Internal */
                                                                             /* ;Internal */
DECLARE_INTERFACE_(ICommDlgBrowser, IUnknown)                                /* ;Internal */
{                                                                            /* ;Internal */
    // *** IUnknown methods ***                                              /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;     /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                   /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                   /* ;Internal */
                                                                             /* ;Internal */
    // *** ICommDlgBrowser methods ***                                       /* ;Internal */
    STDMETHOD(OnDefaultCommand) (THIS_ struct IShellView * ppshv) PURE;      /* ;Internal */
    STDMETHOD(OnStateChange) (THIS_ struct IShellView * ppshv,               /* ;Internal */
		ULONG uChange) PURE;                                         /* ;Internal */
    STDMETHOD(IncludeObject) (THIS_ struct IShellView * ppshv,               /* ;Internal */
		LPCITEMIDLIST pidl) PURE;                                    /* ;Internal */
};                                                                           /* ;Internal */
                                                                             /* ;Internal */
typedef ICommDlgBrowser * LPCOMMDLGBROWSER;                                  /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//========================================================================== /* ;Internal */
//                                                                           /* ;Internal */
// Interface:   IShellView                                                   /* ;Internal */
//                                                                           /* ;Internal */
// History:					/* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//  01-07-93 GeorgeP     Created.               /* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//                                              /* NOT_EVEN_IN_B_LIST */     /* ;Internal */
//                                                                           /* ;Internal */
// [members]                                                                 /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::GetWindow(phwnd)                                              /* ;Internal */
//                                                                           /* ;Internal */
//   Inherited from IOleWindow::GetWindow.                                   /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::ContextSensitiveHelp(fEnterMode)                              /* ;Internal */
//                                                                           /* ;Internal */
//   Inherited from IOleWindow::ContextSensitiveHelp.                        /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::TranslateAccelerator(lpmsg)                                   /* ;Internal */
//                                                                           /* ;Internal */
//   Similar to IOleInPlaceActiveObject::TranlateAccelerator. The explorer   /* ;Internal */
//  calls this function BEFORE any other translation. Returning S_OK         /* ;Internal */
//  indicates that the message was translated (eaten) and should not be      /* ;Internal */
//  translated or dispatched by the explorer.                                /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::EnableModeless(fEnable)                                       /* ;Internal */
//   Similar to IOleInPlaceActiveObject::EnableModeless.                     /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::UIActivate(uState)                                            /* ;Internal */
//                                                                           /* ;Internal */
//   The explorer calls this member function whenever the activation         /* ;Internal */
//  state of the view window is changed by a certain event that is           /* ;Internal */
//  NOT caused by the shell view itself.                                     /* ;Internal */
//                                                                           /* ;Internal */
//   SVUIA_DEACTIVATE will be passed when the explorer is about to           /* ;Internal */
//  destroy the shell view window; the shell view is supposed to remove      /* ;Internal */
//  all the extended UIs (typically merged menu and modeless popup windows). /* ;Internal */
//                                                                           /* ;Internal */
//   SVUIA_ACTIVATE_NOFOCUS will be passsed when the shell view is losing    /* ;Internal */
//  the input focus or the shell view has been just created without the      /* ;Internal */
//  input focus; the shell view is supposed to set menuitems appropriate     /* ;Internal */
//  for non-focused state (no selection specific items should be added).     /* ;Internal */
//                                                                           /* ;Internal */
//   SVUIA_ACTIVATE_FOCUS will be passed when the explorer has just          /* ;Internal */
//  created the view window with the input focus; the shell view is          /* ;Internal */
//  supposed to set menuitems appropriate for focused state.                 /* ;Internal */
//                                                                           /* ;Internal */
//   The shell view should not change focus within this member function.     /* ;Internal */
//  The shell view should not hook the WM_KILLFOCUS message to remerge       /* ;Internal */
//  menuitems. However, the shell view typically hook the WM_SETFOCUS        /* ;Internal */
//  message, and re-merge the menu after calling IShellBrowser::             /* ;Internal */
//  OnViewWindowActivated.                                                   /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::Refresh()                                                     /* ;Internal */
//                                                                           /* ;Internal */
//   The explorer calls this member when the view needs to refresh its       /* ;Internal */
//  contents (such as when the user hits F5 key).                            /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::CreateViewWindow                                              /* ;Internal */
//                                                                           /* ;Internal */
//   This member creates the view window (right-pane of the explorer or the  /* ;Internal */
//  client window of the folder window).                                     /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::DestroyViewWindow                                             /* ;Internal */
//                                                                           /* ;Internal */
//   This member destroys the view window.                                   /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::GetCurrentInfo                                                /* ;Internal */
//                                                                           /* ;Internal */
//   This member returns the folder settings.                                /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::AddPropertySHeetPages                                         /* ;Internal */
//                                                                           /* ;Internal */
//   The explorer calls this member when it is opening the option property   /* ;Internal */
//  sheet. This allows the view to add additional pages to it.               /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::SaveViewState()                                               /* ;Internal */
//                                                                           /* ;Internal */
//   The explorer calls this member when the shell view is supposed to       /* ;Internal */
//  store its view settings. The shell view is supposed to get a view        /* ;Internal */
//  stream by calling IShellBrowser::GetViewStateStream and store the        /* ;Internal */
//  current view state into that stream.                                     /* ;Internal */
//                                                                           /* ;Internal */
//                                                                           /* ;Internal */
// IShellView::SelectItem(pidlItem, uFlags)                                  /* ;Internal */
//                                                                           /* ;Internal */
//   The explorer calls this member to change the selection state of         /* ;Internal */
//  item(s) within the shell view window.  If pidlItem is NULL and uFlags    /* ;Internal */
//  is SVSI_DESELECTOTHERS, all items should be deselected.                  /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------  /* ;Internal */
                                                                             /* ;Internal */
#undef  INTERFACE                                                            /* ;Internal */
#define INTERFACE   IShellView                                               /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// shellview select item flags                                               /* ;Internal */
//                                                                           /* ;Internal */
#define SVSI_DESELECT   0x0000                                               /* ;Internal */
#define SVSI_SELECT     0x0001                                               /* ;Internal */
#define SVSI_EDIT       0x0003  // includes select                           /* ;Internal */
#define SVSI_DESELECTOTHERS 0x0004                                           /* ;Internal */
#define SVSI_ENSUREVISIBLE  0x0008                                           /* ;Internal */
#define SVSI_FOCUSED        0x0010                                           /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// shellview get item object flags                                           /* ;Internal */
//                                                                           /* ;Internal */
#define SVGIO_BACKGROUND    0x00000000                                       /* ;Internal */
#define SVGIO_SELECTION     0x00000001                                       /* ;Internal */
#define SVGIO_ALLVIEW       0x00000002                                       /* ;Internal */
                                                                             /* ;Internal */
//                                                                           /* ;Internal */
// uState values for IShellView::UIActivate                                  /* ;Internal */
//                                                                           /* ;Internal */
typedef enum {                                                               /* ;Internal */
    SVUIA_DEACTIVATE       = 0,                                              /* ;Internal */
    SVUIA_ACTIVATE_NOFOCUS = 1,                                              /* ;Internal */
    SVUIA_ACTIVATE_FOCUS   = 2                                               /* ;Internal */
} SVUIA_STATUS;                                                              /* ;Internal */
                                                                             /* ;Internal */
DECLARE_INTERFACE_(IShellView, IOleWindow)                                   /* ;Internal */
{                                                                            /* ;Internal */
    // *** IUnknown methods ***                                              /* ;Internal */
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;     /* ;Internal */
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;                                   /* ;Internal */
    STDMETHOD_(ULONG,Release) (THIS) PURE;                                   /* ;Internal */
                                                                             /* ;Internal */
    // *** IOleWindow methods ***                                            /* ;Internal */
    STDMETHOD(GetWindow) (THIS_ HWND * lphwnd) PURE;                         /* ;Internal */
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;            /* ;Internal */
                                                                             /* ;Internal */
    // *** IShellView methods ***                                            /* ;Internal */
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;                /* ;Internal */
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;                     /* ;Internal */
    STDMETHOD(UIActivate) (THIS_ UINT uState) PURE;                          /* ;Internal */
    STDMETHOD(Refresh) (THIS) PURE;                                          /* ;Internal */
                                                                             /* ;Internal */
    STDMETHOD(CreateViewWindow)(THIS_ IShellView  *lpPrevView,               /* ;Internal */
		    LPCFOLDERSETTINGS lpfs, IShellBrowser  * psb,            /* ;Internal */
		    RECT * prcView, HWND  *phWnd) PURE;                      /* ;Internal */
    STDMETHOD(DestroyViewWindow)(THIS) PURE;                                 /* ;Internal */
    STDMETHOD(GetCurrentInfo)(THIS_ LPFOLDERSETTINGS lpfs) PURE;             /* ;Internal */
    STDMETHOD(AddPropertySheetPages)(THIS_ DWORD dwReserved,                 /* ;Internal */
                    LPFNADDPROPSHEETPAGE lpfn, LPARAM lparam) PURE;          /* ;Internal */
    STDMETHOD(SaveViewState)(THIS) PURE;                                     /* ;Internal */
    STDMETHOD(SelectItem)(THIS_ LPCITEMIDLIST pidlItem, UINT uFlags) PURE;   /* ;Internal */
    STDMETHOD(GetItemObject)(THIS_ UINT uItem, REFIID riid,                  /* ;Internal */
		    LPVOID *ppv) PURE;                                       /* ;Internal */
};                                                                           /* ;Internal */
                                                                             /* ;Internal */
typedef IShellView *	LPSHELLVIEW;					     /* ;Internal */	
                                                                             /* ;Internal */
/* END_B_LIST_API */ /* ;Internal */

//-------------------------------------------------------------------------
//
// struct STRRET
//
// structure for returning strings from IShellFolder member functions
//
//-------------------------------------------------------------------------
#define STRRET_OLESTR	0x0000			/* ;Internal */
#define STRRET_WSTR	0x0000
#define STRRET_OFFSET	0x0001
#define STRRET_CSTR	0x0002

typedef struct _STRRET
{
    UINT uType;	// One of the STRRET_* values
    union
    {
        LPWSTR          pOleStr;        // OLESTR that will be freed
        UINT            uOffset;        // Offset into SHITEMID (ANSI)
        char            cStr[MAX_PATH]; // Buffer to fill in
    } DUMMYUNIONNAME;
} STRRET, *LPSTRRET;


//-------------------------------------------------------------------------
//
// SHGetPathFromIDList
//
//  This function assumes the size of the buffer (MAX_PATH). The pidl
// should point to a file system object.
//
//-------------------------------------------------------------------------

WINSHELLAPI BOOL WINAPI SHGetPathFromIDList(LPCITEMIDLIST pidl, LPSTR pszPath);


//-------------------------------------------------------------------------
//
// SHGetSpecialFolderLocation
//
//  Caller should call SHFree to free the returned pidl.
//
//-------------------------------------------------------------------------
//
// registry entries for special paths are kept in :
#define REGSTR_PATH_SPECIAL_FOLDERS    REGSTR_PATH_EXPLORER "\\Shell Folders"


#define CSIDL_DESKTOP            0x0000
#define CSIDL_PROGRAMS           0x0002
#define CSIDL_CONTROLS           0x0003
#define CSIDL_PRINTERS           0x0004
#define CSIDL_PERSONAL           0x0005
#define CSIDL_STARTUP            0x0007
#define CSIDL_RECENT             0x0008
#define CSIDL_SENDTO             0x0009
#define CSIDL_BITBUCKET          0x000a
#define CSIDL_STARTMENU          0x000b
#define CSIDL_DESKTOPDIRECTORY   0x0010
#define CSIDL_DRIVES             0x0011		
#define CSIDL_NETWORK            0x0012
#define CSIDL_NETHOOD            0x0013
#define CSIDL_FONTS		 0x0014
#define CSIDL_TEMPLATES          0x0015
#define CSIDL_UNKNOWN            0xfffe		/* ;Internal */
#define CSIDL_STANDARD           0xffff         /* ;Internal */

WINSHELLAPI HRESULT WINAPI SHGetSpecialFolderLocation(HWND hwndOwner, int nFolder, LPITEMIDLIST * ppidl);

//-------------------------------------------------------------------------
// old API get rid of it.
//-------------------------------------------------------------------------
WINSHELLAPI HICON WINAPI SHGetFileIcon(HINSTANCE hinst, LPCSTR pszPath, DWORD dwFileAttribute, UINT uFlags);

//-------------------------------------------------------------------------
//
// SHBrowseForFolder API
//
//-------------------------------------------------------------------------

typedef int (CALLBACK* BFFCALLBACK)(HWND hwnd, UINT uMsg, LPARAM lParam, LPARAM lpData);

typedef struct _browseinfo {
    HWND        hwndOwner;
    LPCITEMIDLIST pidlRoot;
    LPSTR        pszDisplayName;// Return display name of item selected.
    // lpszTitle can be a resource, but the hinst is assumed to be shell32.dll /* ;Internal */
    LPCSTR       lpszTitle;      // text to go in the banner over the tree.
    UINT         ulFlags;       // Flags that control the return stuff
    BFFCALLBACK  lpfn;
    LPARAM      lParam;         // extra info that's passed back in callbacks

    int          iImage;      // output var: where to return the Image index.
} BROWSEINFO, *PBROWSEINFO, *LPBROWSEINFO;

// Browsing for directory.
#define BIF_RETURNONLYFSDIRS   0x0001  // For finding a folder to start document searching
#define BIF_DONTGOBELOWDOMAIN  0x0002  // For starting the Find Computer
#define BIF_STATUSTEXT         0x0004
#define BIF_RETURNFSANCESTORS  0x0008

#define BIF_BROWSEFORCOMPUTER  0x1000  // Browsing for Computers.
#define BIF_BROWSEFORPRINTER   0x2000  // Browsing for Printers

// message from browse
#define BFFM_INITIALIZED        1
#define BFFM_SELCHANGED         2

// messages to browse
#define BFFM_SETSTATUSTEXT      (WM_USER + 100)
#define BFFM_ENABLEOK           (WM_USER + 101)


WINSHELLAPI LPITEMIDLIST WINAPI SHBrowseForFolder(LPBROWSEINFO lpbi);

//-------------------------------------------------------------------------
//
// SHLoadInProc
//
//   When this function is called, the shell calls CoCreateInstance
//  (or equivalent) with CLSCTX_INPROC_SERVER and the specified CLSID
//  from within the shell's process and release it immediately.
//
//-------------------------------------------------------------------------

WINSHELLAPI HRESULT WINAPI SHLoadInProc(REFCLSID rclsid);


//-------------------------------------------------------------------------
//
// IEnumIDList interface
//
//  IShellFolder::EnumObjects member returns an IEnumIDList object.
//
//-------------------------------------------------------------------------

typedef struct IEnumIDList	*LPENUMIDLIST;

#undef 	INTERFACE
#define	INTERFACE 	IEnumIDList

DECLARE_INTERFACE_(IEnumIDList, IUnknown)
{						
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumIDList methods ***
    STDMETHOD(Next)  (THIS_ ULONG celt,
		      LPITEMIDLIST *rgelt,
		      ULONG *pceltFetched) PURE;
    STDMETHOD(Skip)  (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumIDList **ppenum) PURE;
};


//-------------------------------------------------------------------------
//
// IShellFolder interface
//
//
// [Member functions]
//
// IShellFolder::BindToObject(pidl, pbc, riid, ppvOut)
//   This function returns an instance of a sub-folder which is specified
//  by the IDList (pidl).
//
// IShellFolder::BindToStorage(pidl, pbc, riid, ppvObj)
//   This function returns a storage instance of a sub-folder which is
//  specified by the IDList (pidl). The shell never calls this member
//  function in the first release of Chicago.
//
// IShellFolder::CompareIDs(lParam, pidl1, pidl2)
//   This function compares two IDLists and returns the result. The shell
//  explorer always passes 0 as lParam, which indicates "sort by name".
//  It should return 0 (as CODE of the scode), if two id indicates the
//  same object; negative value if pidl1 should be placed before pidl2;
//  positive value if pidl2 should be placed before pidl1.
//
// IShellFolder::CreateViewObject(hwndOwner, riid, ppvOut)
//   This function creates a view object of the folder itself. The view
//  object is a difference instance from the shell folder object.
//   This function creates a view object. The shell browser always passes /* ;Internal */
//  IID_IShellView as riid. "hwndOwner" can be used  as the owner         /* ;Internal */
//  window of its dialog box or menu during the lifetime                  /* ;Internal */
//  of the view object. This member function should always create a new   /* ;Internal */
//  instance which has only one reference count. The explorer may create  /* ;Internal */
//  more than one instances of view object from one shell folder object   /* ;Internal */
//  and treat them as separate instances.                                 /* ;Internal */
//
// IShellFolder::GetAttributesOf(cidl, apidl, prgfInOut)
//   This function returns the attributes of specified objects in that
//  folder. "cidl" and "apidl" specifies objects. "apidl" contains only
//  simple IDLists. The explorer initializes *prgfInOut with a set of
//  flags to be evaluated. The shell folder may optimize the operation
//  by not returning unspecified flags.
//
// IShellFolder::GetUIObjectOf(hwndOwner, cidl, apidl, riid, prgfInOut, ppvOut)
//   This function creates a UI object to be used for specified objects.
//  The shell explorer passes either IID_IDataObject (for transfer operation)
//  or IID_IContextMenu (for context menu operation) as riid.
//
// IShellFolder::GetDisplayNameOf
//   This function returns the display name of the specified object.
//  If the ID contains the display name (in the locale character set),
//  it returns the offset to the name. Otherwise, it returns a pointer
//  to the display name string (UNICODE), which is allocated by the
//  task allocator, or fills in a buffer.
//
// IShellFolder::SetNameOf
//   This function sets the display name of the specified object.
//  If it changes the ID as well, it returns the new ID which is
//  alocated by the task allocator.
//
//-------------------------------------------------------------------------

#undef 	INTERFACE
#define	INTERFACE 	IShellFolder

// IShellFolder::GetDisplayNameOf/SetNameOf uFlags
typedef enum tagSHGDN
{
    SHGDN_NORMAL	    = 0,	// default (display purpose)
    SHGDN_INFOLDER          = 1,        // displayed under a folder (relative)
    //$ MAIL: Removed this because it generates warnings and we don't use it
    //$ MAIL: SHGDN_FORPARSING	    = 0x8000,   // for ParseDisplayName or path
} SHGNO;

// IShellFolder::EnumObjects
typedef enum tagSHCONTF
{
    SHCONTF_FOLDERS         = 32,	// for shell browser
    SHCONTF_NONFOLDERS      = 64,	// for default view
    SHCONTF_INCLUDEHIDDEN   = 128,	// for hidden/system objects
    SHCONTF_RECENTDOCSDIR   = 256,      // validate with recent docs mru ;Internal
    SHCONTF_NETPRINTERSRCH  = 512,      // Hint to enum network that we are looking for printers ;Internal
} SHCONTF;

// IShellFolder::GetAttributesOf flags
#define SFGAO_CANCOPY           DROPEFFECT_COPY // Objects can be copied
#define SFGAO_CANMOVE           DROPEFFECT_MOVE // Objects can be moved
#define SFGAO_CANLINK           DROPEFFECT_LINK // Objects can be linked
#define SFGAO_CANRENAME         0x00000010L     // Objects can be renamed
#define SFGAO_CANDELETE         0x00000020L     // Objects can be deleted
#define SFGAO_HASPROPSHEET      0x00000040L     // Objects have property sheets
#define SFGAO_DROPTARGET	0x00000100L	// Objects are drop target
#define SFGAO_CAPABILITYMASK    0x00000177L
#define SFGAO_LINK              0x00010000L     // Shortcut (link)
#define SFGAO_SHARE             0x00020000L     // shared
#define SFGAO_READONLY          0x00040000L     // read-only
#define SFGAO_GHOSTED           0x00080000L     // ghosted icon
#define SFGAO_DISPLAYATTRMASK   0x000F0000L
#define SFGAO_FILESYSANCESTOR   0x10000000L     // It contains file system folder
#define SFGAO_FOLDER            0x20000000L     // It's a folder.
#define SFGAO_FILESYSTEM        0x40000000L     // is a file system thing (file/folder/root)
#define SFGAO_HASSUBFOLDER      0x80000000L     // Expandable in the map pane
#define SFGAO_CONTENTSMASK      0x80000000L
#define SFGAO_VALIDATE          0x01000000L     // invalidate cached information
#define SFGAO_REMOVABLE        0x02000000L     // is this removeable media?

DECLARE_INTERFACE_(IShellFolder, IUnknown)
{						
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IShellFolder methods ***
    STDMETHOD(ParseDisplayName) (THIS_ HWND hwndOwner,
	LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;

    STDMETHOD(EnumObjects) ( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList) PURE;

    STDMETHOD(BindToObject)     (THIS_ LPCITEMIDLIST pidl, LPBC pbcReserved,
				 REFIID riid, LPVOID * ppvOut) PURE;
    STDMETHOD(BindToStorage)    (THIS_ LPCITEMIDLIST pidl, LPBC pbcReserved,
				 REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD(CompareIDs)       (THIS_ LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject) (THIS_ HWND hwndOwner, REFIID riid, LPVOID * ppvOut) PURE;
    STDMETHOD(GetAttributesOf)  (THIS_ UINT cidl, LPCITEMIDLIST * apidl,
				    ULONG * rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)    (THIS_ HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
    			         REFIID riid, UINT * prgfInOut, LPVOID * ppvOut) PURE;
    STDMETHOD(GetDisplayNameOf) (THIS_ LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)        (THIS_ HWND hwndOwner, LPCITEMIDLIST pidl,
				 LPCOLESTR lpszName, DWORD uFlags,
				 LPITEMIDLIST * ppidlOut) PURE;
};

typedef IShellFolder * LPSHELLFOLDER;

//
//  Helper function which returns a IShellFolder interface to the desktop
// folder. This is equivalent to call CoCreateInstance with CLSID_ShellDesktop.
//
//  CoCreateInstance(CLSID_Desktop, NULL,
//                   CLSCTX_INPROC, IID_IShellFolder, &pshf);
//
WINSHELLAPI HRESULT WINAPI SHGetDesktopFolder(LPSHELLFOLDER *ppshf);


//-------------------------------------------------------------------------  /* ;Internal */
// This is the interface for a browser to "subclass" the main File Cabinet   /* ;Internal */
// window.  Note that only the hwnd, message, wParam, and lParam fields of   /* ;Internal */
// the msg structure are used.  The browser window will get a WM_NOTIFY      /* ;Internal */
// message with NULL ID, FCN_MESSAGE as the code, and a far pointer to       /* ;Internal */
// FCMSG_NOTIFY as the lParam.                                               /* ;Internal */
//                                                                           /* ;Internal */
//-------------------------------------------------------------------------  /* ;Internal */
typedef struct tagFCMSG_NOTIFY						     /* ;Internal */
{                                                                            /* ;Internal */
        NMHDR   hdr;                                                         /* ;Internal */
        MSG     msg;							     /* ;Internal */
        LRESULT lResult;                                                     /* ;Internal */
} FCMSG_NOTIFY;                                                              /* ;Internal */	
                                                                             /* ;Internal */
#define FCN_MESSAGE     (100)                                                /* ;Internal */
                                                                             /* ;Internal */
                                                                             /* ;Internal */
//---------------------------------------------------------------------------/* ;Internal */
// messages that can be send to the cabinet by other apps                    /* ;Internal */
//                                                                           /* ;Internal */
// REVIEW: Do we really need to publish any of those?       /* ;Internal */  /* ;Internal */
//---------------------------------------------------------------------------/* ;Internal */
                                                                             /* ;Internal */
#define NF_INHERITVIEW  0x0000                                               /* ;Internal */
#define NF_LOCALVIEW    0x0001                                               /* ;Internal */
                                                                             /* ;Internal */
// Change the path of an existing folder.                                    /* ;Internal */
// wParam:                                                                   /* ;Internal */
//	0:		LPARAM is a string, handle the message immediately.  /* ;Internal */
//	CSP_HANDLE:	LPARAM is a handle. handle the message immediatelt   /* ;Internal */
//			and then free the handle.                            /* ;Internal */
//	CSP_REPOST:	LPARAM is a string, copy the string and handle the   /* ;Internal */
// 			message later.                                       /* ;Internal */
// 	CSP_REPOST|CSP_HANDLE:                                               /* ;Internal */
//			LPARAM is a handle, just handle the message later    /* ;Internal */
//			and free the handle then.                            /* ;Internal */
// lParam: LPSTR or HANDLE of path.                                          /* ;Internal */
//                                                                           /* ;Internal */
#define CSP_REPOST	0x0001                                               /* ;Internal */
#define CSP_HANDLE	0x0002                                               /* ;Internal */
#define CWM_SETPATH             (WM_USER + 2)                                /* ;Internal */
                                                                             /* ;Internal */
// lpsv points to the Shell View extension that requested idle processing    /* ;Internal */
// uID is an app define identifier for the processor                         /* ;Internal */
// returns: TRUE if there is more idle processing necessary, FALSE if all done /* ;Internal */
// Note that the idle processor should do one "atomic" operation and return  /* ;Internal */
// as soon as possible.                                                      /* ;Internal */
typedef BOOL (CALLBACK *FCIDLEPROC)(void  *lpsv, UINT uID);                  /* ;Internal */
                                                                             /* ;Internal */
// Inform the File Cabinet that you want idle messages.                      /* ;Internal */
// This should ONLY be used by File Cabinet extensions.                      /* ;Internal */
// wParam: app define UINT (passed to FCIDLEPROC).                           /* ;Internal */
// lParam: pointer to an FCIDLEPROC.                                         /* ;Internal */
// return: TRUE if successful; FALSE otherwise                               /* ;Internal */
//                                                                           /* ;Internal */
#define CWM_WANTIDLE            (WM_USER + 3)                                /* ;Internal */
                                                                             /* ;Internal */
// get or set the FOLDERSETTINGS for a view                                  /* ;Internal */
// wParam: BOOL TRUE -> set to view info buffer, FALSE -> get view info buffer/* ;Internal */
// lParam: LPFOLDERSETTINGS buffer to get or set view info                   /* ;Internal */
//                                                                           /* ;Internal */
#define CWM_GETSETCURRENTINFO	(WM_USER + 4)                                /* ;Internal */
#define FileCabinet_GetSetCurrentInfo(_hwnd, _bSet, _lpfs)                  /* ;Internal */ \
	SendMessage(_hwnd, CWM_GETSETCURRENTINFO, (WPARAM)(_bSet),          /* ;Internal */ \
	(LPARAM)(LPFOLDERSETTINGS)_lpfs)                                     /* ;Internal */
                                                                             /* ;Internal */
// selects the specified item in the current view                            /* ;Internal */
// wParam: SVSI_* flags                                                      /* ;Internal */
// lParam: LPCITEMIDLIST of the item ID, NULL -> all items                   /* ;Internal */
//                                                                           /* ;Internal */
#define CWM_SELECTITEM          (WM_USER + 5)                                /* ;Internal */
#define FileCabinet_SelectItem(_hwnd, _sel, _item)                          /* ;Internal */ \
    SendMessage(_hwnd, CWM_SELECTITEM, _sel, (LPARAM)(LPCITEMIDLIST)(_item)) /* ;Internal */
                                                                             /* ;Internal */
// selects the specified path in the current view                            /* ;Internal */
// wParam: SVSI_* flags                                                      /* ;Internal */
// lParam: LPCSTR of the display name                                        /* ;Internal */
//                                                                           /* ;Internal */
#define CWM_SELECTPATH          (WM_USER + 6)                                /* ;Internal */
#define FileCabinet_SelectPath(_hwnd, _sel, _path)                          /* ;Internal */ \
	SendMessage(_hwnd, CWM_SELECTPATH, _sel, (LPARAM)(LPCSTR)(_path))    /* ;Internal */
                                                                             /* ;Internal */
// Get the IShellBrowser object associated with an hwndMain                  /* ;Internal */
#define CWM_GETISHELLBROWSER	(WM_USER + 7)                                /* ;Internal */
#define FileCabinet_GetIShellBrowser(_hwnd)                                 /* ;Internal */ \
	(IShellBrowser  *)SendMessage(_hwnd, CWM_GETISHELLBROWSER, 0, 0L)    /* ;Internal */
                                                                             /* ;Internal */
// Onetree notification.                        ;Internal                    /* ;Internal */
// since onetree is internal to cabinet, we can no longer use WM_NOTIFY   ;Internal
// codes.                                       ;Internal
// so we need to reserve a WM_ id nere.         ;Internal
#define CWM_ONETREEFSE          (WM_USER + 8)   /* ;Internal */
//                                                                      ;Internal
//  two pidls can have the same path, so we need a compare pidl message    ;Internal
#define CWM_COMPAREPIDL         (WM_USER + 9)     /* ;Internal */
//                                                /* ;Internal */
//  sent when the global state changes            /* ;Internal */
#define CWM_GLOBALSTATECHANGE   (WM_USER + 10)    /* ;Internal */
//                                                /* ;Internal */
//  sent to the desktop from a second instance    /* ;Internal */
#define CWM_COMMANDLINE         (WM_USER + 11)    /* ;Internal */
// global clone your current pidl			/* ;Internal */
#define CWM_CLONEPIDL           (WM_USER + 12)     /* ;Internal */
// See if the root of the instance is as specified	/* ;Internal */
#define CWM_COMPAREROOT         (WM_USER + 13)		/* ;Internal */
							/* ;Internal */
#define CWM_RESERVEDFORCOMDLG_FIRST	(WM_USER + 100)	/* ;Internal */
#define CWM_RESERVEDFORCOMDLG_LAST	(WM_USER + 200)	/* ;Internal */


//==========================================================================
// Clipboard format which may be supported by IDataObject from system
// defined shell folders (such as directories, network, ...).
//==========================================================================

#define CFSTR_SHELLIDLISTP      "Shell IDLData Private" /* ;Internal */
#define CFSTR_SHELLIDLIST       "Shell IDList Array"	// CF_IDLIST
#define CFSTR_SHELLIDLISTOFFSET "Shell Object Offsets"	// CF_OBJECTPOSITIONS
#define CFSTR_NETRESOURCES      "Net Resource"		// CF_NETRESOURCE
#define CFSTR_FILEDESCRIPTOR 	"FileGroupDescriptor"	// CF_FILEGROUPDESCRIPTOR
#define CFSTR_FILECONTENTS 	"FileContents"		// CF_FILECONTENTS
#define CFSTR_FILENAME	   	"FileName"		// CF_FILENAME
#define CFSTR_PRINTERGROUP	"PrinterFriendlyName"   // CF_PRINTERS
#define CFSTR_FILENAMEMAP	"FileNameMap"		// CF_FILENAMEMAP

//
// CF_OBJECTPOSITIONS
//
//



#define DVASPECT_SHORTNAME	2 // use for CF_HDROP to get short name version
//
// format of CF_NETRESOURCE
//
typedef struct _NRESARRAY {	// anr
    UINT cItems;
    NETRESOURCE	nr[1];
} NRESARRAY, * LPNRESARRAY;

//
// format of CF_IDLIST
//
typedef struct _IDA {
    UINT cidl;		// number of relative IDList
    UINT aoffset[1];	// [0]: folder IDList, [1]-[cidl]: item IDList
} CIDA, * LPIDA;

//
// FILEDESCRIPTOR.dwFlags field indicate which fields are to be used
//
typedef enum {
    FD_CLSID		= 0x0001,
    FD_SIZEPOINT	= 0x0002,
    FD_ATTRIBUTES       = 0x0004,
    FD_CREATETIME       = 0x0008,
    FD_ACCESSTIME       = 0x0010,
    FD_WRITESTIME       = 0x0020,
    FD_FILESIZE		= 0x0040,
} FD_FLAGS;

typedef struct _FILEDESCRIPTOR { // fod
    DWORD dwFlags;

    CLSID clsid;
    SIZEL sizel;
    POINTL pointl;

    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    CHAR   cFileName[ MAX_PATH ];
} FILEDESCRIPTOR, *LPFILEDESCRIPTOR;

//
// format of CF_FILEGROUPDESCRIPTOR
//
typedef struct _FILEGROUPDESCRIPTOR { // fgd
     UINT cItems;
     FILEDESCRIPTOR fgd[1];
} FILEGROUPDESCRIPTOR, * LPFILEGROUPDESCRIPTOR;

//
// format of CF_HDROP and CF_PRINTERS, in the HDROP case the data that follows
// is a double null terinated list of file names, for printers they are printer
// friendly names
//
typedef struct _DROPFILES {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point (client coords)
   BOOL fNC;                           // is it on NonClient area
				       // and pt is in screen coords
   BOOL fWide;                         // WIDE character switch
} DROPFILES, FAR * LPDROPFILES;

//									/* ;Internal */
// Win 3.1 style HDROP                                                  /* ;Internal */
//                                                                      /* ;Internal */
//  Notes: Our API works only if pFiles == sizeof(DROPFILES16)          /* ;Internal */
//                                                                      /* ;Internal */
typedef struct _DROPFILES16 {                                           /* ;Internal */
    WORD pFiles;                // offset to double null list of files  /* ;Internal */
    POINTS pt;                  // drop point (client coords)           /* ;Internal */
    WORD fNC;                   // is it on non client area             /* ;Internal */
    				// and pt is in screen coords           /* ;Internal */
} DROPFILES16, * LPDROPFILES16;						/* ;Internal */
                                                                        /* ;Internal */
//====== File System Notification APIs ===============================
//
//------ See shelldll\fsnotify.c for function descriptions. ---------- /* ;Internal */
                                                                        /* ;Internal */
//                                                                      /* ;Internal */
//  Definition of the function type to be called by the notification    /* ;Internal */
//  service when a file the client has registered to monitor changes.   /* ;Internal */
//                                                                      /* ;Internal */

typedef struct _SHChangeNotifyEntry                     /* ;Internal */
{                                                       /* ;Internal */
    LPCITEMIDLIST pidl;                                 /* ;Internal */
    BOOL   fRecursive;                                  /* ;Internal */
} SHChangeNotifyEntry;                                  /* ;Internal */


//
//  File System Notification flags
//

#define SHCNRF_InterruptLevel      0x0001                       /* ;Internal */
#define SHCNRF_ShellLevel          0x0002                       /* ;Internal */

#define SHCNE_RENAME	          0x00000001L   // GOING AWAY
#define SHCNE_RENAMEITEM          0x00000001L
#define SHCNE_CREATE	          0x00000002L
#define SHCNE_DELETE	          0x00000004L
#define SHCNE_MKDIR	          0x00000008L
#define SHCNE_RMDIR               0x00000010L
#define SHCNE_MEDIAINSERTED       0x00000020L
#define SHCNE_MEDIAREMOVED        0x00000040L
#define SHCNE_DRIVEREMOVED        0x00000080L
#define SHCNE_DRIVEADD            0x00000100L
#define SHCNE_NETSHARE            0x00000200L
#define SHCNE_NETUNSHARE          0x00000400L
#define SHCNE_ATTRIBUTES          0x00000800L
#define SHCNE_UPDATEDIR           0x00001000L
#define SHCNE_UPDATEITEM          0x00002000L
#define SHCNE_SERVERDISCONNECT    0x00004000L
#define SHCNE_UPDATEIMAGE         0x00008000L
#define SHCNE_DRIVEADDGUI         0x00010000L
#define SHCNE_RENAMEFOLDER        0x00020000L

#define SHCNE_ASSOCCHANGED        0x08000000L

#define SHCNE_DISKEVENTS          0x0002381FL
#define SHCNE_GLOBALEVENTS        0x0C0181E0L // Events that dont match pidls first
#define SHCNE_ALLEVENTS           0x7FFFFFFFL
#define SHCNE_INTERRUPT           0x80000000L // The presence of this flag indicates
                                            // that the event was generated by an
                                            // interrupt.  It is stripped out before
                                            // the clients of SHCNNotify_ see it.

// Update types for the UpdateEntryList api                              /* ;Internal */
#define SHCNNU_SET        1   // Set the notify list to passed in list   /* ;Internal */
#define SHCNNU_ADD        2   // Add the items to the current list       /* ;Internal */
#define SHCNNU_REMOVE     3   // Remove the items from the current list  /* ;Internal */

// Flags
// uFlags & SHCNF_TYPE is an ID which indicates what dwItem1 and dwItem2 mean
#define SHCNF_IDLIST      0x0000	// LPITEMIDLIST
#define SHCNF_PATH        0x0001	// path name
#define SHCNF_PRINTER     0x0002	// printer friendly name
#define SHCNF_DWORD       0x0003	// DWORD
#define SHCNF_PRINTJOB    0x0004	// dwItem1: printer name        /* ;Internal */
					// dwItem2: SHCNF_PRINTJOB_DATA /* ;Internal */
#define SHCNF_TYPE        0x00FF
#define SHCNF_FLUSH       0x1000
#define SHCNF_FLUSHNOWAIT 0x2000
#define SHCNF_NONOTIFYINTERNALS 0x4000 // means don't do shell notify internals.  see comments in code  /* ;Internal */

typedef struct tagSHCNF_PRINTJOB_DATA {					/* ;Internal */
    DWORD JobId;							/* ;Internal */
    DWORD Status;							/* ;Internal */
    DWORD TotalPages;							/* ;Internal */
    DWORD Size;								/* ;Internal */
    DWORD PagesPrinted;							/* ;Internal */
} SHCNF_PRINTJOB_DATA, FAR * LPSHCNF_PRINTJOB_DATA;			/* ;Internal */

//
//  APIs
//
WINSHELLAPI void WINAPI SHChangeNotify(LONG wEventId, UINT uFlags,
				LPCVOID dwItem1, LPCVOID dwItem2);

//
// SHAddToRecentDocs
//
#define SHARD_PIDL	0x00000001L
#define SHARD_PATH      0x00000002L

WINSHELLAPI void WINAPI SHAddToRecentDocs(UINT uFlags, LPCVOID pv);


/// THESE ARE INTERNAL ....  /* ;Internal */
#define SHChangeNotifyHandleEvents() SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL)        /* ;Internal */
WINSHELLAPI ULONG WINAPI SHChangeNotifyRegister(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne); /* ;Internal */
#define SHChangeNotifyRegisterORD 2                          /* ;Internal */
WINSHELLAPI BOOL  WINAPI SHChangeNotifyDeregister(unsigned long ulID);   /* ;Internal */
#define SHChangeNotifyDeregisterORD 4                        /* ;Internal */

WINSHELLAPI BOOL  WINAPI SHChangeNotifyUpdateEntryList(unsigned long ulID, int iUpdateType, int cEntries, SHChangeNotifyEntry *pshcne); /* ;Internal */

WINSHELLAPI HRESULT WINAPI SHGetInstanceExplorer(IUnknown **ppunk);


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif // _SHLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\trayp.h ===
#ifndef _TRAYP_INC
#define _TRAYP_INC

#define TM_WINDOWDESTROYED	(WM_USER+0x100)
#define TM_POSTEDRCLICK 	(WM_USER+0x101)
#define TM_CONTEXTMENU          (WM_USER+0x102)
#define TM_ACTASTASKSW          (WM_USER+0x104)
#define TM_SYSMENUCOUNT         (WM_USER+0x105)
#define TM_TASKTAB              (WM_USER+0x106)

#ifdef ABM_NEW

typedef struct _TRAYAPPBARDATA
{
    APPBARDATA abd;
    DWORD dwMessage;
    HANDLE hSharedRect;
    DWORD dwProcId;
} TRAYAPPBARDATA, *PTRAYAPPBARDATA;

#endif

#endif // _TRAYP_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\inc\debugstr.h ===
/*
 * debugstr.h - Debug message strings.
 */


#ifdef DEBUG

/* TWINRESULT strings */

/*
 * N.b., this array of strings must match the TWINRESULTs defined in synceng.h.
 * The index of the pointer to the string corresponding to a TWINRESULT tr may
 * be determined as rgcpcszTwinResult[tr].
 */

CONST LPCTSTR rgcpcszTwinResult[] =
{
   TEXT("TR_SUCCESS"),
   TEXT("TR_RH_LOAD_FAILED"),
   TEXT("TR_SRC_OPEN_FAILED"),
   TEXT("TR_SRC_READ_FAILED"),
   TEXT("TR_DEST_OPEN_FAILED"),
   TEXT("TR_DEST_WRITE_FAILED"),
   TEXT("TR_ABORT"),
   TEXT("TR_UNAVAILABLE_VOLUME"),
   TEXT("TR_OUT_OF_MEMORY"),
   TEXT("TR_FILE_CHANGED"),
   TEXT("TR_DUPLICATE_TWIN"),
   TEXT("TR_DELETED_TWIN"),
   TEXT("TR_HAS_FOLDER_TWIN_SRC"),
   TEXT("TR_INVALID_PARAMETER"),
   TEXT("TR_REENTERED"),
   TEXT("TR_SAME_FOLDER"),
   TEXT("TR_SUBTREE_CYCLE_FOUND"),
   TEXT("TR_NO_MERGE_HANDLER"),
   TEXT("TR_MERGE_INCOMPLETE"),
   TEXT("TR_TOO_DIFFERENT"),
   TEXT("TR_BRIEFCASE_LOCKED"),
   TEXT("TR_BRIEFCASE_OPEN_FAILED"),
   TEXT("TR_BRIEFCASE_READ_FAILED"),
   TEXT("TR_BRIEFCASE_WRITE_FAILED"),
   TEXT("TR_CORRUPT_BRIEFCASE"),
   TEXT("TR_NEWER_BRIEFCASE"),
   TEXT("TR_NO_MORE")
};

/* CREATERECLISTPROCMSG strings */

/*
 * N.b., this array of strings must match the CREATERECLISTPROCs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * CREATERECLISTPROCMSG crlpm may be determined as
 * rgcpcszCreateRecListMsg[crlpm].
 */

const LPCTSTR rgcpcszCreateRecListMsg[] =
{
   TEXT("CRLS_BEGIN_CREATE_REC_LIST"),
   TEXT("CRLS_DELTA_CREATE_REC_LIST"),
   TEXT("CRLS_END_CREATE_REC_LIST")
};

/* RECSTATUSPROCMSGs strings */

/*
 * N.b., this array of strings must match the RECSTATUSPROCMSGs defined in
 * synceng.h.  The index of the pointer to the string corresponding to a
 * RECSTATUSPROCMSG rspm may be determined as rgcpcszRecStatusMsg[rspm].
 */

CONST LPCTSTR rgcpcszRecStatusMsg[] =
{
   TEXT("RS_BEGIN_COPY"),
   TEXT("RS_DELTA_COPY"),
   TEXT("RS_END_COPY"),
   TEXT("RS_BEGIN_MERGE"),
   TEXT("RS_DELTA_MERGE"),
   TEXT("RS_END_MERGE"),
   TEXT("RS_BEGIN_DELETE"),
   TEXT("RS_DELTA_DELETE"),
   TEXT("RS_END_DELETE")
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\uastrfnc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       uastrfnc.h
//
//  Contents:   Unaligned UNICODE lstr functions for MIPS, PPC, ALPHA, ...
//
//  Classes:
//
//  Functions:
//
//  History:    1-11-95   davepl   Created
//
//--------------------------------------------------------------------------

// NOTE: This file assumes it is included from shellprv.h

#ifndef _UASTRFNC_H_
#define _UASTRFNC_H_

// If we are running on a platform that requires aligned data, we need
// to provide custom string functions that can deal with unaligned
// strings.  On other platforms, these call directly to the normal string
// functions.

#ifndef _X86_
#define ALIGNMENT_MACHINE
#endif

#ifdef ALIGNMENT_MACHINE

UNALIGNED WCHAR * ualstrcpynW(UNALIGNED WCHAR * lpString1,
    		  	      UNALIGNED const WCHAR * lpString2,
    			      int iMaxLength);

int 		  ualstrcmpiW (UNALIGNED const WCHAR * dst, 
			       UNALIGNED const WCHAR * src);

int 		  ualstrcmpW  (UNALIGNED const WCHAR * src, 
			       UNALIGNED const WCHAR * dst);

size_t 		  ualstrlenW  (UNALIGNED const WCHAR * wcs);

UNALIGNED WCHAR * ualstrcpyW  (UNALIGNED WCHAR * dst, 
			       UNALIGNED const WCHAR * src);

#else

#define ualstrcpynW lstrcpynW
#define ualstrcmpiW lstrcmpiW
#define ualstrcmpW  lstrcmpW
#define ualstrlenW  lstrlenW
#define ualstrcpyW  lstrcpyW

#endif // ALIGNMENT_MACHINE

#define ualstrcpynA lstrcpynA
#define ualstrcmpiA lstrcmpiA
#define ualstrcmpA  lstrcmpA
#define ualstrlenA  lstrlenA
#define ualstrcpyA  lstrcpyA

#ifdef UNICODE
#define ualstrcpyn ualstrcpynW
#define ualstrcmpi ualstrcmpiW
#define ualstrcmp  ualstrcmpW
#define ualstrlen  ualstrlenW
#define ualstrcpy  ualstrcpyW
#else
#define ualstrcpyn ualstrcpynA
#define ualstrcmpi ualstrcmpiA
#define ualstrcmp  ualstrcmpA
#define ualstrlen  ualstrlenA
#define ualstrcpy  ualstrcpyA
#endif


#endif // _UASTRFNC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\vdate.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: vdate.h - Debug argument validation helpers
//
// History:
//  06-16-94    Davepl  Created
//
//---------------------------------------------------------------------------

#ifdef DEBUG

__inline void FUNC_VDATEINPUTBUF(void * pBuffer,
                                 size_t cElementSize,
                                 size_t cCount,
                                 int    iLine,
                                 char * pszFile)
{
    if (IsBadWritePtr(pBuffer, cElementSize * cCount))
    {
        char sazOutput[MAX_PATH * 2];
        wsprintfA(sazOutput, "Buffer failed validation at line %d in %s\n", iLine, pszFile);
        OutputDebugStringA(sazOutput);
        DebugBreak();
    }
}

#define VDATEINPUTBUF(ptr, type, count) FUNC_VDATEINPUTBUF(ptr,                 \
                                                           sizeof(type),        \
                                                           count,               \
                                                           __LINE__,            \
                                                           __FILE__)

#else

#define VDATEINPUTBUF(ptr, type, const)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\inc\indirect.h ===
/*
 * indirect.h - Object synchronization engine API types for type-safe indirect
 *              calling.
 */


/*
 * N.b., these API types must match the function prototypes defined in
 * <synceng.h>.  An API function pointer variable may be declared and called in
 * a type-safe manner as an instance of one of the given types, e.g.,
 *
 * HINSTANCE hinstSyncEng;
 *
 * hinstSyncEng = LoadLibrary("synceng.dll");
 *
 * if (hinstSyncEng > HINSTANCE_ERROR)
 * {
 *    OPENBRIEFCASEINDIRECT OpenBriefcaseIndirect;
 *
 *    OpenBriefcaseIndirect = (OPENBRIEFCASEINDIRECT)GetProcAddress(hinstSyncEng, "OpenBriefcase");
 *
 *    if (OpenBriefcaseIndirect)
 *    {
 *       TWINRESULT tr;
 *       HBRFCASE hbr;
 *
 *       tr = (*OpenBriefcaseIndirect)("c:\\chicago\\desktop\\foo.bfc\\briefcase.bfc", OB_FL_TANSLATE_DB_FOLDER, &hbr);
 *    }
 * }
 */


/* Types
 ********/

/* briefcase interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *OPENBRIEFCASEINDIRECT)(LPCTSTR, DWORD, HWND, PHBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *SAVEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLOSEBRIEFCASEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETEBRIEFCASEINDIRECT)(LPCTSTR);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOPENBRIEFCASEINFOINDIRECT)(HBRFCASE, POPENBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *CLEARBRIEFCASECACHEINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDFIRSTBRIEFCASEINDIRECT)(PHBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDNEXTBRIEFCASEINDIRECT)(HBRFCASEITER, PBRFCASEINFO);
typedef SYNCENGAPI TWINRESULT (WINAPI *FINDBRIEFCASECLOSEINDIRECT)(HBRFCASEITER);

/* twin interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ADDOBJECTTWININDIRECT)(HBRFCASE, PCNEWOBJECTTWIN, PHTWINFAMILY);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDFOLDERTWININDIRECT)(HBRFCASE, PCNEWFOLDERTWIN, PHFOLDERTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *RELEASETWINHANDLEINDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *DELETETWININDIRECT)(HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETOBJECTTWINHANDLEINDIRECT)(HBRFCASE, LPCTSTR, LPCTSTR, PHOBJECTTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISFOLDERTWININDIRECT)(HBRFCASE, LPCTSTR, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *CREATEFOLDERTWINLISTINDIRECT)(HBRFCASE, LPCTSTR, PFOLDERTWINLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYFOLDERTWINLISTINDIRECT)(PFOLDERTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ISORPHANOBJECTTWININDIRECT)(HOBJECTTWIN, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *COUNTSOURCEFOLDERTWINSINDIRECT)(HOBJECTTWIN, PULONG);
typedef SYNCENGAPI TWINRESULT (WINAPI *ANYTWINSINDIRECT)(HBRFCASE, PBOOL);

/* twin list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATETWINLISTINDIRECT)(HBRFCASE, PHTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDTWINTOTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *ADDALLTWINSTOTWINLISTINDIRECT)(HTWINLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVETWINFROMTWINLISTINDIRECT)(HTWINLIST, HTWIN);
typedef SYNCENGAPI TWINRESULT (WINAPI *REMOVEALLTWINSFROMTWINLISTINDIRECT)(HTWINLIST);

/* reconciliation list interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *CREATERECLISTINDIRECT)(HTWINLIST, CREATERECLISTPROC, LPARAM, PRECLIST *);
typedef SYNCENGAPI TWINRESULT (WINAPI *DESTROYRECLISTINDIRECT)(PRECLIST);
typedef SYNCENGAPI TWINRESULT (WINAPI *RECONCILEITEMINDIRECT)(PCRECITEM, RECSTATUSPROC, LPARAM, DWORD, HWND, HWND);
typedef SYNCENGAPI TWINRESULT (WINAPI *BEGINRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *ENDRECONCILIATIONINDIRECT)(HBRFCASE);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETFOLDERTWINSTATUSINDIRECT)(HFOLDERTWIN, CREATERECLISTPROC, LPARAM, PFOLDERTWINSTATUS);

/* file stamp interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *GETFILESTAMPINDIRECT)(LPCTSTR, PFILESTAMP);
typedef SYNCENGAPI TWINRESULT (WINAPI *COMPAREFILESTAMPSINDIRECT)(PCFILESTAMP, PCFILESTAMP, PCOMPARISONRESULT);

/* volume ID interface */

typedef SYNCENGAPI TWINRESULT (WINAPI *ISPATHONVOLUMEINDIRECT)(LPCTSTR, HVOLUMEID, PBOOL);
typedef SYNCENGAPI TWINRESULT (WINAPI *GETVOLUMEDESCRIPTIONINDIRECT)(HVOLUMEID, PVOLUMEDESC);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\vmm.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1988-1990
 *
 *   Title: VMM.H - Include file for Virtual Machine Manager
 *
 *   Version:   1.00
 *
 *   Date:  05-May-1988
 *
 *   Author:    RAL
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 *   DATE    REV DESCRIPTION
 *   ----------- --- -----------------------------------------------------------
 *   05-May-1988 RAL Original
 *   13-Nov-1991 PBS C version
 */

#ifndef _VMM_
#define _VMM_


/*
 *  NON Windows/386 Virtual Device sources can include this file to get
 *  some useful equates by declaring the symbol "Not_VxD" If this symbol
 *  is defined, then everything that has to do with the specifics of the
 *  32 bit environment for virtual devices is removed.  Useful equates
 *  include: device ID's, pushad structure, BeginDoc, EndDoc, BeginMsg,
 *  EndMsg, page table equates, etc.
 */

#define FALSE       0       // False
#define VMM_TRUE    (~FALSE)    // The opposite of False!

#define DEBLEVELRETAIL  0
#define DEBLEVELNORMAL  1
#define DEBLEVELMAX 2

#ifndef DEBLEVEL
#ifdef DEBUG
#define DEBLEVEL DEBLEVELNORMAL
#else
#define DEBLEVEL DEBLEVELRETAIL
#endif
#endif

#ifndef WIN31COMPAT
#define WIN40SERVICES
#endif

/* ASM
ifdef MASM6
ifndef NO_MASM6_OPTIONS
;
;   option switches necessary to build VMM/VxD sources with MASM 6
;
    option oldmacros
ifndef  NEWSTRUCTS      ; define NEWSTRUCTS for MASM6 struct semantics
    option oldstructs
endif
    option noscoped
    option segment:flat
    option offset:flat
    option proc:private
endif
endif
;
;   These null macros are recognized by a utility program that produces
;   documentation files.
;
IFDEF MASM6
BeginDoc MACRO
     ENDM
EndDoc MACRO
       ENDM

BeginMsg MACRO
     ENDM
EndMsg MACRO
       ENDM
ELSE
BeginDoc EQU <>
EndDoc EQU <>

BeginMsg EQU <>
EndMsg EQU <>
ENDIF
*/


/******************************************************************************
 *
 *          EQUATES FOR REQUIRED DEVICES
 *
 *   Device ID formulation note:
 *
 *  The high bit of the device ID is reserved for future use.
 *  Microsoft reserves the device ID's 0-1FFh for standard devices.  If
 *  an OEM VxD is a replacement for a standard VxD, then it must use the
 *  standard VxD ID.
 *
 *  OEMS WHO WANT A VXD DEVICE ID ASSIGNED TO THEM,
 *  PLEASE CONTACT MICROSOFT PRODUCT SUPPORT.  ID's are only required for
 *  devices which provide services, V86 API's or PM API's.  Also, calling
 *  services or API's by VxD name is now supported in version 4.0, so an
 *  ID may not be necessary as long as a unique 8 character name is used.
 *
 *****************************************************************************/

#define UNDEFINED_DEVICE_ID 0x00000
#define VMM_DEVICE_ID       0x00001 /* Used for dynalink table */
#define DEBUG_DEVICE_ID     0x00002
#define VPICD_DEVICE_ID     0x00003
#define VDMAD_DEVICE_ID     0x00004
#define VTD_DEVICE_ID       0x00005
#define V86MMGR_DEVICE_ID   0x00006
#define PAGESWAP_DEVICE_ID  0x00007
#define PARITY_DEVICE_ID    0x00008
#define REBOOT_DEVICE_ID    0x00009
#define VDD_DEVICE_ID       0x0000A
#define VSD_DEVICE_ID       0x0000B
#define VMD_DEVICE_ID       0x0000C
#define VKD_DEVICE_ID       0x0000D
#define VCD_DEVICE_ID       0x0000E
#define VPD_DEVICE_ID       0x0000F
#define BLOCKDEV_DEVICE_ID  0x00010
#define VMCPD_DEVICE_ID     0x00011
#define EBIOS_DEVICE_ID     0x00012
#define BIOSXLAT_DEVICE_ID  0x00013
#define VNETBIOS_DEVICE_ID  0x00014
#define DOSMGR_DEVICE_ID    0x00015
#define WINLOAD_DEVICE_ID   0x00016
#define SHELL_DEVICE_ID     0x00017
#define VMPOLL_DEVICE_ID    0x00018
#define VPROD_DEVICE_ID     0x00019
#define DOSNET_DEVICE_ID    0x0001A
#define VFD_DEVICE_ID       0x0001B
#define VDD2_DEVICE_ID      0x0001C /* Secondary display adapter */
#define WINDEBUG_DEVICE_ID  0x0001D
#define TSRLOAD_DEVICE_ID   0x0001E /* TSR instance utility ID */
#define BIOSHOOK_DEVICE_ID  0x0001F /* Bios interrupt hooker VxD */
#define INT13_DEVICE_ID     0x00020
#define PAGEFILE_DEVICE_ID  0x00021 /* Paging File device */
#define SCSI_DEVICE_ID      0x00022 /* SCSI device */
#define MCA_POS_DEVICE_ID   0x00023 /* MCA_POS device */
#define SCSIFD_DEVICE_ID    0x00024 /* SCSI FastDisk device */
#define VPEND_DEVICE_ID     0x00025 /* Pen device */
#define APM_DEVICE_ID       0x00026 /* Power Management device */
#define VPOWERD_DEVICE_ID   APM_DEVICE_ID   /* We overload APM since we replace it */
#define VXDLDR_DEVICE_ID    0x00027 /* VxD Loader device */
#define NDIS_DEVICE_ID      0x00028 /* NDIS wrapper */
#define BIOS_EXT_DEVICE_ID   0x00029 /* Fix Broken BIOS device */
#define VWIN32_DEVICE_ID        0x0002A /* for new WIN32-VxD */
#define VCOMM_DEVICE_ID         0x0002B /* New COMM device driver */
#define SPOOLER_DEVICE_ID       0x0002C /* Local Spooler */
#define WIN32S_DEVICE_ID    0x0002D /* Win32S on Win 3.1 driver */
#define DEBUGCMD_DEVICE_ID      0x0002E /* Debug command extensions */
/* #define RESERVED_DEVICE_ID   0x0002F /* Not currently in use */
/* #define ATI_HELPER_DEVICE_ID    0x00030 /* grabbed by ATI */

/* 31-32 USED BY WFW NET COMPONENTS     */
/* #define VNB_DEVICE_ID           0x00031 /* Netbeui of snowball */
/* #define SERVER_DEVICE_ID        0x00032 /* Server of snowball */

#define CONFIGMG_DEVICE_ID  0x00033 /* Configuration manager (Plug&Play) */
#define DWCFGMG_DEVICE_ID   0x00034 /* Configuration manager for win31 and DOS */
#define SCSIPORT_DEVICE_ID  0x00035 /* Dragon miniport loader/driver */
#define VFBACKUP_DEVICE_ID  0x00036 /* allows backup apps to work with NEC */
#define ENABLE_DEVICE_ID    0x00037 /* for access VxD */
#define VCOND_DEVICE_ID     0x00038 /* Virtual Console Device - check vcond.inc */
/* 39 used by WFW VFat Helper device */

/* 3A used by WFW E-FAX */
/* #define EFAX_DEVICE_ID   0x0003A /* EFAX VxD ID      */

/* 3B used by MS-DOS 6.1 for the DblSpace VxD which has APIs */
/* #define DSVXD_DEVICE_ID  0x0003B /* Dbl Space VxD ID */

#define ISAPNP_DEVICE_ID    0x0003C /* ISA P&P Enumerator */
#define BIOS_DEVICE_ID      0x0003D /* BIOS P&P Enumerator */
/* #define WINSOCK_DEVICE_ID       0x0003E  /* WinSockets */
/* #define WSIPX_DEVICE_ID     0x0003F  /* WinSockets for IPX */

#define IFSMgr_Device_ID    0x00040 /* Installable File System Manager */
#define VCDFSD_DEVICE_ID    0x00041 /* Static CDFS ID */
#define MRCI2_DEVICE_ID     0x00042 /* DrvSpace compression engine */
#define PCI_DEVICE_ID       0x00043 /* PCI P&P Enumerator */
#define PELOADER_DEVICE_ID  0x00044 /* PE Image Loader */
#define EISA_DEVICE_ID      0x00045 /* EISA P&P Enumerator */
#define DRAGCLI_DEVICE_ID   0x00046 /* Dragon network client */
#define DRAGSRV_DEVICE_ID   0x00047 /* Dragon network server */
#define PERF_DEVICE_ID	    0x00048 /* Config/stat info */


#define ETEN_Device_ID      0x00060 /* ETEN DOS (Taiwan) driver */
#define HBIOS_Device_ID     0x00061 /* HBIOS DOS (Korean) driver */
#define VMSGD_Device_ID    0x00062 /* DBCS Message Mode driver */
#define VPPID_Device_ID     0x00063 /* PC-98 System Control PPI */

#define BASEID_FOR_NAMEBASEDVXD        0xf000 /* Name based VxD IDs start here */
#define BASEID_FOR_NAMEBASEDVXD_MASK   0x0fff /* Mask to get the real vxd id */
/*
 *   Initialization order equates.  Devices are initialized in order from
 *   LOWEST to HIGHEST. If 2 or more devices have the same initialization
 *   order value, then they are initialized in order of occurance, so a
 *   specific order is not guaranteed.  Holes have been left to allow maximum
 *   flexibility in ordering devices.
 */

#define VMM_INIT_ORDER      0x000000000
#define DEBUG_INIT_ORDER    0x000000000 /* normally using 0 is bad */
#define DEBUGCMD_INIT_ORDER     0x000000000 /*  but debug must be first */
#define PERF_INIT_ORDER     0x000900000
#define APM_INIT_ORDER          0x001000000
#define VPOWERD_INIT_ORDER  APM_INIT_ORDER  /* We overload APM since we replace it */
#define BIOSHOOK_INIT_ORDER 0x006000000
#define VPROD_INIT_ORDER    0x008000000
#define VPICD_INIT_ORDER    0x00C000000
#define VTD_INIT_ORDER      0x014000000
#define VXDLDR_INIT_ORDER   0x016000000

#define ENUMERATOR_INIT_ORDER   0x016800000 /* Should be before IOS */
#define ISAPNP_INIT_ORDER   ENUMERATOR_INIT_ORDER
#define EISA_INIT_ORDER     ENUMERATOR_INIT_ORDER
#define PCI_INIT_ORDER      ENUMERATOR_INIT_ORDER
#define BIOS_INIT_ORDER     ENUMERATOR_INIT_ORDER+1 /* To simplify reenumeration */
#define CONFIGMG_INIT_ORDER ENUMERATOR_INIT_ORDER+0xFFFF    /* After all enumerators */

#define VCDFSD_INIT_ORDER   0x016F00000
#define IOS_INIT_ORDER      0x017000000
#define PAGEFILE_INIT_ORDER 0x018000000
#define PAGESWAP_INIT_ORDER 0x01C000000
#define PARITY_INIT_ORDER   0x020000000
#define REBOOT_INIT_ORDER   0x024000000
#define EBIOS_INIT_ORDER    0x026000000
#define VDD_INIT_ORDER      0x028000000
#define VSD_INIT_ORDER      0x02C000000

#define VCD_INIT_ORDER      0x030000000
#define COMMDRVR_INIT_ORDER (VCD_INIT_ORDER - 1)
#define PRTCL_INIT_ORDER    (COMMDRVR_INIT_ORDER - 2)
#define MODEM_INIT_ORDER    (COMMDRVR_INIT_ORDER - 3)
#define PORT_INIT_ORDER     (COMMDRVR_INIT_ORDER - 4)

#define VMD_INIT_ORDER      0x034000000
#define VKD_INIT_ORDER      0x038000000
#define VPD_INIT_ORDER      0x03C000000
#define BLOCKDEV_INIT_ORDER 0x040000000
#define MCA_POS_INIT_ORDER  0x041000000
#define SCSIFD_INIT_ORDER   0x041400000
#define SCSIMASTER_INIT_ORDER   0x041800000
#define INT13_INIT_ORDER    0x042000000
#define VMCPD_INIT_ORDER    0x048000000
#define BIOSXLAT_INIT_ORDER 0x050000000
#define VNETBIOS_INIT_ORDER 0x054000000
#define DOSMGR_INIT_ORDER   0x058000000
#define DOSNET_INIT_ORDER   0x05C000000
#define WINLOAD_INIT_ORDER  0x060000000
#define VMPOLL_INIT_ORDER   0x064000000

#define UNDEFINED_INIT_ORDER    0x080000000
#define WIN32_INIT_ORDER    UNDEFINED_INIT_ORDER
#define VCOND_INIT_ORDER    UNDEFINED_INIT_ORDER

#define WINDEBUG_INIT_ORDER 0x081000000
#define VDMAD_INIT_ORDER    0x090000000
#define V86MMGR_INIT_ORDER  0x0A0000000

#define IFSMgr_Init_Order   0x10000 + V86MMGR_Init_Order
#define FSD_Init_Order      0x00100 + IFSMgr_Init_Order
#define VFD_INIT_ORDER      0x50000 + IFSMgr_Init_Order

/* Device that must touch memory in 1st Mb at crit init (after V86mmgr) */
#define UNDEF_TOUCH_MEM_INIT_ORDER  0x0A8000000
#define SHELL_INIT_ORDER    0x0B0000000

/* ASM
;******************************************************************************
;
;   Macro to cause a delay in between I/O accesses to the same device.
;
;------------------------------------------------------------------------------

IO_Delay    macro
jmp $+2
ENDM
*/

#define VXD_FAILURE 0
#define VXD_SUCCESS 1

typedef ULONG HVM;          /* VM handle typedef */

/*
 *  Registers as they appear on the stack after a PUSHAD.
 */

struct Pushad_Struc {
    ULONG Pushad_EDI;           /* Client's EDI */
    ULONG Pushad_ESI;           /* Client's ESI */
    ULONG Pushad_EBP;           /* Client's EBP */
    ULONG Pushad_ESP;           /* ESP before pushad */
    ULONG Pushad_EBX;           /* Client's EBX */
    ULONG Pushad_EDX;           /* Client's EDX */
    ULONG Pushad_ECX;           /* Client's ECX */
    ULONG Pushad_EAX;           /* Client's EAX */
};

/* XLATOFF */

#ifdef RC_INVOKED
#define NOBASEDEFS
#endif

#ifndef NOBASEDEFS

#pragma warning (disable:4209)  // turn off redefinition warning

typedef unsigned char   UCHAR;
typedef unsigned short  USHORT;

#pragma warning (default:4209)  // turn off redefinition warning

#endif

#define GetVxDServiceOrdinal(service)   __##service

#define Begin_Service_Table(device, seg) \
    enum device##_SERVICES { \
    device##_dummy = (device##_DEVICE_ID << 16) - 1,

#define Declare_Service(service, local) \
    GetVxDServiceOrdinal(service),

#define End_Service_Table(device, seg) \
    Num_##device##_Services};

#define VXDINLINE static __inline
/* XLATON */

#ifndef Not_VxD

/* XLATOFF */
#define VxD_LOCKED_CODE_SEG code_seg("_LTEXT", "LCODE")
#define VxD_LOCKED_DATA_SEG data_seg("_LDATA", "LCODE")
#define VxD_INIT_CODE_SEG   code_seg("_ITEXT", "ICODE")
#define VxD_INIT_DATA_SEG   data_seg("_IDATA", "ICODE")
#define VxD_ICODE_SEG       code_seg("_ITEXT", "ICODE")
#define VxD_IDATA_SEG       data_seg("_IDATA", "ICODE")
#define VxD_PAGEABLE_CODE_SEG   code_seg("_PTEXT", "PCODE")
#define VxD_PAGEABLE_DATA_SEG   data_seg("_PDATA", "PDATA")
#define VxD_STATIC_CODE_SEG code_seg("_STEXT", "SCODE")
#define VxD_STATIC_DATA_SEG data_seg("_SDATA", "SCODE")
#define VxD_DEBUG_ONLY_CODE_SEG code_seg("_DBOCODE", "DBOCODE")
#define VxD_DEBUG_ONLY_DATA_SEG data_seg("_DBODATA", "DBOCODE")

#define VxD_SYSEXIT_CODE_SEG    code_seg("SYSEXIT", "SYSEXITCODE")
#define VxD_INT21_CODE_SEG  code_seg("INT21", "INT21CODE")
#define VxD_RARE_CODE_SEG   code_seg("RARE", "RARECODE")
#define VxD_W16_CODE_SEG    code_seg("W16", "W16CODE")
#define VxD_W32_CODE_SEG    code_seg("W32", "W32CODE")
#define VxD_VMCREATE_CODE_SEG   code_seg("VMCREATE", "VMCREATECODE")
#define VxD_VMDESTROY_CODE_SEG  code_seg("VMDESTROY", "VMDESTROYCODE")
#define VxD_THCREATE_CODE_SEG   code_seg("THCREATE", "THCREATECODE")
#define VxD_THDESTROY_CODE_SEG  code_seg("THDESTROY", "THDESTROYCODE")
#define VxD_VMSUSPEND_CODE_SEG  code_seg("VMSUSPEND", "VMSUSPENDCODE")
#define VxD_VMRESUME_CODE_SEG   code_seg("VMRESUME", "VMRESUMECODE")
#define VxD_PNP_CODE_SEG    code_seg("PNP", "PNPCODE")
#define VxD_DOSVM_CODE_SEG  code_seg("DOSVM", "DOSVMCODE")
#define VxD_LOCKABLE_CODE_SEG   code_seg("LOCKABLE", "LOCKABLECODE")
/* XLATON */

/* ASM
??_CUR_CODE_SEG = 0

??_LCODE    =   1
??_ICODE    =   2
??_PCODE    =   3
??_SCODE    =   4
??_DBOCODE  =   5
??_16ICODE  =   6
??_RCODE    =   7
??_LOCKABLECODE =   8

?_LCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_LCODE>
?_ICODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_ICODE>
?_PCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_PCODE>
?_SCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_SCODE>
?_DBOCODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_DBOCODE>
?_16ICODE   equ <(??_CUR_CODE_SEG MOD 16) - ??_16ICODE>
?_RCODE     equ <(??_CUR_CODE_SEG MOD 16) - ??_RCODE>
?_LOCKABLECODE  equ <(??_CUR_CODE_SEG MOD 16) - ??_LOCKABLECODE>

ifndef NO_SEGMENTS

;
;  SEGMENT definitions and order
;

IFDEF   MASM6
_FLAT   EQU FLAT
ELSE
_FLAT   EQU USE32
ENDIF

;*  32 bit locked code
_LTEXT      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LTEXT      ENDS

_TEXT       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TEXT       ENDS

;*  32 bit pageable code
_PTEXT      SEGMENT DWORD PUBLIC _FLAT 'PCODE'
_PTEXT      ENDS



MakeCodeSeg MACRO seglist, classname, grpname, iseg

    IRP segname,<seglist>   ;; For each name in the list

IFNB    <classname>
    segname     SEGMENT DWORD PUBLIC _FLAT "&classname&CODE"
ELSE
    segname     SEGMENT DWORD PUBLIC _FLAT "&segname&CODE"
ENDIF

IFB <iseg>
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ELSE
VxD_&&segname&&_CODE_SEG MACRO
segname  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + iseg
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM
ENDIF

VxD_&&segname&&_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
segname ENDS
        ENDM

segname     ENDS

IFNDEF BLD_COFF
IFNB    <grpname>
    _&grpname GROUP segname
ELSE
    _&&segname GROUP segname
ENDIF
ENDIF

    ENDM                ;; End for each segment

    ENDM

MakeCodeSeg <LOCKABLE_BEGIN, LOCKABLE, LOCKABLE_END>, \
    LOCKABLE, LOCKABLE, ??_LOCKABLECODE
MakeCodeSeg INT21
MakeCodeSeg SYSEXIT
MakeCodeSeg RARE
MakeCodeSeg W16
MakeCodeSeg W32
MakeCodeSeg VMCREATE
MakeCodeSeg VMDESTROY
MakeCodeSeg THCREATE
MakeCodeSeg THDESTROY
MakeCodeSeg VMSUSPEND
MakeCodeSeg VMRESUME
MakeCodeSeg PNP
MakeCodeSeg DOSVM


;***    DefLockableCodeBegin - define beginning of lockable code
;
;   Defines a label with the given name to mark the beginning
;   of the lockable code area for this VxD.  In the debug version,
;   also defines a DWORD containing DFS_TEST_BLOCK so that
;   procedures in the lockable code segment defined with
;   BeginProc may call _Debug_Flags_Service with flags appropriate
;   to the code's current state.

DefLockableCodeBegin MACRO name, private
VxD_LOCKABLE_BEGIN_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_BEGIN_CODE_ENDS
ifndef WIN31COMPAT
if DEBLEVEL
VxD_LOCKED_DATA_SEG
    PUBLIC name&_Debug_Flags
name&_Debug_Flags DD DFS_TEST_BLOCK
VxD_LOCKED_DATA_ENDS
??_debug_flags equ <name&_Debug_Flags>
endif
endif
    ENDM

;***    DefLockableCodeEnd - define end of lockable code
;
;   Defines a label with the given name to mark the end
;   of the lockable code area for this VxD.  By subtracting
;   the offset of the beginning label from the offset of
;   the ending label, the VxD may determine how many bytes
;   of memory to lock or unlock.

DefLockableCodeEnd MACRO name, private
VxD_LOCKABLE_END_CODE_SEG
IFB <private>
    PUBLIC  name
ENDIF
name    LABEL   NEAR
VxD_LOCKABLE_END_CODE_ENDS
    ENDM

;***    CodeLockFlags - declare locked code debug flags
;
;   This macro declares the locked code debug flags.

CodeLockFlags MACRO name
ifndef WIN31COMPAT
if DEBLEVEL
    ifndef name&_Debug_Flags
    VxD_LOCKED_DATA_SEG
        extrn   name&_Debug_Flags:dword
    VxD_LOCKED_DATA_ENDS
    ??_debug_flags equ <name&_Debug_Flags>
    endif
endif
endif
    ENDM

;***    MarkCodeLocked - signify that lockable code is locked
;
;   This macro clears DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeLocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    and ??_debug_flags,NOT DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM

;***    MarkCodeUnlocked - signify that lockable code is unlocked
;
;   This macro sets DFS_TEST_BLOCK in the debug flags
;   DWORD.

MarkCodeUnlocked MACRO
ifndef WIN31COMPAT
if DEBLEVEL
ifdef ??_debug_flags
    pushfd
    or  ??_debug_flags,DFS_TEST_BLOCK
    popfd
endif
endif
endif
    ENDM


;*  32 bit initialization code
_ITEXT      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_ITEXT      ENDS

;*  32 bit locked data
_LDATA      SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_LDATA      ENDS

_DATA       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_DATA       ENDS

;*  32 bit pageable data
_PDATA      SEGMENT DWORD PUBLIC _FLAT 'PDATA'
_PDATA      ENDS

;*  32 Bit initialization data
_IDATA      SEGMENT DWORD PUBLIC _FLAT 'ICODE'
_IDATA      ENDS

;*  Created by C8
_BSS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_BSS        ENDS

CONST       SEGMENT DWORD PUBLIC _FLAT 'LCODE'
CONST       ENDS

_TLS        SEGMENT DWORD PUBLIC _FLAT 'LCODE'
_TLS        ENDS

;*  32 Bit static code for DL-VxDs
_STEXT      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_STEXT      ENDS

;*  32 Bit static data for DL-VxDs
_SDATA      SEGMENT DWORD PUBLIC _FLAT 'SCODE'
_SDATA      ENDS

;*      dummy segment for IsDebugOnlyLoaded
_DBOSTART   SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOSTART   ENDS

;*      32 bit debug only code; loaded only if debugger is present
_DBOCODE    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBOCODE    ENDS

;*      32 bit debug only data; loaded only if debugger is present
_DBODATA    SEGMENT DWORD PUBLIC _FLAT 'DBOCODE'
_DBODATA    ENDS

;*  16 bit code/data that is put into IGROUP automaticly
_16ICODE    SEGMENT WORD USE16 PUBLIC '16ICODE'
_16ICODE    ENDS

;*  Real Mode initialization code/data for devices
_RCODE      SEGMENT WORD USE16 PUBLIC 'RCODE'
_RCODE      ENDS

IFNDEF BLD_COFF
_LGROUP   GROUP _LTEXT, _TEXT, _LDATA, _DATA, _BSS, CONST, _TLS
_IGROUP   GROUP _ITEXT, _IDATA
_SGROUP   GROUP _STEXT, _SDATA
_DBOGROUP GROUP _DBOSTART, _DBOCODE, _DBODATA
ENDIF

endif ; NO_SEGMENTS

    ASSUME CS:FLAT, DS:FLAT, ES:FLAT, SS:FLAT

OFFSET32 EQU <OFFSET FLAT:>


BeginDoc
;==============================================================================
; The following macros are used in defining the routines
;   in a VxD which are going to be registered with VMM as callable entry
;   points. Once registered, the entry points can be called by any other
;   devices via the "VxDCall" macro, defined below. In the comments below,
;   replace "VxD" with the appropriate device name.
;
;*******
;   In the VxD.INC file, put the following lines, replacing <function_name>
;   with an appropriate name describing the function of the routine.
;
;   Begin_Service_Table VxD[,<segname>]
;   VxD_Service <function_name>[,<local segname>]
;   VxD_Service <function_name>[,<local segname>]
;       . . .
;   VxD_Service <function_name>[,<local segname>]
;   End_Service_Table   VxD[,<segname>]
;
;   Note that <segname> is an optional argument and, if specified, the
;   table is put in the segment defined by the macro "yyy_Data_Seg",
;   where yyy=segname. Otherwise the segment is defined by the
;   "VxD_Data_Seg" macro, defined below.
;   Note that <local segname> is an optional argument and, if specified,
;   the procedure's segment is defined by the macro "zzz_Code_Seg",
;   where zzz=segname. Otherwise the segment is defined by the
;   "VxD_Code_Seg" macro, defined below.
;
;*******
; One VxD module should have the following in order to define the entry points:
;Create_VxD_Service_Table = 1           ; Only in module where table is
;   INCLUDE     VxD.INC         ; Include the table definition
;
;*******
; All modules that want to call the services defined in the table should include
;   VxD.INC, but not define the label "Create_VxD_Service_Table". This
;   will define the service names to be used with the VxDCall macro.
;
EndDoc

Begin_Service_Table MACRO Device_Name, Def_Segment

IFDEF   Device_Name&_Name_Based
 IFNDEF @@NextInternalID
    @@NextInternalID    = 0
 ENDIF
 @@NextInternalID = (@@NextInternalID + 1)
 Device_Name&_Internal_ID   = @@NextInternalID + BASEID_FOR_NAMEBASEDVXD
 DefineVxDName  Device_Name, %Device_Name&_Internal_ID
ENDIF

IFB <Def_Segment>
    BST2 Device_Name, VxD
ELSE
    BST2 Device_Name, Def_Segment
ENDIF
    ENDM

DefineVxDName   MACRO Device_Name, InternalID
 @@VxDName&InternalID EQU   <___&Device_Name&STable>
ENDM


BST2 MACRO Device_Name, Def_Segment

Num_&Device_Name&_Services = 0

IFDEF Create_&Device_Name&_Service_Table

Def_Segment&_LOCKED_DATA_SEG

Device_Name&_Service_Table LABEL DWORD

Device_Name&_Service MACRO Procedure, Local_Seg, Condition
LOCAL $$&Procedure

  IFNB <Condition>
  $$&&Procedure MACRO extern
    IFDEF &Condition
      IFNB <extern>
    EXTRN   Procedure:NEAR
      ELSE
    dd  OFFSET32 Procedure
      ENDIF
    ELSE
      IFB <extern>
      dd      0
      ENDIF
    ENDIF
    ENDM
  ENDIF

  IFDIFI <Procedure>, <RESERVED>
    PUBLIC _&&Procedure
     IF1
    _&&Procedure LABEL DWORD
     ENDIF
     IFDIFI <Local_Seg>, <LOCAL>
        IFNB <Local_Seg>
Local_Seg&&_SEG
       ELSE
Def_Segment&_CODE_SEG
        ENDIF
        IFNB <Condition>
    $$&&Procedure extern
       ELSE
    EXTRN   Procedure:NEAR
        ENDIF
        IFNB <Local_Seg>
Local_Seg&&_ENDS
        ELSE
Def_Segment&_CODE_ENDS
        ENDIF
     ENDIF
      IFNB <Condition>
    $$&&Procedure
      ELSE
    dd  OFFSET32 Procedure
      ENDIF

          IFDEF Device_Name&_Name_Based
        @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
          ELSE
        @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
          ENDIF
  ELSE
    dd  0
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1
  IFNB <Condition>
    Purge $$&&Procedure
  ENDIF
    ENDM

ELSE

; Local_Seg and Condition are placeholders only in this form

IFDEF   Device_Name&_Name_Based

Device_Name&_Service MACRO Procedure, Local_Seg, Condition


  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Internal_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ELSE

Device_Name&_Service MACRO Procedure, Local_Seg, Condition

  IFDIFI <Procedure>, <RESERVED>
    @@&&Procedure = (Device_Name&_Device_ID SHL 16) + Num_&Device_Name&_Services
  ENDIF
    Num_&Device_Name&_Services = Num_&Device_Name&_Services + 1

    ENDM
ENDIF

ENDIF

    ENDM

;------------------------------------------------------------------------------

End_Service_Table MACRO Device_Name, Def_Segment

    PURGE   Device_Name&_Service

IFDEF Create_&Device_Name&_Service_Table

IFB <Def_Segment>
VxD_LOCKED_DATA_ENDS
ELSE
Def_Segment&_LOCKED_DATA_ENDS
ENDIF

ENDIF

    ENDM

GetVxDServiceOrdinal    macro   reg,service
    mov reg,@@&service
    endm

GetVxDServiceAddress    macro   reg,service
    mov reg,OFFSET32 service
    endm


;***    Begin_Win32_Services - begin defining Win32 Service Table
;
;   This macro is used to begin the definition of the Win32
;   Service table.  It is modelled after, but not identical
;   to, the Begin_Service_Table macro.  If the the special
;   symbol Create_Win32_Services is defined to be true, then
;   the actual table is emitted.  Otherwise, only the service
;   numbers are defined.
;
;   ENTRY   VxDName     - the name of the VxD; it is assumed
;                 that a corresponding Device_ID is
;                 also defined.
;   EXIT    The macro VxDName&_Win32_Sevice is defined; it
;       accepts a service name as its only parameter.
;       This macro is then used to define each service.

Begin_Win32_Services MACRO VxDName
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
    .errb <VxDName>, <VxD name missing>
    ??w32svcno = 0
if Create_Win32_Services
VxDName&_Win32_Services label dword
    dd  csvc&VxDName, 0
endif
    ??inw32svc = 1

    VxDName&_Win32_Service MACRO Name
        .erre ??inw32svc, <Missing Begin_Win32_Services>
    if Create_Win32_Services
        dd  OFFSET32 Name,cparm&&Name
    endif
        @32&&Name equ   ((VxDName&_Device_ID SHL 16) + ??w32svcno)
        ??w32svcno = ??w32svcno + 1
        ENDM
    ENDM


;***    End_Win32_Services - mark end of Win32 Service Table
;
;   This macro completes initialization of the Win32
;   Service table.
;
;   ENTRY   VxDName     - the same name passed to
;                 Begin_Win32_services

End_Win32_Services MACRO VxDName
    .errb <VxDName>, <VxD name misssing>
if Create_Win32_Services
    csvc&VxDName    equ ($ - VxDName&_Win32_Services)/8 - 1
endif
    ??inw32svc = 0
    PURGE VxDName&_Win32_Service
    ENDM


;***    Declare_Win32_Service - declare an external Win32 Service
;
;   This macro is used to declare a Win32 service that
;   is defined elsewhere, perhaps in a C module.
;
;   ENTRY   Name        - the service name
;       cParms      - the number of DWORD parameters
;   EXIT    The name is defined as external

Declare_Win32_Service MACRO Name, cParms
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
if Create_Win32_Services
    ?merge  <Name>,,,,<EQU>,<_>,<Name>,<@>,%(cParms*4 + 8)
    ?merge  <cparm>,<Name>,,,<EQU>,<cParms>
VxD_CODE_SEG
    ?merge  <EXTRN>,,,,,<_>,<Name>,<@>,%(cParms*4 + 8),<:NEAR>
VxD_CODE_ENDS
endif
    ENDM


;***    Win32call - call a Win32 service from a ring 3 thunk
;
;   This macro is used to call a Win32 service from
;   a ring 3 thunk.  Note that control will not return
;   to the instruction following the call, but to the
;   instruction following the call to the thunk.
;
;   ENTRY   Service     - the name of the service
;       CallBack    - the fword containing the callback

Win32call MACRO Service, CallBack
ifndef Create_Win32_Services
    Create_Win32_Services = 0
endif
ife Create_Win32_Services
    mov eax,@32&Service
ifdef IS_16
    movzx   esp,sp
endif
    call    fword ptr [CallBack]
ifdef DEBUG
    int 3
endif
endif
    ENDM
*/

/*XLATOFF*/
#define GetVxDServiceAddress(service)   service

#define VxDCall(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit (GetVxDServiceOrdinal(service) >> 8) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMCall VxDCall

#define VxDJmp(service) \
    _asm _emit 0xcd \
    _asm _emit 0x20 \
    _asm _emit (GetVxDServiceOrdinal(service) & 0xff) \
    _asm _emit ((GetVxDServiceOrdinal(service) >> 8) & 0xff) | 0x80 \
    _asm _emit (GetVxDServiceOrdinal(service) >> 16) & 0xff \
    _asm _emit (GetVxDServiceOrdinal(service) >> 24) & 0xff \

#define VMMJmp  VxDJmp

#define SERVICE     __cdecl
#define ASYNC_SERVICE   __cdecl
#define WIN32_SERVICE   void __stdcall
/*XLATON*/

/* ASM
;******************************************************************************
;
;   Dword_Align -- Aligns code to dword boundry by inserting nops
;
;------------------------------------------------------------------------------

Dword_Align MACRO Seg_Name
    LOCAL segn
IFDEF MASM6
    align 4
ELSE
IFNB <Seg_Name>
    segn equ Seg_Name
ELSE
IFE ?_LCODE
    segn equ <_LTEXT>
ELSE
IFE ?_ICODE
    segn equ <_ITEXT>
ELSE
IFE ?_PCODE
    segn equ <_PTEXT>
ELSE
IFE ?_SCODE
    segn equ <_STEXT>
ELSE
.err <Dword_Align not supported>
ENDIF
ENDIF
ENDIF
ENDIF
ENDIF
IF (($-OFFSET segn:0) MOD 4)
db 4 - (($-OFFSET segn:0) MOD 4) DUP (90h)
ENDIF
ENDIF
        ENDM


BeginDoc
;******************************************************************************
;
;   Fatal_Error
;
;   DESCRIPTION:
;   This macro is used to crash Windows/386 when an unrecoverable error
;   is detected.  If Msg_Ptr is ommitted then no error message will be
;   displayed, otherwise Msg_Ptr is the address
;   when the
;
;   PARAMETERS:
;   Msg_Ptr (OPTIONAL) - Points to an ASCIIZ string to display.
;
;   EXIT:
;   To DOS (hopefully).  This macro never returns.
;
;==============================================================================
EndDoc

Fatal_Error MACRO Msg_Ptr, Exit_Flags
    pushad
IFB <Msg_Ptr>
    xor esi, esi
ELSE
    mov esi, Msg_Ptr
IFB <Exit_Flags>
    xor eax, eax
ELSE
    mov eax, Exit_Flags
ENDIF
ENDIF
    VMMCall Fatal_Error_Handler
    ENDM

EF_Hang_On_Exit     EQU     1h
*/


/******************************************************************************
 *
 *   The following are control block headers and flags of interest to VxDs.
 *
 *****************************************************************************/

struct cb_s {
    ULONG CB_VM_Status;         /* VM status flags */
    ULONG CB_High_Linear;       /* Address of VM mapped high */
    ULONG CB_Client_Pointer;
    ULONG CB_VMID;
    ULONG CB_Signature;
};

#define VMCB_ID 0x62634D56      /* VMcb */

/*
 *  VM status indicates globally interesting VM states
 */

#define VMSTAT_EXCLUSIVE_BIT    0x00    /* VM is exclusive mode */
#define VMSTAT_EXCLUSIVE        (1L << VMSTAT_EXCLUSIVE_BIT)
#define VMSTAT_BACKGROUND_BIT   0x01    /* VM runs in background */
#define VMSTAT_BACKGROUND       (1L << VMSTAT_BACKGROUND_BIT)
#define VMSTAT_CREATING_BIT 0x02    /* In process of creating */
#define VMSTAT_CREATING         (1L << VMSTAT_CREATING_BIT)
#define VMSTAT_SUSPENDED_BIT    0x03    /* VM not scheduled */
#define VMSTAT_SUSPENDED        (1L << VMSTAT_SUSPENDED_BIT)
#define VMSTAT_NOT_EXECUTEABLE_BIT 0x04 /* VM partially destroyed */
#define VMSTAT_NOT_EXECUTEABLE  (1L << VMSTAT_NOT_EXECUTEABLE_BIT)
#define VMSTAT_PM_EXEC_BIT  0x05    /* Currently in PM app */
#define VMSTAT_PM_EXEC          (1L << VMSTAT_PM_EXEC_BIT)
#define VMSTAT_PM_APP_BIT   0x06    /* PM app present in VM */
#define VMSTAT_PM_APP           (1L << VMSTAT_PM_APP_BIT)
#define VMSTAT_PM_USE32_BIT 0x07    /* PM app is 32-bit */
#define VMSTAT_PM_USE32         (1L << VMSTAT_PM_USE32_BIT)
#define VMSTAT_VXD_EXEC_BIT 0x08    /* Call from VxD */
#define VMSTAT_VXD_EXEC         (1L << VMSTAT_VXD_EXEC_BIT)
#define VMSTAT_HIGH_PRI_BACK_BIT 0x09   /* High pri background */
#define VMSTAT_HIGH_PRI_BACK    (1L << VMSTAT_HIGH_PRI_BACK_BIT)
#define VMSTAT_BLOCKED_BIT  0x0A    /* Blocked on semaphore */
#define VMSTAT_BLOCKED          (1L << VMSTAT_BLOCKED_BIT)
#define VMSTAT_AWAKENING_BIT    0x0B    /* Woke up after blocked */
#define VMSTAT_AWAKENING        (1L << VMSTAT_AWAKENING_BIT)
#define VMSTAT_PAGEABLEV86BIT   0x0C    /* part of V86 is pageable (PM app) */
#define VMSTAT_PAGEABLEV86_BIT  VMSTAT_PAGEABLEV86BIT
#define VMSTAT_PAGEABLEV86      (1L << VMSTAT_PAGEABLEV86BIT)
#define VMSTAT_V86INTSLOCKEDBIT 0x0D    /* Locked regardless of pager type */
#define VMSTAT_V86INTSLOCKED_BIT VMSTAT_V86INTSLOCKEDBIT
#define VMSTAT_V86INTSLOCKED    (1L << VMSTAT_V86INTSLOCKEDBIT)
#define VMSTAT_IDLE_TIMEOUT_BIT 0x0E    /* Scheduled by time-slicer */
#define VMSTAT_IDLE_TIMEOUT     (1L << VMSTAT_IDLE_TIMEOUT_BIT)
#define VMSTAT_IDLE_BIT         0x0F    /* VM has released time slice */
#define VMSTAT_IDLE             (1L << VMSTAT_IDLE_BIT)
#define VMSTAT_CLOSING_BIT  0x10    /* Close_VM called for VM */
#define VMSTAT_CLOSING          (1L << VMSTAT_CLOSING_BIT)
#define VMSTAT_TS_SUSPENDED_BIT 0x11    /* VM suspended by */
#define VMSTAT_TS_SUSPENDED     (1L << VMSTAT_TS_SUSPENDED_BIT)
#define VMSTAT_TS_MAXPRI_BIT    0x12    /* this is fgd_pri 10,000 internally*/
#define VMSTAT_TS_MAXPRI        (1L << VMSTAT_TS_MAXPRI_BIT)

#define VMSTAT_USE32_MASK   (VMSTAT_PM_USE32 | VMSTAT_VXD_EXEC)

struct tcb_s {
    ULONG   TCB_Flags;          /* Thread status flags */
    ULONG   TCB_Reserved1;      /* Used internally by VMM */
    ULONG   TCB_Reserved2;      /* Used internally by VMM */
    ULONG   TCB_Signature;
    ULONG   TCB_ClientPtr;      /* Client registers of thread */
    ULONG   TCB_VMHandle;       /* VM that thread is part of */
    USHORT  TCB_ThreadId;       /* Unique Thread ID */
    USHORT  TCB_PMLockOrigSS;       /* Original SS:ESP before lock stack */
    ULONG   TCB_PMLockOrigESP;
    ULONG   TCB_PMLockOrigEIP;      /* Original CS:EIP before lock stack */
    ULONG   TCB_PMLockStackCount;
    USHORT  TCB_PMLockOrigCS;
    USHORT  TCB_PMPSPSelector;
    ULONG   TCB_ThreadType;     /* dword passed to VMMCreateThread */
    USHORT  TCB_pad1;           /* reusable; for dword align */
    UCHAR   TCB_pad2;           /* reusable; for dword align */
    UCHAR   TCB_extErrLocus;        /* extended error Locus */
    USHORT  TCB_extErr;         /* extended error Code */
    UCHAR   TCB_extErrAction;       /*      "   "   Action */
    UCHAR   TCB_extErrClass;        /*      "   "   Class */
    ULONG   TCB_extErrPtr;      /*      "   pointer */

};

typedef struct tcb_s TCB;
typedef TCB *PTCB;

#define SCHED_OBJ_ID_THREAD         0x42434854    // THCB in ASCII

/*
 *  Thread status indicates globally interesting thread states.
 *  Flags are for information only and must not be modified.
 */

#define THFLAG_SUSPENDED_BIT        0x03   // Thread not scheduled
#define THFLAG_SUSPENDED                   (1L << THFLAG_SUSPENDED_BIT)
#define THFLAG_NOT_EXECUTEABLE_BIT  0x04   // Thread partially destroyed
#define THFLAG_NOT_EXECUTEABLE             (1L << THFLAG_NOT_EXECUTEABLE_BIT)
#define THFLAG_THREAD_CREATION_BIT  0x08   // Thread in status nascendi
#define THFLAG_THREAD_CREATION             (1L << THFLAG_THREAD_CREATION_BIT)
#define THFLAG_THREAD_BLOCKED_BIT   0x0A   // Blocked on semaphore
#define THFLAG_THREAD_BLOCKED              (1L << THFLAG_THREAD_BLOCKED_BIT)
#define THFLAG_CHARSET_BITS     0x10   // Default character set
#define THFLAG_CHARSET_MASK        (3L << THFLAG_CHARSET_BITS)
#define THFLAG_ANSI            (0L << THFLAG_CHARSET_BITS)
#define THFLAG_OEM             (1L << THFLAG_CHARSET_BITS)
#define THFLAG_UNICODE             (2L << THFLAG_CHARSET_BITS)
#define THFLAG_RESERVED            (3L << THFLAG_CHARSET_BITS)
#define THFLAG_EXTENDED_HANDLES_BIT 0x12   // Thread uses extended file handles
#define THFLAG_EXTENDED_HANDLES            (1L << THFLAG_EXTENDED_HANDLES_BIT)
/* the win32 loader opens win32 exes with this bit set to notify IFS
 * so a defragger won't move these files
 * the bit is turned off once the open completes.
 * file open flags are overloaded which is why this is here
 */
#define THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT 0x13   // File thus opened not moved
#define THFLAG_OPEN_AS_IMMOVABLE_FILE            (1L << THFLAG_OPEN_AS_IMMOVABLE_FILE_BIT)

/*
 *   Protected mode application control blocks
 */
struct pmcb_s {
    ULONG PMCB_Flags;
    ULONG PMCB_Parent;
};

/*
 *  The reference data for fault error codes 1-5 (GSDVME_PRIVINST through
 *  GSDVME_INVALFLT) is a pointer to the following fault information structure.
 */
struct VMFaultInfo {
    ULONG VMFI_EIP;             // faulting EIP
    WORD  VMFI_CS;              // faulting CS
    WORD  VMFI_Ints;            // interrupts in service, if any
};

typedef struct VMFaultInfo *PVMFaultInfo;

/******************************************************************************
 *              V M M   S E R V I C E S
 ******************************************************************************/

/*XLATOFF*/
#define VMM_Service Declare_Service
#pragma warning (disable:4003)      // turn off not enough params warning
/*XLATON*/

/*MACROS*/
Begin_Service_Table(VMM, VMM)

VMM_Service (Get_VMM_Version, LOCAL)    // MUST REMAIN SERVICE 0!

VMM_Service (Get_Cur_VM_Handle)
VMM_Service (Test_Cur_VM_Handle)
VMM_Service (Get_Sys_VM_Handle)
VMM_Service (Test_Sys_VM_Handle)
VMM_Service (Validate_VM_Handle)

VMM_Service (Get_VMM_Reenter_Count)
VMM_Service (Begin_Reentrant_Execution)
VMM_Service (End_Reentrant_Execution)

VMM_Service (Install_V86_Break_Point)
VMM_Service (Remove_V86_Break_Point)
VMM_Service (Allocate_V86_Call_Back)
VMM_Service (Allocate_PM_Call_Back)

VMM_Service (Call_When_VM_Returns)

VMM_Service (Schedule_Global_Event)
VMM_Service (Schedule_VM_Event)
VMM_Service (Call_Global_Event)
VMM_Service (Call_VM_Event)
VMM_Service (Cancel_Global_Event)
VMM_Service (Cancel_VM_Event)
VMM_Service (Call_Priority_VM_Event)
VMM_Service (Cancel_Priority_VM_Event)

VMM_Service (Get_NMI_Handler_Addr)
VMM_Service (Set_NMI_Handler_Addr)
VMM_Service (Hook_NMI_Event)

VMM_Service (Call_When_VM_Ints_Enabled)
VMM_Service (Enable_VM_Ints)
VMM_Service (Disable_VM_Ints)

VMM_Service (Map_Flat)
VMM_Service (Map_Lin_To_VM_Addr)

//   Scheduler services

VMM_Service (Adjust_Exec_Priority)
VMM_Service (Begin_Critical_Section)
VMM_Service (End_Critical_Section)
VMM_Service (End_Crit_And_Suspend)
VMM_Service (Claim_Critical_Section)
VMM_Service (Release_Critical_Section)
VMM_Service (Call_When_Not_Critical)
VMM_Service (Create_Semaphore)
VMM_Service (Destroy_Semaphore)
VMM_Service (Wait_Semaphore)
VMM_Service (Signal_Semaphore)
VMM_Service (Get_Crit_Section_Status)
VMM_Service (Call_When_Task_Switched)
VMM_Service (Suspend_VM)
VMM_Service (Resume_VM)
VMM_Service (No_Fail_Resume_VM)
VMM_Service (Nuke_VM)
VMM_Service (Crash_Cur_VM)

VMM_Service (Get_Execution_Focus)
VMM_Service (Set_Execution_Focus)
VMM_Service (Get_Time_Slice_Priority)
VMM_Service (Set_Time_Slice_Priority)
VMM_Service (Get_Time_Slice_Granularity)
VMM_Service (Set_Time_Slice_Granularity)
VMM_Service (Get_Time_Slice_Info)
VMM_Service (Adjust_Execution_Time)
VMM_Service (Release_Time_Slice)
VMM_Service (Wake_Up_VM)
VMM_Service (Call_When_Idle)

VMM_Service (Get_Next_VM_Handle)

//   Time-out and system timer services

VMM_Service (Set_Global_Time_Out)
VMM_Service (Set_VM_Time_Out)
VMM_Service (Cancel_Time_Out)
VMM_Service (Get_System_Time)
VMM_Service (Get_VM_Exec_Time)

VMM_Service (Hook_V86_Int_Chain)
VMM_Service (Get_V86_Int_Vector)
VMM_Service (Set_V86_Int_Vector)
VMM_Service (Get_PM_Int_Vector)
VMM_Service (Set_PM_Int_Vector)

VMM_Service (Simulate_Int)
VMM_Service (Simulate_Iret)
VMM_Service (Simulate_Far_Call)
VMM_Service (Simulate_Far_Jmp)
VMM_Service (Simulate_Far_Ret)
VMM_Service (Simulate_Far_Ret_N)
VMM_Service (Build_Int_Stack_Frame)

VMM_Service (Simulate_Push)
VMM_Service (Simulate_Pop)

// Heap Manager

VMM_Service (_HeapAllocate)
VMM_Service (_HeapReAllocate)
VMM_Service (_HeapFree)
VMM_Service (_HeapGetSize)

/*ENDMACROS*/

/****************************************************
 *
 *   Flags for heap allocator calls
 *
 *   NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define HEAPZEROINIT    0x00000001
#define HEAPZEROREINIT  0x00000002
#define HEAPNOCOPY  0x00000004
#define HEAPLOCKEDIFDP  0x00000100
#define HEAPSWAP    0x00000200
#define HEAPINIT        0x00000400
#define HEAPCLEAN   0x00000800

// Page Manager

/*MACROS*/
VMM_Service (_PageAllocate)
VMM_Service (_PageReAllocate)
VMM_Service (_PageFree)
VMM_Service (_PageLock)
VMM_Service (_PageUnLock)
VMM_Service (_PageGetSizeAddr)
VMM_Service (_PageGetAllocInfo)
VMM_Service (_GetFreePageCount)
VMM_Service (_GetSysPageCount)
VMM_Service (_GetVMPgCount)
VMM_Service (_MapIntoV86)
VMM_Service (_PhysIntoV86)
VMM_Service (_TestGlobalV86Mem)
VMM_Service (_ModifyPageBits)
VMM_Service (_CopyPageTable)
VMM_Service (_LinMapIntoV86)
VMM_Service (_LinPageLock)
VMM_Service (_LinPageUnLock)
VMM_Service (_SetResetV86Pageable)
VMM_Service (_GetV86PageableArray)
VMM_Service (_PageCheckLinRange)
VMM_Service (_PageOutDirtyPages)
VMM_Service (_PageDiscardPages)
/*ENDMACROS*/

/****************************************************
 *
 *  Flags for other page allocator calls
 *
 *  NOTE: HIGH 8 BITS (bits 24-31) are reserved
 *
 ***************************************************/

#define PAGEZEROINIT        0x00000001
#define PAGEUSEALIGN        0x00000002
#define PAGECONTIG      0x00000004
#define PAGEFIXED       0x00000008
#define PAGEDEBUGNULFAULT   0x00000010
#define PAGEZEROREINIT      0x00000020
#define PAGENOCOPY      0x00000040
#define PAGELOCKED      0x00000080
#define PAGELOCKEDIFDP      0x00000100
#define PAGESETV86PAGEABLE  0x00000200
#define PAGECLEARV86PAGEABLE    0x00000400
#define PAGESETV86INTSLOCKED    0x00000800
#define PAGECLEARV86INTSLOCKED  0x00001000
#define PAGEMARKPAGEOUT     0x00002000
#define PAGEPDPSETBASE      0x00004000
#define PAGEPDPCLEARBASE    0x00008000
#define PAGEDISCARD     0x00010000
#define PAGEPDPQUERYDIRTY   0x00020000
#define PAGEMAPFREEPHYSREG  0x00040000
#define PAGENOMOVE      0x10000000
#define PAGEMAPGLOBAL       0x40000000
#define PAGEMARKDIRTY       0x80000000

/****************************************************
 *
 *      Flags for _PhysIntoV86,
 *      _MapIntoV86, and _LinMapIntoV86
 *
 ***************************************************/

#define MAPV86_IGNOREWRAP       0x00000001


// Informational services

/*MACROS*/
VMM_Service (_GetNulPageHandle)
VMM_Service (_GetFirstV86Page)
VMM_Service (_MapPhysToLinear)
VMM_Service (_GetAppFlatDSAlias)
VMM_Service (_SelectorMapFlat)
VMM_Service (_GetDemandPageInfo)
VMM_Service (_GetSetPageOutCount)
/*ENDMACROS*/

/*
 *  Flags bits for _GetSetPageOutCount
 */
#define GSPOC_F_GET 0x00000001

// Device VM page manager

/*MACROS*/
VMM_Service (Hook_V86_Page)
VMM_Service (_Assign_Device_V86_Pages)
VMM_Service (_DeAssign_Device_V86_Pages)
VMM_Service (_Get_Device_V86_Pages_Array)
VMM_Service (MMGR_SetNULPageAddr)

// GDT/LDT management

VMM_Service (_Allocate_GDT_Selector)
VMM_Service (_Free_GDT_Selector)
VMM_Service (_Allocate_LDT_Selector)
VMM_Service (_Free_LDT_Selector)
VMM_Service (_BuildDescriptorDWORDs)
VMM_Service (_GetDescriptor)
VMM_Service (_SetDescriptor)
/*ENDMACROS*/

/*
 *  Flag equates for _BuildDescriptorDWORDs
 */
#define BDDEXPLICITDPL  0x00000001

/*
 *  Flag equates for _Allocate_LDT_Selector
 */
#define ALDTSPECSEL 0x00000001

/*MACROS*/
VMM_Service (_MMGR_Toggle_HMA)
/*ENDMACROS*/

/*
 *  Flag equates for _MMGR_Toggle_HMA
 */
#define MMGRHMAPHYSICAL 0x00000001
#define MMGRHMAENABLE   0x00000002
#define MMGRHMADISABLE  0x00000004
#define MMGRHMAQUERY    0x00000008

/*MACROS*/
VMM_Service (Get_Fault_Hook_Addrs)
VMM_Service (Hook_V86_Fault)
VMM_Service (Hook_PM_Fault)
VMM_Service (Hook_VMM_Fault)
VMM_Service (Begin_Nest_V86_Exec)
VMM_Service (Begin_Nest_Exec)
VMM_Service (Exec_Int)
VMM_Service (Resume_Exec)
VMM_Service (End_Nest_Exec)

VMM_Service (Allocate_PM_App_CB_Area, VMM_ICODE)
VMM_Service (Get_Cur_PM_App_CB)

VMM_Service (Set_V86_Exec_Mode)
VMM_Service (Set_PM_Exec_Mode)

VMM_Service (Begin_Use_Locked_PM_Stack)
VMM_Service (End_Use_Locked_PM_Stack)

VMM_Service (Save_Client_State)
VMM_Service (Restore_Client_State)

VMM_Service (Exec_VxD_Int)

VMM_Service (Hook_Device_Service)

VMM_Service (Hook_Device_V86_API)
VMM_Service (Hook_Device_PM_API)

VMM_Service (System_Control)

//   I/O and software interrupt hooks

VMM_Service (Simulate_IO)
VMM_Service (Install_Mult_IO_Handlers)
VMM_Service (Install_IO_Handler)
VMM_Service (Enable_Global_Trapping)
VMM_Service (Enable_Local_Trapping)
VMM_Service (Disable_Global_Trapping)
VMM_Service (Disable_Local_Trapping)

//   Linked List Abstract Data Type Services

VMM_Service (List_Create)
VMM_Service (List_Destroy)
VMM_Service (List_Allocate)
VMM_Service (List_Attach)
VMM_Service (List_Attach_Tail)
VMM_Service (List_Insert)
VMM_Service (List_Remove)
VMM_Service (List_Deallocate)
VMM_Service (List_Get_First)
VMM_Service (List_Get_Next)
VMM_Service (List_Remove_First)
/*ENDMACROS*/

/*
 *   Flags used by List_Create
 */
#define LF_ASYNC_BIT        0
#define LF_ASYNC        (1 << LF_ASYNC_BIT)
#define LF_USE_HEAP_BIT     1
#define LF_USE_HEAP     (1 << LF_USE_HEAP_BIT)
#define LF_ALLOC_ERROR_BIT  2
#define LF_ALLOC_ERROR      (1 << LF_ALLOC_ERROR_BIT)
/*
 * Swappable lists must use the heap.
 */
#define LF_SWAP         (LF_USE_HEAP + (1 << 3))

/******************************************************************************
 *  I N I T I A L I Z A T I O N   P R O C E D U R E S
 ******************************************************************************/

// Instance data manager

/*MACROS*/
VMM_Service (_AddInstanceItem)

// System structure data manager

VMM_Service (_Allocate_Device_CB_Area)
VMM_Service (_Allocate_Global_V86_Data_Area, VMM_ICODE)
VMM_Service (_Allocate_Temp_V86_Data_Area, VMM_ICODE)
VMM_Service (_Free_Temp_V86_Data_Area, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flag bits for _Allocate_Global_V86_Data_Area
 */
#define GVDAWordAlign       0x00000001
#define GVDADWordAlign      0x00000002
#define GVDAParaAlign       0x00000004
#define GVDAPageAlign       0x00000008
#define GVDAInstance        0x00000100
#define GVDAZeroInit        0x00000200
#define GVDAReclaim	    0x00000400
#define GVDAInquire	    0x00000800
#define GVDAHighSysCritOK   0x00001000
#define GVDAOptInstance     0x00002000
#define GVDAForceLow	    0x00004000

/*
 *  Flag bits for _Allocate_Temp_V86_Data_Area
 */
#define TVDANeedTilInitComplete 0x00000001

// Initialization information calls (win.ini and environment parameters)

/*MACROS*/
VMM_Service (Get_Profile_Decimal_Int, VMM_ICODE)
VMM_Service (Convert_Decimal_String, VMM_ICODE)
VMM_Service (Get_Profile_Fixed_Point, VMM_ICODE)
VMM_Service (Convert_Fixed_Point_String, VMM_ICODE)
VMM_Service (Get_Profile_Hex_Int, VMM_ICODE)
VMM_Service (Convert_Hex_String, VMM_ICODE)
VMM_Service (Get_Profile_Boolean, VMM_ICODE)
VMM_Service (Convert_Boolean_String, VMM_ICODE)
VMM_Service (Get_Profile_String, VMM_ICODE)
VMM_Service (Get_Next_Profile_String, VMM_ICODE)
VMM_Service (Get_Environment_String, VMM_ICODE)
VMM_Service (Get_Exec_Path, VMM_ICODE)
VMM_Service (Get_Config_Directory, VMM_ICODE)
VMM_Service (OpenFile, VMM_ICODE)
/*ENDMACROS*/

// OpenFile, if called after init, must point EDI to a buffer of at least
// this size.

#define VMM_OPENFILE_BUF_SIZE       260

/*MACROS*/
VMM_Service (Get_PSP_Segment, VMM_ICODE)
VMM_Service (GetDOSVectors, VMM_ICODE)
VMM_Service (Get_Machine_Info)
/*ENDMACROS*/

#define GMIF_80486_BIT  0x10
#define GMIF_80486  (1 << GMIF_80486_BIT)
#define GMIF_PCXT_BIT   0x11
#define GMIF_PCXT   (1 << GMIF_PCXT_BIT)
#define GMIF_MCA_BIT    0x12
#define GMIF_MCA    (1 << GMIF_MCA_BIT)
#define GMIF_EISA_BIT   0x13
#define GMIF_EISA   (1 << GMIF_EISA_BIT)
#define GMIF_CPUID_BIT  0x14
#define GMIF_CPUID  (1 << GMIF_CPUID_BIT)

// Following service is not restricted to initialization

/*MACROS*/
VMM_Service (GetSet_HMA_Info)
VMM_Service (Set_System_Exit_Code)

VMM_Service (Fatal_Error_Handler)
VMM_Service (Fatal_Memory_Error)

//   Called by VTD only

VMM_Service (Update_System_Clock)

/******************************************************************************
 *          D E B U G G I N G   E X T E R N S
 ******************************************************************************/

VMM_Service (Test_Debug_Installed)      // Valid call in retail also

VMM_Service (Out_Debug_String)
VMM_Service (Out_Debug_Chr)
VMM_Service (In_Debug_Chr)
VMM_Service (Debug_Convert_Hex_Binary)
VMM_Service (Debug_Convert_Hex_Decimal)

VMM_Service (Debug_Test_Valid_Handle)
VMM_Service (Validate_Client_Ptr)
VMM_Service (Test_Reenter)
VMM_Service (Queue_Debug_String)
VMM_Service (Log_Proc_Call)
VMM_Service (Debug_Test_Cur_VM)

VMM_Service (Get_PM_Int_Type)
VMM_Service (Set_PM_Int_Type)

VMM_Service (Get_Last_Updated_System_Time)
VMM_Service (Get_Last_Updated_VM_Exec_Time)

VMM_Service (Test_DBCS_Lead_Byte)       // for DBCS Enabling
/*ENDMACROS*/

/* ASM
.errnz  @@Test_DBCS_Lead_Byte - 100D1h   ; VMM service table changed above this service
*/

/*************************************************************************
 *************************************************************************
 * END OF 3.00 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service (_AddFreePhysPage, VMM_ICODE)
VMM_Service (_PageResetHandlePAddr)
VMM_Service (_SetLastV86Page, VMM_ICODE)
VMM_Service (_GetLastV86Page)
VMM_Service (_MapFreePhysReg)
VMM_Service (_UnmapFreePhysReg)
VMM_Service (_XchgFreePhysReg)
VMM_Service (_SetFreePhysRegCalBk, VMM_ICODE)
VMM_Service (Get_Next_Arena, VMM_ICODE)
VMM_Service (Get_Name_Of_Ugly_TSR, VMM_ICODE)
VMM_Service (Get_Debug_Options, VMM_ICODE)
/*ENDMACROS*/

/*
 *  Flags for AddFreePhysPage
 */
#define AFPP_SWAPOUT     0x0001 // physical memory that must be swapped out
                                // and subsequently restored at system exit
/*
 *  Flags for PageChangePager
 */
#define PCP_CHANGEPAGER     0x1 // change the pager for the page range
#define PCP_CHANGEPAGERDATA 0x2 // change the pager data dword for the pages
#define PCP_VIRGINONLY      0x4 // make the above changes to virgin pages only


/*
 *  Bits for the ECX return of Get_Next_Arena
 */
#define GNA_HIDOSLINKED  0x0002 // High DOS arenas linked when WIN386 started
#define GNA_ISHIGHDOS    0x0004 // High DOS arenas do exist

/*MACROS*/
VMM_Service (Set_Physical_HMA_Alias, VMM_ICODE)
VMM_Service (_GetGlblRng0V86IntBase, VMM_ICODE)
VMM_Service (_Add_Global_V86_Data_Area, VMM_ICODE)

VMM_Service (GetSetDetailedVMError)
/*ENDMACROS*/

/*
 *  Error code values for the GetSetDetailedVMError service. PLEASE NOTE
 *  that all of these error code values need to have bits set in the high
 *  word. This is to prevent collisions with other VMDOSAPP standard errors.
 *  Also, the low word must be non-zero.
 *
 *  First set of errors (high word = 0001) are intended to be used
 *  when a VM is CRASHED (VNE_Crashed or VNE_Nuked bit set on
 *  VM_Not_Executeable).
 *
 *  PLEASE NOTE that each of these errors (high word == 0001) actually
 *  has two forms:
 *
 *  0001xxxxh
 *  8001xxxxh
 *
 *  The device which sets the error initially always sets the error with
 *  the high bit CLEAR. The system will then optionally set the high bit
 *  depending on the result of the attempt to "nicely" crash the VM. This
 *  bit allows the system to tell the user whether the crash is likely or
 *  unlikely to destabalize the system.
 */
#define GSDVME_PRIVINST     0x00010001  /* Privledged instruction */
#define GSDVME_INVALINST    0x00010002  /* Invalid instruction */
#define GSDVME_INVALPGFLT   0x00010003  /* Invalid page fault */
#define GSDVME_INVALGPFLT   0x00010004  /* Invalid GP fault */
#define GSDVME_INVALFLT     0x00010005  /* Unspecified invalid fault */
#define GSDVME_USERNUKE     0x00010006  /* User requested NUKE of VM */
#define GSDVME_DEVNUKE      0x00010007  /* Device specific problem */
#define GSDVME_DEVNUKEHDWR  0x00010008  /* Device specific problem:
                         *   invalid hardware fiddling
                         *   by VM (invalid I/O)
                         */
#define GSDVME_NUKENOMSG    0x00010009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */
#define GSDVME_OKNUKEMASK   0x80000000  /* "Nice nuke" bit */

/*
 *  Second set of errors (high word = 0002) are intended to be used
 *  when a VM start up is failed (VNE_CreateFail, VNE_CrInitFail, or
 *  VNE_InitFail bit set on VM_Not_Executeable).
 */
#define GSDVME_INSMEMV86    0x00020001  /* base V86 mem    - V86MMGR */
#define GSDVME_INSV86SPACE  0x00020002  /* Kb Req too large - V86MMGR */
#define GSDVME_INSMEMXMS    0x00020003  /* XMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMEMS    0x00020004  /* EMS Kb Req      - V86MMGR */
#define GSDVME_INSMEMV86HI  0x00020005  /* Hi DOS V86 mem   - DOSMGR
                         *           V86MMGR
                         */
#define GSDVME_INSMEMVID    0x00020006  /* Base Video mem   - VDD */
#define GSDVME_INSMEMVM     0x00020007  /* Base VM mem     - VMM
                         *   CB, Inst Buffer
                         */
#define GSDVME_INSMEMDEV    0x00020008  /* Couldn't alloc base VM
                         * memory for device.
                         */
#define GSDVME_CRTNOMSG     0x00020009  /* Supress standard messages:
                         *   SHELL_Message used for
                         *   custom msg.
                         */

/*MACROS*/
VMM_Service (Is_Debug_Chr)

//   Mono_Out services

VMM_Service (Clear_Mono_Screen)
VMM_Service (Out_Mono_Chr)
VMM_Service (Out_Mono_String)
VMM_Service (Set_Mono_Cur_Pos)
VMM_Service (Get_Mono_Cur_Pos)
VMM_Service (Get_Mono_Chr)

//   Service locates a byte in ROM

VMM_Service (Locate_Byte_In_ROM, VMM_ICODE)

VMM_Service (Hook_Invalid_Page_Fault)
VMM_Service (Unhook_Invalid_Page_Fault)
/*ENDMACROS*/

/*
 *  Flag bits of IPF_Flags
 */
#define IPF_PGDIR   0x00000001  /* Page directory entry not-present */
#define IPF_V86PG   0x00000002  /* Unexpected not present Page in V86 */
#define IPF_V86PGH  0x00000004  /* Like IPF_V86PG at high linear */
#define IPF_INVTYP  0x00000008  /* page has invalid not present type */
#define IPF_PGERR   0x00000010  /* pageswap device failure */
#define IPF_REFLT   0x00000020  /* re-entrant page fault */
#define IPF_VMM     0x00000040  /* Page fault caused by a VxD */
#define IPF_PM      0x00000080  /* Page fault by VM in Prot Mode */
#define IPF_V86     0x00000100  /* Page fault by VM in V86 Mode */

/*MACROS*/
VMM_Service (Set_Delete_On_Exit_File)

VMM_Service (Close_VM)
/*ENDMACROS*/

/*
 *   Flags for Close_VM service
 */

#define CVF_CONTINUE_EXEC_BIT   0
#define CVF_CONTINUE_EXEC   (1 << CVF_CONTINUE_EXEC_BIT)

/*MACROS*/
VMM_Service (Enable_Touch_1st_Meg)      // Debugging only
VMM_Service (Disable_Touch_1st_Meg)     // Debugging only

VMM_Service (Install_Exception_Handler)
VMM_Service (Remove_Exception_Handler)

VMM_Service (Get_Crit_Status_No_Block)
/*ENDMACROS*/

/* ASM
; Check if VMM service table has changed above this service
.errnz   @@Get_Crit_Status_No_Block - 100F1h
*/

#ifdef WIN40SERVICES

/*************************************************************************
 *************************************************************************
 *
 * END OF 3.10 SERVICE TABLE MUST NOT SHUFFLE SERVICES BEFORE THIS POINT
 *  FOR COMPATIBILITY.
 *************************************************************************
 *************************************************************************/

/*MACROS*/
VMM_Service     (_GetLastUpdatedThreadExecTime)

VMM_Service (_Trace_Out_Service)
VMM_Service (_Debug_Out_Service)
VMM_Service (_Debug_Flags_Service)
/*ENDMACROS*/

#endif /* WIN40SERVICES */


/*
 *   Flags for _Debug_Flags_Service service.
 *
 *   Don't change these unless you really really know what you're doing.
 *   We need to define these even if we are in WIN31COMPAT mode.
 */

#define DFS_LOG_BIT         0
#define DFS_LOG             (1 << DFS_LOG_BIT)
#define DFS_PROFILE_BIT         1
#define DFS_PROFILE         (1 << DFS_PROFILE_BIT)
#define DFS_TEST_CLD_BIT        2
#define DFS_TEST_CLD            (1 << DFS_TEST_CLD_BIT)
#define DFS_NEVER_REENTER_BIT       3
#define DFS_NEVER_REENTER       (1 << DFS_NEVER_REENTER_BIT)
#define DFS_TEST_REENTER_BIT        4
#define DFS_TEST_REENTER        (1 << DFS_TEST_REENTER_BIT)
#define DFS_NOT_SWAPPING_BIT        5
#define DFS_NOT_SWAPPING        (1 << DFS_NOT_SWAPPING_BIT)
#define DFS_TEST_BLOCK_BIT      6
#define DFS_TEST_BLOCK          (1 << DFS_TEST_BLOCK_BIT)

#define DFS_RARE_SERVICES	0xFFFFFF80

#define DFS_EXIT_NOBLOCK        (DFS_RARE_SERVICES+0)
#define DFS_ENTER_NOBLOCK       (DFS_RARE_SERVICES+DFS_TEST_BLOCK)

#define DFS_TEST_NEST_EXEC	(DFS_RARE_SERVICES+1)

#ifdef WIN40SERVICES

/*MACROS*/
VMM_Service (VMMAddImportModuleName)

VMM_Service (VMM_Add_DDB)
VMM_Service (VMM_Remove_DDB)

VMM_Service     (Test_VM_Ints_Enabled)
VMM_Service     (_BlockOnID)

VMM_Service     (Schedule_Thread_Event)
VMM_Service (Cancel_Thread_Event)
VMM_Service (Set_Thread_Time_Out)
VMM_Service (Set_Async_Time_Out)

VMM_Service (_AllocateThreadDataSlot)
VMM_Service (_FreeThreadDataSlot)
/*ENDMACROS*/

/*
 *  Flag equates for _CreateMutex
 */
#define         MUTEX_MUST_COMPLETE         1L

/*MACROS*/
VMM_Service     (_CreateMutex)

VMM_Service     (_DestroyMutex)
VMM_Service     (_GetMutexOwner)
VMM_Service (Call_When_Thread_Switched)

VMM_Service     (VMMCreateThread)
VMM_Service     (_GetThreadExecTime)
VMM_Service     (VMMTerminateThread)

VMM_Service     (Get_Cur_Thread_Handle)
VMM_Service     (Test_Cur_Thread_Handle)
VMM_Service     (Get_Sys_Thread_Handle)
VMM_Service     (Test_Sys_Thread_Handle)
VMM_Service     (Validate_Thread_Handle)
VMM_Service     (Get_Initial_Thread_Handle)
VMM_Service     (Test_Initial_Thread_Handle)
VMM_Service     (Debug_Test_Valid_Thread_Handle)
VMM_Service (Debug_Test_Cur_Thread)

VMM_Service (VMM_GetSystemInitState)

VMM_Service     (Cancel_Call_When_Thread_Switched)
VMM_Service     (Get_Next_Thread_Handle)
VMM_Service     (Adjust_Thread_Exec_Priority)

VMM_Service (_Deallocate_Device_CB_Area)
VMM_Service (Remove_IO_Handler)
VMM_Service (Remove_Mult_IO_Handlers)
VMM_Service (Unhook_V86_Int_Chain)
VMM_Service (Unhook_V86_Fault)
VMM_Service (Unhook_PM_Fault)
VMM_Service (Unhook_VMM_Fault)
VMM_Service (Unhook_Device_Service)

VMM_Service (_PageReserve)
VMM_Service (_PageCommit)
VMM_Service (_PageDecommit)
VMM_Service (_PagerRegister)
VMM_Service (_PagerQuery)
VMM_Service (_PagerDeregister)
VMM_Service (_ContextCreate)
VMM_Service (_ContextDestroy)
VMM_Service (_PageAttach)
VMM_Service (_PageFlush)
VMM_Service     (_SignalID)
VMM_Service (_PageCommitPhys)

VMM_Service (_Register_Win32_Services)

VMM_Service (Cancel_Call_When_Not_Critical)
VMM_Service (Cancel_Call_When_Idle)
VMM_Service (Cancel_Call_When_Task_Switched)

VMM_Service (_Debug_Printf_Service)
VMM_Service     (_EnterMutex)
VMM_Service     (_LeaveMutex)
VMM_Service     (Simulate_VM_IO)
VMM_Service     (Signal_Semaphore_No_Switch)

VMM_Service (_ContextSwitch)
VMM_Service (_PageModifyPermissions)
VMM_Service (_PageQuery)

VMM_Service     (_EnterMustComplete)
VMM_Service     (_LeaveMustComplete)
VMM_Service     (_ResumeExecMustComplete)
/*ENDMACROS*/

/*
 *  Flag equates for _GetThreadTerminationStatus
 */
#define THREAD_TERM_STATUS_CRASH_PEND       1L
#define THREAD_TERM_STATUS_NUKE_PEND        2L
#define THREAD_TERM_STATUS_SUSPEND_PEND     4L

/*MACROS*/
VMM_Service     (_GetThreadTerminationStatus)
VMM_Service     (_GetInstanceInfo)
/*ENDMACROS*/

/*
 *  Return values for _GetInstanceInfo
 */
#define INSTINFO_NONE   0       /* no data instanced in range */
#define INSTINFO_SOME   1       /* some data instanced in range */
#define INSTINFO_ALL    2       /* all data instanced in range */

/*MACROS*/
VMM_Service     (_ExecIntMustComplete)
VMM_Service (_ExecVxDIntMustComplete)

VMM_Service (Begin_V86_Serialization)

VMM_Service (Unhook_V86_Page)
VMM_Service (VMM_GetVxDLocationList)
VMM_Service (VMM_GetDDBList)
VMM_Service (Unhook_NMI_Event)

VMM_Service (Get_Instanced_V86_Int_Vector)
VMM_Service (Get_Set_Real_DOS_PSP)
/*ENDMACROS*/

#define GSRDP_Set   0x0001

/*MACROS*/
VMM_Service     (Call_Priority_Thread_Event)
VMM_Service     (Get_System_Time_Address)
VMM_Service (Get_Crit_Status_Thread)

VMM_Service (Get_DDB)
VMM_Service (Directed_Sys_Control)
/*ENDMACROS*/

// Registry APIs for VxDs
/*MACROS*/
VMM_Service (_RegOpenKey)
VMM_Service (_RegCloseKey)
VMM_Service (_RegCreateKey)
VMM_Service (_RegDeleteKey)
VMM_Service (_RegEnumKey)
VMM_Service (_RegQueryValue)
VMM_Service (_RegSetValue)
VMM_Service (_RegDeleteValue)
VMM_Service (_RegEnumValue)
VMM_Service (_RegQueryValueEx)
VMM_Service (_RegSetValueEx)
/*ENDMACROS*/

#ifndef REG_SZ      // define only if not there already

#define REG_SZ      0x0001
#define REG_BINARY  0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE  // define only if not there already

#define HKEY_CLASSES_ROOT       0x80000000
#define HKEY_CURRENT_USER       0x80000001
#define HKEY_LOCAL_MACHINE      0x80000002
#define HKEY_USERS          0x80000003
#define HKEY_PERFORMANCE_DATA       0x80000004
#define HKEY_CURRENT_CONFIG     0x80000005
#define HKEY_DYN_DATA       0x80000006

#endif

/*MACROS*/
VMM_Service (_CallRing3)
VMM_Service (Exec_PM_Int)
VMM_Service (_RegFlushKey)
VMM_Service (_PageCommitContig)
VMM_Service (_GetCurrentContext)

VMM_Service     (_LocalizeSprintf)
VMM_Service     (_LocalizeStackSprintf)

VMM_Service (Call_Restricted_Event)
VMM_Service (Cancel_Restricted_Event)

VMM_Service (Register_PEF_Provider, VMM_ICODE)

VMM_Service     (_GetPhysPageInfo)

VMM_Service (_RegQueryInfoKey)
VMM_Service     (MemArb_Reserve_Pages)
/*ENDMACROS*/

/*
 *  Return values for _GetPhysPageInfo
 */
#define PHYSINFO_NONE   0       /* no pages in the specified range exist */
#define PHYSINFO_SOME   1       /* some pages in the specified range exist */
#define PHYSINFO_ALL    2       /* all pages in the specified range exist */

// New timeslicer services
/*MACROS*/
VMM_Service     (Time_Slice_Sys_VM_Idle)
VMM_Service     (Time_Slice_Sleep)
VMM_Service     (Boost_With_Decay)
VMM_Service     (Set_Inversion_Pri)
VMM_Service     (Reset_Inversion_Pri)
VMM_Service     (Release_Inversion_Pri)
VMM_Service     (Get_Thread_Win32_Pri)
VMM_Service     (Set_Thread_Win32_Pri)
VMM_Service     (Set_Thread_Static_Boost)
VMM_Service     (Set_VM_Static_Boost)
VMM_Service     (Release_Inversion_Pri_ID)
VMM_Service     (Attach_Thread_To_Group)
VMM_Service     (Detach_Thread_From_Group)
VMM_Service     (Set_Group_Static_Boost)

VMM_Service (_GetRegistryPath, VMM_ICODE)
VMM_Service (_GetRegistryKey)
/*ENDMACROS*/

// TYPE definitions for _GetRegistryKey

#define REGTYPE_ENUM    0
#define REGTYPE_CLASS   1
#define REGTYPE_VXD     2

// Flag definitions for _GetRegistryKey
#define REGKEY_OPEN                 0
#define REGKEY_CREATE_IFNOTEXIST    1

// Flag definitions for _Assert_Range
#define ASSERT_RANGE_NULL_BAD   0x00000000
#define ASSERT_RANGE_NULL_OK    0x00000001
#define ASSERT_RANGE_NO_DEBUG   0x80000000
#define ASSERT_RANGE_BITS       0x80000001

/*MACROS*/
VMM_Service (Cleanup_Thread_State)
VMM_Service (_RegRemapPreDefKey)
VMM_Service (End_V86_Serialization)
VMM_Service (_Assert_Range)
VMM_Service (_Sprintf)
VMM_Service (_PageChangePager)
VMM_Service (_RegCreateDynKey)
VMM_Service (_RegQMulti)

// Additional timeslicer services
VMM_Service     (Boost_Thread_With_VM)
/*ENDMACROS*/

// Flag definitions for Get_Boot_Flags

#define BOOT_CLEAN              0x00000001
#define BOOT_DOSCLEAN           0x00000002
#define BOOT_NETCLEAN           0x00000004
#define BOOT_INTERACTIVE        0x00000008

/*MACROS*/
VMM_Service     (Get_Boot_Flags)
VMM_Service     (Set_Boot_Flags)

// String and memory services
VMM_Service (_lstrcpyn)
VMM_Service (_lstrlen)
VMM_Service (_lmemcpy)

VMM_Service     (_GetVxDName)

// For vwin32 use only
VMM_Service (Force_Mutexes_Free)
VMM_Service (Restore_Forced_Mutexes)
/*ENDMACROS*/

// Reclaimable low memory services
/*MACROS*/
VMM_Service     (_AddReclaimableItem)
VMM_Service     (_SetReclaimableItem)
VMM_Service     (_EnumReclaimableItem)
/*ENDMACROS*/

// completely wake sys VM from idle state
/*MACROS*/
VMM_Service	(Time_Slice_Wake_Sys_VM)
VMM_Service	(VMM_Replace_Global_Environment)
VMM_Service	(Begin_Non_Serial_Nest_V86_Exec)
VMM_Service	(Get_Nest_Exec_Status)
/*ENDMACROS*/

#endif /* WIN40SERVICES */

/*MACROS*/
End_Service_Table(VMM, VMM)
/*ENDMACROS*/

/*XLATOFF*/
#pragma warning (default:4003)          // turn on not enough params warning
/*XLATON*/

// Flag definitions for _Add/_Set/_EnumReclaimableItem

#define RS_RECLAIM              0x00000001
#define RS_RESTORE              0x00000002
#define RS_DOSARENA             0x00000004

// Structure definition for _EnumReclaimableItem

struct ReclaimStruc {
    ULONG   RS_Linear;                  // low (< 1meg) address of item
    ULONG   RS_Bytes;                   // size of item in bytes
    ULONG   RS_CallBack;                // callback, if any (zero if none)
    ULONG   RS_RefData;                 // reference data for callback, if any
    ULONG   RS_HookTable;               // real-mode hook table (zero if none)
    ULONG   RS_Flags;                   // 0 or more of the RS_* equates
};

typedef struct ReclaimStruc *PReclaimStruc;

//
// Structures for Force_Mutexes_Free/Restore_Forced_Mutexes
//
typedef struct frmtx {
    struct frmtx *frmtx_pfrmtxNext;
    DWORD frmtx_hmutex;
    DWORD frmtx_cEnterCount;
    DWORD frmtx_pthcbOwner;
    DWORD frmtx_htimeout;
} FRMTX;

typedef struct vmmfrinfo {
    struct frmtx vmmfrinfo_frmtxDOS;
    struct frmtx vmmfrinfo_frmtxV86;
    struct frmtx vmmfrinfo_frmtxOther;
} VMMFRINFO;

/*
 *  Data structure for _GetDemandPageInfo
 */
struct DemandInfoStruc {
    ULONG DILin_Total_Count;    /* # pages in linear address space */
    ULONG DIPhys_Count;         /* Count of phys pages */
    ULONG DIFree_Count;         /* Count of free phys pages */
    ULONG DIUnlock_Count;       /* Count of unlocked Phys Pages */
    ULONG DILinear_Base_Addr;   /* Base of pageable address space */
    ULONG DILin_Total_Free;     /* Total Count of free linear pages */

    /*
     *  The following 5 fields are all running totals, kept from the time
     *  the system was started
     */
    ULONG DIPage_Faults;        /* total page faults */
    ULONG DIPage_Ins;           /* calls to pagers to page in a page */
    ULONG DIPage_Outs;          /* calls to pagers to page out a page*/
    ULONG DIPage_Discards;      /* pages discarded w/o calling pager */
    ULONG DIInstance_Faults;    /* instance page faults */

    ULONG DIPagingFileMax;      /* maximum # of pages that could be in paging file */
    ULONG DIPagingFileInUse;    /* # of pages of paging file currently in use */

    ULONG DICommit_Count;       /* Total committed memory, in pages */

    ULONG DIReserved[2];        /* Reserved for expansion */
};

/*
 *  Data structure for _AddInstanceItem
 */
struct InstDataStruc {
    ULONG InstLinkF;        /* INIT <0> RESERVED */
    ULONG InstLinkB;        /* INIT <0> RESERVED */
    ULONG InstLinAddr;      /* Linear address of start of block */
    ULONG InstSize;         /* Size of block in bytes */
    ULONG InstType;         /* Type of block */
};

/*
 *  Values for InstType
 */
#define INDOS_FIELD     0x100   /* Bit indicating INDOS switch requirements */
#define ALWAYS_FIELD    0x200   /* Bit indicating ALWAYS switch requirements */
#define OPTIONAL_FIELD  0x400   /* Bit indicating optional instancing requirements */

/*
 *  Data structure for Hook_Invalid_Page_Fault handlers.
 *
 *  This is the structure of the "invalid page fault information"
 *  which is pointed to by EDI when Invalid page fault hookers
 *  are called.
 *
 *  Page faults can occur on a VM which is not current by touching the VM at
 *  its high linear address.  In this case, IPF_FaultingVM may not be the
 *  current VM, it will be set to the VM whos high linear address was touched.
 */

struct IPF_Data {
    ULONG IPF_LinAddr;      /* CR2 address of fault */
    ULONG IPF_MapPageNum;   /* Possible converted page # of fault */
    ULONG IPF_PTEEntry;     /* Contents of PTE that faulted */
    ULONG IPF_FaultingVM;   /* May not = Current VM (IPF_V86PgH set) */
    ULONG IPF_Flags;        /* Flags */
};

/*
 *
 * Install_Exception_Handler data structure
 *
 */

struct Exception_Handler_Struc {
    ULONG EH_Reserved;
    ULONG EH_Start_EIP;
    ULONG EH_End_EIP;
    ULONG EH_Handler;
};

/*
 *  Flags passed in new memory manager functions
 */

/* PageReserve arena values */
#define PR_PRIVATE  0x80000400  /* anywhere in private arena */
#define PR_SHARED   0x80060000  /* anywhere in shared arena */
#define PR_SYSTEM   0x80080000  /* anywhere in system arena */

/* PageReserve flags */
#define PR_FIXED    0x00000008  /* don't move during PageReAllocate */
#define PR_4MEG     0x00000001  /* allocate on 4mb boundary */
#define PR_STATIC   0x00000010  /* see PageReserve documentation */

/* PageCommit default pager handle values */
#define PD_ZEROINIT 0x00000001  /* swappable zero-initialized pages */
#define PD_NOINIT   0x00000002  /* swappable uninitialized pages */
#define PD_FIXEDZERO    0x00000003  /* fixed zero-initialized pages */
#define PD_FIXED    0x00000004  /* fixed uninitialized pages */

/* PageCommit flags */
#define PC_FIXED    0x00000008  /* pages are permanently locked */
#define PC_LOCKED   0x00000080  /* pages are made present and locked*/
#define PC_LOCKEDIFDP   0x00000100  /* pages are locked if swap via DOS */
#define PC_WRITEABLE    0x00020000  /* make the pages writeable */
#define PC_USER     0x00040000  /* make the pages ring 3 accessible */
#define PC_INCR     0x40000000  /* increment "pagerdata" each page */
#define PC_PRESENT  0x80000000  /* make pages initially present */
#define PC_STATIC   0x20000000  /* allow commit in PR_STATIC object */
#define PC_DIRTY    0x08000000  /* make pages initially dirty */

/* PageCommitContig additional flags */
#define PCC_ZEROINIT    0x00000001  /* zero-initialize new pages */
#define PCC_NOLIN   0x10000000  /* don't map to any linear address */

/*
 *  Structure and flags for PageQuery
 */
#ifndef _WINNT_
typedef struct _MEMORY_BASIC_INFORMATION {
    ULONG mbi_BaseAddress;
    ULONG mbi_AllocationBase;
    ULONG mbi_AllocationProtect;
    ULONG mbi_RegionSize;
    ULONG mbi_State;
    ULONG mbi_Protect;
    ULONG mbi_Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

#define PAGE_NOACCESS          0x01
#define PAGE_READONLY          0x02
#define PAGE_READWRITE         0x04
#define MEM_COMMIT           0x1000
#define MEM_RESERVE          0x2000
#define MEM_FREE            0x10000
#define MEM_PRIVATE         0x20000
#endif


/***ET+ PD - Pager Descriptor
 *
 *  A PD describes a set of routines to call to bring a page into
 *  the system or to get it out.  Each committed page in the system
 *  has an associated PD, a handle to which is stored in the page's
 *  VP.
 *
 *  For any field that is 0, the pager will not be notified
 *  when that action takes place.
 *
 *  For the purpose of pagers, a page can be in one of the two states
 *  describing its current contents:
 *
 *      clean - page has not been written to since its last page out
 *      dirty - page has been written to since its last page out
 *
 *  A page also is in one of two persistent states:
 *
 *      virgin - page has never been written to since it was committed
 *      tainted - page has been written to since it was committed
 *
 *  Note that a tainted page may be either dirty or clean, but a
 *  virgin page is by definition clean.
 *
 *  Examples of PDs:
 *
 *      For 32-bit EXE code or read-only data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = 0
 *        pd_cleanout = 0
 *        pd_dirtyout = 0
 *        pd_virginfree = 0
 *	  pd_taintedfree = 0
 *	  pd_dirty = 0
 *        pd_type = PD_PAGERONLY
 *
 *      For 32-bit EXE writeable data:
 *
 *        pd_virginin = routine to load page from an exe file
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 *
 *      For zero-initialized swappable data:
 *
 *        pd_virginin = routine to zero-fill a page
 *        pd_taintedin = routine to load page from swap file
 *        pd_cleanout = 0
 *        pd_dirtyout = routine to write a page out to the swap file
 *        pd_virginfree = 0
 *        pd_taintedfree = routine to free page from the swap file
 *        pd_dirty = routine to free page from the swap file
 *        pd_type = PD_SWAPPER
 */
/* typedefs for various pager functions */

typedef ULONG _cdecl FUNPAGE(PULONG ppagerdata, PVOID ppage, ULONG faultpage);

typedef FUNPAGE * PFUNPAGE;

struct pd_s {
    /*
     *  The following four fields are entry points in the pager which
     *  we call to page in or page out a page.  The following parameters
     *  are passed to the pager during these calls:
     *
     *  ppagerdata - pointer to the pager-specific dword of data
     *           stored with the virtual page.  The pager is
     *           free to modify the contents of this dword
     *           DURING the page in or out, but not afterwards.
     *
     *  ppage - pointer to page going in or out (a ring 0 alias
     *      to the physical page).  The pager should use this
     *      address to access the contents of the page.
     *
     *  faultpage - faulting linear page number for page-ins, -1 for
     *          page-outs.  This address should not be accessed
     *          by the pager.  It is provided for information
     *          only.  Note that a single page can be mapped at
     *          more than one linear address because of the
     *          MapIntoV86 and LinMapIntoV86 services.
     *
     *  The pager should return non-0 if the page was successfully
     *  paged, or 0 if it failed.
     */
    PFUNPAGE pd_virginin;   /* in - while page has never been written to */
    PFUNPAGE pd_taintedin;  /* in - page written to at least once */
    PFUNPAGE pd_cleanout;   /* out - page not written to since last out */
    PFUNPAGE pd_dirtyout;   /* out - page was written to since last out */

    /*
     *  The pd_*free routines are used to inform the pager when the last
     *  reference to a virtual page controlled by the pager is
     *  decommitted.  A common use of this notification is to
     *  free space in a backing file, or write the page contents
     *  into the backing file.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions, but no return value is recognized.  The "ppage"
     *  and "faultpage" parameters will always be 0.
     */
    PFUNPAGE pd_virginfree;  /* decommit of never-written-to page */
    PFUNPAGE pd_taintedfree; /* decommit of page written to at least once*/

    /*
     *  The pd_dirty routine is used to inform the pager when the
     *  memory manager detects that a page has been written to.  The memory
     *  manager does not detect the write at the instant it occurs, so
     *  the pager should not depend upon prompt notification.  A common
     *  use of this notification might be to invalidate cached data.
     *  If the page was dirtied in more than one memory context,
     *  the pager's pd_dirty routine will be called once for each
     *  context.
     *
     *  These calls take the same parameters as the page-out and -in
     *  functions except that the "ppage" parameter isn't valid and
     *  no return value is recognized.
     */
    PFUNPAGE pd_dirty;

    /*
     *  The pd_type field gives the sytem information about the
     *  overcommit characteristics of pages controlled by this pager.
     *  The following are allowable values for the field:
     *
     *  PD_SWAPPER - under some conditions, pages of this type
     *		may be paged out into the swap file
     *  PD_PAGERONLY - pages controlled by this pager will never
     *		be paged out to the swap file
     *
     *	In addition, the following value may be or'ed in to the pd_type field:
     *
     *	PD_NESTEXEC - must be specified if either the pd_cleanout or pd_dirtyout
     *		functions perform nested excecution or block using the
     *		BLOCK_SVC_INTS flag.  To be safe, this flag should always be
     *		specified if the pager does any sort of file i/o to anything
     *		other than the default paging file.
     */
    ULONG pd_type;
};
typedef struct pd_s PD;
typedef PD * PPD;

/* values for pd_type */
#define PD_SWAPPER	0   /* pages need direct accounting in swap file */
#define PD_PAGERONLY    1   /* pages will never be swapped */
#define PD_NESTEXEC	2   /* page out funtion uses nested execution */

#endif // Not_VxD

/*
 *  The size of a page of memory
 */
#define PAGESHIFT   12
#define PAGESIZE    (1 << PAGESHIFT)
#define PAGEMASK    (PAGESIZE - 1)

#define PAGE(p) ((DWORD)(p) >> PAGESHIFT)
#define NPAGES(cb) (((DWORD)(cb) + PAGEMASK) >> PAGESHIFT)

/*
 *  Address space (arena) boundaries
 */
#define MAXSYSTEMLADDR      ((ULONG) 0xffbfffff)    /* 4 gig - 4meg */
#define MINSYSTEMLADDR      ((ULONG) 0xc0000000)    /* 3 gig */
#define MAXSHAREDLADDR      ((ULONG) 0xbfffffff)
#define MINSHAREDLADDR      ((ULONG) 0x80000000)    /* 2   gig */
#define MAXPRIVATELADDR     ((ULONG) 0x7fffffff)
#define MINPRIVATELADDR     ((ULONG) 0x00400000)    /* 4 meg */
#define MAXDOSLADDR     ((ULONG) 0x003fffff)
#define MINDOSLADDR     ((ULONG) 0x00000000)

#define MAXSYSTEMPAGE       (MAXSYSTEMLADDR >> PAGESHIFT)
#define MINSYSTEMPAGE       (MINSYSTEMLADDR >> PAGESHIFT)
#define MAXSHAREDPAGE       (MAXSHAREDLADDR >> PAGESHIFT)
#define MINSHAREDPAGE       (MINSHAREDLADDR >> PAGESHIFT)
#define MAXPRIVATEPAGE      (MAXPRIVATELADDR >> PAGESHIFT)
#define MINPRIVATEPAGE      (MINPRIVATELADDR >> PAGESHIFT)
#define MAXDOSPAGE      (MAXDOSLADDR >> PAGESHIFT)
#define MINDOSPAGE      (MINDOSLADDR >> PAGESHIFT)

#define CBPRIVATE       (1 + MAXPRIVATELADDR - MINPRIVATELADDR)
#define CBSHARED        (1 + MAXSHAREDLADDR - MINSHAREDLADDR)
#define CBSYSTEM        (1 + MAXSYSTEMLADDR - MINSYSTEMLADDR)
#define CBDOS           (1 + MAXDOSLADDR - MINDOSLADDR)

#define CPGPRIVATE      (1 + MAXPRIVATEPAGE - MINPRIVATEPAGE)
#define CPGSHARED       (1 + MAXSHAREDPAGE - MINSHAREDPAGE)
#define CPGSYSTEM       (1 + MAXSYSTEMPAGE - MINSYSTEMPAGE)
#define CPGDOS          (1 + MAXDOSPAGE - MINDOSPAGE)

/*XLATOFF*/
/*
 *  Largest object that could theoretically be allocated
 */
#define CBMAXALLOC      (max(CBSHARED,max(CBPRIVATE, CBSYSTEM)))
#define CPGMAXALLOC     (max(CPGSHARED,max(CPGPRIVATE, CPGSYSTEM)))

/*XLATON*/

/* ASM
IFDEF DEBUG
DebFar  EQU NEAR PTR
ELSE
DebFar  EQU SHORT
ENDIF
*/

#ifndef Not_VxD

/******************************************************************************
 *
 *           EQUATES FOR SYSTEM_CONTROL CALLS
 *
 *****************************************************************************/

/*
 *  SYS_CRITICAL_INIT is a device init call.  Devices that have a
 *  critical function that needs initializing before interrupts are
 *  enabled should do it at Sys_Critical_Init.  Devices which REQUIRE a
 *  certain range of V86 pages to operate (such as the VDD video memory)
 *  should claim them at Sys_Critical_Init.  SYS VM Simulate_Int,
 *  Exec_Int ACTIVITY IS NOT ALLOWED.  Returning carry aborts device
 *  load only.
 */
#define SYS_CRITICAL_INIT   0x0000      /* Devices req'd for virt mode */

/*
 *  DEVICE_INIT is where most devices do the bulk of their initialization.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed. Returning carry
 *  aborts device load only.
 */
#define DEVICE_INIT     0x0001      /* All other devices init */

/*
 *  INIT_COMPLETE is the final phase of device init called just before the
 *  WIN386 INIT pages are released and the Instance snapshot is taken.
 *  Devices which wish to search for a region of V86 pages >= A0h to use
 *  should do it at INIT_COMPLETE.
 *  SYS VM Simulate_Int, Exec_Int activity is allowed.  Returning carry
 *  aborts device load only.
 */
#define INIT_COMPLETE       0x0002      /* All devices initialized */

/* --------------- INITIALIZATION CODE AND DATA DISCARDED ------------------ */

/*
 *  Same as VM_Init, except for SYS VM.
 */
#define SYS_VM_INIT     0x0003      /* Execute the system VM */

/*
 *  Same as VM_Terminate, except for SYS VM (Normal WIN386 exit ONLY, on a crash
 *  exit this call is not made).  SYS VM Simulate_Int, Exec_Int activity is
 *  allowed.  This and Sys_VM_Terminate2 are your last chances to access
 *  and/or lock pageable data.
 */
#define SYS_VM_TERMINATE    0x0004      /* System VM terminated */

/*
 *  System_Exit call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE ENABLED.  Instance snapshot has been restored.
 *  SYS VM Simulate_Int, Exec_Int ACTIVITY IS NOT ALLOWED.
 */
#define SYSTEM_EXIT     0x0005      /* Devices prepare to exit */

/*
 *  SYS_CRITICAL_EXIT call is made when WIN386 is exiting either normally or via
 *  a crash.  INTERRUPTS ARE DISABLED.  SYS VM Simulate_Int, Exec_Int ACTIVITY
 *   IS NOT ALLOWED.
 */
#define SYS_CRITICAL_EXIT   0x0006      /* System critical devices reset */


/*
 *  Create_VM creates a new VM.  EBX = VM handle of new VM.  Returning
 *  Carry will fail the Create_VM.
 */
#define CREATE_VM       0x0007

/*
 *  Second phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_CRITICAL_INIT    0x0008

/*
 *  Third phase of Create_VM.  EBX = VM handle of new VM.  Returning
 *  Carry will cause the VM to go Not_Executeable, then be destroyed.
 *  VM Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_INIT         0x0009

/*
 *  NORMAL (First phase) of Destroy_VM.  EBX = VM Hanlde.  This occurs
 *  on normal termination of the VM.  Call cannot be failed.  VM
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define VM_TERMINATE        0x000A      /* Still in VM -- About to die */

/*
 *  Second phase of Destroy_VM.  EBX = VM Handle, EDX = Flags (see
 *  below).  Note that in the case of destroying a running VM, this is
 *  the first call made (VM_Terminate call does not occur).  Call cannot
 *  be failed.  VM Simulate_Int, Exec_Int activity is NOT allowed.
 */
#define VM_NOT_EXECUTEABLE  0x000B      /* Most devices die (except VDD) */

/*
 *  Final phase of Destroy_VM.  EBX = VM Handle.  Note that considerable
 *  time can elaps between the VM_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 */
#define DESTROY_VM      0x000C      /* VM's control block about to go */


/*
 *  Flags for VM_Not_Executeable control call (passed in EDX)
 */
#define VNE_CRASHED_BIT     0x00        /* VM was crashed */
#define VNE_CRASHED     (1 << VNE_CRASHED_BIT)
#define VNE_NUKED_BIT       0x01        /* VM was destroyed while active */
#define VNE_NUKED       (1 << VNE_NUKED_BIT)
#define VNE_CREATEFAIL_BIT  0x02        /* Some device failed Create_VM */
#define VNE_CREATEFAIL      (1 << VNE_CREATEFAIL_BIT)
#define VNE_CRINITFAIL_BIT  0x03        /* Some device failed VM_Critical_Init */
#define VNE_CRINITFAIL      (1 << VNE_CRINITFAIL_BIT)
#define VNE_INITFAIL_BIT    0x04        /* Some device failed VM_Init */
#define VNE_INITFAIL        (1 << VNE_INITFAIL_BIT)
#define VNE_CLOSED_BIT      0x05
#define VNE_CLOSED      (1 << VNE_CLOSED_BIT)


/*
 *  EBX = VM Handle. Call cannot be failed.
 */
#define VM_SUSPEND      0x000D      /* VM not runnable until resume */

/*
 *  EBX = VM Handle. Returning carry fails and backs out the resume.
 */
#define VM_RESUME       0x000E      /* VM is leaving suspended state */


/*
 *  EBX = VM Handle to set device focus to.  EDX = Device ID if device
 *  specific setfocus, == 0 if device critical setfocus (all devices).
 *  THIS CALL CANNOT BE FAILED.
 *
 *  NOTE: In case where EDX == 0, ESI is a FLAG word that indicates
 *  special functions.  Currently Bit 0 being set indicates that this
 *  Device critical set focus is also "VM critical".  It means that we
 *  do not want some other VM to take the focus from this app now.  This
 *  is primarily used when doing a device critical set focus to Windows
 *  (the SYS VM) it is interpreted by the SHELL to mean "if an old app
 *  currently has the Windows activation, set the activation to the
 *  Windows Shell, not back to the old app".  ALSO in the case where Bit
 *  0 is set, EDI = The VM handle of the VM that is "having trouble".
 *  Set this to 0 if there is no specific VM associated with the
 *  problem.
 */
#define SET_DEVICE_FOCUS    0x000F


/*
 *  EBX = VM Handle going into message mode.  THIS CALL CANNOT BE FAILED.
 */
#define BEGIN_MESSAGE_MODE  0x0010

/*
 *  EBX = VM Handle leaving message mode.  THIS CALL CANNOT BE FAILED.
 */
#define END_MESSAGE_MODE    0x0011


/* ----------------------- SPECIAL CONTROL CALLS --------------------------- */

/*
 *  Request for reboot.  Call cannot be failed.
 */
#define REBOOT_PROCESSOR    0x0012      /* Request a machine reboot */

/*
 *  Query_Destroy is an information call made by the SHELL device before
 *  an attempt is made to initiate a destroy VM sequence on a running VM
 *  which has not exited normally.  EBX = VM Handle.  Returning carry
 *  indicates that a device "has a problem" with allowing this.  THE
 *  DESTROY SEQUENCE CANNOT BE ABORTED HOWEVER, this decision is up to
 *  the user.  All this does is indicate that there is a "problem" with
 *  allowing the destroy.  The device which returns carry should call
 *  the SHELL_Message service to post an informational dialog about the
 *  reason for the problem.
 */
#define QUERY_DESTROY       0x0013      /* OK to destroy running VM? */


/* ----------------------- DEBUGGING CONTROL CALL -------------------------- */

/*
 *  Special call for device specific DEBUG information display and activity.
 */
#define DEBUG_QUERY     0x0014


/* -------- CALLS FOR BEGIN/END OF PROTECTED MODE VM EXECUTION ------------- */

/*
 *   About to run a protected mode application.
 *   EBX = Current VM handle.
 *   EDX = Flags
 *   EDI -> Application Control Block
 *   Returning with carry set fails the call.
 */
#define BEGIN_PM_APP        0x0015

/*
 *  Flags for Begin_PM_App (passed in EDX)
 */
#define BPA_32_BIT      0x01
#define BPA_32_BIT_FLAG     1

/*
 *  Protected mode application is terminating.
 *  EBX = Current VM handle.  THIS CALL CAN NOT FAIL.
 *  EDI -> Application Control Block
 */
#define END_PM_APP      0x0016

/*
 *  Called whenever system is about to be rebooted.  Allows VxDs to clean
 *  up in preperation for reboot.
 */
#define DEVICE_REBOOT_NOTIFY    0x0017
#define CRIT_REBOOT_NOTIFY  0x0018

/*
 *  Called when VM is about to be terminated using the Close_VM service
 *  EBX = Current VM handle (Handle of VM to close)
 *  EDX = Flags
 *        CVNF_CRIT_CLOSE = 1 if VM is in critical section while closing
 */
#define CLOSE_VM_NOTIFY     0x0019

#define CVNF_CRIT_CLOSE_BIT 0
#define CVNF_CRIT_CLOSE     (1 << CVNF_CRIT_CLOSE_BIT)

/*
 *  Power management event notification.
 *  EBX = 0
 *  ESI = event notification message
 *  EDI -> DWORD return value; VxD's modify the DWORD to return info, not EDI
 *  EDX is reserved
 */
#define POWER_EVENT     0x001A

#define SYS_DYNAMIC_DEVICE_INIT 0x001B
#define SYS_DYNAMIC_DEVICE_EXIT 0x001C

/*
 *  Create_THREAD creates a new thread.  EDI = handle of new thread.
 *  Returning Carry will fail the Create_THREAD. Message is sent in the
 *  context of the creating thread.
 *
 */
#define  CREATE_THREAD  0x001D

/*
 *  Second phase of creating a thread.  EDI = handle of new thread.  Call cannot
 *  be failed. VM Simulate_Int, Exec_Int activity is not allowed (because
 *  never allowed in non-initial threads). Message is sent in the context
 *  of the newly created thread.
 *
 */
#define  THREAD_INIT    0x001E

/*
 *  Normal (first) phase of Destroy_THREAD. EDI = handle of thread.
 *  This occurs on normal termination of the thread.  Call cannot be failed.
 *  Simulate_Int, Exec_Int activity is allowed.
 */
#define  TERMINATE_THREAD  0x001F

/*
 *  Second phase of Destroy_THREAD.  EDI = Handle of thread,
 *  EDX = flags (see below).  Note that in the case of destroying a
 *  running thread, this is the first call made (THREAD_Terminate call
 *  does not occur).  Call cannot be failed.  VM Simulate_Int, Exec_Int
 *  activity is NOT allowed.
 *
 */
#define  THREAD_Not_Executeable  0x0020

/*
 *  Final phase of Destroy_THREAD.  EDI = Thread Handle.  Note that considerable
 *  time can elapse between the THREAD_Not_Executeable call and this call.
 *  Call cannot be failed.  VM Simulate_Int, Exec_Int activity is NOT
 *  allowed.
 *
 */
#define  DESTROY_THREAD    0x0021

/* -------------------- CALLS FOR PLUG&PLAY ------------------------- */

/*
 *  Configuration manager or a devloader is telling a DLVxD that a new devnode
 *  has been created. EBX is the handle of the new devnode and EDX is the load
 *  type (one of the DLVxD_LOAD_* defined in CONFIGMG.H). This is a 'C'
 *  system control call. Contrarily to the other calls, carry flags must be
 *  set if any error code other than CR_SUCCESS is to be return.
 *
 */
#define PNP_NEW_DEVNODE     0x0022


/* -------------------- CALLS FOR Win32  ------------------------- */

/* vWin32 communicates with Vxds on behalf of Win32 apps thru this mechanism.
 */

#define W32_DEVICEIOCONTROL 0x0023

/* sub-functions */
#define DIOC_GETVERSION     0x0
#define DIOC_OPEN       DIOC_GETVERSION
#define DIOC_CLOSEHANDLE    -1

/* -------------------- MORE SYSTEM CALLS ------------------------- */

/*
 * All these messages are sent immediately following the corresponding
 * message of the same name, except that the "2" messages are sent
 * in *reverse* init order.
 */

#define SYS_VM_TERMINATE2   0x0024
#define SYSTEM_EXIT2        0x0025
#define SYS_CRITICAL_EXIT2  0x0026
#define VM_TERMINATE2       0x0027
#define VM_NOT_EXECUTEABLE2 0x0028
#define DESTROY_VM2     0x0029
#define VM_SUSPEND2     0x002A
#define END_MESSAGE_MODE2   0x002B
#define END_PM_APP2     0x002C
#define DEVICE_REBOOT_NOTIFY2   0x002D
#define CRIT_REBOOT_NOTIFY2 0x002E
#define CLOSE_VM_NOTIFY2    0x002F

/*
 * VCOMM gets Address of Contention handler from VxDs by sending this
 * control message
 */

#define GET_CONTENTION_HANDLER  0x0030

#define KERNEL32_INITIALIZED    0x0031

#define KERNEL32_SHUTDOWN       0x0032

#define MAX_SYSTEM_CONTROL  0x0032

/*
 * Dynamic VxD's can communicate with each other using Directed_Sys_Control
 * and a private control message in the following range:
 */

#define BEGIN_RESERVED_PRIVATE_SYSTEM_CONTROL	0x70000000
#define END_RESERVED_PRIVATE_SYSTEM_CONTROL	0x7FFFFFFF

#endif // Not_VxD

/*
 * Values returned from VMM_GetSystemInitState in EAX.
 *
 * Comments represent operations performed by VMM; #define's indicate
 * what VMM_GetSystemInitState will return if you call it between the
 * previous operation and the next.
 *
 * Future versions of Windows may have additional init states between the
 * ones defined here, so you should be careful to use range checks instead
 * of test for equality.
 */

                    /* Protected mode is entered */
#define SYSSTATE_PRESYSCRITINIT     0x00000000
                    /* SYS_CRITICAL_INIT is broadcast */
#define SYSSTATE_PREDEVICEINIT      0x10000000
                    /* DEVICE_INIT is broadcast */
#define SYSSTATE_PREINITCOMPLETE    0x20000000
                    /* INIT_COMPLETE is broadcast */
                    /* VxD initialization complete */
#define SYSSTATE_VXDINITCOMPLETED   0x40000000
                    /* KERNEL32_INITIALIZED is broadcast */
#define SYSSTATE_KERNEL32INITED     0x50000000
                    /* All initialization completed */
                    /* System running normally */
                    /* System shutdown initiated */
                    /* KERNEL32_SHUTDOWN is broadcast */
#define SYSSTATE_KERNEL32TERMINATED 0xA0000000
                    /* System shutdown continues */
#define SYSSTATE_PRESYSVMTERMINATE  0xB0000000
                    /* SYS_VM_TERMINATE is broadcast */
#define SYSSTATE_PRESYSTEMEXIT      0xE0000000
                    /* SYSTEM_EXIT is broadcast */
#define SYSSTATE_PRESYSTEMEXIT2     0xE4000000
                    /* SYSTEM_EXIT2 is broadcast */
#define SYSSTATE_PRESYSCRITEXIT     0xF0000000
                    /* SYS_CRITICAL_EXIT is broadcast */
#define SYSSTATE_PRESYSCRITEXIT2    0xF4000000
                    /* SYS_CRITICAL_EXIT2 is broadcast */
#define SYSSTATE_POSTSYSCRITEXIT2   0xFFF00000
                    /* Return to real mode */

/* ASM
BeginDoc
;******************************************************************************
; BeginProc is a macro for defining entry points to routines in VMM and in the
;   VxDs. It correctly defines the procedure name for VxD services, DWORD
;   aligns the procedure, takes care of public declaration and does some
;   calling verification for debug versions of the software. EndProc is a
;   macro which defines the end of the procedure.
;
; Valid parameters to the BeginProc macro are:
;   PUBLIC              ; Used outside this module (default)
;   LOCAL               ; Local to this module
;   HIGH_FREQ           ; DWORD align procedure
;   SERVICE             ; Routine is called via VxDCall
;   ASYNC_SERVICE           ; Same as "SERVICE" plus routine can
;                   ;   be called under interrupt.
;   HOOK_PROC           ; Proc is a handler installed with
;                   ;   with a call to Hook_xxx_Fault
;                   ;   or Hook_Device_Service.  The
;                   ;   following parameter must be
;                   ;   the label of a DWORD location
;                   ;   which will hold the ptr to next
;                   ;   hook proc. e.g.
;
;                  ;BeginProc foo, SERVICE, HOOK_PROC, foo_next_ptr
;
;   NO_LOG              ; Disable Queue_Out call logging
;   NO_PROFILE          ; Disable DynaLink profile counts
;   NO_TEST_CLD         ; Disable direction flag check
;
;   TEST_BLOCK          ; Trap if in NOBLOCK state
;                   ;  (default if in pageable code seg)
;   TEST_REENTER            ; Trap if Get_VMM_Reenter_Count != 0
;                   ;  (default for non-async services)
;   NEVER_REENTER           ; Trap if VMM has been reentered
;   NOT_SWAPPING            ; Trap if this thread is swapping
;
;   NO_PROLOG           ; Disable all prolog tests
;
;   ESP             ; Use ESP instead of EBP for stack
;                   ;  frame base
;   PCALL               ; pascal calling convention
;   SCALL               ; stdcall calling convention
;   CCALL               ; "C" calling convention
;   ICALL               ; default calling convention
;   W32SVC              ; Win32 service
;
;   segment type            ; Place function in specified segment
;
; The NO_PROFILE flag merely suppresses incrementing the profile count.
; The DWORD of profiling information will still be emitted to appease
; the debugger.  If you want to increment the profile count manually,
; use the IncProfileCount macro.
;
; TEST_REENTER and NEVER_REENTER differ in that the VMM reentry count
; returned by Get_VMM_Reenter_Count is artifically forced to zero by
; Begin_Reentrant_Execution, whereas the counter checked by NEVER_REENTER
; reflects the genuine count of VMM reentry.
;
; A segment type (such as LOCKED, PAGEABLE, STATIC, INIT, DEBUG_ONLY) can be
; provided, in which case the BeginProc and EndProc macros will
; automatically place the appropriate segment directives around the
; definition of the function.
;
;   segment type            ; Place function in specified segment
;
; After the routine header in which the routine entry conditions, exit
;   conditions, side affects and functionality are specified, the BeginProc
;   macro should be used to define the routine's entry point. It has up to
;   four parameters as specified below. For example:
;
;BeginProc  <Function_Name>,PUBLIC, HIGH_FREQ, SERVICE, ASYNC_SERVICE, ESP
;
;   <code>
;
;EndProc    <Function_Name>
;==============================================================================
EndDoc
;
; BeginProc handling takes place in the following phases:
;
;   Phase 1:  Parsing the arguments.
;   Phase 2:  Setting default flags.
;   Phase 3:  Combining the flags.
;   Phase 4:  Code emitted before the label
;   Phase 5:  Munge the name as exported to C/Pascal/whoever
;   Phase 6:  _Debug_Flags_Service prolog
;   Phase 7:  Code emitted after the label
;

??_pf_Check equ 1       ;; Do Enter/LeaveProc checking?
??_pf_ArgsUsed  equ 2       ;; ArgVars were used
??_pf_Entered   equ 4       ;; EnterProc performed
??_pf_Left  equ 8       ;; LeaveProc performed
??_pf_Returned  equ    16               ;; Return performed

??_pushed       =       0               ;; For WIN31COMPAT
??_align    =   0       ;; For WIN31COMPAT
??_ends     equ <>      ;; BeginProc segment

BeginProc macro Name, P1, P2, P3, P4, P5, P6, P7, LastArg
    local   Profile_Data, prelabeldata, ??_hookvar
    ??_frame = 0            ;; local frame base
    ??_aframe = 0           ;; argument frame base
    ??_initaframe = 0       ;; initial aframe value
    ??_numargs = 0          ;; number of argvars
    ??_numlocals = 0        ;; number of localvars
    ??_numlocalsymbols = 0      ;; number of local symbols
    ??_procflags = 0        ;; misc. Enter/LeaveProc flags
    ??_esp = 0          ;; if VMM_TRUE, use esp instead of ebp
    ??_pushed = 0           ;; number of bytes pushed
    ??_align = 0            ;; set if proc should be dword aligned
    ??_hook = 0         ;; set if proc is a Hook_Proc
    ??_hookarg = 0
    ??_service = 0
    ??_async_service = 0
IF DEBLEVEL GT DEBLEVELNORMAL
    ??_log = DFS_LOG        ;; logging on by default
    ??_profile = DFS_PROFILE    ;; service profiling on by default
    ??_test_cld = DFS_TEST_CLD  ;; test that direction is clear
ELSE
    ??_log = 0          ;; logging off
IFDEF DEBUG
IFDEF profileall
IF ?_ICODE
    ??_profile = DFS_PROFILE    ;; service profiling on by default
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
ELSE
    ??_profile = 0          ;; service profiling off
ENDIF
    ??_test_cld = 0         ;; test that direction is clear
ENDIF
    ??_might_block = 0      ;; entering fn might cause VM to block
    ??_test_reenter = 0     ;; don't test for VMM reentry
    ??_never_reenter = 0        ;; don't test for genuine VMM reentry
    ??_not_swapping = 0     ;; don't test that we're not swapping
    ??_prolog_disabled = 0      ;; use a prolog by default
    ??_public = 1           ;; everything's public by default
    ??_cleanoff = 0         ;; don't cleanoff parameters
    ??_ccall = 0
    ??_pcall = 0
    ??_scall = 0
    ??_w32svc = 0
    ??_fleave = FALSE
;   ??_dfs = 0          ;; parm for _Debug_Flags_Service
    ??_name equ <Name>

    .errnb ??_ends, <Cannot nest functions with named segments>
    .errnb <LastArg>, <Too many arguments to BeginProc>

    ;; Phase 1: Parsing the arguments
    irp arg, <P1, P2, P3, P4, P5, P6, P7>
        if ??_hookarg
        ??_hookarg = 0
        ??_hookvar equ <arg>
        elseifdef ?&&arg&&_BeginProc
            ?&&arg&&_BeginProc
        elseifdef VxD_&&arg&&_CODE_SEG
        ??_ends textequ <VxD_&&arg&&_CODE_ENDS>
        VxD_&&arg&&_CODE_SEG
        else
        .err <Bad param "&arg" to BeginProc>
        endif
    endm

    ;; Phase 2:  Setting default flags
    ifndef Not_VxD
	ife ??_service
	    ifndef profileall
	      ??_profile = 0      ;; only services can be profiled
	    endif
	    ifdef VMMSYS
		??_prolog_disabled = 1
	    endif
	else
	    ??_test_cld = DFS_TEST_CLD
	endif       ; ife ??_service

	ife ?_16ICODE
	    ??_prolog_disabled = 1
	else
	ife ?_RCODE             ;; if real-mode code segment
	    ??_prolog_disabled = 1  ;; don't do anything bad
	else                ;; else protected mode code segment
	    ife ?_PCODE     ;; if swappable code
		??_might_block = DFS_TEST_BLOCK
	    endif
	    if ??_service
		ife ??_async_service
		    ??_test_reenter = DFS_TEST_REENTER
		endif
	    endif
    endif       ; ife ?_RCODE
    endif       ; ife ?_16ICODE
    endif	; Not_VxD

    if ??_esp
	;; just return address on stack
	??_basereg equ <esp+??_pushed>
	??_initaframe = 4
    else
	;; ret addr and EBP on stack
	??_basereg equ <ebp>
	??_initaframe = 8
    endif
    @Caller equ <dword ptr [??_basereg+??_initaframe-4]>

    ??_cleanoff = ??_pcall or ??_scall

    ;; Phase 3:  Combining the flags
    ??_dfs = ??_never_reenter + ??_test_reenter + ??_not_swapping + \
         ??_log + ??_profile + ??_test_cld + ??_might_block

    if ??_prolog_disabled
        ??_dfs = 0
    endif

    ;; Phase 4:  Pre-label code

    ifndef Not_VxD

	if ??_hook
	    if ??_align
	    Dword_Align
	    endif
	    prelabeldata:
	    ifndef ??_hookvar
	    .err <HOOK_PROC requires next arg to be name of dword location>
	    endif
	    jmp short Name
	    jmp [??_hookvar]
	    ifdef DEBUG
	    Profile_Data dd  0
	    endif
	    if ??_align
	    .errnz ($ - prelabeldata) mod 4
	    endif
	endif

	ifdef DEBUG
	    ?prolog_&Name label near
	    if (??_service OR ??_profile) AND (??_hook EQ 0)
	    jmp short Name
	    if ??_align
		Dword_Align     ; This also aligns the proc
	    endif           ;   since Profile_Data is a dd

	    IF ?_ICODE
	    ifdef profileall
	      ?ProfileHeader_BeginProc Profile_Data, %@filename
	    else
	      Profile_Data dd 0
	    endif
	    ELSE
	      Profile_Data dd 0
	    ENDIF

	    endif
	endif

	if ??_align
	    Dword_Align
	endif

    endif	; Not_VxD

    Name proc near		;; The label

    ;; Phase 5:  Munge the name as exported to C/Pascal/whoever
    ;;       Warning!  Phase 5 cannot emit code!
    ife ??_pcall or ??_ccall or ??_scall    ;; if no munging
        if ??_public
            public Name
        else
            ifdef DEBUG
                % ?merge @FileName,$,Name,:
                % ?merge public,,,,,@FileName,$,Name
            endif
        endif
    endif
    if ??_ccall
        if ??_public
            _&Name equ Name
	    ifdef Not_VxD
		 public C Name
	    else
                 public _&Name
	    endif
        endif
    endif
    if ??_pcall
        if ??_public
            ?toupper Name
            ?merge  public,,,,%?upper
        endif
    endif
    ;; Phase 6:  _Debug_Flags_Service prolog
    ;;       DO NOT CHANGE UNTIL YOU UNDERSTAND _Debug_Flags_Service
    ifndef Not_VxD
	ifdef DEBUG
	    if ??_dfs EQ DFS_LOG
		VMMCall Log_Proc_Call   ;; no test, just log
	    else
	    if ??_dfs EQ DFS_TEST_REENTER
		VMMCall Test_Reenter    ;; no log, just reenter
	    else
	    if ??_dfs or ?_LOCKABLECODE eq 0
		ifdef WIN31COMPAT
		    if ??_dfs AND DFS_LOG
			VMMCall Log_Proc_Call
		    endif
		    if ??_dfs AND DFS_TEST_REENTER
			VMMCall Test_Reenter
		    endif
		else
		    ife ?_LOCKABLECODE
		    ifdef ??_debug_flags
			push    ??_debug_flags
			if ??_dfs
			pushfd
			or  dword ptr [esp+4],??_dfs
			popfd
			endif
			VMMCall _Debug_Flags_Service
		    elseif ??_dfs
			push    ??_dfs
			VMMCall _Debug_Flags_Service
		    endif
		    else
		    push    ??_dfs
		    VMMCall _Debug_Flags_Service
		    endif
		endif
	    else
	      ifdef profileall
		IncProfileCount
	      endif
	    endif           ;if ??_dfs
	    endif           ; if ??_dfs EQ DFS_TEST_REENTER
	    endif           ; if ??_dfs EQ DFS_LOG
	endif ; DEBUG
    endif ; Not_VxD

    ;; Phase 7:  Post-label code
    ;;       <none>
endm

;
; For each BeginProc keyword, there is a corresponding macro ?XX_BeginProc.
;
; The macro ?_BeginProc is so that the null keyword is not an error.

?_BeginProc macro
endm

?PUBLIC_BeginProc macro
    ??_public = 1
endm

?LOCAL_BeginProc macro
    ??_public = 0
endm

?HIGH_FREQ_BeginProc macro
    ??_align = 1
endm

?HOOK_PROC_BeginProc macro
    ??_hook = 1
    ??_hookarg = 1  ; next arg is dword storage location
endm

?SERVICE_BeginProc macro
    ??_service = 1
    .erre ?_16ICODE, <SERVICEs must be in 32 bit code>
    .erre ?_RCODE, <SERVICEs must be in 32 bit code>
endm

?ASYNC_SERVICE_BeginProc macro
    ??_service = 1
    ??_async_service = 1
    .errnz ?_LCODE, <ASYNC_SERVICE's must be in LOCKED code>
endm

?NO_LOG_BeginProc macro
    ??_log = 0
endm

?NO_PROFILE_BeginProc macro
    ??_profile = 0
endm

?NO_TEST_CLD_BeginProc macro
    ??_test_cld = 0
endm

?TEST_BLOCK_BeginProc macro
    ??_might_block = DFS_TEST_BLOCK
endm

?TEST_REENTER_BeginProc macro
    ??_test_reenter = DFS_TEST_REENTER
endm

?NEVER_REENTER_BeginProc macro
    ??_never_reenter = DFS_NEVER_REENTER
endm

?NOT_SWAPPING_BeginProc macro
    ??_not_swapping = DFS_NOT_SWAPPING
endm

?NO_PROLOG_BeginProc macro
    ??_prolog_disabled = 1
endm

?ESP_BeginProc macro
    ??_esp = VMM_TRUE
    ifndef Not_VxD
	.erre ?_16ICODE, <Beginproc ESP attribute invalid in 16 bit seg.>
	.erre ?_RCODE, <Beginproc ESP attribute invalid in real-mode seg.>
    endif
endm

?CCALL_BeginProc macro
    ??_ccall = 1
endm

?PCALL_BeginProc macro
    ??_pcall = 1
endm

?SCALL_BeginProc macro
    ??_scall = 1
endm

?ICALL_BeginProc macro
    ??_scall = 1    ;; internal calling convention is StdCall
endm

?W32SVC_BeginProc macro
    ??_scall = 1
    ??_w32svc = 1
endm

ifdef DEBUG
ifdef profileall
?ProfileHeader_BeginProc macro PL, filename
ifndef _&filename&__proc_list
  _&filename&__proc_list = 0
  PUBLIC _&filename&__proc_list
endif
    dd OFFSET32 _&filename&__proc_list
PL  dd 0
_&filename&__proc_list = PL
endm
endif

IncProfileCount macro
    if ??_service OR ??_profile
        inc dword ptr [??_name-4]
    else
        ifndef profileall
        .err <IncProfileCount can be used only in services.>
        endif
    endif
endm
else
IncProfileCount macro
endm
endif

;***    ArgVar - declares stack arguments
;
; Usage:
;
;   name   = name of argument.
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4.
;   used   = usually blank, but can be the symbol NOTUSED
;        to indicate that the argument will not be used
;        by the procedure.
;

ArgVar  macro   name,length,used
    ??_numargs = ??_numargs + 1
    if ??_pcall
        ?mkarg  <name>, <length>, <used>, %??_numargs
    else
        ?argvar <name>, <length>, <used>
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
    endm

?mkarg  macro   name, length, used, num
    .xcref  ?MKA&num
    ?deflocal <name>
    ?MKA&num &macro
        ?argvar <name>, <length>, <used>
        &endm
    ??_aframe = ??_aframe + 4
    endm
    .xcref  ?mkarg

?argvar macro   name,length,used
    local   a
    ifidni  <length>,<BYTE>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <byte ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<WORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>, <word ptr [??_basereg+??_initaframe+a]>, <used>
    elseifidni <length>,<DWORD>
        a = ??_aframe
        ??_aframe =  ??_aframe + 4
        ?setname <name>,  <dword ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&l>,<word ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&ll>,<byte ptr [??_basereg+??_initaframe+a]>, <used>
        ?setname <name&lh>,<byte ptr [??_basereg+??_initaframe+a+1]>, <used>
        ?setname <name&h>,<word ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hl>,<byte ptr [??_basereg+??_initaframe+a+2]>, <used>
        ?setname <name&hh>,<byte ptr [??_basereg+??_initaframe+a+3]>, <used>
    else
        a = ??_aframe
        ??_aframe =  ??_aframe + ((length + 3)/4)*4
        ?setname <name>, <[??_basereg+??_initaframe+a]>, <used>
    endif
endm

;***    ?setname - optionally creates the name of an ArgVar
;
;   If <used> is <NOTUSED>, then the name is defined to something
;   bogus.

?setname macro name, value, used
    ?deflocal <name>
    ifidni <used>, <NOTUSED>
        name equ _inaccessible_NOTUSED_
    else
        name equ value
        ??_procflags = ??_procflags OR ??_pf_ArgsUsed OR ??_pf_Check
    endif
endm


;***    LocalVar - declares local stack variables
;
; Usage:
;
;   name   = name of local variable
;   length = a numeric expression denoting the size (in bytes)
;        of the argument.  The symbols BYTE, WORD, and DWORD
;        are synonyms for 1, 2, and 4 respectively.
;        NB!  All arguments sizes are rounded up to the nearest
;        multiple of 4 (unless PACK is indicated)
;   flag   = usually blank, but can be the symbol PACK
;        to suppress the usual padding and aligning of variables
;        PACK is typically used when declaring a bunch of
;        byte or word variables.  Make sure that the total
;        size of PACKed variables is a multiple of 4.
;

LocalVar    macro   name,length,flag
    local   a
    ??_numlocals = ??_numlocals + 1
    ??_pad = 1
    ifidni <flag>, <PACK>
        ??_pad = 0
    endif
    ifidni  <length>,<BYTE>
        ??_frame = ??_frame + 1 + 3 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ byte ptr [??_basereg-a]
    elseifidni <length>,<WORD>
        ??_frame =  ??_frame + 2 + 2 * ??_pad
        a = ??_frame
        ?deflocal <name>
        name equ word ptr [??_basereg-a]
    elseifidni <length>,<DWORD>
        ??_frame = ??_frame + 4
        a = ??_frame
        ?deflocal <name, name&l, name&ll, name&lh, name&h, name&hl, name&hh>
        name equ dword ptr [??_basereg-a]
        name&l equ word ptr [??_basereg-a]
        name&ll equ byte ptr [??_basereg-a]
        name&lh equ byte ptr [??_basereg-a+1]
        name&h equ word ptr [??_basereg-a+2]
        name&hl equ byte ptr [??_basereg-a+2]
        name&hh equ byte ptr [??_basereg-a+3]
    else
        ??_frame =  ??_frame + ((length + 3)/4)*4
        a = ??_frame
        ?deflocal <name>
        name equ [??_basereg-a]
    endif
    ??_procflags = ??_procflags OR ??_pf_Check
endm

?deflocal macro name
    irp nm, <name>
        ??_numlocalsymbols = ??_numlocalsymbols + 1
        ?dodeflocal <nm>, %(??_numlocalsymbols)
    endm
endm
    .xcref  ?deflocal

?dodeflocal macro name, num
    .xcref  ?LOC&num
    ?LOC&num &macro
        name    equ <__inaccessible__NOTINSCOPE__>
        &endm
    endm
    .xcref  ?dodeflocal

;***    EnterProc - generates stack frame on entry

EnterProc macro
    .errnz ??_frame and 3, <Total size of local variables not a multiple of 4.>
    if ??_scall
        if ??_public
	    ifdef Not_VxD
                ?merge  %??_name,@,%(??_aframe),,label,near
                ?merge  public,,,,C,%??_name,@,%(??_aframe)
	    else
                ?merge  _,%??_name,@,%(??_aframe),label,near
                ?merge  public,,,,,_,%??_name,@,%(??_aframe)
	    endif
        endif
    endif
    if ??_pcall
        ??_aframe = 0
        ?count = ??_numargs
        rept    ??_numargs
            ?invprg <?MKA>,%?count
            ?count = ?count - 1
        endm
    endif
    ??_fleave = FALSE
    if ??_esp
        if  ??_frame
            sub esp, ??_frame
            ??_pushed = ??_pushed + ??_frame
            ??_fleave = VMM_TRUE
        endif
    else
        if  ??_frame eq 0
            if (??_aframe eq 0) OR ((??_procflags AND ??_pf_ArgsUsed) EQ 0)
                ifdef DEBUG
                    push    ebp
                    mov ebp,esp
                    ??_fleave = VMM_TRUE
                endif
            else
                push    ebp
                mov ebp,esp
                ??_fleave = VMM_TRUE
            endif
        else
            enter   ??_frame, 0
            ??_fleave = VMM_TRUE
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Entered
endm

;***    LeaveProc - removes stack frame on exit
;
;	NOTE:	If there are localvar and ESP kind of stack frame
;		LeaveProc will destroy flags unless the "PRESERVE_FLAGS"
;		flag is given.  PRESERVE_FLAGS generates bigger, slower
;		code, so use it only when necessary.
;
;   WARNING: For "ESP" type stack frames, this macro DOES NOT adjust
;        the internal stack depth for the local frame.  This is
;        to allow jumping around the LeaveProc/Return to code
;        after the LeaveProc/Return to use args/local variables,
;        but code that uses the stack frame executed after the
;        LeaveProc won't work.

LeaveProc macro flags
    if ??_fleave
        if ??_esp
            ifidni <flags>,<PRESERVE_FLAGS>
                lea esp,[esp + ??_frame]
            else
                add esp,??_frame
            endif
        else
            leave
        endif
    endif
    ??_procflags = ??_procflags OR ??_pf_Left
endm

;***    Return - return appropriately from a procedure
;
;   For "ccall" functions it's just a ret; for "pcall" and "scall"
;   it cleans the parameters off.
;

Return  macro
    if  ??_cleanoff OR ??_w32svc
        if  ??_w32svc AND (??_aframe LT 8)
            ret 8
        else
            ret ??_aframe
        endif
    else
        ret
    endif
    ??_procflags = ??_procflags OR ??_pf_Returned
    endm

;***    EndProc - end the procedure
;

EndProc macro Name, Flag
    Name endp           ;; Masm will provide error msg for us
if ??_w32svc
    if ??_aframe lt 8
        cparm&Name equ 0
    else
        cparm&Name equ (??_aframe/4 - 2)
    endif
endif
if ??_procflags AND ??_pf_Left
if ??_fleave
if ??_esp
    ??_pushed = ??_pushed - ??_frame
endif
endif
endif
ifdifi  <Flag>,<NOCHECK>
    if ??_pushed ne 0
        %out Warning: stack not balanced in Name
    endif
    if ??_procflags AND ??_pf_Check
        ife ??_procflags AND ??_pf_Entered
            %out Warning: ArgVar/LocalVar without EnterProc in Name
        endif
        ife ??_procflags AND ??_pf_Left
            %out Warning: ArgVar/LocalVar without LeaveProc in Name
        endif
        ife ??_procflags AND ??_pf_Returned
            %out Warning: ArgVar/LocalVar without Return in Name
        endif
    endif
endif
ifdifi  <Flag>,<KEEPFRAMEVARS>
    ?count = 0
    rept    ??_numlocalsymbols
        ?count = ?count + 1
        ?invprg <?LOC>,%?count
    endm
endif
    ??_ends
    ??_ends equ <>
    endm

;***    cCall - "C" call
;
;   Arguments pushed in "C" order, caller cleans stack
;
;   USES: Flags.

cCall   macro   name, arglst, flags
    ife .TYPE name
       CondExtern name, near
    endif
    PushCParams <arglst>, <flags>
    call    name
    ClearCParams
    endm
    .xcref  cCall

;***    pCall - pascal call
;
;   Arguments pushed in pascal order, callie cleans stack
;

pCall   macro   name, arglst
    local   ??saved
    ife .TYPE name
        ?toupper name
    else
        ?upper equ <name>
    endif
    CondExtern %?upper, near
    ??saved = ??_pushed
    irp x,<arglst>
        push    x
        ??_pushed = ??_pushed + 4
    endm
    call    ?upper
    ??_pushed = ??saved
    endm
    .xcref  pCall

;***    sCall - standard call
;
;   Arguments pushed in "C" order, callie cleans stack,
;   @argc appended to name
;

sCall   macro   name, arglst
    local   ??saved
    ??saved = ??_pushed
    PushCParams <arglst>
    ?scall  name, %(??_argc * 4)
    ??_pushed = ??saved
    endm
    .xcref  sCall

;***    iCall - internal routine call
;
;   Set to what every type we what to use as a default.

iCall   equ <sCall>

;***    PushCParams
;
;   Processes argument list
;
;   arglist = <arg1, arg2, arg3, ...>
;   flags = the word SMALL if we should prefer size over speed
;       the word FAST if we should prefer speed over size
;
;       The default flag is SMALL, unless the current procedure
;       is High_Freq, in which case we default to FAST.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
IFNDEF  STANDARD_CCALL
NONSTANDARD_CCALL = 1           ;; disabled by default for now
ENDIF

PushCParams macro arglst, flags
    ??_argc = 0         ;; number of dwords on stack (global)
IFDEF   NONSTANDARD_CCALL
    ??_popargs = 0          ;; establish default
ELSE
    ??_popargs = ??_align EQ 0  ;; establish default
ENDIF
    ifidni  <flags>, <SMALL>
        ??_popargs = 1      ;; size, not speed
    elseifidni <flags>, <FAST>
        ??_popargs = 0      ;; speed, not size
    endif

    irp x,<arglst>
        ??_argc = ??_argc + 1
        ?marg   <x>,%??_argc
    endm
    ?count = ??_argc
    rept    ??_argc
        ?invprg <?AM>,%?count
        ?count = ?count - 1
    endm
    endm

;***    ClearCParams
;
;   Processes stack clean up
;
;   This routine will trade size for speed (if requested)
;   by using `pop ecx' to clean off one or two arguments.
;   This relies on the convention that C-call routines do
;   not return useful information in ECX.
;
;   To disable this optimization, define the symbol NONSTANDARD_CCALL.
;
;	If flags must be preserved, pass PRESERVE_FLAGS as an argument.
;	This will generate bigger, slower code, so use it only when
;	necessary.

ClearCParams macro fPreserveFlags
	if	??_argc ne 0
	    if (??_popargs) AND (??_argc LE 2)
	      rept ??_argc
		pop	ecx
	      endm
	    else
	      ifidni <fPreserveFlags>, <PRESERVE_FLAGS>
		lea	esp, [esp][??_argc * 4]
	      else
		add	esp,??_argc * 4
	      endif
	    endif
	endif
	??_pushed = ??_pushed - (??_argc * 4)
	endm

; Makes a macro that will push argment when invoke - used by cCall only

?marg   macro   name, num
    .xcref
    .xcref  ?AM&num
    .cref
    ?AM&num &macro
        push    name
        ??_pushed = ??_pushed + 4
        &endm
    endm
    .xcref  ?marg

; Concatenates, invokes and purges a macro name - used by PushCParams

?invprg macro   name1, name2
    name1&name2
    purge   name1&name2
    endm
    .xcref  ?invprg

; Calls a concatenated standard call name and makes it external

?scall  macro   name1, name2
    CondExtern _&name1&@&name2, near
    call    _&name1&@&name2
    endm
    .xcref  ?scall

; Equates name to a name

?merge  macro   l1, l2, l3, l4, op, r1, r2, r3, r4, r5, r6, r7, r8, r9
    l1&l2&l3&l4 op r1&r2&r3&r4&r5&r6&r7&r8&r9
    endm

; Converts string to upper-case, returned in ?upper

?toupper macro s
      ?upper equ <>
      irpc x,<s>
        if '&x' GE 'a'
          if '&x' LE 'z'
        ?t1 substr <ABCDEFGHIJKLMNOPQRSTUVWXYZ>,'&x'-'a'+1,1
        ?upper catstr ?upper,?t1
          else
        ?upper catstr ?upper,<&x>
          endif
        else
          ?upper catstr ?upper,<&x>
        endif
      endm
    endm
    .xcref

;***    CondExtern - Make name external if not already defined
;
;   This operation is quite different between MASM 5.1 and 6.0.
;

CondExtern macro name,dist
    ifdef MASM6
        ifndef name
        externdef name:dist
        endif
    else
        if2
        ifndef name
            extrn name:dist
        endif
        endif
    endif
endm

;***    SaveReg - Save register, "fd" pushes flags, "ad" pushes all

SaveReg macro   reglist         ;; push those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            pushfd
            ??_pushed = ??_pushed + 4
        else
        ifidni <reg>, <ad>
            pushad
            ??_pushed = ??_pushed + SIZE Pushad_Struc
        else
            push    reg
            ??_pushed = ??_pushed + 4
        endif
        endif
    endm
endm

;***    RestoreReg - Restore register, "fd" pops flags, "ad" pops all
;
;   Note that registers must be restored in reverse order that they
;   were saved.
;

RestoreReg macro     reglist    ;; pop those registers
    irp reg,<reglist>
        ifidni <reg>, <fd>
            popfd
            ??_pushed = ??_pushed - 4
        else
        ifidni <reg>, <ad>
            popad
            ??_pushed = ??_pushed - SIZE Pushad_Struc
        else
            pop reg
            ??_pushed = ??_pushed - 4
        endif
        endif
    endm
endm
*/

#ifdef DEBUG
/******************************************************************************
*   The following macros are for enabling procedure call profile counting
*   of VxD's written in assembler.
*
*   Begin_Profile_List needs to be used in the file that declares the device
*   immediately after the Declare_Virtual_Device line.  Then one Profile_Link
*   line is required for each individual source file.  The list is ended with
*   the End_Profile_List macro.  Profiling only works for debug builds and
*   the sources must all be built with "-Dprofileall" masm switch.
******************************************************************************/

/* ASM
Begin_Profile_List macro devname
ifdef profileall
VxD_DATA_SEG
    db  'PROCLIST'
PUBLIC devname&_Proc_Profile_List
devname&_Proc_Profile_List label dword
endif
endm

Profile_Link macro modname
ifdef profileall
ifdifi <modname>,@filename
EXTRN _&modname&__proc_list:near
endif
    dd  OFFSET32 _&modname&__proc_list
endif
endm

End_Profile_List macro
ifdef profileall
    dd  0
VxD_DATA_ENDS
endif
endm

*/
#endif

#ifndef Not_VxD

/******************************************************************************
 *         S C H E D U L E R   B O O S T   V A L U E S
 *****************************************************************************/

#define RESERVED_LOW_BOOST  0x00000001
#define CUR_RUN_VM_BOOST    0x00000004
#define LOW_PRI_DEVICE_BOOST    0x00000010
#define HIGH_PRI_DEVICE_BOOST   0x00001000
#define CRITICAL_SECTION_BOOST  0x00100000
#define TIME_CRITICAL_BOOST 0x00400000
#define RESERVED_HIGH_BOOST 0x40000000


/******************************************************************************
 *   F L A G S   F O R   C A L L _ P R I O R I T Y _ V M _ E V E N T
 *****************************************************************************/

#define PEF_WAIT_FOR_STI_BIT        0
#define PEF_WAIT_FOR_STI        (1 << PEF_WAIT_FOR_STI_BIT)
#define PEF_WAIT_NOT_CRIT_BIT       1
#define PEF_WAIT_NOT_CRIT       (1 << PEF_WAIT_NOT_CRIT_BIT)

#define PEF_DONT_UNBOOST_BIT        2
#define PEF_DONT_UNBOOST        (1 << PEF_DONT_UNBOOST_BIT)
#define PEF_ALWAYS_SCHED_BIT        3
#define PEF_ALWAYS_SCHED        (1 << PEF_ALWAYS_SCHED_BIT)
#define PEF_TIME_OUT_BIT        4
#define PEF_TIME_OUT            (1 << PEF_TIME_OUT_BIT)

#define PEF_WAIT_NOT_HW_INT_BIT     5
#define PEF_WAIT_NOT_HW_INT     (1 << PEF_WAIT_NOT_HW_INT_BIT)
#define PEF_WAIT_NOT_NESTED_EXEC_BIT    6
#define PEF_WAIT_NOT_NESTED_EXEC    (1 << PEF_WAIT_NOT_NESTED_EXEC_BIT)
#define PEF_WAIT_IN_PM_BIT      7
#define PEF_WAIT_IN_PM          (1 << PEF_WAIT_IN_PM_BIT)

#define PEF_THREAD_EVENT_BIT        8
#define PEF_THREAD_EVENT        (1 << PEF_THREAD_EVENT_BIT)

#define PEF_WAIT_FOR_THREAD_STI_BIT 9
#define PEF_WAIT_FOR_THREAD_STI (1 << PEF_WAIT_FOR_THREAD_STI_BIT)

#define PEF_RING0_EVENT_BIT         10
#define PEF_RING0_EVENT         (1 << PEF_RING0_EVENT_BIT)

#define PEF_WAIT_CRIT_BIT	    11
#define PEF_WAIT_CRIT		(1 << PEF_WAIT_CRIT_BIT)

// synonyms for event restrictions above

#define PEF_WAIT_NOT_TIME_CRIT_BIT   PEF_WAIT_NOT_HW_INT_BIT
#define PEF_WAIT_NOT_TIME_CRIT       PEF_WAIT_NOT_HW_INT
#define PEF_WAIT_NOT_PM_LOCKED_STACK_BIT PEF_WAIT_NOT_NESTED_EXEC_BIT
#define PEF_WAIT_NOT_PM_LOCKED_STACK     PEF_WAIT_NOT_NESTED_EXEC


/******************************************************************************
 *       F L A G S   F O R   B E G I N _ C R I T I C A L _ S E C T I O N,
 *                           E N T E R _ M U T E X
 *             A N D   W A I T _ S E M A P H O R E
 *****************************************************************************/

#define BLOCK_SVC_INTS_BIT      0
#define BLOCK_SVC_INTS          (1 << BLOCK_SVC_INTS_BIT)
#define BLOCK_SVC_IF_INTS_LOCKED_BIT    1
#define BLOCK_SVC_IF_INTS_LOCKED    (1 << BLOCK_SVC_IF_INTS_LOCKED_BIT)
#define BLOCK_ENABLE_INTS_BIT       2
#define BLOCK_ENABLE_INTS       (1 << BLOCK_ENABLE_INTS_BIT)
#define BLOCK_POLL_BIT          3
#define BLOCK_POLL          (1 << BLOCK_POLL_BIT)
#define BLOCK_THREAD_IDLE_BIT           4
#define BLOCK_THREAD_IDLE               (1 << BLOCK_THREAD_IDLE_BIT)
#define BLOCK_FORCE_SVC_INTS_BIT        5
#define BLOCK_FORCE_SVC_INTS            (1 << BLOCK_FORCE_SVC_INTS_BIT)

/******************************************************************************
 *  The following structures are pointed to by EBP when VxD routines are
 *  entered, both for VxD control calls and traps(I/O traps, software INT
 *  traps, etc.).  The first structure as DWORD values, the second WORD
 *  values and the last has BYTE values.
 *****************************************************************************/

struct Client_Reg_Struc {
    ULONG Client_EDI;           /* Client's EDI */
    ULONG Client_ESI;           /* Client's ESI */
    ULONG Client_EBP;           /* Client's EBP */
    ULONG Client_res0;          /* ESP at pushall */
    ULONG Client_EBX;           /* Client's EBX */
    ULONG Client_EDX;           /* Client's EDX */
    ULONG Client_ECX;           /* Client's ECX */
    ULONG Client_EAX;           /* Client's EAX */
    ULONG Client_Error;         /* Dword error code */
    ULONG Client_EIP;           /* EIP */
    USHORT Client_CS;           /* CS */
    USHORT Client_res1;         /*   (padding) */
    ULONG Client_EFlags;        /* EFLAGS */
    ULONG Client_ESP;           /* ESP */
    USHORT Client_SS;           /* SS */
    USHORT Client_res2;         /*   (padding) */
    USHORT Client_ES;           /* ES */
    USHORT Client_res3;         /*   (padding) */
    USHORT Client_DS;           /* DS */
    USHORT Client_res4;         /*   (padding) */
    USHORT Client_FS;           /* FS */
    USHORT Client_res5;         /*   (padding) */
    USHORT Client_GS;           /* GS */
    USHORT Client_res6;         /*   (padding) */
    ULONG Client_Alt_EIP;
    USHORT Client_Alt_CS;
    USHORT Client_res7;
    ULONG Client_Alt_EFlags;
    ULONG Client_Alt_ESP;
    USHORT Client_Alt_SS;
    USHORT Client_res8;
    USHORT Client_Alt_ES;
    USHORT Client_res9;
    USHORT Client_Alt_DS;
    USHORT Client_res10;
    USHORT Client_Alt_FS;
    USHORT Client_res11;
    USHORT Client_Alt_GS;
    USHORT Client_res12;
};


struct Client_Word_Reg_Struc {
    USHORT Client_DI;           /* Client's DI */
    USHORT Client_res13;        /*   (padding) */
    USHORT Client_SI;           /* Client's SI */
    USHORT Client_res14;        /*   (padding) */
    USHORT Client_BP;           /* Client's BP */
    USHORT Client_res15;        /*   (padding) */
    ULONG Client_res16;         /* ESP at pushall */
    USHORT Client_BX;           /* Client's BX */
    USHORT Client_res17;        /*   (padding) */
    USHORT Client_DX;           /* Client's DX */
    USHORT Client_res18;        /*   (padding) */
    USHORT Client_CX;           /* Client's CX */
    USHORT Client_res19;        /*   (padding) */
    USHORT Client_AX;           /* Client's AX */
    USHORT Client_res20;        /*   (padding) */
    ULONG Client_res21;         /* Dword error code */
    USHORT Client_IP;           /* Client's IP */
    USHORT Client_res22;        /*   (padding) */
    ULONG Client_res23;         /* CS */
    USHORT Client_Flags;        /* Client's flags (low) */
    USHORT Client_res24;        /*   (padding) */
    USHORT Client_SP;           /* SP */
    USHORT Client_res25;
    ULONG Client_res26[5];
    USHORT Client_Alt_IP;
    USHORT Client_res27;
    ULONG Client_res28;
    USHORT Client_Alt_Flags;
    USHORT Client_res29;
    USHORT Client_Alt_SP;
};



struct Client_Byte_Reg_Struc {
    ULONG Client_res30[4];      /* EDI, ESI, EBP, ESP at pushall */
    UCHAR Client_BL;            /* Client's BL */
    UCHAR Client_BH;            /* Client's BH */
    USHORT Client_res31;
    UCHAR Client_DL;            /* Client's DL */
    UCHAR Client_DH;            /* Client's DH */
    USHORT Client_res32;
    UCHAR Client_CL;            /* Client's CL */
    UCHAR Client_CH;            /* Client's CH */
    USHORT Client_res33;
    UCHAR Client_AL;            /* Client's AL */
    UCHAR Client_AH;            /* Client's AH */
};


typedef union tagCLIENT_STRUC { /* */
    struct Client_Reg_Struc       CRS;
    struct Client_Word_Reg_Struc  CWRS;
    struct Client_Byte_Reg_Struc  CBRS;
    } CLIENT_STRUCT;

typedef struct Client_Reg_Struc CRS;
typedef CRS *PCRS;

#if 0   /* causes problems with MASM 6 */
/* ASM
.ERRNZ Client_SP - Client_ESP
.ERRNZ Client_AL - Client_EAX
*/
#endif

#define DYNA_LINK_INT   0x20

/* ASM

;***	DeclareNonstandardCcallService
;
;	Declare services as conforming to the C calling convention
;	for parameter-passing, but *not* conforming to the C calling
;	convention for register usage.
;
;	Services which do not use the C calling convention for
;	parameter-passing need not be declared as nonstandard.
;
;	arglst - list of services to declare as nonstandard
;
DeclareNonstandardCcallService macro arglst
	irp	x,<arglst>
	    ??_nonstandardccall_&x = 1
	endm
endm

;
; The following VMM services are nonstandard:
;       _BlockOnID and _LocalizeSprintf modify no registers except flags.
;       _SetLastV86Page modifies no registers except EAX and flags.
;       _Assert_Range returns information in flags.
;
DeclareNonstandardCcallService <_BlockOnID, _LocalizeSprintf>
DeclareNonstandardCcallService <_SetLastV86Page, _Assert_Range>

BeginDoc
;******************************************************************************
; The VMMCall and VxDCall macros provide a dynamic link to the VMM and VxD
;   service routines. For example:
;
;   VMMCall Enable_VM_Ints      ; Equivalent to STI in VM code
;
;   mov     eax,[My_IRQ_Handle]
;   VxDCall VPICD_Set_Int_Request   ; Set IRQ for my device's interrupt
;
; Note that Enable_VM_Ints is defined in VMM.INC and VPICD_Set_Int_Request is
;   defined in VPICD.INC
;
;==============================================================================
EndDoc


BeginDoc
;******************************************************************************
; VxDCall
;==============================================================================
;
;   BlockOnID is always FAST because it doesn't
;   conform to the C calling convention.  (It preserves
;   all registers.)

EndDoc

DefTable MACRO vt, vn
    vt EQU <vn>
ENDM

GenDD2 MACRO vt, sn, jf
    dd  OFFSET32 vt[sn+jf]
ENDM

GenDD   MACRO   P, vid, snum, jflag
    LOCAL   vtable
IFDEF   @@VxDName&vid
    Deftable    vtable, %@@VxDName&vid
    EXTRN   vtable:DWORD
    GenDD2 %vtable, snum, jflag
ELSE
    dd  @@&P+jflag
ENDIF

ENDM


VxDCall MACRO P, Param, flags
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    ifdef ??_nonstandardccall_&P
    PushCParams <Param>, <FAST>
    else
    PushCParams <Param>, <flags>
    endif
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, 0
    ifdef ??_nonstandardccall_&P
	ClearCParams PRESERVE_FLAGS
    else
	ClearCParams
    endif
    ENDM

VxDJmp  MACRO P, Param
    ??_vxdid = (@@&P SHR 16)
    ??_servicenum = (@@&P AND 0FFFFh)
    .errnb <Param>, <Parameters may not be passed to VxDJmp or VMMJmp>
    int Dyna_Link_Int
    GenDD   P, %??_vxdid, %??_servicenum, DL_Jmp_Mask
    ENDM

DL_Jmp_Mask EQU 8000h
DL_Jmp_Bit  EQU 0Fh

VMMCall MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDCall <P>, <Param>
    ENDM

VMMJmp MACRO P, Param
    .ERRNZ (@@&P SHR 16) - VMM_DEVICE_ID
    VxDJmp <P>, <Param>
    ENDM

BeginDoc
;******************************************************************************
; Segment definition macros
;
; The segment definition macros are a convenience used in defining the
;   segments used by the device driver. They are:
;VxD_INIT_CODE_SEG defines start of initialization code segment
;VxD_INIT_CODE_ENDS defines end of initialization code segment
;VxD_ICODE_SEG is an alias for VxD_INIT_CODE_SEG
;VxD_ICODE_ENDS is an alias for VxD_INIT_CODE_ENDS
;VxD_IDATA_SEG   defines start of initialization data segment
;VxD_IDATA_ENDS  defines end of initialization data segment
;VxD_CODE_SEG    defines start of always present code segment
;VxD_CODE_ENDS   defines end of always present code segment
;VxD_DATA_SEG    defines start of always present data segment
;VxD_DATA_ENDS   defines end of always present data segment
;VxD_LOCKED_CODE_SEG    defines start of always present code segment
;VxD_LOCKED_CODE_ENDS   defines end of always present code segment
;VxD_PAGEABLE_CODE_SEG  defines start of swappable code segment
;VxD_PAGEABLE_CODE_ENDS defines end of swappable code segment
;VxD_DEBUG_ONLY_CODE_SEG defines code only loaded if debugger is present
;VxD_DEBUG_ONLY_CODE_ENDS
;VxD_DEBUG_ONLY_DATA_SEG defines data only loaded if debugger is present
;VxD_DEBUG_ONLY_DATA_ENDS
;==============================================================================




EndDoc


;   Resident protected mode code

VxD_CODE_SEG    EQU <VxD_LOCKED_CODE_SEG>
VxD_CODE_ENDS   EQU <VxD_LOCKED_CODE_ENDS>


VxD_LOCKED_CODE_SEG MACRO
_LTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_LCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_LOCKED_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_LTEXT   ENDS
        ENDM


;   Pageable protected mode code

VxD_PAGEABLE_CODE_SEG MACRO
_PTEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_PCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_PAGEABLE_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_PTEXT   ENDS
        ENDM


;   Debug only protected mode code

VxD_DEBUG_ONLY_CODE_SEG MACRO
_DBOCODE    SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_DBOCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
        ENDM

VxD_DEBUG_ONLY_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_DBOCODE    ENDS
        ENDM


;   Protected mode initialization code

VxD_INIT_CODE_SEG   MACRO
_ITEXT  SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_ICODE
    ASSUME  cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT
    ENDM

VxD_INIT_CODE_ENDS  MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_ITEXT  ENDS
        ENDM

VxD_ICODE_SEG equ VxD_INIT_CODE_SEG
VxD_ICODE_ENDS equ VxD_INIT_CODE_ENDS


;   Resident protected mode data

VxD_DATA_SEG    EQU <VxD_LOCKED_DATA_SEG>
VxD_DATA_ENDS   EQU <VxD_LOCKED_DATA_ENDS>

VxD_LOCKED_DATA_SEG MACRO NO_ALIGN
_LDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_LOCKED_DATA_ENDS MACRO
_LDATA   ENDS
        ENDM


;   Protected mode initialization data

VxD_IDATA_SEG   MACRO
_IDATA  SEGMENT
        ENDM
VxD_IDATA_ENDS  MACRO
_IDATA  ENDS
        ENDM


;   Pageable protected mode data

VxD_PAGEABLE_DATA_SEG MACRO NO_ALIGN
_PDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_PAGEABLE_DATA_ENDS MACRO
_PDATA   ENDS
        ENDM


;   Static code segment for DL-VxDs

VxD_STATIC_CODE_SEG MACRO
_STEXT   SEGMENT
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_SCODE
   ASSUME   cs:FLAT, ds:FLAT, es:FLAT, ss:FLAT

        ENDM

VxD_STATIC_CODE_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_STEXT   ENDS
        ENDM


;   Static data segment for DL-VxDs

VxD_STATIC_DATA_SEG MACRO NO_ALIGN
_SDATA   SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_STATIC_DATA_ENDS MACRO
_SDATA   ENDS
        ENDM

;   Debug only protected mode data

VxD_DEBUG_ONLY_DATA_SEG MACRO NO_ALIGN
_DBODATA    SEGMENT
IFB <NO_ALIGN>
    ALIGN 4
ENDIF
        ENDM

VxD_DEBUG_ONLY_DATA_ENDS MACRO
_DBODATA    ENDS
        ENDM


;   16 bit code/data put in the init group (IGROUP)

VxD_16BIT_INIT_SEG  MACRO
_16ICODE SEGMENT
ASSUME CS:_16ICODE, DS:NOTHING, ES:NOTHING, SS:NOTHING
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_16ICODE
          ENDM

VxD_16BIT_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_16ICODE ENDS
           ENDM

;   Real mode segment (16 bit)

VxD_REAL_INIT_SEG  MACRO
_RCODE SEGMENT
ASSUME CS:_RCODE, DS:_RCODE, ES:_RCODE, SS:_RCODE
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHL 4 + ??_RCODE
          ENDM

VxD_REAL_INIT_ENDS MACRO
??_CUR_CODE_SEG = ??_CUR_CODE_SEG SHR 4
_RCODE ENDS
           ENDM
*/

#endif // Not_VxD

#ifndef DDK_VERSION

#ifdef WIN31COMPAT
#define DDK_VERSION 0x30A           /* 3.10 */
#else  /* WIN31COMPAT */
#define DDK_VERSION 0x400           /* 4.00 */
#endif

#endif

struct VxD_Desc_Block {
    ULONG DDB_Next;         /* VMM RESERVED FIELD */
    USHORT DDB_SDK_Version;     /* INIT <DDK_VERSION> RESERVED FIELD */
    USHORT DDB_Req_Device_Number;   /* INIT <UNDEFINED_DEVICE_ID> */
    UCHAR DDB_Dev_Major_Version;    /* INIT <0> Major device number */
    UCHAR DDB_Dev_Minor_Version;    /* INIT <0> Minor device number */
    USHORT DDB_Flags;           /* INIT <0> for init calls complete */
    UCHAR DDB_Name[8];          /* AINIT <"        "> Device name */
    ULONG DDB_Init_Order;       /* INIT <UNDEFINED_INIT_ORDER> */
    ULONG DDB_Control_Proc;     /* Offset of control procedure */
    ULONG DDB_V86_API_Proc;     /* INIT <0> Offset of API procedure */
    ULONG DDB_PM_API_Proc;      /* INIT <0> Offset of API procedure */
    ULONG DDB_V86_API_CSIP;     /* INIT <0> CS:IP of API entry point */
    ULONG DDB_PM_API_CSIP;      /* INIT <0> CS:IP of API entry point */
    ULONG DDB_Reference_Data;       /* Reference data from real mode */
    ULONG DDB_Service_Table_Ptr;    /* INIT <0> Pointer to service table */
    ULONG DDB_Service_Table_Size;   /* INIT <0> Number of services */
    ULONG DDB_Win32_Service_Table;  /* INIT <0> Pointer to Win32 services */
    ULONG DDB_Prev;         /* INIT <'Prev'> Ptr to prev 4.0 DDB */
    ULONG DDB_Reserved0;        /* INIT <0> Reserved */
    ULONG DDB_Reserved1;        /* INIT <'Rsv1'> Reserved */
    ULONG DDB_Reserved2;        /* INIT <'Rsv2'> Reserved */
    ULONG DDB_Reserved3;        /* INIT <'Rsv3'> Reserved */
};

typedef struct VxD_Desc_Block       *PVMMDDB;
typedef PVMMDDB             *PPVMMDDB;

#ifndef Not_VxD

/*
 *  Flag values for DDB_Flags
 */

#define DDB_SYS_CRIT_INIT_DONE_BIT  0
#define DDB_SYS_CRIT_INIT_DONE      (1 << DDB_SYS_CRIT_INIT_DONE_BIT)
#define DDB_DEVICE_INIT_DONE_BIT    1
#define DDB_DEVICE_INIT_DONE        (1 << DDB_DEVICE_INIT_DONE_BIT)

#define DDB_HAS_WIN32_SVCS_BIT      14
#define DDB_HAS_WIN32_SVCS      (1 << DDB_HAS_WIN32_SVCS_BIT)
#define DDB_DYNAMIC_VXD_BIT     15
#define DDB_DYNAMIC_VXD         (1 << DDB_DYNAMIC_VXD_BIT)

#define DDB_DEVICE_DYNALINKED_BIT   13
#define DDB_DEVICE_DYNALINKED       (1 << DDB_DEVICE_DYNALINKED_BIT)


/* ASM
BeginDoc
;******************************************************************************
;
;   Declare_Virtual_Device macro
;
; ???? Write something here ????
;
;==============================================================================
EndDoc
Declare_Virtual_Device MACRO Name, Major_Ver, Minor_Ver, Ctrl_Proc, Device_Num, Init_Order, V86_Proc, PM_Proc, Reference_Data
    LOCAL   V86_API_Offset, PM_API_Offset, Serv_Tab_Offset, Serv_Tab_Len, Ref_Data_Offset

dev_id_err MACRO

IFNDEF Name&_Name_Based
.err <Device ID required when providing services>
ENDIF
    ENDM

IFB <V86_Proc>
    V86_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    V86_API_Offset EQU <OFFSET32 V86_Proc>
ENDIF

IFB <PM_Proc>
    PM_API_Offset EQU 0
ELSE
 IFB <Device_Num>
    dev_id_err
 ENDIF
    PM_API_Offset EQU <OFFSET32 PM_Proc>
ENDIF

IFDEF Name&_Service_Table
 IFB <Device_Num>
    dev_id_err
 ELSE
  IFE Device_Num - UNDEFINED_DEVICE_ID
    dev_id_err
  ENDIF
 ENDIF
    Serv_Tab_Offset EQU <OFFSET32 Name&_Service_Table>
    Serv_Tab_Len    EQU Num_&Name&_Services
ELSE
    Serv_Tab_Offset EQU 0
    Serv_Tab_Len    EQU 0
ENDIF

IFNB    <Device_Num>
  .erre (Device_Num LT BASEID_FOR_NAMEBASEDVXD), <Device ID  must be less than BASEID_FOR_NAMEBASEDVXD>
ENDIF

IFB <Reference_Data>
        Ref_Data_Offset EQU 0
ELSE
        Ref_Data_Offset EQU   <OFFSET32 Reference_Data>
ENDIF

IFDEF DEBUG
VxD_IDATA_SEG
    db  0dh, 0ah, 'D_E_B_U_G===>'
        db      "&Name", '<===', 0dh, 0ah
VxD_IDATA_ENDS
ENDIF

VxD_LOCKED_DATA_SEG

PUBLIC Name&_DDB
Name&_DDB VxD_Desc_Block <,,Device_Num,Major_Ver,Minor_Ver,,"&Name",Init_Order,\
             OFFSET32 Ctrl_Proc, V86_API_Offset, PM_API_Offset, \
             ,,Ref_Data_Offset,Serv_Tab_Offset, Serv_Tab_Len>

VxD_LOCKED_DATA_ENDS

    ENDM

;BeginDoc   ; comment out to make masm work ???
;******************************************************************************
; The Begin_Control_Dispatch macro is used for building a table for dispatching
; messages passed to the VxD_Control procedure.  It is used with
; Control_Dispatch and End_Control_Dispatch.  The only parameter is used to
; contruct the procedure label by adding "_Control" to the end (normally the
; device name is used i.e. VKD results in creating the procedure VKD_Control,
; this created procedure label must be included in Declare_Virtual_Device)
;
; An example of building a complete dispatch table:
;
; Begin_Control_Dispatch MyDevice
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
; Control_Dispatch  Sys_VM_Init, MyDeviceSysInitProcedure
; Control_Dispatch  Create_VM,   MyDeviceCreateVMProcedure
; End_Control_Dispatch MyDevice
;
; (NOTE: Control_Dispatch can be used without Begin_Control_Dispatch, but
;    then it is the programmer's responsibility for declaring a procedure
;    in locked code (VxD_LOCKED_CODE_SEG) and returning Carry clear for
;    any messages not processed.  The advantage in using
;    Begin_Control_Dispatch is when a large # of messages are processed by
;    a device, because a jump table is built which will usually require
;    less code space then the compares and jumps that are done when
;    Control_Dispatch is used alone.
;
;==============================================================================
;EndDoc
Begin_Control_Dispatch MACRO VxD_Name, p1, p2
??_cd_low = 0FFFFFFFFh
??_cd_high = 0

BeginProc VxD_Name&_Control, p1, p2, LOCKED
ENDM

End_Control_Dispatch   MACRO VxD_Name
    LOCAL ignore, table

procoff MACRO num
IFDEF ??_cd_&&num
    dd  OFFSET32 ??_cd_&&num
ELSE
    dd  OFFSET32 ignore
ENDIF
ENDM

IF ??_cd_low EQ ??_cd_high
    cmp eax, ??_cd_low
    ?merge  <jz>,,,,,<??_cd_>, %(??_cd_low)
    clc
    ret
ELSE
IF ??_cd_low GT 0
    sub eax, ??_cd_low
ENDIF ; ??cd_low GT 0
    cmp eax, ??_cd_high - ??_cd_low + 1
    jae short ignore
    jmp [eax*4+table]
ignore:
    clc             ;; this is not redundant
    ret

table label dword
    REPT   ??_cd_high - ??_cd_low + 1
    procoff %(??_cd_low)
    ??_cd_low = ??_cd_low + 1
    ENDM
ENDIF

EndProc VxD_Name&_Control

PURGE procoff
PURGE Begin_Control_Dispatch
PURGE Control_Dispatch
PURGE End_Control_Dispatch
ENDM

BeginDoc
;******************************************************************************
; The Control_Dispatch macro is used for dispatching based on message
;   passed to the VxD_Control procedure. E.G.:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure
;
; For "C" control functions:
;
; Control_Dispatch  Device_Init, MyDeviceInitProcedure, sCall, <arglst>
;
; The "callc" can be sCall, cCall or pCall depending on the calling
; convention.  "arglst" is the list of registers to pass as parameters
; to "C" control procedure.  The "C" control procedure returns VXD_SUCCESS
; or VXD_FAILURE and the carry flag gets set appropriately.
;
; (NOTE: Control_Dispatch can be used with Begin_Control_Dispatch and
;    End_Control_Dispatch to create a jump table for dispatching messages,
;    when a large # of messages are processed.)
;
;==============================================================================
EndDoc
Control_Dispatch MACRO Service, Procedure, callc, arglst
    LOCAL Skip_Interseg_Jump

.errnz ?_LCODE, <Control_Dispatch must be in VxD_LOCKED_CODE_SEG.>

IFB <callc>

IFDEF ??_cd_low
Equate_Service MACRO Serv
??_cd_&&Serv equ Procedure
ENDM

Equate_Service %(Service)

IF Service LT ??_cd_low
??_cd_low = Service
ENDIF
IF Service GT ??_cd_high
??_cd_high = Service
ENDIF

PURGE Equate_Service

ELSE
    cmp eax, Service
    jz  Procedure
ENDIF

ELSE ; ifb callc

    cmp eax, Service
    jne SHORT Skip_Interseg_Jump
    callc   Procedure, <arglst>
IF Service EQ PNP_NEW_DEVNODE
    stc
ELSE
    cmp eax,1
ENDIF
    ret
Skip_Interseg_Jump:

ENDIF ; ifb callc

    ENDM
*/


/******************************************************************************
 *  The following are the definitions for the "type of I/O" parameter passed
 *  to a I/O trap routine.
 *****************************************************************************/

#define BYTE_INPUT  0x000
#define BYTE_OUTPUT 0x004
#define WORD_INPUT  0x008
#define WORD_OUTPUT 0x00C
#define DWORD_INPUT 0x010
#define DWORD_OUTPUT    0x014

#define OUTPUT_BIT  2
#define OUTPUT      (1 << OUTPUT_BIT)
#define WORD_IO_BIT 3
#define WORD_IO     (1 << WORD_IO_BIT)
#define DWORD_IO_BIT    4
#define DWORD_IO    (1 << DWORD_IO_BIT)

#define STRING_IO_BIT   5
#define STRING_IO   (1 << STRING_IO_BIT)
#define REP_IO_BIT  6
#define REP_IO      (1 << REP_IO_BIT)
#define ADDR_32_IO_BIT  7
#define ADDR_32_IO  (1 << ADDR_32_IO_BIT)
#define REVERSE_IO_BIT  8
#define REVERSE_IO  (1 << REVERSE_IO_BIT)

#define IO_SEG_MASK 0x0FFFF0000     /* Use this to get segment */
#define IO_SEG_SHIFT    0x10            /* Must shift right this many */


/* ASM
BeginDoc
;******************************************************************************
;
;   Dispatch_Byte_IO macro
;
; Dispatch_Byte_IO Byte_In_Proc, Byte_Out_Proc
;==============================================================================
EndDoc
Dispatch_Byte_IO MACRO In_Proc, Out_Proc
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
IFIDNI <In_Proc>, <Fall_Through>
    je  Out_Proc
ELSE
IFIDNI <Out_Proc>, <Fall_Through>
    jb  In_Proc
ELSE
    je  Out_Proc
    jmp In_Proc
ENDIF
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   Emulate_Non_Byte_IO
;
; Emulate_Non_Byte_IO
;
;==============================================================================
EndDoc
Emulate_Non_Byte_IO MACRO
    LOCAL   Byte_IO
    cmp ecx, Byte_Output
    jbe SHORT Byte_IO
    VMMJmp  Simulate_IO
Byte_IO:
    ENDM
*/


/* ASM
BeginDoc
;******************************************************************************
;
; Begin_VxD_IO_Table
;
;   Example:
; Begin_VxD_IO_Table MyTableName
;
;==============================================================================
EndDoc
*/


struct VxD_IOT_Hdr {
    USHORT VxD_IO_Ports;
};

struct VxD_IO_Struc {
    USHORT VxD_IO_Port;
    ULONG VxD_IO_Proc;
};


/* ASM
.ERRNZ SIZE VxD_IOT_Hdr - 2 ; Begin_VxD_IO_Table creates a 1 word count hdr
Begin_VxD_IO_Table MACRO Table_Name
PUBLIC Table_Name
Table_Name LABEL WORD

ifndef MASM6
IF2
IFNDEF Table_Name&_Entries
.err <No End_VxD_IO_Table for &Table_Name>
ENDIF
    dw  Table_Name&_Entries
ELSE
    dw  ?
ENDIF
ELSE  ; MASM6 - skip the warning message - we'll get it anyway
    dw  Table_Name&_Entries
ENDIF ; MASM6

    ENDM

.ERRNZ SIZE VxD_IO_Struc - 6    ; VxD_IO creates 6 byte I/O port entries
VxD_IO MACRO Port, Proc_Name
    dw  Port
    dd  OFFSET32 Proc_Name
    ENDM

End_VxD_IO_Table MACRO Table_Name

IFNDEF Table_Name
.err <No Begin_VxD_IO_Table for &Table_Name>
ELSE
    Table_Name&_Entries EQU (($-Table_Name)-2) / (SIZE VxD_IO_Struc)
IF Table_Name&_Entries LE 0
.err <Invalid number of port traps in &Table_Name>
ENDIF
ENDIF
        ENDM


;******************************************************************************
;
; Push_Client_State takes an optional argument which if equal to the symbol
; USES_EDI saves code size by suppressing the preservation of the EDI register.
;
; Similarly, Pop_Client_State takes an optional argument which if equal to
; the symbol USES_ESI saves code size by suppressing the preservation of
; the ESI register.
;
;******************************************************************************

Push_Client_State MACRO Can_Trash_EDI
    sub esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed + SIZE Client_Reg_Struc
    ifidni <Can_Trash_EDI>, <USES_EDI>
    mov edi, esp
    VMMCall Save_Client_State
    else
    push    edi
    lea edi, [esp+4]
    VMMCall Save_Client_State
    pop edi
    endif
    ENDM

Pop_Client_State MACRO Can_Trash_ESI
    ifdifi <Can_Trash_ESI>, <USES_ESI>
    push    esi
    lea esi, [esp+4]
    VMMCall Restore_Client_State
    pop esi
    else
    mov esi, esp
    VMMCall Restore_Client_State
    endif
    add esp, SIZE Client_Reg_Struc
    ??_pushed = ??_pushed - SIZE Client_Reg_Struc
    ENDM

BeginDoc
;******************************************************************************
;
;   CallRet -- Call procedure and return.  For debugging purposes only.
;          If compiled with debugging then this will generate a call
;          followed by a return.  If non-debugging version then the
;          specified label will be jumped to.
;
;   PARAMETERS:
;   Label_Name = Procedure to be called
;
;   EXIT:
;   Return from current procedure
;
;------------------------------------------------------------------------------
EndDoc

CallRet MACRO P1, P2
IFDEF DEBUG
IFIDNI <P1>, <SHORT>
    call    P2
ELSE
    call    P1
ENDIF
    ret
ELSE
    jmp P1 P2
ENDIF
    ENDM

BeginDoc
;******************************************************************************
;
;   VxDCallRet
;   VMMCallRet -- CallRet for VxDCall and VMMCall.
;
;------------------------------------------------------------------------------
EndDoc

IFDEF   DEBUG

VxDCallRet macro p:req
    VxDCall p
    ret
endm

VMMCallRet macro p:req
    VMMCall p
    ret
endm

ELSE ; RETAIL

VxDCallRet equ <VxDJmp>
VMMCallRet equ <VMMJmp>

ENDIF


; ebp offsets to segments pushed by PMode_Fault in Fault_Dispatch
PClient_DS equ WORD PTR -4
PClient_ES equ WORD PTR -8
PClient_FS equ WORD PTR -12
PClient_GS equ WORD PTR -16


;******************************************************************************
;
; Client_Ptr_Flat takes an optional third argument which if equal to the
; symbol USES_EAX saves code size by supressing the preservation of the
; EAX register.  The USES_EAX flag is ignored if the destination register
; is itself EAX.
;
;******************************************************************************

Client_Ptr_Flat MACRO Reg_32, Cli_Seg, Cli_Off, Can_Trash_EAX

IFDIFI <Reg_32>, <EAX>
    IFDIFI <Can_Trash_EAX>, <USES_EAX>
    xchg    Reg_32, eax
    ENDIF
ENDIF
IFB <Cli_Off>
    mov ax, (Client_&Cli_Seg * 100h) + 0FFh
ELSE
    mov ax, (Client_&Cli_Seg * 100h) + Client_&Cli_Off
ENDIF
    VMMCall Map_Flat

IFDIFI <Reg_32>, <EAX>
    xchg    Reg_32, eax
ENDIF

    ENDM

;------------------------------------------------------------------------------

VxDint  MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
    VMMCall Exec_VxD_Int
    ENDM

VxDintMustComplete MACRO   Int_Number
    if  (OPATTR Int_Number) AND 4
    push    Int_Number
    else
    push    DWORD PTR Int_Number
    endif
        VMMCall _ExecVxDIntMustComplete
    ENDM


*/

#endif // Not_VxD


/******************************************************************************
 *
 *  The following equates are for flags sent to the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/
#define DUPLICATE_DEVICE_ID_BIT     0   /* loaded */
#define DUPLICATE_DEVICE_ID     (1 << DUPLICATE_DEVICE_ID_BIT)
#define DUPLICATE_FROM_INT2F_BIT    1   /* loaded from INT 2F list */
#define DUPLICATE_FROM_INT2F        (1 << DUPLICATE_FROM_INT2F_BIT)
#define LOADING_FROM_INT2F_BIT      2   /* in the INT 2F device list */
#define LOADING_FROM_INT2F      (1 << LOADING_FROM_INT2F_BIT)


/******************************************************************************
 *
 *  The following equates are used to indicate the result of the real mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define DEVICE_LOAD_OK      0   /* load protected mode portion */
#define ABORT_DEVICE_LOAD   1   /* don't load protected mode portion */
#define ABORT_WIN386_LOAD   2   /* fatal-error: abort load of Win386 */



#define NO_FAIL_MESSAGE_BIT 15  /* set bit to suppress error message */
#define NO_FAIL_MESSAGE     (1 << NO_FAIL_MESSAGE_BIT)


/******************************************************************************
 *
 *  The following equates define the loader services available to the real-mode
 *  initialization portion of a device driver:
 *
 *****************************************************************************/

#define LDRSRV_GET_PROFILE_STRING   0   /* search SYSTEM.INI for string */
#define LDRSRV_GET_NEXT_PROFILE_STRING  1   /* search for next string */
#define LDRSRV_RESERVED         2   /* RESERVED */
#define LDRSRV_GET_PROFILE_BOOLEAN  3   /* search SYSTEM.INI for boolean */
#define LDRSRV_GET_PROFILE_DECIMAL_INT  4   /* search SYSTEM.INI for integer */
#define LDRSRV_GET_PROFILE_HEX_INT  5   /* search SYSTEM.INI for hex int */
#define LDRSRV_COPY_EXTENDED_MEMORY 6   /* allocate/init extended memory */
#define LDRSRV_GET_MEMORY_INFO      7   /* get info about machine memory */

/* Add the new loader services contiguously here */

/****** Registry services for Real mode init time *************
 * The parameters for these are as defined in Windows.h for the
 * corresponding Win Reg API and should be on Stack. These are
 * C Callable except that the function no has to be in AX
 * ************************************************************
*/

#define LDRSRV_RegOpenKey       0x100
#define LDRSRV_RegCreateKey     0x101
#define LDRSRV_RegCloseKey      0x102
#define LDRSRV_RegDeleteKey     0x103
#define LDRSRV_RegSetValue      0x104
#define LDRSRV_RegQueryValue        0x105
#define LDRSRV_RegEnumKey       0x106
#define LDRSRV_RegDeleteValue       0x107
#define LDRSRV_RegEnumValue     0x108
#define LDRSRV_RegQueryValueEx      0x109
#define LDRSRV_RegSetValueEx        0x10A
#define LDRSRV_RegFlushKey      0x10B


/*
 *  For the Copy_Extended_Memory service, the following types of memory can be
 *  requested:
 */

#define LDRSRV_COPY_INIT        1   /* memory discarded after init */
#define LDRSRV_COPY_LOCKED      2   /* locked memory */
#define LDRSRV_COPY_PAGEABLE        3   /* pageable memory */

/****************************************************************************
*
*   Object types supported by the vxd loader
*
*  Notes : Low bit of all CODE type objects should be set (VXDLDR uses this)
*           Also Init type objects should be added to the second part of the
*           list (which starts with ICODE_OBJ).
*
*****************************************************************************/

#define RCODE_OBJ       -1

#define LCODE_OBJ       0x01
#define LDATA_OBJ       0x02
#define PCODE_OBJ       0x03
#define PDATA_OBJ       0x04
#define SCODE_OBJ       0x05
#define SDATA_OBJ       0x06
#define CODE16_OBJ      0x07
#define LMSG_OBJ        0x08
#define PMSG_OBJ        0x09

#define	DBOC_OBJ	0x0B
#define	DBOD_OBJ	0x0C

#define ICODE_OBJ       0x11
#define IDATA_OBJ       0x12
#define ICODE16_OBJ     0x13
#define IMSG_OBJ        0x14


struct ObjectLocation {
    ULONG OL_LinearAddr ;
    ULONG OL_Size ;
    UCHAR  OL_ObjType ;
} ;

#define MAXOBJECTS  30

/*****************************************************************************
 *
 *      Device_Location structure
 *
 *****************************************************************************/

struct Device_Location_List {
    ULONG DLL_DDB ;
    UCHAR DLL_NumObjects ;
    struct ObjectLocation DLL_ObjLocation[1];
};


/* ========================================================================= */

/*
 *  CR0 bit assignments
 */
#define PE_BIT      0   /* 1 = Protected Mode */
#define PE_MASK     (1 << PE_BIT)
#define MP_BIT      1   /* 1 = Monitor Coprocessor */
#define MP_MASK     (1 << MP_BIT)
#define EM_BIT      2   /* 1 = Emulate Math Coprocessor */
#define EM_MASK     (1 << EM_BIT)
#define TS_BIT      3   /* 1 = Task Switch occured */
#define TS_MASK     (1 << TS_BIT)
#define ET_BIT      4   /* 1 = 387 present, 0 = 287 present */
#define ET_MASK     (1 << ET_BIT)
#define PG_BIT      31  /* 1 = paging enabled, 0 = paging disabled */
#define PG_MASK     (1 << PG_BIT)


/*
 *  EFLAGs bit assignments
 */
#define CF_BIT      0
#define CF_MASK     (1 << CF_BIT)
#define PF_BIT      2
#define PF_MASK     (1 << PF_BIT)
#define AF_BIT      4
#define AF_MASK     (1 << AF_BIT)
#define ZF_BIT      6
#define ZF_MASK     (1 << ZF_BIT)
#define SF_BIT      7
#define SF_MASK     (1 << SF_BIT)
#define TF_BIT      8
#define TF_MASK     (1 << TF_BIT)
#define IF_BIT      9
#define IF_MASK     (1 << IF_BIT)
#define DF_BIT      10
#define DF_MASK     (1 << DF_BIT)
#define OF_BIT      11  /* Overflow flag */
#define OF_MASK     (1 << OF_BIT)
#define IOPL_MASK   0x3000  /* IOPL flags */
#define IOPL_BIT0   12
#define IOPL_BIT1   13
#define NT_BIT      14  /* Nested task flag */
#define NT_MASK     (1 << NT_BIT)
#define RF_BIT      16  /* Resume flag */
#define RF_MASK     (1 << RF_BIT)
#define VM_BIT      17  /* Virtual Mode flag */
#define VM_MASK     (1 << VM_BIT)
#define AC_BIT      18  /* Alignment check */
#define AC_MASK     (1 << AC_BIT)
#define VIF_BIT     19  /* Virtual Interrupt flag */
#define VIF_MASK    (1 << VIF_BIT)
#define VIP_BIT     20  /* Virtual Interrupt pending */
#define VIP_MASK    (1 << VIP_BIT)



/* ASM
;------------------------------------------------------------------------------
;
;     Temporary MASM macros (to be removed when supported by MASM)
;
;------------------------------------------------------------------------------

IFDEF MASM6
loopde EQU <looped>
loopdne EQU <loopned>
loopdz EQU <loopzd>
loopdnz EQU <loopnzd>
ELSE
loopd EQU <loop>
loopde EQU <loope>
loopdne EQU <loopne>
loopdz EQU <loopz>
loopdnz EQU <loopnz>
ENDIF
*/


/******************************************************************************
 *              PAGE TABLE EQUATES
 *****************************************************************************/


#define P_SIZE      0x1000      /* page size */

/******************************************************************************
 *
 *              PAGE TABLE ENTRY BITS
 *
 *****************************************************************************/

#define P_PRESBIT   0
#define P_PRES      (1 << P_PRESBIT)
#define P_WRITEBIT  1
#define P_WRITE     (1 << P_WRITEBIT)
#define P_USERBIT   2
#define P_USER      (1 << P_USERBIT)
#define P_ACCBIT    5
#define P_ACC       (1 << P_ACCBIT)
#define P_DIRTYBIT  6
#define P_DIRTY     (1 << P_DIRTYBIT)

#define P_AVAIL     (P_PRES+P_WRITE+P_USER) /* avail to user & present */

/****************************************************
 *
 *  Page types for page allocator calls
 *
 ***************************************************/

#define PG_VM       0
#define PG_SYS      1
#define PG_RESERVED1    2
#define PG_PRIVATE  3
#define PG_RESERVED2    4
#define PG_RELOCK   5       /* PRIVATE to MMGR */
#define PG_INSTANCE 6
#define PG_HOOKED   7
#define PG_IGNORE   0xFFFFFFFF

/****************************************************
 *
 *  Definitions for the access byte in a descriptor
 *
 ***************************************************/

/*
 *  Following fields are common to segment and control descriptors
 */
#define D_PRES      0x080       /* present in memory */
#define D_NOTPRES   0       /* not present in memory */

#define D_DPL0      0       /* Ring 0 */
#define D_DPL1      0x020       /* Ring 1 */
#define D_DPL2      0x040       /* Ring 2 */
#define D_DPL3      0x060       /* Ring 3 */

#define D_SEG       0x010       /* Segment descriptor */
#define D_CTRL      0       /* Control descriptor */

#define D_GRAN_BYTE 0x000       /* Segment length is byte granular */
#define D_GRAN_PAGE 0x080       /* Segment length is page granular */
#define D_DEF16     0x000       /* Default operation size is 16 bits */
#define D_DEF32     0x040       /* Default operation size is 32 bits */


/*
 *  Following fields are specific to segment descriptors
 */
#define D_CODE      0x08        /* code */
#define D_DATA      0       /* data */

#define D_X     0       /* if code, exec only */
#define D_RX        0x02        /* if code, readable */
#define D_C     0x04        /* if code, conforming */

#define D_R     0       /* if data, read only */
#define D_W     0x02        /* if data, writable */
#define D_ED        0x04        /* if data, expand down */

#define D_ACCESSED  1       /* segment accessed bit */


/*
 *  Useful combination access rights bytes
 */
#define RW_DATA_TYPE    (D_PRES+D_SEG+D_DATA+D_W)
#define R_DATA_TYPE (D_PRES+D_SEG+D_DATA+D_R)
#define CODE_TYPE   (D_PRES+D_SEG+D_CODE+D_RX)

#define D_PAGE32    (D_GRAN_PAGE+D_DEF32)   /* 32 bit Page granular */

/*
 * Masks for selector fields
 */
#define SELECTOR_MASK   0xFFF8      /* selector index */
#define SEL_LOW_MASK    0xF8        /* mask for low byte of sel indx */
#define TABLE_MASK  0x04        /* table bit */
#define RPL_MASK    0x03        /* privilige bits */
#define RPL_CLR     (~RPL_MASK) /* clear ring bits */

#define IVT_ROM_DATA_SIZE   0x500

/*XLATOFF*/

#ifndef WINNT

#ifndef Not_VxD

#define ENABLE_INTERRUPTS() {__asm sti}
#define DISABLE_INTERRUPTS()    {__asm cli}

#define SAVE_FLAGS(flags) \
    __asm pushfd \
    __asm pop flags

#define RESTORE_FLAGS(flags) \
    __asm push flags \
    __asm popfd

#define IO_Delay() \
    __asm _emit 0xeb \
    __asm _emit 0x00

#define Touch_Register(Register) _asm xor Register, Register

typedef DWORD   HEVENT;

#define VMM_GET_DDB_NAMED 0

#pragma warning (disable:4209)  // turn off redefine warning (with basedef.h)

typedef ULONG HTIMEOUT;     // timeout handle
typedef ULONG CMS;      // count of milliseconds

#pragma warning (default:4209)  // turn on redefine warning (with basedef.h)

typedef DWORD   VMM_SEMAPHORE;

#ifndef WANTVXDWRAPS

WORD VXDINLINE
Get_VMM_Version()
{
    WORD w;
    VMMCall(Get_VMM_Version);
    _asm mov [w], ax
    return(w);
}

PVOID VXDINLINE
_HeapAllocate(ULONG Bytes, ULONG Flags)
{
    PVOID p;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Bytes]
    VMMCall(_HeapAllocate)
    _asm add esp, 8
    _asm mov [p], eax
    return(p);
}

ULONG VXDINLINE
_HeapFree(PVOID Address, ULONG Flags)
{
    ULONG ul;
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    _asm push [Flags]
    _asm push [Address]
    VMMCall(_HeapFree)
    _asm add esp, 8
    _asm mov [ul], eax
    return(ul);
}

HEVENT VXDINLINE
Call_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Call_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

HEVENT VXDINLINE
Schedule_Global_Event(void (__cdecl *pfnEvent)(), ULONG ulRefData)
{
    HEVENT hevent;
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnEvent]
    VMMCall(Schedule_Global_Event)
    _asm mov [hevent], esi
    return(hevent);
}

void VXDINLINE
Cancel_Global_Event( HEVENT hevent )
{
    _asm mov esi, hevent
    VMMCall( Cancel_Global_Event );
}

HVM VXDINLINE
Get_Sys_VM_Handle(VOID)
{
    HVM hvm;
    Touch_Register(ebx)
    VxDCall(Get_Sys_VM_Handle);
    _asm mov [hvm], ebx
    return(hvm);
}

VOID VXDINLINE
Fatal_Error_Handler(PCHAR pszMessage, DWORD dwExitFlag)
{
    _asm mov esi, [pszMessage]
    _asm mov eax, [dwExitFlag]
    VMMCall(Fatal_Error_Handler);
}

VMM_SEMAPHORE VXDINLINE
Create_Semaphore(LONG lTokenCount)
{
    VMM_SEMAPHORE vmm_semaphore;
    _asm mov ecx, [lTokenCount]
    VMMCall(Create_Semaphore)
    _asm cmc
    _asm sbb ecx, ecx
    _asm and eax, ecx
    _asm mov [vmm_semaphore], eax
    return(vmm_semaphore);
}

void VXDINLINE
Destroy_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Destroy_Semaphore)
}

void VXDINLINE
Signal_Semaphore(VMM_SEMAPHORE vsSemaphore)
{
    _asm mov eax, [vsSemaphore]
    VMMCall(Signal_Semaphore)
}

void VXDINLINE
Wait_Semaphore(VMM_SEMAPHORE vsSemaphore, DWORD dwFlags)
{
    _asm mov eax, [vsSemaphore]
    _asm mov ecx, [dwFlags]
    VMMCall(Wait_Semaphore)
}

HVM VXDINLINE
Get_Execution_Focus(void)
{
    HVM hvm;
    Touch_Register(ebx)
    VMMCall(Get_Execution_Focus)
    _asm mov [hvm], ebx
    return(hvm);
}

void VXDINLINE
Begin_Critical_Section(ULONG Flags)
{
    _asm mov ecx, [Flags]
    VMMCall(Begin_Critical_Section)
}

void VXDINLINE
End_Critical_Section(void)
{
    VMMCall(End_Critical_Section)
}

void VXDINLINE
Fatal_Memory_Handler(void)
{
    VMMCall(Fatal_Memory_Error);
}

void VXDINLINE
Begin_Nest_Exec(void)
{
    VMMCall(Begin_Nest_Exec)
}

void VXDINLINE
End_Nest_Exec(void)
{
    VMMCall(End_Nest_Exec)
}

void VXDINLINE
Resume_Exec(void)
{
    VMMCall(Resume_Exec)
}

HTIMEOUT VXDINLINE
Set_VM_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_VM_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

HTIMEOUT VXDINLINE
Set_Global_Time_Out(void (__cdecl *pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Global_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

void VXDINLINE
Cancel_Time_Out(HTIMEOUT htimeout)
{
    _asm mov esi, htimeout
    VMMCall(Cancel_Time_Out)
}


void VXDINLINE
Update_System_Clock(ULONG msElapsed)
{
    __asm mov ecx,[msElapsed]
    VMMCall(Update_System_Clock)
}

void VXDINLINE
Enable_Touch_1st_Meg(void)
{
    VMMCall(Enable_Touch_1st_Meg)
}

void VXDINLINE
Disable_Touch_1st_Meg(void)
{
    VMMCall(Disable_Touch_1st_Meg)
}

void VXDINLINE
Out_Debug_String(char *psz)
{
    __asm pushad
    __asm mov esi, [psz]
    VMMCall(Out_Debug_String)
    __asm popad
}

void VXDINLINE
Queue_Debug_String(char *psz, ULONG ulEAX, ULONG ulEBX)
{
    _asm push esi
    _asm push [ulEAX]
    _asm push [ulEBX]
    _asm mov esi, [psz]
    VMMCall(Queue_Debug_String)
    _asm pop esi
}

#ifdef WIN40SERVICES

HTIMEOUT VXDINLINE
Set_Async_Time_Out(void (*pfnTimeout)(), CMS cms, ULONG ulRefData)
{
    HTIMEOUT htimeout;
    _asm mov eax, [cms]
    _asm mov edx, [ulRefData]
    _asm mov esi, [pfnTimeout]
    VMMCall(Set_Async_Time_Out)
    _asm mov [htimeout], esi
    return(htimeout);
}

VXDINLINE struct VxD_Desc_Block *
VMM_Get_DDB(WORD DeviceID, PCHAR Name)
{
    struct VxD_Desc_Block *p;
    _asm movzx eax, [DeviceID]
    _asm mov edi, [Name]
    VMMCall(Get_DDB);
    _asm mov [p], ecx
    return(p);
}

DWORD VXDINLINE
VMM_Directed_Sys_Control(struct VxD_Desc_Block *DDB, DWORD SysControl, DWORD rEBX, DWORD rEDX, DWORD rESI, DWORD rEDI)
{
    DWORD dw;
    _asm mov eax, [SysControl]
    _asm mov ebx, [rEBX]
    _asm mov ecx, [DDB]
    _asm mov edx, [rEDX]
    _asm mov esi, [rESI]
    _asm mov edi, [rEDI]
    VMMCall(Directed_Sys_Control);
    _asm mov [dw], eax
    return(dw);
}

void VXDINLINE
_Trace_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Trace_Out_Service)
}

void VXDINLINE
_Debug_Out_Service(char *psz)
{
    __asm push psz
    VMMCall(_Debug_Out_Service)
}

void VXDINLINE
_Debug_Flags_Service(ULONG flags)
{
    __asm push flags
    VMMCall(_Debug_Flags_Service)
}

void VXDINLINE _cdecl
_Debug_Printf_Service(char *pszfmt, ...)
{
    __asm lea  eax,(pszfmt + 4)
    __asm push eax
    __asm push pszfmt
    VMMCall(_Debug_Printf_Service)
    __asm add esp, 2*4
}

#endif // WIN40SERVICES

#endif // WANTVXDWRAPS

#endif // Not_VxD

#endif // not WINNT

/*XLATON*/

#endif /* _VMM_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\inc\recguids.h ===
/*
 * recguids.h - OLE reconciliation interface GUID definitions.
 */


/* GUIDs
 ********/

DEFINE_GUID(IID_IReconcileInitiator, 0x99180161L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IReconcilableObject, 0x99180162L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_INotifyReplica,      0x99180163L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
DEFINE_GUID(IID_IBriefcaseInitiator, 0x99180164L, 0xDA16, 0x101A, 0x93, 0x5C, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\inc\reconcil.h ===
/*
 * reconcil.h - OLE reconciliation interface definitions.
 */


#ifndef __RECONCIL_H__
#define __RECONCIL_H__


/* Headers
 **********/

#include <recguids.h>


#ifdef __cplusplus
extern "C" {                        /* Assume C declarations for C++. */
#endif   /* __cplusplus */


/* Constants
 ************/

/* for use in IStorage::SetStateBits() */

#define STATEBITS_FLAT                 (0x0001)

/* reconciliation SCODEs */

#define REC_S_IDIDTHEUPDATES           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1000)
#define REC_S_NOTCOMPLETE              MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1001)
#define REC_S_NOTCOMPLETEBUTPROPAGATE  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x1002)

#define REC_E_ABORTED                  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1000)
#define REC_E_NOCALLBACK               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1001)
#define REC_E_NORESIDUES               MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1002)
#define REC_E_TOODIFFERENT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1003)
#define REC_E_INEEDTODOTHEUPDATES      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x1004)


/* Interfaces
 *************/

#undef  INTERFACE
#define INTERFACE INotifyReplica

DECLARE_INTERFACE_(INotifyReplica, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* INotifyReplica methods */

   STDMETHOD(YouAreAReplica)(THIS_
                             ULONG ulcOtherReplicas,
                             IMoniker **rgpmkOtherReplicas) PURE;
};

#undef  INTERFACE
#define INTERFACE IReconcileInitiator

DECLARE_INTERFACE_(IReconcileInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcileInitiator methods */

   STDMETHOD(SetAbortCallback)(THIS_
                               IUnknown *punkForAbort) PURE;

   STDMETHOD(SetProgressFeedback)(THIS_
                                  ULONG ulProgress,
                                  ULONG ulProgressMax) PURE;
};

/* IReconcilableObject::Reconcile() flags */

typedef enum _reconcilef
{
   /* interaction with the user is allowed */

   RECONCILEF_MAYBOTHERUSER         = 0x0001,

   /*
    * hwndProgressFeedback may be used to provide reconciliation progress
    * feedback to the user.
    */

   RECONCILEF_FEEDBACKWINDOWVALID   = 0x0002,

   /* residue support not required */

   RECONCILEF_NORESIDUESOK          = 0x0004,

   /* caller not interested in callee's residues */

   RECONCILEF_OMITSELFRESIDUE       = 0x0008,

   /*
    * Reconcile() call resuming after a previous Reconcile() call returned
    * REC_E_NOTCOMPLETE
    */

   RECONCILEF_RESUMERECONCILIATION  = 0x0010,

   /* Object may perform all updates. */

   RECONCILEF_YOUMAYDOTHEUPDATES    = 0x0020,

   /* Only this object has been changed. */

   RECONCILEF_ONLYYOUWERECHANGED    = 0x0040,

   /* flag combinations */

   ALL_RECONCILE_FLAGS              = (RECONCILEF_MAYBOTHERUSER |
                                       RECONCILEF_FEEDBACKWINDOWVALID |
                                       RECONCILEF_NORESIDUESOK |
                                       RECONCILEF_OMITSELFRESIDUE |
                                       RECONCILEF_RESUMERECONCILIATION |
                                       RECONCILEF_YOUMAYDOTHEUPDATES |
                                       RECONCILEF_ONLYYOUWERECHANGED)
}
RECONCILEF;

#undef  INTERFACE
#define INTERFACE IReconcilableObject

DECLARE_INTERFACE_(IReconcilableObject, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IReconcilableObject methods */

   STDMETHOD(Reconcile)(THIS_
                        IReconcileInitiator *pInitiator,
                        DWORD dwFlags,
                        HWND hwndOwner,
                        HWND hwndProgressFeedback,
                        ULONG ulcInput,
                        IMoniker **rgpmkOtherInput,
                        PLONG plOutIndex,
                        IStorage *pstgNewResidues,
                        PVOID pvReserved) PURE;

   STDMETHOD(GetProgressFeedbackMaxEstimate)(THIS_
                                             PULONG pulProgressMax) PURE;
};

#undef  INTERFACE
#define INTERFACE IBriefcaseInitiator

DECLARE_INTERFACE_(IBriefcaseInitiator, IUnknown)
{
   /* IUnknown methods */

   STDMETHOD(QueryInterface)(THIS_
                             REFIID riid,
                             PVOID *ppvObject) PURE;

   STDMETHOD_(ULONG, AddRef)(THIS) PURE;

   STDMETHOD_(ULONG, Release)(THIS) PURE;

   /* IBriefcaseInitiator methods */

   STDMETHOD(IsMonikerInBriefcase)(THIS_
                                   IMoniker *pmk) PURE;
};


#ifdef __cplusplus
}                                   /* End of extern "C" {. */
#endif   /* __cplusplus */


#endif   /* ! __RECONCIL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\wutilsp.h ===
#define MAX_PRN_PAGES 10

//
// This data structure is privately shared with 
// prtprop.c in SHELLDLL
// prt16.c in LIBRARY
//
typedef struct // apg
{
    DWORD cpages;
    HPROPSHEETPAGE ahpage[MAX_PRN_PAGES];
} PAGEARRAY, FAR * LPPAGEARRAY;

// thunk from shell232.dll -> shell.dll
VOID WINAPI CallAddPropSheetPages16(LPFNADDPROPSHEETPAGES lpfn16, LPVOID hdrop, LPPAGEARRAY papg);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\vmmreg.h ===
/*****************************************************************************
 *
 *   (C) Copyright MICROSOFT Corp., 1993
 *
 *   Title:	VMMREG.H - Include file for VMM/Loader Registry Services
 *
 *   Version:	1.00
 *
 *   Date:	03-June-1993
 *
 *   Author:	Nagara
 *
 *-----------------------------------------------------------------------------
 *
 *   Change log:
 *
 ******************************************************************************
 */

#ifndef	_VMMREG_H
#define _VMMREG_H

typedef DWORD	VMMHKEY;
typedef	VMMHKEY	*PVMMHKEY;
typedef DWORD	VMMREGRET;			// return type for the REG Functions

#define	MAX_VMM_REG_KEY_LEN	256	// includes the \0 terminator

#ifndef REG_SZ		// define only if not there already

#define REG_SZ		0x0001
#define REG_BINARY	0x0003

#endif

#ifndef HKEY_LOCAL_MACHINE	// define only if not there already

#define HKEY_CLASSES_ROOT		0x80000000
#define HKEY_CURRENT_USER		0x80000001
#define HKEY_LOCAL_MACHINE		0x80000002
#define HKEY_USERS			0x80000003
#define HKEY_PERFORMANCE_DATA		0x80000004
#define HKEY_CURRENT_CONFIG		0x80000005
#define HKEY_DYN_DATA			0x80000006

#endif


// ERROR CODES returned by Registry
// NOTE THAT THESE ARE ALSO DEFINED IN WINERROR.H 
// and so VMMREG.H should be included after WINERROR.H

#ifndef ERROR_FILE_NOT_FOUND
#define ERROR_FILE_NOT_FOUND             2L
#endif

#ifndef ERROR_BADDB
#define ERROR_BADDB                      1009L
#endif

#ifndef ERROR_MORE_DATA
#define ERROR_MORE_DATA                  234L    
#endif

#ifndef ERROR_BADKEY
#define ERROR_BADKEY			 1010L
#endif

#ifndef ERROR_CANTOPEN
#define ERROR_CANTOPEN                   1011L
#endif

#ifndef ERROR_CANTREAD
#define ERROR_CANTREAD                   1012L
#define ERROR_CANTWRITE                  1013L
#endif

#ifndef ERROR_REGISTRY_CORRUPT
#define ERROR_REGISTRY_CORRUPT           1015L
#define ERROR_REGISTRY_IO_FAILED         1016L
#endif

#ifndef ERROR_KEY_DELETED
#define ERROR_KEY_DELETED                1018L
#endif

#ifndef ERROR_OUTOFMEMORY
#define ERROR_OUTOFMEMORY		   14L
#endif

#ifndef ERROR_INVALID_PARAMETER
#define ERROR_INVALID_PARAMETER		   87L
#endif

#ifndef ERROR_LOCK_FAILED
#define ERROR_LOCK_FAILED                167L
#endif

#ifndef ERROR_NO_MORE_ITEMS
#define ERROR_NO_MORE_ITEMS		  259L
#endif	


#ifndef  ERROR_SUCCESS           
#define ERROR_SUCCESS           0L
#endif

// END ERROR CODES

/*XLATOFF*/
#ifndef Not_VxD

/*NOINC*/
#ifndef _PROVIDER_STRUCTS_DEFINED
#define _PROVIDER_STRUCTS_DEFINED

#define PROVIDER_KEEPS_VALUE_LENGTH	0x1
struct val_context {
    int valuelen;		// the total length of this value
    PVOID value_context;	// provider's context
    PVOID val_buff_ptr;	// where in the ouput buffer the value is.
};

typedef struct val_context *PVALCONTEXT;

typedef struct pvalue {		      // Provider supplied value/context.
    PCHAR pv_valuename;          // The value name pointer
    DWORD pv_valuelen;
    PVOID pv_value_context;
    DWORD pv_type;
}PVALUE;

typedef struct pvalue *PPVALUE;

typedef VMMREGRET (_cdecl *PQUERYHANDLER)(PVOID, PVALCONTEXT, DWORD, PVOID, DWORD *, DWORD);

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    // capability flags (none defined yet).
    PVOID pi_key_context;
}PROVIDER;

typedef PROVIDER *PPROVIDER;

struct value_ent {
    PCHAR ve_valuename;
    DWORD ve_valuelen;
    DWORD ve_valueptr;
    DWORD ve_type;
};

typedef struct value_ent VALENT;
typedef VALENT *PVALENT;

#endif // not(_PROVIDER_STRUCTS_DEFINED)
/*INC*/

#ifndef WIN31COMPAT

#pragma warning (disable:4035)		// turn off no return code warning

#ifndef	WANTVXDWRAPS



VMMREGRET VXDINLINE
VMM_RegOpenKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegOpenKey);
    _asm add  esp, 3*4
}

VMMREGRET VXDINLINE
VMM_RegCloseKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCloseKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegCreateKey(VMMHKEY hkey, PCHAR lpszSubKey, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateKey);
    _asm add  esp, 3*4
}


VMMREGRET VXDINLINE
VMM_RegCreateDynKey(PCHAR lpszSubKey, PVOID KC, PVOID pi, PVOID vl, DWORD num_vals, PVMMHKEY phkResult)
{
    _asm push phkResult
    _asm push num_vals
    _asm push vl
    _asm push pi
    _asm push KC
    _asm push lpszSubKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegCreateDynKey);
    _asm add  esp, 6*4
}
VMMREGRET VXDINLINE
VMM_RegQMulti (VMMHKEY hKey,PCHAR lpszSubKey, PVOID val_list,DWORD num_vals, PCHAR lpValueBuf, DWORD *ldwTotsize)
{
    _asm push ldwTotsize
    _asm push lpValueBuf
    _asm push num_vals
    _asm push val_list
    _asm push lpszSubKey
    _asm push hKey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQMulti);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegDeleteKey(VMMHKEY hkey, PCHAR lpszSubKey)
{
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteKey);
    _asm add  esp, 2*4
}

VMMREGRET VXDINLINE
VMM_RegEnumKey(VMMHKEY hkey, DWORD iSubKey, PCHAR lpszName, DWORD cchName)
{
    _asm push cchName
    _asm push lpszName
    _asm push iSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumKey);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValue(VMMHKEY hkey, PCHAR lpszSubKey, PCHAR lpszValue, PDWORD lpcbValue)
{
    _asm push lpcbValue
    _asm push lpszValue
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValue);
    _asm add  esp, 4*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValue(VMMHKEY hkey, PCHAR lpszSubKey, DWORD fdwType, PCHAR lpszData, DWORD cbData)
{
    _asm push cbData
    _asm push lpszData
    _asm push fdwType
    _asm push lpszSubKey
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValue);
    _asm add  esp, 5*4 
}

VMMREGRET VXDINLINE
VMM_RegDeleteValue(VMMHKEY hkey, PCHAR lpszValue)
{
    _asm push lpszValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegDeleteValue);
    _asm add  esp, 2*4 
}

VMMREGRET VXDINLINE
VMM_RegEnumValue(VMMHKEY hkey, DWORD iValue, PCHAR lpszValue, PDWORD lpcbValue, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpcbValue
    _asm push lpszValue
    _asm push iValue
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegEnumValue);
    _asm add  esp, 8*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryValueEx(VMMHKEY hkey, PCHAR lpszValueName, PDWORD lpdwReserved, PDWORD lpdwType, PBYTE lpbData, PDWORD lpcbData)
{
    _asm push lpcbData
    _asm push lpbData
    _asm push lpdwType
    _asm push lpdwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryValueEx);
    _asm add  esp, 6*4 
}

VMMREGRET VXDINLINE
VMM_RegSetValueEx(VMMHKEY hkey, PCHAR lpszValueName, DWORD dwReserved, DWORD fdwType, PBYTE lpbData, DWORD cbData)
{
    _asm push cbData
    _asm push lpbData
    _asm push fdwType
    _asm push dwReserved
    _asm push lpszValueName
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegSetValueEx);
    _asm add  esp, 6*4
}

VMMREGRET VXDINLINE
VMM_RegFlushKey(VMMHKEY hkey)
{
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegFlushKey);
    _asm add  esp, 1*4 
}

VMMREGRET VXDINLINE
VMM_RegQueryInfoKey(VMMHKEY hkey, PCHAR lpszClass, PDWORD lpcchClass,PDWORD lpdwReserved, PDWORD lpcSubKeys, PDWORD lpcchMaxSubKey, PDWORD lpcchMaxClass, 
PDWORD lpcValues, PDWORD lpcchMaxValueName, PDWORD lpcbMaxValueData,PDWORD lpcbSecurityDesc, PDWORD lpftLastWriteTime)
{
    _asm push lpftLastWriteTime
    _asm push lpcbSecurityDesc
    _asm push lpcbMaxValueData
    _asm push lpcchMaxValueName
    _asm push lpcValues
    _asm push lpcchMaxClass
    _asm push lpcchMaxSubKey
    _asm push lpcSubKeys
    _asm push lpdwReserved
    _asm push lpcchClass
    _asm push lpszClass
    _asm push hkey
    Touch_Register(eax)
    Touch_Register(ecx)
    Touch_Register(edx)
    VMMCall(_RegQueryInfoKey);
    _asm add  esp, 12*4 
}

#endif	// WANTVXDWRAPS

#pragma warning (default:4035)		// turn on no return code warning

#endif // WIN31COMPAT

#endif // Not_VxD

/*XLATON*/

/* ASM
;**************************************************************
; Macros for Realmode loader registry Services
;
;**************************************************************
LDR_RegOpenKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegOpenKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegCloseKey	Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegCloseKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
LDR_RegCreateKey	Macro	hKey,OffSubKey,SegSubKey,OffphKey,SegphKey
	push	SegphKey
	push	OffphKey		; lphKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegCreateKey
	call	dword ptr [_ServiceEntry]
	add	sp,3*4		; for 3 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteKey	Macro	hKey,OffSubKey,SegSubKey
	push	SegSubKey
	push	OffSubKey		; lpszSubKey
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteKey
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumKey	Macro	hKey,iSubKey,OffszName,SegszName,BufLen
	push	dword ptr BufLen
	push	SegszName
	push	OffszName
	push	dword ptr iSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegEnumKey
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValue	Macro	hKey,OffSubKey,SegSubKey,OffValue,SegValue,OffcbValue,SegcbValue
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValue
	call	dword ptr [_ServiceEntry]
	add	sp,4*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValue	Macro	hKey,OffSubKey,SegSubKey,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	SegSubKey
	push	OffSubKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValue
	call	dword ptr [_ServiceEntry]
	add	sp,5*4		; for 4 parameters on stack
ENDM
;**************************************************************
LDR_RegDeleteValue	Macro	hKey,OffValue,SegValue
	push	SegValue
	push	OffValue		; lpszValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegDeleteValue
	call	dword ptr [_ServiceEntry]
	add	sp,2*4		; for 2 parameters on stack
ENDM
;**************************************************************
LDR_RegEnumValue	Macro hKey,iValue,OffValue,SegValue,OffcbValue,SegcbValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegcbValue
	push	OffcbValue
	push	SegValue
	push	OffValue
	push	dword ptr iValue
	push	dword ptr hKey		; hKey
	mov	ax,LDRSRV_RegEnumValue
	call	dword ptr [_ServiceEntry]
	add	sp,8*4		; for 8 parameters on stack
ENDM
;**************************************************************
LDR_RegQueryValueEx	Macro	hKey,OffValue,SegValue,RegReserved,OffdwType,SegdwType,OffData,SegData,OffcbData,SegcbData
	push	SegcbData
	push	OffcbData
	push	SegData
	push	OffData
	push	SegdwType
	push	OffdwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegQueryValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegSetValueEx	Macro	hKey,OffValue,SegValue,RegReserved,dwType,OffData,SegData,cbData
	push	dword ptr cbData
	push	SegData
	push	OffData
	push	dword ptr dwType
	push	dword ptr RegReserved
	push	SegValue
	push	OffValue
	push	dword ptr hKey
	mov	ax,LDRSRV_RegSetValueEx
	call	dword ptr [_ServiceEntry]
	add	sp,6*4		; for 6 parameters on stack
ENDM
;**************************************************************
LDR_RegFlushKey		Macro	hKey
	push	dword ptr hKey
	mov	ax,LDRSRV_RegFlushKey
	call	dword ptr [_ServiceEntry]
	add	sp,1*4		; for 1 parameter on stack
ENDM
;**************************************************************
*/
#endif		/* _VMMREG_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\wshioctl.h ===
/*****************************************************************************
 *
 *  (C) Copyright MICROSOFT Corp., 1994, 1995
 *
 *  Title:      WSHOICTL.H - IOCTL interface for Wshell
 *
 *  Version:    4.00
 *
 *  Date:       30-Nov-1988
 *
 *  Author:     RAL
 *
 *----------------------------------------------------------------------------
 *
 *  Change log:
 *
 *     DATE     REV                 DESCRIPTION
 *  ----------- --- ----------------------------------------------------------
 *  01-Aug-1994 RAL Original
 *  05-Apr-1995 [stevecat] NT and Unicode port
 *
 *****************************************************************************/

#ifndef _WSHIOCTL_H
#define _WSHIOCTL_H


#define SHELLFILENAME TEXT("\\\\.\\SHELL")

//
// Flags for _SHELL_SuggestSingleMSDOSMode
//
// SSAMFLAG_KILLVM
//        A fatal application error has occurred.  Display a warning box
//        unconditionally.  Regardless of the answer, terminate the VM.
//        If this bit is set, the call does not return.
//
//  SSAMFLAG_TIMER
//        Not used.  Sorry.
//
//  SSAM_REQREALMODE
//        App requires *real* mode, not V86 mode, not EMM stuff, not
//        QEMM.  Just pure unadulterated real mode.  Also known as
//        SSAM_COMANCHE, because Comanche does an "lgdt" to enter
//        protected mode without checking if it is safe to do so.
//        This flag is inspected by AppWiz to decide how to set up
//        the config.sys and autoexec.bat.
//
//  SSAM_KILLUNLESSTOLD
//        Suggest Single MS-DOS mode (unless suppressed via PIF), and
//        if the answer is "Okay", then kill the VM.  If the user
//        says, "Keep running", then let it stay.
//
//  SSAM_FROMREGLIST
//        This app was run from a command prompt, triggered by registry
//        settings.  Just re-execute it in its own VM so that APPS.INF
//        settings will take effect.
//
//  SSAM_FAILEDAPI
//        This app just made an API call that was unsuccessful or
//        unsupported.  If the app terminates within 0.1 second,
//        then suggest single-app mode.  If the app continues
//        execution, then don't suggest.
//

#define SSAMFLAG_KILLVM         0x0000001
#define SSAMFLAG_TIMER          0x0000002
#define SSAMFLAG_REQREALMODE    0x0000004
#define SSAMFLAG_KILLUNLESSTOLD 0x0000008
#define SSAMFLAG_FROMREGLIST    0x0000010
#define SSAMFLAG_FAILEDAPI      0x0000020

//
//  IOCTL codes
//
#define WSHIOCTL_GETVERSION       0
#define WSHIOCTL_BLUESCREEN       1
#define WSHIOCTL_GET1APPINFO      2
#define WSHIOCTL_SIGNALSEM        3
#define WSHIOCTL_MAX              4        /* Remember, _MAX = _LIMIT + 1 */

//
//  Result codes
//
#define SSR_CONTINUE       0
#define SSR_CLOSEVM        1
#define SSR_KILLAPP        2

//
//  Sizes for strings
//
#define MAXVMTITLESIZE      32
#define MAXVMPROGSIZE       64
#define MAXVMCMDSIZE        64
#define MAXVMDIRSIZE        64
#define MAXPIFPATHSIZE      260

typedef struct _SINGLEAPPSTRUC {    /* shex */

        DWORD        SSA_dwFlags;
        DWORD        SSA_VMHandle;
        DWORD        SSA_ResultPtr;
        DWORD        SSA_Semaphore;
        TCHAR        SSA_PIFPath[MAXPIFPATHSIZE];
        TCHAR        SSA_VMTitle[MAXVMTITLESIZE];
        TCHAR        SSA_ProgName[MAXVMPROGSIZE];
        TCHAR        SSA_CommandLine[MAXVMCMDSIZE];
        TCHAR        SSA_CurDir[MAXVMCMDSIZE];

} SINGLEAPPSTRUC;

//
// Structures for WSHIOCTL_BLUESCREEN.
//
// lpvInBuffer must point to a BLUESCREENINFO structure.
// lpvOutBuffer must point to a DWORD which receives the message box result.
// The message box result is an IDXX value, as defined in windows.h.
//

/* H2INCSWITCHES -t */
typedef struct _BLUESCREENINFO {    /* bsi */

    TCHAR *pszText;         /* Message text (OEM character set) */
    TCHAR *pszTitle;        /* Message title (OEM character set) */
                            /* NULL means "Windows" */
    DWORD  flStyle;         /* Message box flags (see windows.h) */
                            /* Add'l flags defined in ddk\inc\shell.h */

} BLUESCREENINFO;
/* H2INCSWITCHES -t- */



#endif // _WSHIOCTL_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\brfhndlr\rover\filesync\syncui\inc\winuserp.h ===
/*++ BUILD Version: 0003    // Increment this if a change has global effects

Copyright (c) 1985-95, Microsoft Corporation

Module Name:

    winuserp.h

Abstract:

    Private
    Procedure declarations, constant definitions and macros for the User
    component.

--*/
#ifndef _WINUSERP_
#define _WINUSERP_

#ifdef __cplusplus
extern "C" {
#endif /* __cplusplus */
#ifdef STRICT
#else /* !STRICT */
#endif /* !STRICT */
#define RT_MENUEX       MAKEINTRESOURCE(13)     // RT_MENU subtype
#define RT_NAMETABLE    MAKEINTRESOURCE(15)     // removed in 3.1
#define RT_DIALOGEX     MAKEINTRESOURCE(18)     // RT_DIALOG subtype
#define RT_LAST         MAKEINTRESOURCE(22)
#define RT_AFXFIRST     MAKEINTRESOURCE(0xF0)   // reserved: AFX
#define RT_AFXLAST      MAKEINTRESOURCE(0xFF)   // reserved: AFX
#define SB_MAX              3
#define SB_CMD_MAX          8
#define VK_NONE           0x00
#define VK_KANA           0x15
#define VK_HANGEUL        0x15
#define VK_JUNJA          0x17
#define VK_HANJA          0x19
#define VK_KANJI          0x19
/* #define VK_COPY        0x2C not used by keyboards. */
#define WH_CHOOKS          (WH_MAXHOOK - WH_MINHOOK + 1)
#define MSGF_CBTHOSEBAGSUSEDTHIS  7
#define HSHELL_SYSMENU              9
#define HSHELL_HIGHBIT            0x8000
#define HSHELL_FLASH              (HSHELL_REDRAW|HSHELL_HIGHBIT)
#define HSHELL_RUDEAPPACTIVATED (HSHELL_WINDOWACTIVATED|HSHELL_HIGHBIT)
// This needs to be internal until the shell catches up
typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;
#define KLF_SETFORPROCESS   0x00000100
#define KLF_RESET           0x40000000
#define KLF_INITTIME        0x80000000

WINUSERAPI
HKL
WINAPI
LoadKeyboardLayoutEx(
    HKL hkl,
    LPCWSTR pwszKLID,
    UINT Flags);


/*
 *    Private API, originally for Cairo Shell, which calls FHungApp
 *    based on the hwnd supplied.  Used for fake system menus on the
 *    shell tray.
 */

BOOL IsHungAppWindow(HWND hwnd);

BOOL WowWaitForMsgAndEvent(HANDLE hevent);
WINUSERAPI VOID WINAPI RegisterSystemThread(DWORD flags, DWORD reserved);
#define RST_DONTATTACHQUEUE       0x00000001
#define RST_DONTJOURNALATTACH     0x00000002
#define RST_ALWAYSFOREGROUNDABLE  0x00000004
#define RST_FAULTTHREAD           0x00000008
#define GWL_WOWWORDS        (-1)
#define GWL_WOWDWORD1       (-30)
#define GWL_WOWDWORD2       (-31)
#define GWL_WOWDWORD3       (-32)
#define GCL_WOWWORDS        (-27)
#define GCL_WOWDWORD1       (-28)
#define GCL_WOWDWORD2       (-29)
#define WM_SIZEWAIT                     0x0004
#define WM_SETVISIBLE                   0x0009
#define WM_SYSTEMERROR                  0x0017
/*
 * This is used by DefWindowProc() and DefDlgProc(), it's the 16-bit version
 * of the WM_CTLCOLORBTN, WM_CTLCOLORDLG, ... messages.
 */
#define WM_CTLCOLOR                     0x0019
#define WM_LOGOFF                       0x0025
#define WM_ALTTABACTIVE                 0x0029
#define WM_FILESYSCHANGE                0x0034

#define WM_SHELLNOTIFY                  0x0034
#define SHELLNOTIFY_DISKFULL            0x0001
#define SHELLNOTIFY_OLELOADED           0x0002
#define SHELLNOTIFY_OLEUNLOADED         0x0003
#define SHELLNOTIFY_WALLPAPERCHANGED    0x0004

#define WM_ISACTIVEICON                 0x0035
#define WM_QUERYPARKICON                0x0036
#define WM_WINHELP                      0x0038
#define WM_FULLSCREEN                   0x003A
#define WM_CLIENTSHUTDOWN               0x003B
#define WM_DDEMLEVENT                   0x003C
#define MM_CALCSCROLL                   0x003F
#define WM_TESTING                      0x0040
#define WM_OTHERWINDOWCREATED           0x0042
#define WM_OTHERWINDOWDESTROYED         0x0043
#define WM_COPYGLOBALDATA               0x0049
#define WM_LOGONNOTIFY                  0x004C
#define WM_KEYF1                        0x004D
#define WM_ACCESS_WINDOW                0x004F
#define WM_FINALDESTROY                 0x0070  /* really destroy (window not locked) */
#define WM_MEASUREITEM_CLIENTDATA       0x0071  /* WM_MEASUREITEM bug clientdata thunked already */
#define WM_SYNCPAINT                    0x0088
#define WM_SYNCTASK                     0x0089
#define WM_KLUDGEMINRECT                0x008B
#define WM_CONVERTREQUESTEX             0x0108
#define WM_YOMICHAR                     0x0108
#define WM_CONVERTREQUEST               0x010A
#define WM_CONVERTRESULT                0x010B
#define WM_INTERIM                      0x010C
#define WM_SYSTIMER                     0x0118
#define WM_LBTRACKPOINT                 0x0131
#define MN_FIRST                        0x01E0
#define MN_SETHMENU                     (MN_FIRST + 0)
#define MN_GETHMENU                     (MN_FIRST + 1)
#define MN_SIZEWINDOW                   (MN_FIRST + 2)
#define MN_OPENHIERARCHY                (MN_FIRST + 3)
#define MN_CLOSEHIERARCHY               (MN_FIRST + 4)
#define MN_SELECTITEM                   (MN_FIRST + 5)
#define MN_CANCELMENUS                  (MN_FIRST + 6)
#define MN_SELECTFIRSTVALIDITEM         (MN_FIRST + 7)
#define MN_GETPPOPUPMENU                (MN_FIRST + 10)
#define MN_FINDMENUWINDOWFROMPOINT      (MN_FIRST + 11)
#define MN_SHOWPOPUPWINDOW              (MN_FIRST + 12)
#define MN_BUTTONDOWN                   (MN_FIRST + 13)
#define MN_MOUSEMOVE                    (MN_FIRST + 14)
#define MN_BUTTONUP                     (MN_FIRST + 15)
#define MN_SETTIMERTOOPENHIERARCHY      (MN_FIRST + 16)
#define MN_DBLCLK                       (MN_FIRST + 17)
#define WM_IME_SYSTEM                   0x0287
#define WM_DROPOBJECT                   0x022A
#define WM_QUERYDROPOBJECT              0x022B
#define WM_BEGINDRAG                    0x022C
#define WM_DRAGLOOP                     0x022D
#define WM_DRAGSELECT                   0x022E
#define WM_DRAGMOVE                     0x022F
#define WM_KANJIFIRST                   0x0280
#define WM_KANJILAST                    0x029F
#define WM_TRACKMOUSEEVENT_FIRST        0x02A0
#define WM_TRACKMOUSEEVENT_LAST         0x02AF
#define WM_PALETTEGONNACHANGE           0x0310
#define WM_CHANGEPALETTE                0x0311
#define WM_SYSMENU                      0x0313
#define WM_HOOKMSG                      0x0314
#define WM_EXITPROCESS                  0x0315
#define WM_WAKETHREAD                   0x0316
#define WM_NOTIFYWOW                    0x0340
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F
#define WM_INTERNAL_DDE_FIRST           0x03E0
#define WM_INTERNAL_DDE_LAST            0x03EF
#define WM_COALESCE_FIRST               0x0390
#define WM_COALESCE_LAST                0x039F
#define WM_MM_RESERVED_FIRST            0x03A0
#define WM_MM_RESERVED_LAST             0x03DF
#define WM_CBT_RESERVED_FIRST           0x03F0
#define WM_CBT_RESERVED_LAST            0x03FF
/* wParam for WM_NOTIFYWOW message  */
#define WMNW_UPDATEFINDREPLACE  0
#define WMSZ_KEYSIZE        0
#define WMSZ_MOVE           9
#define WMSZ_KEYMOVE        10
#define WMSZ_SIZEFIRST      WMSZ_LEFT
#define SMTO_BROADCAST      0x0004
#define SMTO_NOTIMEOUTIFNOTHUNG 0x0008
#define ICON_RECREATE       2
#define WVR_MINVALID        WVR_ALIGNTOP
#define WVR_MAXVALID        WVR_VALIDRECTS
#define TME_VALID (TME_HOVER | TME_LEAVE | TME_QUERY | TME_CANCEL)
#define WS_VALID            (WS_OVERLAPPED     | \
                             WS_POPUP          | \
                             WS_CHILD          | \
                             WS_MINIMIZE       | \
                             WS_VISIBLE        | \
                             WS_DISABLED       | \
                             WS_CLIPSIBLINGS   | \
                             WS_CLIPCHILDREN   | \
                             WS_MAXIMIZE       | \
                             WS_CAPTION        | \
                             WS_BORDER         | \
                             WS_DLGFRAME       | \
                             WS_VSCROLL        | \
                             WS_HSCROLL        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_GROUP          | \
                             WS_TABSTOP        | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)
#define WS_EX_DRAGOBJECT        0x00000002L
#define WS_EX_ANSICREATOR       0x80000000L
#define WS_EX_ALLEXSTYLES    (WS_EX_TRANSPARENT | WS_EX_DLGMODALFRAME | WS_EX_DRAGOBJECT | WS_EX_NOPARENTNOTIFY | WS_EX_TOPMOST | WS_EX_ACCEPTFILES)

#define WS_EX_VALID          (WS_EX_DLGMODALFRAME  | \
                              WS_EX_DRAGOBJECT     | \
                              WS_EX_NOPARENTNOTIFY | \
                              WS_EX_TOPMOST        | \
                              WS_EX_ACCEPTFILES    | \
                              WS_EX_TRANSPARENT    | \
                              WS_EX_ALLEXSTYLES)

#define WS_EX_VALID40        (WS_EX_VALID          | \
                              WS_EX_MDICHILD       | \
                              WS_EX_WINDOWEDGE     | \
                              WS_EX_CLIENTEDGE     | \
                              WS_EX_CONTEXTHELP    | \
                              WS_EX_TOOLWINDOW     | \
                              WS_EX_RIGHT          | \
                              WS_EX_LEFT           | \
                              WS_EX_RTLREADING     | \
                              WS_EX_LEFTSCROLLBAR  | \
                              WS_EX_CONTROLPARENT  | \
                              WS_EX_STATICEDGE     | \
                              WS_EX_APPWINDOW)
#define CS_OEMCHARS         0x0010  /* reserved (see user\server\usersrv.h) */
#define CS_LVB              0x0400
#define CS_SYSTEM           0x8000
#define CS_VALID            (CS_VREDRAW           | \
                             CS_HREDRAW           | \
                             CS_KEYCVTWINDOW      | \
                             CS_DBLCLKS           | \
                             0x0010               | \
                             CS_OWNDC             | \
                             CS_CLASSDC           | \
                             CS_PARENTDC          | \
                             CS_NOKEYCVT          | \
                             CS_NOCLOSE           | \
                             CS_SAVEBITS          | \
                             CS_BYTEALIGNCLIENT   | \
                             CS_BYTEALIGNWINDOW   | \
                             CS_GLOBALCLASS)
#define CS_VALID31            0x0800ffef
#define CS_VALID40            0x0801feeb
#define BDR_VALID       0x000F
#define BF_VALID       (BF_MIDDLE |  \
                        BF_SOFT   |  \
                        BF_ADJUST |  \
                        BF_FLAT   |  \
                        BF_MONO   |  \
                        BF_LEFT   |  \
                        BF_TOP    |  \
                        BF_RIGHT  |  \
                        BF_BOTTOM |  \
                        BF_DIAGONAL)
#define DFC_CACHE               0xFFFF
#define DFCS_INMENU             0x0040
#define DFCS_INSMALL            0x0080
#define DFCS_SCROLLMIN          0x0000
#define DFCS_SCROLLVERT         0x0000
#define DFCS_SCROLLMAX          0x0001
#define DFCS_SCROLLHORZ         0x0002
#define DFCS_SCROLLLINE         0x0004

#define DFCS_CACHEICON          0x0000
#define DFCS_CACHEBUTTONS       0x0001

#define DC_NOVISIBLE        0x0800
#define DC_BUTTONS          0x1000
#define DC_NOSENDMSG        0x2000
#define DC_CENTER           0x4000
#define DC_FRAME            0x8000
#define DC_CAPTION          (DC_ICON | DC_TEXT | DC_BUTTONS)
#define DC_NC               (DC_CAPTION | DC_FRAME)
WINUSERAPI BOOL    WINAPI DrawCaptionTempA(HWND, HDC, LPRECT, HFONT, HICON, LPSTR, UINT);
WINUSERAPI BOOL    WINAPI DrawCaptionTempW(HWND, HDC, LPRECT, HFONT, HICON, LPWSTR, UINT);
#ifdef UNICODE
#define DrawCaptionTemp  DrawCaptionTempW
#else
#define DrawCaptionTemp  DrawCaptionTempA
#endif // !UNICODE
#define PAS_IN          0x0001
#define PAS_OUT         0x0002
#define PAS_LEFT        0x0004
#define PAS_RIGHT       0x0008
#define PAS_UP          0x0010
#define PAS_DOWN        0x0020
#define PAS_HORZ        (PAS_LEFT | PAS_RIGHT)
#define PAS_VERT        (PAS_UP | PAS_DOWN)
#define CF_FIRST            0
#define WPF_VALID              (WPF_SETMINPOSITION     | \
                                WPF_RESTORETOMAXIMIZED)
/*
 * MEASUREITEMSTRUCT_EX for ownerdraw
 * used when server initiates a WM_MEASUREITEM and adds the additional info
 * of whether the itemData needs to be thunked when the message is sent to
 * the client (see also WM_MEASUREITEM_CLIENTDATA
 */
typedef struct tagMEASUREITEMSTRUCT_EX {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    DWORD      itemData;
    BOOL       bThunkClientData;
} MEASUREITEMSTRUCT_EX, NEAR *PMEASUREITEMSTRUCT_EX, FAR *LPMEASUREITEMSTRUCT_EX;
#define PM_VALID           (PM_NOREMOVE | \
                            PM_REMOVE   | \
                            PM_NOYIELD)
#define MOD_VALID           (MOD_ALT|MOD_CONTROL|MOD_SHIFT|MOD_WIN)
#define EWX_REALLYLOGOFF ENDSESSION_LOGOFF
#define EWX_SYSTEM_CALLER           0x0100
#define EWX_WINLOGON_CALLER         0x0200
#define EWX_WINLOGON_OLD_SYSTEM     0x0400
#define EWX_WINLOGON_OLD_SHUTDOWN   0x0800
#define EWX_WINLOGON_OLD_REBOOT     0x1000
#define EWX_WINLOGON_API_SHUTDOWN   0x2000
#define EWX_WINLOGON_OLD_POWEROFF   0x4000
#define EWX_NOTIFY                  0x8000
#define BSM_COMPONENTS          0x0000000F
#define BSM_VALID               0x0000001F
#define BSF_SYSTEMSHUTDOWN      0x40000000
#define BSF_MSGSRV32OK          0x80000000
#define BSF_VALID               0x0000007F
    /* UINT cbSize; */
#define SWP_STATECHANGE     0x8000  /* force size, move messages */
#define SWP_NOCLIENTSIZE    0x0800  /* Client didn't resize */
#define SWP_NOCLIENTMOVE    0x1000  /* Client didn't move   */

#define SWP_DEFERDRAWING    0x2000

#define SWP_CHANGEMASK      (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_FRAMECHANGED | SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_NOCHANGE        (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE)

#define SWP_VALID1          (SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOREDRAW | SWP_NOACTIVATE | SWP_FRAMECHANGED)
#define SWP_VALID2          (SWP_SHOWWINDOW | SWP_HIDEWINDOW | SWP_NOCOPYBITS | SWP_NOOWNERZORDER | SWP_NOCLIENTSIZE | SWP_NOCLIENTMOVE | SWP_NOSENDCHANGING | SWP_ASYNCWINDOWPOS | SWP_DEFERDRAWING)
#define SWP_VALID           (SWP_VALID1 | SWP_VALID2)
#undef SWP_VALID
#define SWP_VALID           (SWP_DEFERERASE      | \
                             SWP_ASYNCWINDOWPOS  | \
                             SWP_NOCOPYBITS      | \
                             SWP_NOOWNERZORDER   | \
                             SWP_NOSENDCHANGING  | \
                             SWP_NOSIZE          | \
                             SWP_NOMOVE          | \
                             SWP_NOZORDER        | \
                             SWP_NOREDRAW        | \
                             SWP_NOACTIVATE      | \
                             SWP_FRAMECHANGED    | \
                             SWP_SHOWWINDOW      | \
                             SWP_HIDEWINDOW)
#define HWND_GROUPTOTOP HWND_TOPMOST
/*
 * WARNING:
 * The following structures must NOT be DWORD padded because they are
 * followed by strings, etc that do not have to be DWORD aligned.
 */
#include <pshpack2.h>

/*
 * Chicago dialog template
 */
typedef struct {
    WORD wDlgVer;
    WORD wSignature;
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    WORD cDlgItems;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE2;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2A;
typedef DLGTEMPLATE2 *LPDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGTEMPLATE2W LPDLGTEMPLATE2;
#else
typedef LPDLGTEMPLATE2A LPDLGTEMPLATE2;
#endif // UNICODE
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2A;
typedef CONST DLGTEMPLATE2 *LPCDLGTEMPLATE2W;
#ifdef UNICODE
typedef LPCDLGTEMPLATE2W LPCDLGTEMPLATE2;
#else
typedef LPCDLGTEMPLATE2A LPCDLGTEMPLATE2;
#endif // UNICODE
/*
 * Dialog item template for NT 1.0a/Chicago (dit2)
 */
typedef struct {
    DWORD dwHelpID;
    DWORD dwExStyle;
    DWORD style;
    short x;
    short y;
    short cx;
    short cy;
    DWORD dwID;
} DLGITEMTEMPLATE2;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *PDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef PDLGITEMTEMPLATE2W PDLGITEMTEMPLATE2;
#else
typedef PDLGITEMTEMPLATE2A PDLGITEMTEMPLATE2;
#endif // UNICODE
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2A;
typedef DLGITEMTEMPLATE2 *LPDLGITEMTEMPLATE2W;
#ifdef UNICODE
typedef LPDLGITEMTEMPLATE2W LPDLGITEMTEMPLATE2;
#else
typedef LPDLGITEMTEMPLATE2A LPDLGITEMTEMPLATE2;
#endif // UNICODE

#include <poppack.h> /* Resume normal packing */
#define MWMO_VALID        0x0003
#define QS_SMSREPLY         0x0200
#define QS_SYSEXPUNGE       0x0400
#define QS_THREADATTACHED   0x0800
#define QS_EXCLUSIVE        0x1000      // wait for these events only!!
#define QS_EVENT            0x2000      // signifies event message
#define QS_TRANSFER         0x4000      // Input was transfered from another thread
#define QS_VALID           (QS_KEY           | \
                            QS_MOUSEMOVE     | \
                            QS_MOUSEBUTTON   | \
                            QS_POSTMESSAGE   | \
                            QS_TIMER         | \
                            QS_PAINT         | \
                            QS_SENDMESSAGE   | \
                            QS_TRANSFER      | \
                            QS_HOTKEY        | \
                            QS_ALLPOSTMESSAGE)

/*
 * QS_EVENT is used to clear the QS_EVENT bit, QS_EVENTSET is used to
 * set the bit.
 *
 * Include QS_SENDMESSAGE because the queue events
 * match what a win3.1 app would see as the QS_SENDMESSAGE bit. Plus 16 bit
 * apps don't even know about QS_EVENT.
 */
#define QS_EVENTSET        (QS_EVENT | QS_SENDMESSAGE)
#define SM_UNUSED_64            64
#define SM_UNUSED_65            65
#define SM_UNUSED_66            66
#define SM_MAX                  75
#define SM_CXWORKAREA           SM_CXSCREEN     // BOGUS TEMPORARY
#define SM_CYWORKAREA           SM_CYSCREEN     // BOGUS TEMPORARY
#define SM_XWORKAREA            SM_CXBORDER     // BOGUS TEMPORARY
#define SM_YWORKAREA            SM_CYBORDER     // BOGUS TEMPORARY
WINUSERAPI int WINAPI DrawMenuBarTemp(HWND, HDC, LPRECT, HMENU, HFONT);
WINUSERAPI BOOL WINAPI SetSystemMenu(HWND, HMENU);
#if(WINVER >= 0x040a)
#define MNS_NOCHECK     0x00000001
#define MNS_VALID       0x00000001
#define MFNOCHECK       0x08

#define SIZEOFMENUITEMINFO95 0x2C

#define MIM_MAXHEIGHT   0x00000001
#define MIM_BACKGROUND  0x00000002
#define MIM_HELPID      0x00000004
#define MIM_MENUDATA    0x00000008
#define MIM_STYLE       0x00000010
#define MIM_MASK        0x0000001F

typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    DWORD   dwMenuData;
}   MENUINFO, FAR *LPMENUINFO;
typedef const MENUINFO FAR *LPCMENUINFO;

WINUSERAPI
BOOL
WINAPI
GetMenuInfo(
             HMENU,
             LPMENUINFO);

WINUSERAPI
BOOL
WINAPI
SetMenuInfo(
             HMENU,
             LPCMENUINFO);
#endif /* WINVER >= 0x040a */
#if(WINVER >= 0x040a)
#define MIIM_STRING      0x00000040
#define MIIM_BITMAP      0x00000080
#define MIIM_FTYPE       0x00000100
#define MIIM_MASK        0x000001FF
#define HBM_BITMAPCALLBACK  (HBITMAP)(-1)
#endif /* WINVER >= 0x040a */
#define TPM_SYSMENU         0x0200L
#if(WINVER >= 0x040a)
#define TPM_RECURSE         0X0001L
#endif /* WINVER >= 0x040a */
#if(WINVER >= 0x040a)

#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RECURSE      | \
                        TPM_RETURNCMD)
#else /* (WINVER == 0x040a) */
#define TPM_VALID      (TPM_LEFTBUTTON   | \
                        TPM_RIGHTBUTTON  | \
                        TPM_LEFTALIGN    | \
                        TPM_CENTERALIGN  | \
                        TPM_RIGHTALIGN   | \
                        TPM_TOPALIGN     | \
                        TPM_VCENTERALIGN | \
                        TPM_BOTTOMALIGN  | \
                        TPM_HORIZONTAL   | \
                        TPM_VERTICAL     | \
                        TPM_NONOTIFY     | \
                        TPM_RETURNCMD)

#endif /* (WINVER == 0x040a) */
typedef struct _dropfilestruct {
   DWORD pFiles;                       // offset of file list
   POINT pt;                           // drop point
   BOOL fNC;                           // is it on NonClient area
   BOOL fWide;                         // WIDE character switch
} DROPFILESTRUCT, FAR * LPDROPFILESTRUCT;
#define DT_VALID            0x0007ffff  /* union of all others */
#undef DT_VALID
#define DT_VALID           (DT_CENTER          | \
                            DT_RIGHT           | \
                            DT_VCENTER         | \
                            DT_BOTTOM          | \
                            DT_WORDBREAK       | \
                            DT_SINGLELINE      | \
                            DT_EXPANDTABS      | \
                            DT_TABSTOP         | \
                            DT_NOCLIP          | \
                            DT_EXTERNALLEADING | \
                            DT_CALCRECT        | \
                            DT_NOPREFIX        | \
                            DT_INTERNAL        | \
                            DT_EDITCONTROL     | \
                            DT_PATH_ELLIPSIS   | \
                            DT_END_ELLIPSIS    | \
                            DT_MODIFYSTRING    | \
                            DT_RTLREADING      | \
                            DT_WORD_ELLIPSIS)
#define DST_TEXTMAX     0x0002
#define DST_GLYPH       0x0005
#define DST_TYPEMASK    0x0007
#define DST_GRAYSTRING  0x0008
#define DSS_DEFAULT     0x0040
WINUSERAPI VOID WINAPI SwitchToThisWindow(HWND hwnd, BOOL fUnknown);
#define DCX_USESTYLE         0x00010000L

#define DCX_INVALID          0x00000800L
#define DCX_INUSE            0x00001000L
#define DCX_SAVEDRGNINVALID  0x00002000L

#define DCX_NEEDFONT         0x00020000L
#define DCX_NODELETERGN      0x00040000L
#define DCX_NOCLIPCHILDREN   0x00080000L

#define DCX_NORECOMPUTE      0x00100000L

#define DCX_CREATEDC         0x00800000L

#define DCX_OWNDC            0x00008000L

#define DCX_DESTROYTHIS      0x00400000L

#define DCX_PWNDORGINVISIBLE    0x10000000L
#define DCX_DONTRIPONDESTROY    0x80000000L

#define DCX_MATCHMASK       (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_NORESETATTRS     | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_CREATEDC)

#define DCX_VALID           (DCX_WINDOW           | \
                             DCX_CACHE            | \
                             DCX_NORESETATTRS     | \
                             DCX_CLIPCHILDREN     | \
                             DCX_CLIPSIBLINGS     | \
                             DCX_PARENTCLIP       | \
                             DCX_EXCLUDERGN       | \
                             DCX_INTERSECTRGN     | \
                             DCX_EXCLUDEUPDATE    | \
                             DCX_INTERSECTUPDATE  | \
                             DCX_LOCKWINDOWUPDATE | \
                             DCX_INVALID          | \
                             DCX_INUSE            | \
                             DCX_SAVEDRGNINVALID  | \
                             DCX_OWNDC            | \
                             DCX_USESTYLE         | \
                             DCX_NEEDFONT         | \
                             DCX_NODELETERGN      | \
                             DCX_NOCLIPCHILDREN   | \
                             DCX_NORECOMPUTE      | \
                             DCX_VALIDATE         | \
                             DCX_DESTROYTHIS      | \
                             DCX_CREATEDC)
#define RDW_REDRAWWINDOW        0x1000  /* Called from RedrawWindow()*/
#define RDW_SUBTRACTSELF        0x2000  /* Subtract self from hrgn   */

#define RDW_COPYRGN             0x4000  /* Copy the passed-in region */
#define RDW_IGNOREUPDATEDIRTY   0x8000  /* Ignore WFUPDATEDIRTY      */
#define RDW_VALIDMASK          (RDW_INVALIDATE      | \
                                RDW_INTERNALPAINT   | \
                                RDW_ERASE           | \
                                RDW_VALIDATE        | \
                                RDW_NOINTERNALPAINT | \
                                RDW_NOERASE         | \
                                RDW_NOCHILDREN      | \
                                RDW_ALLCHILDREN     | \
                                RDW_UPDATENOW       | \
                                RDW_ERASENOW        | \
                                RDW_FRAME           | \
                                RDW_NOFRAME)
#define SW_SCROLLWINDOW     0x8000  /* Called from ScrollWindow() */
#define SW_VALIDFLAGS      (SW_SCROLLWINDOW     | \
                            SW_SCROLLCHILDREN   | \
                            SW_INVALIDATE       | \
                            SW_ERASE)
#define ESB_MAX             0x0003
#define SB_DISABLE_MASK     ESB_DISABLE_BOTH

/*
 * Help Engine stuff
 *
 * Note: for Chicago this is in winhelp.h and called WINHLP
 */
typedef struct {
    WORD cbData;              /* Size of data                     */
    WORD usCommand;           /* Command to execute               */
    DWORD ulTopic;            /* Topic/context number (if needed) */
    DWORD ulReserved;         /* Reserved (internal use)          */
    WORD offszHelpFile;       /* Offset to help file in block     */
    WORD offabData;           /* Offset to other data in block    */
} HLP, *LPHLP;

#define MBEX_VALIDL                 0xf3f7
#define MBEX_VALIDH                 1
#define MB_VALID                   (MB_OK                   | \
                                    MB_OKCANCEL             | \
                                    MB_ABORTRETRYIGNORE     | \
                                    MB_YESNOCANCEL          | \
                                    MB_YESNO                | \
                                    MB_RETRYCANCEL          | \
                                    MB_ICONHAND             | \
                                    MB_ICONQUESTION         | \
                                    MB_ICONEXCLAMATION      | \
                                    MB_ICONASTERISK         | \
                                    MB_DEFBUTTON1           | \
                                    MB_DEFBUTTON2           | \
                                    MB_DEFBUTTON3           | \
                                    MB_DEFBUTTON4           | \
                                    MB_APPLMODAL            | \
                                    MB_SYSTEMMODAL          | \
                                    MB_TASKMODAL            | \
                                    MB_HELP                 | \
                                    MB_TOPMOST              | \
                                    MB_RIGHT                | \
                                    MB_RTLREADING           | \
                                    MB_NOFOCUS              | \
                                    MB_SETFOREGROUND        | \
                                    MB_DEFAULT_DESKTOP_ONLY | \
                                    MB_SERVICE_NOTIFICATION | \
                                    MB_TYPEMASK             | \
                                    MB_USERICON             | \
                                    MB_ICONMASK             | \
                                    MB_DEFMASK              | \
                                    MB_MODEMASK             | \
                                    MB_MISCMASK)
#define CWP_VALID           (CWP_SKIPINVISIBLE | CWP_SKIPDISABLED | CWP_SKIPTRANSPARENT)
#define COLOR_ENDCOLORS         COLOR_INFOBK
#define COLOR_MAX               (COLOR_ENDCOLORS+1)
WINUSERAPI HANDLE WINAPI SetSysColorsTemp(COLORREF FAR *, HBRUSH FAR *, UINT wCnt);

WINUSERAPI
BOOL
WINAPI
SetDeskWallpaper(
    LPCSTR lpString);

WINUSERAPI HWND WINAPI CreateDialogIndirectParamAorW(
    HANDLE hmod,
    LPCDLGTEMPLATE lpDlgTemplate,
    HWND hwndOwner,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam,
    UINT fAnsi);

WINUSERAPI int WINAPI DialogBoxIndirectParamAorW(
    HINSTANCE hmod,
    LPCDLGTEMPLATEW lpDlgTemplate,
    HWND hwndOwner,
    DLGPROC lpDialogFunc,
    LPARAM dwInitParam,
    UINT fAnsiFlags);

WINUSERAPI void LoadLocalFonts(void);

WINUSERAPI UINT UserRealizePalette(HDC hdc);

WINUSERAPI HWND    WINAPI  GetShellWindow(void);
WINUSERAPI BOOL    WINAPI  SetShellWindow(HWND);
WINUSERAPI BOOL    WINAPI  SetShellWindowEx(HWND, HWND);
WINUSERAPI HWND    WINAPI  GetProgmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetProgmanWindow(HWND);
WINUSERAPI HWND    WINAPI  GetTaskmanWindow(void);
WINUSERAPI BOOL    WINAPI  SetTaskmanWindow(HWND);
WINUSERAPI BOOL    WINAPI  RegisterShellHookWindow(HWND);
WINUSERAPI BOOL    WINAPI  DeregisterShellHookWindow(HWND);

WINUSERAPI HWND WINAPI GetNextQueueWindow (HWND hWnd, INT nCmd);
#define MF_CHANGE_VALID   (MF_INSERT          | \
                           MF_CHANGE          | \
                           MF_APPEND          | \
                           MF_DELETE          | \
                           MF_REMOVE          | \
                           MF_BYCOMMAND       | \
                           MF_BYPOSITION      | \
                           MF_SEPARATOR       | \
                           MF_ENABLED         | \
                           MF_GRAYED          | \
                           MF_DISABLED        | \
                           MF_UNCHECKED       | \
                           MF_CHECKED         | \
                           MF_USECHECKBITMAPS | \
                           MF_STRING          | \
                           MF_BITMAP          | \
                           MF_OWNERDRAW       | \
                           MF_POPUP           | \
                           MF_MENUBARBREAK    | \
                           MF_MENUBREAK       | \
                           MF_UNHILITE        | \
                           MF_HILITE          | \
                           MF_SYSMENU)

#define MF_VALID          (MF_CHANGE_VALID    | \
                           MF_HELP            | \
                           MF_MOUSESELECT)

#define MFT_MASK            0x00034B64L
#define MFS_MASK            0x0000108BL
#define MFR_POPUP           0x01
#define MFR_END             0x80
#define MFT_OLDAPI_MASK     0x00004B64L
#define MFS_OLDAPI_MASK     0x0000008BL
#define MFT_NONSTRING       0x00000904L
#define MFT_BREAK           0x00000060L
typedef struct {        // version 1
    DWORD dwHelpID;
    DWORD fType;
    DWORD fState;
    DWORD menuId;
    WORD  wResInfo;
    WCHAR mtString[1];
} MENUITEMTEMPLATE2, *PMENUITEMTEMPLATE2;
#define IDC_NWPEN           MAKEINTRESOURCE(32531)
#define IDC_HUNG            MAKEINTRESOURCE(32632)
WINUSERAPI UINT PrivateExtractIconExA(
    LPCSTR szFileName,
    int      nIconIndex,
    HICON   *phiconLarge,
    HICON   *phiconSmall,
    UINT     nIcons);
WINUSERAPI UINT PrivateExtractIconExW(
    LPCWSTR szFileName,
    int      nIconIndex,
    HICON   *phiconLarge,
    HICON   *phiconSmall,
    UINT     nIcons);
#ifdef UNICODE
#define PrivateExtractIconEx  PrivateExtractIconExW
#else
#define PrivateExtractIconEx  PrivateExtractIconExA
#endif // !UNICODE


WINUSERAPI UINT PrivateExtractIconsA(
    LPCSTR szFileName,
    int      nIconIndex,
    int      cxIcon,
    int      cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT     nIcons,
    UINT     flags);
WINUSERAPI UINT PrivateExtractIconsW(
    LPCWSTR szFileName,
    int      nIconIndex,
    int      cxIcon,
    int      cyIcon,
    HICON   *phicon,
    UINT    *piconid,
    UINT     nIcons,
    UINT     flags);
#ifdef UNICODE
#define PrivateExtractIcons  PrivateExtractIconsW
#else
#define PrivateExtractIcons  PrivateExtractIconsA
#endif // !UNICODE
#define LR_GLOBAL           0x0100
#define LR_ENVSUBST         0x0200
#define LR_ACONFRAME        0x0400
#define LR_CREATEREALDIB    0x0800
#define LR_VALID            0xF8FF
#define DI_VALID       (DI_MASK | DI_IMAGE | DI_COMPAT | DI_DEFAULTSIZE)
#define OBM_STARTUP         32733
#define OBM_TRUETYPE        32732
#define OBM_HELP            32731
#define OBM_HELPD           32730
#define OCR_NWPEN           32631
#define OCR_HELP            32651
/*
 * Default Cursor IDs to get original image from User
 */
#define OCR_FIRST_DEFAULT           100
#define OCR_ARROW_DEFAULT           100
#define OCR_IBEAM_DEFAULT           101
#define OCR_WAIT_DEFAULT            102
#define OCR_CROSS_DEFAULT           103
#define OCR_UPARROW_DEFAULT         104
#define OCR_SIZENWSE_DEFAULT        105
#define OCR_SIZENESW_DEFAULT        106
#define OCR_SIZEWE_DEFAULT          107
#define OCR_SIZENS_DEFAULT          108
#define OCR_SIZEALL_DEFAULT         109
#define OCR_NO_DEFAULT              110
#define OCR_APPSTARTING_DEFAULT     111
#define OCR_HELP_DEFAULT            112
#define OCR_NWPEN_DEFAULT           113
#define OCR_ICON_DEFAULT            114
#define COCR_CONFIGURABLE           (OCR_ICON_DEFAULT - OCR_FIRST_DEFAULT + 1)
/* Default IDs for original User images */
#define OIC_FIRST_DEFAULT           100
#define OIC_APPLICATION_DEFAULT     100
#define OIC_HAND_DEFAULT            101
#define OIC_WARNING_DEFAULT         101
#define OIC_QUESTION_DEFAULT        102
#define OIC_EXCLAMATION_DEFAULT     103
#define OIC_ERROR_DEFAULT           103
#define OIC_ASTERISK_DEFAULT        104
#define OIC_INFORMATION_DEFAULT     104
#define OIC_WINLOGO_DEFAULT         105
#define COIC_CONFIGURABLE           (OIC_WINLOGO_DEFAULT - OIC_FIRST_DEFAULT + 1)
#ifdef RC_INVOKED
#else
#endif /* RC_INVOKED */
#define IDUSERICON      10
#define ES_FMTMASK          0x0003L
#define ES_COMBOBOX         0x0200L
#define EM_SETFONT              0x00C3 /* no longer suported */
#define EM_SETWORDBREAK         0x00CA /* no longer suported */
#define EM_MSGMAX               0x00D8
#define BS_PUSHBOX          0x0000000AL
#define BS_TYPEMASK         0x0000000FL
#define BS_IMAGEMASK        0x000000C0L
#define BS_HORZMASK         0x00000300L
#define BS_VERTMASK         0x00000C00L
#define BS_ALIGNMASK        0x00000F00L
#define SS_EDITCONTROL      0x00002000L
#define DDL_NOFILES         0x1000
#define DDL_VALID          (DDL_READWRITE  | \
                            DDL_READONLY   | \
                            DDL_HIDDEN     | \
                            DDL_SYSTEM     | \
                            DDL_DIRECTORY  | \
                            DDL_ARCHIVE    | \
                            DDL_POSTMSGS   | \
                            DDL_DRIVES     | \
                            DDL_EXCLUSIVE)
/*
 * Valid dialog style bits for Chicago compatibility.
 */
//#define DS_VALID_FLAGS (DS_ABSALIGN|DS_SYSMODAL|DS_LOCALEDIT|DS_SETFONT|DS_MODALFRAME|DS_NOIDLEMSG | DS_SETFOREGROUND)
#define DS_VALID_FLAGS   0x1FFF

#define SCDLG_CLIENT            0x0001
#define SCDLG_ANSI              0x0002
#define SCDLG_NOREVALIDATE      0x0004
#define SCDLG_16BIT             0x0008      // Created for a 16 bit thread; common dialogs
#define DS_VALID31          0x01e3L
#define DS_VALID40          0x3FFFL
#define DS_RECURSE      DS_CONTROL  /* BOGUS GOING AWAY */
#define DS_COMMONDIALOG     0x4000L
#define DS_NONBOLD  DS_3DLOOK   /* BOGUS GOING AWAY */
#define LBCB_CARETON            0x01A3
#define LBCB_CARETOFF           0x01A4
#define LB_INSERTSTRINGUPPER    0x01AA
#define LB_INSERTSTRINGLOWER    0x01AB
#define LB_ADDSTRINGUPPER       0x01AC
#define LB_ADDSTRINGLOWER       0x01AD
#define LBCB_STARTTRACK         0x01AE
#define LBCB_ENDTRACK           0x01AF
#define CBEC_SETCOMBOFOCUS          (CB_MSGMAX+1)
#define CBEC_KILLCOMBOFOCUS         (CB_MSGMAX+2)
#define SIF_RETURNOLDPOS    0x1000
#define SIF_NOSCROLL        0x2000
#define SIF_MASK            0x701F
#define HELP_HB_NORMAL    0x0000L
#define HELP_HB_STRING    0x0100L
#define HELP_HB_STRUCT    0x0200L
#define SPI_TIMEOUTS                7
#define SPI_KANJIMENU               8
#define SPI_UNUSED39               39
#define SPI_UNUSED40               40
#define SPI_GETSNAPTODEFBUTTON     95
#define SPI_SETSNAPTODEFBUTTON     96
#define SPI_GETMENUSHOWDELAY      106
#define SPI_SETMENUSHOWDELAY      107
#define SPI_GETUSERPREFERENCE     108
#define SPI_SETUSERPREFERENCE     109
/*
 *  Please consider using a SPI_UP_
 *  (i.e., use SPI_*USERPREFERENCE)
 *  You'll get most SystemParametersInfo
 *   support for free
 */
#define SPI_MAX                   110
/*
 * These are stored in gpviCPUserPreferences
 * Use the SPI_UP(p) macro to access them
 */
#define SPI_UP_ACTIVEWINDOWTRACKING     0
#define SPI_UP_COUNT                    1
#define SPIF_VALID            (SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE)
#define CDS_EXCLUSIVE       0x80000000
#define CDS_VALID           0xF000001F

WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsExA(
    LPCSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEA lpDevMode,
    DWORD dwFlags);
WINUSERAPI
BOOL
WINAPI
EnumDisplaySettingsExW(
    LPCWSTR lpszDeviceName,
    DWORD iModeNum,
    LPDEVMODEW lpDevMode,
    DWORD dwFlags);
#ifdef UNICODE
#define EnumDisplaySettingsEx  EnumDisplaySettingsExW
#else
#define EnumDisplaySettingsEx  EnumDisplaySettingsExA
#endif // !UNICODE

/* Flags for EnumDisplaySettingsEx */
#define EDS_SHOW_DUPLICATES           0x00000001
#define EDS_SHOW_MONITOR_NOT_CAPABLE  0x00000002

void LoadRemoteFonts(void);
#define FKF_VALID           0x0000007F
#define SKF_VALID           0x000001FF
#define MKF_VALID           0x000000FF
#define ATF_VALID           0x00000003
#define SSF_VALID           0x00000007
#define TKF_VALID           0x0000003F
WINUSERAPI VOID WINAPI RegisterNetworkCapabilities(DWORD dwBitsToSet, DWORD dwValues);
#define RNC_NETWORKS              0x00000001
#define RNC_LOGON                 0x00000002

#define LOGON_LOGOFF        0
#define LOGON_INPUT_TIMEOUT 1
#define LOGON_RESTARTSHELL  2
#ifdef CITRIX
#define SESSION_RECONNECTED     3
#define SESSION_DISCONNECTED    4
#define SESSION_LOGOFF          5
#endif
#define LOGON_FLG_MASK      0xF0000000
#define LOGON_FLG_SHIFT     28

#define STARTF_DESKTOPINHERIT   0x40000000
#define STARTF_SCREENSAVER      0x80000000

#define WSS_ERROR       0
#define WSS_BUSY        1
#define WSS_IDLE        2

#define DTF_CENTER    0x00   /* Center the bitmap (default)                  */
#define DTF_TILE      0x01   /* Tile the bitmap                              */
#define DTF_STRETCH   0x02   /* Stretch bitmap to cover screen.              */
#define DTF_NOPALETTE 0x04   /* Realize palette, otherwise match to default. */
#define DTF_RETAIN    0x08   /* Retain bitmap, ignore win.ini changes        */
#define DTF_FIT       0x10   /* Fit the bitmap to the screen (scaled).       */

#ifdef _INC_DDEMLH
BOOL DdeIsDataHandleReadOnly(
    HDDEDATA hData);

int DdeGetDataHandleFormat(
    HDDEDATA hData);

DWORD DdeGetCallbackInstance(VOID);
#endif /* defined _INC_DDEMLH */


WINUSERAPI
HWND
WINAPI
WOWFindWindow(
    LPCSTR lpClassName,
    LPCSTR lpWindowName);

int
InternalDoEndTaskDlg(
    TCHAR* pszTitle);

DWORD
InternalWaitCancel(
    HANDLE handle,
    DWORD dwMilliseconds);

HANDLE
InternalCreateCallbackThread(
    HANDLE hProcess,
    DWORD lpfn,
    DWORD dwData);

WINUSERAPI
UINT
WINAPI
GetInternalWindowPos(
    HWND hWnd,
    LPRECT lpRect,
    LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
SetInternalWindowPos(
    HWND hWnd,
    UINT cmdShow,
    LPRECT lpRect,
    LPPOINT lpPoint);

WINUSERAPI
BOOL
WINAPI
CalcChildScroll(
    HWND hWnd,
    UINT sb);

WINUSERAPI
BOOL
WINAPI
RegisterTasklist(
    HWND hWndTasklist);

WINUSERAPI
BOOL
WINAPI
CascadeChildWindows(
    HWND hWndParent,
    UINT flags);

WINUSERAPI
BOOL
WINAPI
TileChildWindows(
    HWND hWndParent,
    UINT flags);

WINUSERAPI
int
WINAPI
InternalGetWindowText(
    HWND hWnd,
    LPWSTR lpString,
    int nMaxCount);

BOOL
BoostHardError(
    DWORD dwProcessId,
    BOOL fForce);

/*
 * Services support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterServicesProcess(
    DWORD dwProcessId);

/*
 * Logon support routines
 */
WINUSERAPI
BOOL
WINAPI
RegisterLogonProcess(
    DWORD dwProcessId,
    BOOL fSecure);

WINUSERAPI
UINT
WINAPI
LockWindowStation(
    HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
UnlockWindowStation(
    HWINSTA hWindowStation);

WINUSERAPI
BOOL
WINAPI
SetWindowStationUser(
    HWINSTA hWindowStation,
    PLUID pLuidUser,
    PSID pSidUser,
    DWORD cbSidUser);

WINUSERAPI
BOOL
WINAPI
SetDesktopBitmap(
    HDESK hdesk,
    HBITMAP hbmWallpaper,
    DWORD dwStyle);

WINUSERAPI
BOOL
WINAPI
SetLogonNotifyWindow(
    HWINSTA hWindowStation,
    HWND hWndNotify);

WINUSERAPI
UINT
WINAPI
GetIconId(
    HANDLE hRes,
    LPSTR lpszType);

int
CriticalNullCall(
    VOID);

int
NullCall(
    VOID);

VOID
UserNotifyConsoleApplication(
    DWORD dwProcessId);

HBRUSH
GetConsoleWindowBrush(
    PVOID pWnd);

VOID vFontSweep();
VOID vLoadLocalT1Fonts();
VOID vLoadRemoteT1Fonts();


#ifndef NOMSG

#define TM_POSTCHARBREAKS 0x0002

WINUSERAPI
BOOL
WINAPI
TranslateMessageEx(
    CONST MSG *lpMsg,
    UINT flags);

#endif /* !NOMSG */

int
WCSToMBEx(
    WORD wCodePage,
    LPCWSTR pUnicodeString,
    int cbUnicodeChar,
    LPSTR *ppAnsiString,
    int nAnsiChar,
    BOOL bAllocateMem);

int
MBToWCSEx(
    WORD wCodePage,
    LPCSTR pAnsiString,
    int nAnsiChar,
    LPWSTR *ppUnicodeString,
    int cbUnicodeChar,
    BOOL bAllocateMem);

WINUSERAPI
BOOL
WINAPI
EndTask(
    HWND hWnd,
    BOOL fShutDown,
    BOOL fForce);

WINUSERAPI
BOOL
WINAPI
UpdatePerUserSystemParameters(
    BOOL bUserLoggedOn);

typedef VOID  (APIENTRY *PFNW32ET)(VOID);

BOOL
RegisterUserHungAppHandlers(
    PFNW32ET pfnW32EndTask,
    HANDLE   hEventWowExec);

ATOM
RegisterClassWOWA(
    PVOID   lpWndClass,
    LPDWORD pdwWOWstuff);

LONG
GetClassWOWWords(
    HINSTANCE hInstance,
    LPCTSTR pString);

DWORD
CurrentTaskLock(
    DWORD hlck);

typedef struct _DISPLAY_DEVICEA {
    DWORD cb;
    BYTE   DeviceName[32];
    BYTE   DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;
#ifdef UNICODE
typedef DISPLAY_DEVICEW DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEW PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEW LPDISPLAY_DEVICE;
#else
typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#endif // UNICODE

#define DISPLAY_DEVICE_ATTACHED_TO_DESKTOP 0x00000001
#define DISPLAY_DEVICE_MULTI_DRIVER        0x00000002
#define DISPLAY_DEVICE_PRIMARY_DEVICE      0x00000004
#define DISPLAY_DEVICE_MIRRORING_DRIVER    0x00000008


WINUSERAPI
BOOL
WINAPI
EnumDisplayDevicesA(
    PVOID Unused,
    DWORD iDevNum,
    PDISPLAY_DEVICEA lpDisplayDevice);
WINUSERAPI
BOOL
WINAPI
EnumDisplayDevicesW(
    PVOID Unused,
    DWORD iDevNum,
    PDISPLAY_DEVICEW lpDisplayDevice);
#ifdef UNICODE
#define EnumDisplayDevices  EnumDisplayDevicesW
#else
#define EnumDisplayDevices  EnumDisplayDevicesA
#endif // !UNICODE


WINUSERAPI
HDESK
WINAPI
GetInputDesktop(
    VOID);

#define WINDOWED       0
#define FULLSCREEN     1
#define GDIFULLSCREEN  2
#define FULLSCREENMIN  4


#define WCSToMB(pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar,\
bAllocateMem)\
WCSToMBEx(0, pUnicodeString, cbUnicodeChar, ppAnsiString, nAnsiChar, bAllocateMem)

#define MBToWCS(pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar,\
bAllocateMem)\
MBToWCSEx(0, pAnsiString, nAnsiChar, ppUnicodeString, cbUnicodeChar, bAllocateMem)

#define ID(string) (((DWORD)string & 0xffff0000) == 0)

/*
 * For setting RIT timers and such.  GDI uses this for the cursor-restore
 * timer.
 */
#define TMRF_READY      0x0001
#define TMRF_SYSTEM     0x0002
#define TMRF_RIT        0x0004
#define TMRF_INIT       0x0008
#define TMRF_ONESHOT    0x0010
#define TMRF_WAITING    0x0020


/*
 * For GDI SetAbortProc support.
 */

int
CsDrawTextA(
    HDC hDC,
    LPCSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
int
CsDrawTextW(
    HDC hDC,
    LPCWSTR lpString,
    int nCount,
    LPRECT lpRect,
    UINT uFormat);
#ifdef UNICODE
#define CsDrawText  CsDrawTextW
#else
#define CsDrawText  CsDrawTextA
#endif // !UNICODE

LONG
CsTabbedTextOutA(
    HDC hDC,
    int X,
    int Y,
    LPCSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
LONG
CsTabbedTextOutW(
    HDC hDC,
    int X,
    int Y,
    LPCWSTR lpString,
    int nCount,
    int nTabPositions,
    LPINT lpnTabStopPositions,
    int nTabOrigin);
#ifdef UNICODE
#define CsTabbedTextOut  CsTabbedTextOutW
#else
#define CsTabbedTextOut  CsTabbedTextOutA
#endif // !UNICODE

int
CsFrameRect(
    HDC hDC,
    CONST RECT *lprc,
    HBRUSH hbr);

#ifdef UNICODE
#define CsDrawText      CsDrawTextW
#define CsTabbedTextOut CsTabbedTextOutW
#else /* !UNICODE */
#define CsDrawText      CsDrawTextA
#define CsTabbedTextOut CsTabbedTextOutA
#endif /* !UNICODE */

/*
 * Custom Cursor action.
 */
HCURSOR
GetCursorInfo(
    HCURSOR hcur,
    LPWSTR id,
    int iFrame,
    LPDWORD pjifRate,
    LPINT pccur);


/*
 * WOW: replace cursor/icon handle
 */

WINUSERAPI
BOOL
WINAPI
SetCursorContents(HCURSOR hCursor, HCURSOR hCursorNew);


#ifdef WX86

/*
 *  Wx86
 *  export from wx86.dll to convert an x86 hook proc to risc address.
 */
typedef
PVOID
(*PFNWX86HOOKCALLBACK)(
    SHORT HookType,
    PVOID HookProc
    );

#endif







typedef struct _TAG {
    DWORD type;
    DWORD style;
    DWORD len;
} TAG, *PTAG;

#define MAKETAG(a, b, c, d) (DWORD)(a | (b<<8) | ((DWORD)c<<16) | ((DWORD)d<<24))


/* Valid TAG types. */

/* 'ASDF' (CONT) - Advanced Systems Data Format */

#define TAGT_ASDF MAKETAG('A', 'S', 'D', 'F')


/* 'RAD ' (CONT) - ?R Animation ?Definition (an aggregate type) */

#define TAGT_RAD  MAKETAG('R', 'A', 'D', ' ')


/* 'ANIH' (DATA) - ANImation Header */
/* Contains an ANIHEADER structure. */

#define TAGT_ANIH MAKETAG('A', 'N', 'I', 'H')


/*
 * 'RATE' (DATA) - RATE table (array of jiffies)
 * Contains an array of JIFs.  Each JIF specifies how long the corresponding
 * animation frame is to be displayed before advancing to the next frame.
 * If the AF_SEQUENCE flag is set then the count of JIFs == anih.cSteps,
 * otherwise the count == anih.cFrames.
 */
#define TAGT_RATE MAKETAG('R', 'A', 'T', 'E')

/*
 * 'SEQ ' (DATA) - SEQuence table (array of frame index values)
 * Countains an array of DWORD frame indices.  anih.cSteps specifies how
 * many.
 */
#define TAGT_SEQ  MAKETAG('S', 'E', 'Q', ' ')


/* 'ICON' (DATA) - Windows ICON format image (replaces MPTR) */

#define TAGT_ICON MAKETAG('I', 'C', 'O', 'N')


/* 'TITL' (DATA) - TITLe string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that titles the file. */

#define TAGT_TITL MAKETAG('T', 'I', 'T', 'L')


/* 'AUTH' (DATA) - AUTHor string (can be inside or outside aggregates) */
/* Contains a single ASCIIZ string that indicates the author of the file. */

#define TAGT_AUTH MAKETAG('A', 'U', 'T', 'H')



#define TAGT_AXOR MAKETAG('A', 'X', 'O', 'R')


/* Valid TAG styles. */

/* 'CONT' - CONTainer chunk (contains other DATA and CONT chunks) */

#define TAGS_CONT MAKETAG('C', 'O', 'N', 'T')


/* 'DATA' - DATA chunk */

#define TAGS_DATA MAKETAG('D', 'A', 'T', 'A')

typedef DWORD JIF, *PJIF;

typedef struct _ANIHEADER {     /* anih */
    DWORD cbSizeof;
    DWORD cFrames;
    DWORD cSteps;
    DWORD cx, cy;
    DWORD cBitCount, cPlanes;
    JIF   jifRate;
    DWORD fl;
} ANIHEADER, *PANIHEADER;

/* If the AF_ICON flag is specified the fields cx, cy, cBitCount, and */
/* cPlanes are all unused.  Each frame will be of type ICON and will */
/* contain its own dimensional information. */

#define AF_ICON     0x0001L     /* Windows format icon/cursor animation */
#define AF_SEQUENCE 0x0002L     /* Animation is sequenced */
#ifdef __cplusplus
}
#endif  /* __cplusplus */
#endif  /* !_WINUSERP_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\reg.h ===
#ifndef _REGROUTINES_
#define _REGROUTINES_


#define GUID_SIZE 128
#define MAX_STRING_LENGTH 256


BOOL SetRegKeyValue(
       HKEY hKeyTop,
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValue);

BOOL AddRegNamedValue(
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValueName,
       LPTSTR pszValue);




STDMETHODIMP GetItemIdForHandlerItem(CLSID CLSIDServer,WCHAR *pszItemText,SYNCMGRITEMID *ItemID,BOOL fCreateKey);
STDMETHODIMP SetItemIdForHandlerItem(CLSID CLSIDServer,WCHAR *pszItemText,SYNCMGRITEMID ItemID);



#endif // _REGROUTINES_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\offsync.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//
// Purpose:  Implements the IOfflineSynchronize Interfaces for the OneStop Handler

//#include "priv.h"
#include "SyncHndl.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.


// begin helper apis, move to separate file

#define ALLOC(cb) CoTaskMemAlloc(cb)
#define FREE(cb) CoTaskMemFree(cb)


// create an new offline items list and initialize it to nothing
// and set the refcount to 1.
LPSYNCMGRHANDLERITEMS CreateOfflineHandlerItemsList()
{
LPSYNCMGRHANDLERITEMS lpoffline =
				(LPSYNCMGRHANDLERITEMS) ALLOC(sizeof(SYNCMGRHANDLERITEMS));


	if (lpoffline)
	{
		memset(lpoffline,0,sizeof(SYNCMGRHANDLERITEMS));
		AddRef_OfflineHandlerItemsList(lpoffline);

		// do any specific itemlist initializatoin here.
	}
	

	return lpoffline;
}

DWORD AddRef_OfflineHandlerItemsList(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
	return ++lpOfflineItem->_cRefs;
}

DWORD Release_OfflineHandlerItemsList(LPSYNCMGRHANDLERITEMS lpOfflineItem)
{
DWORD cRefs;
	
	cRefs = --lpOfflineItem->_cRefs;

	if (0 == lpOfflineItem->_cRefs)
	{
		FREE(lpOfflineItem);
	}

	return cRefs;
}


// allocates space for a new offline and adds it to the list,
// if successfull returns pointer to new item so caller can initialize it. 
LPSYNCMGRHANDLERITEM AddOfflineItemToList(LPSYNCMGRHANDLERITEMS pOfflineItemsList,ULONG cbSize)
{
LPSYNCMGRHANDLERITEM pOfflineItem;
    
    // size must be at least size of the base offlinehandler item.
    if (cbSize < sizeof(SYNCMGRHANDLERITEM))
	return NULL;

     pOfflineItem = (LPSYNCMGRHANDLERITEM) ALLOC(cbSize);

	// todo: Add validation.
	if (pOfflineItem)
	{
	    // initialize to zero, and then add it to the list.
	    memset(pOfflineItem,0,cbSize);
	    pOfflineItem->pNextOfflineItem = pOfflineItemsList->pFirstOfflineItem;
	    pOfflineItemsList->pFirstOfflineItem = pOfflineItem;

	    ++pOfflineItemsList->dwNumOfflineItems;
	}


	return pOfflineItem;
}


// end of helper APIS

// Implementation must override this.
STDMETHODIMP COneStopHandler::Initialize(DWORD dwReserved,DWORD dwSyncFlags,
			DWORD cbCookie,BYTE const*lpCookie)
{
	return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{


    return E_NOTIMPL;
}

STDMETHODIMP COneStopHandler::EnumSyncMgrItems(ISyncMgrEnumItems** ppenumOffineItems)
{

	if (m_pOfflineHandlerItems)
	{
		*ppenumOffineItems = new  CEnumOfflineItems(m_pOfflineHandlerItems,0);
	}
	else
	{
		*ppenumOffineItems = NULL;
	}

	return *ppenumOffineItems ? NOERROR: E_OUTOFMEMORY;
}


STDMETHODIMP COneStopHandler::GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv)
{

    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowProperties(HWND hwnd,REFSYNCMGRITEMID dwItemID)
{

	// if support properties should display it as a standard property dialog.

	return E_NOTIMPL;
}



STDMETHODIMP COneStopHandler::SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack)
{
LPSYNCMGRSYNCHRONIZECALLBACK pCallbackCurrent = m_pOfflineSynchronizeCallback;

	m_pOfflineSynchronizeCallback = lpCallBack;

	if (m_pOfflineSynchronizeCallback)
		m_pOfflineSynchronizeCallback->AddRef();

	if (pCallbackCurrent)
		pCallbackCurrent->Release();

	return NOERROR;
}




STDMETHODIMP COneStopHandler::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID* pItemIDs,
						    HWND hwndParent,DWORD dwReserved)
{
	return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::Synchronize(HWND hwndParent)
{
	return E_NOTIMPL;
}

STDMETHODIMP COneStopHandler::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
    return E_NOTIMPL;
}


STDMETHODIMP COneStopHandler::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{

	// Can show any synchronization conflicts. Also gives a chance
	// to display any errors that occured during synchronization

	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\enum.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//
// Purpose:  Implements the IEnumOfflineItems Interfaces for the OneStop Handler

//#include "priv.h"
#include "SyncHndl.h"

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.


CEnumOfflineItems::CEnumOfflineItems(LPSYNCMGRHANDLERITEMS  pOfflineItems,DWORD cOffset)
{
DWORD dwItemIndex;

    ODS("CEnumOfflineItems::CEnumOfflineItems()\r\n");

    m_cRef				= 1;	// give the intial reference
	m_pOfflineItems		= pOfflineItems;
    m_cOffset		    = cOffset;

	AddRef_OfflineHandlerItemsList(m_pOfflineItems); // increment our hold on shared memory.

	// set the current item to point to next record.
	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	dwItemIndex = cOffset;
	
	// this is a bug if this happens so assert in final.
	if (dwItemIndex > m_pOfflineItems->dwNumOfflineItems)
		dwItemIndex = 0;

	while(dwItemIndex--)
	{
		m_pNextItem = m_pNextItem->pNextOfflineItem;
		++m_cOffset;
		if (NULL == m_pNextItem)
			break; // Again, another error.
	}


}

CEnumOfflineItems::~CEnumOfflineItems()
{
	Release_OfflineHandlerItemsList(m_pOfflineItems); // decrement our hold on shared memory.
}

STDMETHODIMP CEnumOfflineItems::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        ODS("CEnumOfflineItems::QueryInterface()==>IID_IUknown\r\n");

    	*ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrEnumItems))
    {
        ODS("CEnumOfflineItems::QueryInterface()==>IID_IEnumOfflineItems\r\n");

        *ppv = (LPSYNCMGRENUMITEMS) this;
    }
    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

    ODS("CEnumOfflineItems::QueryInterface()==>Unknown Interface!\r\n");

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::AddRef()
{
    ODS("CEnumOfflineItems::AddRef()\r\n");

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CEnumOfflineItems::Release()
{
    ODS("CEnumOfflineItems::Release()\r\n");

    if (--m_cRef)
        return m_cRef;

    delete this;

    return 0L;
}

STDMETHODIMP CEnumOfflineItems::Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched)
{
HRESULT hr = NOERROR;
ULONG ulFetchCount = celt;
LPSYNCMGRITEM pOfflineItem;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		ulFetchCount = m_pOfflineItems->dwNumOfflineItems - m_cOffset;
		hr = S_FALSE;
	}

	pOfflineItem = rgelt;

	while (ulFetchCount--)
	{
		*pOfflineItem = m_pNextItem->offlineItem;
		m_pNextItem = m_pNextItem->pNextOfflineItem; // add error checking
		++m_cOffset;
		++pOfflineItem;
	}

	
	return hr;
}

STDMETHODIMP CEnumOfflineItems::Skip(ULONG celt)
{
HRESULT hr;

	if ( (m_cOffset + celt) > m_pOfflineItems->dwNumOfflineItems)
	{
		m_cOffset = m_pOfflineItems->dwNumOfflineItems;
		m_pNextItem = NULL;
		hr = S_FALSE;
	}
	else
	{
		while (celt--)
		{
			++m_cOffset;
			m_pNextItem = m_pNextItem->pNextOfflineItem;

			// add error checking for NULL, etc.
		}

		hr = NOERROR;
	}

	return hr;
}

STDMETHODIMP CEnumOfflineItems::Reset()
{

	m_pNextItem = m_pOfflineItems->pFirstOfflineItem;
	return NOERROR;
}

STDMETHODIMP CEnumOfflineItems::Clone(ISyncMgrEnumItems **ppenum)
{

    *ppenum = new  CEnumOfflineItems(m_pOfflineItems,m_cOffset);

	return *ppenum ? NOERROR : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\base.h ===
// put handler specific declarations that the base class needs here.

#ifndef _BASESTUFF_
#define _BASESTUFF_

// structure for adding any item specific data.
// warning: must contain OFFLINEHANDLERITEM structure first so 
//    can use common enumerator.

typedef struct _HANDLERITEM
{
SYNCMGRHANDLERITEM baseItem;
char szProfileName[MAX_PATH];
LPMDBX	pmdbx; // offlineStore interface.
LPMAPISESSION lpSession; // mapi logon session for this item.
BOOL fItemCompleted;
} HANDLERITEM;

typedef HANDLERITEM *LPHANDLERITEM;

#endif // _BASESTUFF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\synchndl.cpp ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright (C) 1993-1996  Microsoft Corporation.  All Rights Reserved.
//
//  MODULE:   shellext.cpp
//
// Purpose:  Implements the class factory code as well as COneStopHandler::QI,
//           COneStopHandler::AddRef and COneStopHandler::Release code.


#include <objbase.h>
#include "SyncHndl.h"
#include "reg.h"

// vars and functions specific implementations must override.

EXTERN_C const GUID CLSID_OneStopHandler;
extern TCHAR szCLSIDDescription[];
extern COneStopHandler* CreateHandlerObject();
extern void DestroyHandlerObject(COneStopHandler* pOfflineSynchronize);

//
// Global variables
//
UINT      g_cRefThisDll = 0;    // Reference count of this DLL.
HINSTANCE g_hmodThisDll = NULL;	// Handle to this DLL itself.


///////////////////////////////////////////////////////////////////////////// 
// DllRegisterServer - Adds entries to the system registry 
 
STDAPI DllRegisterServer(void) 
{ 
HRESULT  hr = NOERROR;
#ifndef _UNICODE
WCHAR	wszID[GUID_SIZE+1];
#endif // !_UNICODE	 
TCHAR    szID[GUID_SIZE+1];
TCHAR    szCLSID[GUID_SIZE+1];
TCHAR    szModulePath[MAX_PATH];

  // Obtain the path to this module's executable file for later use.
  GetModuleFileName(
    g_hmodThisDll,
    szModulePath,
    sizeof(szModulePath)/sizeof(TCHAR));

  /*-------------------------------------------------------------------------
    Create registry entries for the DllSndBall Component.
  -------------------------------------------------------------------------*/
  // Create some base key strings.
#ifdef _UNICODE
  StringFromGUID2(CLSID_OneStopHandler, szID, GUID_SIZE);
#else
  BOOL fUsedDefaultChar;

  StringFromGUID2(CLSID_OneStopHandler, wszID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
	wszID,-1,szID,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);

#endif // _UNICODE

  lstrcpy(szCLSID, TEXT("CLSID\\"));
  lstrcat(szCLSID, szID);

  // Create entries under CLSID.

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    NULL,
    szCLSIDDescription);

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    TEXT("InProcServer32"),
    szModulePath);

  AddRegNamedValue(
    szCLSID,
    TEXT("InProcServer32"),
    TEXT("ThreadingModel"),
    TEXT("Apartment"));

#define ONESTOPKEY TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\SyncMgr\\Handlers")

  // Register with OneStop
    SetRegKeyValue(HKEY_LOCAL_MACHINE,
    ONESTOPKEY,
    NULL,
    TEXT("OneStop Reg Key") );

    SetRegKeyValue(HKEY_LOCAL_MACHINE,
    ONESTOPKEY,
    szID,
    szCLSIDDescription);

  return hr;
} 


extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ODS("In DLLMain, DLL_PROCESS_ATTACH\r\n");

        // Extension DLL one-time initialization

        g_hmodThisDll = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ODS("In DLLMain, DLL_PROCESS_DETACH\r\n");
    }

    return 1;   // ok
}

//---------------------------------------------------------------------------
// DllCanUnloadNow
//---------------------------------------------------------------------------

STDAPI DllCanUnloadNow(void)
{
    ODS("In DLLCanUnloadNow\r\n");

    return (g_cRefThisDll == 0 ? S_OK : S_FALSE);
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvOut)
{
    ODS("In DllGetClassObject\r\n");

    *ppvOut = NULL;

    if (IsEqualIID(rclsid, CLSID_OneStopHandler))
    {
        CClassFactory *pcf = new CClassFactory;

        return pcf->QueryInterface(riid, ppvOut);
    }

    return CLASS_E_CLASSNOTAVAILABLE;
}

CClassFactory::CClassFactory()
{
    ODS("CClassFactory::CClassFactory()\r\n");

    m_cRef = 0L;

    g_cRefThisDll++;	
}
																
CClassFactory::~CClassFactory()				
{
    g_cRefThisDll--;
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,
                                                   LPVOID FAR *ppv)
{
    ODS("CClassFactory::QueryInterface()\r\n");

    *ppv = NULL;

    // Any interface on this object is the object pointer

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (LPCLASSFACTORY)this;

        AddRef();

        return NOERROR;
    }

    return E_NOINTERFACE;
}	

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (--m_cRef)
        return m_cRef;

    delete this;

    return 0L;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
                                                      REFIID riid,
                                                      LPVOID *ppvObj)
{
HRESULT hr = NOERROR;

    *ppvObj = NULL;

      ODS("CClassFactory::CreateInstance()\r\n");

    // Shell extensions typically don't support aggregation (inheritance)

    if (pUnkOuter)
    	return CLASS_E_NOAGGREGATION;

    // Create the main shell extension object.  The shell will then call
    // QueryInterface with IID_IShellExtInit--this is how shell extensions are
    // initialized.

    LPSYNCMGRSYNCHRONIZE pOneStopHandler = CreateHandlerObject();  //Create the COneStopHandler object

    if (NULL == pOneStopHandler)
    	return E_OUTOFMEMORY;

    hr =  pOneStopHandler->QueryInterface(riid, ppvObj);
    pOneStopHandler->Release(); // remove our reference.

    return hr;

}


STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    return NOERROR;
}

// *********************** COneStopHandler *************************
COneStopHandler::COneStopHandler()
{
    ODS("COneStopHandler::COneStopHandler()\r\n");

    m_cRef = 1;
    m_pOfflineHandlerItems = NULL;
    m_pOfflineSynchronizeCallback = NULL;

    g_cRefThisDll++;
}

COneStopHandler::~COneStopHandler()
{

	// TODO: ADD ASSERTS THAT MEMBERS HAVE BEEN RELEASED.
    g_cRefThisDll--;
}

STDMETHODIMP COneStopHandler::QueryInterface(REFIID riid, LPVOID FAR *ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        ODS("COneStopHandler::QueryInterface()==>IID_IUknown\r\n");

    	*ppv = (LPUNKNOWN)this;
    }
    else if (IsEqualIID(riid, IID_ISyncMgrSynchronize))
    {
        ODS("COneStopHandler::QueryInterface()==>IID_IOfflineSynchronize\r\n");

        *ppv = (LPSYNCMGRSYNCHRONIZE)this;
    }
    if (*ppv)
    {
        AddRef();

        return NOERROR;
    }

    ODS("COneStopHandler::QueryInterface()==>Unknown Interface!\r\n");

	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) COneStopHandler::AddRef()
{
    ODS("COneStopHandler::AddRef()\r\n");

    return ++m_cRef;
}

STDMETHODIMP_(ULONG) COneStopHandler::Release()
{
    ODS("COneStopHandler::Release()\r\n");

    if (--m_cRef)
        return m_cRef;

    DestroyHandler();

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\reg.cpp ===
#include <objbase.h>
#include "SyncHndl.h"
#include "reg.h"

// file contains registration and helper reg routines for handlers





// export for how Rundll32 calls us
EXTERN_C void WINAPI  RunDllRegister(HWND hwnd,
				HINSTANCE hAppInstance,
				LPSTR pszCmdLine,
				int nCmdShow)
{
    
  DllRegisterServer();
  
}



/*F+F++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  Function: SetRegKeyValue

  Summary:  Internal utility function to set a Key, Subkey, and value
            in the system Registry under HKEY_CLASSES_ROOT.

  Args:     LPTSTR pszKey,
            LPTSTR pszSubkey,
            LPTSTR pszValue)

  Returns:  BOOL
              TRUE if success; FALSE if not.
------------------------------------------------------------------------F-F*/


BOOL SetRegKeyValue(
       HKEY hKeyTop,
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValue)
{
  BOOL bOk = FALSE;
  LONG ec;
  HKEY hKey;
  TCHAR szKey[MAX_STRING_LENGTH];

  lstrcpy(szKey, pszKey);

  if (NULL != pszSubkey)
  {
    lstrcat(szKey, TEXT("\\"));
    lstrcat(szKey, pszSubkey);
  }

  ec = RegCreateKeyEx(
         hKeyTop,
         szKey,
         0,
         NULL,
         REG_OPTION_NON_VOLATILE,
         KEY_ALL_ACCESS,
         NULL,
         &hKey,
         NULL);

  if (NULL != pszValue && ERROR_SUCCESS == ec)
  {
    ec = RegSetValueEx(
           hKey,
           NULL,
           0,
           REG_SZ,
           (BYTE *)pszValue,
           (lstrlen(pszValue)+1)*sizeof(TCHAR));
    if (ERROR_SUCCESS == ec)
      bOk = TRUE;
    RegCloseKey(hKey);
  }

  return bOk;
}


// get the regKeyvalue,

LRESULT GetRegKeyValue(HKEY hkeyParent, PCSTR pcszSubKey,
                                   PCSTR pcszValue, PDWORD pdwValueType,
                                   PBYTE pbyteBuf, PDWORD pdwcbBufLen)
{
LONG lResult;
HKEY hkeySubKey;

    lResult = RegOpenKeyEx(hkeyParent, pcszSubKey, 0, KEY_QUERY_VALUE,
                           &hkeySubKey);

    if (lResult == ERROR_SUCCESS)
    {
        LONG lResultClose;

        lResult = RegQueryValueEx(hkeySubKey, pcszValue, NULL, pdwValueType,
                                  pbyteBuf, pdwcbBufLen);

        lResultClose = RegCloseKey(hkeySubKey);

        if (lResult == ERROR_SUCCESS)
            lResult = lResultClose;
    }

    return(lResult);
}


/*F+F++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  Function: AddRegNamedValue

  Summary:  Internal utility function to add a named data value to an
            existing Key (with optional Subkey) in the system Registry
            under HKEY_CLASSES_ROOT.

  Args:     LPTSTR pszKey,
            LPTSTR pszSubkey,
            LPTSTR pszValueName,
            LPTSTR pszValue)

  Returns:  BOOL
              TRUE if success; FALSE if not.
------------------------------------------------------------------------F-F*/
BOOL AddRegNamedValue(
       LPTSTR pszKey,
       LPTSTR pszSubkey,
       LPTSTR pszValueName,
       LPTSTR pszValue)
{
  BOOL bOk = FALSE;
  LONG ec;
  HKEY hKey;
  TCHAR szKey[MAX_STRING_LENGTH];

  lstrcpy(szKey, pszKey);

  if (NULL != pszSubkey)
  {
    lstrcat(szKey, TEXT("\\"));
    lstrcat(szKey, pszSubkey);
  }

  ec = RegOpenKeyEx(
         HKEY_CLASSES_ROOT,
         szKey,
         0,
         KEY_ALL_ACCESS,
         &hKey);

  if (NULL != pszValue && ERROR_SUCCESS == ec)
  {
    ec = RegSetValueEx(
           hKey,
           pszValueName,
           0,
           REG_SZ,
           (BYTE *)pszValue,
           (lstrlen(pszValue)+1)*sizeof(TCHAR));
    if (ERROR_SUCCESS == ec)
      bOk = TRUE;
    RegCloseKey(hKey);
  }

  return bOk;
}

#define HANDLERITEMSKEY TEXT("\\HandlerItems")

// routines for storing and retreiving an ItemID associate with a CLSID and TextString
// if the item isn't found an fCreateKey is true the key will be created for the item.

STDMETHODIMP GetItemIdForHandlerItem(CLSID CLSIDServer,WCHAR *pszItemText,SYNCMGRITEMID *ItemID,BOOL fCreateKey)
{
#ifndef _UNICODE
WCHAR	wszID[GUID_SIZE+1];
TCHAR	wszItemText[GUID_SIZE+1];
WCHAR   wszItemdID[GUID_SIZE+1];
#endif // !_UNICODE	 
TCHAR    szID[GUID_SIZE+1];
TCHAR    *pszLocalItemText = NULL;
TCHAR    szCLSID[GUID_SIZE+1];
TCHAR    szItemID[GUID_SIZE+1];
DWORD	 dwBufLenght = GUID_SIZE+1;
HRESULT  lResult;

#ifdef _UNICODE
  StringFromGUID2(CLSIDServer, szID, GUID_SIZE);
  StringFromGUID2(ItemID, szID, GUID_SIZE);
 
  
  pszLocalItemText =  pszItemText;
#else
  BOOL fUsedDefaultChar;

  // convert clsidServer

  StringFromGUID2(CLSIDServer, wszID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
	wszID,-1,szID,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);

  // convert ItemText
  WideCharToMultiByte(CP_ACP ,0,
	pszItemText,-1,wszItemText,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);

   pszLocalItemText = wszItemText;
   
#endif // _UNICODE

  lstrcpy(szCLSID, TEXT("CLSID\\"));
  lstrcat(szCLSID, szID);
  lstrcat(szCLSID,HANDLERITEMSKEY);
  lstrcat(szCLSID,"\\");
  lstrcat(szCLSID,pszLocalItemText);

   lResult = GetRegKeyValue(HKEY_CLASSES_ROOT,szCLSID,
                              NULL,NULL,
                               (PBYTE) szItemID,&dwBufLenght);

    if (lResult != ERROR_SUCCESS && 
	   TRUE == fCreateKey)
    {

	lResult = CoCreateGuid(ItemID);


	SetItemIdForHandlerItem(CLSIDServer,pszItemText
			,*ItemID);
    }
    else
    {
    #ifdef _UNICODE
	lResult = IIDFromString(szID,ItemID);
    #else

        MultiByteToWideChar(CP_ACP, 0,
                            szItemID, -1,
                            wszItemdID, GUID_SIZE + 1);

       lResult = IIDFromString(wszItemdID,ItemID);
   
    #endif // _UNICODE
    }


    return lResult;
}


// sets the ItemID info so it can be retreived later.

STDMETHODIMP SetItemIdForHandlerItem(CLSID CLSIDServer,WCHAR *pszItemText,SYNCMGRITEMID ItemID)
{
#ifndef _UNICODE
WCHAR	wszID[GUID_SIZE+1];
TCHAR	wszItemText[GUID_SIZE+1];
WCHAR   wszItemdID[GUID_SIZE+1];
#endif // !_UNICODE	 
TCHAR    szID[GUID_SIZE+1];
TCHAR    *pszLocalItemText = NULL;
TCHAR    szCLSID[GUID_SIZE+1];
TCHAR    szItemID[GUID_SIZE+1];

#ifdef _UNICODE
  StringFromGUID2(CLSIDServer, szID, GUID_SIZE);
  StringFromGUID2(ItemID, szID, GUID_SIZE);
 
  
  pszLocalItemText =  pszItemText;
#else
  BOOL fUsedDefaultChar;

  // convert clsidServer

  StringFromGUID2(CLSIDServer, wszID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
	wszID,-1,szID,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);

  // convert ItemID
  StringFromGUID2(ItemID, wszItemdID, GUID_SIZE);

  WideCharToMultiByte(CP_ACP ,0,
	wszItemdID,-1,szItemID,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);



  // convert ItemText
  WideCharToMultiByte(CP_ACP ,0,
	pszItemText,-1,wszItemText,GUID_SIZE + 1,
	NULL,&fUsedDefaultChar);

   pszLocalItemText = wszItemText;
   
#endif // _UNICODE

  lstrcpy(szCLSID, TEXT("CLSID\\"));
  lstrcat(szCLSID, szID);
  lstrcat(szCLSID,HANDLERITEMSKEY);


  // Create entries under CLSID.

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    NULL,
    "Handler Items");

  SetRegKeyValue(HKEY_CLASSES_ROOT,
    szCLSID,
    pszLocalItemText,
    szItemID);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\handler\synchndl.h ===
//
// The class ID of this OneStop Handler class.
//
//
                                  
#define ODS(sz) OutputDebugString(sz)

#ifndef _SYNCHNDLR_H
#define _SYNCHNDLR_H

#include <objbase.h>
#include <mobsync.h>

#include "reg.h" // include so Handlers can call the reg helper routines.


// base structure for OfflineHandler item.
//  specific implementations allocate extra space on the end for their specific data.
typedef struct  _SYNCMGRHANDLERITEM
{
    _SYNCMGRHANDLERITEM *pNextOfflineItem;
    SYNCMGRITEM offlineItem; // array of OfflineItems
}  SYNCMGRHANDLERITEM;

typedef SYNCMGRHANDLERITEM *LPSYNCMGRHANDLERITEM;


// structure for keeping track of items as a whole 
typedef struct  _tagSYNCMGRHANDLERITEMS
{
    DWORD _cRefs;			    // reference count on this structure
    DWORD dwNumOfflineItems;		    // number of items in OffItems array.
    LPSYNCMGRHANDLERITEM pFirstOfflineItem; // ptr to first OfflineItem in linked list
} SYNCMGRHANDLERITEMS;

typedef SYNCMGRHANDLERITEMS *LPSYNCMGRHANDLERITEMS;



class CClassFactory : public IClassFactory
{
protected:
	ULONG	m_cRef;

public:
	CClassFactory();
	~CClassFactory();

	//IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	//IClassFactory members
	STDMETHODIMP		CreateInstance(LPUNKNOWN, REFIID, LPVOID FAR *);
	STDMETHODIMP		LockServer(BOOL);

};
typedef CClassFactory *LPCClassFactory;

// todo: need helper functions for creating and releasing
// structure so each function doesn't have to call it.


class COneStopHandler : public ISyncMgrSynchronize
{
private:   // should be private
	DWORD m_cRef;
	LPSYNCMGRHANDLERITEMS m_pOfflineHandlerItems;
	LPSYNCMGRSYNCHRONIZECALLBACK m_pOfflineSynchronizeCallback;

public:
	COneStopHandler();
	~COneStopHandler();

	//IUnknown members
	STDMETHODIMP		QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	virtual inline STDMETHODIMP  DestroyHandler() { return NOERROR; };

	// IOfflineSynchroinze methods
	STDMETHODIMP	Initialize(DWORD dwReserved,DWORD dwSyncFlags,
				    DWORD cbCookie,const BYTE *lpCooke);
	STDMETHODIMP	GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
        
	STDMETHODIMP	EnumSyncMgrItems(ISyncMgrEnumItems **ppenumOffineItems);
	STDMETHODIMP	GetItemObject(REFSYNCMGRITEMID ItemID,REFIID riid,void** ppv);
	STDMETHODIMP	ShowProperties(HWND hwnd,REFSYNCMGRITEMID ItemID);
	STDMETHODIMP	SetProgressCallback(ISyncMgrSynchronizeCallback *lpCallBack);
	STDMETHODIMP	PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID* pItemIDs,HWND hWndParent,
				    DWORD dwReserved);
	STDMETHODIMP	Synchronize(HWND hwnd);
	STDMETHODIMP    SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
	STDMETHODIMP	ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);
	// functions for get/set of private variables.
	inline LPSYNCMGRHANDLERITEMS GetOfflineItemsHolder() { return m_pOfflineHandlerItems; };
	inline void SetOfflineItemsHolder(LPSYNCMGRHANDLERITEMS pOfflineHandlerItems) 
				{ m_pOfflineHandlerItems = pOfflineHandlerItems; };

	inline LPSYNCMGRSYNCHRONIZECALLBACK GetOfflineSynchronizeCallback() 
					{ return m_pOfflineSynchronizeCallback; };
};
typedef COneStopHandler *LPCOneStopHandler;


class CEnumOfflineItems : public ISyncMgrEnumItems
{
private:
	DWORD m_cRef;
	DWORD m_cOffset;
	LPSYNCMGRHANDLERITEMS m_pOfflineItems; // array of offline items, same format as give to OneStop
	LPSYNCMGRHANDLERITEM m_pNextItem;

public:
	CEnumOfflineItems(LPSYNCMGRHANDLERITEMS  pOfflineItems,DWORD cOffset);
	~CEnumOfflineItems();

	//IUnknown members
	STDMETHODIMP			QueryInterface(REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();
	
	//IEnumOfflineItems members
	STDMETHODIMP Next(ULONG celt, LPSYNCMGRITEM rgelt,ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(ISyncMgrEnumItems **ppenum);
};
typedef CEnumOfflineItems *LPCEnumOfflineItems;

STDAPI DllRegisterServer(void);



// helper function declarations. 
// TODO: MOVE TO OWN FILE
DWORD AddRef_OfflineHandlerItemsList(LPSYNCMGRHANDLERITEMS lpOfflineItem);
DWORD Release_OfflineHandlerItemsList(LPSYNCMGRHANDLERITEMS lpOfflineItem);
LPSYNCMGRHANDLERITEMS CreateOfflineHandlerItemsList();
LPSYNCMGRHANDLERITEM AddOfflineItemToList(LPSYNCMGRHANDLERITEMS pOfflineItemsList,ULONG cbSize);


#endif // _SYNCHNDLR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\edkmdb.h ===
/*
 *	EDKMDB.H
 *
 *	Microsoft Exchange Information Store
 *	Copyright (C) 1986-1996, Microsoft Corporation
 *
 *	Contains declarations of additional properties and interfaces
 *	offered by Microsoft Exchange Information Store
 */

#ifndef	EDKMDB_INCLUDED
#define	EDKMDB_INCLUDED

/*
 *	WARNING: Many of the property id values contained within this
 *  file are subject to change.  For best results please use the
 *	literals declared here instead of the numerical values.
 */

#define pidExchangeXmitReservedMin		0x3FE0
#define pidExchangeNonXmitReservedMin	0x65E0
#define	pidProfileMin					0x6600
#define	pidStoreMin						0x6618
#define	pidFolderMin					0x6638
#define	pidMessageReadOnlyMin			0x6640
#define	pidMessageWriteableMin			0x6658
#define	pidAttachReadOnlyMin			0x666C
#define	pidSpecialMin					0x6670
#define	pidAdminMin						0x6690
#define pidSecureProfileMin				PROP_ID_SECURE_MIN

/*------------------------------------------------------------------------
 *
 *	PROFILE properties
 *
 *	These are used in profiles which contain the Exchange Messaging
 *	Service.  These profiles contain a "global section" used to store
 *	common data, plus individual sections for the transport provider,
 *	one store provider for the user, one store provider for the public
 *	store, and one store provider for each additional mailbox the user
 *	has delegate access to.
 *
 *-----------------------------------------------------------------------*/

/* GUID of the global section */

#define	pbGlobalProfileSectionGuid	"\x13\xDB\xB0\xC8\xAA\x05\x10\x1A\x9B\xB0\x00\xAA\x00\x2F\xC4\x5A"


/* Properties in the global section */

#define	PR_PROFILE_VERSION				PROP_TAG( PT_LONG, pidProfileMin+0x00)
#define	PR_PROFILE_CONFIG_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x01)
#define	PR_PROFILE_HOME_SERVER			PROP_TAG( PT_STRING8, pidProfileMin+0x02)
#define	PR_PROFILE_HOME_SERVER_DN		PROP_TAG( PT_STRING8, pidProfileMin+0x12)
#define	PR_PROFILE_HOME_SERVER_ADDRS	PROP_TAG( PT_MV_STRING8, pidProfileMin+0x13)
#define	PR_PROFILE_USER					PROP_TAG( PT_STRING8, pidProfileMin+0x03)
#define	PR_PROFILE_CONNECT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x04)
#define PR_PROFILE_TRANSPORT_FLAGS		PROP_TAG( PT_LONG, pidProfileMin+0x05)
#define	PR_PROFILE_UI_STATE				PROP_TAG( PT_LONG, pidProfileMin+0x06)
#define	PR_PROFILE_UNRESOLVED_NAME		PROP_TAG( PT_STRING8, pidProfileMin+0x07)
#define	PR_PROFILE_UNRESOLVED_SERVER	PROP_TAG( PT_STRING8, pidProfileMin+0x08)
#define PR_PROFILE_BINDING_ORDER		PROP_TAG( PT_STRING8, pidProfileMin+0x09)
#define PR_PROFILE_MAX_RESTRICT			PROP_TAG( PT_LONG, pidProfileMin+0x0D)
#define	PR_PROFILE_AB_FILES_PATH		PROP_TAG( PT_STRING8, pidProfileMin+0xE)
#define PR_PROFILE_OFFLINE_STORE_PATH	PROP_TAG( PT_STRING8, pidProfileMin+0x10)
#define PR_PROFILE_OFFLINE_INFO			PROP_TAG( PT_BINARY, pidProfileMin+0x11)
#define PR_PROFILE_ADDR_INFO			PROP_TAG( PT_BINARY, pidSpecialMin+0x17)
#define PR_PROFILE_OPTIONS_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x19)
#define PR_PROFILE_SECURE_MAILBOX		PROP_TAG( PT_BINARY, pidSecureProfileMin + 0)
#define PR_DISABLE_WINSOCK				PROP_TAG( PT_LONG, pidProfileMin+0x18)

/* Properties passed through the Service Entry to the OST */
#define PR_OST_ENCRYPTION				PROP_TAG(PT_LONG, 0x6702)

/* Values for PR_OST_ENCRYPTION */
#define OSTF_NO_ENCRYPTION              ((DWORD)0x80000000)
#define OSTF_COMPRESSABLE_ENCRYPTION    ((DWORD)0x40000000)
#define OSTF_BEST_ENCRYPTION            ((DWORD)0x20000000)

/* Properties in each profile section */

#define	PR_PROFILE_OPEN_FLAGS			PROP_TAG( PT_LONG, pidProfileMin+0x09)
#define	PR_PROFILE_TYPE					PROP_TAG( PT_LONG, pidProfileMin+0x0A)
#define	PR_PROFILE_MAILBOX				PROP_TAG( PT_STRING8, pidProfileMin+0x0B)
#define	PR_PROFILE_SERVER				PROP_TAG( PT_STRING8, pidProfileMin+0x0C)
#define	PR_PROFILE_SERVER_DN			PROP_TAG( PT_STRING8, pidProfileMin+0x14)

/* Properties in the Public Folders section */

#define PR_PROFILE_FAVFLD_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x0F)
#define PR_PROFILE_FAVFLD_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x15)
#define PR_PROFILE_ALLPUB_DISPLAY_NAME	PROP_TAG(PT_STRING8, pidProfileMin+0x16)
#define PR_PROFILE_ALLPUB_COMMENT		PROP_TAG(PT_STRING8, pidProfileMin+0x17)

// Current value for PR_PROFILE_VERSION
#define	PROFILE_VERSION						((ULONG)0x501)

// Bit values for PR_PROFILE_CONFIG_FLAGS

#define	CONFIG_SERVICE						((ULONG)1)
#define	CONFIG_SHOW_STARTUP_UI				((ULONG)2)
#define	CONFIG_SHOW_CONNECT_UI				((ULONG)4)
#define	CONFIG_PROMPT_FOR_CREDENTIALS		((ULONG)8)

// Bit values for PR_PROFILE_CONNECT_FLAGS

#define	CONNECT_USE_ADMIN_PRIVILEGE			((ULONG)1)
#define	CONNECT_NO_RPC_ENCRYPTION			((ULONG)2)

// Bit values for PR_PROFILE_TRANSPORT_FLAGS

#define	TRANSPORT_DOWNLOAD					((ULONG)1)
#define TRANSPORT_UPLOAD					((ULONG)2)

// Bit values for PR_PROFILE_OPEN_FLAGS

#define	OPENSTORE_USE_ADMIN_PRIVILEGE		((ULONG)1)
#define OPENSTORE_PUBLIC					((ULONG)2)
#define	OPENSTORE_HOME_LOGON				((ULONG)4)
#define OPENSTORE_TAKE_OWNERSHIP			((ULONG)8)
#define OPENSTORE_OVERRIDE_HOME_MDB			((ULONG)16)
#define OPENSTORE_TRANSPORT					((ULONG)32)
#define OPENSTORE_REMOTE_TRANSPORT			((ULONG)64)

// Values for PR_PROFILE_TYPE

#define	PROFILE_PRIMARY_USER				((ULONG)1)
#define	PROFILE_DELEGATE					((ULONG)2)
#define	PROFILE_PUBLIC_STORE				((ULONG)3)
#define	PROFILE_SUBSCRIPTION				((ULONG)4)


/*------------------------------------------------------------------------
 *
 *	MDB object properties
 *
 *-----------------------------------------------------------------------*/

/* PR_MDB_PROVIDER GUID in stores table */

#define pbExchangeProviderPrimaryUserGuid	"\x54\x94\xA1\xC0\x29\x7F\x10\x1B\xA5\x87\x08\x00\x2B\x2A\x25\x17"
#define pbExchangeProviderDelegateGuid		"\x9e\xb4\x77\x00\x74\xe4\x11\xce\x8c\x5e\x00\xaa\x00\x42\x54\xe2"
#define pbExchangeProviderPublicGuid		"\x78\xb2\xfa\x70\xaf\xf7\x11\xcd\x9b\xc8\x00\xaa\x00\x2f\xc4\x5a"
#define pbExchangeProviderXportGuid			"\xa9\x06\x40\xe0\xd6\x93\x11\xcd\xaf\x95\x00\xaa\x00\x4a\x35\xc3"

// All properties in this section are readonly

// Identity of store
	// All stores
#define	PR_USER_ENTRYID					PROP_TAG( PT_BINARY, pidStoreMin+0x01)
#define	PR_USER_NAME					PROP_TAG( PT_STRING8, pidStoreMin+0x02)

	// All mailbox stores
#define	PR_MAILBOX_OWNER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x03)
#define	PR_MAILBOX_OWNER_NAME			PROP_TAG( PT_STRING8, pidStoreMin+0x04)
#define PR_OOF_STATE					PROP_TAG( PT_BOOLEAN, pidStoreMin+0x05)

	// Public stores -- name of hierarchy server
#define	PR_HIERARCHY_SERVER				PROP_TAG( PT_TSTRING, pidStoreMin+0x1B)

// Entryids of special folders
	// All mailbox stores
#define	PR_SCHEDULE_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x06)

	// All mailbox and gateway stores
#define PR_IPM_DAF_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x07)

	// Public store
#define	PR_NON_IPM_SUBTREE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x08)
#define	PR_EFORMS_REGISTRY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x09)
#define	PR_SPLUS_FREE_BUSY_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0A)
#define	PR_OFFLINE_ADDRBOOK_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0B)
#define	PR_EFORMS_FOR_LOCALE_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x0C)
#define	PR_FREE_BUSY_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0D)
#define	PR_ADDRBOOK_FOR_LOCAL_SITE_ENTRYID		PROP_TAG( PT_BINARY, pidStoreMin+0x0E)
#define	PR_OFFLINE_MESSAGE_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x0F)
#define PR_IPM_FAVORITES_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x18)
#define PR_IPM_PUBLIC_FOLDERS_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x19)

	// Gateway stores
#define	PR_GW_MTSIN_ENTRYID				PROP_TAG( PT_BINARY, pidStoreMin+0x10)
#define	PR_GW_MTSOUT_ENTRYID			PROP_TAG( PT_BINARY, pidStoreMin+0x11)
#define	PR_TRANSFER_ENABLED				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x12)

// This property is preinitialized to 256 bytes of zeros
// GetProp on this property is guaranteed to RPC.  May be used
// to determine line speed of connection to server.
#define	PR_TEST_LINE_SPEED				PROP_TAG( PT_BINARY, pidStoreMin+0x13)

// Used with OpenProperty to get interface, also on folders
#define	PR_HIERARCHY_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x14)
#define	PR_CONTENTS_SYNCHRONIZER		PROP_TAG( PT_OBJECT, pidStoreMin+0x15)
#define	PR_COLLECTOR					PROP_TAG( PT_OBJECT, pidStoreMin+0x16)

// Used with OpenProperty to get interface for folders, messages, attachmentson
#define	PR_FAST_TRANSFER				PROP_TAG( PT_OBJECT, pidStoreMin+0x17)

// This property is available on mailbox and public stores.  If it exists
// and its value is TRUE, the store is connected to the offline store provider.
#define PR_STORE_OFFLINE				PROP_TAG( PT_BOOLEAN, pidStoreMin+0x1A)

// In transit state for store object.  This state is
// set when mail is being moved and it pauses mail delivery
// to the mail box
#define	PR_IN_TRANSIT					PROP_TAG( PT_BOOLEAN, pidStoreMin)

// Writable only with Admin rights, available on public stores and folders
#define PR_REPLICATION_STYLE			PROP_TAG( PT_LONG, pidAdminMin)
#define PR_REPLICATION_SCHEDULE			PROP_TAG( PT_BINARY, pidAdminMin+0x01)
#define PR_REPLICATION_MESSAGE_PRIORITY PROP_TAG( PT_LONG, pidAdminMin+0x02)

// Writable only with Admin rights, available on public stores
#define PR_OVERALL_MSG_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x03 )
#define PR_REPLICATION_ALWAYS_INTERVAL	PROP_TAG( PT_LONG, pidAdminMin+0x04 )
#define PR_REPLICATION_MSG_SIZE			PROP_TAG( PT_LONG, pidAdminMin+0x05 )

// default replication style=always interval (minutes)
#define STYLE_ALWAYS_INTERVAL_DEFAULT	(ULONG) 15

// default replication message size limit (KB)
#define REPLICATION_MESSAGE_SIZE_LIMIT_DEFAULT	(ULONG) 100

// Values for PR_REPLICATION_STYLE
#define STYLE_NEVER				(ULONG) 0	// never replicate
#define STYLE_NORMAL			(ULONG) 1	// use 84 byte schedule TIB
#define STYLE_ALWAYS			(ULONG) 2	// replicate at fastest rate
#define STYLE_DEFAULT			(ULONG) -1	// default value

/*------------------------------------------------------------------------
 *
 *	INCREMENTAL CHANGE SYNCHRONIZATION
 *	folder and message properties
 *
 *-----------------------------------------------------------------------*/

#define PR_SOURCE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x0)
#define PR_PARENT_SOURCE_KEY			PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x1)
#define PR_CHANGE_KEY					PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x2)
#define PR_PREDECESSOR_CHANGE_LIST		PROP_TAG( PT_BINARY, pidExchangeNonXmitReservedMin+0x3)

/*------------------------------------------------------------------------
 *
 *	FOLDER object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, available on all folders
#define	PR_FOLDER_CHILD_COUNT			PROP_TAG( PT_LONG, pidFolderMin)
#define	PR_RIGHTS						PROP_TAG( PT_LONG, pidFolderMin+0x01)
#define	PR_ACL_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin)
#define	PR_RULES_TABLE					PROP_TAG( PT_OBJECT, pidExchangeXmitReservedMin+0x1)
#define	PR_HAS_RULES				PROP_TAG( PT_BOOLEAN, pidFolderMin+0x02)

//Read only, available only for public folders
#define	PR_ADDRESS_BOOK_ENTRYID		PROP_TAG( PT_BINARY, pidFolderMin+0x03)

//Writable, available on folders in all stores
#define	PR_ACL_DATA					PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin)
#define	PR_RULES_DATA				PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x1)
#define	PR_FOLDER_DESIGN_FLAGS		PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x2)
#define	PR_DESIGN_IN_PROGRESS		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x4)
#define	PR_SECURE_ORIGINATION		PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x5)

//Writable, available only for public folders
#define	PR_PUBLISH_IN_ADDRESS_BOOK	PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x6)
#define	PR_RESOLVE_METHOD			PROP_TAG( PT_LONG,  pidExchangeXmitReservedMin+0x7)
#define	PR_ADDRESS_BOOK_DISPLAY_NAME	PROP_TAG( PT_TSTRING, pidExchangeXmitReservedMin+0x8)

//Writable, used to indicate locale id for eforms registry subfolders
#define	PR_EFORMS_LOCALE_ID			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0x9)

// Writable only with Admin rights, available only for public folders
#define PR_REPLICA_LIST				PROP_TAG( PT_BINARY, pidAdminMin+0x8)
#define PR_OVERALL_AGE_LIMIT		PROP_TAG( PT_LONG, pidAdminMin+0x9)

//PR_RESOLVE_METHOD values
#define	RESOLVE_METHOD_DEFAULT			((LONG)0)	// default handling attach conflicts
#define	RESOLVE_METHOD_LAST_WRITER_WINS	((LONG)1)	// the last writer will win conflict
#define	RESOLVE_METHOD_NO_CONFLICT_NOTIFICATION ((LONG)2) // no conflict notif

//Read only, available only for public folder favorites
#define PR_PUBLIC_FOLDER_ENTRYID	PROP_TAG( PT_BINARY, pidFolderMin+0x04)

/*------------------------------------------------------------------------
 *
 *	MESSAGE object properties
 *
 *-----------------------------------------------------------------------*/

// Read only, automatically set on all messages in all stores
#define	PR_HAS_NAMED_PROPERTIES			PROP_TAG(PT_BOOLEAN, pidMessageReadOnlyMin+0x0A)

// Read only but outside the provider specific range for replication thru GDK-GWs
#define	PR_CREATOR_NAME					PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x18)
#define	PR_CREATOR_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x19)
#define	PR_LAST_MODIFIER_NAME			PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x1A)
#define	PR_LAST_MODIFIER_ENTRYID		PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x1B)

// Read only, appears on messages which have DAM's pointing to them
#define PR_HAS_DAMS						PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0xA)
#define PR_RULE_TRIGGER_HISTORY			PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x12)
#define	PR_MOVE_TO_STORE_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x13)
#define	PR_MOVE_TO_FOLDER_ENTRYID		PROP_TAG( PT_BINARY, pidExchangeXmitReservedMin+0x14)

// Read only, available only on messages in the public store
#define	PR_REPLICA_SERVER				PROP_TAG(PT_TSTRING, pidMessageReadOnlyMin+0x4)

// Writeable, used for recording send option dialog settings
#define	PR_DEFERRED_SEND_NUMBER			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xB)
#define	PR_DEFERRED_SEND_UNITS			PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xC)
#define	PR_EXPIRY_NUMBER				PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xD)
#define	PR_EXPIRY_UNITS					PROP_TAG( PT_LONG, pidExchangeXmitReservedMin+0xE)

// Writeable, deferred send time
#define PR_DEFERRED_SEND_TIME			PROP_TAG( PT_SYSTIME, pidExchangeXmitReservedMin+0xF)

//Writeable, intended for both folders and messages in gateway mailbox
#define	PR_GW_ADMIN_OPERATIONS			PROP_TAG( PT_LONG, pidMessageWriteableMin)

//Writeable, used for DMS messages
#define PR_P1_CONTENT					PROP_TAG( PT_BINARY, 0x1100)
#define PR_P1_CONTENT_TYPE				PROP_TAG( PT_BINARY, 0x1101)

// Properties on deferred action messages
#define	PR_CLIENT_ACTIONS		  		PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x5)
#define	PR_DAM_ORIGINAL_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x6)
#define PR_DAM_BACK_PATCHED				PROP_TAG( PT_BOOLEAN, pidMessageReadOnlyMin+0x7)

// Properties on deferred action error messages
#define	PR_RULE_ERROR					PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x8)
#define	PR_RULE_ACTION_TYPE				PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x9)
#define	PR_RULE_ACTION_NUMBER			PROP_TAG(PT_LONG, pidMessageReadOnlyMin+0x10)
#define PR_RULE_FOLDER_ENTRYID			PROP_TAG(PT_BINARY, pidMessageReadOnlyMin+0x11)

// Property on conflict notification indicating entryid of conflicting object
#define	PR_CONFLICT_ENTRYID				PROP_TAG(PT_BINARY, pidExchangeXmitReservedMin+0x10)

// Property on messages to indicate the language client used to create this message
#define	PR_MESSAGE_LOCALE_ID			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x11)

// Properties on Quota warning messages to indicate Storage quota and Excess used
#define	PR_STORAGE_QUOTA_LIMIT			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x15)
#define	PR_EXCESS_STORAGE_USED			PROP_TAG(PT_LONG, pidExchangeXmitReservedMin+0x16)
#define PR_SVR_GENERATING_QUOTA_MSG		PROP_TAG(PT_TSTRING, pidExchangeXmitReservedMin+0x17)

// Property affixed by delegation rule and deleted on forwards
#define PR_DELEGATED_BY_RULE			PROP_TAG( PT_BOOLEAN, pidExchangeXmitReservedMin+0x3)

// Message status bit used to indicate message is in conflict
#define	MSGSTATUS_IN_CONFLICT			((ULONG) 0x800)

/*------------------------------------------------------------------------
 *
 *	ATTACHMENT object properties
 *
 *-----------------------------------------------------------------------*/

// Appears on attachments to a message marked to be in conflict.  Identifies
// those attachments which are conflicting versions of the top level message
#define	PR_IN_CONFLICT					PROP_TAG(PT_BOOLEAN, pidAttachReadOnlyMin)


/*------------------------------------------------------------------------
 *
 *	TABLE object properties
 *
 *	Id Range: 0x662F-0x662F
 *
 *-----------------------------------------------------------------------*/

//This property can be used in a contents table to get PR_ENTRYID returned
//as a long term entryid instead of a short term entryid.
#define	PR_LONGTERM_ENTRYID_FROM_TABLE	PROP_TAG(PT_BINARY, pidSpecialMin)


/*------------------------------------------------------------------------
 *
 *	Gateway "MTE" ENVELOPE properties
 *
 *	Id Range:  0x66E0-0x66FF
 *
 *-----------------------------------------------------------------------*/

#define PR_ORIGINATOR_NAME				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x3)
#define PR_ORIGINATOR_ADDR				PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x4)
#define PR_ORIGINATOR_ADDRTYPE			PROP_TAG( PT_TSTRING, pidMessageWriteableMin+0x5)
#define PR_ORIGINATOR_ENTRYID			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x6)
#define PR_ARRIVAL_TIME					PROP_TAG( PT_SYSTIME, pidMessageWriteableMin+0x7)
#define PR_TRACE_INFO					PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x8)
#define PR_INTERNAL_TRACE_INFO 			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x12)
#define PR_SUBJECT_TRACE_INFO			PROP_TAG( PT_BINARY, pidMessageWriteableMin+0x9)
#define PR_RECIPIENT_NUMBER				PROP_TAG( PT_LONG, pidMessageWriteableMin+0xA)
#define PR_MTS_SUBJECT_ID				PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xB)
#define PR_REPORT_DESTINATION_NAME		PROP_TAG(PT_TSTRING, pidMessageWriteableMin+0xC)
#define PR_REPORT_DESTINATION_ENTRYID	PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xD)
#define PR_CONTENT_SEARCH_KEY			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xE)
#define PR_FOREIGN_ID					PROP_TAG(PT_BINARY, pidMessageWriteableMin+0xF)
#define PR_FOREIGN_REPORT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x10)
#define PR_FOREIGN_SUBJECT_ID			PROP_TAG(PT_BINARY, pidMessageWriteableMin+0x11)
#define PR_MTS_ID						PR_MESSAGE_SUBMISSION_ID
#define PR_MTS_REPORT_ID				PR_MESSAGE_SUBMISSION_ID


/*------------------------------------------------------------------------
 *
 *	Trace properties format
 *		PR_TRACE_INFO
 *		PR_INTERNAL_TRACE_INFO
 *
 *-----------------------------------------------------------------------*/

#define MAX_ADMD_NAME_SIZ       17
#define MAX_PRMD_NAME_SIZ       17
#define MAX_COUNTRY_NAME_SIZ    4
#define MAX_MTA_NAME_SIZ		33

#define	ADMN_PAD				3
#define	PRMD_PAD				3
#define	COUNTRY_PAD				0
#define	MTA_PAD					3

typedef struct {
    LONG     lAction;                // The routing action the tracing site
                                     // took.
    FILETIME ftArrivalTime;          // The time at which the communique
                                     // entered the tracing site.
    FILETIME ftDeferredTime;         // The time are which the tracing site
                                     // released the message.
    char     rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];           	// ADMD
    char     rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 	// Country
    char     rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];              	// PRMD
    char     rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       	// Attempted ADMD
    char     rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];  // Attempted Country
    char     rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];				// Attempted PRMD
}   TRACEENTRY, FAR * LPTRACEENTRY;

typedef struct {
    ULONG       cEntries;               // Number of trace entries
    TRACEENTRY  rgtraceentry[MAPI_DIM]; // array of trace entries
} TRACEINFO, FAR * LPTRACEINFO;

typedef struct
{
	LONG		lAction;				// The routing action the tracing domain took.
	FILETIME	ftArrivalTime;			// The time at which the communique entered the tracing domain.
	FILETIME	ftDeferredTime;			// The time are which the tracing domain released the message.

    char        rgchADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];				// ADMD
    char        rgchCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD]; 		// Country
    char        rgchPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];             	// PRMD
    char        rgchAttADMDName[MAX_ADMD_NAME_SIZ+ADMN_PAD];       		// Attempted ADMD
    char        rgchAttCountryName[MAX_COUNTRY_NAME_SIZ+COUNTRY_PAD];	// Attempted Country
    char        rgchAttPRMDId[MAX_PRMD_NAME_SIZ+PRMD_PAD];		        // Attempted PRMD
    char        rgchMTAName[MAX_MTA_NAME_SIZ+MTA_PAD]; 		            // MTA Name
    char        rgchAttMTAName[MAX_MTA_NAME_SIZ+MTA_PAD];		        // Attempted MTA Name
}INTTRACEENTRY, *PINTTRACEENTRY;

typedef	struct
{
	ULONG  			cEntries;					// Number of trace entries
	INTTRACEENTRY	rgIntTraceEntry[MAPI_DIM];	// array of internal trace entries
}INTTRACEINFO, *PINTTRACEINFO;


/*------------------------------------------------------------------------
 *
 *	"IExchangeModifyTable" Interface Declaration
 *
 *	Used for get/set rules and access control on folders.
 *
 *-----------------------------------------------------------------------*/


/* ulRowFlags */
#define ROWLIST_REPLACE		((ULONG)1)

#define ROW_ADD				((ULONG)1)
#define ROW_MODIFY			((ULONG)2)
#define ROW_REMOVE			((ULONG)4)
#define ROW_EMPTY			(ROW_ADD|ROW_REMOVE)

typedef struct _ROWENTRY
{
	ULONG			ulRowFlags;
	ULONG			cValues;
	LPSPropValue	rgPropVals;
} ROWENTRY, FAR * LPROWENTRY;

typedef struct _ROWLIST
{
	ULONG			cEntries;
	ROWENTRY		aEntries[MAPI_DIM];
} ROWLIST, FAR * LPROWLIST;

#define EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(IPURE)					\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyTable)												\
		(THIS_	ULONG						ulFlags,					\
				LPROWLIST					lpMods) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeModifyTable
DECLARE_MAPI_INTERFACE_(IExchangeModifyTable, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMODIFYTABLE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeModifyTable,	LPEXCHANGEMODIFYTABLE);

/* Access Control Specifics */

//Properties
#define	PR_MEMBER_ID					PROP_TAG( PT_I8, pidSpecialMin+0x01)
#define	PR_MEMBER_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x02)
#define	PR_MEMBER_ENTRYID				PR_ENTRYID
#define	PR_MEMBER_RIGHTS				PROP_TAG( PT_LONG, pidSpecialMin+0x03)

//Security bits
typedef DWORD RIGHTS;
#define frightsReadAny			0x0000001L
#define	frightsCreate			0x0000002L
#define	frightsEditOwned		0x0000008L
#define	frightsDeleteOwned		0x0000010L
#define	frightsEditAny			0x0000020L
#define	frightsDeleteAny		0x0000040L
#define	frightsCreateSubfolder	0x0000080L
#define	frightsOwner			0x0000100L
#define	frightsContact			0x0000200L	// NOTE: not part of rightsAll
#define	rightsNone				0x00000000
#define	rightsReadOnly			frightsReadAny
#define	rightsReadWrite			(frightsReadAny|frightsEditAny)
#define	rightsAll				0x00001FBL

/* Rules specifics */

//Property types
#define	PT_SRESTRICTION				((ULONG) 0x00FD)
#define	PT_ACTIONS					((ULONG) 0x00FE)

//Properties in rule table
#define	PR_RULE_ID						PROP_TAG( PT_I8, pidSpecialMin+0x04)
#define	PR_RULE_IDS						PROP_TAG( PT_BINARY, pidSpecialMin+0x05)
#define	PR_RULE_SEQUENCE				PROP_TAG( PT_LONG, pidSpecialMin+0x06)
#define	PR_RULE_STATE					PROP_TAG( PT_LONG, pidSpecialMin+0x07)
#define	PR_RULE_USER_FLAGS				PROP_TAG( PT_LONG, pidSpecialMin+0x08)
#define	PR_RULE_CONDITION				PROP_TAG( PT_SRESTRICTION, pidSpecialMin+0x09)
#define	PR_RULE_ACTIONS					PROP_TAG( PT_ACTIONS, pidSpecialMin+0x10)
#define	PR_RULE_PROVIDER				PROP_TAG( PT_STRING8, pidSpecialMin+0x11)
#define	PR_RULE_NAME					PROP_TAG( PT_TSTRING, pidSpecialMin+0x12)
#define	PR_RULE_LEVEL					PROP_TAG( PT_LONG, pidSpecialMin+0x13)
#define	PR_RULE_PROVIDER_DATA			PROP_TAG( PT_BINARY, pidSpecialMin+0x14)

//PR_STATE property values
#define ST_DISABLED			0x0000
#define ST_ENABLED			0x0001
#define ST_ERROR			0x0002
#define ST_ONLY_WHEN_OOF	0x0004
#define ST_KEEP_OOF_HIST	0x0008
#define ST_EXIT_LEVEL		0x0010

#define ST_CLEAR_OOF_HIST	0x80000000

//Empty restriction
#define NULL_RESTRICTION	0xff

// special RELOP for Member of DL
#define RELOP_MEMBER_OF_DL	100

//Action types
typedef enum
{
	OP_MOVE = 1,
	OP_COPY,
	OP_REPLY,
	OP_OOF_REPLY,
	OP_DEFER_ACTION,
	OP_BOUNCE,
	OP_FORWARD,
	OP_DELEGATE,
	OP_TAG,
	OP_DELETE,
	OP_MARK_AS_READ
} ACTTYPE;

// action flavors

// for OP_REPLY
#define	DO_NOT_SEND_TO_ORIGINATOR		1

//scBounceCode values
#define	BOUNCE_MESSAGE_SIZE_TOO_LARGE	(SCODE) MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD
#define BOUNCE_FORMS_MISMATCH			(SCODE) MAPI_DIAG_RENDITION_UNSUPPORTED
#define BOUNCE_ACCESS_DENIED			(SCODE) MAPI_DIAG_MAIL_REFUSED

//Message class prefix for Reply and OOF Reply templates
#define szReplyTemplateMsgClassPrefix	"IPM.Note.Rules.ReplyTemplate."
#define szOofTemplateMsgClassPrefix		"IPM.Note.Rules.OofTemplate."

//Action structure
typedef struct _action
{
	ACTTYPE		acttype;

	// to indicate which flavour of the action.
	ULONG		ulActionFlavor;

	// Action restriction
	// currently unsed and must be set to NULL
	LPSRestriction	lpRes;

	// currently unused, must be set to 0.
	LPSPropTagArray	lpPropTagArray;

	// User defined flags
	ULONG		ulFlags;

	// padding to align the union on 8 byte boundary
	ULONG		dwAlignPad;

	union
	{
		// used for OP_MOVE and OP_COPY actions
		struct
		{
			ULONG		cbStoreEntryId;
			LPENTRYID	lpStoreEntryId;
			ULONG		cbFldEntryId;
			LPENTRYID	lpFldEntryId;
		} actMoveCopy;

		// used for OP_REPLY and OP_OOF_REPLY actions
		struct
		{
			ULONG		cbEntryId;
			LPENTRYID	lpEntryId;
			GUID		guidReplyTemplate;
		} actReply;

		// used for OP_DEFER_ACTION action
		struct
		{
			ULONG		cbData;
			BYTE		*pbData;
		} actDeferAction;

		// Error code to set for OP_BOUNCE action
		SCODE			scBounceCode;

		// list of address for OP_FORWARD and OP_DELEGATE action
		LPADRLIST		lpadrlist;

		// prop value for OP_TAG action
		SPropValue		propTag;
	};
} ACTION, FAR * LPACTION;

// Rules version
#define EDK_RULES_VERSION		1

//Array of actions
typedef struct _actions
{
	ULONG		ulVersion;		// use the #define above
	UINT		cActions;
	LPACTION	lpAction;
} ACTIONS;

// message class definitions for Deferred Action and Deffered Error messages
#define szDamMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Action"
#define szDemMsgClass		"IPC.Microsoft Exchange 4.0.Deferred Error"

/*
 *	Rule error codes
 *	Values for PR_RULE_ERROR
 */
#define	RULE_ERR_UNKNOWN		1			//general catchall error
#define	RULE_ERR_LOAD			2			//unable to load folder rules
#define	RULE_ERR_DELIVERY		3			//unable to deliver message temporarily
#define	RULE_ERR_PARSING		4			//error while parsing
#define	RULE_ERR_CREATE_DAE		5			//error creating DAE message
#define	RULE_ERR_NO_FOLDER		6			//folder to move/copy doesn't exist
#define	RULE_ERR_NO_RIGHTS		7			//no rights to move/copy into folder
#define	RULE_ERR_CREATE_DAM		8			//error creating DAM
#define RULE_ERR_NO_SENDAS		9			//can not send as another user
#define RULE_ERR_NO_TEMPLATE	10			//reply template is missing
#define RULE_ERR_EXECUTION		11			//error in rule execution
#define RULE_ERR_QUOTA_EXCEEDED	12

#define RULE_ERR_FIRST		RULE_ERR_UNKNOWN
#define RULE_ERR_LAST		RULE_ERR_QUOTA_EXCEEDED

/*------------------------------------------------------------------------
 *
 *	"IExchangeRuleAction" Interface Declaration
 *
 *	Used for get actions from a Deferred Action Message.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGERULEACTION_METHODS(IPURE)						\
	MAPIMETHOD(ActionCount)												\
		(THIS_	ULONG FAR *					lpcActions) IPURE;			\
	MAPIMETHOD(GetAction)												\
		(THIS_	ULONG						ulActionNumber,				\
				LARGE_INTEGER	*			lpruleid,					\
				LPACTION FAR *				lppAction) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeRuleAction
DECLARE_MAPI_INTERFACE_(IExchangeRuleAction, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGERULEACTION_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeRuleAction,	LPEXCHANGERULEACTION);

/*------------------------------------------------------------------------
 *
 *	"IExchangeManageStore" Interface Declaration
 *
 *	Used for store management functions.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(IPURE)					\
	MAPIMETHOD(CreateStoreEntryID)										\
		(THIS_	LPSTR						lpszMsgStoreDN,				\
				LPSTR						lpszMailboxDN,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(EntryIDFromSourceKey)									\
		(THIS_	ULONG						cFolderKeySize,				\
				BYTE FAR *					lpFolderSourceKey,			\
				ULONG						cMessageKeySize,			\
				BYTE FAR *					lpMessageSourceKey,			\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID) IPURE;			\
	MAPIMETHOD(GetRights)												\
		(THIS_	ULONG						cbUserEntryID,				\
				LPENTRYID					lpUserEntryID,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG FAR *					lpulRights) IPURE;			\
	MAPIMETHOD(GetMailboxTable)											\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetPublicFolderTable)									\
		(THIS_	LPSTR						lpszServerName,				\
				LPMAPITABLE FAR *			lppTable,					\
				ULONG						ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeManageStore
DECLARE_MAPI_INTERFACE_(IExchangeManageStore, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEMANAGESTORE_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeManageStore, LPEXCHANGEMANAGESTORE);


// Properties for GetMailboxTable
#define PR_NT_USER_NAME                         PROP_TAG( PT_TSTRING, pidAdminMin+0x10)
#define PR_LOCALE_ID                            PROP_TAG( PT_LONG, pidAdminMin+0x11 )
#define PR_LAST_LOGON_TIME                      PROP_TAG( PT_SYSTIME, pidAdminMin+0x12 )
#define PR_LAST_LOGOFF_TIME                     PROP_TAG( PT_SYSTIME, pidAdminMin+0x13 )
#define PR_STORAGE_LIMIT_INFORMATION			PROP_TAG( PT_LONG, pidAdminMin+0x14 )

// Properties for GetPublicFolderTable
#define PR_FOLDER_FLAGS                         PROP_TAG( PT_LONG, pidAdminMin+0x18 )
#define	PR_LAST_ACCESS_TIME						PROP_TAG( PT_SYSTIME, pidAdminMin+0x19 )
#define PR_RESTRICTION_COUNT                    PROP_TAG( PT_LONG, pidAdminMin+0x1A )
#define PR_CATEG_COUNT                          PROP_TAG( PT_LONG, pidAdminMin+0x1B )
#define PR_CACHED_COLUMN_COUNT                  PROP_TAG( PT_LONG, pidAdminMin+0x1C )
#define PR_NORMAL_MSG_W_ATTACH_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x1D )
#define PR_ASSOC_MSG_W_ATTACH_COUNT             PROP_TAG( PT_LONG, pidAdminMin+0x1E )
#define PR_RECIPIENT_ON_NORMAL_MSG_COUNT        PROP_TAG( PT_LONG, pidAdminMin+0x1F )
#define PR_RECIPIENT_ON_ASSOC_MSG_COUNT 		PROP_TAG( PT_LONG, pidAdminMin+0x20 )
#define PR_ATTACH_ON_NORMAL_MSG_COUNT   		PROP_TAG( PT_LONG, pidAdminMin+0x21 )
#define PR_ATTACH_ON_ASSOC_MSG_COUNT    		PROP_TAG( PT_LONG, pidAdminMin+0x22 )
#define PR_NORMAL_MESSAGE_SIZE                  PROP_TAG( PT_LONG, pidAdminMin+0x23 )
#define PR_NORMAL_MESSAGE_SIZE_EXTENDED         PROP_TAG( PT_I8, pidAdminMin+0x23 )
#define PR_ASSOC_MESSAGE_SIZE                   PROP_TAG( PT_LONG, pidAdminMin+0x24 )
#define PR_ASSOC_MESSAGE_SIZE_EXTENDED          PROP_TAG( PT_I8, pidAdminMin+0x24 )
#define PR_FOLDER_PATHNAME                      PROP_TAG(PT_TSTRING, pidAdminMin+0x25 )
#define PR_OWNER_COUNT							PROP_TAG( PT_LONG, pidAdminMin+0x26 )
#define PR_CONTACT_COUNT						PROP_TAG( PT_LONG, pidAdminMin+0x27 )

// PT_I8 version of PR_MESSAGE_SIZE defined in mapitags.h
#define	PR_MESSAGE_SIZE_EXTENDED			PROP_TAG(PT_I8, PROP_ID(PR_MESSAGE_SIZE))

/* Bits in PR_FOLDER_FLAGS */
#define MDB_FOLDER_IPM                  0x1
#define MDB_FOLDER_SEARCH               0x2
#define MDB_FOLDER_NORMAL               0x4
#define MDB_FOLDER_RULES                0x8

/* Bits used in ulFlags in GetPublicFolderTable() */
#define MDB_NON_IPM                     0x10
#define MDB_IPM                         0x20

/* Bits in PR_STORAGE_LIMIT_INFORMATION */
#define MDB_LIMIT_BELOW					0x1
#define MDB_LIMIT_ISSUE_WARNING			0x2
#define MDB_LIMIT_PROHIBIT_SEND			0x4
#define MDB_LIMIT_NO_CHECK				0x8


/*------------------------------------------------------------------------
 *
 *	"IExchangeFastTransfer" Interface Declaration
 *
 *	Used for fast transfer interface used to
 *	implement CopyTo, CopyProps, CopyFolder, and
 *	CopyMessages.
 *
 *-----------------------------------------------------------------------*/

// Transfer flags
// Use MAPI_MOVE for move option

// Transfer methods
#define	TRANSFER_COPYTO			1
#define	TRANSFER_COPYPROPS		2
#define	TRANSFER_COPYMESSAGES	3
#define	TRANSFER_COPYFOLDER		4


#define EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(IPURE)			\
	MAPIMETHOD(Config)											\
		(THIS_	ULONG				ulFlags,					\
				ULONG				ulTransferMethod) IPURE;	\
	MAPIMETHOD(TransferBuffer)									\
		(THIS_	ULONG				cb,							\
				LPBYTE				lpb,						\
				ULONG				*lpcbProcessed) IPURE;		\
	STDMETHOD_(BOOL, IsInterfaceOk)								\
		(THIS_	ULONG				ulTransferMethod,			\
				REFIID				refiid,						\
				LPSPropTagArray		lpptagList,					\
				ULONG				ulFlags) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFastTransfer
DECLARE_MAPI_INTERFACE_(IExchangeFastTransfer, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFASTTRANSFER_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeFastTransfer, LPEXCHANGEFASTTRANSFER);



/*------------------------------------------------------------------------
 *
 *	"IExchangeExportChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)								\
		(THIS_	HRESULT				hResult,				\
		 	    ULONG				ulFlags,				\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;	\
	MAPIMETHOD(Config)										\
		(THIS_	LPSTREAM			lpStream,				\
				ULONG				ulFlags,				\
				LPUNKNOWN			lpUnk,					\
		 		LPSRestriction		lpRestriction,			\
		 	    LPSPropTagArray		lpIncludeProps,			\
		 	    LPSPropTagArray		lpExcludeProps,			\
		 		ULONG				ulBufferSize) IPURE;	\
	MAPIMETHOD(Synchronize)									\
		(THIS_	ULONG FAR *			lpulSteps,				\
				ULONG FAR *			lpulProgress) IPURE;	\
	MAPIMETHOD(UpdateState)									\
		(THIS_	LPSTREAM			lpStream) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeExportChanges
DECLARE_MAPI_INTERFACE_(IExchangeExportChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEEXPORTCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeExportChanges, LPEXCHANGEEXPORTCHANGES);


typedef struct _ReadState
{
	ULONG		cbSourceKey;
	BYTE	*	pbSourceKey;
	ULONG		ulFlags;
} READSTATE, *LPREADSTATE;

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportContentsChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder contents (i.e. messages)
 *
 *-----------------------------------------------------------------------*/


#define EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
		 	    ULONG				ulFlags,						\
		 	    LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportMessageChange)									\
		(THIS_	ULONG					cpvalChanges,				\
				LPSPropValue			ppvalChanges,				\
				ULONG					ulFlags,					\
				LPMESSAGE				*lppmessage) IPURE;			\
	MAPIMETHOD(ImportMessageDeletion)								\
		(THIS_	ULONG					ulFlags,					\
		 		LPENTRYLIST				lpSrcEntryList) IPURE;		\
	MAPIMETHOD(ImportPerUserReadStateChange)						\
		(THIS_	ULONG					cElements,					\
		 		LPREADSTATE			 	lpReadState) IPURE;			\
	MAPIMETHOD(ImportMessageMove)									\
		(THIS_	ULONG					cbSourceKeySrcFolder,		\
		 		BYTE FAR *				pbSourceKeySrcFolder,		\
		 		ULONG					cbSourceKeySrcMessage,		\
		 		BYTE FAR *				pbSourceKeySrcMessage,		\
		 		ULONG					cbPCLMessage,				\
		 		BYTE FAR *				pbPCLMessage,				\
		 		ULONG					cbSourceKeyDestMessage,		\
		 		BYTE FAR *				pbSourceKeyDestMessage,		\
		 		ULONG					cbChangeNumDestMessage,		\
		 		BYTE FAR *				pbChangeNumDestMessage) IPURE;


#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportContentsChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportContentsChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTCONTENTSCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportContentsChanges,
						   LPEXCHANGEIMPORTCONTENTSCHANGES);

/*------------------------------------------------------------------------
 *
 *	"IExchangeImportHierarchyChanges" Interface Declaration
 *
 *	Used for Incremental Synchronization of folder hierarchy
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(IPURE)		\
	MAPIMETHOD(GetLastError)										\
		(THIS_	HRESULT				hResult,						\
				ULONG 				ulFlags,						\
				LPMAPIERROR FAR *	lppMAPIError) IPURE;			\
	MAPIMETHOD(Config)												\
		(THIS_	LPSTREAM				lpStream,					\
		 		ULONG					ulFlags) IPURE;				\
	MAPIMETHOD(UpdateState)											\
		(THIS_	LPSTREAM				lpStream) IPURE;			\
	MAPIMETHOD(ImportFolderChange)									\
		(THIS_	ULONG						cpvalChanges,			\
				LPSPropValue				ppvalChanges) IPURE;	\
	MAPIMETHOD(ImportFolderDeletion)								\
		(THIS_	ULONG						ulFlags,				\
		 		LPENTRYLIST					lpSrcEntryList) IPURE;

#undef		 INTERFACE
#define		 INTERFACE  IExchangeImportHierarchyChanges
DECLARE_MAPI_INTERFACE_(IExchangeImportHierarchyChanges, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEIMPORTHIERARCHYCHANGES_METHODS(PURE)
};
#undef	IMPL
#define IMPL

DECLARE_MAPI_INTERFACE_PTR(IExchangeImportHierarchyChanges,
						   LPEXCHANGEIMPORTHIERARCHYCHANGES);

/*------------------------------------------------------------------------
 *
 *	Errors returned by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define MAKE_SYNC_E(err)	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_ITF, err))
#define MAKE_SYNC_W(warn)	(MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, warn))

#define SYNC_E_UNKNOWN_FLAGS			MAPI_E_UNKNOWN_FLAGS
#define SYNC_E_INVALID_PARAMETER		E_INVALIDARG
#define SYNC_E_ERROR					E_FAIL
#define SYNC_E_OBJECT_DELETED			MAKE_SYNC_E(0x800)
#define SYNC_E_IGNORE					MAKE_SYNC_E(0x801)
#define SYNC_E_CONFLICT					MAKE_SYNC_E(0x802)
#define SYNC_E_NO_PARENT				MAKE_SYNC_E(0x803)
#define SYNC_E_UNSYNCHRONIZED			MAKE_SYNC_E(0x805)

#define SYNC_W_PROGRESS					MAKE_SYNC_W(0x820)
#define SYNC_W_CLIENT_CHANGE_NEWER		MAKE_SYNC_W(0x821)

/*------------------------------------------------------------------------
 *
 *	Flags used by Exchange Incremental Change Synchronization Interface
 *
 *-----------------------------------------------------------------------*/

#define	SYNC_UNICODE				0x01
#define SYNC_NO_DELETIONS			0x02
#define SYNC_NO_SOFT_DELETIONS		0x04
#define	SYNC_READ_STATE				0x08
#define SYNC_ASSOCIATED				0x10
#define SYNC_NORMAL					0x20
#define	SYNC_NO_CONFLICTS			0x40
#define SYNC_ONLY_SPECIFIED_PROPS	0x80
#define SYNC_NO_FOREIGN_KEYS		0x100
#define SYNC_LIMITED_IMESSAGE		0x200


/*------------------------------------------------------------------------
 *
 *	Flags used by ImportMessageDeletion and ImportFolderDeletion methods
 *
 *-----------------------------------------------------------------------*/

#define SYNC_SOFT_DELETE			0x01
#define SYNC_EXPIRY					0x02

/*------------------------------------------------------------------------
 *
 *	Flags used by ImportPerUserReadStateChange method
 *
 *-----------------------------------------------------------------------*/

#define SYNC_READ					0x01

/*------------------------------------------------------------------------
 *
 *	"IExchangeFavorites" Interface Declaration
 *
 *	Used for adding or removing favorite folders from the public store.
 *	This interface is obtained by calling QueryInterface on the folder
 *	whose EntryID is specified by PR_IPM_FAVORITES_ENTRYID on the public
 *	store.
 *
 *-----------------------------------------------------------------------*/

#define EXCHANGE_IEXCHANGEFAVORITES_METHODS(IPURE)						\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(AddFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\
	MAPIMETHOD(DelFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IExchangeFavorites
DECLARE_MAPI_INTERFACE_(IExchangeFavorites, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	EXCHANGE_IEXCHANGEFAVORITES_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IExchangeFavorites,	LPEXCHANGEFAVORITES);


/*------------------------------------------------------------------------
 *
 *	Properties used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/
											  
#define PR_OFFLINE_FLAGS				PROP_TAG( PT_LONG, pidFolderMin + 0x10)
#define PR_SYNCHRONIZE_FLAGS			PROP_TAG( PT_LONG, pidExchangeNonXmitReservedMin + 0x4)
							

/*------------------------------------------------------------------------
 *
 *	Flags used by the Offline Folders API
 *
 *-----------------------------------------------------------------------*/

#define OF_AVAILABLE_OFFLINE					((ULONG) 0x00000001)
#define OF_FORCE								((ULONG) 0x80000000)

#define SF_DISABLE_STARTUP_SYNC					((ULONG) 0x00000001)


#endif	//EDKMDB_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\handler.cpp ===
// implementation for app specific data
#include <objbase.h>

#include <Mapi.h>
#include <Mapix.h>
#include "MAPIDEFS.H"
#include "EDKMDB.H"
#include "mapispi.h"
#include "mapiform.h"
#include "mdbuix.h"

#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <objbase.h>
#include "SyncHndl.h"
#include "priv.h"
#include "base.h"
#include "handler.h"
#pragma data_seg()

TCHAR szCLSIDDescription[] = TEXT("Outlook OneStop Handler");

typedef struct _tagProfileItem
{
struct _tagProfileItem *pNextProfileItem;
char *profileName; // pointer to profile name, only valid for lifetime of thread
DWORD dwThreadId; // thread that owns the profile.
} ProfileItem;

// global list of Profile items so mail knows what profile it has already done.
ProfileItem *g_pProfileItem = NULL; // pointer to first profile item

extern HINSTANCE g_hmodThisDll; // Handle to this DLL itself.
BOOL g_InCall = FALSE;

// general routine for creating a working thread to make calls on.

DWORD WINAPI WorkerThread( LPVOID lpArg );

// thread creation for PrepareForSync and synchronize, 
// for simplification in Initialize we spin a worker thread and then 
// post all incoming requests to it so don't have to working about
// api we are calling handling multiple threads.

typedef struct _tagWorkerThreadArgs
{
HANDLE hEvent; // Event to wait on for new thread to be created.
HRESULT hr; // return code of thread.
CMailHandler *pThis;
}  WorkerThreadArgs;


HRESULT CreateWorkerThread(DWORD *pdwThreadID,HANDLE *phThread,
			   CMailHandler *pThis)
{
HRESULT hr = E_FAIL;
HANDLE hNewThread = NULL;
WorkerThreadArgs ThreadArgs;


    *phThread = NULL;

    ThreadArgs.hEvent = CreateEvent(NULL,FALSE,FALSE,NULL);
    ThreadArgs.pThis = pThis;

    if (ThreadArgs.hEvent)
    {
	hNewThread = CreateThread(NULL,0,WorkerThread,&ThreadArgs,0,pdwThreadID);

	if (hNewThread)
	{
	   WaitForSingleObject(ThreadArgs.hEvent,INFINITE);
	   if (NOERROR == ThreadArgs.hr)
	   {
		*phThread = hNewThread;
		hr = NOERROR;
	   }
	   else
	   {
		CloseHandle(hNewThread); 
		hr = ThreadArgs.hr;
	   }

	}
	else
	{
	    hr = GetLastError();
	}

	CloseHandle(ThreadArgs.hEvent);
    }

    return hr;
}

typedef struct _tagArgs
{




} METHODARGS; // list of possible member for calling ThreadWndProc

// definitions for handler messages
#define WM_WORKERMSG_PREPFORSYNC (WM_USER+1)
#define WM_WORKERMSG_SYNCHRONIZE  (WM_USER+2)

#define DWL_THREADWNDPROCCLASS 0 // window long offset to MsgService Hwnd this ptr.

// WndProc for Worker thread
LRESULT CALLBACK  MsgThreadWndProc(HWND hWnd,UINT msg,WPARAM wParam,LPARAM lParam)
{
CMailHandler *pThis = (CMailHandler *) GetWindowLong(hWnd, DWL_THREADWNDPROCCLASS);

    switch (msg)
    {
	case WM_CREATE :
	    {
	    CREATESTRUCT *pCreateStruct = (CREATESTRUCT *) lParam;

	    SetWindowLong(hWnd, DWL_THREADWNDPROCCLASS,(LONG) pCreateStruct->lpCreateParams );
	    pThis = (CMailHandler *) pCreateStruct->lpCreateParams ;
	    }
	    break;
	case WM_DESTROY:
	    PostQuitMessage(0); // shut down this thread.
	    break;
	case WM_WORKERMSG_PREPFORSYNC:
	    pThis->PrepareForSyncCall();
	    break;
	case WM_WORKERMSG_SYNCHRONIZE:
	    pThis->SynchronizeCall();
	    break;
	default:
	    break;
    }

    return DefWindowProc(hWnd, msg, wParam, lParam);
}


DWORD WINAPI WorkerThread( LPVOID lpArg )
{
MSG msg;
HRESULT hr;
HRESULT hrCoInitialize;
WorkerThreadArgs *pThreadArgs = (WorkerThreadArgs *) lpArg;

				
   pThreadArgs->hr = NOERROR;

   hrCoInitialize = CoInitialize(NULL);

   // need to do a PeekMessage and then set an event to make sure
   // a message loop is created before the first PostMessage is sent.

   PeekMessage(&msg, NULL, WM_USER, WM_USER, PM_NOREMOVE);

   // initialize the dialog box before returning to main thread.
   if (FAILED(hrCoInitialize) )
   {
	pThreadArgs->hr = E_OUTOFMEMORY;
   }
   else
   {
    ATOM aWndClass;
    WNDCLASS        xClass;


	// Register windows class.we need for handling thread communication
	xClass.style         = 0;
	xClass.lpfnWndProc   = MsgThreadWndProc;
	xClass.cbClsExtra    = 0;

	xClass.cbWndExtra    = sizeof(DWORD); // room for class this ptr
	xClass.hInstance     = g_hmodThisDll;
	xClass.hIcon         = NULL;
	xClass.hCursor       = NULL;
	xClass.hbrBackground = (HBRUSH) (COLOR_BACKGROUND + 1);
	xClass.lpszMenuName  = NULL;
	xClass.lpszClassName = "OutlookHandlerClass";

	aWndClass = RegisterClass( &xClass );


	pThreadArgs->pThis->m_hwnd = CreateWindowEx(0,
			  "OutlookHandlerClass",
			  TEXT(""),
			  // must use WS_POPUP so the window does not get
			  // assigned a hot key by user.
			  (WS_DISABLED | WS_POPUP),
			  CW_USEDEFAULT,
			  CW_USEDEFAULT,
			  CW_USEDEFAULT,
			  CW_USEDEFAULT,
			  NULL, // REVIEW, can we give it a parent to not show up.
			  NULL,
			  g_hmodThisDll,
			  pThreadArgs->pThis);

	pThreadArgs->hr =  pThreadArgs->pThis->m_hwnd ? NOERROR : E_UNEXPECTED;
    }

   hr = pThreadArgs->hr;

   // let the caller know the thread is done initializing.
   if (pThreadArgs->hEvent)
     SetEvent(pThreadArgs->hEvent);




   if (NOERROR == hr)
   {
       // sit in loop receiving messages.
       while (GetMessage(&msg, NULL, 0, 0)) 
       {
	     TranslateMessage(&msg);
	     DispatchMessage(&msg);
	}
   }

   if (SUCCEEDED(hrCoInitialize))
       CoUninitialize();

   return 0;
}





COneStopHandler* CreateHandlerObject()
{
    g_InCall = FALSE;
    return new CMailHandler();
}


STDMETHODIMP CMailHandler::DestroyHandler()
{
    
    if (g_InCall)
    {
	// MessageBox(NULL,"UNINIT","",1);
    }

    if (m_fMapiInitialized)
    {
	m_fMapiInitialized = FALSE;
	MAPIUninitialize();
    }

    delete this;
    return NOERROR;
}


CMailHandler::CMailHandler()
{
    m_fMapiInitialized = FALSE;
    m_dwSyncFlags = 0;
    m_hwnd = FALSE;

    m_fInPrepareForSync = FALSE;
    m_fInSynchronize = FALSE;
    m_pCurHandlerItem = NULL;
}

CMailHandler::~CMailHandler()
{

}


STDMETHODIMP CMailHandler::Initialize(DWORD dwReserved,DWORD dwSyncFlags,
					DWORD cbCookie,const BYTE *lpCooke)
{
HRESULT hr = NOERROR; // if already initialized just return NOERROR;
DWORD pThreadID;
HANDLE phThread;

    m_dwSyncFlags = dwSyncFlags;
    InitializeCriticalSection(&m_CriticalSection);

    // create workerthread
    if (hr = (NOERROR == CreateWorkerThread(&pThreadID,&phThread,
		       this))) 
    {

	if (FALSE == m_fMapiInitialized)
	{
	MAPIINIT_0 mapiInit;

		mapiInit.ulVersion  = MAPI_INIT_VERSION;
		mapiInit.ulFlags  = MAPI_MULTITHREAD_NOTIFICATIONS;

		if (NOERROR == (hr = MAPIInitialize( 0 /* &mapiInit) */) ) )
		{
			m_fMapiInitialized = TRUE;

			// if mapi was initialized, go ahead and get profile stuff.
			hr = GetProfileInformation();
		}
	}
    

    }


    return hr;
}

STDMETHODIMP CMailHandler::GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo)
{
    
    return E_NOTIMPL;
}

HRESULT CMailHandler::GetProfileInformation()
{
DWORD dwProfileCount = 0;
LPSYNCMGRHANDLERITEMS pOfflineItemsHolder;
LPHANDLERITEM pOfflineItem;
HRESULT hr;
LPPROFADMIN pProfAdmin;

    hr = MAPIAdminProfiles(0,&pProfAdmin);

    if (NOERROR == hr)
    {
    LPMAPITABLE pMapiTable;
    
	if (NOERROR == pProfAdmin->GetProfileTable(0,&pMapiTable))
	{
	LPSRowSet pRows;

	     SizedSPropTagArray(1, taga) = { 1, { PR_DISPLAY_NAME } };

	     if (NOERROR == pMapiTable->SetColumns((LPSPropTagArray)&taga, TBL_BATCH) )
	     {

		 while (NOERROR == pMapiTable->QueryRows(1,0,&pRows)
				&& (pRows->cRows > 0) )
		 {

			if (NULL == (pOfflineItemsHolder = GetOfflineItemsHolder()) )
			{  // if first item, set up the enumerator.
				pOfflineItemsHolder = CreateOfflineHandlerItemsList();

				// if still NULL, break out of loop
				if (NULL == pOfflineItemsHolder)
					break;

				SetOfflineItemsHolder(pOfflineItemsHolder);
			}

			// add the item to the list.
			if (pOfflineItem = (LPHANDLERITEM) AddOfflineItemToList(pOfflineItemsHolder,sizeof(HANDLERITEM) ))
			{
			char *pszProfileName = pRows->aRow[0].lpProps[0].Value.lpszA;
			SYNCMGRITEMID offType;

				pOfflineItem->pmdbx = NULL;
				pOfflineItem->lpSession = NULL;
				pOfflineItem->fItemCompleted = FALSE;
				memcpy(pOfflineItem->szProfileName,pszProfileName,
						strlen(pszProfileName) + 1);
				
				// add outlook specific data
				pOfflineItem->baseItem.offlineItem.cbSize = sizeof(SYNCMGRITEM);

				// review, for now just generate a new guid
				CoCreateGuid(&offType);


				pOfflineItem->baseItem.offlineItem.ItemID = offType;
//				pOfflineItem->baseItem.offlineItem.dwItemID = dwProfileCount + 1;
				pOfflineItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
			
				pOfflineItem->baseItem.offlineItem.hIcon = 
							LoadIcon(g_hmodThisDll,MAKEINTRESOURCE(IDI_IOUTLOOK));
				pOfflineItem->baseItem.offlineItem.dwFlags = 0L;

				// for now, just use the path as the description
				// need to change this.

				// if we are not already unicode, have to convert now
				#ifndef UNICODE
					MultiByteToWideChar(CP_ACP,0,pszProfileName,-1,
								pOfflineItem->baseItem.offlineItem.wszItemName,MAX_SYNCMGRITEMNAME);
				#else

					// bug, can overrun buffer big time.
					// already unicode, just copy it in.
					memcpy(pOfflineItem->baseItem.offlineItem.wszItemName,
							pszProfileName,strlen(pszProfileName) + 1); 


				#endif // UNICODE

				GetItemIdForHandlerItem(CLSID_OneStopHandler,pOfflineItem->baseItem.offlineItem.wszItemName,
					    &pOfflineItem->baseItem.offlineItem.ItemID,TRUE);

				// don't do anything on the status for now.
				// pOfflineItem->offlineItem.wszStatus = NULL;

				++dwProfileCount; // increment the briefcase count.
			}

			MAPIFreeBuffer(pRows);

		     }
	     }

		pMapiTable->Release();
	}

	pProfAdmin->Release();
    }


    return dwProfileCount ? S_OK : S_FALSE; 
}


STDMETHODIMP CMailHandler::PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
							HWND hWndParent,DWORD dwReserved)

{
LPMAPITABLE     ptbl    = NULL;
LPSRowSet	prs	= NULL;
LPMDB		pmdb	= NULL;
LPSPropValue	pval	= NULL;
LPHANDLERITEM	pHandlerItem;

HRESULT hr = E_FAIL;
LPSYNCMGRSYNCHRONIZECALLBACK pOfflineSynchronizeCallback = GetOfflineSynchronizeCallback();
SYNCMGRPROGRESSITEM progItem;

	pHandlerItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;
	
	if (m_fMapiInitialized)
	{
	    // loop through items setting state based on PrepareForSyncSettings

	    for ( ; pHandlerItem; pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem)
	    {
	    ULONG NumItemsCount = cbNumItems;
	    SYNCMGRITEMID *pCurItemID = pItemIDs;


		// see if item has been specified to sync, if not, update the state
		// to reflect this else go ahead and prepare.
		
		pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

		while (NumItemsCount--)
		{
		    if (IsEqualGUID(*pCurItemID,pHandlerItem->baseItem.offlineItem.ItemID))
		    {
			pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;
			break;
		    }

		    ++pCurItemID;
		}
	    }

	    // we have now set the information. Call worker function
	    // on second thread to do the actual work.

	    m_hwndParent = hWndParent;
	    m_fInPrepareForSync = TRUE;

            //  should really be posting message so can return from call immediately
	     PrepareForSyncCall();

	}
	else
	{
	    progItem.mask = SYNCMGRPROGRESSITEM_STATUSTEXT | SYNCMGRPROGRESSITEM_STATUSTYPE ;	    progItem.lpcStatusText = L"Connecting to Server";

	    progItem.dwStatusType = SYNCMGRSTATUS_FAILED;
	    progItem.lpcStatusText = L"Could Not Initialize MAPI";


	    // applies to all items

	    while (pHandlerItem)
	    {
		if (pOfflineSynchronizeCallback)
		{
			pOfflineSynchronizeCallback->Progress(
			    (pHandlerItem->baseItem.offlineItem.ItemID)
								,&progItem);
		}

		pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem;

	    }

	    return E_FAIL;
	}

    return NOERROR;
}

// called on worker thread
void CMailHandler::PrepareForSyncCall()
{
LPMAPITABLE     ptbl    = NULL;
LPSRowSet	prs	= NULL;
LPMDB		pmdb	= NULL;
SRestriction	res;
SPropValue	val;
LPSPropValue	pval	= NULL;
LPHANDLERITEM	pHandlerItem;
SYNCMGRITEMID ItemID;

HRESULT hr = E_FAIL;
LPSYNCMGRSYNCHRONIZECALLBACK pOfflineSynchronizeCallback = GetOfflineSynchronizeCallback();
SYNCMGRPROGRESSITEM progItem;

// take critical section except for when calling MapiLogon
// if a setitemStatus comes in can wait for this to complete
// or kill handler after so long.

    EnterCriticalSection(&m_CriticalSection);

    pHandlerItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;

    for ( ; pHandlerItem; pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem)
    {
    char *pname = pHandlerItem->szProfileName;

	if (pHandlerItem->baseItem.offlineItem.dwItemState == SYNCMGRITEMSTATE_CHECKED)
	{
	ProfileItem *pCurItem;
	BOOL fFoundMatch = FALSE;
	DWORD dwLogonFlags;
	    
	    // if item is already in the list then continue, else
	    // add the profile name to the list

	    pCurItem = g_pProfileItem;
	    while (pCurItem)
	    {
		if (0 == strcmp(pCurItem->profileName,pHandlerItem->szProfileName))
		{
		    fFoundMatch = TRUE;
		    break;
		}

		pCurItem = pCurItem->pNextProfileItem;
	    }
	    
	    if (fFoundMatch)
		continue;

	    // didn't find a match so go ahead and add this one.
	    pCurItem = (ProfileItem*) CoTaskMemAlloc(sizeof(ProfileItem));

	    if (pCurItem)
	    {	
		pCurItem->profileName = pHandlerItem->szProfileName;
		pCurItem->dwThreadId = GetCurrentThreadId();

		pCurItem->pNextProfileItem = g_pProfileItem;
		g_pProfileItem = pCurItem;
	    }

	
	    pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED;

	    ItemID = pHandlerItem->baseItem.offlineItem.ItemID;
	    progItem.mask = SYNCMGRPROGRESSITEM_STATUSTEXT | SYNCMGRPROGRESSITEM_STATUSTYPE ;
	    progItem.lpcStatusText = L"Connecting to Server";
		progItem.dwStatusType = SYNCMGRSTATUS_PENDING;
		
	    if (pOfflineSynchronizeCallback)
		    pOfflineSynchronizeCallback->Progress(ItemID,&progItem); 

	    dwLogonFlags = MAPI_EXTENDED | MAPI_TIMEOUT_SHORT 
			    | MAPI_NEW_SESSION | MAPI_NO_MAIL;

	    if (SYNCMGRFLAG_MAYBOTHERUSER & m_dwSyncFlags)
	    {
		   dwLogonFlags |= MAPI_LOGON_UI;
	    }

	    m_pCurHandlerItem = pHandlerItem; // set handler item
	    LPMAPISESSION lpSession; // mapi logon session for this item.

	    LeaveCriticalSection(&m_CriticalSection);

	    if (NOERROR != (hr =  MAPILogonEx( (DWORD) m_hwndParent,
				    pname,NULL,
					     dwLogonFlags ,&lpSession)) )
	    {
		    
		    EnterCriticalSection(&m_CriticalSection); 

		    // if a SetItemStatus came in while logon then don't
		    // change the progress.

		    if (!pHandlerItem->fItemCompleted)
		    {
			progItem.mask |= SYNCMGRPROGRESSITEM_PROGVALUE
					    | SYNCMGRPROGRESSITEM_MAXVALUE;

			progItem.iProgValue = 1;
			progItem.iMaxValue = 1;
			progItem.lpcStatusText = L"Unable to Logon to Server";
			progItem.dwStatusType = SYNCMGRSTATUS_FAILED;
			    
			if (pOfflineSynchronizeCallback)
				pOfflineSynchronizeCallback->Progress(ItemID,&progItem);
		    }

		    continue;
	    }

	    
	    EnterCriticalSection(&m_CriticalSection); 

	    // if setitemstate came in during logon just release session
	    if (pHandlerItem->fItemCompleted)
	    {
		if (lpSession)
		    lpSession->Release();
		continue;
	    }

	    pHandlerItem->lpSession = lpSession;

	    // now make sure that there is a valid message store and we
	    // are connected to a remote server.
	    // Find the MessageStore
	    SizedSPropTagArray(2, taga) = { 2, { PR_ENTRYID, PR_MDB_PROVIDER } };

	    hr = pHandlerItem->lpSession->GetMsgStoresTable(0, &ptbl);
	    if (HR_FAILED(hr))
	    {
		    ptbl->Release();
		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;
		    continue;
	    }

	    hr = ptbl->SetColumns((LPSPropTagArray)&taga, TBL_BATCH);
	    if (HR_FAILED(hr))
	    {
		    ptbl->Release();
		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;
		    continue;
	    }

	    res.rt				= RES_PROPERTY;
	    res.res.resProperty.relop	= RELOP_EQ;
	    res.res.resProperty.lpProp	= &val;
	    res.res.resProperty.ulPropTag	= PR_MDB_PROVIDER;
	    val.ulPropTag			= PR_MDB_PROVIDER;
	    val.Value.bin.cb		= sizeof(MAPIUID);
	    val.Value.bin.lpb		= (LPBYTE)pbExchangeProviderPrimaryUserGuid;

	    hr = ptbl->FindRow(&res, BOOKMARK_BEGINNING, 0);
	    if (HR_FAILED(hr))
	    {
		    ptbl->Release();
		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;

		    continue;
	    }

	    hr = ptbl->QueryRows(1, 0, &prs);

	    ptbl->Release(); // All done with MapiTable Object.
	    ptbl = NULL;

	    if (HR_FAILED(hr))
	    {
		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;

		    continue;
	    }

	    if (prs->cRows == 0)
	    {
		    hr = ResultFromScode(MAPI_E_NOT_FOUND);

		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;

		    continue;
	    }


	    hr = pHandlerItem->lpSession->OpenMsgStore(0, prs->aRow[0].lpProps[0].Value.bin.cb,
			    (LPENTRYID)prs->aRow[0].lpProps[0].Value.bin.lpb, NULL,
			    MAPI_DEFERRED_ERRORS | MDB_TEMPORARY | MDB_NO_MAIL | MDB_WRITE,
			    &pmdb);

	    if (HR_FAILED(hr))
	    {
		pHandlerItem->lpSession->Release();
		pHandlerItem->lpSession = NULL;
		continue;;
	    }


	    // If offline then don't try to sync anything.
	    hr = HrGetOneProp((LPMAPIPROP) pmdb, PR_STATUS_CODE, &pval);

	    // Review - this returns a success code but indicates couldn't
	    //    get all the information.
	    if (HR_FAILED(hr))
	    {
		    pmdb->Release();

		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;

		    continue;
	    }

	    ULONG ulStatus = pval->Value.ul;
	    MAPIFreeBuffer(pval);

	    if (ulStatus & STATUS_OFFLINE)
	    {

		    progItem.mask |= SYNCMGRPROGRESSITEM_PROGVALUE
					| SYNCMGRPROGRESSITEM_MAXVALUE;

		    progItem.iProgValue = 1;
		    progItem.iMaxValue = 1;
		    progItem.lpcStatusText = L"Mail is Offline";
		    progItem.dwStatusType = SYNCMGRSTATUS_FAILED;

		    if (pOfflineSynchronizeCallback)
			    pOfflineSynchronizeCallback->Progress(ItemID,&progItem);


		    pmdb->Release();

		    pHandlerItem->lpSession->Release();
		    pHandlerItem->lpSession = NULL;

		    continue;
	    }


	    hr = pmdb->QueryInterface(IID_IMDBX, (LPVOID *)&pHandlerItem->pmdbx);

	    pmdb->Release(); 
	    pmdb = NULL; 

	    if (FAILED(hr))
	    {
		pHandlerItem->lpSession->Release();
		pHandlerItem->lpSession = NULL;
		pHandlerItem->pmdbx = NULL;
		continue;	
	    }

	    progItem.lpcStatusText = L"Connected to Server";

	    if (pOfflineSynchronizeCallback)
		    pOfflineSynchronizeCallback->Progress(ItemID,&progItem);
	}

    }

    m_fInPrepareForSync = FALSE;
    m_pCurHandlerItem = NULL;

    LeaveCriticalSection(&m_CriticalSection);

    // let caller know we are done preparing.
    if (pOfflineSynchronizeCallback)
	    pOfflineSynchronizeCallback->PrepareForSyncCompleted(NOERROR);

}

STDMETHODIMP CMailHandler::Synchronize(HWND hwnd)
{
    // set up hwnd then call syncrhonize on the worker thread
    m_hwndParent = hwnd;
    m_fInSynchronize = TRUE;
    m_pCurHandlerItem = NULL;

    // should be posting this so can return immediately but seem to be some mapi problems switching thread?
   // PostMessage(m_hwnd,WM_WORKERMSG_SYNCHRONIZE,0,0);

   SynchronizeCall();

    return NOERROR;
}

// called on worker thread
void CMailHandler::SynchronizeCall()
{
STDPROG			stdprog;
ULONG			ulFlags;
HRESULT			hr;
LPHANDLERITEM		pHandlerItem;
SYNCMGRITEMID		ItemID;
LPSYNCMGRSYNCHRONIZECALLBACK pOfflineSynchronizeCallback = GetOfflineSynchronizeCallback();


// stay in critical section except in synchronize out call.

    EnterCriticalSection(&m_CriticalSection);

    pHandlerItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;

    for ( ; pHandlerItem; pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem)
    {

	ItemID = pHandlerItem->baseItem.offlineItem.ItemID;

	if (NULL == pHandlerItem->pmdbx 
		    || SYNCMGRITEMSTATE_UNCHECKED == pHandlerItem->baseItem.offlineItem.dwItemState)
	{
	     if (pHandlerItem->lpSession)
	     {
		pHandlerItem->lpSession->Release();
		pHandlerItem->lpSession = NULL;
	     }

	     continue;

	}

	// point to folder if only want to synchronize a single folder.
	ULONG cbEntryID = 0;
	LPENTRYID lpEntryID = 0;
	
	ulFlags = SYNC_OUTGOING_MAIL |
			SYNC_UPLOAD_HIERARCHY | SYNC_DOWNLOAD_HIERARCHY |
			SYNC_UPLOAD_FAVORITES | SYNC_DOWNLOAD_FAVORITES |
			SYNC_UPLOAD_VIEWS	  | SYNC_DOWNLOAD_VIEWS |
			SYNC_UPLOAD_CONTENTS  | SYNC_DOWNLOAD_CONTENTS 
			| SYNC_FORMS ;

	stdprog.hwndParent = NULL;
	stdprog.nProgCur = 0;
	stdprog.nProgMax = 100;
	stdprog.idAVI = 0;
	stdprog.szCaption = NULL;
	stdprog.ulFlags = 0;

	stdprog.hwndDlg = NULL;
	stdprog.fCancelled = FALSE;
	
	stdprog.dwStartTime = GetTickCount();
	stdprog.dwShowTime = 0;
	stdprog.hcursor = (HCURSOR) &ItemID; // overload teh hCursor with the itemID
	stdprog.wndprocCancel = (WNDPROC) GetOfflineSynchronizeCallback(); // overload wndprocCancel for Progress

	LPMAPISESSION lpSession = pHandlerItem->lpSession;

	m_fInSynchronize = FALSE;
	m_pCurHandlerItem = pHandlerItem;

	LeaveCriticalSection(&m_CriticalSection);

	hr = pHandlerItem->pmdbx->Synchronize(ulFlags,lpSession, 
			cbEntryID, lpEntryID, &stdprog,
			ProgressUpdate,
			(GETFORMMSGPROC)FormGetFormMessage);

	EnterCriticalSection(&m_CriticalSection);

	// Update the Progress Bar to complete status.
	if (NOERROR == hr)
	{
	SYNCMGRPROGRESSITEM progItem;

		progItem.mask = SYNCMGRPROGRESSITEM_STATUSTEXT
							    | SYNCMGRPROGRESSITEM_STATUSTYPE
							| SYNCMGRPROGRESSITEM_PROGVALUE
							| SYNCMGRPROGRESSITEM_MAXVALUE;

		progItem.iProgValue  = stdprog.nProgCur;
		progItem.iMaxValue = stdprog.nProgMax;

		if (stdprog.fCancelled == FALSE)
		{
			    progItem.dwStatusType = SYNCMGRSTATUS_SUCCEEDED;
			progItem.lpcStatusText = L"Update Completed Successfully";

			GetOfflineSynchronizeCallback()->Progress(ItemID,&progItem);
		}
		else
		{	progItem.dwStatusType =  SYNCMGRSTATUS_SKIPPED;
			progItem.lpcStatusText = L"";
			GetOfflineSynchronizeCallback()->Progress(ItemID,&progItem);
		}
	}
	else
	{
		    SYNCMGRPROGRESSITEM progItem;

		progItem.mask = SYNCMGRPROGRESSITEM_STATUSTEXT
							    | SYNCMGRPROGRESSITEM_STATUSTYPE
							| SYNCMGRPROGRESSITEM_PROGVALUE
							| SYNCMGRPROGRESSITEM_MAXVALUE;

		progItem.iProgValue  = stdprog.nProgCur;
		progItem.iMaxValue = stdprog.nProgMax;

		if (stdprog.fCancelled == FALSE)
		{
		    progItem.dwStatusType =  SYNCMGRSTATUS_FAILED;				
			progItem.lpcStatusText = L"Errors Occured";

		    GetOfflineSynchronizeCallback()->Progress(ItemID,&progItem);

		    //Log Errors
		    SYNCMGRLOGERRORINFO errorItem;
		    errorItem.mask = NULL;

		    //Log warning: One without more info
		    GetOfflineSynchronizeCallback()->LogError(SYNCMGRLOGLEVEL_WARNING,
							    L"Outlook had a warning occur.",
                                                            &errorItem);

		    errorItem.mask |= SYNCMGRLOGERROR_ERRORFLAGS;
		    errorItem.dwSyncMgrErrorFlags = SYNCMGRERRORFLAG_ENABLEJUMPTEXT ;

		    errorItem.mask |= SYNCMGRLOGERROR_ERRORID;
		    errorItem.ErrorID = CLSID_OneStopHandler ;

		    //Log error: One with more info
		    GetOfflineSynchronizeCallback()->LogError(SYNCMGRLOGLEVEL_ERROR,
							    L"Outlook had an error occur.",
							    &errorItem);

		    errorItem.ErrorID = IID_IMDBX;
		    //Log information: One with more info
		    GetOfflineSynchronizeCallback()->LogError(SYNCMGRLOGLEVEL_INFORMATION,
							    L"Outlook had lengthy informational log entry that was quite verbose and wordy, chalk full of needless verbage and diatribe, that the user will never spend any time reading because it was simply too long.",
							    &errorItem);

                    // now delete thsm
                    //GetOfflineSynchronizeCallback()->DeleteLogError(CLSID_OneStopHandler,0);
		}
	}

	pHandlerItem->fItemCompleted = TRUE;

	if (pHandlerItem->pmdbx)
	{
	    pHandlerItem->pmdbx->Release();
	    pHandlerItem->pmdbx = NULL; 
	}

	if (pHandlerItem->lpSession)
	{
	    pHandlerItem->lpSession->Release(); 
	    pHandlerItem->lpSession = NULL;
	}

	// when the synchronize is done it is okay to open a new session
	// to the same profile

	ProfileItem *pCurItem;
	ProfileItem profItemDummy;
	BOOL fFoundMatch = FALSE;
		
	// if item is already in the list then continue, else
	// add the profile name to the list

	profItemDummy.pNextProfileItem = g_pProfileItem;
	pCurItem = &profItemDummy;

	while (pCurItem->pNextProfileItem)
	{
	    if (0 == strcmp(pCurItem->pNextProfileItem->profileName,pHandlerItem->szProfileName))
	    {
	    ProfileItem *pMatch;

		pMatch = pCurItem->pNextProfileItem;
		pCurItem->pNextProfileItem = pMatch->pNextProfileItem;

		g_pProfileItem = profItemDummy.pNextProfileItem;
		CoTaskMemFree(pMatch);
		break;
	    }

	    pCurItem = pCurItem->pNextProfileItem;
	}
	


    }


    m_fInSynchronize = FALSE;
    m_pCurHandlerItem = NULL;

    LeaveCriticalSection(&m_CriticalSection);

    if (pOfflineSynchronizeCallback)
    {
	pOfflineSynchronizeCallback->SynchronizeCompleted(NOERROR);
    }



}




STDMETHODIMP CMailHandler::SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus)
{
LPHANDLERITEM pHandlerItem;
LPSYNCMGRSYNCHRONIZECALLBACK pOfflineSynchronizeCallback = GetOfflineSynchronizeCallback();
SYNCMGRPROGRESSITEM progItem;

    // m_pCurHandlerItem

    // either called before start PrepareForSync
    // in PrepareForsync
    // BetweenPrepareForSync and Synchronize
    // in synchronize
    // after synchronize.

    // 	pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

    progItem.mask = SYNCMGRPROGRESSITEM_STATUSTYPE
					| SYNCMGRPROGRESSITEM_PROGVALUE
					| SYNCMGRPROGRESSITEM_MAXVALUE;

    progItem.iProgValue  = 10;
    progItem.iMaxValue = 10;
    progItem.dwStatusType = SYNCMGRSTATUS_SKIPPED;


    EnterCriticalSection(&m_CriticalSection);

    // find the HandlerItem associated with the ItemID.
    pHandlerItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;
	
    for ( ; pHandlerItem; pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem)
    {
	if (IsEqualGUID(ItemID,(pHandlerItem->baseItem.offlineItem.ItemID)))
	{
	    break;
	}

    }

    // if item isn't complete try to stop it.
    if (pHandlerItem && !pHandlerItem->fItemCompleted)
    {

	// if the curItem isn't set then nothing is currently going on
	// with this item. If this is the case then just clean
	// it up and set the progress accordingly

	if (pHandlerItem != m_pCurHandlerItem)
	{
	    pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_UNCHECKED;

	    if (pHandlerItem->pmdbx)
	    {
		pHandlerItem->pmdbx->Release();
		pHandlerItem->pmdbx = NULL;
	    }   
	    
	    if (pHandlerItem->lpSession)
	    {
		pHandlerItem->lpSession->Release();
		pHandlerItem->lpSession = NULL;
	    }

	    pHandlerItem->fItemCompleted = TRUE;

	    if (pOfflineSynchronizeCallback)
		pOfflineSynchronizeCallback->Progress(ItemID,&progItem);

	}
	else
	{
	    // call is currently working on this item so just
	    // wait for now until the item finishes
	    // should rely wait and if doesn't abort after so long kill
	    
	    // if this is a prepareforsync set itemcomplted to true 
	    // and set the callback

	    if (m_fInPrepareForSync)
	    {
		pHandlerItem->fItemCompleted = TRUE;

		if (pOfflineSynchronizeCallback)
		    pOfflineSynchronizeCallback->Progress(ItemID,&progItem);
	    }



	}


    }

    LeaveCriticalSection(&m_CriticalSection);

    return NOERROR;
}


STDMETHODIMP CMailHandler::ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID)
{
#if _IMPL
	// Can show any synchronization conflicts. Also gives a chance
	// to display any errors that occured during synchronization

	if (SYNCMGRFLAG_MAYBOTHERUSER & m_dwSyncFlags)
	{
		// can show any conflicts or errors that occured.

	}


        // FOR RETRYSYNC TEST FIND FIRST CHECKED ITEMid AND SET THIS

        LPHANDLERITEM pHandlerItem;

        pHandlerItem = (LPHANDLERITEM) GetOfflineItemsHolder()->pFirstOfflineItem;
	
	for ( ; pHandlerItem; pHandlerItem = (LPHANDLERITEM) pHandlerItem->baseItem.pNextOfflineItem)
	{
	    // see if item has been specified to sync, if not, update the state
	    // to reflect this else go ahead and prepare.
	    
	    if (pHandlerItem->baseItem.offlineItem.dwItemState = SYNCMGRITEMSTATE_CHECKED)
            {
                break;
            }

        }

    if (pHandlerItem)
    {
        *ppItemIDs = (SYNCMGRITEMID *) CoTaskMemAlloc(sizeof(SYNCMGRITEMID));
        *ppItemIDs[0] = pHandlerItem->baseItem.offlineItem.ItemID;
        *pcbNumItems = 1;
    }

#endif // _IMPL

  return E_NOTIMPL;
  //  return *pcbNumItems ? S_SYNCMGR_RETRYSYNC : 
}



// Help functions and callbacks

VOID CALLBACK ProgressUpdate(STDPROG *stg, LPSTR lpcStatusText, INT iCurValue, INT iMaxValue)
{
HRESULT hr;
ISyncMgrSynchronizeCallback *lpCallBack = 	(ISyncMgrSynchronizeCallback *) stg->wndprocCancel;
SYNCMGRITEMID* pItemID = (SYNCMGRITEMID *) stg->hcursor;
WCHAR StatusBuf[256];
DWORD dwoffset = 0;

	// status text we get back states "Synchronizing Folder 'inbox', 
	// we always want to wack off the Synchronizing

#ifdef _TRUNCATESTATUS
	if (lpcStatusText && (0 == strnicmp("Synchronizing ",lpcStatusText,sizeof("Synchronizing"))) )
	{
		dwoffset = sizeof("Synchronizing");
	}
#endif // _TRUNCATESTATUS

	
	if (0 ==  MultiByteToWideChar(CP_ACP,0,lpcStatusText + dwoffset,-1,
				StatusBuf,256))
	{
		*StatusBuf = L'\0';

	}


	stg->nProgCur = iCurValue;
	stg->nProgMax = iMaxValue;

	// now estimate the time remaining

	DWORD dwElapsed = GetTickCount() - 	stg->dwStartTime;
	DWORD dwTicksRemaining = 0;

	if (0 != iCurValue)
	{
		dwTicksRemaining = ((iMaxValue - iCurValue) * dwElapsed)/iCurValue;
	}

	SYNCMGRPROGRESSITEM progItem;

	progItem.mask = SYNCMGRPROGRESSITEM_STATUSTEXT
						| SYNCMGRPROGRESSITEM_STATUSTYPE
						| SYNCMGRPROGRESSITEM_PROGVALUE
						| SYNCMGRPROGRESSITEM_MAXVALUE;

	progItem.iProgValue  = iCurValue;
	progItem.iMaxValue = iMaxValue;
	progItem.lpcStatusText = StatusBuf;
	progItem.dwStatusType = SYNCMGRSTATUS_UPDATING;
	
	hr = lpCallBack->Progress(*pItemID,&progItem);


	if (S_SYNCMGR_CANCELITEM == hr || S_SYNCMGR_CANCELALL == hr)
	{ 
		stg->fCancelled = TRUE; // Stop the Transfer.
	}

}

extern "C" HRESULT FormGetFormMessage(LPMAPIFORMINFO pinfo, ULONG FAR *pulReg,
					LPSTR lpcClass, LPMESSAGE FAR *ppmsg); // in IFRMREGU.CPP

// Review, implementation in ifrmregu.cpp
HRESULT FormGetFormMessage(LPMAPIFORMINFO, ULONG FAR *,
                           LPSTR, LPMESSAGE FAR *)
{
    return ResultFromScode(MAPI_E_CALL_FAILED);
}





HRESULT HrGetOneProp(LPMAPIPROP lpIProp, ULONG ulTag, LPSPropValue* lppProp)
{
    SizedSPropTagArray(1,ptag) = {1, {ulTag}};
    ULONG   ulT;

    *lppProp = NULL;

    return lpIProp->GetProps((LPSPropTagArray)&ptag,0, &ulT, lppProp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\priv.h ===
//--------------------------------------------------------------
// common user interface routines
//
//
//--------------------------------------------------------------

#ifndef STRICT
#define STRICT
#endif

#define INC_OLE2        // WIN32, get ole2 from windows.h

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>


#include "mobsync.h"


#define ResultFromShort(i)  ResultFromScode(MAKE_SCODE(SEVERITY_SUCCESS, 0, (USHORT)(i)))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\handler.h ===
// header file for handler specific items

#ifndef _HANDER_IMPL_
#define _HANDER_IMPL_

// DEFINE A NEW CLSID FOR EACH HANDLER
// {97484BA1-26C7-11d1-9A39-0020AFDA97B0}
DEFINE_GUID(CLSID_OneStopHandler,0x97484ba1, 0x26c7, 0x11d1, 0x9a, 0x39, 0x0, 0x20, 0xaf, 0xda, 0x97, 0xb0);

#undef  MDBX_VERSION
#define MDBX_VERSION	0x0c

DEFINE_GUID(IID_IMDBX,0x2F63F100+MDBX_VERSION,0x0A2E,0x11CF,0x9F,0xED,0x00,0xAA,0x00,0xB9,0x2B,0x87);

//DEFINE_OLEGUID(IID_IMAPIProp,       0x00020303, 0, 0);
//DEFINE_OLEGUID(IID_IMAPIStatus,      0x00020305 , 0, 0);


// declarations specific to Mail handler
#include "resource.h"


VOID CALLBACK ProgressUpdate(STDPROG *stg, LPSTR lpcStatusText, INT iCurValue, INT iMaxValue);
extern "C" HRESULT FormGetFormMessage(LPMAPIFORMINFO pinfo, ULONG FAR *pulReg,
					LPSTR lpcClass, LPMESSAGE FAR *ppmsg); // in IFRMREGU.CPP
HRESULT HrGetOneProp(LPMAPIPROP lpIProp, ULONG ulTag, LPSPropValue* lppProp);


// override the OneStopHandler Base class
class CMailHandler :  public COneStopHandler
{
private: 	
	BOOL	m_fMapiInitialized;
	DWORD	m_dwSyncFlags;

public:
    	CMailHandler();
	~CMailHandler();

	STDMETHODIMP DestroyHandler();
	STDMETHODIMP Initialize(DWORD dwReserved,DWORD dwSyncFlags,
			DWORD cbCookie,const BYTE *lpCooke);
	STDMETHODIMP GetHandlerInfo(LPSYNCMGRHANDLERINFO *ppSyncMgrHandlerInfo);
	STDMETHODIMP PrepareForSync(ULONG cbNumItems,SYNCMGRITEMID *pItemIDs,
			HWND hwndParent,DWORD dwReserved);
	STDMETHODIMP Synchronize(HWND hwndParent);
	STDMETHODIMP SetItemStatus(REFSYNCMGRITEMID ItemID,DWORD dwSyncMgrStatus);
	STDMETHODIMP ShowError(HWND hWndParent,REFSYNCMGRERRORID ErrorID);

	// variables added for WorkerThread
	HWND m_hwnd;
	HWND m_hwndParent;
	CRITICAL_SECTION m_CriticalSection;
	BOOL m_fInPrepareForSync;
	BOOL m_fInSynchronize;
	LPHANDLERITEM m_pCurHandlerItem; // set for item that is currently being worked on.

	void PrepareForSyncCall();
	void SynchronizeCall();

private:
	HRESULT GetProfileInformation();

	friend COneStopHandler* CreateHandlerObject();
};

COneStopHandler* CreateHandlerObject();

#endif // #define _HANDER_IMPL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\mapidoc.h ===
// MapiDoc.h : interface of the CMapiDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAPIDOC_H__7BE6AFAB_0840_11D1_9A39_0020AFDA97B0__INCLUDED_)
#define AFX_MAPIDOC_H__7BE6AFAB_0840_11D1_9A39_0020AFDA97B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class CMapiDoc : public CDocument
{
protected: // create from serialization only
	CMapiDoc();
	DECLARE_DYNCREATE(CMapiDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMapiDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMapiDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMapiDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAPIDOC_H__7BE6AFAB_0840_11D1_9A39_0020AFDA97B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\mdbuix.h ===
/*
 * mdbuix.h
 *
 * Private interface between EMSMDB.DLL and EMSUIX.DLL
 *
 * Copyright (C) 1995 Microsoft Corporation
 */

/*
 * This GUID changes when the version changes, disabling access to those who
 * don't have the right version of the header file
 *
 * NOTE:  I've actually generated this GUID from 0x03 to 0x16
 */

#ifdef _ROG_CHANGED

#define MDBX_VERSION	0x0B

DEFINE_GUID(IID_IMDBX,
	0x2F63F100+MDBX_VERSION,0x0A2E,0x11CF,0x9F,0xED,0x00,0xAA,0x00,0xB9,0x2B,0x87);

#endif // _ROGCHANGED

#ifndef __MDBUIX_H_
#define __MDBUIX_H_

#include "wmsuix.h"

typedef BOOL (CALLBACK *CREATEPROC)(STDPROG *);
typedef VOID (CALLBACK *UPDATEPROC)(STDPROG *, LPSTR, INT, INT);
typedef VOID (CALLBACK *DESTROYPROC)(STDPROG *, BOOL);

// To get the message underlying a form
typedef HRESULT (CALLBACK *GETFORMMSGPROC) (LPMAPIFORMINFO, ULONG FAR *,
	LPSTR lpcClass, LPMESSAGE FAR *);

// Flags to the Synchronize method

#define SYNC_UPLOAD_HIERARCHY	0x0001
#define SYNC_DOWNLOAD_HIERARCHY	0x0002
#define SYNC_UPLOAD_FAVORITES	0x0004
#define SYNC_DOWNLOAD_FAVORITES	0x0008
#define SYNC_UPLOAD_VIEWS		0x0010
#define SYNC_DOWNLOAD_VIEWS		0x0020
#define SYNC_UPLOAD_CONTENTS	0x0040
#define SYNC_DOWNLOAD_CONTENTS	0x0080
#define SYNC_ONE_FOLDER			0x0100
#define SYNC_OUTGOING_MAIL		0x0200
#define SYNC_FORMS				0x0400

#define MAPI_IMDBX_METHODS(IPURE)										\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD_(ULONG,GetFolderType)									\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					pbEntryID) IPURE;			\
	MAPIMETHOD(EditFavorites)											\
		(THIS_	LPENTRYLIST					lpEntryList,				\
				BOOL						fAdd) IPURE;				\
	MAPIMETHOD(Synchronize)												\
		(THIS_	ULONG						ulFlags,					\
				LPMAPISESSION				pses,						\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				STDPROG FAR *				lpStdProgress,				\
				UPDATEPROC					lpUpdateProc,				\
				GETFORMMSGPROC				lpFormMsgProc) IPURE;		\
	MAPIMETHOD(OnlineStoreLogon)										\
		(THIS_	LPMSLOGON FAR *				lppMSLogon,					\
				LPMDB FAR *					lppMDB) IPURE;				\
	MAPIMETHOD(DownloadMessage)											\
		(THIS_ 	ULONG						ulFlags,					\
				LPMESSAGE					lpMsgSource,				\
				LPMESSAGE					lpMsgDest)	IPURE;			\
	MAPIMETHOD_(ULONG,GetStoreType)										\
		(THIS) IPURE;													\
	MAPIMETHOD(GetFolderSync)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					pbEntryID,					\
				BOOL						fFull,						\
				FLDSYNC *					pfldsync) IPURE;			\
	MAPIMETHOD(SetFolderSync)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					pbEntryID,					\
				ULONG						cbParEntryID,				\
				LPENTRYID					pbParEntryID,				\
				BOOL						fEnable) IPURE;				\
	MAPIMETHOD(ConfigureOffline)										\
		(THIS_	ULONG						ulUIParam) IPURE;			\
	MAPIMETHOD(DownloadComplete)										\
		(THIS) IPURE;													\
	MAPIMETHOD(TestActiveCount)											\
		(THIS_  ULONG						ulFlags,					\
				ULONG FAR *					pulActiveCount) IPURE;		\
	MAPIMETHOD(GetDCName)												\
		(THIS_	char * szDomainName,									\
		CHAR rgchDomainController[ 16+2 ]) IPURE;						\
	MAPIMETHOD(GetTransferredViewCount)									\
		(THIS_  ULONG						ulFlags,					\
				ULONG FAR *					pulViewCount) IPURE;		\


typedef struct _fldsync
{
	ULONG		ulFlags;
	FILETIME	ftLastSync;
	ULONG		cItemOnline;
	ULONG		cItemOffline;
	ULONG		cbParEntryID;
	BYTE		rgbParEntryID[46];
} FLDSYNC, * PFLDSYNC;

#define FLDSYNC_UNCONFIGURED	0x00000001	// Offline store not configured
#define FLDSYNC_OFFLINE			0x00000002	// Currently viewing offline store
#define FLDSYNC_REPLICATED		0x00000004	// Folder is marked for replication
#define FLDSYNC_NOTFOUND		0x00000008	// Folder doesn't exist offline
#define FLDSYNC_DELETED			0x00000010	// Folder has been deleted offline
#define FLDSYNC_SPECIAL			0x00000020	// Folder is one of special four
#define FLDSYNC_HASMODS			0x00000040	// Offline folder has unsync'd mods

#undef		 INTERFACE
#define		 INTERFACE	IMDBX
DECLARE_MAPI_INTERFACE_(IMDBX, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMDBX_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMDBX, LPMDBX);

#define MDBX_SIG				(0x50554200 + MDBX_VERSION)

// Flags returned from GetFolderType
#define MDBX_FTYPE_UNKNOWN		0
#define MDBX_FTYPE_PUB_IPM		1
#define MDBX_FTYPE_FAV_ROOT		2
#define MDBX_FTYPE_FAV			3
#define MDBX_FTYPE_PUB_ROOT		4
#define MDBX_FTYPE_PUB			5
#define MDBX_FTYPE_PRV_IPM		6
#define MDBX_FTYPE_PRV			7

// Flags returned from GetStoreType
#define MDBX_STORE_OFFLINE		0x80000000		// This is the offline store
#define MDBX_STORE_PUBLIC		0x00000001
#define MDBX_STORE_PRIVATE		0x00000002
#define MDBX_STORE_OST_OPEN		0x40000000		// The OST is open

#ifdef WIN32
#define MDBX_SIG_OFFSET			48
#else
#define MDBX_SIG_OFFSET			44
#endif

#define MDBX_GetSig(_pmdb)	\
	(IsBadWritePtr((_pmdb), MDBX_SIG_OFFSET + sizeof(DWORD)) ? 0 : \
		*(DWORD *)((LPBYTE)(_pmdb) + MDBX_SIG_OFFSET))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\mapiview.h ===
// MapiView.h : interface of the CMapiView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAPIVIEW_H__7BE6AFAD_0840_11D1_9A39_0020AFDA97B0__INCLUDED_)
#define AFX_MAPIVIEW_H__7BE6AFAD_0840_11D1_9A39_0020AFDA97B0__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CMapiView : public CView
{
protected: // create from serialization only
	CMapiView();
	DECLARE_DYNCREATE(CMapiView)

// Attributes
public:
	CMapiDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMapiView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMapiView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMapiView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in MapiView.cpp
inline CMapiDoc* CMapiView::GetDocument()
   { return (CMapiDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAPIVIEW_H__7BE6AFAD_0840_11D1_9A39_0020AFDA97B0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\mapiform.h ===
/*
 *	M A P I F O R M . H
 *
 *	Declarations of interfaces for clients and providers of MAPI
 *  forms and form registries.
 *
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

#ifndef MAPIFORM_H
#define MAPIFORM_H

/* Include common MAPI header files if they haven't been already. */

#ifndef MAPIDEFS_H
#include <mapidefs.h>
#include <mapicode.h>
#include <mapiguid.h>
#include <mapitags.h>
#endif

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

#ifndef _MAC
typedef const RECT FAR *LPCRECT;
#endif

/* HFRMREG is an enumeration which represents a registry container.
 * Microsoft reserves the values from 0 to 0x3FFF for its own use.
 */

typedef ULONG HFRMREG;

#define HFRMREG_DEFAULT  0
#define HFRMREG_LOCAL    1
#define HFRMREG_PERSONAL 2
#define HFRMREG_FOLDER   3

DECLARE_MAPI_INTERFACE_PTR(IPersistMessage, LPPERSISTMESSAGE);
DECLARE_MAPI_INTERFACE_PTR(IMAPIMessageSite, LPMAPIMESSAGESITE);
DECLARE_MAPI_INTERFACE_PTR(IMAPISession, LPMAPISESSION);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewContext, LPMAPIVIEWCONTEXT);
DECLARE_MAPI_INTERFACE_PTR(IMAPIViewAdviseSink, LPMAPIVIEWADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormAdviseSink, LPMAPIFORMADVISESINK);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormInfo, LPMAPIFORMINFO);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormMgr, LPMAPIFORMMGR);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormContainer, LPMAPIFORMCONTAINER);
DECLARE_MAPI_INTERFACE_PTR(IMAPIForm, LPMAPIFORM);
DECLARE_MAPI_INTERFACE_PTR(IMAPIFormFactory, LPMAPIFORMFACTORY);

typedef const char FAR *FAR * LPPCSTR;
typedef LPMAPIFORMINFO FAR *LPPMAPIFORMINFO;

STDAPI MAPIOpenFormMgr(LPMAPISESSION pSession, LPMAPIFORMMGR FAR * ppmgr);
STDAPI MAPIOpenLocalFormContainer(LPMAPIFORMCONTAINER FAR * ppfcnt);


/*-- GetLastError ----------------------------------------------------------*/
/* This defines the GetLastError method held in common by most mapiform
 * interfaces.  It is defined separately so that an implementor may include
 * more than one mapiform interface in a class.
 */

#define MAPI_GETLASTERROR_METHOD(IPURE)                                 \
    MAPIMETHOD(GetLastError) (THIS_                                     \
        /*in*/  HRESULT hResult,                                        \
	/*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIERROR FAR * lppMAPIError) IPURE;                  \


/*-- IPersistMessage -------------------------------------------------------*/
/* This interface is implemented by forms and is used to save,
 * initialize and load forms to and from messages.
 */

#define MAPI_IPERSISTMESSAGE_METHODS(IPURE)                             \
    MAPIMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) IPURE;             \
    MAPIMETHOD(IsDirty)(THIS) IPURE;                                    \
    MAPIMETHOD(InitNew)(THIS_                                           \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(Load)(THIS_                                              \
        /*in*/ LPMAPIMESSAGESITE pMessageSite,                          \
        /*in*/ LPMESSAGE pMessage,                                      \
		/*in*/ ULONG ulMessageStatus,                                   \
		/*in*/ ULONG ulMessageFlags) IPURE;                             \
    MAPIMETHOD(Save)(THIS_                                              \
        /*in*/ LPMESSAGE pMessage,                                      \
        /*in*/ ULONG fSameAsLoad) IPURE;                                \
    MAPIMETHOD(SaveCompleted)(THIS_                                     \
        /*in*/ LPMESSAGE pMessage) IPURE;                               \
    MAPIMETHOD(HandsOffMessage)(THIS) IPURE;                            \

#undef INTERFACE
#define INTERFACE IPersistMessage
DECLARE_MAPI_INTERFACE_(IPersistMessage, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IPERSISTMESSAGE_METHODS(PURE)
};


/*-- IMAPIMessageSite ------------------------------------------------------*/

#define MAPI_IMAPIMESSAGESITE_METHODS(IPURE)                            \
    MAPIMETHOD(GetSession) (THIS_                                       \
        /*out*/ LPMAPISESSION FAR * ppSession) IPURE;                   \
    MAPIMETHOD(GetStore) (THIS_                                         \
        /*out*/ LPMDB FAR * ppStore) IPURE;                             \
    MAPIMETHOD(GetFolder) (THIS_                                        \
        /*out*/ LPMAPIFOLDER FAR * ppFolder) IPURE;                     \
    MAPIMETHOD(GetMessage) (THIS_                                       \
        /*out*/ LPMESSAGE FAR * ppmsg) IPURE;                           \
    MAPIMETHOD(GetFormManager) (THIS_                                   \
        /*out*/ LPMAPIFORMMGR FAR * ppFormMgr) IPURE;                   \
    MAPIMETHOD(NewMessage) (THIS_                                       \
        /*in*/  ULONG fComposeInFolder,                                 \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPPERSISTMESSAGE pPersistMessage,                       \
        /*out*/ LPMESSAGE FAR * ppMessage,                              \
        /*out*/ LPMAPIMESSAGESITE FAR * ppMessageSite,                  \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(CopyMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination) IPURE;                 \
    MAPIMETHOD(MoveMessage) (THIS_                                      \
        /*in*/  LPMAPIFOLDER pFolderDestination,                        \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(DeleteMessage) (THIS_                                    \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(SaveMessage) (THIS) IPURE;                               \
    MAPIMETHOD(SubmitMessage) (THIS_                                    \
		/*in*/ ULONG ulFlags) IPURE;                                    \
    MAPIMETHOD(GetSiteStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIMessageSite
DECLARE_MAPI_INTERFACE_(IMAPIMessageSite, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIMESSAGESITE_METHODS(PURE)
};


/*-- IMAPIForm -------------------------------------------------------------*/
/* This interface is implemented by forms for the benefit of viewers.
 * One method (ShutdownForm) is provided such that simple forms implementing
 * only IMAPIForm and IPersistMessage have reasonable embedding behavior.
 */

#define MAPI_IMAPIFORM_METHODS(IPURE)                                   \
    MAPIMETHOD(SetViewContext) (THIS_                                   \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext) IPURE;                  \
    MAPIMETHOD(GetViewContext) (THIS_                                   \
        /*out*/ LPMAPIVIEWCONTEXT FAR * ppViewContext) IPURE;           \
    MAPIMETHOD(ShutdownForm)(THIS_                                             \
        /*in*/  ULONG ulSaveOptions) IPURE;                             \
    MAPIMETHOD(DoVerb) (THIS_                                           \
        /*in*/  LONG iVerb,                                             \
        /*in*/  LPMAPIVIEWCONTEXT lpViewContext, /* can be null */      \
        /*in*/  ULONG hwndParent,                                       \
        /*in*/  LPCRECT lprcPosRect) IPURE;                             \
    MAPIMETHOD(Advise)(THIS_                                            \
        /*in*/  LPMAPIVIEWADVISESINK pAdvise,                           \
        /*out*/ ULONG FAR * pdwStatus) IPURE;                           \
    MAPIMETHOD(Unadvise) (THIS_                                         \
        /*in*/  ULONG ulConnection) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIForm
DECLARE_MAPI_INTERFACE_(IMAPIForm, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORM_METHODS(PURE)
};

typedef enum tagSAVEOPTS
{
	SAVEOPTS_SAVEIFDIRTY = 0,
	SAVEOPTS_NOSAVE = 1,
	SAVEOPTS_PROMPTSAVE = 2
} SAVEOPTS;


/*-- IMAPIViewContext ------------------------------------------------------*/
/* Implemented by viewers to support next/previous in forms.
 */

/* Structure passed in GetPrintSetup  */

typedef struct {
	ULONG ulFlags;  /* MAPI_UNICODE */
	HGLOBAL hDevMode;
	HGLOBAL hDevNames;
	ULONG ulFirstPageNumber;
	ULONG fPrintAttachments;
} FORMPRINTSETUP, FAR * LPFORMPRINTSETUP;

/* Values for pulFormat in GetSaveStream */

#define SAVE_FORMAT_TEXT                1
#define SAVE_FORMAT_RICHTEXT            2

/* Values from 0 to 0x3fff are reserved for future definition by Microsoft */

#define MAPI_IMAPIVIEWCONTEXT_METHODS(IPURE)                            \
    MAPIMETHOD(SetAdviseSink)(THIS_                                     \
        /*in*/  LPMAPIFORMADVISESINK pmvns) IPURE;                      \
    MAPIMETHOD(ActivateNext)(THIS_                                      \
        /*in*/  ULONG ulDir,                                            \
        /*in*/  LPCRECT prcPosRect) IPURE;                              \
    MAPIMETHOD(GetPrintSetup)(THIS_                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPFORMPRINTSETUP FAR * lppFormPrintSetup) IPURE;        \
    MAPIMETHOD(GetSaveStream)(THIS_                                     \
        /*out*/ ULONG FAR * pulFlags,                                   \
        /*out*/ ULONG FAR * pulFormat,                                  \
        /*out*/ LPSTREAM FAR * ppstm) IPURE;                            \
    MAPIMETHOD(GetViewStatus) (THIS_                                    \
		/*out*/ LPULONG lpulStatus) IPURE;                              \

#undef INTERFACE
#define INTERFACE IMAPIViewContext
DECLARE_MAPI_INTERFACE_(IMAPIViewContext, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIVIEWCONTEXT_METHODS(PURE)
};

#define VCSTATUS_NEXT                           0x00000001
#define VCSTATUS_PREV                           0x00000002
#define VCSTATUS_MODAL                          0x00000004
#define VCSTATUS_INTERACTIVE                    0x00000008
#define VCSTATUS_READONLY                       0x00000010
#define VCSTATUS_DELETE                         0x00010000
#define VCSTATUS_COPY                           0x00020000
#define VCSTATUS_MOVE                           0x00040000
#define VCSTATUS_SUBMIT                         0x00080000
#define VCSTATUS_DELETE_IS_MOVE                 0x00100000
#define VCSTATUS_SAVE                           0x00200000
#define VCSTATUS_NEW_MESSAGE                    0x00400000

#define VCDIR_NEXT                              VCSTATUS_NEXT
#define VCDIR_PREV                              VCSTATUS_PREV
#define VCDIR_DELETE                            VCSTATUS_DELETE
#define VCDIR_MOVE                              VCSTATUS_MOVE


/*-- IMAPIFormAdviseSink ---------------------------------------------------*/
/* Part of form server, held by view; receives notifications from the view.
 *
 * This part of the form server, but is not an interface on the form
 * object.  This means that clients should not expect to QueryInterface
 * from an IMAPIForm* or IOleObject* to this interface, or vice versa.
 */

#define MAPI_IMAPIFORMADVISESINK_METHODS(IPURE)                         \
    STDMETHOD(OnChange)(THIS_ ULONG ulDir) IPURE;                       \
    STDMETHOD(OnActivateNext)(THIS_                                     \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*out*/ LPPERSISTMESSAGE FAR * ppPersistMessage) IPURE;         \

#undef INTERFACE
#define INTERFACE IMAPIFormAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIFormAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIFORMADVISESINK_METHODS(PURE)
};


/*-- IMAPIViewAdviseSink ---------------------------------------------------*/
/* Part of view context, held by form; receives notifications from the form.
 */

#define MAPI_IMAPIVIEWADVISESINK_METHODS(IPURE)                         \
    MAPIMETHOD(OnShutdown)(THIS) IPURE;                                    \
    MAPIMETHOD(OnNewMessage)(THIS) IPURE;                               \
    MAPIMETHOD(OnPrint)(THIS_                                           \
        /*in*/ ULONG dwPageNumber,                                      \
        /*in*/ HRESULT hrStatus) IPURE;                                 \
    MAPIMETHOD(OnSubmitted) (THIS) IPURE;                               \
    MAPIMETHOD(OnSaved) (THIS) IPURE;                                   \

#undef INTERFACE
#define INTERFACE IMAPIViewAdviseSink
DECLARE_MAPI_INTERFACE_(IMAPIViewAdviseSink, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIVIEWADVISESINK_METHODS(PURE)
};


/*-- IMAPIFormInfo ---------------------------------------------------------*/
/* Is implemented by registries.  Describes the form.
 */

/* Single enum value */

typedef struct
{								/* fpev */
	LPTSTR pszDisplayName;		/* carries the display string */
	ULONG nVal;					/* the value for the above enumeration */
} SMAPIFormPropEnumVal, FAR * LPMAPIFORMPROPENUMVAL;

/* MAPI Form property descriptor */

/*
 * Values for the tag in the SMAPIFormProp structure
 *
 * Microsoft reserves the range from 0 to 0x3FFF for future use in its other
 * forms registry implementations.
 */

typedef ULONG FORMPROPSPECIALTYPE;

#define FPST_VANILLA                    0
#define FPST_ENUM_PROP                  1

typedef struct
{
	ULONG ulFlags;				/* Contains MAPI_UNICODE if strings are UNICODE */
	ULONG nPropType;			/* type of the property, hiword is 0 */
	MAPINAMEID nmid;			/* id of the property */
	LPTSTR pszDisplayName;
	FORMPROPSPECIALTYPE nSpecialType;	/* tag for the following union */
	union
	{
		struct
		{
			MAPINAMEID nmidIdx;
			ULONG cfpevAvailable;	/* # of enums */
			LPMAPIFORMPROPENUMVAL pfpevAvailable;
		} s1;					/* Property String/Number association Enumeration */
	} u;
} SMAPIFormProp, FAR * LPMAPIFORMPROP;

/* Array of form properties */

typedef struct
{
	ULONG cProps;
	ULONG ulPad;				/* Pad to 8-byte alignment for insurance */
	SMAPIFormProp aFormProp[MAPI_DIM];
} SMAPIFormPropArray, FAR * LPMAPIFORMPROPARRAY;

#define CbMAPIFormPropArray(_c) \
         (offsetof(SMAPIFormPropArray, aFormProp) + \
         (_c)*sizeof(SMAPIFormProp))

/* Structure defining the layout of an mapi verb description */

typedef struct
{
	LONG lVerb;
	LPTSTR szVerbname;
	DWORD fuFlags;
	DWORD grfAttribs;
	ULONG ulFlags;				/* Either 0 or MAPI_UNICODE */
} SMAPIVerb, FAR * LPMAPIVERB;

/* Structure used for returning arrays of mapi verbs */

typedef struct
{
	ULONG cMAPIVerb;			/* Number of verbs in the structure */
	SMAPIVerb aMAPIVerb[MAPI_DIM];
} SMAPIVerbArray, FAR * LPMAPIVERBARRAY;

#define CbMAPIVerbArray(_c) \
         (offsetof(SMAPIVerbArray, aMAPIVerb) + \
         (_c)*sizeof(SMAPIVerb))

#define MAPI_IMAPIFORMINFO_METHODS(IPURE)                               \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppFormPropArray) IPURE;       \
    MAPIMETHOD(CalcVerbSet)(THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIVERBARRAY FAR * ppMAPIVerbArray) IPURE;           \
    MAPIMETHOD(MakeIconFromBinary)(THIS_                                \
        /*in*/ ULONG nPropID,                                           \
        /*out*/ HICON FAR* phicon) IPURE;                               \
    MAPIMETHOD(SaveForm)(THIS_                                          \
        /*in*/ LPCTSTR szFileName) IPURE;                               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*out*/ LPMAPIFORMCONTAINER FAR * ppformcontainer) IPURE;       \

#undef INTERFACE
#define INTERFACE IMAPIFormInfo
DECLARE_MAPI_INTERFACE_(IMAPIFormInfo, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE) 	/* note: subsumes getlasterror */
	MAPI_IMAPIFORMINFO_METHODS(PURE)
};


/* Enumeration of permissible values for PR_FORM_MESSAGE_BEHAVIOR */

#define	MAPI_MESSAGE_BEHAVIOR_IPM 0
#define	MAPI_MESSAGE_BEHAVIOR_FOLDER 1


/*-- IMAPIFormMgr ----------------------------------------------------------*/
/* The client-visible interface for form resolution and dispatch.
 */

/* Structure containing an array of message class strings */

typedef struct
{
	ULONG cValues;
	LPCSTR aMessageClass[MAPI_DIM];
} SMessageClassArray, FAR * LPSMESSAGECLASSARRAY;

#define CbMessageClassArray(_c) \
        (offsetof(SMessageClassArray, aMessageClass) + (_c)*sizeof(LPCSTR))

/* Structure containing an array of IMAPIFormInfo interfaces */

typedef struct
{
	ULONG cForms;
	LPMAPIFORMINFO aFormInfo[MAPI_DIM];
} SMAPIFormInfoArray, FAR * LPSMAPIFORMINFOARRAY;

#define CbMAPIFormInfoArray(_c) \
         (offsetof(SMAPIFormInfoArray, aFormInfo) + \
         (_c)*sizeof(LPMAPIFORMINFO))

/* Flags for IMAPIFormMgr::SelectFormContainer */

#define MAPIFORM_SELECT_ALL_REGISTRIES           0
#define MAPIFORM_SELECT_FOLDER_REGISTRY_ONLY     1
#define MAPIFORM_SELECT_NON_FOLDER_REGISTRY_ONLY 2

/* Flags for IMAPIFormMgr::CalcFormPropSet */

#define FORMPROPSET_UNION                 0
#define FORMPROPSET_INTERSECTION          1

/* Flags for IMAPIFormMgr::ResolveMessageClass and
   IMAPIFormMgr::ResolveMultipleMessageClasses */

#define MAPIFORM_EXACTMATCH             0x0020

#define MAPI_IMAPIFORMMGR_METHODS(IPURE)                                \
    MAPIMETHOD(LoadForm)(THIS_                                          \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCSTR lpszMessageClass,                                \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  LPMAPIFOLDER pFolderFocus,                              \
        /*in*/  LPMAPIMESSAGESITE pMessageSite,                         \
        /*in*/  LPMESSAGE pmsg,                                         \
        /*in*/  LPMAPIVIEWCONTEXT pViewContext,                         \
        /*in*/  REFIID riid,                                            \
        /*out*/ LPVOID FAR *ppvObj) IPURE;                              \
    MAPIMETHOD(ResolveMessageClass)(THIS_                               \
        /*in*/  LPCSTR szMsgClass,                                      \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPMAPIFORMINFO FAR* ppResult) IPURE;                    \
    MAPIMETHOD(ResolveMultipleMessageClasses)(THIS_                     \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClasses,                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFOLDER pFolderFocus, /* can be null */            \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * pfrminfoarray) IPURE;        \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR* ppResults) IPURE;              \
    MAPIMETHOD(CreateForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfoToActivate,                      \
        /*in*/  REFIID refiidToAsk,                                     \
        /*out*/ LPVOID FAR* ppvObj) IPURE;                              \
    MAPIMETHOD(SelectForm)(THIS_                                        \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*out*/ LPMAPIFORMINFO FAR * ppfrminfoReturned) IPURE;          \
    MAPIMETHOD(SelectMultipleForms)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR pszTitle,                                       \
        /*in*/  LPMAPIFOLDER pfld,                                      \
        /*in*/  LPSMAPIFORMINFOARRAY pfrminfoarray,                     \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(SelectFormContainer)(THIS_                               \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(OpenFormContainer)(THIS_                                 \
        /*in*/  HFRMREG hfrmreg,                                        \
        /*in*/  LPUNKNOWN lpunk,                                        \
        /*out*/ LPMAPIFORMCONTAINER FAR * lppfcnt) IPURE;               \
    MAPIMETHOD(PrepareForm)(THIS_                                       \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPMAPIFORMINFO pfrminfo) IPURE;                         \
    MAPIMETHOD(IsInConflict)(THIS_                                      \
        /*in*/  ULONG ulMessageFlags,                                   \
        /*in*/  ULONG ulMessageStatus,                                  \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  LPMAPIFOLDER pFolderFocus) IPURE;                       \

#undef         INTERFACE
#define         INTERFACE    IMAPIFormMgr
DECLARE_MAPI_INTERFACE_(IMAPIFormMgr, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMMGR_METHODS(PURE)
};

/* Platform numbers (used in .CFG files for forms) */

#define MAPIFORM_CPU_X86                1
#define MAPIFORM_CPU_MIP                2
#define MAPIFORM_CPU_AXP                3
#define MAPIFORM_CPU_PPC                4
#define MAPIFORM_CPU_M68                5

#define MAPIFORM_OS_WIN_31              1
#define MAPIFORM_OS_WINNT_35            2
#define MAPIFORM_OS_WIN_95              3
#define MAPIFORM_OS_MAC_7x              4
#define MAPIFORM_OS_WINNT_40            5

#define MAPIFORM_PLATFORM(CPU, OS) ((ULONG) ((((ULONG) CPU) << 16) | OS))


/*-- IMAPIFormContainer -------------------------------------------------*/

/*  Flags for IMAPIFormMgr::CalcFormPropSet */

/* #define FORMPROPSET_UNION            0   */
/* #define FORMPROPSET_INTERSECTION     1   */

/*  Flags for IMAPIFormMgr::InstallForm     */

#define MAPIFORM_INSTALL_DIALOG                 MAPI_DIALOG
#define MAPIFORM_INSTALL_OVERWRITEONCONFLICT    0x0010

/*  Flags for IMAPIFormContainer::ResolveMessageClass and
    IMAPIFormContainer::ResolveMultipleMessageClasses */
/* #define MAPIFORM_EXACTIMATCH    0x0020   */

#define MAPI_IMAPIFORMCONTAINER_METHODS(IPURE)                       \
    MAPIMETHOD(InstallForm)(THIS_                                   \
        /*in*/  ULONG ulUIParam,                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  LPCTSTR szCfgPathName) IPURE;                           \
    MAPIMETHOD(RemoveForm)(THIS_                                        \
        /*in*/  LPCSTR szMessageClass) IPURE;                           \
    MAPIMETHOD(ResolveMessageClass) (THIS_                              \
        /*in*/  LPCSTR szMessageClass,                                  \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMINFO FAR * pforminfo) IPURE;                  \
    MAPIMETHOD(ResolveMultipleMessageClasses) (THIS_                    \
        /*in*/  LPSMESSAGECLASSARRAY pMsgClassArray,                    \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPSMAPIFORMINFOARRAY FAR * ppfrminfoarray) IPURE;       \
    MAPIMETHOD(CalcFormPropSet)(THIS_                                   \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPMAPIFORMPROPARRAY FAR * ppResults) IPURE;             \
    MAPIMETHOD(GetDisplay)(THIS_                                        \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPTSTR FAR * pszDisplayName) IPURE;                     \

#undef INTERFACE
#define INTERFACE IMAPIFormContainer
DECLARE_MAPI_INTERFACE_(IMAPIFormContainer, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMCONTAINER_METHODS(PURE)
};

/*-- IMAPIFormFactory ------------------------------------------------------*/

#define MAPI_IMAPIFORMFACTORY_METHODS(IPURE)                            \
    MAPIMETHOD(CreateClassFactory) (THIS_                               \
        /*in*/  REFCLSID clsidForm,                                     \
        /*in*/  ULONG ulFlags,                                          \
        /*out*/ LPCLASSFACTORY FAR * lppClassFactory) IPURE;            \
    MAPIMETHOD(LockServer) (THIS_                                       \
        /*in*/  ULONG ulFlags,                                          \
        /*in*/  ULONG fLockServer) IPURE;                               \

#undef INTERFACE
#define INTERFACE IMAPIFormFactory
DECLARE_MAPI_INTERFACE_(IMAPIFormFactory, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_GETLASTERROR_METHOD(PURE)
	MAPI_IMAPIFORMFACTORY_METHODS(PURE)
};

#endif							/* MAPIFORM_H */


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\types\idl\makefile.inc ===
#
# Inference rules.
#
.SUFFIXES:.idl

# Copy .idl file from sdk\inc to here
{$(SDK_INC_PATH)}.idl{$(O)}.idl:
    copy $? $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Handler.rc
//
#define IDI_ICON1                       129
#define IDI_ICON2                       130
#define IDI_ICON3                       131
#define IDD_GAKPAGE                     132
#define IDI_ICON4                       133
#define IDI_ICON5                       134
#define IDI_ICON6                       135
#define IDI_BRIEFCASE                   138
#define IDI_IOUTLOOK                    139
#define IDC_RED                         1000
#define IDC_CHECK1                      1000
#define IDC_GREEN                       1001
#define IDC_CHECK2                      1001
#define IDC_BLUE                        1002
#define IDC_CONNECTSPEEDS               1002
#define IDC_RADIO1                      1003
#define IDC_RADIO2                      1004
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        140
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\types\proxy\dlldatax.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/


#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( mobsync )
EXTERN_PROXY_FILE( mobsyncp )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( mobsync ),
  REFERENCE_PROXY_FILE( mobsyncp ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\types\proxy\stub_mobsyncp_p.c ===
#include <mobsyncp_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\types\proxy\stub_mobsync_p.c ===
#include <mobsync_p.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\test\outhndlr\wmsuix.h ===
// Only include this stuff once

#ifndef __WMSUIX_H__
#define __WMSUIX_H__

// Progress stuff pulled out to allow this header to be included in Local Rep

// Standard progress dialog functions
typedef struct _stdprog
{
	// IN parameters
	HWND		hwndParent;			// Parent window to disable/enable
	INT			nProgCur;			// Starting position of progress
	INT			nProgMax;			// Starting max value for progress
	INT			idAVI;				// Resource id of animation to play
	LPTSTR		szCaption;			// Caption of progress dialog
	ULONG		ulFlags;			// Flags

	// OUT parameters
	HWND		hwndDlg;			// Progress dialog window;
	BOOL		fCancelled;

	// internal stuff
	DWORD		dwStartTime;
	DWORD		dwShowTime;
	HCURSOR		hcursor;
	WNDPROC		wndprocCancel;

#ifdef DBCS
#ifdef WIN16
	DLGTEMPLATE FAR *lpDlg;
#else	// !WIN16
	DLGTEMPLATE *lpDlg;
#endif	// !WIN16
#endif	// !DBCS
}				
STDPROG;

#define STDPROG_FLAGS_ALWAYS_SHOW	0x00000001		// always show progress dialog immediately
#define STDPROG_FLAGS_BACKGROUND	0x00000002		// don't bring progress dialog to front

#ifdef __cplusplus
extern "C" {
#endif
BOOL CALLBACK FCreateStandardProgress(STDPROG * pstdprog);
VOID CALLBACK UpdateStandardProgress(STDPROG * pstdprog, LPTSTR szComment, INT nProgCur, INT nProgMax);
VOID CALLBACK DestroyStandardProgress(STDPROG * pstdprog, BOOL fFlashFull);
#ifdef __cplusplus
}
#endif

// Keep these in ssync w/ \capone\mapin\mapin.rh
#define AVI_StandardProgressMove		410
#define AVI_StandardProgressCopy		411
#define AVI_StandardProgressDelete		412
#define AVI_StandardProgressDeletePerm	413
#define AVI_StandardProgressRemote		414
#define AVI_StandardProgressDownloadAB	415
#define AVI_StandardProgressRecycle		416
#define AVI_StandardProgressSynchronize	417

// RAS stuff used by Local Rep
#ifdef _RAS_H_

#ifdef WIN16
typedef DWORD (FAR PASCAL *PFNRASGETERRORSTRING)(DWORD, LPSTR, DWORD);
typedef DWORD (FAR PASCAL *PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (FAR PASCAL *PFNRASDIAL)(LPSTR, LPSTR, LPRASDIALPARAMS, DWORD, LPVOID, LPHRASCONN);
typedef DWORD (FAR PASCAL *PFNRASGETCONNECTSTATUS)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (FAR PASCAL *PFNRASHANGUP)(HRASCONN);
typedef DWORD (FAR PASCAL *PFNRASENUMENTRIES)(LPSTR, LPSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
#endif
	
#if defined(WIN32) && !defined(MAC) && !defined(_X86_)
typedef DWORD (APIENTRY *PFNRASGETERRORSTRING)(DWORD, LPTSTR, DWORD);
typedef DWORD (APIENTRY *PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *PFNRASDIAL)(LPTSTR, LPTSTR, LPRASDIALPARAMS, LPVOID, RASDIALFUNC, LPHRASCONN);
typedef DWORD (APIENTRY *PFNRASGETCONNECTSTATUS)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *PFNRASHANGUP)(HRASCONN);
typedef DWORD (APIENTRY *PFNRASENUMENTRIES)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
#endif

#if defined(WIN32) && defined(_X86_)
#define USETAPI

typedef DWORD (APIENTRY *PFNRASGETERRORSTRING)(DWORD, LPTSTR, DWORD);
typedef DWORD (APIENTRY *PFNRASENUMCONNECTIONS)(LPRASCONN, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *PFNRASDIAL)(LPTSTR, LPTSTR, LPRASDIALPARAMS, LPVOID, RASDIALFUNC, LPHRASCONN);
typedef DWORD (APIENTRY *PFNRASGETCONNECTSTATUS)(HRASCONN, LPRASCONNSTATUS);
typedef DWORD (APIENTRY *PFNRASHANGUP)(HRASCONN);
typedef DWORD (APIENTRY *PFNRASENUMENTRIES)(LPTSTR, LPTSTR, LPRASENTRYNAME, LPDWORD, LPDWORD);
typedef DWORD (APIENTRY *PFNRASEDITPHONEBOOKENTRY) ( HWND, LPSTR, LPSTR );
typedef DWORD (APIENTRY *PFNRASCREATEPHONEBOOKENTRY) ( HWND, LPSTR );
#endif


#if defined(WIN32) && !defined(MAC)
#ifdef UNICODE
#define RASDIALSTRING					"RasDialW"
#define RASENUMCONNECTIONSSTRING		"RasEnumConnectionsW"
#define RASGETCONNECTSTATUSSTRING		"RasGetConnectStatusW"
#define RASHANGUPSTRING					"RasHangUpW"
#define RASGETERRORSTRINGSTRING			"RasGetErrorStringW"
#define RASENUMENTRIESSTRING			"RasEnumEntriesW"
#define RASCREATEPHONEBOOKENTRYSTRING	"RasCreatePhonebookEntryW"
#define RASEDITPHONEBOOKENTRYSTRING		"RasEditPhonebookEntryW"
#else
#define RASDIALSTRING					"RasDialA"
#define RASENUMCONNECTIONSSTRING		"RasEnumConnectionsA"
#define RASGETCONNECTSTATUSSTRING		"RasGetConnectStatusA"
#define RASHANGUPSTRING					"RasHangUpA"
#define RASGETERRORSTRINGSTRING			"RasGetErrorStringA"
#define RASENUMENTRIESSTRING			"RasEnumEntriesA"
#define RASCREATEPHONEBOOKENTRYSTRING	"RasCreatePhonebookEntryA"
#define RASEDITPHONEBOOKENTRYSTRING		"RasEditPhonebookEntryA"
#endif
#else
#define RASDIALSTRING					"RasDial"
#define RASENUMCONNECTIONSSTRING		"RasEnumConnections"
#define RASGETCONNECTSTATUSSTRING		"RasGetConnectStatus"
#define RASHANGUPSTRING					"RasHangUp"
#define RASGETERRORSTRINGSTRING			"RasGetErrorString"
#define RASENUMENTRIESSTRING			"RasEnumEntries"
#define RASCREATEPHONEBOOKENTRYSTRING	"RasCreatePhonebookEntry"
#define RASEDITPHONEBOOKENTRYSTRING		"RasEditPhonebookEntry"
#endif


// sizes for the RASDIALPARAMS struct in ras.h
#define cchRxpMaxEntryName	RAS_MaxEntryName
#define cchRxpUNLEN			UNLEN
#define cchRxpDNLEN			DNLEN
#define cchRxpPWLEN			PWLEN


typedef struct
{
	HINSTANCE hinstRas;
	PFNRASENUMCONNECTIONS		pfnrasenumconnections;
	PFNRASDIAL					pfnrasdial;
	PFNRASGETCONNECTSTATUS		pfnrasgetconnectstatus;
	PFNRASHANGUP				pfnrashangup;
	PFNRASGETERRORSTRING		pfnrasgeterrorstring;
	PFNRASENUMENTRIES			pfnrasenumentries;
#if defined(WIN32) && defined(_X86_)
	PFNRASCREATEPHONEBOOKENTRY	pfnrascreatephonebookentry;
	PFNRASEDITPHONEBOOKENTRY	pfnraseditphonebookentry;
#endif
	HRASCONN					hrasconn;
	BOOL						fRasAvailable;
	TCHAR						szRasEntryDialed[cchRxpMaxEntryName + 1];
} RASPACKAGE;

typedef struct
{
	TCHAR	szRasEntry[cchRxpMaxEntryName + 1];
	TCHAR	szUserName[cchRxpUNLEN + 1];
	TCHAR	szDomainName[cchRxpDNLEN + 1];
	TCHAR	szPassword[cchRxpPWLEN + 1];
//	BYTE	bRasPasswd[256];
	BOOL	fDoSchedEvery;
	LONG	lSchedEvery;		// in Minutes
	BOOL	fDoSchedAt;
	LONG	lSchedAt;			// in Minutes from Midnight
	BOOL	fDisconHead;
	BOOL	fDisconTrans;
	BOOL    fUseRas;
	BOOL	fTransferMarked;	// If false tranfer filter
	FILETIME	ftBasetime;
	LPSRestriction	lpRes;
	
	BOOL	fAddrBookSch;
	BOOL	fAddrBook;
	
	LPSRestriction lpResNormal;
	BOOL	fTransferMarkedNorm; // If false tranfer filter	
} EMSRPREF;

#endif // _RAS_H_

#endif // __WMSUIX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\mobile\syncmgr\types\proxy\prxstub.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       prxstub.c
//
//  Contents:   local marshalling code
//
//  Classes:    
//
//  Notes:   	HICON marshals are not explosed through ole32.def
//		so this file defines them locally and just turns
//		around and call the HWND routines which are exposed
//		and marshalled the same way HICON is internal in OLE.
//
//		If Ole32 adds this to the .def on all platforms interested
//		in remoting then this code is no longer necessary
//		   
//
//  History:    11-Nov-98   rogerg      Created.
//
//--------------------------------------------------------------------------

#ifdef _REMOTINTERFACES

#include "rpcproxy.h"

// local file to define unexported marshal interfaces

unsigned long  __RPC_USER  HICON_UserSize(
		unsigned long * pFlags,
		unsigned long   Offset,
		HICON * pH )
{

	return HWND_UserSize(pFlags,Offset ,(HWND *) pH);
}

unsigned char __RPC_FAR * __RPC_USER  HICON_UserMarshal( 
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserMarshal( pFlags,pBuffer,(HWND *) pH);

}
 
unsigned char __RPC_FAR * __RPC_USER  HICON_UserUnmarshal(
		unsigned long * pFlags,
		unsigned char * pBuffer,
		HICON	* pH)
{

	return HWND_UserUnmarshal(pFlags
				,pBuffer
				, (HWND *) pH);
}

void    __RPC_USER  HICON_UserFree(
		unsigned long * pFlags,
		HICON	* pH)
{

	HWND_UserFree( pFlags,(HWND *) pH);
} 

#endif // #ifdef _REMOTINTERFACES
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\dllfuncs.cpp ===
/*
 * DLLFUNCS.CPP
 *
 * Contains entry and exit points for the DLL implementation
 * of the OLE 2.0 User Interface Support Library.
 *
 * This file is not needed if we are linking the static library
 * version of this library.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "uiclass.h"

OLEDBGDATA_MAIN(TEXT("OLEDLG"))

/*
 * DllMain
 *
 * Purpose:
 *  DLL-specific entry point called from LibEntry.
 */

STDAPI_(BOOL) OleUIInitialize(HINSTANCE, HINSTANCE);
STDAPI_(BOOL) OleUIUnInitialize();

#pragma code_seg(".text$initseg")

BOOL WINAPI DllMain(HINSTANCE hInst, DWORD Reason, LPVOID lpv)
{
        if (Reason == DLL_PROCESS_DETACH)
        {
                OleDbgOut2(TEXT("DllMain: OLEDLG.DLL unloaded\r\n"));

                OleUIUnInitialize();
        }
        else if (Reason == DLL_PROCESS_ATTACH)
        {
                OSVERSIONINFO sVersion;

                sVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

                if (GetVersionEx(&sVersion))
                {
                    if (VER_PLATFORM_WIN32s == sVersion.dwPlatformId)
                    {
                        if ((1 == sVersion.dwMajorVersion) && (30 > sVersion.dwMinorVersion))
                        {
                            return(FALSE); // fail to load on older versions of Win32s
                        }
                    }
                }

                OleDbgOut2(TEXT("DllMain: OLEDLG.DLL loaded\r\n"));

                DisableThreadLibraryCalls(hInst);

                OleUIInitialize(hInst, (HINSTANCE)0);
        }
        return TRUE;
}

#pragma code_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\busy.cpp ===
/*
 * BUSY.CPP
 *
 * Implements the OleUIBusy function which invokes the "Server Busy"
 * dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"

OLEDBGDATA

// Internally used structure
typedef struct tagBUSY
{
        // Keep these items first as the Standard* functions depend on it here.
        LPOLEUIBUSY     lpOBZ;  // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog or that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD   dwFlags;        // Flags passed in
        HWND    hWndBlocked;    // HWND of app which is blocking

} BUSY, *PBUSY, FAR *LPBUSY;

// Internal function prototypes
// BUSY.CPP

INT_PTR CALLBACK BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
BOOL GetTaskInfo(HWND hWnd, HTASK htask, LPTSTR* lplpszWindowName, HWND* lphWnd);
void BuildBusyDialogString(HWND, DWORD, int, LPTSTR);
BOOL FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam);
void MakeWindowActive(HWND hWndSwitchTo);

/*
 * OleUIBusy
 *
 * Purpose:
 *  Invokes the standard OLE "Server Busy" dialog box which
 *  notifies the user that the server application is not receiving
 *  messages.  The dialog then asks the user to either cancel
 *  the operation, switch to the task which is blocked, or continue
 *  waiting.
 *
 * Parameters:
 *  lpBZ            LPOLEUIBUSY pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *              OLEUI_BZERR_HTASKINVALID  : Error
 *              OLEUI_BZ_SWITCHTOSELECTED : Success, user selected "switch to"
 *              OLEUI_BZ_RETRYSELECTED    : Success, user selected "retry"
 *              OLEUI_CANCEL              : Success, user selected "cancel"
 */
STDAPI_(UINT) OleUIBusy(LPOLEUIBUSY lpOBZ)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpOBZ, sizeof(OLEUIBUSY),
                &hMemDlg);

        // Error out if the standard validation failed
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Error out if our secondary validation failed
        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        // Invoke the dialog.
        uRet = UStandardInvocation(BusyDialogProc, (LPOLEUISTANDARD)lpOBZ,
                hMemDlg, MAKEINTRESOURCE(IDD_BUSY));
        return uRet;
}

/*
 * BusyDialogProc
 *
 * Purpose:
 *  Implements the OLE Busy dialog as invoked through the OleUIBusy function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 *
 */
INT_PTR CALLBACK BusyDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPBUSY lpBZ = (LPBUSY)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // Process our special "close" message.  If we get this message,
        // this means that the call got unblocked, so we need to
        // return OLEUI_BZ_CALLUNBLOCKED to our calling app.
        if (iMsg == uMsgCloseBusyDlg)
        {
                SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_CALLUNBLOCKED, 0L);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpBZ)
            {
                StandardCleanup(lpBZ, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FBusyInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_ACTIVATEAPP:
                {
                        /* try to bring down our Busy/NotResponding dialog as if
                        **    the user entered RETRY.
                        */
                        BOOL fActive = (BOOL)wParam;
                        if (fActive)
                        {
                                // If this is the app BUSY case, then bring down our
                                // dialog when switching BACK to our app
                                if (lpBZ && !(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                                        SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
                        }
                        else
                        {
                                // If this is the app NOT RESPONDING case, then bring down
                                // our dialog when switching AWAY to another app
                                if (lpBZ && (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
                                        SendMessage(hDlg,uMsgEndDialog,OLEUI_BZ_RETRYSELECTED,0L);
                        }
                }
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_BZ_SWITCHTO:
                        {
                                BOOL fNotRespondingDlg =
                                                (BOOL)(lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG);
                                HWND hwndTaskList = hDlg;

                                // If this is the app not responding case, then we want
                                // to bring down the dialog when "SwitchTo" is selected.
                                // If the app is busy (RetryRejectedCall situation) then
                                // we do NOT want to bring down the dialog. this is
                                // the OLE2.0 user model design.
                                if (fNotRespondingDlg)
                                {
                                        hwndTaskList = GetParent(hDlg);
                                        if (hwndTaskList == NULL)
                                                hwndTaskList = GetDesktopWindow();
                                        PostMessage(hDlg, uMsgEndDialog,
                                                OLEUI_BZ_SWITCHTOSELECTED, 0L);
                                }

                                // If user selects "Switch To...", switch activation
                                // directly to the window which is causing the problem.
                                if (IsWindow(lpBZ->hWndBlocked))
                                        MakeWindowActive(lpBZ->hWndBlocked);
                                else
                                        PostMessage(hwndTaskList, WM_SYSCOMMAND, SC_TASKLIST, 0);
                        }
                        break;

                case IDC_BZ_RETRY:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_BZ_RETRYSELECTED, 0L);
                        break;

                case IDCANCEL:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;
                }
                break;
        }

        return FALSE;
}

/*
 * FBusyInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Busy dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FBusyInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        HFONT hFont;
        LPBUSY lpBZ = (LPBUSY)LpvStandardInit(hDlg, sizeof(BUSY), &hFont);

        // PvStandardInit sent a termination to us already.
        if (NULL == lpBZ)
                return FALSE;

        // Our original structure is in lParam
        LPOLEUIBUSY lpOBZ = (LPOLEUIBUSY)lParam;

        // Copy it to our instance of the structure (in lpBZ)
        lpBZ->lpOBZ = lpOBZ;
        lpBZ->nIDD = IDD_BUSY;

        //Copy other information from lpOBZ that we might modify.
        lpBZ->dwFlags = lpOBZ->dwFlags;

        // Set default information
        lpBZ->hWndBlocked = NULL;

        // Insert HWND of our dialog into the address pointed to by
        // lphWndDialog.  This can be used by the app who called
        // OleUIBusy to bring down the dialog with uMsgCloseBusyDialog
        if (lpOBZ->lphWndDialog &&
                !IsBadWritePtr(lpOBZ->lphWndDialog, sizeof(HWND)))
        {
                *lpOBZ->lphWndDialog = hDlg;
        }

        // Update text in text box --
        // GetTaskInfo will return two pointers, one to the task name
        // (file name) and one to the window name.  We need to call
        // OleStdFree on these when we're done with them.  We also
        // get the HWND which is blocked in this call
        //
        // In the case where this call fails, a default message should already
        // be present in the dialog template, so no action is needed

        LPTSTR lpWindowName;
        if (GetTaskInfo(hDlg, lpOBZ->hTask, &lpWindowName, &lpBZ->hWndBlocked))
        {
                // Build string to present to user, place in IDC_BZ_MESSAGE1 control
                BuildBusyDialogString(hDlg, lpBZ->dwFlags, IDC_BZ_MESSAGE1, lpWindowName);
                OleStdFree(lpWindowName);
        }

        // Update icon with the system "exclamation" icon
        HICON hIcon = LoadIcon(NULL, IDI_EXCLAMATION);
        SendDlgItemMessage(hDlg, IDC_BZ_ICON, STM_SETICON, (WPARAM)hIcon, 0L);

        // Disable/Enable controls
        if ((lpBZ->dwFlags & BZ_DISABLECANCELBUTTON) ||
                (lpBZ->dwFlags & BZ_NOTRESPONDINGDIALOG))
        {
                // Disable cancel for "not responding" dialog
                StandardEnableDlgItem(hDlg, IDCANCEL, FALSE);
        }

        if (lpBZ->dwFlags & BZ_DISABLESWITCHTOBUTTON)
                StandardEnableDlgItem(hDlg, IDC_BZ_SWITCHTO, FALSE);

        if (lpBZ->dwFlags & BZ_DISABLERETRYBUTTON)
                StandardEnableDlgItem(hDlg, IDC_BZ_RETRY, FALSE);

        // Call the hook with lCustData in lParam
        UStandardHook((LPVOID)lpBZ, hDlg, WM_INITDIALOG, wParam, lpOBZ->lCustData);

        // Update caption if lpszCaption was specified
        if (lpBZ->lpOBZ->lpszCaption && !IsBadReadPtr(lpBZ->lpOBZ->lpszCaption, 1))
        {
                SetWindowText(hDlg, lpBZ->lpOBZ->lpszCaption);
        }
        return TRUE;
}

/*
 * BuildBusyDialogString
 *
 * Purpose:
 *  Builds the string that will be displayed in the dialog from the
 *  task name and window name parameters.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  dwFlags         DWORD containing flags passed into dialog
 *  iControl        Control ID to place the text string
 *  lpTaskName      LPSTR pointing to name of task (e.g. C:\TEST\TEST.EXE)
 *  lpWindowName    LPSTR for name of window
 *
 * Caveats:
 *  The caller of this function MUST de-allocate the lpTaskName and
 *  lpWindowName pointers itself with OleStdFree
 *
 * Return Value:
 *  void
 */
void BuildBusyDialogString(
        HWND hDlg, DWORD dwFlags, int iControl, LPTSTR lpWindowName)
{
        // Load the format string out of stringtable, choose a different
        // string depending on what flags are passed in to the dialog
        UINT uiStringNum;
        if (dwFlags & BZ_NOTRESPONDINGDIALOG)
                uiStringNum = IDS_BZRESULTTEXTNOTRESPONDING;
        else
                uiStringNum = IDS_BZRESULTTEXTBUSY;

        TCHAR szFormat[256];
        if (LoadString(_g_hOleStdResInst, uiStringNum, szFormat, 256) == 0)
                return;

        // Build the string. The format string looks like this:
        // "This action cannot be completed because the "%1" application
        // is [busy | not responding]. Choose \"Switch To\" to correct the
        // problem."

        TCHAR szMessage[512];
        FormatString1(szMessage, szFormat, lpWindowName);
        SetDlgItemText(hDlg, iControl, szMessage);
}

/*
 * GetTaskInfo()
 *
 * Purpose:  Gets information about the specified task and places the
 * module name, window name and top-level HWND for the task in the specified
 * pointers
 *
 * NOTE: The two string pointers allocated in this routine are
 * the responsibility of the CALLER to de-allocate.
 *
 * Parameters:
 *    hWnd             HWND who called this function
 *    htask            HTASK which we want to find out more info about
 *    lplpszTaskName   Location that the module name is returned
 *    lplpszWindowName Location where the window name is returned
 *
 */
BOOL GetTaskInfo(
        HWND hWnd, HTASK htask, LPTSTR* lplpszWindowName, HWND* lphWnd)
{
        if (htask == NULL)
                return FALSE;

        // initialize 'out' parameters
        *lplpszWindowName = NULL;

        // Now, enumerate top-level windows in system
        HWND hwndNext = GetWindow(hWnd, GW_HWNDFIRST);
        while (hwndNext)
        {
                // See if we can find a non-owned top level window whose
                // hInstance matches the one we just got passed.  If we find one,
                // we can be fairly certain that this is the top-level window for
                // the task which is blocked.
                DWORD dwProcessID;
                DWORD dwThreadID = GetWindowThreadProcessId(hwndNext, &dwProcessID);
                if ((hwndNext != hWnd) &&
                        (dwThreadID == HandleToUlong(htask)) &&
                        (IsWindowVisible(hwndNext)) && !GetWindow(hwndNext, GW_OWNER))
                {
                        // We found our window!  Alloc space for new strings
                        LPTSTR lpszWN;
                        if ((lpszWN = (LPTSTR)OleStdMalloc(MAX_PATH_SIZE)) == NULL)
                                break;

                        // We found the window we were looking for, copy info to
                        // local vars
                        GetWindowText(hwndNext, lpszWN, MAX_PATH);

                        // Note: the task name cannot be retrieved with the Win32 API.

                        // everything was successful. Set string pointers to point to our data.
                        *lplpszWindowName = lpszWN;
                        *lphWnd = hwndNext;
                        return TRUE;
                }
                hwndNext = GetWindow(hwndNext, GW_HWNDNEXT);
        }

        return FALSE;
}

/*
 * MakeWindowActive()
 *
 * Purpose: Makes specified window the active window.
 *
 */
void MakeWindowActive(HWND hWndSwitchTo)
{
        // If it's iconic, we need to restore it.
        if (IsIconic(hWndSwitchTo))
                ShowWindow(hWndSwitchTo, SW_RESTORE);

        // Move the new window to the top of the Z-order
        SetForegroundWindow(GetLastActivePopup(hWndSwitchTo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\dbgutil.cpp ===
/*************************************************************************
**
**    OLE 2.0 Common Utilities
**
**    dbgutil.h
**
**    This file contains file contains functions to support debug output.
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"

#ifdef _DEBUG

static int s_nDbgIndent = 0;        // indent level for debug message
static int s_nDbgLevel = 0;   // default dbg level printed

STDAPI_(void) OleDbgPrint(
	int     nDbgLvl,
	LPTSTR   lpszPrefix,
	LPTSTR   lpszMsg,
	int     nIndent)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintAlways(lpszPrefix, lpszMsg, nIndent);
}

STDAPI_(void) OleDbgPrintAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, int nIndent)
{
	if (nIndent < 0)
		OleDbgIndent(nIndent);

	if (lpszPrefix && *lpszPrefix != '\0')
	{
		OutputDebugString(TEXT("| "));
		for (int i = 0; i < s_nDbgIndent; i++)
			OutputDebugString(TEXT("----"));

		OutputDebugString(lpszPrefix);
		OutputDebugString(TEXT(": "));
	}

	OutputDebugString(lpszMsg);
	if (nIndent > 0)
		OleDbgIndent(nIndent);
}

STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl)
{
	s_nDbgLevel = nDbgLvl;
}

STDAPI_(int) OleDbgGetDbgLevel( void )
{
	return s_nDbgLevel;
}

STDAPI_(void) OleDbgIndent(int n)
{
	switch (n)
	{
	case -1:
		s_nDbgIndent--;
		break;
	case 1:
		s_nDbgIndent++;
		break;
	case -2:
		s_nDbgIndent = 0;
		break;
	}
}


STDAPI_(void) OleDbgPrintRefCnt(
		int         nDbgLvl,
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintRefCntAlways(lpszPrefix, lpszMsg, lpObj, refcnt);
}


STDAPI_(void) OleDbgPrintRefCntAlways(
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPVOID      lpObj,
		ULONG       refcnt)
{
	TCHAR szBuf[256];
	wsprintf(szBuf, TEXT("[obj=(0x%lx) cnt=%ld] %s"), lpObj, refcnt, lpszMsg);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}

STDAPI_(void) OleDbgPrintRect(
		int         nDbgLvl,
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPRECT      lpRect)
{
	if (nDbgLvl <= s_nDbgLevel)
		OleDbgPrintRectAlways(lpszPrefix, lpszMsg, lpRect);
}


STDAPI_(void) OleDbgPrintRectAlways(
		LPTSTR       lpszPrefix,
		LPTSTR       lpszMsg,
		LPRECT      lpRect)
{
	TCHAR szBuf[256];
	wsprintf(
		szBuf,
		TEXT("%s: (%d,%d)-(%d,%d) %dx%d\r\n"),
		lpszMsg,
		lpRect->left,
		lpRect->top,
		lpRect->right,
		lpRect->bottom,
		(lpRect->right-lpRect->left),
		(lpRect->bottom-lpRect->top)
	);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}


#define CASE_SCODE(sc)  \
	case sc: \
		pszErrName = TEXT(#sc); \
		break;

STDAPI_(void) OleDbgPrintScodeAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, SCODE sc)
{
	const TCHAR* pszErrName;

	switch (sc)
	{
	/* SCODE's defined in SCODE.H */

	CASE_SCODE(S_OK)
	CASE_SCODE(S_FALSE)
	CASE_SCODE(E_UNEXPECTED)
	CASE_SCODE(E_OUTOFMEMORY)
	CASE_SCODE(E_INVALIDARG)
	CASE_SCODE(E_NOINTERFACE)
	CASE_SCODE(E_POINTER)
	CASE_SCODE(E_HANDLE)
	CASE_SCODE(E_ABORT)
	CASE_SCODE(E_FAIL)
	CASE_SCODE(E_ACCESSDENIED)

	/* SCODE's defined in OLE2.H */

	CASE_SCODE(OLE_E_OLEVERB)
	CASE_SCODE(OLE_E_ADVF)
	CASE_SCODE(OLE_E_ENUM_NOMORE)
	CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
	CASE_SCODE(OLE_E_NOCONNECTION)
	CASE_SCODE(OLE_E_NOTRUNNING)
	CASE_SCODE(OLE_E_NOCACHE)
	CASE_SCODE(OLE_E_BLANK)
	CASE_SCODE(OLE_E_CLASSDIFF)
	CASE_SCODE(OLE_E_CANT_GETMONIKER)
	CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
	CASE_SCODE(OLE_E_STATIC)
	CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
	CASE_SCODE(OLE_E_INVALIDRECT)
	CASE_SCODE(OLE_E_WRONGCOMPOBJ)
	CASE_SCODE(OLE_E_INVALIDHWND)
	CASE_SCODE(OLE_E_NOT_INPLACEACTIVE)
	CASE_SCODE(OLE_E_CANTCONVERT)
	CASE_SCODE(OLE_E_NOSTORAGE)

	CASE_SCODE(DV_E_FORMATETC)
	CASE_SCODE(DV_E_DVTARGETDEVICE)
	CASE_SCODE(DV_E_STGMEDIUM)
	CASE_SCODE(DV_E_STATDATA)
	CASE_SCODE(DV_E_LINDEX)
	CASE_SCODE(DV_E_TYMED)
	CASE_SCODE(DV_E_CLIPFORMAT)
	CASE_SCODE(DV_E_DVASPECT)
	CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
	CASE_SCODE(DV_E_NOIVIEWOBJECT)

	CASE_SCODE(OLE_S_USEREG)
	CASE_SCODE(OLE_S_STATIC)
	CASE_SCODE(OLE_S_MAC_CLIPFORMAT)

	CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
	CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
	CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
	CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
	CASE_SCODE(CONVERT10_E_STG_FMT)
	CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
	CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
	CASE_SCODE(CONVERT10_S_NO_PRESENTATION)

	CASE_SCODE(CLIPBRD_E_CANT_OPEN)
	CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
	CASE_SCODE(CLIPBRD_E_CANT_SET)
	CASE_SCODE(CLIPBRD_E_BAD_DATA)
	CASE_SCODE(CLIPBRD_E_CANT_CLOSE)

	CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
	CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
	CASE_SCODE(DRAGDROP_E_INVALIDHWND)
	CASE_SCODE(DRAGDROP_S_DROP)
	CASE_SCODE(DRAGDROP_S_CANCEL)
	CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)

	CASE_SCODE(OLEOBJ_E_NOVERBS)
	CASE_SCODE(OLEOBJ_E_INVALIDVERB)
	CASE_SCODE(OLEOBJ_S_INVALIDVERB)
	CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
	CASE_SCODE(OLEOBJ_S_INVALIDHWND)
	CASE_SCODE(INPLACE_E_NOTUNDOABLE)
	CASE_SCODE(INPLACE_E_NOTOOLSPACE)
	CASE_SCODE(INPLACE_S_TRUNCATED)

	/* SCODE's defined in COMPOBJ.H */

	CASE_SCODE(CO_E_NOTINITIALIZED)
	CASE_SCODE(CO_E_ALREADYINITIALIZED)
	CASE_SCODE(CO_E_CANTDETERMINECLASS)
	CASE_SCODE(CO_E_CLASSSTRING)
	CASE_SCODE(CO_E_IIDSTRING)
	CASE_SCODE(CO_E_APPNOTFOUND)
	CASE_SCODE(CO_E_APPSINGLEUSE)
	CASE_SCODE(CO_E_ERRORINAPP)
	CASE_SCODE(CO_E_DLLNOTFOUND)
	CASE_SCODE(CO_E_ERRORINDLL)
	CASE_SCODE(CO_E_WRONGOSFORAPP)
	CASE_SCODE(CO_E_OBJNOTREG)
	CASE_SCODE(CO_E_OBJISREG)
	CASE_SCODE(CO_E_OBJNOTCONNECTED)
	CASE_SCODE(CO_E_APPDIDNTREG)
	CASE_SCODE(CLASS_E_NOAGGREGATION)
    CASE_SCODE(CLASS_E_CLASSNOTAVAILABLE)
	CASE_SCODE(REGDB_E_READREGDB)
	CASE_SCODE(REGDB_E_WRITEREGDB)
	CASE_SCODE(REGDB_E_KEYMISSING)
	CASE_SCODE(REGDB_E_INVALIDVALUE)
	CASE_SCODE(REGDB_E_CLASSNOTREG)
	CASE_SCODE(REGDB_E_IIDNOTREG)
	CASE_SCODE(RPC_E_CALL_REJECTED)
	CASE_SCODE(RPC_E_CALL_CANCELED)
	CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
	CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
	CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
	CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
	CASE_SCODE(RPC_E_SERVER_DIED)
	CASE_SCODE(RPC_E_CLIENT_DIED)
	CASE_SCODE(RPC_E_INVALID_DATAPACKET)
	CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
	CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
	CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
	CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
	CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
	CASE_SCODE(RPC_E_INVALID_DATA)
	CASE_SCODE(RPC_E_INVALID_PARAMETER)
	CASE_SCODE(RPC_E_UNEXPECTED)

	/* SCODE's defined in DVOBJ.H */

	CASE_SCODE(DATA_S_SAMEFORMATETC)
	CASE_SCODE(VIEW_E_DRAW)
	CASE_SCODE(VIEW_S_ALREADY_FROZEN)
	CASE_SCODE(CACHE_E_NOCACHE_UPDATED)
	CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
	CASE_SCODE(CACHE_S_SAMECACHE)
	CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)

	/* SCODE's defined in STORAGE.H */

	CASE_SCODE(STG_E_INVALIDFUNCTION)
	CASE_SCODE(STG_E_FILENOTFOUND)
	CASE_SCODE(STG_E_PATHNOTFOUND)
	CASE_SCODE(STG_E_TOOMANYOPENFILES)
	CASE_SCODE(STG_E_ACCESSDENIED)
	CASE_SCODE(STG_E_INVALIDHANDLE)
	CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
	CASE_SCODE(STG_E_INVALIDPOINTER)
	CASE_SCODE(STG_E_NOMOREFILES)
	CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
	CASE_SCODE(STG_E_SEEKERROR)
	CASE_SCODE(STG_E_WRITEFAULT)
	CASE_SCODE(STG_E_READFAULT)
	CASE_SCODE(STG_E_SHAREVIOLATION)
	CASE_SCODE(STG_E_LOCKVIOLATION)
	CASE_SCODE(STG_E_FILEALREADYEXISTS)
	CASE_SCODE(STG_E_INVALIDPARAMETER)
	CASE_SCODE(STG_E_MEDIUMFULL)
	CASE_SCODE(STG_E_ABNORMALAPIEXIT)
	CASE_SCODE(STG_E_INVALIDHEADER)
	CASE_SCODE(STG_E_INVALIDNAME)
	CASE_SCODE(STG_E_UNKNOWN)
	CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
	CASE_SCODE(STG_E_INVALIDFLAG)
	CASE_SCODE(STG_E_INUSE)
	CASE_SCODE(STG_E_NOTCURRENT)
	CASE_SCODE(STG_E_REVERTED)
	CASE_SCODE(STG_E_CANTSAVE)
	CASE_SCODE(STG_E_OLDFORMAT)
	CASE_SCODE(STG_E_OLDDLL)
	CASE_SCODE(STG_E_SHAREREQUIRED)
	CASE_SCODE(STG_E_NOTFILEBASEDSTORAGE)
	CASE_SCODE(STG_E_EXTANTMARSHALLINGS)
	CASE_SCODE(STG_S_CONVERTED)

	/* SCODE's defined in STORAGE.H */

	CASE_SCODE(MK_E_CONNECTMANUALLY)
	CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
	CASE_SCODE(MK_E_NEEDGENERIC)
	CASE_SCODE(MK_E_UNAVAILABLE)
	CASE_SCODE(MK_E_SYNTAX)
	CASE_SCODE(MK_E_NOOBJECT)
	CASE_SCODE(MK_E_INVALIDEXTENSION)
	CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
	CASE_SCODE(MK_E_NOTBINDABLE)
	CASE_SCODE(MK_E_NOTBOUND)
	CASE_SCODE(MK_E_CANTOPENFILE)
	CASE_SCODE(MK_E_MUSTBOTHERUSER)
	CASE_SCODE(MK_E_NOINVERSE)
	CASE_SCODE(MK_E_NOSTORAGE)
	CASE_SCODE(MK_E_NOPREFIX)
	CASE_SCODE(MK_S_REDUCED_TO_SELF)
	CASE_SCODE(MK_S_ME)
	CASE_SCODE(MK_S_HIM)
	CASE_SCODE(MK_S_US)
	CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)

	default:
		pszErrName = TEXT("UNKNOWN SCODE");
		break;
	}

	TCHAR szBuf[256];
	wsprintf(szBuf, TEXT("%s %s (0x%lx)\n"), lpszMsg, pszErrName, sc);
	OleDbgPrintAlways(lpszPrefix, szBuf, 0);
}

STDAPI OleStdAssert(LPTSTR lpstrExpr, LPTSTR lpstrMsg, LPTSTR lpstrFileName, UINT iLine)
{
	TCHAR buf[4096];
	wsprintf(buf, _T("Expr: %s Msg: (%s)\n")
		_T("File: %s, line: %ud"), lpstrExpr, lpstrMsg, lpstrFileName, iLine);
	int i = MessageBox(GetActiveWindow(), buf, _T("Assertion Failed!"),
		MB_TASKMODAL|MB_ABORTRETRYIGNORE);
	switch (i)
	{
	case IDABORT:
		ExitProcess((UINT)-3);
		break;

	case IDRETRY:
		#ifdef _X86_
			_asm int 3;
		#else
			DebugBreak();
		#endif
		break;
	}
	return NOERROR;
}

#endif //_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\convert.cpp ===
/*
 * CONVERT.CPP
 *
 * Implements the OleUIConvert function which invokes the complete
 * Convert dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include "utility.h"
#include "iconbox.h"

OLEDBGDATA

// Internally used structure
typedef struct tagCONVERT
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUICONVERT  lpOCV;   // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

        DWORD   dwFlags;            // Flags passed in
        HWND    hListVisible;       // listbox that is currently visible
        HWND    hListInvisible;     // listbox that is currently hidden
        CLSID   clsid;              // Class ID sent in to dialog: IN only
        DWORD   dvAspect;
        BOOL    fCustomIcon;
        UINT    IconIndex;          // index (in exe) of current icon
        LPTSTR  lpszIconSource;     // path to current icon source
        LPTSTR  lpszCurrentObject;
        LPTSTR  lpszConvertDefault;
        LPTSTR  lpszActivateDefault;

} CONVERT, *PCONVERT, FAR *LPCONVERT;

// Internal function prototypes
// CONVERT.CPP

INT_PTR CALLBACK ConvertDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FConvertInit(HWND hDlg, WPARAM, LPARAM);
void SetConvertResults(HWND, LPCONVERT);
UINT FillClassList(CLSID clsid, HWND hList, HWND hListInvisible,
        LPTSTR FAR *lplpszCurrentClass, BOOL fIsLinkedObject, WORD wFormat,
        UINT cClsidExclude, LPCLSID lpClsidExclude, BOOL bAddSameClass);
BOOL FormatIncluded(LPTSTR szStringToSearch, WORD wFormat);
void SwapWindows(HWND, HWND, HWND);
void ConvertCleanup(HWND hDlg, LPCONVERT lpCV);
static void UpdateClassIcon(HWND hDlg, LPCONVERT lpCV, HWND hList);

/*
 * OleUIConvert
 *
 * Purpose:
 *  Invokes the standard OLE Change Type dialog box allowing the user
 *  to change the type of the single specified object, or change the
 *  type of all OLE objects of a specified type.
 *
 * Parameters:
 *  lpCV            LPOLEUICONVERT pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */
STDAPI_(UINT) OleUIConvert(LPOLEUICONVERT lpCV)
{
        HGLOBAL  hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCV, sizeof(OLEUICONVERT),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        if (lpCV->hMetaPict != NULL && !IsValidMetaPict(lpCV->hMetaPict))
        {
            return(OLEUI_CTERR_HMETAPICTINVALID);
        }

        if ((lpCV->dwFlags & CF_SETCONVERTDEFAULT)
                 && (!IsValidClassID(lpCV->clsidConvertDefault)))
           uRet = OLEUI_CTERR_CLASSIDINVALID;

        if ((lpCV->dwFlags & CF_SETACTIVATEDEFAULT)
                 && (!IsValidClassID(lpCV->clsidActivateDefault)))
           uRet = OLEUI_CTERR_CLASSIDINVALID;

        if ((lpCV->dvAspect != DVASPECT_ICON) && (lpCV->dvAspect != DVASPECT_CONTENT))
           uRet = OLEUI_CTERR_DVASPECTINVALID;

        if ((lpCV->wFormat >= CF_CLIPBOARDMIN) && (lpCV->wFormat <= CF_CLIPBOARDMAX))
        {
                TCHAR szTemp[8];
                if (0 == GetClipboardFormatName(lpCV->wFormat, szTemp, 8))
                        uRet = OLEUI_CTERR_CBFORMATINVALID;
        }

        if ((NULL != lpCV->lpszUserType)
                && (IsBadReadPtr(lpCV->lpszUserType, 1)))
                uRet = OLEUI_CTERR_STRINGINVALID;

        if ( (NULL != lpCV->lpszDefLabel)
                && (IsBadReadPtr(lpCV->lpszDefLabel, 1)) )
                uRet = OLEUI_CTERR_STRINGINVALID;

        if (0 != lpCV->cClsidExclude &&
                IsBadReadPtr(lpCV->lpClsidExclude, lpCV->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        UINT nIDD;
        if (!bWin4)
                nIDD = lpCV->dwFlags & CF_CONVERTONLY ? IDD_CONVERTONLY : IDD_CONVERT;
        else
                nIDD = lpCV->dwFlags & CF_CONVERTONLY ? IDD_CONVERTONLY4 : IDD_CONVERT4;

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(ConvertDialogProc, (LPOLEUISTANDARD)lpCV,
                hMemDlg, MAKEINTRESOURCE(nIDD));
        return uRet;
}

/*
 * ConvertDialogProc
 *
 * Purpose:
 *  Implements the OLE Convert dialog as invoked through the
 *  OleUIConvert function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 *
 */
INT_PTR CALLBACK ConvertDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPCONVERT lpCV = (LPCONVERT)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        //If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        //Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
                PostMessage(lpCV->lpOCV->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpCV)
            {
                ConvertCleanup(hDlg, lpCV);
                StandardCleanup(lpCV, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FConvertInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_CV_ACTIVATELIST:
                case IDC_CV_CONVERTLIST:
                        switch (wCode)
                        {
                        case LBN_SELCHANGE:
                                // Change "Results" window to reflect current selection
                                SetConvertResults(hDlg, lpCV);

                                // Update the icon we display, if in display as icon mode
                                if ((lpCV->dwFlags & CF_SELECTCONVERTTO) &&
                                         lpCV->dvAspect == DVASPECT_ICON && !lpCV->fCustomIcon)
                                {
                                        UpdateClassIcon(hDlg, lpCV, hWndMsg);
                                }
                                break;

                        case LBN_DBLCLK:
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                break;
                        }
                        break;

                case IDC_CV_CONVERTTO:
                case IDC_CV_ACTIVATEAS:
                        {
                                HWND hList = lpCV->hListVisible;
                                HWND hListInvisible = lpCV->hListInvisible;

                                if (IDC_CV_CONVERTTO == wParam)
                                {
                                        // User just click on the button again - it was
                                        // already selected.
                                        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
                                                break;

                                        // If we're working with a linked object, don't
                                        // add the activate list - just the object's
                                        // class should appear in the listbox.
                                        SwapWindows(hDlg,  hList, hListInvisible);

                                        lpCV->hListVisible = hListInvisible;
                                        lpCV->hListInvisible = hList;

                                        EnableWindow(lpCV->hListInvisible, FALSE);
                                        EnableWindow(lpCV->hListVisible, TRUE);

                                        // Update our flags.
                                        lpCV->dwFlags &= ~CF_SELECTACTIVATEAS;
                                        lpCV->dwFlags |= CF_SELECTCONVERTTO;
                                }
                                else
                                {
                                        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
                                                break;

                                        SwapWindows(hDlg, hList, hListInvisible);

                                        lpCV->hListVisible = hListInvisible;
                                        lpCV->hListInvisible = hList;

                                        EnableWindow(lpCV->hListInvisible, FALSE);
                                        EnableWindow(lpCV->hListVisible, TRUE);

                                        // Update our flags.
                                        lpCV->dwFlags |= CF_SELECTACTIVATEAS;
                                        lpCV->dwFlags &= ~CF_SELECTCONVERTTO;
                                }

                                LRESULT lRetVal;
                                if (lpCV->dwFlags & CF_SELECTCONVERTTO)
                                        lRetVal = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszConvertDefault);
                                else
                                        lRetVal = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszActivateDefault);

                                if (LB_ERR == lRetVal)
                                {
                                        TCHAR szCurrentObject[40];
                                        GetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, szCurrentObject, 40);
                                        SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)szCurrentObject);
                                }

                                // Turn updates back on.
                                SendMessage(hDlg, WM_SETREDRAW, TRUE, 0L);

                                InvalidateRect(lpCV->hListVisible, NULL, TRUE);
                                UpdateWindow(lpCV->hListVisible);

                                if ((lpCV->dvAspect & DVASPECT_ICON) && (lpCV->dwFlags & CF_SELECTCONVERTTO))
                                        UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);

                                // Hide the icon stuff when Activate is selected...show
                                // it again when Convert is selected.
                                BOOL fState = ((lpCV->dwFlags & CF_SELECTACTIVATEAS) ||
                                                  (lpCV->dwFlags & CF_DISABLEDISPLAYASICON)) ?
                                                  SW_HIDE : SW_SHOW;

                                StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, fState);

                                // Only display the icon if convert is selected AND
                                // display as icon is checked.
                                if ((SW_SHOW==fState) && (DVASPECT_ICON!=lpCV->dvAspect))
                                   fState = SW_HIDE;

                                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, fState);
                                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, fState);

                                SetConvertResults(hDlg, lpCV);
                        }
                        break;

                case IDOK:
                        {
                                // Set output flags to current ones
                                lpCV->lpOCV->dwFlags = lpCV->dwFlags;

                                // Update the dvAspect and fObjectsIconChanged members
                                // as appropriate.
                                if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
                                {
                                        // DON'T update aspect if activate as was selected.
                                        lpCV->lpOCV->fObjectsIconChanged = FALSE;
                                }
                                else
                                        lpCV->lpOCV->dvAspect = lpCV->dvAspect;

                                // Get the new clsid
                                TCHAR szBuffer[256];
                                LRESULT iCurSel = SendMessage(lpCV->hListVisible, LB_GETCURSEL, 0, 0);
                                SendMessage(lpCV->hListVisible, LB_GETTEXT, iCurSel, (LPARAM)szBuffer);

                                LPTSTR lpszCLSID = PointerToNthField(szBuffer, 2, '\t');
#if defined(WIN32) && !defined(UNICODE)
                                OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
                                ATOW(wszCLSID, lpszCLSID, OLEUI_CCHKEYMAX);
                                CLSIDFromString(wszCLSID, (&(lpCV->lpOCV->clsidNew)));
#else
                                CLSIDFromString(lpszCLSID, (&(lpCV->lpOCV->clsidNew)));
#endif

                                // Free the hMetaPict we got in.
                                OleUIMetafilePictIconFree(lpCV->lpOCV->hMetaPict);

                                // Get the hMetaPict (if display as icon is checked)
                                if (DVASPECT_ICON == lpCV->dvAspect)
                                        lpCV->lpOCV->hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                else
                                        lpCV->lpOCV->hMetaPict = (HGLOBAL)NULL;

                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        }
                        break;

                case IDCANCEL:
                        {
                            HGLOBAL hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                            OleUIMetafilePictIconFree(hMetaPict);
                            SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        }
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpCV->lpOCV->hWndOwner,
                                uMsgHelp, (WPARAM)hDlg, MAKELPARAM(IDD_CONVERT, 0));
                        break;

                case IDC_CV_DISPLAYASICON:
                        {
                                BOOL fCheck = IsDlgButtonChecked(hDlg, wID);
                                if (fCheck)
                                        lpCV->dvAspect = DVASPECT_ICON;
                                else
                                        lpCV->dvAspect = DVASPECT_CONTENT;

                                if (fCheck && !lpCV->fCustomIcon)
                                        UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);

                                // Show or hide the icon depending on the check state.
                                int i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
                                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, i);
                                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, i);
                                SetConvertResults(hDlg, lpCV);
                        }
                        break;

                case IDC_CV_CHANGEICON:
                        {
                                // Initialize the structure for the hook.
                                OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));

                                ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                        IDC_CV_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                ci.cbStruct = sizeof(ci);
                                ci.hWndOwner= hDlg;
                                ci.dwFlags  = CIF_SELECTCURRENT;

                                // Only show help if we're showing it for this dialog.
                                if (lpCV->dwFlags & CF_SHOWHELPBUTTON)
                                        ci.dwFlags |= CIF_SHOWHELP;

                                int iSel = (INT)SendMessage(lpCV->hListVisible, LB_GETCURSEL, 0, 0);

                                // Get whole string
                                LPTSTR pszString = (LPTSTR)OleStdMalloc(
                                        OLEUI_CCHLABELMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);

                                SendMessage(lpCV->hListVisible, LB_GETTEXT, iSel, (LPARAM)pszString);

                                // Set pointer to CLSID (string)
                                LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');

                                // Get the clsid to pass to change icon.
#if defined(WIN32) && !defined(UNICODE)
                                OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
                                ATOW(wszCLSID, pszCLSID, OLEUI_CCHKEYMAX);
                                CLSIDFromString(wszCLSID, &(ci.clsid));
#else
                                CLSIDFromString(pszCLSID, &(ci.clsid));
#endif
                                OleStdFree(pszString);

                                // Let the hook in to customize Change Icon if desired.
                                uRet = UStandardHook(lpCV, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

                                if (0 == uRet)
                                        uRet= (OLEUI_OK == OleUIChangeIcon(&ci));

                                // Update the display if necessary.
                                if (0 != uRet)
                                {
                                        SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET, 0,
                                                (LPARAM)ci.hMetaPict);

                                        // Update our custom/default flag
                                        if (ci.dwFlags & CIF_SELECTDEFAULT)
                                                lpCV->fCustomIcon = FALSE;   // we're in default mode (icon changes on each LB selchange)
                                        else if (ci.dwFlags & CIF_SELECTFROMFILE)
                                                lpCV->fCustomIcon = TRUE;    // we're in custom mode (icon doesn't change)

                                        // no change in fCustomIcon if user selected current
                                        lpCV->lpOCV->fObjectsIconChanged = TRUE;
                                }
                        }
                        break;
                }
                break;
        }

        return FALSE;
}

/*
 * FConvertInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Convert dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FConvertInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;  // non-bold version of dialog's font
        LPCONVERT lpCV = (LPCONVERT)LpvStandardInit(hDlg, sizeof(CONVERT), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpCV)
                return FALSE;

        LPOLEUICONVERT lpOCV = (LPOLEUICONVERT)lParam;
        lpCV->lpOCV = lpOCV;
        lpCV->nIDD = IDD_CONVERT;
        lpCV->fCustomIcon = FALSE;

        // Copy other information from lpOCV that we might modify.
        lpCV->dwFlags = lpOCV->dwFlags;
        lpCV->clsid = lpOCV->clsid;
        lpCV->dvAspect = lpOCV->dvAspect;
        lpCV->hListVisible = GetDlgItem(hDlg, IDC_CV_ACTIVATELIST);
        lpCV->hListInvisible = GetDlgItem(hDlg, IDC_CV_CONVERTLIST);
        OleDbgAssert(lpCV->hListInvisible != NULL);
        lpCV->lpszCurrentObject = lpOCV->lpszUserType;
        lpOCV->clsidNew = CLSID_NULL;
        lpOCV->fObjectsIconChanged = FALSE;

        lpCV->lpszConvertDefault = (LPTSTR)OleStdMalloc(OLEUI_CCHLABELMAX_SIZE);
        lpCV->lpszActivateDefault = (LPTSTR)OleStdMalloc(OLEUI_CCHLABELMAX_SIZE);
        lpCV->lpszIconSource = (LPTSTR)OleStdMalloc(MAX_PATH_SIZE);

		if ((lpCV->lpszConvertDefault == NULL)  ||
			(lpCV->lpszActivateDefault == NULL) ||
		    (lpCV->lpszIconSource == NULL))
		{
			if (lpCV->lpszConvertDefault != NULL)
				OleStdFree (lpCV->lpszConvertDefault);
			if (lpCV->lpszActivateDefault != NULL)
				OleStdFree (lpCV->lpszActivateDefault);
			if (lpCV->lpszIconSource != NULL)
				OleStdFree (lpCV->lpszIconSource);
			
			// Gonna kill the window...
			PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
			return FALSE;
		}

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_CV_OBJECTTYPE, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_CV_RESULTTEXT, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Hide the help button if necessary
        if (!(lpCV->dwFlags & CF_SHOWHELPBUTTON))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpCV->dwFlags & CF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_CV_CHANGEICON));

        // Fill the Object Type listbox with entries from the reg DB.
        UINT nRet = FillClassList(lpOCV->clsid, lpCV->hListVisible,
                lpCV->hListInvisible, &(lpCV->lpszCurrentObject),
                lpOCV->fIsLinkedObject, lpOCV->wFormat,
                lpOCV->cClsidExclude, lpOCV->lpClsidExclude,
                !(lpCV->dwFlags & CF_CONVERTONLY));

        if (nRet == -1)
        {
                // bring down dialog if error when filling list box
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
        }

        // Set the name of the current object.
        SetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, lpCV->lpszCurrentObject);

        // Disable the "Activate As" button if the Activate list doesn't
        // have any objects in it.
        int cItemsActivate = (INT)SendMessage(lpCV->hListVisible, LB_GETCOUNT, 0, 0L);
        if (1 >= cItemsActivate || (lpCV->dwFlags & CF_DISABLEACTIVATEAS))
                StandardEnableDlgItem(hDlg, IDC_CV_ACTIVATEAS, FALSE);

        // Set the tab width in the list to push all the tabs off the side.
        RECT rect;
        if (lpCV->hListVisible != NULL)
                GetClientRect(lpCV->hListVisible, &rect);
        else
                GetClientRect(lpCV->hListInvisible, &rect);
        DWORD dw = GetDialogBaseUnits();
        rect.right = (8*rect.right)/LOWORD(dw);  //Convert pixels to 2x dlg units.
        if (lpCV->hListVisible != NULL)
                SendMessage(lpCV->hListVisible, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)(&rect.right));
        SendMessage(lpCV->hListInvisible, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)(&rect.right));

        // Make sure that either "Convert To" or "Activate As" is selected
        // and initialize listbox contents and selection accordingly
        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
        {
                // Don't need to adjust listbox here because FillClassList
                // initializes to the "Activate As" state.
                CheckRadioButton(hDlg, IDC_CV_CONVERTTO, IDC_CV_ACTIVATEAS, IDC_CV_ACTIVATEAS);

                // Hide the icon stuff when Activate is selected...it gets shown
                // again when Convert is selected.
                StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
        }
        else
        {
                // Default case.  If user hasn't selected either flag, we will
                // come here anyway.
                // swap listboxes.

                HWND hWndTemp = lpCV->hListVisible;

                if (lpCV->dwFlags & CF_DISABLEDISPLAYASICON)
                {
                        StandardShowDlgItem(hDlg, IDC_CV_DISPLAYASICON, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
                }

                lpCV->dwFlags |= CF_SELECTCONVERTTO; // Make sure flag is set
                if (!(lpCV->dwFlags & CF_CONVERTONLY))
                        CheckRadioButton(hDlg, IDC_CV_CONVERTTO, IDC_CV_ACTIVATEAS, IDC_CV_CONVERTTO);

                SwapWindows(hDlg, lpCV->hListVisible, lpCV->hListInvisible);

                lpCV->hListVisible = lpCV->hListInvisible;
                lpCV->hListInvisible = hWndTemp;

                if (lpCV->hListInvisible)
                        EnableWindow(lpCV->hListInvisible, FALSE);
                EnableWindow(lpCV->hListVisible, TRUE);
        }

        // Initialize Default strings.

        // Default convert string is easy...just user the user type name from
        // the clsid we got, or the current object
        if ((lpCV->dwFlags & CF_SETCONVERTDEFAULT)
                 && (IsValidClassID(lpCV->lpOCV->clsidConvertDefault)))
        {
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(lpCV->lpOCV->clsidConvertDefault, USERCLASSTYPE_FULL,
                        &lpszTemp) == NOERROR)
                {
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpCV->lpszConvertDefault, lpszTemp, OLEUI_CCHLABELMAX);
#else
                        lstrcpyn(lpCV->lpszConvertDefault, lpszTemp, OLEUI_CCHLABELMAX);
#endif
                        OleStdFree(lpszTemp);
                }
                else
                {
                   lstrcpy(lpCV->lpszConvertDefault, lpCV->lpszCurrentObject);
                }
        }
        else
                lstrcpy(lpCV->lpszConvertDefault, 
						(lpCV->lpszCurrentObject ? lpCV->lpszCurrentObject : TEXT("")));


        // Default activate is a bit trickier.  We want to use the user type
        // name if from the clsid we got (assuming we got one), or the current
        // object if it fails or we didn't get a clsid.  But...if there's a
        // Treat As entry in the reg db, then we use that instead.  So... the
        // logic boils down to this:
        //
        // if ("Treat As" in reg db)
        //    use it;
        // else
        //    if (CF_SETACTIVATEDEFAULT)
        //      use it;
        //    else
        //      use current object;

        HKEY hKey;
        LONG lRet = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hKey);
        LPARAM lpRet;

        if (lRet != ERROR_SUCCESS)
                goto CheckInputFlag;

        LPOLESTR lpszCLSID;
        StringFromCLSID(lpCV->lpOCV->clsid, &lpszCLSID);
        TCHAR szKey[OLEUI_CCHKEYMAX];
#if defined(WIN32) && !defined(UNICODE)
        WTOA(szKey, lpszCLSID, OLEUI_CCHKEYMAX);
#else
        lstrcpy(szKey, lpszCLSID);
#endif
        lstrcat(szKey, TEXT("\\TreatAs"));
        OleStdFree(lpszCLSID);

        TCHAR szValue[OLEUI_CCHKEYMAX];
        dw = OLEUI_CCHKEYMAX_SIZE;
        lRet = RegQueryValue(hKey, szKey, szValue, (LONG*)&dw);

        CLSID clsid;
        if (lRet != ERROR_SUCCESS)
        {
                RegCloseKey(hKey);
                goto CheckInputFlag;
        }
        else
        {
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszValue[OLEUI_CCHKEYMAX];
                ATOW(wszValue,szValue,OLEUI_CCHKEYMAX);
                CLSIDFromString(wszValue, &clsid);
#else
                CLSIDFromString(szValue, &clsid);
#endif
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &lpszTemp) == NOERROR)
                {
						if (lpCV->lpszActivateDefault)
						{
#if defined(WIN32) && !defined(UNICODE)
                            WTOA(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
#else
                            lstrcpyn(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
#endif
						}
                        OleStdFree(lpszTemp);
                }
                else
                {
                        RegCloseKey(hKey);
                        goto CheckInputFlag;
                }
        }
        RegCloseKey(hKey);
        goto SelectStringInListbox;

CheckInputFlag:
        if ((lpCV->dwFlags & CF_SETACTIVATEDEFAULT)
                 && (IsValidClassID(lpCV->lpOCV->clsidActivateDefault)))
        {
                LPOLESTR lpszTemp = NULL;
                if (OleRegGetUserType(lpCV->lpOCV->clsidActivateDefault, USERCLASSTYPE_FULL,
                        &lpszTemp) == NOERROR)
                {
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
#else
                        lstrcpyn(lpCV->lpszActivateDefault, lpszTemp, OLEUI_CCHLABELMAX);
#endif
                        OleStdFree(lpszTemp);
                }
                else
                {
                   lstrcpy(lpCV->lpszActivateDefault, lpCV->lpszCurrentObject);
                }
        }
        else
			if ((lpCV->lpszActivateDefault) && (lpCV->lpszCurrentObject))
                lstrcpy((lpCV->lpszActivateDefault), lpCV->lpszCurrentObject);



SelectStringInListbox:
        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
           lpRet = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszConvertDefault);
        else
           lpRet = SendMessage(lpCV->hListVisible, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)lpCV->lpszActivateDefault);

        if (LB_ERR == lpRet)
           SendMessage(lpCV->hListVisible, LB_SETCURSEL, (WPARAM)0, 0L);

        if ((HGLOBAL)NULL != lpOCV->hMetaPict)
        {
                HGLOBAL hMetaPict = OleDuplicateData(lpOCV->hMetaPict, CF_METAFILEPICT, NULL);
                SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET,
                        0, (LPARAM)hMetaPict);
                lpCV->fCustomIcon = TRUE;
        }
        else
        {
                UpdateClassIcon(hDlg, lpCV, lpCV->hListVisible);
        }

        // Initialize icon stuff
        if (DVASPECT_ICON == lpCV->dvAspect )
        {
                SendDlgItemMessage(hDlg, IDC_CV_DISPLAYASICON, BM_SETCHECK, TRUE, 0L);
        }
        else
        {
                // Hide & disable icon stuff
                StandardShowDlgItem(hDlg, IDC_CV_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_CV_ICONDISPLAY, SW_HIDE);
        }

        // Call the hook with lCustData in lParam
        UStandardHook((LPVOID)lpCV, hDlg, WM_INITDIALOG, wParam, lpOCV->lCustData);

        // Update results window
        SetConvertResults(hDlg, lpCV);

        // Update caption if lpszCaption was specified
        if (lpCV->lpOCV->lpszCaption && !IsBadReadPtr(lpCV->lpOCV->lpszCaption, 1))
        {
                SetWindowText(hDlg, lpCV->lpOCV->lpszCaption);
        }

        return TRUE;
}

/*
 * FillClassList
 *
 * Purpose:
 *  Enumerates available OLE object classes from the registration
 *  database that we can convert or activate the specified clsid from.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  clsid           Class ID for class to find convert classes for
 *  hList           HWND to the listbox to fill.
 *  hListActivate   HWND to invisible listbox that stores "activate as" list.
 *  lpszClassName   LPSTR to put the (hr) class name of the clsid; we
 *                  do it here since we've already got the reg db open.
 *  fIsLinkedObject BOOL is the original object a linked object
 *  wFormat         WORD specifying the format of the original class.
 *  cClsidExclude   UINT number of entries in exclude list
 *  lpClsidExclude  LPCLSID array classes to exclude for list
 *
 * Return Value:
 *  UINT            Number of strings added to the listbox, -1 on failure.
 */
UINT FillClassList(CLSID clsid, HWND hListActivate, HWND hListConvert,
        LPTSTR FAR *lplpszCurrentClass, BOOL fIsLinkedObject,
        WORD wFormat, UINT cClsidExclude, LPCLSID lpClsidExclude, BOOL bAddSameClass)
{
        // Clean out the existing strings.
        if (hListActivate)
                SendMessage(hListActivate, LB_RESETCONTENT, 0, 0L);

        OleDbgAssert(hListConvert != NULL);
        SendMessage(hListConvert, LB_RESETCONTENT, 0, 0L);

        // Open up the root key.
        HKEY hKey;
        LONG lRet = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hKey);
        LPARAM lpRet;

        if (ERROR_SUCCESS != lRet)
                return (UINT)-1;

        if (NULL == *lplpszCurrentClass)
        {
#if defined(WIN32) && !defined(UNICODE)
                LPOLESTR wszCurrentClass;
                if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &wszCurrentClass) != NOERROR)
#else
                if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, lplpszCurrentClass) != NOERROR)
#endif
                {
                        *lplpszCurrentClass = OleStdLoadString(_g_hOleStdResInst, IDS_PSUNKNOWNTYPE);
                        if (*lplpszCurrentClass == NULL)
                        {
                                RegCloseKey(hKey);
                                return (UINT)-1;
                        }
                }
#if defined(WIN32) && !defined(UNICODE)
                else
                {
                    UINT uLen = WTOALEN(wszCurrentClass);
                    *lplpszCurrentClass = (LPTSTR)OleStdMalloc(uLen);
                    if (NULL == *lplpszCurrentClass)
                    {
                        RegCloseKey(hKey);
                        OleStdFree(wszCurrentClass);
                        return (UINT)-1;
                    }
                    WTOA(*lplpszCurrentClass, wszCurrentClass, uLen);
                    OleStdFree(wszCurrentClass);
                }
#endif
        }

        // Get the class name of the original class.
        LPTSTR lpszCLSID;
#if defined(WIN32) && !defined(UNICODE)
        // This code does not report allocation errors because neither did
        // the original code before I extended it to support 32-bit ANSI builds.
        // (NOTE that the result of StringFromCLSID is never checked against
        // NULL after the #else case below, which contains the original code.)
        // In any event, if OleStdMalloc returns NULL, then the string will
        // simply be lost. Technically an error, but not a fatal one.
        LPOLESTR wszCLSID;
        StringFromCLSID(clsid, &wszCLSID);
        lpszCLSID = NULL;
        if (NULL != wszCLSID)
        {
            UINT uLen = WTOALEN(wszCLSID);
            lpszCLSID = (LPTSTR) OleStdMalloc(uLen);
            if (NULL != lpszCLSID)
            {
                WTOA(lpszCLSID, wszCLSID, uLen);
            }
            OleStdFree(wszCLSID);
        }
#else
        StringFromCLSID(clsid, &lpszCLSID);
#endif
        // Here, we step through the entire registration db looking for
        // class that can read or write the original class' format.  We
        // maintain two lists - an activate list and a convert list.  The
        // activate list is a subset of the convert list - activate == read/write
        // and convert == read. We swap the listboxes as needed with
        // SwapWindows, and keep track of which is which in the lpCV structure.

        // Every item has the following format:
        //
        //     Class Name\tclsid\0

        UINT cStrings = 0;
        TCHAR szClass[OLEUI_CCHKEYMAX];
        lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        TCHAR szFormatKey[OLEUI_CCHKEYMAX];
        TCHAR szFormat[OLEUI_CCHKEYMAX];
        TCHAR szHRClassName[OLEUI_CCHKEYMAX];
        CLSID clsidForList;

        while (ERROR_SUCCESS == lRet)
        {
                UINT j;
                BOOL fExclude = FALSE;                

                //Check if this CLSID is in the exclusion list.
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszClass[OLEUI_CCHKEYMAX];
                ATOW(wszClass, szClass, OLEUI_CCHKEYMAX);
                HRESULT hr = CLSIDFromString(wszClass, &clsidForList);
#else
                HRESULT hr = CLSIDFromString(szClass, &clsidForList);
#endif
                if (SUCCEEDED(hr))
                {
                    for (j = 0; j < cClsidExclude; j++)
                    {
                        if (IsEqualCLSID(clsidForList, lpClsidExclude[j]))
                        {
                            fExclude=TRUE;
                            break;
                        }
                    }
                    if (fExclude)
                        goto Next;   // don't add this class to list
                }

                // Check for a \Conversion\Readwritable\Main - if its
                // readwriteable, then the class can be added to the ActivateAs
                // list.
                // NOTE: the presence of this key should NOT automatically be
                //       used to add the class to the CONVERT list.

                lstrcpy(szFormatKey, szClass);
                lstrcat(szFormatKey, TEXT("\\Conversion\\Readwritable\\Main"));

                DWORD dw; dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                {
                        // Here, we've got a list of formats that this class can read
                        // and write. We need to see if the original class' format is
                        // in this list.  We do that by looking for wFormat in
                        // szFormat - if it in there, then we add this class to the
                        // ACTIVATEAS list only. we do NOT automatically add it to the
                        // CONVERT list. Readable and Readwritable format lists should
                        // be handled separately.

                        dw=OLEUI_CCHKEYMAX_SIZE;
                        lRet=RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && hListActivate != NULL)
                        {
                                // only add if not already in list
                                lstrcat(szHRClassName, TEXT("\t"));
                                if (LB_ERR == SendMessage(hListActivate, LB_FINDSTRING, 0, (LPARAM)szHRClassName))
                                {
                                        lstrcat(szHRClassName, szClass);
                                        SendMessage(hListActivate, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                                }
                        }
                }

                // Here we'll check to see if the original class' format is in the
                // readable list. if so, we will add the class to the CONVERTLIST

                // We've got a special case for a linked object here.
                // If an object is linked, then the only class that
                // should appear in the convert list is the object's
                // class.  So, here we check to see if the object is
                // linked.  If it is, then we compare the classes.  If
                // they aren't the same, then we just go to the next key.

                if (!fIsLinkedObject || lstrcmp(lpszCLSID, szClass) == 0)
                {
                        //Check for a \Conversion\Readable\Main entry
                        lstrcpy(szFormatKey, szClass);
                        lstrcat(szFormatKey, TEXT("\\Conversion\\Readable\\Main"));

                        // Check to see if this class can read the original class
                        // format.  If it can, add the string to the listbox as
                        // CONVERT_LIST.

                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                        {
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);

                                if (ERROR_SUCCESS == lRet)
                                {
                                        // only add if not already in list
                                        lstrcat(szHRClassName, TEXT("\t"));
                                        if (LB_ERR == SendMessage(hListConvert, LB_FINDSTRING, 0, (LPARAM)szHRClassName))
                                        {
                                                lstrcat(szHRClassName, szClass);
                                                SendMessage(hListConvert, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                                        }
                                }
                        }
                }
Next:
                //Continue with the next key.
                lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        }  // end while

        // If the original class isn't already in the list, add it.
        if (bAddSameClass)
        {
                lstrcpy(szHRClassName, *lplpszCurrentClass);
                lstrcat(szHRClassName, TEXT("\t"));
                lstrcat(szHRClassName, lpszCLSID);

                if (hListActivate != NULL)
                {
                        // only add it if it's not there already.
                        lpRet = SendMessage(hListActivate, LB_FINDSTRING, (WPARAM)-1, (LPARAM)szHRClassName);
                        if (LB_ERR == lpRet)
                                SendMessage(hListActivate, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
                }

                // only add it if it's not there already.
                lpRet = SendMessage(hListConvert, LB_FINDSTRING, (WPARAM)-1, (LPARAM)szHRClassName);
                if (LB_ERR == lpRet)
                        SendMessage(hListConvert, LB_ADDSTRING, 0, (LPARAM)szHRClassName);
        }

        // Free the string we got from StringFromCLSID.
        OleStdFree(lpszCLSID);
        RegCloseKey(hKey);

        return cStrings;        // return # of strings added
}

/*
 * OleUICanConvertOrActivateAs
 *
 * Purpose:
 *  Determine if there is any OLE object class from the registration
 *  database that we can convert or activate the specified clsid from.
 *
 * Parameters:
 *  rClsid          REFCLSID Class ID for class to find convert classes for
 *  fIsLinkedObject BOOL is the original object a linked object
 *  wFormat         WORD specifying the format of the original class.
 *
 * Return Value:
 *  BOOL            TRUE if Convert command should be enabled, else FALSE
 */
STDAPI_(BOOL) OleUICanConvertOrActivateAs(
        REFCLSID rClsid, BOOL fIsLinkedObject, WORD wFormat)
{
        // Open up the root key.
        HKEY hKey;
        HRESULT hr;
        LONG lRet = RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hKey);

        if (ERROR_SUCCESS != lRet)
                return FALSE;

        // Get the class name of the original class.
        LPTSTR lpszCLSID = NULL;
#if defined(WIN32) && !defined(UNICODE)
        // This code does not report allocation errors because neither did
        // the original code before I extended it to support 32-bit ANSI builds.
        // In any event, if OleStdMalloc returns NULL, then the string will
        // simply be lost. Technically an error, but not a fatal one.
        // Since this routine has no way to report errors anyway (a design flaw
        // IMHO) I consider this to be marginally acceptable.
        LPOLESTR wszCLSID;
        StringFromCLSID(rClsid, &wszCLSID);
        lpszCLSID = NULL;
        if (NULL != wszCLSID)
        {
            UINT uLen = WTOALEN(wszCLSID);
            lpszCLSID = (LPTSTR) OleStdMalloc(uLen);
            if (NULL != lpszCLSID)
            {
                WTOA(lpszCLSID, wszCLSID, uLen);
            }
            OleStdFree(wszCLSID);
        }
#else
        hr = StringFromCLSID(rClsid, &lpszCLSID);
#endif
	if (FAILED(hr) || lpszCLSID == NULL) //out of memory, most likely
	    return FALSE;

        // Here, we step through the entire registration db looking for
        // class that can read or write the original class' format.
        // This loop stops if a single class is found.

        UINT cStrings = 0;
        TCHAR szClass[OLEUI_CCHKEYMAX];
        lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));

        TCHAR szFormatKey[OLEUI_CCHKEYMAX];
        TCHAR szFormat[OLEUI_CCHKEYMAX];
        TCHAR szHRClassName[OLEUI_CCHKEYMAX];
        BOOL fEnableConvert = FALSE;

        while (ERROR_SUCCESS == lRet)
        {
                if (lstrcmp(lpszCLSID, szClass) == 0)
                        goto next;   // we don't want to consider the source class

                // Check for a \Conversion\ReadWriteable\Main entry first - if its
                // readwriteable, then we don't need to bother checking to see if
                // its readable.

                lstrcpy(szFormatKey, szClass);
                lstrcat(szFormatKey, TEXT("\\Conversion\\Readwritable\\Main"));
                DWORD dw; dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                if (ERROR_SUCCESS != lRet)
                {
                        // Try \\DataFormats\DefaultFile too
                        lstrcpy(szFormatKey, szClass);
                        lstrcat(szFormatKey, TEXT("\\DataFormats\\DefaultFile"));
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);
                }

                if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                {
                        // Here, we've got a list of formats that this class can read
                        // and write. We need to see if the original class' format is
                        // in this list.  We do that by looking for wFormat in
                        // szFormat - if it in there, then we add this class to the
                        // both lists and continue.  If not, then we look at the
                        // class' readable formats.

                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);
                        if (ERROR_SUCCESS == lRet)
                        {
                                fEnableConvert = TRUE;
                                break;  // STOP -- found one!
                        }
                }

                // We either didn't find the readwritable key, or the
                // list of readwritable formats didn't include the
                // original class format.  So, here we'll check to
                // see if its in the readable list.

                // We've got a special case for a linked object here.
                // If an object is linked, then the only class that
                // should appear in the convert list is the object's
                // class.  So, here we check to see if the object is
                // linked.  If it is, then we compare the classes.  If
                // they aren't the same, then we just go to the next key.

                else if (!fIsLinkedObject || lstrcmp(lpszCLSID, szClass) == 0)
                {
                        // Check for a \Conversion\Readable\Main entry
                        lstrcpy(szFormatKey, szClass);
                        lstrcat(szFormatKey, TEXT("\\Conversion\\Readable\\Main"));

                        // Check to see if this class can read the original class format.
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, szFormatKey, szFormat, (LONG*)&dw);

                        if (ERROR_SUCCESS == lRet && FormatIncluded(szFormat, wFormat))
                        {
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, szClass, szHRClassName, (LONG*)&dw);
                                if (ERROR_SUCCESS == lRet)
                                {
                                        fEnableConvert = TRUE;
                                        break;  // STOP -- found one!
                                }
                        }
                }
next:
                // Continue with the next key.
                lRet = RegEnumKey(hKey, cStrings++, szClass, sizeof(szClass) / sizeof(TCHAR));
        }

        // Free the string we got from StringFromCLSID.
        OleStdFree(lpszCLSID);
        RegCloseKey(hKey);

        return fEnableConvert;
}

/*
 * FormatIncluded
 *
 * Purpose:
 *  Parses the string for format from the word.
 *
 * Parameters:
 *  szStringToSearch  String to parse
 *  wFormat           format to find
 *
 * Return Value:
 *  BOOL        TRUE if format is found in string,
 *              FALSE otherwise.
 */
BOOL FormatIncluded(LPTSTR szStringToSearch, WORD wFormat)
{
        TCHAR szFormat[255];
        if (wFormat < 0xC000)
                wsprintf(szFormat, TEXT("%d"), wFormat);
        else
                GetClipboardFormatName(wFormat, szFormat, 255);

        LPTSTR lpToken = szStringToSearch;
        while (lpToken != NULL)
        {
                LPTSTR lpTokenNext = FindChar(lpToken, TEXT(','));
                if (lpTokenNext != NULL)
                {
                        *lpTokenNext = 0;
                        ++lpTokenNext;
                }
                if (0 == lstrcmpi(lpToken, szFormat))
                        return TRUE;

                lpToken = lpTokenNext;
        }
        return FALSE;
}

/*
 * UpdateClassIcon
 *
 * Purpose:
 *  Handles LBN_SELCHANGE for the Object Type listbox.  On a selection
 *  change, we extract an icon from the server handling the currently
 *  selected object type using the utility function HIconFromClass.
 *  Note that we depend on the behavior of FillClassList to stuff the
 *  object class after a tab in the listbox string that we hide from
 *  view (see WM_INITDIALOG).
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpCV            LPCONVERT pointing to the dialog structure
 *  hList           HWND of the Object Type listbox.
 *
 * Return Value:
 *  None
 */
static void UpdateClassIcon(HWND hDlg, LPCONVERT lpCV, HWND hList)
{
        if (GetDlgItem(hDlg, IDC_CV_ICONDISPLAY) == NULL)
                return;

        // Get current selection in the list box
        int iSel= (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (LB_ERR == iSel)
                return;

        // Allocate a string to hold the entire listbox string
        DWORD cb = (DWORD)SendMessage(hList, LB_GETTEXTLEN, iSel, 0L);
        LPTSTR pszName = (LPTSTR)OleStdMalloc((cb+1) * sizeof(TCHAR));
        if (pszName == NULL)
                return;

        // Get whole string
        SendMessage(hList, LB_GETTEXT, iSel, (LPARAM)pszName);

        // Set pointer to CLSID (string)
        LPTSTR pszCLSID = PointerToNthField(pszName, 2, '\t');

        // Create the class ID with this string.
        CLSID clsid;
#if defined(WIN32) && !defined(UNICODE)
        OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
        ATOW(wszCLSID, pszCLSID, OLEUI_CCHKEYMAX);
        HRESULT hr = CLSIDFromString(wszCLSID, &clsid);
#else
        HRESULT hr = CLSIDFromString(pszCLSID, &clsid);
#endif
        if (SUCCEEDED(hr))
        {
            // Get Icon for that CLSID
            HGLOBAL hMetaPict = OleGetIconOfClass(clsid, NULL, TRUE);

            // Replace current icon with the new one.
            SendDlgItemMessage(hDlg, IDC_CV_ICONDISPLAY, IBXM_IMAGESET, 1,
                               (LPARAM)hMetaPict);
        }

        OleStdFree(pszName);
}

/*
 * SetConvertResults
 *
 * Purpose:
 *  Centralizes setting of the Result display in the Convert
 *  dialog.  Handles loading the appropriate string from the module's
 *  resources and setting the text, displaying the proper result picture,
 *  and showing the proper icon.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *  lpCV            LPCONVERT in which we assume that the dwFlags is
 *                  set to the appropriate radio button selection, and
 *                  the list box has the appropriate class selected.
 *
 * Return Value:
 *  None
 */
void SetConvertResults(HWND hDlg, LPCONVERT lpCV)
{
        HWND hList = lpCV->hListVisible;

        /*
         * We need scratch memory for loading the stringtable string, loading
         * the object type from the listbox, loading the source object
         * type, and constructing the final string.  We therefore allocate
         * four buffers as large as the maximum message length (512) plus
         * the object type, guaranteeing that we have enough
         * in all cases.
         */
        UINT i = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        UINT cch = 512+(UINT)SendMessage(hList, LB_GETTEXTLEN, i, 0L);
        HGLOBAL hMem = GlobalAlloc(GHND, (DWORD)(4*cch)*sizeof(TCHAR));
        if (NULL == hMem)
                return;

        LPTSTR lpszOutput = (LPTSTR)GlobalLock(hMem);
        LPTSTR lpszSelObj = lpszOutput + cch;
        LPTSTR lpszDefObj = lpszSelObj + cch;
        LPTSTR lpszString = lpszDefObj + cch;

        // Get selected object and null terminate human-readable name (1st field).
        SendMessage(hList, LB_GETTEXT, i, (LPARAM)lpszSelObj);

        LPTSTR pszT = PointerToNthField(lpszSelObj, 2, '\t');
        pszT = CharPrev(lpszSelObj, pszT);
        *pszT = '\0';

        // Get default object
        GetDlgItemText(hDlg, IDC_CV_OBJECTTYPE, lpszDefObj, 512);

        //Default is an empty string.
        *lpszOutput=0;

        if (lpCV->dwFlags & CF_SELECTCONVERTTO)
        {
                if (lpCV->lpOCV->fIsLinkedObject)  // working with linked object
                        LoadString(_g_hOleStdResInst, IDS_CVRESULTCONVERTLINK, lpszOutput, cch);
                else
                {
                        if (0 !=lstrcmp(lpszDefObj, lpszSelObj))
                        {
                                // converting to a new class
                                if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTCONVERTTO, lpszString, cch))
                                        FormatString2(lpszOutput, lpszString, lpszDefObj, lpszSelObj);
                        }
                        else
                        {
                                // converting to the same class (no conversion)
                                if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTNOCHANGE, lpszString, cch))
                                        wsprintf(lpszOutput, lpszString, lpszDefObj);
                        }
                }

                if (lpCV->dvAspect == DVASPECT_ICON)  // Display as icon is checked
                {
                   if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTDISPLAYASICON, lpszString, cch))
                                lstrcat(lpszOutput, lpszString);
                }
        }

        if (lpCV->dwFlags & CF_SELECTACTIVATEAS)
        {
           if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTACTIVATEAS, lpszString, cch))
                        FormatString2(lpszOutput, lpszString, lpszDefObj, lpszSelObj);

           // activating as a new class
           if (0 != lstrcmp(lpszDefObj, lpszSelObj))
           {
                        if (0 != LoadString(_g_hOleStdResInst, IDS_CVRESULTACTIVATEDIFF, lpszString, cch))
                                lstrcat(lpszOutput, lpszString);
           }
           else // activating as itself.
           {
                        lstrcat(lpszOutput, TEXT("."));
           }
        }

        // If LoadString failed, we simply clear out the results (*lpszOutput=0 above)
        SetDlgItemText(hDlg, IDC_CV_RESULTTEXT, lpszOutput);

        GlobalUnlock(hMem);
        GlobalFree(hMem);
}

/*
 * ConvertCleanup
 *
 * Purpose:
 *  Performs convert-specific cleanup before Convert termination.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *
 * Return Value:
 *  None
 */
void ConvertCleanup(HWND hDlg, LPCONVERT lpCV)
{
        // Free our strings. Zero out the user type name string
        // the the calling app doesn't free to it.

        OleStdFree((LPVOID)lpCV->lpszConvertDefault);
        OleStdFree((LPVOID)lpCV->lpszActivateDefault);
        OleStdFree((LPVOID)lpCV->lpszIconSource);
        if (lpCV->lpOCV->lpszUserType)
        {
                OleStdFree((LPVOID)lpCV->lpOCV->lpszUserType);
                lpCV->lpOCV->lpszUserType = NULL;
        }

        if (lpCV->lpOCV->lpszDefLabel)
        {
                OleStdFree((LPVOID)lpCV->lpOCV->lpszDefLabel);
                lpCV->lpOCV->lpszDefLabel = NULL;
        }
}

/*
 * SwapWindows
 *
 * Purpose:
 *  Moves hWnd1 to hWnd2's position and hWnd2 to hWnd1's position.
 *  Does NOT change sizes.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can turn redraw off
 *
 * Return Value:
 *  None
 */
void SwapWindows(HWND hDlg, HWND hWnd1, HWND hWnd2)
{
        if (hWnd1 != NULL && hWnd2 != NULL)
        {
                RECT rect1; GetWindowRect(hWnd1, &rect1);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rect1, 2);

                RECT rect2; GetWindowRect(hWnd2, &rect2);
                MapWindowPoints(NULL, hDlg, (LPPOINT)&rect2, 2);

                SetWindowPos(hWnd1, NULL,
                        rect2.left, rect2.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
                SetWindowPos(hWnd2, NULL,
                        rect1.left, rect1.top, 0, 0, SWP_NOZORDER | SWP_NOSIZE);
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\drawicon.cpp ===
/*
 * DRAWICON.CPP
 *
 * Functions to handle creation of metafiles with icons and labels
 * as well as functions to draw such metafiles with or without the label.
 *
 * The metafile is created with a comment that marks the records containing
 * the label code.  Drawing the metafile enumerates the records, draws
 * all records up to that point, then decides to either skip the label
 * or draw it.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "utility.h"
#include "malloc.h"

// Private implementation

//Structure for label and source extraction from a metafile
typedef struct tagLABELEXTRACT
{
        LPTSTR      lpsz;
        UINT        Index;      // index in lpsz (so we can retrieve 2+ lines)
        DWORD       PrevIndex;  // index of last line (so we can mimic word wrap)

        union
                {
                UINT    cch;        //Length of label for label extraction
                UINT    iIcon;      //Index of icon in source extraction.
                } u;

        //For internal use in enum procs
        BOOL        fFoundIconOnly;
        BOOL        fFoundSource;
        BOOL        fFoundIndex;
} LABELEXTRACT, FAR * LPLABELEXTRACT;


//Structure for extracting icons from a metafile (CreateIcon parameters)
typedef struct tagICONEXTRACT
{
        HICON       hIcon;          //Icon created in the enumeration proc.

        /*
         * Since we want to handle multitasking well we have the caller
         * of the enumeration proc instantiate these variables instead of
         * using statics in the enum proc (which would be bad).
         */
        BOOL        fAND;
        HGLOBAL     hMemAND;        //Enumeration proc allocates and copies
} ICONEXTRACT, FAR * LPICONEXTRACT;


//Structure to use to pass info to EnumMetafileDraw
typedef struct tagDRAWINFO
{
        RECT     Rect;
        BOOL     fIconOnly;
} DRAWINFO, FAR * LPDRAWINFO;


int CALLBACK EnumMetafileIconDraw(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPARAM);
int CALLBACK EnumMetafileExtractLabel(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);
int CALLBACK EnumMetafileExtractIcon(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPICONEXTRACT);
int CALLBACK EnumMetafileExtractIconSource(HDC, HANDLETABLE FAR *, METARECORD FAR *, int, LPLABELEXTRACT);

/*
 * Strings for metafile comments.  KEEP THESE IN SYNC WITH THE
 * STRINGS IN GETICON.CPP
 */

static const char szIconOnly[] = "IconOnly"; // Where to stop to exclude label.

/*
 * OleUIMetafilePictIconFree
 *
 * Purpose:
 *  Deletes the metafile contained in a METAFILEPICT structure and
 *  frees the memory for the structure itself.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL metafilepict structure created in
 *                  OleMetafilePictFromIconAndLabel
 *
 * Return Value:
 *  None
 */

STDAPI_(void) OleUIMetafilePictIconFree(HGLOBAL hMetaPict)
{
        if (NULL != hMetaPict)
        {
                STGMEDIUM stgMedium;
                stgMedium.tymed = TYMED_MFPICT;
                stgMedium.hMetaFilePict = hMetaPict;
                stgMedium.pUnkForRelease = NULL;
                ReleaseStgMedium(&stgMedium);
        }
}

/*
 * OleUIMetafilePictIconDraw
 *
 * Purpose:
 *  Draws the metafile from OleMetafilePictFromIconAndLabel, either with
 *  the label or without.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  pRect           LPRECT in which to draw the metafile.
 *  hMetaPict       HGLOBAL to the METAFILEPICT from
 *                  OleMetafilePictFromIconAndLabel
 *  fIconOnly       BOOL specifying to draw the label or not.
 *
 * Return Value:
 *  BOOL            TRUE if the function is successful, FALSE if the
 *                  given metafilepict is invalid.
 */

STDAPI_(BOOL) OleUIMetafilePictIconDraw(HDC hDC, LPCRECT pRect,
        HGLOBAL hMetaPict, BOOL fIconOnly)
{
        if (NULL == hMetaPict)
                return FALSE;

        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        DRAWINFO di;
        di.Rect = *pRect;
        di.fIconOnly = fIconOnly;

        //Transform to back to pixels
        int cx = XformWidthInHimetricToPixels(hDC, pMF->xExt);
        int cy = XformHeightInHimetricToPixels(hDC, pMF->yExt);

        SaveDC(hDC);

        SetMapMode(hDC, pMF->mm);
        SetViewportOrgEx(hDC, (pRect->right - cx) / 2, 0, NULL);
        SetViewportExtEx(hDC, min ((pRect->right - cx) / 2 + cx, cx), cy, NULL);

        if (fIconOnly)
                EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileIconDraw, (LPARAM)&di);
        else
           PlayMetaFile(hDC, pMF->hMF);

        RestoreDC(hDC, -1);

        GlobalUnlock(hMetaPict);
        return TRUE;
}

/*
 * EnumMetafileIconDraw
 *
 * Purpose:
 *  EnumMetaFile callback function that draws either the icon only or
 *  the icon and label depending on given flags.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  lParam          LPARAM flags passed in EnumMetaFile.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */
int CALLBACK EnumMetafileIconDraw(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPARAM lParam)
{
        LPDRAWINFO lpdi = (LPDRAWINFO)lParam;

        /*
         * We play everything blindly except for DIBBITBLT (or DIBSTRETCHBLT)
         * and ESCAPE with MFCOMMENT.  For the BitBlts we change the x,y to
         * draw at (0,0) instead of wherever it was written to draw.  The
         * comment tells us there to stop if we don't want to draw the label.
         */

        //If we're playing icon only, stop enumeration at the comment.
        if (lpdi->fIconOnly)
        {
                if (META_ESCAPE==pMFR->rdFunction && MFCOMMENT==pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                return 0;
                }

                /*
                 * Check for the records in which we want to munge the coordinates.
                 * destX is offset 6 for BitBlt, offset 9 for StretchBlt, either of
                 * which may appear in the metafile.
                 */
                if (META_DIBBITBLT == pMFR->rdFunction)
                        pMFR->rdParm[6]=0;

                if (META_DIBSTRETCHBLT == pMFR->rdFunction)
                          pMFR->rdParm[9] = 0;
        }

        PlayMetaFileRecord(hDC, phTable, pMFR, cObj);
        return 1;
}


/*
 * OleUIMetafilePictExtractLabel
 *
 * Purpose:
 *  Retrieves the label string from metafile representation of an icon.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *  lpszLabel       LPSTR in which to store the label.
 *  cchLabel        UINT length of lpszLabel.
 *  lpWrapIndex     DWORD index of first character in last line. Can be NULL
 *                  if calling function doesn't care about word wrap.
 *
 * Return Value:
 *  UINT            Number of characters copied.
 */
STDAPI_(UINT) OleUIMetafilePictExtractLabel(HGLOBAL hMetaPict, LPTSTR lpszLabel,
        UINT cchLabel, LPDWORD lpWrapIndex)
{
        if (NULL == hMetaPict || NULL == lpszLabel || 0 == cchLabel)
                return FALSE;

        /*
         * We extract the label by getting a screen DC and walking the metafile
         * records until we see the ExtTextOut record we put there.  That
         * record will have the string embedded in it which we then copy out.
         */
        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        LABELEXTRACT le;
        le.lpsz=lpszLabel;
        le.u.cch=cchLabel;
        le.Index=0;
        le.fFoundIconOnly=FALSE;
        le.fFoundSource=FALSE;  //Unused for this function.
        le.fFoundIndex=FALSE;   //Unused for this function.
        le.PrevIndex = 0;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC = GetDC(NULL);
        if (hDC)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractLabel, (LPARAM)(LPLABELEXTRACT)&le);
            ReleaseDC(NULL, hDC);
        } else {
            le.u.cch = 0;
			lpszLabel[0] = NULL;
        }

        GlobalUnlock(hMetaPict);

        //Tell where we wrapped (if calling function cares)
        if (NULL != lpWrapIndex)
           *lpWrapIndex = le.PrevIndex;

        //Return amount of text copied
        return le.u.cch;
}

/*
 * EnumMetafileExtractLabel
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile looking for
 *  ExtTextOut, then concatenates the text from each one into a buffer
 *  in lParam.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pLE             LPLABELEXTRACT providing the destination buffer and length.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractLabel(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE)
{
        /*
         * We don't allow anything to happen until we see "IconOnly"
         * in an MFCOMMENT that is used to enable everything else.
         */
        if (!pLE->fFoundIconOnly)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                pLE->fFoundIconOnly=TRUE;
                }
                return 1;
        }

        //Enumerate all records looking for META_EXTTEXTOUT - there can be more
        //than one.
        if (META_EXTTEXTOUT == pMFR->rdFunction)
        {
                /*
                 * If ExtTextOut has NULL fuOptions, then the rectangle is omitted
                 * from the record, and the string starts at rdParm[4].  If
                 * fuOptions is non-NULL, then the string starts at rdParm[8]
                 * (since the rectange takes up four WORDs in the array).  In
                 * both cases, the string continues for (rdParm[2]+1) >> 1
                 * words.  We just cast a pointer to rdParm[8] to an LPSTR and
                 * lstrcpyn into the buffer we were given.
                 *
                 * Note that we use element 8 in rdParm instead of 4 because we
                 * passed ETO_CLIPPED in for the options on ExtTextOut--docs say
                 * [4] which is rect doesn't exist if we passed zero there.
                 *
                 */

                UINT cchMax = min(pLE->u.cch - pLE->Index, (UINT)pMFR->rdParm[2]);
                LPTSTR lpszTemp = pLE->lpsz + pLE->Index;
#ifdef _UNICODE
                MultiByteToWideChar(CP_ACP, 0, (LPSTR)&pMFR->rdParm[8], cchMax,
                        lpszTemp, cchMax+1);
#else
                lstrcpyn(lpszTemp, (LPSTR)&pMFR->rdParm[8], cchMax+1);
#endif
                lpszTemp[cchMax+1] = 0;

                pLE->PrevIndex = pLE->Index;
                pLE->Index += cchMax;
        }
        return 1;
}

/*
 * OleUIMetafilePictExtractIcon
 *
 * Purpose:
 *  Retrieves the icon from metafile into which DrawIcon was done before.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *
 * Return Value:
 *  HICON           Icon recreated from the data in the metafile.
 */
STDAPI_(HICON) OleUIMetafilePictExtractIcon(HGLOBAL hMetaPict)
{
        if (NULL == hMetaPict)
                return NULL;

        /*
         * We extract the label by getting a screen DC and walking the metafile
         * records until we see the ExtTextOut record we put there.  That
         * record will have the string embedded in it which we then copy out.
         */
        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);

        if (NULL == pMF)
                return FALSE;

        ICONEXTRACT ie;
        ie.fAND  = TRUE;
        ie.hIcon = NULL;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC=GetDC(NULL);
        if (hDC != NULL)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractIcon, (LPARAM)&ie);
            ReleaseDC(NULL, hDC);
        }

        GlobalUnlock(hMetaPict);

        return ie.hIcon;
}

/*
 * EnumMetafileExtractIcon
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile looking for
 *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two
 *  of them, the first being the AND mask and the second being the XOR
 *  data.  We
 *  ExtTextOut, then copies the text into a buffer in lParam.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pIE             LPICONEXTRACT providing the destination buffer and length.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractIcon(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPICONEXTRACT pIE)
{
        //Continue enumeration if we don't see the records we want.
        if (META_DIBBITBLT != pMFR->rdFunction && META_DIBSTRETCHBLT != pMFR->rdFunction)
                return 1;

        UNALIGNED BITMAPINFO* lpBI;
        UINT uWidth, uHeight;
        /*
         * Windows 3.0 DrawIcon uses META_DIBBITBLT in whereas 3.1 uses
         * META_DIBSTRETCHBLT so we have to handle each case separately.
         */
        if (META_DIBBITBLT==pMFR->rdFunction)       //Win3.0
        {
                //Get dimensions and the BITMAPINFO struct.
                uHeight = pMFR->rdParm[1];
                uWidth = pMFR->rdParm[2];
                lpBI = (LPBITMAPINFO)&(pMFR->rdParm[8]);
        }

        if (META_DIBSTRETCHBLT == pMFR->rdFunction)   //Win3.1
        {
                //Get dimensions and the BITMAPINFO struct.
                uHeight = pMFR->rdParm[2];
                uWidth = pMFR->rdParm[3];
                lpBI = (LPBITMAPINFO)&(pMFR->rdParm[10]);
        }

        UNALIGNED BITMAPINFOHEADER* lpBH=(LPBITMAPINFOHEADER)&(lpBI->bmiHeader);

        //Pointer to the bits which follows the BITMAPINFO structure.
        LPBYTE lpbSrc=(LPBYTE)lpBI+sizeof(BITMAPINFOHEADER);

        //Add the length of the color table (if one exists)
        if (0 != lpBH->biClrUsed)
        {
                // If we have an explicit count of colors used, we
                // can find the offset to the data directly
                lpbSrc += (lpBH->biClrUsed*sizeof(RGBQUAD));
        }
        else if (lpBH->biCompression == BI_BITFIELDS)
        {
                // 16 or 32 bpp, indicated by BI_BITFIELDS in the compression
                // field, have 3 DWORD masks for adjusting subsequent
                // direct-color values, and no palette
                lpbSrc += 3 * sizeof(DWORD);
        }
        else
        {
                // In other cases, there is an array of RGBQUAD entries
                // equal to 2^(biBitCount) where biBitCount is the number
                // of bits per pixel.  The exception is 24 bpp bitmaps,
                // which have no color table and just use direct RGB values.
                lpbSrc += (lpBH->biBitCount == 24) ? 0 :
                        (1 << (lpBH->biBitCount)) * sizeof(RGBQUAD);
        }

        // copy into aligned stack space (since SetDIBits needs aligned data)
        size_t nSize = (size_t)(lpbSrc - (LPBYTE)lpBI);
        LPBITMAPINFO lpTemp = (LPBITMAPINFO)_alloca(nSize);
        memcpy(lpTemp, lpBI, nSize);

        /*
         * All the bits we have in lpbSrc are device-independent, so we
         * need to change them over to be device-dependent using SetDIBits.
         * Once we have a bitmap with the device-dependent bits, we can
         * GetBitmapBits to have buffers with the real data.
         *
         * For each pass we have to allocate memory for the bits.  We save
         * the memory for the mask between passes.
         */

        HBITMAP hBmp;

        //Use CreateBitmap for ANY monochrome bitmaps
        if (pIE->fAND || 1==lpBH->biBitCount)
                hBmp=CreateBitmap((UINT)lpBH->biWidth, (UINT)lpBH->biHeight, 1, 1, NULL);
        else
                hBmp=CreateCompatibleBitmap(hDC, (UINT)lpBH->biWidth, (UINT)lpBH->biHeight);

        if (!hBmp || !SetDIBits(hDC, hBmp, 0, (UINT)lpBH->biHeight, (LPVOID)lpbSrc, lpTemp, DIB_RGB_COLORS))
        {
                if (!pIE->fAND)
                        GlobalFree(pIE->hMemAND);

                if (hBmp)
                    DeleteObject(hBmp);

                return 0;
        }

        //Allocate memory and get the DDBits into it.
        BITMAP bm;
        GetObject(hBmp, sizeof(bm), &bm);

        DWORD cb = bm.bmHeight*bm.bmWidthBytes * bm.bmPlanes;
        HGLOBAL hMem = GlobalAlloc(GHND, cb);

        if (NULL==hMem)
        {
                if (NULL != pIE->hMemAND)
                        GlobalFree(pIE->hMemAND);

                DeleteObject(hBmp);
                return 0;
        }

        LPBYTE lpbDst = (LPBYTE)GlobalLock(hMem);
        GetBitmapBits(hBmp, cb, (LPVOID)lpbDst);
        DeleteObject(hBmp);
        GlobalUnlock(hMem);

        /*
         * If this is the first pass (pIE->fAND==TRUE) then save the memory
         * of the AND bits for the next pass.
         */
        if (pIE->fAND)
        {
                pIE->fAND = FALSE;
                pIE->hMemAND = hMem;

                //Continue enumeration looking for the next blt record.
                return 1;
        }
        else
        {
                //Get the AND pointer again.
                lpbSrc=(LPBYTE)GlobalLock(pIE->hMemAND);

                /*
                 * Create the icon now that we have all the data.  lpbDst already
                 * points to the XOR bits.
                 */

                int cxIcon = GetSystemMetrics(SM_CXICON);
                int cyIcon = GetSystemMetrics(SM_CYICON);

                pIE->hIcon = CreateIcon(_g_hOleStdInst, uWidth, uHeight,
                        (BYTE)bm.bmPlanes, (BYTE)bm.bmBitsPixel, lpbSrc, lpbDst);

                GlobalUnlock(pIE->hMemAND);
                GlobalFree(pIE->hMemAND);
                GlobalFree(hMem);

                return 0;
        }
}


/*
 * OleUIMetafilePictExtractIconSource
 *
 * Purpose:
 *  Retrieves the filename and index of the icon source from a metafile
 *  created with OleMetafilePictFromIconAndLabel.
 *
 * Parameters:
 *  hMetaPict       HGLOBAL to the METAFILEPICT containing the metafile.
 *  lpszSource      LPTSTR in which to store the source filename.  This
 *                  buffer should be MAX_PATH characters.
 *  piIcon          UINT FAR * in which to store the icon's index
 *                  within lpszSource
 *
 * Return Value:
 *  BOOL            TRUE if the records were found, FALSE otherwise.
 */
STDAPI_(BOOL) OleUIMetafilePictExtractIconSource(HGLOBAL hMetaPict,
        LPTSTR lpszSource, UINT FAR *piIcon)
{
        if (NULL == hMetaPict || NULL == lpszSource || NULL == piIcon)
                return FALSE;

        /*
         * We will walk the metafile looking for the two comment records
         * following the IconOnly comment.  The flags fFoundIconOnly and
         * fFoundSource indicate if we have found IconOnly and if we have
         * found the source comment already.
         */

        LPMETAFILEPICT pMF = (LPMETAFILEPICT)GlobalLock(hMetaPict);
        if (NULL == pMF)
                return FALSE;

        LABELEXTRACT    le;
        le.lpsz = lpszSource;
        le.fFoundIconOnly = FALSE;
        le.fFoundSource = FALSE;
        le.fFoundIndex = FALSE;
        le.u.iIcon = NULL;

        //Use a screen DC so we have something valid to pass in.
        HDC hDC = GetDC(NULL);
        if (hDC)
        {
            EnumMetaFile(hDC, pMF->hMF, (MFENUMPROC)EnumMetafileExtractIconSource,
                         (LPARAM)(LPLABELEXTRACT)&le);
            ReleaseDC(NULL, hDC);
        }
        GlobalUnlock(hMetaPict);

        //Copy the icon index to the caller's variable.
        *piIcon=le.u.iIcon;

        //Check that we found everything.
        return (le.fFoundIconOnly && le.fFoundSource && le.fFoundIndex);
}


/*
 * EnumMetafileExtractIconSource
 *
 * Purpose:
 *  EnumMetaFile callback function that walks a metafile skipping the first
 *  comment record, extracting the source filename from the second, and
 *  the index of the icon in the third.
 *
 * Parameters:
 *  hDC             HDC into which the metafile should be played.
 *  phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *  pMFR            METARECORD FAR * giving the enumerated record.
 *  pLE             LPLABELEXTRACT providing the destination buffer and
 *                  area to store the icon index.
 *
 * Return Value:
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileExtractIconSource(HDC hDC, HANDLETABLE FAR *phTable,
        METARECORD FAR *pMFR, int cObj, LPLABELEXTRACT pLE)
{
        /*
         * We don't allow anything to happen until we see "IconOnly"
         * in an MFCOMMENT that is used to enable everything else.
         */
        if (!pLE->fFoundIconOnly)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
                        if (0 == lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
                                pLE->fFoundIconOnly=TRUE;
                }
                return 1;
        }

        //Now see if we find the source string.
        if (!pLE->fFoundSource)
        {
                if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
                {
#ifdef _UNICODE
                        MultiByteToWideChar(CP_ACP, 0, (LPSTR)&pMFR->rdParm[2], -1,
                                pLE->lpsz, MAX_PATH);
#else
                        lstrcpyn(pLE->lpsz, (LPSTR)&pMFR->rdParm[2], MAX_PATH);
#endif
                        pLE->lpsz[MAX_PATH-1] = '\0';
                        pLE->fFoundSource=TRUE;
                }
                return 1;
        }

        //Next comment will be the icon index.
        if (META_ESCAPE == pMFR->rdFunction && MFCOMMENT == pMFR->rdParm[0])
        {
                /*
                 * This string contains the icon index in string form,
                 * so we need to convert back to a UINT.  After we see this
                 * we can stop the enumeration.  The comment will have
                 * a null terminator because we made sure to save it.
                 */
                LPSTR psz = (LPSTR)&pMFR->rdParm[2];
                pLE->u.iIcon = 0;

                //Do Ye Olde atoi
                while (*psz)
                        pLE->u.iIcon = (10*pLE->u.iIcon)+((*psz++)-'0');

                pLE->fFoundIndex=TRUE;
                return 0;
        }
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\chngsrc.cpp ===
/*
 * CHNGSRC.CPP
 *
 * Implements the OleUIChangeSource function which invokes the complete
 * Change Source dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"

OLEDBGDATA

// Internally used structure
typedef struct tagCHANGESOURCE
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUICHANGESOURCE     lpOCS;       //Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

} CHANGESOURCE, *PCHANGESOURCE, FAR* LPCHANGESOURCE;

// Internal function prototypes
// CHNGSRC.CPP

UINT_PTR CALLBACK ChangeSourceHookProc(HWND, UINT, WPARAM, LPARAM);
BOOL FChangeSourceInit(HWND hDlg, WPARAM, LPARAM);
STDAPI_(BOOL) IsValidInterface(void FAR* ppv);

/*
 * OleUIChangeSource
 *
 * Purpose:
 *  Invokes the standard OLE Change Source dialog box allowing the user
 *  to change the source of a link.  The link source is not actually
 *  changed by this dialog.  It is up to the caller to actually change
 *  the link source itself.
 *
 * Parameters:
 *  lpCS            LPOLEUIChangeSource pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */
STDAPI_(UINT) OleUIChangeSource(LPOLEUICHANGESOURCE lpCS)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCS,
                sizeof(OLEUICHANGESOURCE), &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;


        HCURSOR hCurSave = NULL;

        // validate contents of lpCS
        if (lpCS->lpOleUILinkContainer == NULL)
        {
                uRet = OLEUI_CSERR_LINKCNTRNULL;
                goto Error;
        }
        if (!IsValidInterface(lpCS->lpOleUILinkContainer))
        {
                uRet = OLEUI_CSERR_LINKCNTRINVALID;
                goto Error;
        }

        // lpszFrom and lpszTo must be NULL (they are out only)
        if (lpCS->lpszFrom != NULL)
        {
                uRet = OLEUI_CSERR_FROMNOTNULL;
                goto Error;
        }
        if (lpCS->lpszTo != NULL)
        {
                uRet = OLEUI_CSERR_TONOTNULL;
                goto Error;
        }

        // lpszDisplayName must be valid or NULL
        if (lpCS->lpszDisplayName != NULL &&
                IsBadStringPtr(lpCS->lpszDisplayName, (UINT)-1))
        {
                uRet = OLEUI_CSERR_SOURCEINVALID;
                goto Error;
        }

        hCurSave = HourGlassOn();

        // attempt to retrieve link source if not provided
        if (lpCS->lpszDisplayName == NULL)
        {
                if (NOERROR != lpCS->lpOleUILinkContainer->GetLinkSource(
                        lpCS->dwLink, &lpCS->lpszDisplayName, &lpCS->nFileLength,
                        NULL, NULL, NULL, NULL))
                {
                        uRet = OLEUI_CSERR_SOURCEINVALID;
                        goto Error;
                }
        }

        // verify that nFileLength is valid
        if ((UINT)lstrlen(lpCS->lpszDisplayName) < lpCS->nFileLength)
        {
            uRet = OLEUI_CSERR_SOURCEINVALID;
            goto Error;
        }

        // allocate file buffer and split directory and file name
        UINT nFileLength; nFileLength = lpCS->nFileLength;
        UINT nFileBuf; nFileBuf = max(nFileLength+1, MAX_PATH);
        LPTSTR lpszFileBuf;
        LPTSTR lpszDirBuf; lpszDirBuf = (LPTSTR)OleStdMalloc(nFileBuf * sizeof(TCHAR));
        if (lpszDirBuf == NULL)
        {
                uRet = OLEUI_ERR_OLEMEMALLOC;
                goto Error;
        }
        lstrcpyn(lpszDirBuf, lpCS->lpszDisplayName, nFileLength+1);

        UINT nFileLen; nFileLen = GetFileName(lpszDirBuf, NULL, 0);

        lpszFileBuf = (LPTSTR)OleStdMalloc(nFileBuf * sizeof(TCHAR));
        if (lpszFileBuf == NULL)
        {
                uRet = OLEUI_ERR_OLEMEMALLOC;
                goto ErrorFreeDirBuf;
        }
        memmove(lpszFileBuf, lpszDirBuf+nFileLength-nFileLen+1,
                (nFileLen+1)*sizeof(TCHAR));
        lpszDirBuf[nFileLength-(nFileLen - 1)] = 0;

        // start filling the OPENFILENAME struct
        OPENFILENAME ofn; memset(&ofn, 0, sizeof(ofn));
        ofn.lpstrFile = lpszFileBuf;
        ofn.nMaxFile = nFileBuf;
        ofn.lpstrInitialDir = lpszDirBuf;

        // load filter strings
        TCHAR szFilters[MAX_PATH];
        if (!LoadString(_g_hOleStdResInst, IDS_FILTERS, szFilters, MAX_PATH))
                szFilters[0] = 0;
        else
                ReplaceCharWithNull(szFilters, szFilters[lstrlen(szFilters)-1]);
        ofn.lpstrFilter = szFilters;
        ofn.nFilterIndex = 1;

        TCHAR szTitle[MAX_PATH];

        // set the caption
        if (NULL!=lpCS->lpszCaption)
            ofn.lpstrTitle = lpCS->lpszCaption;
        else
        {
            LoadString(_g_hOleStdResInst, IDS_CHANGESOURCE, szTitle, MAX_PATH);
            ofn.lpstrTitle = szTitle;
        }

        // fill in rest of OPENFILENAME struct
        ofn.hwndOwner = lpCS->hWndOwner;
        ofn.lStructSize = sizeof(ofn);
        ofn.Flags = OFN_HIDEREADONLY | OFN_ENABLEHOOK;
        if (bWin4 && ((NULL == lpCS->hInstance && NULL == lpCS->hResource)
                || 0 != (lpCS->dwFlags & CSF_EXPLORER)))
            ofn.Flags |= OFN_EXPLORER;
        if (lpCS->dwFlags & CSF_SHOWHELP)
                ofn.Flags |= OFN_SHOWHELP;
        ofn.lCustData = (LPARAM)lpCS;
        ofn.lpfnHook = ChangeSourceHookProc;
        ofn.lCustData = (LPARAM)lpCS;
        lpCS->lpOFN = &ofn;             // needed sometimes in hook proc

        // allow hooking of the dialog resource
        if (lpCS->hResource != NULL)
        {
                ofn.hInstance = (HINSTANCE)lpCS->hResource;
                ofn.lpTemplateName = (LPCTSTR)lpCS->hResource;
                ofn.Flags |= OFN_ENABLETEMPLATEHANDLE;
        }
        else
        {
                if (lpCS->hInstance == NULL)
                {
                        ofn.hInstance = _g_hOleStdResInst;
                        ofn.lpTemplateName = bWin4 ?
                                MAKEINTRESOURCE(IDD_CHANGESOURCE4) : MAKEINTRESOURCE(IDD_CHANGESOURCE);
                        ofn.Flags |= OFN_ENABLETEMPLATE;
                }
                else
                {
                        ofn.hInstance = lpCS->hInstance;
                        ofn.lpTemplateName = lpCS->lpszTemplate;
                        ofn.Flags |= OFN_ENABLETEMPLATE;
                }
        }

        if (lpCS->hWndOwner != NULL)
        {
                // allow hooking of the OFN struct
                SendMessage(lpCS->hWndOwner, uMsgBrowseOFN, ID_BROWSE_CHANGESOURCE, (LPARAM)&ofn);
        }

        // call up the dialog
        BOOL bResult;

        bResult = StandardGetOpenFileName(&ofn);

        // cleanup
        OleStdFree(lpszDirBuf);
        OleStdFree(lpszFileBuf);

        HourGlassOff(hCurSave);

        // map return value to OLEUI_ standard returns
        return bResult ? OLEUI_OK : OLEUI_CANCEL;

// handle most error returns here
ErrorFreeDirBuf:
        OleStdFree(lpszDirBuf);

Error:
        if (hCurSave != NULL)
                HourGlassOff(hCurSave);
        return uRet;
}

/*
 * ChangeSourceHookProc
 *
 * Purpose:
 *  Implements the OLE Change Source dialog as invoked through the
 *  OleUIChangeSource function.  This is a standard COMMDLG hook function
 *  as opposed to a dialog proc.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
UINT_PTR CALLBACK ChangeSourceHookProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPCHANGESOURCE lpCS = (LPCHANGESOURCE)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        LPOLEUICHANGESOURCE lpOCS = NULL;
        if (lpCS != NULL)
                lpOCS = lpCS->lpOCS;

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return uHook;

        // Process help message
        if ((iMsg == uMsgHelp) && NULL != lpOCS)
        {
            PostMessage(lpOCS->hWndOwner, uMsgHelp,
                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                // Free any specific allocations before calling StandardCleanup
                StandardCleanup((PVOID)lpCS, hDlg);
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // handle validation of the file name (when user hits OK)
        if ((iMsg == uMsgFileOKString) && (lpOCS != NULL))
        {
                // always use fully qualified name
                LPOPENFILENAME lpOFN = lpOCS->lpOFN;
                LPCTSTR lpsz = lpOFN->lpstrFile;
                LPTSTR lpszFile;
                TCHAR szPath[MAX_PATH];
                if (!GetFullPathName(lpsz, MAX_PATH, szPath, &lpszFile))
                        lstrcpyn(szPath, lpsz, MAX_PATH);
                UINT nLenFile = lstrlen(szPath);
                TCHAR szItemName[MAX_PATH];
                GetDlgItemText(hDlg, edt2, szItemName, MAX_PATH);

                // combine them into szDisplayName (which is now large enough)
                TCHAR szDisplayName[MAX_PATH+MAX_PATH];
                lstrcpy(szDisplayName, szPath);
                if (szItemName[0] != '\0')
                {
                        lstrcat(szDisplayName, TEXT("\\"));
                        lstrcat(szDisplayName, szItemName);
                }

                if (!(lpOCS->dwFlags & CSF_ONLYGETSOURCE))
                {
                        // verify the source by calling into the link container
                        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpOCS->lpOleUILinkContainer;
                        ULONG chEaten;
                        if (lpOleUILinkCntr->SetLinkSource(lpOCS->dwLink, szDisplayName, nLenFile,
                                &chEaten, TRUE) != NOERROR)
                        {
                                // link not verified ok
                                lpOCS->dwFlags &= ~CSF_VALIDSOURCE;
                                UINT uRet = PopupMessage(hDlg, IDS_CHANGESOURCE, IDS_INVALIDSOURCE,
                                                MB_ICONQUESTION | MB_YESNO);
                                if (uRet == IDYES)
                                {
                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                        return 1;       // do not close dialog
                                }

                                // user doesn't care if the link is valid or not
                                lpOleUILinkCntr->SetLinkSource(lpOCS->dwLink, szDisplayName, nLenFile,
                                        &chEaten, FALSE);
                        }
                        else
                        {
                                // link was verified ok
                                lpOCS->dwFlags |= CSF_VALIDSOURCE;
                        }
                }

                // calculate lpszFrom and lpszTo for batch changes to links
                DiffPrefix(lpOCS->lpszDisplayName, szDisplayName, &lpOCS->lpszFrom, &lpOCS->lpszTo);

                // only keep them if the file name portion is the only part that changed
                if (lstrcmpi(lpOCS->lpszTo, lpOCS->lpszFrom) == 0 ||
                        (UINT)lstrlen(lpOCS->lpszFrom) > lpOCS->nFileLength)
                {
                        OleStdFree(lpOCS->lpszFrom);
                        lpOCS->lpszFrom = NULL;

                        OleStdFree(lpOCS->lpszTo);
                        lpOCS->lpszTo = NULL;
                }

                // store new source in lpOCS->lpszDisplayName
                OleStdFree(lpOCS->lpszDisplayName);
                lpOCS->lpszDisplayName = OleStdCopyString(szDisplayName);
                lpOCS->nFileLength = nLenFile;

                return 0;
        }

        switch (iMsg)
        {
        case WM_NOTIFY:
            if (((NMHDR*)lParam)->code == CDN_HELP)
            {
                goto POSTHELP;
            }
            break;
        case WM_COMMAND:
            if (wID == pshHelp)
            {
POSTHELP:
                PostMessage(lpCS->lpOCS->hWndOwner, uMsgHelp,
                        (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
            }
            break;
        case WM_INITDIALOG:
            return FChangeSourceInit(hDlg, wParam, lParam);
        }

        return 0;
}

/*
 * FChangeSourceInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Change Source dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FChangeSourceInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPCHANGESOURCE lpCS = (LPCHANGESOURCE)LpvStandardInit(hDlg, sizeof(CHANGESOURCE), NULL);

        // PvStandardInit send a termination to us already.
        if (NULL == lpCS)
                return FALSE;

        LPOLEUICHANGESOURCE lpOCS=
                (LPOLEUICHANGESOURCE)((LPOPENFILENAME)lParam)->lCustData;
        lpCS->lpOCS = lpOCS;
        lpCS->nIDD = IDD_CHANGESOURCE;

        // Setup Item text box with item part of lpszDisplayName
        LPTSTR lpszItemName = lpOCS->lpszDisplayName + lpOCS->nFileLength;
        if (*lpszItemName != '\0')
                SetDlgItemText(hDlg, edt2, lpszItemName+1);
        SendDlgItemMessage(hDlg, edt2, EM_LIMITTEXT, MAX_PATH, 0L);

        // Change the caption
        if (NULL!=lpOCS->lpszCaption)
                SetWindowText(hDlg, lpOCS->lpszCaption);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpCS, hDlg, WM_INITDIALOG, wParam, lpOCS->lCustData);
#ifdef CHICO
        TCHAR szTemp[MAX_PATH];
        LoadString(_g_hOleStdResInst, IDS_CHNGSRCOKBUTTON , szTemp, MAX_PATH);
        CommDlg_OpenSave_SetControlText(GetParent(hDlg), IDOK, szTemp);
#endif
        return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\common.cpp ===
/*
 * COMMON.CPP
 *
 * Standardized (and centralized) pieces of each OLEDLG dialog function:
 *
 *  UStandardValidation     Validates standard fields in each dialog structure
 *  UStandardInvocation     Invokes a dialog through DialogBoxIndirectParam
 *  LpvStandardInit         Common WM_INITDIALOG processing
 *  LpvStandardEntry        Common code to execute on dialog proc entry.
 *  UStandardHook           Centralized hook calling function.
 *  StandardCleanup         Common exit/cleanup code.
 *  StandardShowDlgItem     Show-Enable/Hide-Disable dialog item
 *      StandardEnableDlgItem   Enable/Disable dialog item
 *  StandardResizeDlgY          Resize dialog to fit controls
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"

OLEDBGDATA

/*
 * UStandardValidation
 *
 * Purpose:
 *  Performs validation on the standard pieces of any dialog structure,
 *  that is, the fields defined in the OLEUISTANDARD structure.
 *
 * Parameters:
 *  lpUI            const LPOLEUISTANDARD pointing to the shared data of
 *                  all structs.
 *  cbExpect        const UINT structure size desired by the caller.
 *  phDlgMem        const HGLOBAL FAR * in which to store a loaded customized
 *                  template, if one exists.
 *                  (This may be NULL in which case the template pointer isn't
 *                  needed by the calling function and should be released.)
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS if all validation succeeded.  Otherwise
 *                  it will be one of the standard error codes.
 */
UINT WINAPI UStandardValidation(LPOLEUISTANDARD lpUI, const UINT cbExpect,
        HGLOBAL* phMemDlg)
{
        /*
         * 1.  Validate non-NULL pointer parameter.  Note:  We don't validate
         *     phDlg since it's not passed from an external source.
         */
        if (NULL == lpUI)
                return OLEUI_ERR_STRUCTURENULL;

        // 2.  Validate that the structure is readable and writable.
        if (IsBadWritePtr(lpUI, cbExpect))
                return OLEUI_ERR_STRUCTUREINVALID;

        // 3.  Validate the structure size
        if (cbExpect != lpUI->cbStruct)
                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // 4.  Validate owner-window handle.  NULL is considered valid.
        if (NULL != lpUI->hWndOwner && !IsWindow(lpUI->hWndOwner))
                return OLEUI_ERR_HWNDOWNERINVALID;

        // 5.  Validate the dialog caption.  NULL is considered valid.
        if (NULL != lpUI->lpszCaption && IsBadReadPtr(lpUI->lpszCaption, 1))
                return OLEUI_ERR_LPSZCAPTIONINVALID;

        // 6.  Validate the hook pointer.  NULL is considered valid.
        if (NULL != lpUI->lpfnHook && IsBadCodePtr((FARPROC)lpUI->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        /*
         * 7.  If hInstance is non-NULL, we have to also check lpszTemplate.
         *     Otherwise, lpszTemplate is not used and requires no validation.
         *     lpszTemplate cannot be NULL if used.
         */
        HGLOBAL hMem = NULL;
        if (NULL != lpUI->hInstance)
        {
                //Best we can try is one character
                if (NULL == lpUI->lpszTemplate || (HIWORD(PtrToUlong(lpUI->lpszTemplate)) != 0 &&
                        IsBadReadPtr(lpUI->lpszTemplate, 1)))
                        return OLEUI_ERR_LPSZTEMPLATEINVALID;
                HRSRC hRes = FindResource(lpUI->hInstance, lpUI->lpszTemplate, RT_DIALOG);
                if (NULL == hRes)
                    return OLEUI_ERR_FINDTEMPLATEFAILURE;

                hMem = LoadResource(lpUI->hInstance, hRes);
                if (NULL == hMem)
                    return OLEUI_ERR_LOADTEMPLATEFAILURE;
        }

        // 8. If hResource is non-NULL, be sure we can lock it.
        if (NULL != lpUI->hResource)
        {
                if ((LPSTR)NULL == LockResource(lpUI->hResource))
                        return OLEUI_ERR_HRESOURCEINVALID;
        }

        /*
         * Here we have hMem==NULL if we should use the standard template
         * or the one in lpUI->hResource.  If hMem is non-NULL, then we
         * loaded one from the calling application's resources which the
         * caller of this function has to free if it sees any other error.
         */
        if (NULL != phMemDlg)
        {
            *phMemDlg = hMem;
        }
        return OLEUI_SUCCESS;
}

/*
 * UStandardInvocation
 *
 * Purpose:
 *  Provides standard template loading and calling on DialogBoxIndirectParam
 *  for all the OLE UI dialogs.
 *
 * Parameters:
 *  lpDlgProc       DLGPROC of the dialog function.
 *  lpUI            LPOLEUISTANDARD containing the dialog structure.
 *  hMemDlg         HGLOBAL containing the dialog template.  If this
 *                  is NULL and lpUI->hResource is NULL, then we load
 *                  the standard template given the name in lpszStdTemplate
 *  lpszStdTemplate LPCSTR standard template to load if hMemDlg is NULL
 *                  and lpUI->hResource is NULL.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS if all is well, otherwise and error
 *                  code.
 */
UINT WINAPI UStandardInvocation(
        DLGPROC lpDlgProc, LPOLEUISTANDARD lpUI, HGLOBAL hMemDlg, LPTSTR lpszStdTemplate)
{
        // Make sure we have a template, then lock it down
        HGLOBAL hTemplate = hMemDlg;
        if (NULL == hTemplate)
                hTemplate = lpUI->hResource;

        if (NULL == hTemplate)
        {
                HRSRC hRes = FindResource(_g_hOleStdResInst, (LPCTSTR) lpszStdTemplate, RT_DIALOG);
                if (NULL == hRes)
                        return OLEUI_ERR_FINDTEMPLATEFAILURE;

                hTemplate = LoadResource(_g_hOleStdResInst, hRes);
                if (NULL == hTemplate)
                        return OLEUI_ERR_LOADTEMPLATEFAILURE;
        }

        /*
         * hTemplate has the template to use, so now we can invoke the dialog.
         * Since we have exported all of our dialog procedures using the
         * _keyword, we do not need to call MakeProcInstance,
         * we can ue the dialog procedure address directly.
         */

        INT_PTR iRet = DialogBoxIndirectParam(_g_hOleStdResInst, (LPCDLGTEMPLATE)hTemplate,
                lpUI->hWndOwner, lpDlgProc, (LPARAM)lpUI);

        if (-1 == iRet)
                return OLEUI_ERR_DIALOGFAILURE;

        // Return the code from EndDialog, generally OLEUI_OK or OLEUI_CANCEL
        return (UINT)iRet;
}

/*
 * LpvStandardInit
 *
 * Purpose:
 *  Default actions for WM_INITDIALOG handling in the dialog, allocating
 *  a dialog-specific structure, setting that memory as a dialog property,
 *  and creating a small font if necessary setting that font as a property.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  cbStruct        UINT size of dialog-specific structure to allocate.
 *  fCreateFont     BOOL indicating if we need to create a small Helv
 *                  font for this dialog.
 *  phFont          HFONT FAR * in which to place a created font.  Can be
 *                  NULL if fCreateFont is FALSE.
 *
 * Return Value:
 *  LPVOID          Pointer to global memory allocated for the dialog.
 *                  The memory will have been set as a dialog property
 *                  using the STRUCTUREPROP label.
 */
LPVOID WINAPI LpvStandardInit(HWND hDlg, UINT cbStruct, HFONT* phFont)
{
        // Must have at least sizeof(void*) bytes in cbStruct
        if (sizeof(void*) > cbStruct)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
                return NULL;
        }

        HGLOBAL gh = GlobalAlloc(GHND, cbStruct);
        if (NULL == gh)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
                return NULL;
        }
        LPVOID lpv = GlobalLock(gh);
        SetProp(hDlg, STRUCTUREPROP, gh);

        if (phFont != NULL)
            *phFont = NULL;
        if (!bWin4 && phFont != NULL)
        {
                // Create the non-bold font for result and file texts.  We call
                HFONT hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);
                LOGFONT lf;
                GetObject(hFont, sizeof(LOGFONT), &lf);
                lf.lfWeight = FW_NORMAL;

                // Attempt to create the font.  If this fails, then we return no font.
                *phFont = CreateFontIndirect(&lf);

                // If we couldn't create the font, we'll do with the default.
                if (NULL != *phFont)
                        SetProp(hDlg, FONTPROP, (HANDLE)*phFont);
        }

        // Setup the context help mode (WS_EX_CONTEXTHELP)
        if (bWin4)
        {
                DWORD dwExStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
                dwExStyle |= WS_EX_CONTEXTHELP;
                SetWindowLong(hDlg, GWL_EXSTYLE, dwExStyle);
        }

        return lpv;
}

typedef struct COMMON
{
        OLEUISTANDARD*  pStandard;
        UINT                    nIDD;

} COMMON, *PCOMMON, FAR* LPCOMMON;


/*
 * LpvStandardEntry
 *
 * Purpose:
 *  Retrieves the dialog's structure property and calls the hook
 *  as necessary.  This should be called on entry into all dialog
 *  procedures.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  iMsg            UINT message to the dialog
 *  wParam, lParam  WPARAM, LPARAM message parameters
 *  puHookResult    UINT FAR * in which this function stores the return value
 *                  from the hook if it is called.  If no hook is available,
 *                  this will be FALSE.
 *
 * Return Value:
 *  LPVOID          Pointer to the dialog's extra structure held in the
 *                  STRUCTUREPROP property.
 */
// char szDebug[100];
 
LPVOID WINAPI LpvStandardEntry(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam, UINT FAR * puHookResult)
{
    // This will fail under WM_INITDIALOG, where we allocate using StandardInit
    LPVOID  lpv = NULL;
    HGLOBAL gh = GetProp(hDlg, STRUCTUREPROP);


    if (NULL != puHookResult && NULL != gh)
    {
        *puHookResult = 0;

        // gh was locked previously, lock and unlock to get lpv
        lpv = GlobalLock(gh);
        GlobalUnlock(gh);

        // Call the hook for all messages except WM_INITDIALOG
        if (NULL != lpv && WM_INITDIALOG != iMsg)
        *puHookResult = UStandardHook(lpv, hDlg, iMsg, wParam, lParam);

        // Default processing for various messages
        LPCOMMON lpCommon = (LPCOMMON)lpv;
        if (*puHookResult == 0 && NULL != lpv)
        {
            switch (iMsg)
            {
                // handle standard Win4 help messages
            case WM_HELP:
                {
                HWND hWndChild = (HWND)((LPHELPINFO)lParam)->hItemHandle;
                //skip read-only controls (requested by Help folks)
                //basically the help strings for items like ObjectName on GnrlProps
                //give useless information. 
                //If we do not make this check now the other option is to turn ON
                //the #if 0 inside the switch. That is ugly.

                    if (hWndChild!=hDlg	) 
                    {
                        int iCtrlId = ((LPHELPINFO)lParam)->iCtrlId;
                        // wsprintfA(szDebug,"\n @@@ hWnd= %lx, hChld = %lx,  ctrlId = %d ", hDlg, hWndChild, iCtrlId);
                        // OutputDebugStringA(szDebug);
                        switch (iCtrlId)
                        {
                            // list of control IDs that should not have help
                        case -1:		//IDC_STATIC
                        case 0xffff:    //IDC_STATIC
                        case IDC_CI_GROUP:
                        case IDC_GP_OBJECTICON:
                            break;
                        default:
                            StandardHelp(hWndChild, lpCommon->nIDD);                        

                        }
                    }
                *puHookResult = TRUE;  //We handled the message.
                break;
            } //case WM_HELP

            case WM_CONTEXTMENU:
                {
                    POINT pt;
                    int iCtrlId;
                    HWND hwndChild = NULL;
                    if( hDlg == (HWND) wParam )
                    {
                        GetCursorPos(&pt);
                        ScreenToClient(hDlg, &pt);
                        hwndChild = ChildWindowFromPointEx(hDlg, pt, 
                        CWP_SKIPINVISIBLE); 
                        //hWndChild will now be either hDlg or hWnd of the ctrl   
                    }

                    if ( hwndChild != hDlg ) 
                    {
                        if (hwndChild) 
                        {
                            iCtrlId = GetDlgCtrlID(hwndChild);
                        }
                        else
                        {
                            iCtrlId = GetDlgCtrlID((HWND)wParam);
                        }
                        // wsprintfA(szDebug, "\n ### hWnd= %lx, hChld = %lx,  ctrlId = %d ", hDlg, hwndChild, iCtrlId);
                        // OutputDebugStringA(szDebug);
                        switch (iCtrlId)
                        {
                            // list of control IDs that should not have help
                        case -1:        //  IDC_STATIC
                        case 0xffff:    //  IDC_STATIC
                        case IDC_CI_GROUP:
                        case IDC_GP_OBJECTICON:
                        break;
                        default:
                            StandardContextMenu(wParam, lParam, lpCommon->nIDD);
                        }
                    }

                    *puHookResult = TRUE;  //We handled the message.
                    break;
                }   // case WM_CONTEXTMENU

            case WM_CTLCOLOREDIT:
                {
                    // make readonly edits have gray background
                    if (bWin4 && (GetWindowLong((HWND)lParam, GWL_STYLE)
                        & ES_READONLY))
                    {
                        *puHookResult = (UINT)SendMessage(hDlg, WM_CTLCOLORSTATIC, wParam, lParam);
                    }
                    break;
                }   
            }   //switch (iMsg)
        }   //*puHookResult == 0
    } //NULL != puHookResult 
    return lpv;
}

/*
 * UStandardHook
 *
 * Purpose:
 *  Provides a generic hook calling function assuming that all private
 *  dialog structures have a far pointer to their assocated public
 *  structure as the first field, and that the first part of the public
 *  structure matches an OLEUISTANDARD.
 *
 * Parameters:
 *  pv              PVOID to the dialog structure.
 *  hDlg            HWND to send with the call to the hook.
 *  iMsg            UINT message to send to the hook.
 *  wParam, lParam  WPARAM, LPARAM message parameters
 *
 * Return Value:
 *  UINT            Return value from the hook, zero to indicate that
 *                  default action should occur,  nonzero to specify
 *                  that the hook did process the message.  In some
 *                  circumstances it will be important for the hook to
 *                  return a non-trivial non-zero value here, such as
 *                  a brush from WM_CTLCOLOR, in which case the caller
 *                  should return that value from the dialog procedure.
 */
UINT WINAPI UStandardHook(LPVOID lpv, HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        UINT uRet = 0;
        LPOLEUISTANDARD lpUI = *((LPOLEUISTANDARD FAR *)lpv);
        if (NULL != lpUI && NULL != lpUI->lpfnHook)
        {
                /*
                 * In order for the hook to have the proper DS, they should be
                 * compiling with -GA -GEs so and usin __to get everything
                 * set up properly.
                 */
                uRet = (*lpUI->lpfnHook)(hDlg, iMsg, wParam, lParam);
        }
        return uRet;
}

/*
 * StandardCleanup
 *
 * Purpose:
 *  Removes properties and reverses any other standard initiazation
 *  done through StandardSetup.
 *
 * Parameters:
 *  lpv             LPVOID containing the private dialog structure.
 *  hDlg            HWND of the dialog closing.
 *
 * Return Value:
 *  None
 */
void WINAPI StandardCleanup(LPVOID lpv, HWND hDlg)
{
        HFONT hFont=(HFONT)RemoveProp(hDlg, FONTPROP);
        if (NULL != hFont)
        {
            DeleteObject(hFont);
        }

        HGLOBAL gh = RemoveProp(hDlg, STRUCTUREPROP);
        if (gh != NULL)
        {
                GlobalUnlock(gh);
                GlobalFree(gh);
        }
}

/* StandardShowDlgItem
 * -------------------
 *    Show & Enable or Hide & Disable a dialog item as appropriate.
 *    it is NOT sufficient to simply hide the item; it must be disabled
 *    too or the keyboard accelerator still functions.
 */
void WINAPI StandardShowDlgItem(HWND hDlg, int idControl, int nCmdShow)
{
        HWND hItem = GetDlgItem(hDlg, idControl);
        if (hItem != NULL)
        {
                ShowWindow(hItem, nCmdShow);
                EnableWindow(hItem, nCmdShow != SW_HIDE);
        }
}

/* StandardEnableDlgItem
 * -------------------
 *    Enable/Disable a dialog item. If the item does not exist
 *        this call is a noop.
 */
void WINAPI StandardEnableDlgItem(HWND hDlg, int idControl, BOOL bEnable)
{
        HWND hItem = GetDlgItem(hDlg, idControl);
        if (hItem != NULL)
                EnableWindow(hItem, bEnable);
}

/* StandardResizeDlgY
 * ------------------
 *    Resize a dialog to fit around the visible controls.  This is used
 *        for dialogs which remove controls from the bottom of the dialogs.
 *    A good example of this is the convert dialog, which when CF_HIDERESULTS
 *    is selected, removes the "results box" at the bottom of the dialog.
 *        This implementation currently
 */
BOOL WINAPI StandardResizeDlgY(HWND hDlg)
{
        RECT rect;

        // determine maxY by looking at all child windows on the dialog
        int maxY = 0;
        HWND hChild = GetWindow(hDlg, GW_CHILD);
        while (hChild != NULL)
        {
                if (GetWindowLong(hChild, GWL_STYLE) & WS_VISIBLE)
                {
                        GetWindowRect(hChild, &rect);
                        if (rect.bottom > maxY)
                                maxY = rect.bottom;
                }
                hChild = GetWindow(hChild, GW_HWNDNEXT);
        }

        if (maxY > 0)
        {
                // get current font that the dialog is using
                HFONT hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0);
                if (hFont == NULL)
                        hFont = (HFONT)GetStockObject(SYSTEM_FONT);
                OleDbgAssert(hFont != NULL);

                // calculate height of the font in pixels
                HDC hDC = GetDC(NULL);
                hFont = (HFONT)SelectObject(hDC, hFont);
                TEXTMETRIC tm;
                GetTextMetrics(hDC, &tm);
                SelectObject(hDC, hFont);
                ReleaseDC(NULL, hDC);

                // determine if window is too large and resize if necessary
                GetWindowRect(hDlg, &rect);
                if (rect.bottom > maxY + tm.tmHeight)
                {
                        // window is too large -- resize it
                        rect.bottom = maxY + tm.tmHeight;
                        SetWindowPos(hDlg, NULL,
                                0, 0, rect.right-rect.left, rect.bottom-rect.top,
                                SWP_NOMOVE|SWP_NOACTIVATE|SWP_NOZORDER);
                        return TRUE;
                }
        }

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Support for Windows 95 help
#define HELPFILE        TEXT("mfcuix.hlp")

LPDWORD LoadHelpInfo(UINT nIDD)
{
        HRSRC hrsrc = FindResource(_g_hOleStdResInst, MAKEINTRESOURCE(nIDD),
                MAKEINTRESOURCE(RT_HELPINFO));
        if (hrsrc == NULL)
                return NULL;

        HGLOBAL hHelpInfo = LoadResource(_g_hOleStdResInst, hrsrc);
        if (hHelpInfo == NULL)
                return NULL;

        LPDWORD lpdwHelpInfo = (LPDWORD)LockResource(hHelpInfo);
        return lpdwHelpInfo;
}

void WINAPI StandardHelp(HWND hWnd, UINT nIDD)
{
        LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
        if (lpdwHelpInfo == NULL)
        {
                OleDbgOut1(TEXT("Warning: unable to load help information (RT_HELPINFO)\n"));
                return;
        }
/*
        int id=GetDlgCtrlID( hWnd);
        wsprintfA(szDebug,"\n HH @@@### hWnd= %lx, ctrlId = %d %lx", hWnd,id,id);
        OutputDebugStringA(szDebug);
*/
        
        WinHelp(hWnd, HELPFILE, HELP_WM_HELP, (ULONG_PTR)lpdwHelpInfo);
}

void WINAPI StandardContextMenu(WPARAM wParam, LPARAM, UINT nIDD)
{
        LPDWORD lpdwHelpInfo = LoadHelpInfo(nIDD);
        if (lpdwHelpInfo == NULL)
        {
                OleDbgOut1(TEXT("Warning: unable to load help information (RT_HELPINFO)\n"));
                return;
        }
/*
        int id=GetDlgCtrlID((HWND)wParam);
        wsprintfA(szDebug,"\n CC $$$*** hWnd= %lx, ctrlId = %d %lx ",(HWND)wParam,id,id);
        OutputDebugStringA(szDebug);
*/
        
        WinHelp((HWND)wParam, HELPFILE, HELP_CONTEXTMENU, (ULONG_PTR)lpdwHelpInfo);
}

/////////////////////////////////////////////////////////////////////////////
// StandardPropertySheet (stub for Windows 95 API PropertySheet)

typedef void (WINAPI* LPFNINITCOMMONCONTROLS)(VOID);

int WINAPI StandardInitCommonControls()
{
        TASKDATA* pTaskData = GetTaskData();
        OleDbgAssert(pTaskData != NULL);

        if (pTaskData->hInstCommCtrl == NULL)
        {
                pTaskData->hInstCommCtrl = LoadLibrary(TEXT("comctl32.dll"));
                if (pTaskData->hInstCommCtrl == NULL)
                        goto Error;

                LPFNINITCOMMONCONTROLS lpfnInitCommonControls = (LPFNINITCOMMONCONTROLS)
                        GetProcAddress(pTaskData->hInstCommCtrl, "InitCommonControls");
                if (lpfnInitCommonControls == NULL)
                        goto ErrorFreeLibrary;
                (*lpfnInitCommonControls)();
        }
        return 0;

ErrorFreeLibrary:
        if (pTaskData->hInstCommCtrl != NULL)
        {
                FreeLibrary(pTaskData->hInstCommCtrl);
                pTaskData->hInstCommCtrl = NULL;
        }

Error:
        return -1;
}

typedef int (WINAPI* LPFNPROPERTYSHEET)(LPCPROPSHEETHEADER);

int WINAPI StandardPropertySheet(LPPROPSHEETHEADER lpPS, BOOL fWide)
{
        int nResult = StandardInitCommonControls();
        if (nResult < 0)
                return nResult;

        TASKDATA* pTaskData = GetTaskData();
        OleDbgAssert(pTaskData != NULL);

        LPFNPROPERTYSHEET lpfnPropertySheet;
        if (fWide)
        {
            lpfnPropertySheet = (LPFNPROPERTYSHEET)GetProcAddress(pTaskData->hInstCommCtrl, "PropertySheetW");
        }
        else
        {
            lpfnPropertySheet = (LPFNPROPERTYSHEET)GetProcAddress(pTaskData->hInstCommCtrl, "PropertySheetA");
        }
        if (lpfnPropertySheet == NULL)
                return -1;

        nResult = (*lpfnPropertySheet)(lpPS);
        return nResult;
}

typedef HICON (WINAPI* LPFNEXTRACTICON)(HINSTANCE, LPCTSTR, UINT);

HICON StandardExtractIcon(HINSTANCE hInst, LPCTSTR lpszExeFileName, UINT nIconIndex)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNEXTRACTICON lpfnExtractIcon;

    if (pTaskData->hInstShell == NULL)
    {
        pTaskData->hInstShell = LoadLibrary(TEXT("shell32.dll"));
        if (pTaskData->hInstShell == NULL)
            goto Error;
    }
    lpfnExtractIcon = (LPFNEXTRACTICON)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstShell, "ExtractIconW");
#else
    GetProcAddress(pTaskData->hInstShell, "ExtractIconA");
#endif
    if (lpfnExtractIcon == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnExtractIcon)(hInst, lpszExeFileName, nIconIndex);

ErrorFreeLibrary:
    if (pTaskData->hInstShell != NULL)
    {
            FreeLibrary(pTaskData->hInstShell);
            pTaskData->hInstShell = NULL;
    }

Error:
    return NULL;
}


typedef BOOL (WINAPI* LPFNGETOPENFILENAME)(LPOPENFILENAME);

BOOL StandardGetOpenFileName(LPOPENFILENAME lpofn)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNGETOPENFILENAME lpfnGetOpenFileName;

    if (pTaskData->hInstComDlg == NULL)
    {
        pTaskData->hInstComDlg = LoadLibrary(TEXT("comdlg32.dll"));
        if (pTaskData->hInstComDlg == NULL)
            goto Error;
    }
    lpfnGetOpenFileName = (LPFNGETOPENFILENAME)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstComDlg, "GetOpenFileNameW");
#else
    GetProcAddress(pTaskData->hInstComDlg, "GetOpenFileNameA");
#endif
    if (lpfnGetOpenFileName == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnGetOpenFileName)(lpofn);

ErrorFreeLibrary:
    if (pTaskData->hInstComDlg != NULL)
    {
            FreeLibrary(pTaskData->hInstComDlg);
            pTaskData->hInstComDlg = NULL;
    }

Error:
    return FALSE;
}

typedef short (WINAPI* LPFNGETFILETITLE)(LPCTSTR, LPTSTR, WORD);

short StandardGetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf)
{
    TASKDATA* pTaskData = GetTaskData();
    OleDbgAssert(pTaskData != NULL);
    LPFNGETFILETITLE lpfnGetFileTitle;

    if (pTaskData->hInstComDlg == NULL)
    {
        pTaskData->hInstComDlg = LoadLibrary(TEXT("comdlg32.dll"));
        if (pTaskData->hInstComDlg == NULL)
            goto Error;
    }
    lpfnGetFileTitle = (LPFNGETFILETITLE)
#ifdef UNICODE
    GetProcAddress(pTaskData->hInstComDlg, "GetFileTitleW");
#else
    GetProcAddress(pTaskData->hInstComDlg, "GetFileTitleA");
#endif
    if (lpfnGetFileTitle == NULL)
            goto ErrorFreeLibrary;
    return (*lpfnGetFileTitle)(lpszFile, lpszTitle, cbBuf);

ErrorFreeLibrary:
    if (pTaskData->hInstComDlg != NULL)
    {
            FreeLibrary(pTaskData->hInstComDlg);
            pTaskData->hInstComDlg = NULL;
    }

Error:
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\common.h ===
/*
 * COMMON.H
 *
 * Structures and definitions applicable to all OLE 2.0 UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _COMMON_H_
#define _COMMON_H_

// Macros to handle control message packing between Win16 and Win32
#ifndef COMMANDPARAMS
#define COMMANDPARAMS(wID, wCode, hWndMsg)                          \
        WORD        wID     = LOWORD(wParam);                       \
        WORD        wCode   = HIWORD(wParam);                       \
        HWND        hWndMsg = (HWND)lParam;
#endif

#ifndef SendCommand
#define SendCommand(hWnd, wID, wCode, hControl)                     \
                        SendMessage(hWnd, WM_COMMAND, MAKELONG(wID, wCode)      \
                                                , (LPARAM)hControl)
#endif

// Property labels used to store dialog structures and fonts
#define STRUCTUREPROP       TEXT("Structure")
#define FONTPROP            TEXT("Font")

#ifndef WM_HELP

// WM_HELP is new Windows 95 help message
#define WM_HELP         0x0053
// WM_CONTEXTMENU is new Windows 95 right button menus
#define WM_CONTEXTMENU  0x007B

typedef struct tagHELPINFO      /* Structure pointed to by lParam of WM_HELP */
{
    UINT    cbSize;             /* Size in bytes of this struct  */
    int     iContextType;       /* Either HELPINFO_WINDOW or HELPINFO_MENUITEM */
    int     iCtrlId;            /* Control Id or a Menu item Id. */
    HANDLE  hItemHandle;        /* hWnd of control or hMenu.     */
    DWORD   dwContextId;        /* Context Id associated with this item */
    POINT   MousePos;           /* Mouse Position in screen co-ordinates */
}  HELPINFO, FAR *LPHELPINFO;

#define HELP_CONTEXTMENU        0x000a
#define HELP_WM_HELP            0x000c

#endif //!WM_HELP


#ifndef WS_EX_CONTEXTHELP
#define WS_EX_CONTEXTHELP       0x0400L
#endif

#ifndef OFN_EXPLORER
#define OFN_EXPLORER            0x00080000
#endif

#ifndef WS_EX_CLIENTEDGE
#define WS_EX_CLIENTEDGE        0x200
#endif


/*
 * Standard structure for all dialogs.  This commonality lets us make
 * a single piece of code that will validate this entire structure and
 * perform any necessary initialization.
 */

typedef struct tagOLEUISTANDARD
{
        // These IN fields are standard across all OLEUI dialog functions.
        DWORD           cbStruct;       // Structure Size
        DWORD           dwFlags;        // IN-OUT:  Flags
        HWND            hWndOwner;      // Owning window
        LPCTSTR         lpszCaption;    // Dialog caption bar contents
        LPFNOLEUIHOOK   lpfnHook;       // Hook callback
        LPARAM          lCustData;      // Custom data to pass to hook
        HINSTANCE       hInstance;      // Instance for customized template name
        LPCTSTR         lpszTemplate;   // Customized template name
        HRSRC           hResource;      // Customized template handle

} OLEUISTANDARD, *POLEUISTANDARD, FAR *LPOLEUISTANDARD;

// Function prototypes
// COMMON.CPP

UINT WINAPI UStandardValidation(LPOLEUISTANDARD, const UINT, HGLOBAL*);
UINT WINAPI UStandardInvocation(DLGPROC, LPOLEUISTANDARD, HGLOBAL, LPTSTR);
LPVOID WINAPI LpvStandardInit(HWND, UINT, HFONT* = NULL);
LPVOID WINAPI LpvStandardEntry(HWND, UINT, WPARAM, LPARAM, UINT FAR *);
UINT WINAPI UStandardHook(LPVOID, HWND, UINT, WPARAM, LPARAM);
void WINAPI StandardCleanup(LPVOID, HWND);
void WINAPI StandardShowDlgItem(HWND hDlg, int idControl, int nCmdShow);
void WINAPI StandardEnableDlgItem(HWND hDlg, int idControl, BOOL bEnable);
BOOL WINAPI StandardResizeDlgY(HWND hDlg);
void WINAPI StandardHelp(HWND, UINT);
void WINAPI StandardContextMenu(WPARAM, LPARAM, UINT nIDD);
UINT InternalObjectProperties(LPOLEUIOBJECTPROPS lpOP, BOOL fWide);
int WINAPI StandardPropertySheet(LPPROPSHEETHEADER lpPS, BOOL fWide);
int WINAPI StandardInitCommonControls();
HICON StandardExtractIcon(HINSTANCE hInst, LPCTSTR lpszExeFileName, UINT nIconIndex);
BOOL StandardGetOpenFileName(LPOPENFILENAME lpofn);
short StandardGetFileTitle(LPCTSTR lpszFile, LPTSTR lpszTitle, WORD cbBuf);

// shared globals: registered messages
extern UINT uMsgHelp;
extern UINT uMsgEndDialog;
extern UINT uMsgBrowse;
extern UINT uMsgChangeIcon;
extern UINT uMsgFileOKString;
extern UINT uMsgCloseBusyDlg;
extern UINT uMsgConvert;
extern UINT uMsgChangeSource;
extern UINT uMsgAddControl;
extern UINT uMsgBrowseOFN;

typedef struct tagTASKDATA
{
        HINSTANCE hInstCommCtrl;
        HINSTANCE hInstShell;
        HINSTANCE hInstComDlg;
} TASKDATA;

STDAPI_(TASKDATA*) GetTaskData();       // returns TASKDATA for current process

extern BOOL bWin4;                      // TRUE if running Win4 or greater
extern BOOL bSharedData;        // TRUE if runing Win32s

/////////////////////////////////////////////////////////////////////////////
// Maximum buffer sizes

// Maximum key size we read from the RegDB.
#define OLEUI_CCHKEYMAX             256  // same in geticon.c too
#define OLEUI_CCHKEYMAX_SIZE        OLEUI_CCHKEYMAX*sizeof(TCHAR)

// Maximum length of Object menu
#define OLEUI_OBJECTMENUMAX         256

// Maximim length of a path in BYTEs
#define MAX_PATH_SIZE               (MAX_PATH*sizeof(TCHAR))

// Icon label length
#define OLEUI_CCHLABELMAX           80  // same in geticon.c too (doubled)
#define OLEUI_CCHLABELMAX_SIZE      OLEUI_CCHLABELMAX*sizeof(TCHAR)

// Length of the CLSID string
#define OLEUI_CCHCLSIDSTRING        39
#define OLEUI_CCHCLSIDSTRING_SIZE   OLEUI_CCHCLSIDSTRING*sizeof(TCHAR)

#endif //_COMMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\links.cpp ===
/*
 * links.c
 *
 * Implements the OleUIEditLinks function which invokes the complete
 * Edit Links dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include <commdlg.h>
#include <dlgs.h>
#include <stdlib.h>

OLEDBGDATA

// INTERNAL INFORMATION STARTS HERE
#define OLEUI_SZMAX 255
#define LINKTYPELEN 30  // was 9, now I've more than tripled it
#define szNULL    TEXT("\0")

typedef UINT (CALLBACK* COMMDLGHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

// Internally used structure

typedef struct tagLINKINFO
{
        DWORD   dwLink;             // app specific identifier of a link
        LPTSTR  lpszDisplayName;    // file based part of name
        LPTSTR  lpszItemName;       // object part of name
        LPTSTR  lpszShortFileName;  // filename without path
        LPTSTR  lpszShortLinkType;  // Short link type - progID
        LPTSTR  lpszFullLinkType;   // Full link type - user friendly name
        LPTSTR  lpszAMX;            // Is the link auto (A) man (M) or dead (X)
        ULONG   clenFileName;       // count of file part of mon.
        BOOL    fSourceAvailable;   // bound or not - on boot assume yes??
        BOOL    fIsAuto;            // 1 =automatic, 0=manual update
        BOOL    fIsMarked;          // 1 = marked, 0 = not
        BOOL    fDontFree;          // Don't free this data since it's being reused
        BOOL    fIsSelected;        // item selected or to be selected
} LINKINFO, FAR* LPLINKINFO;

typedef struct tagEDITLINKS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIEDITLINKS    lpOEL;  // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        BOOL        fClose;         // Does the button read cancel (0) or
                                                                // close (1)?
        BOOL        fItemsExist;    // TRUE, items in lbox, FALSE, none
        UINT        nChgSrcHelpID;  // ID for Help callback from ChangeSrc dlg
        TCHAR       szClose[50];    // Text for Close button
                                                                //   (when Cancel button gets renamed)
        int         nColPos[3];     // tab positions for list box
        int         nHeightLine;    // height of each line in owner draw listbox
        int         nMaxCharWidth;  // maximim width of text in owner draw listbox

} EDITLINKS, *PEDITLINKS, FAR *LPEDITLINKS;

// Internal function prototypes
// LINKS.CPP

INT_PTR CALLBACK EditLinksDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FEditLinksInit(HWND, WPARAM, LPARAM);
BOOL Container_ChangeSource(HWND, LPEDITLINKS);
HRESULT Container_AutomaticManual(HWND, BOOL, LPEDITLINKS);
HRESULT CancelLink(HWND, LPEDITLINKS);
HRESULT Container_UpdateNow(HWND, LPEDITLINKS);
HRESULT Container_OpenSource(HWND, LPEDITLINKS);
int AddLinkLBItem(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPLINKINFO lpLI,
        BOOL fGetSelected);
VOID BreakString(LPLINKINFO);
int GetSelectedItems(HWND, int FAR* FAR*);
VOID InitControls(HWND hDlg, LPEDITLINKS lpEL);
VOID UpdateLinkLBItem(HWND hListBox, int nIndex, LPEDITLINKS lpEL, BOOL bSelect);
VOID ChangeAllLinks(HWND hLIstBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPTSTR lpszFrom, LPTSTR lpszTo);
int LoadLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr);
VOID RefreshLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr);


/*
* OleUIEditLinks
*
* Purpose:
*  Invokes the standard OLE Edit Links dialog box allowing the user
*  to manipulate ole links (delete, update, change source, etc).
*
* Parameters:
*  lpEL            LPOLEUIEditLinks pointing to the in-out structure
*                  for this dialog.
*
* Return Value:
*  UINT            One of the following codes, indicating success or error:
*                      OLEUI_SUCCESS           Success
*                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
*/
STDAPI_(UINT) OleUIEditLinks(LPOLEUIEDITLINKS lpEL)
{
        HGLOBAL  hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpEL, sizeof(OLEUIEDITLINKS),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Validate interface.
        if (NULL == lpEL->lpOleUILinkContainer)
        {
            uRet = OLEUI_ELERR_LINKCNTRNULL;
        }
        else if(IsBadReadPtr(lpEL->lpOleUILinkContainer, sizeof(IOleUILinkContainer)))
        {
            uRet = OLEUI_ELERR_LINKCNTRINVALID;
        }

        if (OLEUI_SUCCESS != uRet)
        {
            return(uRet);
        }

        UINT nIDD = bWin4 ? IDD_EDITLINKS4 : IDD_EDITLINKS;

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(EditLinksDialogProc, (LPOLEUISTANDARD)lpEL,
                hMemDlg, MAKEINTRESOURCE(nIDD));
        return uRet;
}

/*
* EditLinksDialogProc
*
* Purpose:
*  Implements the OLE Edit Links dialog as invoked through the
*  OleUIEditLinks function.
*
* Parameters:
*  Standard
*
* Return Value:
*  Standard
*/
INT_PTR CALLBACK EditLinksDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPEDITLINKS lpEL = (LPEDITLINKS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (BOOL)uRet;

        //Process help message from secondary dialog
        if ((iMsg == uMsgHelp) && (lpEL))
        {
                PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpEL)
            {
                StandardCleanup(lpEL, hDlg);
            }
            break;
        case WM_INITDIALOG:
                return FEditLinksInit(hDlg, wParam, lParam);

        case WM_MEASUREITEM:
                {
                        LPMEASUREITEMSTRUCT lpMIS = (LPMEASUREITEMSTRUCT)lParam;
                        int nHeightLine;

                        if (lpEL && lpEL->nHeightLine != -1)
                        {
                                // use cached height
                                nHeightLine = lpEL->nHeightLine;
                        }
                        else
                        {
                                HFONT hFont;
                                HDC   hDC;
                                TEXTMETRIC  tm;

                                hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L);

                                if (hFont == NULL)
                                        hFont = (HFONT)GetStockObject(SYSTEM_FONT);

                                hDC = GetDC(hDlg);
                                hFont = (HFONT)SelectObject(hDC, hFont);

                                GetTextMetrics(hDC, &tm);
                                nHeightLine = tm.tmHeight;

                                if (lpEL)
                                {
                                        lpEL->nHeightLine = nHeightLine;
                                        lpEL->nMaxCharWidth = tm.tmMaxCharWidth;
                                }
                                ReleaseDC(hDlg, hDC);
                        }
                        lpMIS->itemHeight = nHeightLine;
                }
                break;

        case WM_DRAWITEM:
                {
                        LPDRAWITEMSTRUCT lpDIS = (LPDRAWITEMSTRUCT)lParam;
                        LPLINKINFO lpLI = (LPLINKINFO)lpDIS->itemData;

                        if ((int)lpDIS->itemID < 0)
                                break;

                        if ((ODA_DRAWENTIRE | ODA_SELECT) & lpDIS->itemAction)
                        {
                                HBRUSH hbr;
                                COLORREF crText;
                                if (ODS_SELECTED & lpDIS->itemState)
                                {
                                        /*Get proper txt colors */
                                        crText = SetTextColor(lpDIS->hDC,
                                                        GetSysColor(COLOR_HIGHLIGHTTEXT));
                                        hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                                        lpLI->fIsSelected = TRUE;
                                }
                                else
                                {
                                        hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
                                        lpLI->fIsSelected = FALSE;
                                }

                                FillRect(lpDIS->hDC, &lpDIS->rcItem, hbr);
                                DeleteObject(hbr);

                                int nOldBkMode = SetBkMode(lpDIS->hDC, TRANSPARENT);

                                RECT rcClip;
                                if (lpLI->lpszDisplayName)
                                {
                                        TCHAR szTemp[MAX_PATH];
                                        lstrcpy(szTemp, lpLI->lpszDisplayName);
                                        LPTSTR lpsz = ChopText(
                                                        lpDIS->hwndItem,
                                                        lpEL->nColPos[1] - lpEL->nColPos[0]
                                                                - (lpEL->nMaxCharWidth > 0 ?
                                                                lpEL->nMaxCharWidth : 5),
                                                        szTemp, 0
                                        );
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[0];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.left + lpEL->nColPos[1]
                                                                        - (lpEL->nMaxCharWidth > 0 ?
                                                                        lpEL->nMaxCharWidth : 5);
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpsz,
                                                        lstrlen(lpsz),
                                                        NULL
                                        );
                                }
                                if (lpLI->lpszShortLinkType)
                                {
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[1];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.left + lpEL->nColPos[2]
                                                                        - (lpEL->nMaxCharWidth > 0 ?
                                                                        lpEL->nMaxCharWidth : 5);
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpLI->lpszShortLinkType,
                                                        lstrlen(lpLI->lpszShortLinkType),
                                                        NULL
                                        );
                                }
                                if (lpLI->lpszAMX)
                                {
                                        rcClip.left = lpDIS->rcItem.left + lpEL->nColPos[2];
                                        rcClip.top = lpDIS->rcItem.top;
                                        rcClip.right = lpDIS->rcItem.right;
                                        rcClip.bottom = lpDIS->rcItem.bottom;
                                        ExtTextOut(
                                                        lpDIS->hDC,
                                                        rcClip.left,
                                                        rcClip.top,
                                                        ETO_CLIPPED,
                                                        (LPRECT)&rcClip,
                                                        lpLI->lpszAMX,
                                                        lstrlen(lpLI->lpszAMX),
                                                        NULL
                                        );
                                }

                                SetBkMode(lpDIS->hDC, nOldBkMode);

                                // restore orig colors if we changed them
                                if (ODS_SELECTED & lpDIS->itemState)
                                        SetTextColor(lpDIS->hDC, crText);

                        }
                        if (ODA_FOCUS & lpDIS->itemAction)
                                DrawFocusRect(lpDIS->hDC, &lpDIS->rcItem);
                }
                return TRUE;

        case WM_DELETEITEM:
                {
                        LPDELETEITEMSTRUCT lpDIS = (LPDELETEITEMSTRUCT)lParam;
                        UINT idCtl = (UINT)wParam;
                        LPLINKINFO lpLI = (LPLINKINFO)lpDIS->itemData;

                        if (lpLI->lpszDisplayName)
                                OleStdFree((LPVOID)lpLI->lpszDisplayName);
                        if (lpLI->lpszShortLinkType)
                                OleStdFree((LPVOID)lpLI->lpszShortLinkType);
                        if (lpLI->lpszFullLinkType)
                                OleStdFree((LPVOID)lpLI->lpszFullLinkType);

                        /* The ChangeSource processing reuses allocated space for
                        **    links that have been modified.
                        */
                        // Don't free the LINKINFO for the changed links
                        if (lpLI->fDontFree)
                                lpLI->fDontFree = FALSE;
                        else
                        {
                                if (lpLI->lpszAMX)
                                        OleStdFree((LPVOID)lpLI->lpszAMX);
                                OleStdFree((LPVOID)lpLI);
                        }
                }
                return TRUE;

        case WM_COMPAREITEM:
                {
                        LPCOMPAREITEMSTRUCT lpCIS = (LPCOMPAREITEMSTRUCT)lParam;
                        LPLINKINFO lpLI1 = (LPLINKINFO)lpCIS->itemData1;
                        LPLINKINFO lpLI2 = (LPLINKINFO)lpCIS->itemData2;

                        // Sort list entries by DisplayName
                        return lstrcmp(lpLI1->lpszDisplayName, lpLI2->lpszDisplayName);
                }

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_EL_CHANGESOURCE:
                        {
                                BOOL fRet = Container_ChangeSource(hDlg, lpEL);
                                if (!fRet)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                         MB_ICONEXCLAMATION | MB_OK);
                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_AUTOMATIC:
                        {
                                CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, 1);
                                CheckDlgButton(hDlg, IDC_EL_MANUAL, 0);

                                HRESULT hErr = Container_AutomaticManual(hDlg, TRUE, lpEL);
                                if (hErr != NOERROR)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                        MB_ICONEXCLAMATION | MB_OK);

                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_MANUAL:
                        {
                                CheckDlgButton(hDlg, IDC_EL_MANUAL, 1);
                                CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, 0);

                                HRESULT hErr = Container_AutomaticManual(hDlg, FALSE, lpEL);
                                if (hErr != NOERROR)
                                        PopupMessage(hDlg, IDS_LINKS, IDS_FAILED,
                                                        MB_ICONEXCLAMATION | MB_OK);

                                InitControls(hDlg, lpEL);
                        }
                        break;

                case IDC_EL_CANCELLINK:
                        CancelLink(hDlg,lpEL);
                        InitControls(hDlg, lpEL);
                        break;

                case IDC_EL_UPDATENOW:
                        Container_UpdateNow(hDlg, lpEL);
                        InitControls(hDlg, lpEL);
                        break;

                case IDC_EL_OPENSOURCE:
                        {
                            HRESULT hErr = Container_OpenSource(hDlg, lpEL);
                            if (hErr != NOERROR)
                            {
                                InitControls(hDlg, lpEL);
                                // Don't close dialog
                                break;
                            }
                            SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                        } // fall through

                case IDC_EL_LINKSLISTBOX:
                        if (wCode == LBN_SELCHANGE)
                                InitControls(hDlg, lpEL);
                        break;

                case IDCANCEL:
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp,
                                (WPARAM)hDlg, MAKELPARAM(IDD_EDITLINKS, 0));
                        break;
                }
                break;

        default:
                if (lpEL != NULL && iMsg == lpEL->nChgSrcHelpID)
                {
                        PostMessage(lpEL->lpOEL->hWndOwner, uMsgHelp,
                                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGESOURCE, 0));
                }
                if (iMsg == uMsgBrowseOFN &&
                        lpEL != NULL && lpEL->lpOEL && lpEL->lpOEL->hWndOwner)
                {
                        SendMessage(lpEL->lpOEL->hWndOwner, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/*
 * FEditLinksInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Edit Links dialog box.
 *
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FEditLinksInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPEDITLINKS lpEL = (LPEDITLINKS)LpvStandardInit(hDlg, sizeof(EDITLINKS), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpEL)
                return FALSE;

        LPOLEUIEDITLINKS lpOEL = (LPOLEUIEDITLINKS)lParam;
        lpEL->lpOEL = lpOEL;
        lpEL->nIDD = IDD_EDITLINKS;

        // metrics unknown so far
        lpEL->nHeightLine = -1;
        lpEL->nMaxCharWidth = -1;

        /* calculate the column positions relative to the listbox */
        HWND hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        RECT rc;
        GetWindowRect(hListBox, (LPRECT)&rc);
        int nStart = rc.left;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL1), (LPRECT)&rc);
        lpEL->nColPos[0] = rc.left - nStart;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL2), (LPRECT)&rc);
        lpEL->nColPos[1] = rc.left - nStart;
        GetWindowRect(GetDlgItem(hDlg, IDC_EL_COL3), (LPRECT)&rc);
        lpEL->nColPos[2] = rc.left - nStart;

        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;

        ULONG cLinks = LoadLinkLB(hListBox, lpOleUILinkCntr);
        if ((int)cLinks < 0)
                return FALSE;

        BOOL fDlgItem = (BOOL)cLinks;
        lpEL->fItemsExist = (BOOL)cLinks;

        InitControls(hDlg, lpEL);

        // Copy other information from lpOEL that we might modify.

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                // Do this for as many controls as you need it for.
                // SendDlgItemMessage(hDlg, ID_<UFILL>, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Show or hide the help button
        if (!(lpEL->lpOEL->dwFlags & ELF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        /*
         * PERFORM OTHER INITIALIZATION HERE.  ON ANY LoadString
         * FAILURE POST OLEUI_MSG_ENDDIALOG WITH OLEUI_ERR_LOADSTRING.
         */

        // If requested disable UpdateNow button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLEUPDATENOW))
                StandardShowDlgItem(hDlg, IDC_EL_UPDATENOW, SW_HIDE);

        // If requested disable OpenSource button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLEOPENSOURCE))
                StandardShowDlgItem(hDlg, IDC_EL_OPENSOURCE, SW_HIDE);

        // If requested disable UpdateNow button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLECHANGESOURCE))
                StandardShowDlgItem(hDlg, IDC_EL_CHANGESOURCE, SW_HIDE);

        // If requested disable CancelLink button
        if ((lpEL->lpOEL->dwFlags & ELF_DISABLECANCELLINK))
                StandardShowDlgItem(hDlg, IDC_EL_CANCELLINK, SW_HIDE);

        // Change the caption
        if (NULL!=lpOEL->lpszCaption)
                SetWindowText(hDlg, lpOEL->lpszCaption);

        // Load 'Close' string used to rename Cancel button
        int n = LoadString(_g_hOleStdResInst, IDS_CLOSE, lpEL->szClose, sizeof(lpEL->szClose)/sizeof(TCHAR));
        if (!n)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                return FALSE;
        }

        if (cLinks > 0)
                SetFocus(hListBox);
        else
                SetFocus(GetDlgItem(hDlg, IDCANCEL));

        lpEL->nChgSrcHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // Call the hook with lCustData in lParam
        UStandardHook(lpEL, hDlg, WM_INITDIALOG, wParam, lpOEL->lCustData);

        return FALSE;
}

/*
* Container_ChangeSource
*
* Purpose:
*  Tunnel to File Open type dlg and allow user to select new file
*  for file based monikers, OR to change the whole moniker to what
*  the user types into the editable field.
*
* Parameters:
*  hDlg            HWND of the dialog
*  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
*              info)
*
* Return Value:
*  BOOL          for now, because we are not using any ole functions
*                to return an HRESULT.
*  HRESULT       HRESULT value indicating success or failure of
*              changing the moniker value
*/

BOOL Container_ChangeSource(HWND hDlg, LPEDITLINKS lpEL)
{
        HWND hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        int FAR* rgIndex;
        int cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return FALSE;

        if (!cSelItems)
                return TRUE;

        OLEUICHANGESOURCE cs; memset(&cs, 0, sizeof(cs));
        cs.cbStruct = sizeof(cs);
        cs.hWndOwner = hDlg;
        if (lpEL->lpOEL->dwFlags & ELF_SHOWHELP)
                cs.dwFlags |= CSF_SHOWHELP;

        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        cs.lpOleUILinkContainer = lpOleUILinkCntr;

        for (int i = cSelItems-1; i >= 0; i--)
        {
                // allow caller to customize the change source dialog
                LPLINKINFO lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);
                cs.lpszDisplayName = lpLI->lpszDisplayName;
                cs.dwLink = lpLI->dwLink;
                cs.nFileLength = lpLI->clenFileName;

                UINT uRet = UStandardHook(lpEL, hDlg, uMsgChangeSource, 0, (LPARAM)&cs);
                if (!uRet)
                        uRet = (OLEUI_OK == OleUIChangeSource(&cs));
                if (!uRet)
                        break;  // dialog canceled (cancel for all)

                if (!lpEL->fClose)
                {
                        SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                        lpEL->fClose = TRUE;
                }

                // update the list box item for the new name
                //      (note: original lpszDisplayName already freed)
                lpLI->fSourceAvailable = (cs.dwFlags & CSF_VALIDSOURCE);
                lpLI->lpszDisplayName = cs.lpszDisplayName;
                UpdateLinkLBItem(hListBox, rgIndex[i], lpEL, TRUE);

                // if differed only in file name, allow user to change all links
                if (cs.lpszFrom != NULL && cs.lpszTo != NULL)
                        ChangeAllLinks(hListBox, lpOleUILinkCntr, cs.lpszFrom, cs.lpszTo);

                // must free and NULL out the lpszFrom and lpszTo OUT fields
                OleStdFree(cs.lpszFrom);
                cs.lpszFrom = NULL;
                OleStdFree(cs.lpszTo);
                cs.lpszTo = NULL;
        }

        if (rgIndex != NULL)
                OleStdFree(rgIndex);

        return TRUE;
}

/*
* Container_AutomaticManual
*
* Purpose:
*   To change the selected moniker to manual or automatic update.
*
* Parameters:
*  hDlg            HWND of the dialog
*  FAutoMan        Flag indicating AUTO (TRUE/1) or MANUAL(FALSE/0)
*  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
*              info)
*            * this may change - don't know how the linked list
*            * of multi-selected items will work.
* Return Value:
*  HRESULT       HRESULT value indicating success or failure of
*              changing the moniker value
*/

HRESULT Container_AutomaticManual(HWND hDlg, BOOL fAutoMan, LPEDITLINKS lpEL)
{
        HRESULT hErr = NOERROR;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPLINKINFO  lpLI;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        /* Change so looks at flag in structure.  Only update those that
        need to be updated.  Make sure to change flag if status changes.
        */

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);
                if (fAutoMan)
                {
                        // If switching to AUTOMATIC
                        if (!lpLI->fIsAuto)   // Only change MANUAL links
                        {
                                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::SetLinkUpdateOptions called\r\n"));
                                hErr=lpOleUILinkCntr->SetLinkUpdateOptions(
                                                lpLI->dwLink,
                                                OLEUPDATE_ALWAYS
                                );
                                OLEDBG_END2

                                lpLI->fIsAuto=TRUE;
                                lpLI->fIsMarked = TRUE;
                                bUpdate = TRUE;
                        }
                }
                else   // If switching to MANUAL
                {
                        if (lpLI->fIsAuto)  // Only do AUTOMATIC Links
                        {
                                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::SetLinkUpdateOptions called\r\n"));
                                hErr=lpOleUILinkCntr->SetLinkUpdateOptions(
                                                lpLI->dwLink,
                                                OLEUPDATE_ONCALL
                                );
                                OLEDBG_END2

                                lpLI->fIsAuto = FALSE;
                                lpLI->fIsMarked = TRUE;
                                bUpdate = TRUE;
                        }
                }

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::SetLinkUpdateOptions returned"),hErr);
                        break;
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

HRESULT CancelLink(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT hErr;
        LPMONIKER lpmk;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPLINKINFO  lpLI;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        lpmk = NULL;

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);

                UINT uRet = PopupMessage(hDlg, IDS_LINKS,
                        IDS_CONFIRMBREAKLINK, MB_YESNO|MB_ICONQUESTION);
                if (uRet == IDNO)
                        break;

                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::CancelLink called\r\n"));
                hErr = lpOleUILinkCntr->CancelLink(lpLI->dwLink);
                OLEDBG_END2

                if (!lpEL->fClose)
                {
                        SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                        lpEL->fClose = TRUE;
                }

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::CancelLink returned"),hErr);
                        lpLI->fIsMarked = TRUE;
                        bUpdate = TRUE;
                }
                else
                {
                        // Delete links that we make null from listbox
                        SendMessage(hListBox, LB_DELETESTRING, (WPARAM) rgIndex[i], 0L);
                        int i2;
                        for (i2 = i + 1; i2 < cSelItems; i2++)
                        {
                            if (rgIndex[i2] > rgIndex[i])
                                rgIndex[i2]--;
                        }
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

/*
 * Container_UpdateNow
 *
 * Purpose:
 *   Immediately force an update for all (manual) links
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  LPEDITLINKS     Pointer to EditLinks structure (contains all nec. info)
 *            * this may change - don't know how the linked list
 *            * of multi-selected items will work.
 * Return Value:
 *  HRESULT       HRESULT value indicating success or failure of
 *              changing the moniker value
 */
HRESULT Container_UpdateNow(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT         hErr;
        LPLINKINFO      lpLI;
        int cSelItems;
        int FAR* rgIndex;
        int i = 0;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);
        BOOL        bUpdate = FALSE;

        OleDbgAssert(lpOleUILinkCntr);

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (!cSelItems)
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[i], 0);

                OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::UpdateLink called\r\n"));
                hErr = lpOleUILinkCntr->UpdateLink(
                                lpLI->dwLink,
                                TRUE,
                                FALSE
                );
                OLEDBG_END2
                bUpdate = TRUE;
                lpLI->fIsMarked = TRUE;

                if (hErr != NOERROR)
                {
                        OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::UpdateLink returned"),hErr);
                        break;
                }
        }

        if (bUpdate)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;

}

/*
 * Container_OpenSource
 *
 * Purpose:
 *   Immediately force an update for all (manual) links
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  LPEDITLINKS     Pointer to EditLinks structure (contains all nec.
 *              info)
 *
 * Return Value:
 *  HRESULT       HRESULT value indicating success or failure of
 *              changing the moniker value
 */

HRESULT Container_OpenSource(HWND hDlg, LPEDITLINKS lpEL)
{
        HRESULT         hErr;
        int             cSelItems;
        int FAR*        rgIndex;
        LPLINKINFO      lpLI;
        RECT            rcPosRect;
        LPOLEUILINKCONTAINER lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;
        HWND            hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);

        OleDbgAssert(lpOleUILinkCntr);

        rcPosRect.top = 0;
        rcPosRect.left = 0;
        rcPosRect.right = 0;
        rcPosRect.bottom = 0;

        cSelItems = GetSelectedItems(hListBox, &rgIndex);

        if (cSelItems < 0)
                return ResultFromScode(E_FAIL);

        if (cSelItems != 1)     // can't open source for multiple items
                return NOERROR;

        HCURSOR hCursorOld = HourGlassOn();

        if (!lpEL->fClose)
        {
                SetDlgItemText(hDlg, IDCANCEL, lpEL->szClose);
                lpEL->fClose = TRUE;
        }

        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, rgIndex[0], 0);

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::OpenLinkSource called\r\n"));
        hErr = lpOleUILinkCntr->OpenLinkSource(
                        lpLI->dwLink
        );
        OLEDBG_END2

        UpdateLinkLBItem(hListBox, rgIndex[0], lpEL, TRUE);
        if (hErr != NOERROR) {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::OpenLinkSource returned"),hErr);
        }

        if (rgIndex) 
                OleStdFree((LPVOID)rgIndex);

        HourGlassOff(hCursorOld);

        return hErr;
}

/* AddLinkLBItem
** -------------
**
**    Add the item pointed to by lpLI to the Link ListBox and return
**    the index of it in the ListBox
*/
int AddLinkLBItem(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPLINKINFO lpLI, BOOL fGetSelected)
{
        HRESULT hErr;
        DWORD dwUpdateOpt;
        int nIndex;

        OleDbgAssert(lpOleUILinkCntr && hListBox && lpLI);

        lpLI->fDontFree = FALSE;

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::GetLinkSource called\r\n"));
        hErr = lpOleUILinkCntr->GetLinkSource(
                        lpLI->dwLink,
                        (LPTSTR FAR*)&lpLI->lpszDisplayName,
                        (ULONG FAR*)&lpLI->clenFileName,
                        (LPTSTR FAR*)&lpLI->lpszFullLinkType,
                        (LPTSTR FAR*)&lpLI->lpszShortLinkType,
                        (BOOL FAR*)&lpLI->fSourceAvailable,
                        fGetSelected ? (BOOL FAR*)&lpLI->fIsSelected : NULL
        );
        OLEDBG_END2

        if (hErr != NOERROR)
        {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::GetLinkSource returned"),hErr);
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_GETLINKSOURCE,
                                MB_ICONEXCLAMATION | MB_OK);
                goto cleanup;
        }

        OLEDBG_BEGIN2(TEXT("IOleUILinkContainer::GetLinkUpdateOptions called\r\n"));
        hErr=lpOleUILinkCntr->GetLinkUpdateOptions(
                        lpLI->dwLink,
                        (LPDWORD)&dwUpdateOpt
        );
        OLEDBG_END2

        if (hErr != NOERROR)
        {
                OleDbgOutHResult(TEXT("WARNING: IOleUILinkContainer::GetLinkUpdateOptions returned"),hErr);
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_GETLINKUPDATEOPTIONS,
                                MB_ICONEXCLAMATION | MB_OK);

                goto cleanup;
        }

        if (lpLI->fSourceAvailable)
        {
                if (dwUpdateOpt == OLEUPDATE_ALWAYS)
                {
                        lpLI->fIsAuto = TRUE;
                        LoadString(_g_hOleStdResInst, IDS_LINK_AUTO, lpLI->lpszAMX,
                                        (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));
                }
                else
                {
                        lpLI->fIsAuto = FALSE;
                        LoadString(_g_hOleStdResInst, IDS_LINK_MANUAL, lpLI->lpszAMX,
                                        (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));
                }
        }
        else
                LoadString(_g_hOleStdResInst, IDS_LINK_UNKNOWN, lpLI->lpszAMX,
                                (int)OleStdGetSize((LPVOID)lpLI->lpszAMX) / sizeof (TCHAR));

        BreakString(lpLI);

        nIndex = (int)SendMessage(hListBox, LB_ADDSTRING, (WPARAM)0,
                        (LPARAM)lpLI);

        if (nIndex == LB_ERR)
        {
                PopupMessage(hListBox, IDS_LINKS, IDS_ERR_ADDSTRING,
                                MB_ICONEXCLAMATION | MB_OK);
                goto cleanup;
        }
        return nIndex;

cleanup:
        if (lpLI->lpszDisplayName)
                OleStdFree((LPVOID)lpLI->lpszDisplayName);

        if (lpLI->lpszShortLinkType)
                OleStdFree((LPVOID)lpLI->lpszShortLinkType);

        if (lpLI->lpszFullLinkType)
                OleStdFree((LPVOID)lpLI->lpszFullLinkType);

        return -1;
}

/* BreakString
 * -----------
 *
 *  Purpose:
 *      Break the lpszDisplayName into various parts
 *
 *  Parameters:
 *      lpLI            pointer to LINKINFO structure
 *
 *  Returns:
 *
 */
VOID BreakString(LPLINKINFO lpLI)
{
        LPTSTR lpsz;

        if (!lpLI->clenFileName ||
                (lstrlen(lpLI->lpszDisplayName)==(int)lpLI->clenFileName))
        {
                lpLI->lpszItemName = NULL;
        }
        else
        {
                lpLI->lpszItemName = lpLI->lpszDisplayName + lpLI->clenFileName;
        }

        // search from last character of filename
        lpsz = lpLI->lpszDisplayName + lstrlen(lpLI->lpszDisplayName);
        while (lpsz > lpLI->lpszDisplayName)
        {
                lpsz = CharPrev(lpLI->lpszDisplayName, lpsz);
                if ((*lpsz == '\\') || (*lpsz == '/') || (*lpsz == ':'))
                        break;
        }

        if (lpsz == lpLI->lpszDisplayName)
                lpLI->lpszShortFileName = lpsz;
        else
                lpLI->lpszShortFileName = CharNext(lpsz);
}

/* GetSelectedItems
 * ----------------
 *
 *  Purpose:
 *      Retrieve the indices of the selected items in the listbox
 *      Note that *lprgIndex needed to be free after using the function
 *
 *  Parameters:
 *      hListBox        window handle of listbox
 *      lprgIndex       pointer to an integer array to receive the indices
 *                      must be freed afterwards
 *
 *  Returns:
 *      number of indices retrieved, -1 if error
 */
int GetSelectedItems(HWND hListBox, int FAR* FAR* lprgIndex)
{
        DWORD cSelItems;
        DWORD cCheckItems;

        *lprgIndex = NULL;

        cSelItems = (DWORD)SendMessage(hListBox, LB_GETSELCOUNT, 0, 0L);
        if ((int)cSelItems < 0)      // error
                return (int)cSelItems;

        if (!cSelItems)
                return 0;

        *lprgIndex = (int FAR*)OleStdMalloc((int)cSelItems * sizeof(int));

        cCheckItems = (DWORD)SendMessage(hListBox, LB_GETSELITEMS,
                        (WPARAM) cSelItems, (LPARAM) (int FAR *) *lprgIndex);

        if (cCheckItems == cSelItems)
                return (int)cSelItems;
        else
        {
                if (*lprgIndex)
                        OleStdFree((LPVOID)*lprgIndex);
                *lprgIndex = NULL;
                return 0;
        }
}

/* InitControls
 * ------------
 *
 *  Purpose:
 *      Initialize the state of the Auto/Manual button, Link source/type
 *      static field, etc in the dialogs according to the selection in the
 *      listbox
 *
 *  Parameters:
 *      hDlg        handle to the dialog window
 */
VOID InitControls(HWND hDlg, LPEDITLINKS lpEL)
{
        int         cSelItems;
        HWND        hListBox;
        int         i;
        int FAR*    rgIndex;
        LPLINKINFO  lpLI;
        LPTSTR      lpszType = NULL;
        LPTSTR      lpszSource = NULL;
        int         cAuto = 0;
        int         cManual = 0;
        BOOL        bSameType = TRUE;
        BOOL        bSameSource = TRUE;
        TCHAR       tsz[MAX_PATH];
        LPTSTR      lpsz;

        hListBox = GetDlgItem(hDlg, IDC_EL_LINKSLISTBOX);

        cSelItems = GetSelectedItems(hListBox, &rgIndex);
        if (cSelItems < 0) 
			return;

		if ((cSelItems > 0) && (rgIndex == NULL))
			return;

        StandardEnableDlgItem(hDlg, IDC_EL_AUTOMATIC, (BOOL)cSelItems);
        StandardEnableDlgItem(hDlg, IDC_EL_MANUAL, (BOOL)cSelItems);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLECANCELLINK))
                StandardEnableDlgItem(hDlg, IDC_EL_CANCELLINK, (BOOL)cSelItems);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLEOPENSOURCE))
                StandardEnableDlgItem(hDlg, IDC_EL_OPENSOURCE, cSelItems == 1);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLECHANGESOURCE))
                StandardEnableDlgItem(hDlg, IDC_EL_CHANGESOURCE, cSelItems == 1);
        if (lpEL && !(lpEL->lpOEL->dwFlags & ELF_DISABLEUPDATENOW))
                StandardEnableDlgItem(hDlg, IDC_EL_UPDATENOW, (BOOL)cSelItems);

        for (i = 0; i < cSelItems; i++)
        {
                lpLI = (LPLINKINFO)SendDlgItemMessage(hDlg, IDC_EL_LINKSLISTBOX,
                        LB_GETITEMDATA, rgIndex[i], 0);

                if (lpszSource && lpLI->lpszDisplayName)
                {
                        if (bSameSource && lstrcmp(lpszSource, lpLI->lpszDisplayName))
                                bSameSource = FALSE;
                }
                else
                        lpszSource = lpLI->lpszDisplayName;

                if (lpszType && lpLI->lpszFullLinkType)
                {
                        if (bSameType && lstrcmp(lpszType, lpLI->lpszFullLinkType))
                                bSameType = FALSE;
                }
                else
                        lpszType = lpLI->lpszFullLinkType;

                if (lpLI->fIsAuto)
                        cAuto++;
                else
                        cManual++;
        }

        CheckDlgButton(hDlg, IDC_EL_AUTOMATIC, cAuto && !cManual);
        CheckDlgButton(hDlg, IDC_EL_MANUAL, !cAuto && cManual);

        /* fill full source in static text box
        **    below list
        */
        if (!bSameSource || !lpszSource)
                lpszSource = szNULL;
        lstrcpy(tsz, lpszSource);
        lpsz = ChopText(GetDlgItem(hDlg, IDC_EL_LINKSOURCE), 0, tsz, 0);
        SetDlgItemText(hDlg, IDC_EL_LINKSOURCE, lpsz);

        /* fill full link type name in static
        **    "type" text box
        */
        if (!bSameType || !lpszType)
                lpszType = szNULL;
        SetDlgItemText(hDlg, IDC_EL_LINKTYPE, lpszType);

        if (rgIndex)
                OleStdFree((LPVOID)rgIndex);
}


/* UpdateLinkLBItem
 * -----------------
 *
 *  Purpose:
 *      Update the linkinfo struct in the listbox to reflect the changes
 *      made by the last operation. It is done simply by removing the item
 *      from the listbox and add it back.
 *
 *  Parameters:
 *      hListBox        handle of listbox
 *      nIndex          index of listbox item
 *      lpEL            pointer to editlinks structure
 *      bSelect         select the item or not after update
 */
VOID UpdateLinkLBItem(HWND hListBox, int nIndex, LPEDITLINKS lpEL, BOOL bSelect)
{
        LPLINKINFO lpLI;
        LPOLEUILINKCONTAINER    lpOleUILinkCntr;

        if (!hListBox || (nIndex < 0) || !lpEL)
                return;

        lpOleUILinkCntr = lpEL->lpOEL->lpOleUILinkContainer;

        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);

        if (lpLI == NULL)
                return;

        /* Don't free the data associated with this listbox item
        **    because we are going to reuse the allocated space for
        **    the modified link. WM_DELETEITEM processing in the
        **    dialog checks this flag before deleting data
        **    associcated with list item.
        */
        lpLI->fDontFree = TRUE;
        SendMessage(hListBox, LB_DELETESTRING, nIndex, 0L);

        nIndex = AddLinkLBItem(hListBox, lpOleUILinkCntr, lpLI, FALSE);
        if (bSelect)
        {
                SendMessage(hListBox, LB_SETSEL, TRUE, MAKELPARAM(nIndex, 0));
                SendMessage(hListBox, LB_SETCARETINDEX, nIndex, MAKELPARAM(TRUE, 0));
        }
}



/* ChangeAllLinks
 * --------------
 *
 *  Purpose:
 *      Enumerate all the links in the listbox and change those starting
 *      with lpszFrom to lpszTo.
 *
 *  Parameters:
 *      hListBox        window handle of
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *      lpszFrom        prefix for matching
 *      lpszTo          prefix to substitution
 *
 *  Returns:
 */
VOID ChangeAllLinks(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr, LPTSTR lpszFrom, LPTSTR lpszTo)
{
        int     cItems;
        int     nIndex;
        int     cFrom;
        LPLINKINFO  lpLI;
        TCHAR   szTmp[MAX_PATH];
        BOOL    bFound;

        cFrom = lstrlen(lpszFrom);

        cItems = (int)SendMessage(hListBox, LB_GETCOUNT, 0, 0L);
        OleDbgAssert(cItems >= 0);

        bFound = FALSE;

#ifdef _DEBUG
        OleDbgPrint(3, TEXT("From : "), lpszFrom, 0);
        OleDbgPrint(3, TEXT(""), TEXT("\r\n"), 0);
        OleDbgPrint(3, TEXT("To   : "), lpszTo, 0);
        OleDbgPrint(3, TEXT(""), TEXT("\r\n"), 0);
#endif

        for (nIndex = 0; nIndex < cItems; nIndex++)
        {
                lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);

                // unmark the item
                lpLI->fIsMarked = FALSE;

                /* if the corresponding position for the end of lpszFrom in the
                **    display name is not a separator. We stop comparing this
                **    link.
                */
                if (!*(lpLI->lpszDisplayName + cFrom) ||
                        (*(lpLI->lpszDisplayName + cFrom) == '\\') ||
                        (*(lpLI->lpszDisplayName + cFrom) == '!'))
                {
                        lstrcpyn(szTmp, lpLI->lpszDisplayName, cFrom + 1);
                        if (!lstrcmp(szTmp, lpszFrom))
                        {
                                HRESULT hErr;
                                int nFileLength;
                                ULONG ulDummy;

                                if (!bFound)
                                {
                                        TCHAR szTitle[256];
                                        TCHAR szMsg[256];
                                        TCHAR szBuf[256];
                                        int uRet;

                                        LoadString(_g_hOleStdResInst, IDS_CHANGESOURCE, szTitle,
                                                        sizeof(szTitle)/sizeof(TCHAR));
                                        LoadString(_g_hOleStdResInst, IDS_CHANGEADDITIONALLINKS,
                                                        szMsg, sizeof(szMsg)/sizeof(TCHAR));
                                        wsprintf(szBuf, szMsg, lpszFrom);
                                        uRet = MessageBox(hListBox, szBuf, szTitle,
                                                        MB_ICONQUESTION | MB_YESNO);
                                        if (uRet == IDYES)
                                                bFound = TRUE;
                                        else
                                                return;
                                }

                                lstrcpy(szTmp, lpszTo);
                                lstrcat(szTmp, lpLI->lpszDisplayName + cFrom);
                                nFileLength = lstrlen(szTmp) -
                                        (lpLI->lpszItemName ? lstrlen(lpLI->lpszItemName) : 0);

                                hErr = lpOleUILinkCntr->SetLinkSource(
                                                lpLI->dwLink,
                                                szTmp,
                                                (ULONG)nFileLength,
                                                (ULONG FAR*)&ulDummy,
                                                TRUE
                                );
                                if (hErr != NOERROR)
                                {
                                        lpOleUILinkCntr->SetLinkSource(
                                                        lpLI->dwLink,
                                                        szTmp,
                                                        (ULONG)nFileLength,
                                                        (ULONG FAR*)&ulDummy,
                                                        FALSE);
                                }
                                lpLI->fIsMarked = TRUE;
                        }
                }
        }

        /* have to do the refreshing after processing all links, otherwise
        **    the item positions will change during the process as the
        **    listbox stores items in order
        */
        if (bFound)
                RefreshLinkLB(hListBox, lpOleUILinkCntr);
}



/* LoadLinkLB
 * ----------
 *
 *  Purpose:
 *      Enumerate all links from the Link Container and build up the Link
 *      ListBox
 *
 *  Parameters:
 *      hListBox        window handle of
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *      lpszFrom        prefix for matching
 *      lpszTo          prefix to substitution
 *
 *  Returns:
 *      number of link items loaded, -1 if error
 */
int LoadLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr)
{
        DWORD       dwLink = 0;
        LPLINKINFO  lpLI;
        int         nIndex;
        int         cLinks;

        cLinks = 0;

        while ((dwLink = lpOleUILinkCntr->GetNextLink(dwLink)) != 0)
        {
                lpLI = (LPLINKINFO)OleStdMalloc(sizeof(LINKINFO));
                if (NULL == lpLI)
                        return -1;

                lpLI->fIsMarked = FALSE;
                lpLI->fIsSelected = FALSE;
                lpLI->fDontFree = FALSE;

                lpLI->lpszAMX = (LPTSTR)OleStdMalloc((LINKTYPELEN+1)*sizeof(TCHAR));

                lpLI->dwLink = dwLink;
                cLinks++;
                if ((nIndex = AddLinkLBItem(hListBox,lpOleUILinkCntr,lpLI,TRUE)) < 0)
                        // can't load list box
                        return -1;

                if (lpLI->fIsSelected)
                        SendMessage(hListBox, LB_SETSEL, TRUE, MAKELPARAM(nIndex, 0));
        }
        if (SendMessage(hListBox,LB_GETSELITEMS,(WPARAM)1,(LPARAM)(int FAR*)&nIndex))
                SendMessage(hListBox, LB_SETCARETINDEX, (WPARAM)nIndex, MAKELPARAM(TRUE, 0));

        return cLinks;
}

/* RefreshLinkLB
 * -------------
 *
 *  Purpose:
 *      Enumerate all items in the links listbox and update those with
 *      fIsMarked set.
 *      Note that this is a time consuming routine as it keeps iterating
 *      all items in the listbox until all of them are unmarked.
 *
 *  Parameters:
 *      hListBox        window handle of listbox
 *      lpOleUILinkCntr pointer to OleUI Link Container
 *
 *  Returns:
 *
 */
VOID RefreshLinkLB(HWND hListBox, LPOLEUILINKCONTAINER lpOleUILinkCntr)
{
        int cItems;
        int nIndex;
        LPLINKINFO  lpLI;
        BOOL        bStop;

        OleDbgAssert(hListBox);

        cItems = (int)SendMessage(hListBox, LB_GETCOUNT, 0, 0L);
        OleDbgAssert(cItems >= 0);

        do
        {
                bStop = TRUE;
                for (nIndex = 0; nIndex < cItems; nIndex++)
                {
                        lpLI = (LPLINKINFO)SendMessage(hListBox, LB_GETITEMDATA, nIndex, 0);
                        if (lpLI->fIsMarked)
                        {
                                lpLI->fIsMarked = FALSE;
                                lpLI->fDontFree = TRUE;

                                SendMessage(hListBox, LB_DELETESTRING, nIndex, 0L);
                                nIndex=AddLinkLBItem(hListBox, lpOleUILinkCntr, lpLI, FALSE);
                                if (lpLI->fIsSelected)
                                {
                                        SendMessage(hListBox, LB_SETSEL, (WPARAM)TRUE,
                                                        MAKELPARAM(nIndex, 0));
                                        SendMessage(hListBox, LB_SETCARETINDEX, (WPARAM)nIndex,
                                                        MAKELPARAM(TRUE, 0));
                                }
                                bStop = FALSE;
                                break;
                        }
                }
        } while (!bStop);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\objprop.cpp ===
/*
 * OBJPROP.CPP
 *
 * Implements the OleUIObjectProperties function which invokes the complete
 * Object Properties dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "iconbox.h"
#include "resimage.h"
#include <stddef.h>

OLEDBGDATA

// Internally used structure
typedef struct tagGNRLPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIGNRLPROPS lpOGP;         // Original structure passed.
        UINT            nIDD;                   // IDD of dialog (used for help info)

        CLSID           clsidNew;               // new class ID (if conversion done)

} GNRLPROPS, *PGNRLPROPS, FAR* LPGNRLPROPS;

typedef struct tagVIEWPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIVIEWPROPS lpOVP;         // Original structure passed.
        UINT                    nIDD;           // IDD of dialog (used for help info)

        BOOL                    bIconChanged;
        int                             nCurrentScale;
        BOOL                    bRelativeToOrig;
        DWORD                   dvAspect;

} VIEWPROPS, *PVIEWPROPS, FAR* LPVIEWPROPS;

typedef struct tagLINKPROPS
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUILINKPROPS lpOLP;         // Original structure passed.
        UINT            nIDD;                   // IDD of dialog (used for help info)

        DWORD           dwUpdate;               // original update mode
        LPTSTR          lpszDisplayName;// new link source
        ULONG           nFileLength;    // file name part of source

} LINKPROPS, *PLINKPROPS, FAR* LPLINKPROPS;

// Internal function prototypes
// OBJPROP.CPP

/*
 * OleUIObjectProperties
 *
 * Purpose:
 *  Invokes the standard OLE Object Properties dialog box allowing the user
 *  to change General, View, and Link properties of an OLE object.  This
 *  dialog uses the new Windows 95 tabbed dialogs.
 *
 * Parameters:
 *  lpOP            LPOLEUIObjectProperties pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 *
 */

static UINT WINAPI ValidateObjectProperties(LPOLEUIOBJECTPROPS);
static UINT WINAPI PrepareObjectProperties(LPOLEUIOBJECTPROPS);

STDAPI_(UINT) OleUIObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
#ifdef UNICODE
    return (InternalObjectProperties(lpOP, TRUE));
#else
    return (InternalObjectProperties(lpOP, FALSE));
#endif
}

UINT InternalObjectProperties(LPOLEUIOBJECTPROPS lpOP, BOOL fWide)
{
        // Validate Parameters
        UINT uRet = ValidateObjectProperties(lpOP);
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        if (NULL == lpOP->lpObjInfo)
        {
            return(OLEUI_OPERR_OBJINFOINVALID);
        }

        if (IsBadReadPtr(lpOP->lpObjInfo, sizeof(IOleUIObjInfo)))
        {
            return(OLEUI_OPERR_OBJINFOINVALID);
        }

        if (lpOP->dwFlags & OPF_OBJECTISLINK)
        {
            if (NULL == lpOP->lpLinkInfo)
            {
                return(OLEUI_OPERR_LINKINFOINVALID);
            }

            if (IsBadReadPtr(lpOP->lpLinkInfo, sizeof(IOleUILinkInfo)))
            {
                return(OLEUI_OPERR_LINKINFOINVALID);
            }
        }

        // Fill Missing values in lpPS
        LPPROPSHEETHEADER lpPS = (LPPROPSHEETHEADER)lpOP->lpPS;
        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lpPS->ppsp;
        uRet = PrepareObjectProperties(lpOP);
        if (OLEUI_SUCCESS != uRet)
                return uRet;

        LPTSTR lpszShortType = NULL;
        lpOP->lpObjInfo->GetObjectInfo(lpOP->dwObject, NULL, NULL,
                NULL, &lpszShortType, NULL);
        if (lpszShortType == NULL)
                return OLEUI_ERR_OLEMEMALLOC;

        TCHAR szCaption[256];
        if (lpPS->pszCaption == NULL)
        {
            TCHAR szTemp[256];
            LoadString(_g_hOleStdResInst,
                    (lpOP->dwFlags & OPF_OBJECTISLINK) ?
                            IDS_LINKOBJECTPROPERTIES : IDS_OBJECTPROPERTIES,
                    szTemp, sizeof(szTemp) / sizeof(TCHAR));
            wsprintf(szCaption, szTemp, lpszShortType);
#ifdef UNICODE
            if (!fWide)
            {
                  // We're going to actually call the ANSI version of PropertySheet,
                  // so we need to store the caption as an ANSI string.
                  lstrcpy(szTemp, szCaption);
                  WTOA((char *)szCaption, szTemp, 256);
            }
#endif
            lpPS->pszCaption = szCaption;
        }
        OleStdFree(lpszShortType);

        // Invoke the property sheet
        int nResult = StandardPropertySheet(lpOP->lpPS, fWide);

        // Cleanup any temporary memory allocated during the process
        if (lpPP == NULL)
        {
                OleStdFree((LPVOID)lpOP->lpPS->ppsp);
                lpOP->lpPS->ppsp = NULL;
        }

        // map PropertPage return value to OLEUI_ return code
        if (nResult < 0)
                uRet = OLEUI_OPERR_PROPERTYSHEET;
        else if (nResult == 0)
                uRet = OLEUI_CANCEL;
        else
                uRet = OLEUI_OK;

        return uRet;
}

/////////////////////////////////////////////////////////////////////////////
// Validation code

static UINT WINAPI ValidateGnrlProps(LPOLEUIGNRLPROPS lpGP)
{
        OleDbgAssert(lpGP != NULL);

        if (lpGP->cbStruct != sizeof(OLEUIGNRLPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpGP->lpfnHook && IsBadCodePtr((FARPROC)lpGP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateViewProps(LPOLEUIVIEWPROPS lpVP)
{
        OleDbgAssert(lpVP != NULL);

        if (lpVP->cbStruct != sizeof(OLEUIVIEWPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpVP->lpfnHook && IsBadCodePtr((FARPROC)lpVP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateLinkProps(LPOLEUILINKPROPS lpLP)
{
        OleDbgAssert(lpLP != NULL);

        if (lpLP->cbStruct != sizeof(OLEUILINKPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;
        if (lpLP->lpfnHook && IsBadCodePtr((FARPROC)lpLP->lpfnHook))
                return OLEUI_ERR_LPFNHOOKINVALID;

        return OLEUI_SUCCESS;
}

static UINT WINAPI ValidateObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
        // Validate LPOLEUIOBJECTPROPS lpOP
        if (lpOP == NULL)
                return OLEUI_ERR_STRUCTURENULL;

        if (IsBadWritePtr(lpOP, sizeof(OLEUIOBJECTPROPS)))
                return OLEUI_ERR_STRUCTUREINVALID;

        // Validate cbStruct field of OLEUIOBJECTPROPS
        if (lpOP->cbStruct != sizeof(OLEUIOBJECTPROPS))
                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // Validate "sub" property pointers
        if (lpOP->lpGP == NULL || lpOP->lpVP == NULL ||
                ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP == NULL))
                return OLEUI_OPERR_SUBPROPNULL;

        if (IsBadWritePtr(lpOP->lpGP, sizeof(OLEUIGNRLPROPS)) ||
                IsBadWritePtr(lpOP->lpVP, sizeof(OLEUIVIEWPROPS)) ||
                ((lpOP->dwFlags & OPF_OBJECTISLINK) &&
                        IsBadWritePtr(lpOP->lpLP, sizeof(OLEUILINKPROPS))))
                return OLEUI_OPERR_SUBPROPINVALID;

        // Validate property sheet data pointers
        LPPROPSHEETHEADER lpPS = lpOP->lpPS;
        if (lpPS == NULL)
                return OLEUI_OPERR_PROPSHEETNULL;

// Size of PROPSHEEDHEADER has changed, meaning that if we check for
// the size of PROPSHEETHEADER as we used to, we will break older code.
        if ( IsBadWritePtr(lpPS, sizeof(DWORD)) )
            return OLEUI_OPERR_PROPSHEETINVALID;

        if (IsBadWritePtr(lpPS, lpPS->dwSize))
            return OLEUI_OPERR_PROPSHEETINVALID;

//        DWORD dwSize = lpPS->dwSize;
//        if (dwSize < sizeof(PROPSHEETHEADER))
//                return OLEUI_ERR_CBSTRUCTINCORRECT;

        // If links specified, validate "sub" link property pointer
        if (lpOP->dwFlags & OPF_OBJECTISLINK)
        {
                if (lpPS->ppsp != NULL && lpPS->nPages < 3)
                        return OLEUI_OPERR_PAGESINCORRECT;
        }
        else
        {
                if (lpPS->ppsp != NULL && lpPS->nPages < 2)
                        return OLEUI_OPERR_PAGESINCORRECT;
        }
// Size of PROPSHEETPAGE has changed, meaning that if we check for
// the size of the new PROPSHEETPAGE we will break old code.
//        if (lpPS->ppsp != NULL &&
//                IsBadWritePtr((PROPSHEETPAGE*)lpPS->ppsp,
//                        lpPS->nPages * sizeof(PROPSHEETPAGE)))
//        {
//                return OLEUI_OPERR_INVALIDPAGES;
//        }

        // not setting PSH_PROPSHEETPAGE is not supported
        if (lpOP->dwFlags & OPF_NOFILLDEFAULT)
        {
                if (!(lpPS->dwFlags & PSH_PROPSHEETPAGE))
                        return OLEUI_OPERR_NOTSUPPORTED;
        }
        else if (lpPS->dwFlags != 0)
        {
                return OLEUI_OPERR_NOTSUPPORTED;
        }

        // Sanity check any pages provided
        LPCPROPSHEETPAGE lpPP = lpPS->ppsp;
        for (UINT nPage = 0; nPage < lpPS->nPages; nPage++)
        {
// Size of PROPSHEETPAGE has changed, meaning that if we check for
// the size of the new PROPSHEETPAGE we will break old code.
//                if (lpPP->dwSize != sizeof(PROPSHEETPAGE))
//                        return OLEUI_ERR_CBSTRUCTINCORRECT;
                if (lpPP->pfnDlgProc != NULL)
                        return OLEUI_OPERR_DLGPROCNOTNULL;
                if (lpPP->lParam != 0)
                        return OLEUI_OPERR_LPARAMNOTZERO;
                lpPP = (LPCPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
        }

        // validate individual prop page structures
        UINT uRet = ValidateGnrlProps(lpOP->lpGP);
        if (uRet != OLEUI_SUCCESS)
                return uRet;
        uRet = ValidateViewProps(lpOP->lpVP);
        if (uRet != OLEUI_SUCCESS)
                return uRet;
        if ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP != NULL)
        {
                uRet = ValidateLinkProps(lpOP->lpLP);
                if (uRet != OLEUI_SUCCESS)
                        return uRet;
        }

        return OLEUI_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
// GnrlPropsDialogProc and helpers

// takes a DWORD add commas etc to it and puts the result in the buffer
LPTSTR AddCommas(DWORD dw, LPTSTR pszResult, UINT nMax)
{
    NUMBERFMT numberFmt;
    numberFmt.NumDigits = 0;
    numberFmt.LeadingZero = 0;

    TCHAR szSep[5];
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szSep, sizeof(szSep) / sizeof(TCHAR));
    numberFmt.Grouping = Atol(szSep);
    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szSep, sizeof(szSep) / sizeof(TCHAR));
    numberFmt.lpDecimalSep = numberFmt.lpThousandSep = szSep;
    numberFmt.NegativeOrder= 0;

    TCHAR szTemp[64];
    wsprintf(szTemp, TEXT("%lu"), dw);

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szTemp, &numberFmt, pszResult, nMax);
    return pszResult;
}

const short pwOrders[] = {IDS_BYTES, IDS_ORDERKB, IDS_ORDERMB, IDS_ORDERGB, IDS_ORDERTB};

/* converts numbers into short formats
 *      532     -> 523 bytes
 *      1340    -> 1.3KB
 *      23506   -> 23.5KB
 *              -> 2.4MB
 *              -> 5.2GB
 */
LPTSTR ShortSizeFormat64(__int64 dw64, LPTSTR szBuf)
{
    int i;
    UINT wInt, wLen, wDec;
    TCHAR szTemp[10], szOrder[20], szFormat[5];

    if (dw64 < 1000)
    {
        wsprintf(szTemp, TEXT("%d"), DWORD(dw64));
        i = 0;
    }
    else
    {
        for (i = 1; i < (sizeof(pwOrders) - 1)
            && dw64 >= 1000L * 1024L; dw64 >>= 10, i++)
            ; /* do nothing */

        wInt = DWORD(dw64 >> 10);
        AddCommas(wInt, szTemp, sizeof(szTemp)/sizeof(TCHAR));
        wLen = lstrlen(szTemp);
        if (wLen < 3)
        {
            wDec = DWORD(dw64 - (__int64)wInt * 1024L) * 1000 / 1024;
            // At this point, wDec should be between 0 and 1000
            // we want get the top one (or two) digits.
            wDec /= 10;
            if (wLen == 2)
                wDec /= 10;

            // Note that we need to set the format before getting the
            // intl char.
            lstrcpy(szFormat, TEXT("%02d"));

            szFormat[2] = '0' + 3 - wLen;
                    GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL,
                            szTemp+wLen, sizeof(szTemp)-wLen);
                    wLen = lstrlen(szTemp);
            wLen += wsprintf(szTemp+wLen, szFormat, wDec);
        }
    }

    LoadString(_g_hOleStdResInst, pwOrders[i], szOrder,
               sizeof(szOrder)/sizeof(szOrder[0]));
    wsprintf(szBuf, szOrder, (LPSTR)szTemp);

    return szBuf;
}

LPTSTR WINAPI ShortSizeFormat(DWORD dw, LPTSTR szBuf)
{
        return ShortSizeFormat64((__int64)dw, szBuf);
}

BOOL FGnrlPropsRefresh(HWND hDlg, LPGNRLPROPS lpGP)
{
        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpGP->lpOGP->lpOP;
        LPOLEUIOBJINFO lpObjInfo = lpOP->lpObjInfo;

        // get object's icon
        HGLOBAL hMetaPict;
        lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict, NULL, NULL);
        if (hMetaPict != NULL)
        {
                HICON hIcon = OleUIMetafilePictExtractIcon(hMetaPict);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTICON, STM_SETICON,
                        (WPARAM)hIcon, 0);
        }
        OleUIMetafilePictIconFree(hMetaPict);

        // get type, short type, location, and size of object
        DWORD dwObjSize;
        LPTSTR lpszLabel = NULL;
        LPTSTR lpszType = NULL;
        LPTSTR lpszShortType = NULL;
        LPTSTR lpszLocation = NULL;
        lpObjInfo->GetObjectInfo(lpOP->dwObject, &dwObjSize, &lpszLabel,
                &lpszType, &lpszShortType, &lpszLocation);

        // set name, type, and size of object
        SetDlgItemText(hDlg, IDC_GP_OBJECTNAME, lpszLabel);
        SetDlgItemText(hDlg, IDC_GP_OBJECTTYPE, lpszType);
        SetDlgItemText(hDlg, IDC_GP_OBJECTLOCATION, lpszLocation);
        TCHAR szTemp[128];
        if (dwObjSize == (DWORD)-1)
        {
                LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN, szTemp, 64);
                SetDlgItemText(hDlg, IDC_GP_OBJECTSIZE, szTemp);
        }
        else
        {
                // get the master formatting string
                TCHAR szFormat[64];
                LoadString(_g_hOleStdResInst, IDS_OBJECTSIZE, szFormat, 64);

                // format the size in two ways (short, and with commas)
                TCHAR szNum1[20], szNum2[32];
                ShortSizeFormat(dwObjSize, szNum1);
                AddCommas(dwObjSize, szNum2, 32);
                FormatString2(szTemp, szFormat, szNum1, szNum2);

                // set the control's text
                SetDlgItemText(hDlg, IDC_GP_OBJECTSIZE, szTemp);
        }

        // enable/disable convert button as necessary
        BOOL bEnable = TRUE;
        if (lpOP->dwFlags & (OPF_OBJECTISLINK|OPF_DISABLECONVERT))
                bEnable = FALSE;
        else
        {
                CLSID clsid; WORD wFormat;
                lpObjInfo->GetConvertInfo(lpOP->dwObject, &clsid, &wFormat, NULL, NULL, NULL);
                bEnable = OleUICanConvertOrActivateAs(clsid, FALSE, wFormat);
        }
        StandardEnableDlgItem(hDlg, IDC_GP_CONVERT, bEnable);

        // cleanup temporary info strings
        OleStdFree(lpszLabel);
        OleStdFree(lpszType);
        OleStdFree(lpszShortType);
        OleStdFree(lpszLocation);

        return TRUE;
}

BOOL FGnrlPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPGNRLPROPS lpGP = (LPGNRLPROPS)LpvStandardInit(hDlg, sizeof(GNRLPROPS), &hFont);

        // LpvStandardInit send a termination to us already.
        if (NULL == lpGP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUIGNRLPROPS lpOGP = (LPOLEUIGNRLPROPS)lpPP->lParam;
        lpGP->lpOGP = lpOGP;
        lpGP->nIDD = IDD_GNRLPROPS;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTNAME, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTTYPE, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTLOCATION, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_GP_OBJECTSIZE, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Show or hide the help button
        if (!(lpOGP->lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Initialize the controls
        FGnrlPropsRefresh(hDlg, lpGP);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpGP, hDlg, WM_INITDIALOG, wParam, lpOGP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK GnrlPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPGNRLPROPS lpGP = (LPGNRLPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUIGNRLPROPS lpOGP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUIOBJINFO lpObjInfo = NULL;
        if (lpGP != NULL)
        {
                lpOGP = lpGP->lpOGP;
                if (lpOGP != NULL)
                {
                        lpObjInfo = lpOGP->lpOP->lpObjInfo;
                        lpOP = lpOGP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FGnrlPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_GP_CONVERT:
                        {
                                if(!lpGP)
                                    return TRUE;

                                // Call up convert dialog to obtain new CLSID
                                OLEUICONVERT cv; memset(&cv, 0, sizeof(cv));
                                cv.cbStruct = sizeof(cv);
                                cv.dwFlags |= CF_CONVERTONLY;
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                    cv.dwFlags |= CF_SHOWHELPBUTTON;
                                cv.clsidConvertDefault = lpGP->clsidNew;
                                cv.dvAspect = DVASPECT_CONTENT;
                                lpObjInfo->GetObjectInfo(lpOP->dwObject,
                                        NULL, NULL, &cv.lpszUserType, NULL, NULL);
                                lpObjInfo->GetConvertInfo(lpOP->dwObject,
                                        &cv.clsid, &cv.wFormat, &cv.clsidConvertDefault,
                                        &cv.lpClsidExclude, &cv.cClsidExclude);
                                cv.fIsLinkedObject =
                                        (lpOGP->lpOP->dwFlags & OPF_OBJECTISLINK);
                                if (cv.clsidConvertDefault != CLSID_NULL)
                                        cv.dwFlags |= CF_SETCONVERTDEFAULT;
                                cv.hWndOwner = GetParent(GetParent(hDlg));

                                // allow caller to hook the convert structure
                                uHook = UStandardHook(lpGP, hDlg, uMsgConvert, 0, (LPARAM)&cv);
                                if (0 == uHook)
                                {
                                        uHook = (OLEUI_OK == OleUIConvert(&cv));
                                        SetFocus(hDlg);
                                }

                                // check to see dialog results
                                if (uHook != 0 && (cv.dwFlags & CF_SELECTCONVERTTO))
                                {
                                        lpGP->clsidNew = cv.clsidNew;
                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        return TRUE;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_GNRLPROPS, 0));
                        return TRUE;


                }
                break;

        case PSM_QUERYSIBLINGS:
                if(!lpGP)
                    break;

                SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                switch (wParam)
                {
                case OLEUI_QUERY_GETCLASSID:
                        *(CLSID*)lParam = lpGP->clsidNew;
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                        return TRUE;

                case OLEUI_QUERY_LINKBROKEN:
                        FGnrlPropsRefresh(hDlg, lpGP);
                        return TRUE;
                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_GNRLPROPS, 0));
                    break;
                case PSN_APPLY:
                        if(!lpGP)
                            return TRUE;

                        // apply changes if changes made
                        if (lpGP->clsidNew != CLSID_NULL)
                        {
                                // convert the object -- fail the apply if convert fails
                                if (NOERROR != lpObjInfo->ConvertObject(lpOP->dwObject,
                                        lpGP->clsidNew))
                                {
                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                        return TRUE;
                                }
                                lpGP->clsidNew = CLSID_NULL;
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                {
                        HICON hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_GP_OBJECTICON,
                                STM_GETICON, 0, 0);
                        if (hIcon != NULL)
                                DestroyIcon(hIcon);
                        StandardCleanup((PVOID)lpGP, hDlg);
                }
                return TRUE;
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// ViewPropsDialogProc and helpers

void EnableDisableScaleControls(LPVIEWPROPS lpVP, HWND hDlg)
{
        LPOLEUIVIEWPROPS lpOVP = lpVP->lpOVP;
        BOOL bEnable = !(lpOVP->dwFlags & VPF_DISABLESCALE) &&
                SendDlgItemMessage(hDlg, IDC_VP_ASICON, BM_GETCHECK, 0, 0) == 0;
        StandardEnableDlgItem(hDlg, IDC_VP_SPIN, bEnable);
        StandardEnableDlgItem(hDlg, IDC_VP_PERCENT, bEnable);
        StandardEnableDlgItem(hDlg, IDC_VP_SCALETXT, bEnable);
        bEnable = bEnable && !(lpOVP->dwFlags & VPF_DISABLERELATIVE);
        StandardEnableDlgItem(hDlg, IDC_VP_RELATIVE, bEnable);
}

BOOL FViewPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPVIEWPROPS lpVP = (LPVIEWPROPS)LpvStandardInit(hDlg, sizeof(VIEWPROPS));

        // LpvStandardInit send a termination to us already.
        if (NULL == lpVP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUIVIEWPROPS lpOVP = (LPOLEUIVIEWPROPS)lpPP->lParam;
        lpVP->lpOVP = lpOVP;
        lpVP->nIDD = IDD_VIEWPROPS;

        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpOVP->lpOP;
        LPOLEUIOBJINFO lpObjInfo = lpOP->lpObjInfo;

        // initialize icon and scale variables
        HGLOBAL hMetaPict;
        DWORD dvAspect;
        int nCurrentScale;
        lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict,
                &dvAspect, &nCurrentScale);
        SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET,
                0, (LPARAM)hMetaPict);
        lpVP->nCurrentScale = nCurrentScale;
        lpVP->dvAspect = dvAspect;

        // Initialize the result image
        SendDlgItemMessage(hDlg, IDC_VP_RESULTIMAGE,
                RIM_IMAGESET, RESULTIMAGE_EDITABLE, 0L);

        // Initialize controls
        CheckRadioButton(hDlg, IDC_VP_EDITABLE, IDC_VP_ASICON,
                dvAspect == DVASPECT_CONTENT ?  IDC_VP_EDITABLE : IDC_VP_ASICON);
        SendDlgItemMessage(hDlg, IDC_VP_RELATIVE, BM_SETCHECK,
                (lpOVP->dwFlags & VPF_SELECTRELATIVE) != 0, 0L);
        if (!(lpOVP->dwFlags & VPF_DISABLESCALE))
                SetDlgItemInt(hDlg, IDC_VP_PERCENT, nCurrentScale, FALSE);
        lpVP->bRelativeToOrig = SendDlgItemMessage(hDlg, IDC_VP_RELATIVE,
                BM_GETCHECK, 0, 0) != 0;

        // Setup up-down control as buddy to IDC_VP_PERCENT
        HWND hWndSpin = CreateWindowEx(0, UPDOWN_CLASS, NULL,
                WS_CHILD|UDS_SETBUDDYINT|UDS_ARROWKEYS|UDS_ALIGNRIGHT, 0, 0, 0, 0,
                hDlg, (HMENU)IDC_VP_SPIN, _g_hOleStdInst, NULL);
        if (hWndSpin != NULL)
        {
                SendMessage(hWndSpin, UDM_SETRANGE, 0,
                        MAKELPARAM(lpOVP->nScaleMax, lpOVP->nScaleMin));
                SendMessage(hWndSpin, UDM_SETPOS, 0, nCurrentScale);
                SendMessage(hWndSpin, UDM_SETBUDDY,
                        (WPARAM)GetDlgItem(hDlg, IDC_VP_PERCENT), 0);
                ShowWindow(hWndSpin, SW_SHOW);
        }
        EnableDisableScaleControls(lpVP, hDlg);
        if (!(lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpVP, hDlg, WM_INITDIALOG, wParam, lpOVP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK ViewPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPVIEWPROPS lpVP = (LPVIEWPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUIVIEWPROPS lpOVP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUIOBJINFO lpObjInfo = NULL;
        if (lpVP != NULL)
        {
                lpOVP = lpVP->lpOVP;
                if (lpOVP != NULL)
                {
                        lpObjInfo = lpOVP->lpOP->lpObjInfo;
                        lpOP = lpOVP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FViewPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_VP_ASICON:
                case IDC_VP_EDITABLE:
                        EnableDisableScaleControls(lpVP, hDlg);
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        return TRUE;

                case IDC_VP_CHANGEICON:
                        {
                                // Call up Change Icon dialog to obtain new icon
                                OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));
                                ci.cbStruct = sizeof(ci);
                                ci.dwFlags = CIF_SELECTCURRENT;
                                ci.hWndOwner = GetParent(GetParent(hDlg));
                                ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY,
                                        IBXM_IMAGEGET, 0, 0L);

                                // get classid to look for (may be new class if conversion applied)
                                SendMessage(GetParent(hDlg), PSM_QUERYSIBLINGS,
                                        OLEUI_QUERY_GETCLASSID, (LPARAM)&ci.clsid);
                                lpObjInfo->GetConvertInfo(lpOP->dwObject,
                                        &ci.clsid, NULL, NULL, NULL, NULL);
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                        ci.dwFlags |= CIF_SHOWHELP;

                                // allow the caller to hook the change icon
                                uHook = UStandardHook(lpVP, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);
                                if (0 == uHook)
                                {
                                        uHook = (OLEUI_OK == OleUIChangeIcon(&ci));
                                        SetFocus(hDlg);
                                }
                                if (0 != uHook)
                                {
                                        // apply the changes
                                        SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET, 1,
                                                (LPARAM)ci.hMetaPict);
                                        lpVP->bIconChanged = TRUE;
                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        return TRUE;

                case IDC_VP_PERCENT:
                case IDC_VP_RELATIVE:
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        return TRUE;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_VIEWPROPS, 0));
                        return TRUE;
                }
                break;

        case WM_VSCROLL:
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                break;

        case PSM_QUERYSIBLINGS:
                SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                switch (wParam)
                {
                case OLEUI_QUERY_LINKBROKEN:
					    // lpVP could be NULL in low memory situations-- in this case don't handle
					    // the message.
					    if (lpVP != NULL)
						{
							if (!lpVP->bIconChanged)
							{
                                // re-init icon, since user hasn't changed it
                                HGLOBAL hMetaPict;
                                lpObjInfo->GetViewInfo(lpOP->dwObject, &hMetaPict, NULL, NULL);
                                SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGESET,
												   1, (LPARAM)hMetaPict);
							}
							return TRUE;
						}
                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_VIEWPROPS, 0));
                    break;
                case PSN_APPLY:
                        {
                                HGLOBAL hMetaPict = NULL;
                                int nCurrentScale = -1;
                                DWORD dvAspect = (DWORD)-1;
                                BOOL bRelativeToOrig = FALSE;

                                // handle icon change
                                if (lpVP->bIconChanged)
                                {
                                        hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_VP_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                        lpVP->bIconChanged = FALSE;
                                }

                                // handle scale changes
                                if (IsWindowEnabled(GetDlgItem(hDlg, IDC_VP_PERCENT)))
                                {
                                        // parse the percentage entered
                                        BOOL bValid;
                                        nCurrentScale = GetDlgItemInt(hDlg, IDC_VP_PERCENT, &bValid, FALSE);
                                        if (!bValid)
                                        {
                                                PopupMessage(GetParent(hDlg), IDS_VIEWPROPS,
                                                        IDS_INVALIDPERCENTAGE, MB_OK|MB_ICONEXCLAMATION);

                                                // cancel the call
                                                SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                                return TRUE;
                                        }
                                        // normalize range
                                        int nScaleMin, nScaleMax;
                                        if (lpOVP->nScaleMin > lpOVP->nScaleMax)
                                        {
                                                nScaleMin = lpOVP->nScaleMax;
                                                nScaleMax = lpOVP->nScaleMin;
                                        }
                                        else
                                        {
                                                nScaleMin = lpOVP->nScaleMin;
                                                nScaleMax = lpOVP->nScaleMax;
                                        }
                                        // check range for validity
                                        if (nCurrentScale < nScaleMin || nCurrentScale > nScaleMax)
                                        {
                                                // format appropriate message
                                                TCHAR szCaption[128];
                                                LoadString(_g_hOleStdResInst, IDS_VIEWPROPS, szCaption, 128);
                                                TCHAR szFormat[128];
                                                LoadString(_g_hOleStdResInst, IDS_RANGEERROR, szFormat, 128);
                                                TCHAR szTemp[256], szNum1[32], szNum2[32];
                                                wsprintf(szNum1, _T("%d"), lpOVP->nScaleMin);
                                                wsprintf(szNum2, _T("%d"), lpOVP->nScaleMax);
                                                FormatString2(szTemp, szFormat, szNum1, szNum2);
                                                MessageBox(GetParent(hDlg), szTemp, szCaption, MB_OK|MB_ICONEXCLAMATION);

                                                // and cancel the call
                                                SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                                                return TRUE;
                                        }

                                        // otherwise scale is in correct range
                                        bRelativeToOrig =
                                                SendDlgItemMessage(hDlg, IDC_VP_RELATIVE, BM_GETCHECK, 0, 0) != 0;
                                        if (nCurrentScale != lpVP->nCurrentScale ||
                                                bRelativeToOrig != lpVP->bRelativeToOrig)
                                        {
                                                lpVP->nCurrentScale = nCurrentScale;
                                                lpVP->bRelativeToOrig = bRelativeToOrig;
                                        }
                                }

                                // handle aspect changes
                                if (SendDlgItemMessage(hDlg, IDC_VP_ASICON, BM_GETCHECK, 0, 0L))
                                        dvAspect = DVASPECT_ICON;
                                else
                                        dvAspect = DVASPECT_CONTENT;
                                if (dvAspect == lpVP->dvAspect)
                                        dvAspect = (DWORD)-1;
                                else
                                {
                                        lpVP->dvAspect = dvAspect;
                                        bRelativeToOrig = 1;
                                }

                                lpObjInfo->SetViewInfo(lpOP->dwObject, hMetaPict, dvAspect,
                                        nCurrentScale, bRelativeToOrig);
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                SendDlgItemMessage(hDlg, IDC_VP_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0);
                StandardCleanup((PVOID)lpVP, hDlg);
                return TRUE;
        }
        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// LinkPropsDialogProc and helpers

static BOOL IsNullTime(const FILETIME* lpFileTime)
{
    FILETIME fileTimeNull = { 0, 0 };
    return CompareFileTime(&fileTimeNull, lpFileTime) == 0;
}

static BOOL SetDlgItemDate(HWND hDlg, int nID, const FILETIME* lpFileTime)
{
    if (IsNullTime(lpFileTime))
                return FALSE;

        // convert UTC file time to system time
    FILETIME localTime;
    FileTimeToLocalFileTime(lpFileTime, &localTime);
        SYSTEMTIME systemTime;
        FileTimeToSystemTime(&localTime, &systemTime);

        TCHAR szDate[80];
        GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systemTime,
                NULL, szDate, sizeof(szDate) / sizeof(TCHAR));

        SetDlgItemText(hDlg, nID, szDate);
        return TRUE;
}

static BOOL SetDlgItemTime(HWND hDlg, int nID, const FILETIME* lpFileTime)
{
    if (IsNullTime(lpFileTime))
                return FALSE;

        // convert UTC file time to system time
    FILETIME localTime;
    FileTimeToLocalFileTime(lpFileTime, &localTime);
        SYSTEMTIME systemTime;
        FileTimeToSystemTime(&localTime, &systemTime);

        if (systemTime.wHour || systemTime.wMinute || systemTime.wSecond)
        {
                TCHAR szTime[80];
                GetTimeFormat(LOCALE_USER_DEFAULT, 0, &systemTime,
                        NULL, szTime, sizeof(szTime)/sizeof(TCHAR));

                SetDlgItemText(hDlg, nID, szTime);
        }
        return TRUE;
}

BOOL FLinkPropsInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPLINKPROPS lpLP = (LPLINKPROPS)LpvStandardInit(hDlg, sizeof(LINKPROPS), &hFont);

        // LpvStandardInit send a termination to us already.
        if (NULL == lpLP)
                return FALSE;

        LPPROPSHEETPAGE lpPP = (LPPROPSHEETPAGE)lParam;
        LPOLEUILINKPROPS lpOLP = (LPOLEUILINKPROPS)lpPP->lParam;
        lpLP->lpOLP = lpOLP;
        lpLP->nIDD = IDD_LINKPROPS;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                // Do this for as many controls as you need it for.
                SendDlgItemMessage(hDlg, IDC_LP_LINKSOURCE, WM_SETFONT, (WPARAM)hFont, 0);
                SendDlgItemMessage(hDlg, IDC_LP_DATE, WM_SETFONT, (WPARAM)hFont, 0);
                SendDlgItemMessage(hDlg, IDC_LP_TIME, WM_SETFONT, (WPARAM)hFont, 0);
        }

        // general "Unknown" string for unknown items
        TCHAR szUnknown[64];
        LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN, szUnknown, 64);

        // get object information and fill in default fields
        LPOLEUIOBJECTPROPS lpOP = lpOLP->lpOP;
        LPOLEUILINKINFO lpLinkInfo = lpOP->lpLinkInfo;
        FILETIME lastUpdate; memset(&lastUpdate, 0, sizeof(lastUpdate));
        lpLinkInfo->GetLastUpdate(lpOP->dwLink, &lastUpdate);

        // initialize time and date static text
        if (IsNullTime(&lastUpdate))
        {
                // time and date are unknown
                SetDlgItemText(hDlg, IDC_LP_DATE, szUnknown);
                SetDlgItemText(hDlg, IDC_LP_TIME, szUnknown);
        }
        else
        {
                // time and date are known
                SetDlgItemDate(hDlg, IDC_LP_DATE, &lastUpdate);
                SetDlgItemTime(hDlg, IDC_LP_TIME, &lastUpdate);
        }

        // initialize source display name
        LPTSTR lpszDisplayName;
        lpLinkInfo->GetLinkSource(lpOP->dwLink, &lpszDisplayName,
                &lpLP->nFileLength, NULL, NULL, NULL, NULL);
        SetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpszDisplayName);
        OleStdFree(lpszDisplayName);

        // initialize automatic/manual update field
        DWORD dwUpdate;
        lpLinkInfo->GetLinkUpdateOptions(lpOP->dwLink, &dwUpdate);
        CheckRadioButton(hDlg, IDC_LP_AUTOMATIC, IDC_LP_MANUAL,
                dwUpdate == OLEUPDATE_ALWAYS ? IDC_LP_AUTOMATIC : IDC_LP_MANUAL);
        lpLP->dwUpdate = dwUpdate;

        if (!(lpOP->dwFlags & OPF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Call the hook with lCustData in lParam
        UStandardHook((PVOID)lpLP, hDlg, WM_INITDIALOG, wParam, lpOLP->lCustData);
        return TRUE;
}

INT_PTR CALLBACK LinkPropsDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uHook = 0;
        LPLINKPROPS lpLP = (LPLINKPROPS)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

        // If the hook processed the message, we're done.
        if (0 != uHook)
                return (INT_PTR)uHook;

        // Get pointers to important info
        LPOLEUILINKPROPS lpOLP = NULL;
        LPOLEUIOBJECTPROPS lpOP = NULL;
        LPOLEUILINKINFO lpLinkInfo;
        if (lpLP != NULL)
        {
                lpOLP = lpLP->lpOLP;
                if (lpOLP != NULL)
                {
                        lpLinkInfo = lpOLP->lpOP->lpLinkInfo;
                        lpOP = lpOLP->lpOP;
                }
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
                FLinkPropsInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_LP_OPENSOURCE:
                        // force update
                        SendMessage(GetParent(hDlg), PSM_APPLY, 0, 0);

                        // launch the object
                        lpLinkInfo->OpenLinkSource(lpOP->dwLink);

                        // close the dialog
                        SendMessage(GetParent(hDlg), WM_COMMAND, IDOK, 0);
                        break;

                case IDC_LP_UPDATENOW:
                        {
                                // force update
                                SendMessage(GetParent(hDlg), PSM_APPLY, 0, 0);

                                // update the link via container provided callback
                                if (lpLinkInfo->UpdateLink(lpOP->dwLink, TRUE, FALSE) != NOERROR)
                                        break;

                                // since link was updated, update the time/date display
                                SYSTEMTIME systemTime; GetSystemTime(&systemTime);
                                FILETIME localTime; SystemTimeToFileTime(&systemTime, &localTime);
                                FILETIME lastUpdate; LocalFileTimeToFileTime(&localTime, &lastUpdate);
                                lpLinkInfo->GetLastUpdate(lpOP->dwLink, &lastUpdate);

                                SetDlgItemDate(hDlg, IDC_LP_DATE, &lastUpdate);
                                SetDlgItemTime(hDlg, IDC_LP_TIME, &lastUpdate);

                                // modification that cannot be undone
                                SendMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        }
                        break;

                case IDC_LP_BREAKLINK:
                        {
                                UINT uRet = PopupMessage(GetParent(hDlg), IDS_LINKPROPS,
                                        IDS_CONFIRMBREAKLINK, MB_YESNO|MB_ICONQUESTION);
                                if (uRet == IDYES)
                                {
                                        // cancel the link turning it into a picture
                                        lpLinkInfo->CancelLink(lpOP->dwLink);

                                        // allow other pages to refresh
                                        lpOP->dwFlags &= ~OPF_OBJECTISLINK;
                                        SendMessage(GetParent(hDlg), PSM_QUERYSIBLINGS,
                                                OLEUI_QUERY_LINKBROKEN, 0);

                                        // remove the links page (since this is no longer a link)
                                        SendMessage(GetParent(hDlg), PSM_REMOVEPAGE, 2, 0);

                                }
                        }
                        break;

                case IDC_LP_CHANGESOURCE:
                        {
                                // get current source in OLE memory
                                UINT nLen = GetWindowTextLength(GetDlgItem(hDlg, IDC_LP_LINKSOURCE));
                                LPTSTR lpszDisplayName = (LPTSTR)OleStdMalloc((nLen+1) * sizeof(TCHAR));
                                GetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpszDisplayName, nLen+1);
                                if (lpszDisplayName == NULL)
                                        break;

                                // fill in the OLEUICHANGESOURCE struct
                                OLEUICHANGESOURCE cs; memset(&cs, 0, sizeof(cs));
                                cs.cbStruct = sizeof(cs);
                                cs.hWndOwner = GetParent(GetParent(hDlg));
                                cs.dwFlags = CSF_ONLYGETSOURCE;
                                if (lpOP->dwFlags & OPF_SHOWHELP)
                                        cs.dwFlags |= CSF_SHOWHELP;
                                cs.lpOleUILinkContainer = lpLinkInfo;
                                cs.dwLink = lpOP->dwLink;
                                cs.lpszDisplayName = lpszDisplayName;
                                cs.nFileLength = lpLP->nFileLength;

                                // allow the Change Souce dialog to be hooked
                                UINT uRet = UStandardHook(lpLP, hDlg, uMsgChangeSource, 0,
                                        (LPARAM)&cs);
                                if (!uRet)
                                {
                                        uRet = (OLEUI_OK == OleUIChangeSource(&cs));
                                        SetFocus(hDlg);
                                }
                                if (uRet)
                                {
                                        OleStdFree(lpLP->lpszDisplayName);

                                        lpLP->lpszDisplayName = cs.lpszDisplayName;
                                        lpLP->nFileLength = cs.nFileLength;
                                        SetDlgItemText(hDlg, IDC_LP_LINKSOURCE, lpLP->lpszDisplayName);

                                        OleStdFree(cs.lpszTo);
                                        OleStdFree(cs.lpszFrom);

                                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                                }
                        }
                        break;

                case IDC_LP_MANUAL:
                case IDC_LP_AUTOMATIC:
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        break;
                case IDC_OLEUIHELP:
                        PostMessage(GetParent(GetParent(hDlg)),
                                uMsgHelp,
                                (WPARAM)hDlg,
                                MAKELPARAM(IDD_LINKPROPS, 0));
                        return TRUE;

                }
                break;

        case WM_NOTIFY:
                switch (((NMHDR*)lParam)->code)
                {
                case PSN_HELP:
                    PostMessage(GetParent(GetParent(hDlg)), uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_LINKPROPS, 0));
                    break;
                case PSN_APPLY:
                        {
                                // update link update options first
                                DWORD dwUpdate;
                                if (SendDlgItemMessage(hDlg, IDC_LP_AUTOMATIC, BM_GETCHECK, 0, 0))
                                        dwUpdate = OLEUPDATE_ALWAYS;
                                else
                                        dwUpdate = OLEUPDATE_ONCALL;
                                if (dwUpdate != lpLP->dwUpdate)
                                        lpLinkInfo->SetLinkUpdateOptions(lpOP->dwLink, dwUpdate);

                                // set the link source
                                if (lpLP->lpszDisplayName != NULL)
                                {
                                        // try setting with validation first
                                        ULONG chEaten;
                                        if (NOERROR != lpLinkInfo->SetLinkSource(lpOP->dwLink,
                                                lpLP->lpszDisplayName, lpLP->nFileLength, &chEaten,
                                                TRUE))
                                        {
                                                UINT uRet = PopupMessage(GetParent(hDlg), IDS_LINKPROPS,
                                                        IDS_INVALIDSOURCE,  MB_ICONQUESTION|MB_YESNO);
                                                if (uRet == IDYES)
                                                {
                                                        // user wants to correct the link source
                                                        SetWindowLong(hDlg, DWLP_MSGRESULT, 1);
                                                        return TRUE;
                                                }
                                                // user doesn't care if link source is bogus
                                                lpLinkInfo->SetLinkSource(lpOP->dwLink,
                                                        lpLP->lpszDisplayName, lpLP->nFileLength, &chEaten,
                                                        FALSE);
                                        }
                                        OleStdFree(lpLP->lpszDisplayName);
                                        lpLP->lpszDisplayName = NULL;
                                }
                        }
                        SetWindowLong(hDlg, DWLP_MSGRESULT, 0);
                        PostMessage(GetParent(hDlg), PSM_CANCELTOCLOSE, 0, 0);
                        return TRUE;
                }
                break;

        case WM_DESTROY:
                if (lpLP != NULL)
                {
                        OleStdFree(lpLP->lpszDisplayName);
                        lpLP->lpszDisplayName = NULL;
                }
                StandardCleanup((PVOID)lpLP, hDlg);
                return TRUE;

        default:
                if (lpOP != NULL && lpOP->lpPS->hwndParent && iMsg == uMsgBrowseOFN)
                {
                        SendMessage(lpOP->lpPS->hwndParent, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Property Page initialization code

struct PROPPAGEDATA
{
        UINT    nTemplateID;
        UINT    nTemplateID4;
        DLGPROC pfnDlgProc;
        size_t  nPtrOffset;
};

#define PTR_OFFSET(x) offsetof(OLEUIOBJECTPROPS, x)
static PROPPAGEDATA pageData[3] =
{
        { IDD_GNRLPROPS,IDD_GNRLPROPS4, GnrlPropsDialogProc, PTR_OFFSET(lpGP), },
        { IDD_VIEWPROPS,IDD_VIEWPROPS,  ViewPropsDialogProc, PTR_OFFSET(lpVP), },
        { IDD_LINKPROPS,IDD_LINKPROPS4, LinkPropsDialogProc, PTR_OFFSET(lpLP), },
};
#undef PTR_OFFSET

static UINT WINAPI PrepareObjectProperties(LPOLEUIOBJECTPROPS lpOP)
{
        // setup back pointers from page structs to sheet structs
        lpOP->lpGP->lpOP = lpOP;
        lpOP->lpVP->lpOP = lpOP;
        if ((lpOP->dwFlags & OPF_OBJECTISLINK) && lpOP->lpLP != NULL)
                lpOP->lpLP->lpOP = lpOP;

        // pre-init GNRLPROPS struct
        LPOLEUIGNRLPROPS lpGP = lpOP->lpGP;

        // get ready to initialize PROPSHEET structs
        LPPROPSHEETHEADER lpPS = lpOP->lpPS;
        LPPROPSHEETPAGE lpPPs = (LPPROPSHEETPAGE)lpPS->ppsp;
        UINT nMaxPage = (lpOP->dwFlags & OPF_OBJECTISLINK ? 3 : 2);

        // setting OPF_NOFILLDEFAULT allows you to control almost everything
        if (!(lpOP->dwFlags & OPF_NOFILLDEFAULT))
        {
                // get array of 3 PROPSHEETPAGE structs if not provided
                if (lpPS->ppsp == NULL)
                {
                        lpPS->nPages = nMaxPage;
                        lpPPs = (LPPROPSHEETPAGE)
                                OleStdMalloc(nMaxPage * sizeof(PROPSHEETPAGE));
                        if (lpPPs == NULL)
                                return OLEUI_ERR_OLEMEMALLOC;
                        memset(lpPPs, 0, nMaxPage * sizeof(PROPSHEETPAGE));
                        lpPS->ppsp = lpPPs;
                }

                // fill in defaults for lpPS
                lpPS->dwFlags |= PSH_PROPSHEETPAGE;
                if (lpPS->hInstance == NULL)
                        lpPS->hInstance = _g_hOleStdResInst;

                // fill Defaults for Standard Property Pages
                LPPROPSHEETPAGE lpPP = lpPPs;
                for (UINT nPage = 0; nPage < nMaxPage; nPage++)
                {
                        PROPPAGEDATA* pPageData = &pageData[nPage];
                        if (lpPP->dwSize == 0)
                                lpPP->dwSize = sizeof(PROPSHEETPAGE);
                        if (lpPP->hInstance == NULL)
                                lpPP->hInstance = _g_hOleStdResInst;
                        UINT nIDD = bWin4 ?
                                pPageData->nTemplateID4 : pPageData->nTemplateID;
                        if (lpPP->pszTemplate == NULL)
                                lpPP->pszTemplate = MAKEINTRESOURCE(nIDD);
                        lpPP = (LPPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
                }
        }

        // fill Property Page info which cannot be overridden
        LPPROPSHEETPAGE lpPP = lpPPs;
        for (UINT nPage = 0; nPage < nMaxPage; nPage++)
        {
                PROPPAGEDATA* pPageData = &pageData[nPage];
                lpPP->pfnDlgProc = pPageData->pfnDlgProc;
                lpPP->lParam = (LPARAM)
                        *(OLEUIGNRLPROPS**)((LPBYTE)lpOP + pPageData->nPtrOffset);
                lpPP = (LPPROPSHEETPAGE)((LPBYTE)lpPP+lpPP->dwSize);
        }
        return OLEUI_SUCCESS;
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\iconbox.h ===
/*
 * ICONBOX.H
 *
 * Structures and definitions for the IconBox control.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _ICONBOX_H_
#define _ICONBOX_H_

// Function prototypes
BOOL FIconBoxInitialize(HINSTANCE, HINSTANCE);
void IconBoxUninitialize(void);
LRESULT CALLBACK IconBoxWndProc(HWND, UINT, WPARAM, LPARAM);

// Window extra bytes contain the bitmap index we deal with currently.
#define CBICONBOXWNDEXTRA              (sizeof(HGLOBAL)+sizeof(BOOL))
#define IBWW_HIMAGE                    0
#define IBWW_FLABEL                    (sizeof(HGLOBAL))

// Control messages
#define IBXM_IMAGESET                   (WM_USER+0)
#define IBXM_IMAGEGET                   (WM_USER+1)
#define IBXM_IMAGEFREE                  (WM_USER+2)
#define IBXM_LABELENABLE                (WM_USER+3)

#endif //_ICONBOX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\geticon.cpp ===
/*
 *  GETICON.CPP
 *
 *  Functions to create DVASPECT_ICON metafile from filename or classname.
 *
 *  OleMetafilePictFromIconAndLabel
 *
 *    (c) Copyright Microsoft Corp. 1992-1993 All Rights Reserved
 */


/*******
 *
 * ICON (DVASPECT_ICON) METAFILE FORMAT:
 *
 * The metafile generated with OleMetafilePictFromIconAndLabel contains
 * the following records which are used by the functions in DRAWICON.CPP
 * to draw the icon with and without the label and to extract the icon,
 * label, and icon source/index.
 *
 *  SetWindowOrg
 *  SetWindowExt
 *  DrawIcon:
 *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the
 *      AND mask, one for the image bits.
 *  Escape with the comment "IconOnly"
 *      This indicates where to stop record enumeration to draw only
 *      the icon.
 *  SetTextColor
 *  SetTextAlign
 *  SetBkColor
 *  CreateFont
 *  SelectObject on the font.
 *  ExtTextOut
 *      One or more ExtTextOuts occur if the label is wrapped.  The
 *      text in these records is used to extract the label.
 *  SelectObject on the old font.
 *  DeleteObject on the font.
 *  Escape with a comment that contains the path to the icon source.
 *  Escape with a comment that is the ASCII of the icon index.
 *
 *******/

#include "precomp.h"
#include "common.h"
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include "utility.h"

OLEDBGDATA

static const TCHAR szSeparators[] = TEXT(" \t\\/!:");

#define IS_SEPARATOR(c)         ( (c) == ' ' || (c) == '\\' \
                                                                  || (c) == '/' || (c) == '\t' \
                                                                  || (c) == '!' || (c) == ':')
#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' )

#define IS_SPACE(c)                     ( (c) == ' ' || (c) == '\t' || (c) == '\n' )

/*
 * GetAssociatedExecutable
 *
 * Purpose:  Finds the executable associated with the provided extension
 *
 * Parameters:
 *   lpszExtension   LPSTR points to the extension we're trying to find
 *                   an exe for. Does **NO** validation.
 *
 *   lpszExecutable  LPSTR points to where the exe name will be returned.
 *                   No validation here either - pass in 128 char buffer.
 *
 * Return:
 *   BOOL            TRUE if we found an exe, FALSE if we didn't.
 *
 */
BOOL FAR PASCAL GetAssociatedExecutable(LPTSTR lpszExtension, LPTSTR lpszExecutable)
{
        HKEY hKey;
        LRESULT lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);
        if (ERROR_SUCCESS != lRet)
                return FALSE;

        LONG dw = MAX_PATH_SIZE;
        TCHAR szValue[OLEUI_CCHKEYMAX];
        lRet = RegQueryValue(hKey, lpszExtension, szValue, &dw);  //ProgId
        if (ERROR_SUCCESS != lRet)
        {
                RegCloseKey(hKey);
                return FALSE;
        }

        // szValue now has ProgID
        TCHAR szKey[OLEUI_CCHKEYMAX];
        lstrcpy(szKey, szValue);
        lstrcat(szKey, TEXT("\\Shell\\Open\\Command"));

        dw = MAX_PATH_SIZE;
        lRet = RegQueryValue(hKey, szKey, szValue, &dw);
        if (ERROR_SUCCESS != lRet)
        {
                RegCloseKey(hKey);
                return FALSE;
        }

        // szValue now has an executable name in it.  Let's null-terminate
        // at the first post-executable space (so we don't have cmd line
        // args.
        LPTSTR lpszTemp = szValue;
        while ('\0' != *lpszTemp && IS_SPACE(*lpszTemp))
                lpszTemp = CharNext(lpszTemp);      // Strip off leading spaces

        LPTSTR lpszExe = lpszTemp;
        while ('\0' != *lpszTemp && !IS_SPACE(*lpszTemp))
                lpszTemp = CharNext(lpszTemp);     // Step through exe name
        *lpszTemp = '\0';  // null terminate at first space (or at end).

        lstrcpy(lpszExecutable, lpszExe);
        return TRUE;
}


/*
 * PointerToNthField
 *
 * Purpose:
 *  Returns a pointer to the beginning of the nth field.
 *  Assumes null-terminated string.
 *
 * Parameters:
 *  lpszString        string to parse
 *  nField            field to return starting index of.
 *  chDelimiter       char that delimits fields
 *
 * Return Value:
 *  LPSTR             pointer to beginning of nField field.
 *                    NOTE: If the null terminator is found
 *                          Before we find the Nth field, then
 *                          we return a pointer to the null terminator -
 *                          calling app should be sure to check for
 *                          this case.
 *
 */
LPTSTR FAR PASCAL PointerToNthField(LPTSTR lpszString, int nField, TCHAR chDelimiter)
{
        if (1 == nField)
                return lpszString;

        int cFieldFound = 1;
        LPTSTR lpField = lpszString;
        while (*lpField != '\0')
        {
                if (*lpField++ == chDelimiter)
                {
                        cFieldFound++;
                        if (nField == cFieldFound)
                                return lpField;
                }
        }
        return lpField;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\icon.cpp ===
/*
 * ICON.CPP
 *
 * Implements the OleUIChangeIcon function which invokes the complete
 * Change Icon dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "iconbox.h"

OLEDBGDATA

ULONG
MyGetLongPathName(LPCTSTR pcsPath,
                 LPTSTR  pcsLongPath,
                 ULONG   cchLongPath);

#define CXICONPAD       (12)
#define CYICONPAD       (4)

// Internally used structure
typedef struct tagCHANGEICON
{
        LPOLEUICHANGEICON   lpOCI;      //Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD               dwFlags;
        HICON               hCurIcon;
        TCHAR               szLabel[OLEUI_CCHLABELMAX+1];
        TCHAR               szFile[MAX_PATH];
        UINT                iIcon;
        HICON               hDefIcon;
        TCHAR               szDefIconFile[MAX_PATH];
        UINT                iDefIcon;
        UINT                nBrowseHelpID;      // Help ID callback for Browse dlg

} CHANGEICON, *PCHANGEICON, FAR *LPCHANGEICON;

// Internal function prototypes
// ICON.CPP

INT_PTR CALLBACK ChangeIconDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FChangeIconInit(HWND, WPARAM, LPARAM);
UINT UFillIconList(HWND, UINT, LPTSTR, BOOL);
BOOL FDrawListIcon(LPDRAWITEMSTRUCT);
void UpdateResultIcon(LPCHANGEICON, HWND, UINT);

/*
 * OleUIChangeIcon
 *
 * Purpose:
 *  Invokes the standard OLE Change Icon dialog box allowing the user
 *  to select an icon from an icon file, executable, or DLL.
 *
 * Parameters:
 *  lpCI            LPOLEUIChangeIcon pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS or OLEUI_OK if all is well, otherwise
 *                  an error value.
 */
STDAPI_(UINT) OleUIChangeIcon(LPOLEUICHANGEICON lpCI)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpCI, sizeof(OLEUICHANGEICON),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        // Check for a valid hMetaPict.
        if (NULL == lpCI->hMetaPict && NULL == lpCI->szIconExe && CLSID_NULL == lpCI->clsid)
        {
            return(OLEUI_CIERR_MUSTHAVECURRENTMETAFILE);
        }
        if (lpCI->hMetaPict != NULL && !IsValidMetaPict(lpCI->hMetaPict))
        {
            return(OLEUI_CIERR_MUSTHAVECURRENTMETAFILE);
        }

        // Test to be sure that the class ID matches a registered class ID
        // so we can return OLEUI_CIERR_MUSTHAVECLSID if necessary.
        HGLOBAL hTemp = OleGetIconOfClass(lpCI->clsid, NULL, TRUE);
        if (hTemp == NULL)
        {
            return(OLEUI_CIERR_MUSTHAVECLSID);
        }
        OleUIMetafilePictIconFree(hTemp);

        if (lpCI->dwFlags & CIF_USEICONEXE &&
                (lpCI->cchIconExe < 1 || lpCI->cchIconExe > MAX_PATH))
        {
                uRet = OLEUI_CIERR_SZICONEXEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }

        // Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(ChangeIconDialogProc, (LPOLEUISTANDARD)lpCI,
                hMemDlg, MAKEINTRESOURCE(IDD_CHANGEICON));
        return uRet;
}

/*
 * ChangeIconDialogProc
 *
 * Purpose:
 *  Implements the OLE Change Icon dialog as invoked through the
 *  OleUIChangeIcon function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
INT_PTR CALLBACK ChangeIconDialogProc(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{

        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        UINT uRet = 0;
        LPCHANGEICON lpCI = (LPCHANGEICON)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (INT_PTR)uRet;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        TCHAR szTemp[MAX_PATH];
        HICON hIcon;
        HGLOBAL hMetaPict;

        switch (iMsg)
        {
        case WM_DESTROY:
            if (lpCI)
            {
                SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_RESETCONTENT, 0, 0L);
                StandardCleanup(lpCI, hDlg);
            }
            break;
        case WM_INITDIALOG:
                FChangeIconInit(hDlg, wParam, lParam);
                return TRUE;

        case WM_MEASUREITEM:
                {
                        LPMEASUREITEMSTRUCT lpMI = (LPMEASUREITEMSTRUCT)lParam;

                        // All icons are system metric+padding in width and height
                        lpMI->itemWidth = GetSystemMetrics(SM_CXICON)+CXICONPAD;
                        lpMI->itemHeight= GetSystemMetrics(SM_CYICON)+CYICONPAD;
                }
                break;

        case WM_DRAWITEM:
                return FDrawListIcon((LPDRAWITEMSTRUCT)lParam);

        case WM_DELETEITEM:
                DestroyIcon((HICON)(((LPDELETEITEMSTRUCT)lParam)->itemData));
                break;

        case WM_COMMAND:
                switch (wID)
                {
                case IDC_CI_CURRENT:
                case IDC_CI_DEFAULT:
                case IDC_CI_FROMFILE:
                        if (lpCI != NULL)
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                        break;

                case IDC_CI_LABELEDIT:
                        if (lpCI != NULL && EN_KILLFOCUS == wCode)
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                        break;

                case IDC_CI_FROMFILEEDIT:
                        GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));
                        if (lpCI != NULL)
                        {
                                if (wCode == EN_KILLFOCUS)
                                {
                                        if (lstrcmpi(szTemp, lpCI->szFile))
                                        {
                                                lstrcpy(lpCI->szFile, szTemp);
                                                UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE);
                                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                        }
                                }
                                else if (wCode == EN_SETFOCUS)
                                {
                                        UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                }
                        }
                        break;

                case IDC_CI_ICONLIST:
                        switch (wCode)
                        {
                        case LBN_SETFOCUS:
                                // If we got the focus, see about updating.
                                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));

                                // Check if file changed and update the list if so
                                if (lpCI && 0 != lstrcmpi(szTemp, lpCI->szFile))
                                {
                                        lstrcpy(lpCI->szFile, szTemp);
                                        UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE);
                                }
                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                break;

                        case LBN_SELCHANGE:
                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                break;

                        case LBN_DBLCLK:
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                break;
                        }
                        break;

                case IDC_CI_BROWSE:
                        {
                                lstrcpyn(szTemp, lpCI->szFile, sizeof(szTemp)/sizeof(TCHAR));
                                uRet = UStandardHook(lpCI, hDlg, uMsgBrowse, MAX_PATH_SIZE,
                                        (LPARAM)lpCI->szFile);

                                DWORD dwOfnFlags = OFN_FILEMUSTEXIST;
                                if (lpCI->lpOCI->dwFlags & CIF_SHOWHELP)
                                   dwOfnFlags |= OFN_SHOWHELP;

                                if (0 == uRet)
                                {
                                        uRet = (BOOL)Browse(hDlg, lpCI->szFile, NULL, MAX_PATH_SIZE,
                                                IDS_ICONFILTERS, dwOfnFlags, ID_BROWSE_CHANGEICON, NULL);
                                }

                                if (0 != uRet && 0 != lstrcmpi(szTemp, lpCI->szFile))
                                {
                                        SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);
                                        UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, TRUE);
                                        UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                }
                        }
                        break;

                case IDOK:
                        {
                            HWND hwndCtl = GetDlgItem(hDlg, IDOK);
                            if (hwndCtl == GetFocus())
                            {
                                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, szTemp, sizeof(szTemp)/sizeof(TCHAR));

                                // Check if the file name is valid
                                // if SelectFromFile radio button selected
                                if (lpCI->dwFlags & CIF_SELECTFROMFILE)
                                {
                                        // Check if the file changed at all.
                                        if (0 != lstrcmpi(szTemp, lpCI->szFile))
                                        {
                                                lstrcpy(lpCI->szFile, szTemp);
                                                // file changed.  May need to expand the name
                                                // calling DoesFileExist will do the trick
                                                DoesFileExist(lpCI->szFile, MAX_PATH);
                                                UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, TRUE);
                                                SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);
                                                UpdateResultIcon(lpCI, hDlg, IDC_CI_FROMFILE);
                                                return TRUE; // eat this message to prevent focus change.
                                        }
                                        if (!DoesFileExist(lpCI->szFile, MAX_PATH))
                                        {
                                                OpenFileError(hDlg, ERROR_FILE_NOT_FOUND, lpCI->szFile);
                                                HWND hWnd = GetDlgItem(hDlg, IDC_CI_FROMFILEEDIT);
                                                SetFocus(hWnd);
                                                SendMessage(hWnd, EM_SETSEL, 0, -1);
                                                return TRUE;  // eat this message
                                        }
                                }

                                // Get current metafile image
                                UpdateResultIcon(lpCI, hDlg, (UINT)-1);
                                hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY,
                                        IBXM_IMAGEGET, 0, 0);

                                // Clean up the current icon that we extracted.
                                hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                                DestroyIcon(hIcon);

                                // Clean up the default icon
                                DestroyIcon(lpCI->hDefIcon);

                                // Remove the prop set on our parent
                                RemoveProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG);

                                OleUIMetafilePictIconFree(lpCI->lpOCI->hMetaPict);
                                lpCI->lpOCI->hMetaPict = hMetaPict;
                                lpCI->lpOCI->dwFlags = lpCI->dwFlags;
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                            }
                            else
                            {
                                SetFocus(hwndCtl);
                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                            }
                            break;
                        }

                case IDCANCEL:
                        // Free current icon display image
                        SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0);

                        // Clean up the current icon that we extracted.
                        hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                        DestroyIcon(hIcon);

                        // Clean up the default icon
                        DestroyIcon(lpCI->hDefIcon);

                        // Remove the prop set on our parent
                        RemoveProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG);

                        // We leave hMetaPict intact on Cancel; caller's responsibility
                        SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                        break;

                case IDC_OLEUIHELP:
                        PostMessage(lpCI->lpOCI->hWndOwner, uMsgHelp,
                                                (WPARAM)hDlg, MAKELPARAM(IDD_CHANGEICON, 0));
                        break;
                }
                break;

        default:
                if (lpCI && iMsg == lpCI->nBrowseHelpID)
                {
                        PostMessage(lpCI->lpOCI->hWndOwner, uMsgHelp,
                                        (WPARAM)hDlg, MAKELPARAM(IDD_CHANGEICONBROWSE, 0));
                }
                if (iMsg == uMsgBrowseOFN &&
                        lpCI && lpCI->lpOCI && lpCI->lpOCI->hWndOwner)
                {
                        SendMessage(lpCI->lpOCI->hWndOwner, uMsgBrowseOFN, wParam, lParam);
                }
                break;
        }

        return FALSE;
}

/*
 * FChangeIconInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Change Icon dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FChangeIconInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        LPCHANGEICON lpCI = (LPCHANGEICON)LpvStandardInit(hDlg, sizeof(CHANGEICON));

        // LpvStandardInit send a termination to us already.
        if (NULL == lpCI)
                return FALSE;

        // Save the original pointer and copy necessary information.
        LPOLEUICHANGEICON lpOCI = (LPOLEUICHANGEICON)lParam;
        lpCI->lpOCI = lpOCI;
        lpCI->nIDD = IDD_CHANGEICON;
        lpCI->dwFlags = lpOCI->dwFlags;

        // Go extract the icon source from the metafile.
        TCHAR szTemp[MAX_PATH];
	szTemp[0] = 0;
        OleUIMetafilePictExtractIconSource(lpOCI->hMetaPict, szTemp, &lpCI->iIcon);
        MyGetLongPathName(szTemp, lpCI->szFile, MAX_PATH);

        // Go extract the icon and the label from the metafile
        OleUIMetafilePictExtractLabel(lpOCI->hMetaPict, lpCI->szLabel, OLEUI_CCHLABELMAX_SIZE, NULL);
        lpCI->hCurIcon = OleUIMetafilePictExtractIcon(lpOCI->hMetaPict);

        // Show or hide the help button
        if (!(lpCI->dwFlags & CIF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Set text limits and initial control contents
        SendDlgItemMessage(hDlg, IDC_CI_LABELEDIT, EM_LIMITTEXT, OLEUI_CCHLABELMAX, 0L);
        SendDlgItemMessage(hDlg, IDC_CI_FROMFILEEDIT, EM_LIMITTEXT, MAX_PATH,  0L);
        SetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpCI->szFile);

        // Copy the label text into the edit and static controls.
        SetDlgItemText(hDlg, IDC_CI_LABELEDIT,   lpCI->szLabel);

        lpCI->hDefIcon = NULL;
        if (lpCI->dwFlags & CIF_USEICONEXE)
        {
                lpCI->hDefIcon = StandardExtractIcon(_g_hOleStdInst, lpCI->lpOCI->szIconExe, 0);
                if (NULL != lpCI->hDefIcon)
                {
                        lstrcpy(lpCI->szDefIconFile, lpCI->lpOCI->szIconExe);
                        lpCI->iDefIcon = 0;
                }
        }

        if (NULL == lpCI->hDefIcon)
        {
                HGLOBAL hMetaPict;
                hMetaPict = OleGetIconOfClass(lpCI->lpOCI->clsid, NULL, TRUE);
                lpCI->hDefIcon = OleUIMetafilePictExtractIcon(hMetaPict);
                TCHAR szTemp[MAX_PATH];
                OleUIMetafilePictExtractIconSource(hMetaPict,
                        szTemp, &lpCI->iDefIcon);
                MyGetLongPathName(szTemp, lpCI->szDefIconFile, MAX_PATH);
                OleUIMetafilePictIconFree(hMetaPict);
        }

        // Initialize all the icon displays.
        SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_SETICON,
           (WPARAM)lpCI->hCurIcon, 0L);
        SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_SETICON,
           (WPARAM)lpCI->hDefIcon, 0L);

        /*
         *  Since we cannot predict the size of icons on any display,
         *  we have to resize the icon listbox to the size of an icon
         *  (plus padding), a scrollbar, and two borders (top & bottom).
         */
        UINT cyList = GetSystemMetrics(SM_CYICON)+GetSystemMetrics(SM_CYHSCROLL)
                   +GetSystemMetrics(SM_CYBORDER)*2+CYICONPAD;
        HWND hList = GetDlgItem(hDlg, IDC_CI_ICONLIST);
        RECT rc;
        GetClientRect(hList, &rc);
        SetWindowPos(hList, NULL, 0, 0, rc.right, cyList, SWP_NOMOVE | SWP_NOZORDER);

        // Set the columns in this multi-column listbox to hold one icon
        SendMessage(hList, LB_SETCOLUMNWIDTH,
                GetSystemMetrics(SM_CXICON)+CXICONPAD,0L);

        /*
         *  If the listbox expanded below the group box, then size
         *  the groupbox down, move the label static and exit controls
         *  down, and expand the entire dialog appropriately.
         */
        GetWindowRect(hList, &rc);
        RECT rcG;
        GetWindowRect(GetDlgItem(hDlg, IDC_CI_GROUP), &rcG);
        if (rc.bottom > rcG.bottom)
        {
                // Calculate amount to move things down.
                cyList=(rcG.bottom-rcG.top)-(rc.bottom-rc.top-cyList);

                // Expand the group box.
                rcG.right -=rcG.left;
                rcG.bottom-=rcG.top;
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_GROUP), NULL, 0, 0,
                        rcG.right, rcG.bottom+cyList, SWP_NOMOVE | SWP_NOZORDER);

                // Expand the dialog box.
                GetClientRect(hDlg, &rc);
                SetWindowPos(hDlg, NULL, 0, 0, rc.right, rc.bottom+cyList,
                        SWP_NOMOVE | SWP_NOZORDER);

                // Move the label and edit controls down.
                GetClientRect(GetDlgItem(hDlg, IDC_CI_LABEL), &rc);
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_LABEL), NULL, 0, cyList,
                        rc.right, rc.bottom, SWP_NOSIZE | SWP_NOZORDER);

                GetClientRect(GetDlgItem(hDlg, IDC_CI_LABELEDIT), &rc);
                SetWindowPos(GetDlgItem(hDlg, IDC_CI_LABELEDIT), NULL, 0, cyList,
                        rc.right, rc.bottom, SWP_NOSIZE | SWP_NOZORDER);
        }

        /*
         *  Select Current, Default, or From File radiobuttons appropriately.
         *  The CheckRadioButton call sends WM_COMMANDs which handle
         *  other actions.  Note that if we check From File, which
         *  takes an icon from the list, we better fill the list.
         *  This will also fill the list even if default is selected.
         */
        if (0 != UFillIconList(hDlg, IDC_CI_ICONLIST, lpCI->szFile, FALSE))
        {
                // If szFile worked, then select the source icon in the listbox.
                SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_SETCURSEL, lpCI->iIcon, 0L);
        }

        if (lpCI->dwFlags & CIF_SELECTCURRENT)
        {
                CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, IDC_CI_CURRENT);
        }
        else
        {
                UINT uID = (lpCI->dwFlags & CIF_SELECTFROMFILE) ? IDC_CI_FROMFILE : IDC_CI_DEFAULT;
                CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, uID);
        }
        UpdateResultIcon(lpCI, hDlg, (UINT)-1);

        // Change the caption
        if (NULL!=lpOCI->lpszCaption)
                SetWindowText(hDlg, lpOCI->lpszCaption);

        /*  Give our parent window access to our hDlg (via a special SetProp).
         *  The PasteSpecial dialog may need to force our dialog down if the
         *  clipboard contents change underneath it. if so it will send
         *  us a IDCANCEL command.
         */
        SetProp(lpCI->lpOCI->hWndOwner, PROP_HWND_CHGICONDLG, hDlg);
        lpCI->nBrowseHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // Call the hook with lCustData in lParam
        UStandardHook(lpCI, hDlg, WM_INITDIALOG, wParam, lpOCI->lCustData);
        return TRUE;
}

/*
 * UFillIconList
 *
 * Purpose:
 *  Given a listbox and a filename, attempts to open that file and
 *  read all the icons that exist therein, adding them to the listbox
 *  hList as owner-draw items.  If the file does not exist or has no
 *  icons, then you get no icons and an appropriate warning message.
 *
 * Parameters:
 *  hDlg            HWND of the dialog containing the listbox.
 *  idList          UINT identifier of the listbox to fill.
 *  pszFile         LPSTR of the file from which to extract icons.
 *
 * Return Value:
 *  UINT            Number of items added to the listbox.  0 on failure.
 */
UINT UFillIconList(HWND hDlg, UINT idList, LPTSTR pszFile, BOOL bError)
{
        HWND hList = GetDlgItem(hDlg, idList);
        if (NULL == hList)
                return 0;

        // Clean out the listbox.
        SendMessage(hList, LB_RESETCONTENT, 0, 0L);

        // If we have an empty string, just exit leaving the listbox empty as well
        if (0 == lstrlen(pszFile))
                return 0;

        // Turn on the hourglass
        HCURSOR hCur = HourGlassOn();
        UINT nFileError = 0;

        // Check if the file is valid.
        TCHAR szPathName[MAX_PATH];
        LPTSTR lpszFilePart = NULL;
        UINT cIcons = 0;
        if (SearchPath(NULL, pszFile, NULL, MAX_PATH, szPathName, &lpszFilePart) != 0)
        {
                // This hack is still necessary in Win32 because even under
                // Win32s this ExtractIcon bug appears.
           #ifdef EXTRACTICONWORKS
                // Get the icon count for this file.
                cIcons = (UINT)StandardExtractIcon(_g_hOleStdInst, szPathName, (UINT)-1);
           #else
                /*
                 * ExtractIcon in Windows 3.1 with -1 eats a selector, leaving an
                 * extra global memory object around for this applciation.  Since
                 * changing icons may happen very often with all OLE apps in
                 * the system, we have to work around it.  So we'll say we
                 * have lots of icons and just call ExtractIcon until it
                 * fails.  We check if there's any around by trying to get
                 * the first one.
                 */
                cIcons = 0xFFFF;
                HICON hIcon = StandardExtractIcon(_g_hOleStdInst, szPathName, 0);

                // Fake a failure with cIcons=0, or cleanup hIcon from this test.
                if (NULL == hIcon || 1 == HandleToUlong(hIcon))
                        cIcons = 0;
                else
                        DestroyIcon(hIcon);
           #endif

                if (0 != cIcons)
                {
                        SendMessage(hList, WM_SETREDRAW, FALSE, 0L);
                        for (UINT i = 0; i < cIcons; i++)
                        {
                                hIcon=StandardExtractIcon(_g_hOleStdInst, szPathName, i);
                                if (hIcon != NULL)
                                        SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)hIcon);
                                else
                                        break;
                        }

                        //Force complete repaint
                        SendMessage(hList, WM_SETREDRAW, TRUE, 0L);
                        InvalidateRect(hList, NULL, TRUE);

                        //Select an icon
                        SendMessage(hList, LB_SETCURSEL, 0, 0L);
                }
                else
                        nFileError = IDS_CINOICONSINFILE;
        }
        else
                nFileError = ERROR_FILE_NOT_FOUND;

        // show error if necessary and possible
        if (nFileError && bError)
        {
                ErrorWithFile(hDlg, _g_hOleStdResInst, nFileError, szPathName,
                        MB_OK | MB_ICONEXCLAMATION);
        }

        HourGlassOff(hCur);
        return cIcons;
}

/*
 * FDrawListIcon
 *
 * Purpose:
 *  Handles WM_DRAWITEM for the icon listbox.
 *
 * Parameters:
 *  lpDI            LPDRAWITEMSTRUCT from WM_DRAWITEM
 *
 * Return Value:
 *  BOOL            TRUE if we did anything, FALSE if there are no items
 *                  in the list.
 */
BOOL FDrawListIcon(LPDRAWITEMSTRUCT lpDI)
{
        /*
         * If there are no items in the list, then itemID is negative according
         * to the Win3.1 SDK.  Unfortunately DRAWITEMSTRUCT has an unsigned int
         * for this field, so we need the typecast to do a signed comparison.
         */
        if ((int)lpDI->itemID < 0)
                return FALSE;

        /*
         * For selection or draw entire case we just draw the entire item all
         * over again.  For focus cases, we only call DrawFocusRect.
         */
        if (lpDI->itemAction & (ODA_SELECT | ODA_DRAWENTIRE))
        {
                COLORREF cr;

                // Clear background and draw the icon.
                if (lpDI->itemState & ODS_SELECTED)
                        cr = SetBkColor(lpDI->hDC, GetSysColor(COLOR_HIGHLIGHT));
                else
                        cr = SetBkColor(lpDI->hDC, GetSysColor(COLOR_WINDOW));

                // Draw a cheap rectangle.
                ExtTextOut(lpDI->hDC, 0, 0, ETO_OPAQUE, &lpDI->rcItem, NULL, 0, NULL);
                DrawIcon(lpDI->hDC, lpDI->rcItem.left+(CXICONPAD/2),
                        lpDI->rcItem.top+(CYICONPAD/2), (HICON)(lpDI->itemData));

                // Restore original background for DrawFocusRect
                SetBkColor(lpDI->hDC, cr);
        }

        // Always change focus on the focus action.
        if (lpDI->itemAction & ODA_FOCUS || lpDI->itemState & ODS_FOCUS)
                DrawFocusRect(lpDI->hDC, &lpDI->rcItem);

        return TRUE;
}

/*
 * UpdateResultIcon
 *
 * Purpose:
 *  Updates the result icon using the current icon in the default display
 *  or the icon listbox depending on fFromDefault.
 *
 * Parameters:
 *  lpCI            LPCHANGEICON containing dialog flags.
 *  hDlg            HWND of the dialog
 *  uID             UINT identifying the radiobutton selected.
 *
 * Return Value:
 *  None
 */
void UpdateResultIcon(LPCHANGEICON lpCI, HWND hDlg, UINT uID)
{
        if (uID == -1)
        {
                if (SendDlgItemMessage(hDlg, IDC_CI_CURRENT, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_CURRENT;
                else if (SendDlgItemMessage(hDlg, IDC_CI_DEFAULT, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_DEFAULT;
                else if (SendDlgItemMessage(hDlg, IDC_CI_FROMFILE, BM_GETCHECK, 0, 0))
                        uID = IDC_CI_FROMFILE;
        }

        lpCI->dwFlags &= ~(CIF_SELECTCURRENT | CIF_SELECTDEFAULT | CIF_SELECTFROMFILE);
        LRESULT lTemp = -1;

        switch (uID)
        {
        case IDC_CI_CURRENT:
                lTemp = SendDlgItemMessage(hDlg, IDC_CI_CURRENTICON, STM_GETICON, 0, 0L);
                lpCI->dwFlags |= CIF_SELECTCURRENT;
                break;

        case IDC_CI_DEFAULT:
                lTemp = SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_GETICON, 0, 0L);
                lpCI->dwFlags |= CIF_SELECTDEFAULT;
                break;

        case IDC_CI_FROMFILE:
                {
                        // Get the selected icon from the list and place it in the result
                        lpCI->dwFlags |= CIF_SELECTFROMFILE;
                        UINT iSel = (UINT)SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_GETCURSEL, 0, 0L);
                        if (LB_ERR == (int)iSel)
                                lTemp = SendDlgItemMessage(hDlg, IDC_CI_DEFAULTICON, STM_GETICON, 0, 0L);
                        else
                                lTemp = SendDlgItemMessage(hDlg, IDC_CI_ICONLIST, LB_GETITEMDATA, iSel, 0);
                        break;
                }

        default:
                OleDbgAssert(FALSE);
                break;
        }
        CheckRadioButton(hDlg, IDC_CI_CURRENT, IDC_CI_FROMFILE, uID);

        // set current icon display as a result of the controls
        LPTSTR lpszSourceFile = lpCI->szFile;
        if (lpCI->dwFlags & CIF_SELECTDEFAULT)
        {
                // use defaults
                lpszSourceFile = lpCI->szDefIconFile;
                lpCI->iIcon = lpCI->iDefIcon;
        }
        else if (lpCI->dwFlags & CIF_SELECTCURRENT)
        {
                TCHAR szTemp[MAX_PATH];
                OleUIMetafilePictExtractIconSource(lpCI->lpOCI->hMetaPict,
                        szTemp, &lpCI->iIcon);
                MyGetLongPathName(szTemp, lpszSourceFile, MAX_PATH);
        }
        else if (lpCI->dwFlags & CIF_SELECTFROMFILE)
        {
                // get from file and index
                GetDlgItemText(hDlg, IDC_CI_FROMFILEEDIT, lpszSourceFile, MAX_PATH);
                lpCI->iIcon = (UINT)SendDlgItemMessage(hDlg,
                        IDC_CI_ICONLIST, LB_GETCURSEL, 0, 0L);
        }

        // Get new hMetaPict and set result text
        TCHAR szTemp[MAX_PATH];
        GetDlgItemText(hDlg, IDC_CI_LABELEDIT, szTemp, MAX_PATH);
        TCHAR szShortFile[MAX_PATH];
        GetShortPathName(lpszSourceFile, szShortFile, MAX_PATH);
#if defined(WIN32) && !defined(UNICODE)
        OLECHAR wszTemp[MAX_PATH];
        OLECHAR wszSourceFile[MAX_PATH];
        ATOW(wszTemp, szTemp, MAX_PATH);
        ATOW(wszSourceFile, szShortFile, MAX_PATH);
        HGLOBAL hMetaPict = OleMetafilePictFromIconAndLabel(
                (HICON)lTemp, wszTemp, wszSourceFile, lpCI->iIcon);
#else
        HGLOBAL hMetaPict = OleMetafilePictFromIconAndLabel(
                (HICON)lTemp, szTemp, szShortFile, lpCI->iIcon);
#endif
        SendDlgItemMessage(hDlg, IDC_CI_ICONDISPLAY, IBXM_IMAGESET, 1,
                (LPARAM)hMetaPict);
}

//+---------------------------------------------------------------------------
//
//  Function:   IsLongComponent, public
//
//  Synopsis:   Determines whether the current path component is a legal
//              8.3 name or not.  If not, it is considered to be a long
//              component.
//
//  Arguments:  [pwcsPath] - Path to check
//              [ppwcsEnd] - Return for end of component pointer
//
//  Returns:    BOOL
//
//  Modifies:   [ppwcsEnd]
//
//  History:    28-Aug-94       DrewB   Created
//              5-04-95         stevebl Modified for use by oledlg
//
//  Notes:      An empty path is considered to be long
//              The following characters are not valid in file name domain:
//              * + , : ; < = > ? [ ] |
//
//----------------------------------------------------------------------------

BOOL IsLongComponent(LPCTSTR pwcsPath,
                     PTSTR *ppwcsEnd)
{
    LPTSTR pwcEnd, pwcDot;
    BOOL fLongNameFound;
    TCHAR wc;

    pwcEnd = (LPTSTR)pwcsPath;
    fLongNameFound = FALSE;
    pwcDot = NULL;

    while (TRUE)
    {
        wc = *pwcEnd;

        if (wc == '\\' || wc == 0)
        {
            *ppwcsEnd = pwcEnd;

            // We're at a component terminator, so make the
            // determination of whether what we've seen is a long
            // name or short one

            // If we've aready seen illegal characters or invalid
            // structure for a short name, don't bother to check lengths
            if (pwcEnd-pwcsPath > 0 && !fLongNameFound)
            {
                // If this component fits in 8.3 then it is a short name
                if ((!pwcDot && (ULONG)(pwcEnd - pwcsPath) <= 8) ||
                    (pwcDot && ((ULONG)(pwcEnd - pwcDot) <= 3 + 1 &&
                                (ULONG)(pwcEnd - pwcsPath) <= 8 + 3 + 1)))
                {
                    return FALSE;
                }
            }

            return TRUE;
        }

        // Handle dots
        if (wc == '.')
        {
            // If two or more '.' or the base name is longer than
            // 8 characters or no base name at all, it is an illegal dos
            // file name
            if (pwcDot != NULL ||
                ((ULONG)(pwcEnd - pwcsPath)) > 8 ||
                (pwcEnd == pwcsPath && *(pwcEnd + 1) != '\\'))
            {
                fLongNameFound = TRUE;
            }

            pwcDot = pwcEnd;
        }

        // Check for characters which aren't valid in short names
        else if (wc <= ' ' ||
                 wc == '*' ||
                 wc == '+' ||
                 wc == ',' ||
                 wc == ':' ||
                 wc == ';' ||
                 wc == '<' ||
                 wc == '=' ||
                 wc == '>' ||
                 wc == '?' ||
                 wc == '[' ||
                 wc == ']' ||
                 wc == '|')
        {
            fLongNameFound = TRUE;
        }

        pwcEnd++;
    }
}

//
// The following code was stolen from NT's RTL in curdir.c
//

#define IS_PATH_SEPARATOR(wch) \
    ((wch) == '\\' || (wch) == '/')

typedef enum
{
    PATH_TYPE_UNKNOWN,
    PATH_TYPE_UNC_ABSOLUTE,
    PATH_TYPE_LOCAL_DEVICE,
    PATH_TYPE_ROOT_LOCAL_DEVICE,
    PATH_TYPE_DRIVE_ABSOLUTE,
    PATH_TYPE_DRIVE_RELATIVE,
    PATH_TYPE_ROOTED,
    PATH_TYPE_RELATIVE
} PATH_TYPE;

PATH_TYPE
DetermineDosPathNameType(
    IN LPCTSTR DosFileName
    )

/*++

Routine Description:

    This function examines the Dos format file name and determines the
    type of file name (i.e.  UNC, DriveAbsolute, Current Directory
    rooted, or Relative.

Arguments:

    DosFileName - Supplies the Dos format file name whose type is to be
        determined.

Return Value:

    PATH_TYPE_UNKNOWN - The path type can not be determined

    PATH_TYPE_UNC_ABSOLUTE - The path specifies a Unc absolute path
        in the format \\server-name\sharename\rest-of-path

    PATH_TYPE_LOCAL_DEVICE - The path specifies a local device in the format
        \\.\rest-of-path this can be used for any device where the nt and
        Win32 names are the same. For example mailslots.

    PATH_TYPE_ROOT_LOCAL_DEVICE - The path specifies the root of the local
        devices in the format \\.

    PATH_TYPE_DRIVE_ABSOLUTE - The path specifies a drive letter absolute
        path in the form drive:\rest-of-path

    PATH_TYPE_DRIVE_RELATIVE - The path specifies a drive letter relative
        path in the form drive:rest-of-path

    PATH_TYPE_ROOTED - The path is rooted relative to the current disk
        designator (either Unc disk, or drive). The form is \rest-of-path.

    PATH_TYPE_RELATIVE - The path is relative (i.e. not absolute or rooted).

--*/

{
    PATH_TYPE ReturnValue;

    if ( IS_PATH_SEPARATOR(*DosFileName) )
    {
        if ( IS_PATH_SEPARATOR(*(DosFileName+1)) )
        {
            if ( DosFileName[2] == '.' )
            {
                if ( IS_PATH_SEPARATOR(*(DosFileName+3)) )
                {
                    ReturnValue = PATH_TYPE_LOCAL_DEVICE;
                }
                else if ( (*(DosFileName+3)) == 0 )
                {
                    ReturnValue = PATH_TYPE_ROOT_LOCAL_DEVICE;
                }
                else
                {
                    ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
                }
            }
            else
            {
                ReturnValue = PATH_TYPE_UNC_ABSOLUTE;
            }
        }
        else
        {
            ReturnValue = PATH_TYPE_ROOTED;
        }
    }
    else if (*(DosFileName+1) == ':')
    {
        if (IS_PATH_SEPARATOR(*(DosFileName+2)))
        {
            ReturnValue = PATH_TYPE_DRIVE_ABSOLUTE;
        }
        else
        {
            ReturnValue = PATH_TYPE_DRIVE_RELATIVE;
        }
    }
    else
    {
        ReturnValue = PATH_TYPE_RELATIVE;
    }

    return ReturnValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   MyGetLongPathName, public
//
//  Synopsis:   Expand each component of the given path into its
//              long form
//
//  Arguments:  [pwcsPath] - Path
//              [pwcsLongPath] - Long path return buffer
//              [cchLongPath] - Size of return buffer in characters
//
//  Returns:    0 for errors
//              Number of characters needed for buffer if buffer is too small
//                includes NULL terminator
//              Length of long path, doesn't include NULL terminator
//
//  Modifies:   [pwcsLongPath]
//
//  History:    28-Aug-94       DrewB   Created
//              11-Nov-94       BruceMa Modifed to use for Chicago at
//                                      FindFirstFile
//              5-04-95         stevebl Modified for use by OLEDLG
//
//  Notes:      The source and destination buffers can be the same memory
//              Doesn't handle paths with internal . and .., although
//              they are handled at the beginning
//
//----------------------------------------------------------------------------

ULONG
MyGetLongPathName(LPCTSTR pcsPath,
                 LPTSTR  pwcsLongPath,
                 ULONG   cchLongPath)
{
    PATH_TYPE pt;
    HANDLE h;
    LPTSTR pwcsLocalLongPath;
    ULONG cchReturn, cb, cch, cchOutput;
    LPTSTR pwcStart = NULL;
    LPTSTR pwcEnd;
    LPTSTR pwcLong;
    TCHAR wcSave;
    BOOL fLong;
    WIN32_FIND_DATA wfd;
    cchReturn = 0;
    pwcsLocalLongPath = NULL;

    __try
    {
        //
        // First, run down the string checking for tilde's. Any path
        // that has a short name section to it will have a tilde. If
        // there are no tilde's, then we already have the long path,
        // so we can return the string.
        //
        fLong = TRUE;
        for (pwcLong = (LPTSTR)pcsPath; *pwcLong != 0; pwcLong++)
        {
            if (*pwcLong == L'~')
            {
                fLong = FALSE;
            }
        }
        //
        // This derives the number of characters, including the NULL
        //
        cch = ((ULONG)(pwcLong - pcsPath)) + 1;

        //
        // If it isn't a long path already, then we are going to have
        // to parse it.
        //
        if (!fLong)
        {
            // Decide the path type, we want find out the position of
            // the first character of the first name
            pt = DetermineDosPathNameType(pcsPath);
            switch(pt)
            {
                // Form: "\\server_name\share_name\rest_of_the_path"
            case PATH_TYPE_UNC_ABSOLUTE:
#if defined(UNICODE)
                if ((pwcStart = wcschr(pcsPath + 2, L'\\')) != NULL &&
                    (pwcStart = wcschr(pwcStart + 1, L'\\')) != NULL)
#else
                if ((pwcStart = strchr(pcsPath + 2, '\\')) != NULL &&
                    (pwcStart = strchr(pwcStart + 1, '\\')) != NULL)
#endif
                {
                    pwcStart++;
                }
                else
                {
                    pwcStart = NULL;
                }
                break;

                // Form: "\\.\rest_of_the_path"
            case PATH_TYPE_LOCAL_DEVICE:
                pwcStart = (LPTSTR)pcsPath + 4;
                break;

                // Form: "\\."
            case PATH_TYPE_ROOT_LOCAL_DEVICE:
                pwcStart = NULL;
                break;

                // Form: "D:\rest_of_the_path"
            case PATH_TYPE_DRIVE_ABSOLUTE:
                pwcStart = (LPTSTR)pcsPath + 3;
                break;

                // Form: "rest_of_the_path"
            case PATH_TYPE_RELATIVE:
                pwcStart = (LPTSTR) pcsPath;
                goto EatDots;

                // Form: "D:rest_of_the_path"
            case PATH_TYPE_DRIVE_RELATIVE:
                pwcStart = (LPTSTR)pcsPath+2;

            EatDots:
                // Handle .\ and ..\ cases
                while (*pwcStart != 0 && *pwcStart == L'.')
                {
                    if (pwcStart[1] == L'\\')
                    {
                        pwcStart += 2;
                    }
                    else if (pwcStart[1] == L'.' && pwcStart[2] == L'\\')
                    {
                        pwcStart += 3;
                    }
                    else
                    {
                        break;
                    }
                }
                break;

                // Form: "\rest_of_the_path"
            case PATH_TYPE_ROOTED:
                pwcStart = (LPTSTR)pcsPath + 1;
                break;

            default:
                pwcStart = NULL;
                break;
            }
        }

        // In the special case where we have no work to do, exit quickly
        // This saves a lot of instructions for trivial cases
        // In one case the path as given requires no processing
        // The middle case, we determine there were no tilde's in the path
        // In the other, the path only has one component and it is already
        // long
        ///
        if (pwcStart == NULL ||
            (fLong == TRUE) ||
            ((fLong = IsLongComponent(pwcStart, &pwcEnd)) &&
             *pwcEnd == 0))
        {
            // Nothing to convert, copy down the source string
            // to the buffer if necessary

            if (pwcStart != NULL)
            {
                cch = (ULONG)(pwcEnd - pcsPath + 1);
            }

            if (cchLongPath >= cch)
            {
                memcpy(pwcsLongPath, pcsPath, cch * sizeof(TCHAR));

                cchReturn = cch - 1;
                goto gsnTryExit;
            }
            else
            {
                cchReturn = cch;
                goto gsnTryExit;
            }
        }

        // Make a local buffer so that we won't overlap the
        // source pathname in case the long name is longer than the
        // source name.
        if (cchLongPath > 0)
        {
            pwcsLocalLongPath = (PTCHAR)malloc(cchLongPath * sizeof(TCHAR));
            if (pwcsLocalLongPath == NULL)
            {
                goto gsnTryExit;
            }
        }

        // Set up pointer to copy output to
        pwcLong = pwcsLocalLongPath;
        cchOutput = 0;

        // Copy the portions of the path that we skipped initially
        cch = (ULONG)(pwcStart-pcsPath);
        cchOutput += cch;
        if (cchOutput <= cchLongPath)
        {
            memcpy(pwcLong, pcsPath, cch*sizeof(TCHAR));
            pwcLong += cch;
        }

        for (;;)
        {
            // Determine whether the current component is long or short
            cch = ((ULONG)(pwcEnd-pwcStart))+1;
            cb = cch*sizeof(TCHAR);

            if (fLong)
            {
                // If the component is already long, just copy it into
                // the output.  Copy the terminating character along with it
                // so the output remains properly punctuated

                cchOutput += cch;
                if (cchOutput <= cchLongPath)
                {
                    memcpy(pwcLong, pwcStart, cb);
                    pwcLong += cch;
                }
            }
            else
            {
                TCHAR wcsTmp[MAX_PATH];

                // For a short component we need to determine the
                // long name, if there is one.  The only way to
                // do this reliably is to enumerate for the child

                wcSave = *pwcEnd;
                *pwcEnd = 0;

                h = FindFirstFile(pcsPath, &wfd);
                *pwcEnd = wcSave;

                if (h == INVALID_HANDLE_VALUE)
                {
                    goto gsnTryExit;
                }

                FindClose(h);

                lstrcpy(wcsTmp, wfd.cFileName);

                // Copy the filename returned by the query into the output
                // Copy the terminator from the original component into
                // the output to maintain punctuation
                cch = lstrlen(wcsTmp)+1;
                cchOutput += cch;
                if (cchOutput <= cchLongPath)
                {
                    memcpy(pwcLong, wcsTmp, (cch-1)*sizeof(TCHAR));
                    pwcLong += cch;
                    *(pwcLong-1) = *pwcEnd;
                }
            }

            if (*pwcEnd == 0)
            {
                break;
            }

            // Update start pointer to next component
            pwcStart = pwcEnd+1;
            fLong = IsLongComponent(pwcStart, &pwcEnd);
        }

        // Copy local output buffer to given output buffer if necessary
        if (cchLongPath >= cchOutput)
        {
            memcpy(pwcsLongPath, pwcsLocalLongPath, cchOutput * sizeof(TCHAR));
            cchReturn = cchOutput-1;
        }
        else
        {
            cchReturn = cchOutput;
        }

gsnTryExit:;
    }
    __finally
    {
        if (pwcsLocalLongPath != NULL)
        {
            free(pwcsLocalLongPath);
            pwcsLocalLongPath = NULL;
        }
    }

    return cchReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\ole2ui.cpp ===
/*
 * OLE2UI.CPP
 *
 * Contains initialization routines and miscellaneous API implementations for
 * the OLE 2.0 User Interface Support Library.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"
#include <commdlg.h>
#include <stdarg.h>
#include "strcache.h"

OLEDBGDATA

// Registered messages for use with all the dialogs, registered in LibMain
UINT uMsgHelp;
UINT uMsgEndDialog;
UINT uMsgBrowse;
UINT uMsgChangeIcon;
UINT uMsgFileOKString;
UINT uMsgCloseBusyDlg;
UINT uMsgConvert;
UINT uMsgChangeSource;
UINT uMsgAddControl;
UINT uMsgBrowseOFN;

// local function prototypes
INT_PTR CALLBACK PromptUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK UpdateLinksDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam);

// local definition
#define WM_U_UPDATELINK (WM_USER+0x2000)
#define WM_U_SHOWWINDOW (WM_USER+0x2001)

// local structure definition
typedef struct tagUPDATELINKS
{
        LPOLEUILINKCONTAINER    lpOleUILinkCntr;    // pointer to Link Container
        UINT                    cLinks;             // total number of links
        UINT                    cUpdated;           // number of links updated
        DWORD                   dwLink;             // pointer to link
        BOOL                    fError;             // error flag
        LPTSTR                  lpszTitle;          // caption for dialog box
} UPDATELINKS, *PUPDATELINKS, FAR *LPUPDATELINKS;


/*
 * OleUIInitialize
 *
 * NOTE: This function should only be called by your application IF it is
 * using the static-link version of this library.  If the DLL version is
 * being used, this function is automatically called from the OLEDLG DLL's
 * LibMain.
 *
 * Purpose:
 *   Initializes the OLE UI Library.  Registers the OLE clipboard formats
 *   used in the Paste Special dialog, registers private custom window
 *   messages, and registers window classes of the "Result Image"
 *   and "Icon Box" custom controls used in the UI dialogs.
 *
 * Parameters:
 *
 *  hInstance       HINSTANCE of the module where the UI library resources
 *                  and Dialog Procedures are contained.  If you are calling
 *                  this function yourself, this should be the instance handle
 *                  of your application.
 *
 *  hPrevInst       HINSTANCE of the previous application instance.
 *                  This is the parameter passed in to your WinMain.  For
 *                  the DLL version, this should always be set to zero (for
 *                  WIN16 DLLs).
 *
 * Return Value:
 *  BOOL            TRUE if initialization was successful.
 *                  FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL bWin4;                             // TRUE if running Windows4 or greater
BOOL bSharedData;               // TRUE if running Win32s (it has shared data)

static DWORD tlsIndex= (DWORD)-1;
static TASKDATA taskData;

STDAPI_(TASKDATA*) GetTaskData()
{
        TASKDATA* pData;
        if (tlsIndex == (DWORD)-1)
                pData = &taskData;
        else
                pData = (TASKDATA*)TlsGetValue(tlsIndex);
        return pData;
}

DWORD WINAPI _AfxTlsAlloc()
{
        DWORD dwResult = TlsAlloc();
        DWORD dwVersion = GetVersion();
        if ((dwVersion & 0x80000000) && (BYTE)dwVersion <= 3)
        {
                while (dwResult <= 2)
                        dwResult = TlsAlloc();
        }
        return dwResult;
}

static int nInitCount;

STDAPI_(BOOL) OleUIUnInitialize();

STDAPI_(BOOL) OleUIInitialize(HINSTANCE hInstance,
        HINSTANCE hPrevInst)
{
        OleDbgOut1(TEXT("OleUIInitialize called.\r\n"));

        // Cache information about the windows version we are running
        DWORD dwVersion = GetVersion();
        bWin4 = LOBYTE(dwVersion) >= 4;
        bSharedData = !bWin4 && (dwVersion & 0x80000000);

        if (nInitCount == 0)
        {
                if (bSharedData)
                {
                        // allocate thread local storage on Win32s
                        tlsIndex = _AfxTlsAlloc();
                        if (tlsIndex == (DWORD)-1)
                                return FALSE;
                }
        }
        ++nInitCount;

        // Setup process local storage if necessary
        if (tlsIndex != (DWORD)-1)
        {
                void* pData = LocalAlloc(LPTR, sizeof(TASKDATA));
                if (pData == NULL)
                {
                        if (nInitCount == 0)
                        {
                                OleUIUnInitialize();
                                return FALSE;
                        }
                }
                TlsSetValue(tlsIndex, pData);
        }

        // Initialize OleStd functions
        OleStdInitialize(hInstance, hInstance);

        // Register messages we need for the dialogs.
        uMsgHelp = RegisterWindowMessage(SZOLEUI_MSG_HELP);
        uMsgEndDialog = RegisterWindowMessage(SZOLEUI_MSG_ENDDIALOG);
        uMsgBrowse = RegisterWindowMessage(SZOLEUI_MSG_BROWSE);
        uMsgChangeIcon = RegisterWindowMessage(SZOLEUI_MSG_CHANGEICON);
        uMsgFileOKString = RegisterWindowMessage(FILEOKSTRING);
        uMsgCloseBusyDlg = RegisterWindowMessage(SZOLEUI_MSG_CLOSEBUSYDIALOG);
        uMsgConvert = RegisterWindowMessage(SZOLEUI_MSG_CONVERT);
        uMsgChangeSource = RegisterWindowMessage(SZOLEUI_MSG_CHANGESOURCE);
        uMsgAddControl = RegisterWindowMessage(SZOLEUI_MSG_ADDCONTROL);
        uMsgBrowseOFN = RegisterWindowMessage(SZOLEUI_MSG_BROWSE_OFN);

        if (!FResultImageInitialize(hInstance, hPrevInst))
        {
                OleDbgOut1(TEXT("OleUIInitialize: FResultImageInitialize failed. Terminating.\r\n"));
                return 0;
        }
        if (!FIconBoxInitialize(hInstance, hPrevInst))
        {
                OleDbgOut1(TEXT("OleUIInitialize: FIconBoxInitialize failed. Terminating.\r\n"));
                return 0;
        }

#if USE_STRING_CACHE==1
        // It is ok if this fails. InsertObject dialog can do without the cache 
        // support. InsertObjCacheUninit will cleanup as appropriate.
        if (!InsertObjCacheInitialize())
        {
            OleDbgOut1(TEXT("OleUIInitiallize: InsertObjCacheInit failed."));
        }
#endif
        return TRUE;
}

#pragma code_seg()


/*
 * OleUIUnInitialize
 *
 * NOTE: This function should only be called by your application IF it is using
 * the static-link version of this library.  If the DLL version is being used,
 * this function is automatically called from the DLL's LibMain.
 *
 * Purpose:
 *   Uninitializes OLE UI libraries.  Deletes any resources allocated by the
 *   library.
 *
 * Return Value:
 *   BOOL       TRUE if successful, FALSE if not.  Current implementation always
 *              returns TRUE.
 */
STDAPI_(BOOL) OleUIUnInitialize()
{
#if USE_STRING_CACHE==1
        InsertObjCacheUninitialize();
#endif
        IconBoxUninitialize();
        ResultImageUninitialize();

        // Cleanup thread local storage
        if (tlsIndex != (DWORD)-1)
        {
                TASKDATA* pData = (TASKDATA*)TlsGetValue(tlsIndex);
                TlsSetValue(tlsIndex, NULL);
                if (pData != NULL)
                {
                        if (pData->hInstCommCtrl != NULL)
                                FreeLibrary(pData->hInstCommCtrl);
                        if (pData->hInstShell != NULL)
                                FreeLibrary(pData->hInstShell);
                        if (pData->hInstComDlg != NULL)
                                FreeLibrary(pData->hInstComDlg);
                        LocalFree(pData);
                }
        }

        // Last chance cleanup
        if (nInitCount == 1)
        {
                // cleanup thread local storage
                if (tlsIndex != (DWORD)-1)
                {
                        TlsFree(tlsIndex);
                        tlsIndex = (DWORD)-1;
                }
        }
        if (nInitCount != 0)
                --nInitCount;

        return TRUE;
}


/*
 * OleUIAddVerbMenu
 *
 * Purpose:
 *  Add the Verb menu for the specified object to the given menu.  If the
 *  object has one verb, we directly add the verb to the given menu.  If
 *  the object has multiple verbs we create a cascading sub-menu.
 *
 * Parameters:
 *  lpObj           LPOLEOBJECT pointing to the selected object.  If this
 *                  is NULL, then we create a default disabled menu item.
 *
 *  lpszShortType   LPTSTR with short type name (AuxName==2) corresponding
 *                  to the lpOleObj. if the string is NOT known, then NULL
 *                  may be passed. if NULL is passed, then
 *                  IOleObject::GetUserType will be called to retrieve it.
 *                  if the caller has the string handy, then it is faster
 *                  to pass it in.
 *
 *  hMenu           HMENU in which to make modifications.
 *
 *  uPos            Position of the menu item
 *
 *  uIDVerbMin      UINT_PTR ID value at which to start the verbs.
 *                      verb_0 = wIDMVerbMin + verb_0
 *                      verb_1 = wIDMVerbMin + verb_1
 *                      verb_2 = wIDMVerbMin + verb_2
 *                      etc.
 *  uIDVerbMax      UINT_PTR maximum ID value allowed for object verbs.
 *                     if uIDVerbMax==0 then any ID value is allowed
 *
 *  bAddConvert     BOOL specifying whether or not to add a "Convert" item
 *                  to the bottom of the menu (with a separator).
 *
 *  idConvert       UINT ID value to use for the Convert menu item, if
 *                  bAddConvert is TRUE.
 *
 *  lphMenu         HMENU FAR * of the cascading verb menu if it's created.
 *                  If there is only one verb, this will be filled with NULL.
 *
 *
 * Return Value:
 *  BOOL            TRUE if lpObj was valid and we added at least one verb
 *                  to the menu.  FALSE if lpObj was NULL and we created
 *                  a disabled default menu item
 */

STDAPI_(BOOL) OleUIAddVerbMenu(LPOLEOBJECT lpOleObj,
        LPCTSTR lpszShortType,
        HMENU hMenu, UINT uPos,
        UINT uIDVerbMin, UINT uIDVerbMax,
        BOOL bAddConvert, UINT idConvert,
        HMENU FAR *lphMenu)
{
        LPPERSISTSTORAGE    lpPS=NULL;
        LPENUMOLEVERB       lpEnumOleVerb = NULL;
        OLEVERB             oleverb;
        LPCTSTR             lpszShortTypeName = lpszShortType;
        LPTSTR              lpszVerbName = NULL;
        HRESULT             hrErr;
        BOOL                fStatus;
        BOOL                fIsLink = FALSE;
        BOOL                fResult = TRUE;
        BOOL                fAddConvertItem = FALSE;
        int                 cVerbs = 0;
        UINT                uFlags = MF_BYPOSITION;
        static BOOL         fFirstTime = TRUE;
        static TCHAR        szBuffer[OLEUI_OBJECTMENUMAX];
        static TCHAR        szNoObjectCmd[OLEUI_OBJECTMENUMAX];
        static TCHAR        szObjectCmd1Verb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szLinkCmd1Verb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szObjectCmdNVerb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szLinkCmdNVerb[OLEUI_OBJECTMENUMAX];
        static TCHAR        szUnknown[OLEUI_OBJECTMENUMAX];
        static TCHAR        szEdit[OLEUI_OBJECTMENUMAX];
        static TCHAR        szConvert[OLEUI_OBJECTMENUMAX];

        // Set fAddConvertItem flag
        if (bAddConvert & (idConvert != 0))
                fAddConvertItem = TRUE;

        // only need to load the strings the 1st time
        if (fFirstTime)
        {
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITNOOBJCMD,
                                 szNoObjectCmd, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITLINKCMD_1VERB,
                                 szLinkCmd1Verb, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITOBJECTCMD_1VERB,
                                 szObjectCmd1Verb, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITLINKCMD_NVERB,
                                 szLinkCmdNVerb, OLEUI_OBJECTMENUMAX))
                        return FALSE;
                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDITOBJECTCMD_NVERB,
                                 szObjectCmdNVerb, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIUNKNOWN,
                                 szUnknown, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UIEDIT,
                                 szEdit, OLEUI_OBJECTMENUMAX))
                        return FALSE;

                if (0 == LoadString(_g_hOleStdResInst, IDS_OLE2UICONVERT,
                                   szConvert, OLEUI_OBJECTMENUMAX) && fAddConvertItem)
                        return FALSE;

                fFirstTime = FALSE;
        }

        // Delete whatever menu may happen to be here already.
        DeleteMenu(hMenu, uPos, uFlags);

        if (lphMenu == NULL || IsBadWritePtr(lphMenu, sizeof(HMENU)))
        {
            goto AVMError;
        }
        *lphMenu=NULL;

        if ((!lpOleObj) || IsBadReadPtr(lpOleObj, sizeof (IOleObject)))
                goto AVMError;

        if ((!lpszShortTypeName) || IsBadReadPtr(lpszShortTypeName, sizeof(TCHAR)))
        {
                // get the Short form of the user type name for the menu
                OLEDBG_BEGIN2(TEXT("IOleObject::GetUserType called\r\n"))
#if defined(WIN32) && !defined(UNICODE)
                LPOLESTR wszShortTypeName = NULL;
                lpszShortTypeName = NULL;
                hrErr = lpOleObj->GetUserType(
                                USERCLASSTYPE_SHORT,
                                &wszShortTypeName);
                if (NULL != wszShortTypeName)
                {
                    UINT uLen = WTOALEN(wszShortTypeName);
                    lpszShortTypeName = (LPTSTR) OleStdMalloc(uLen);
                    if (NULL != lpszShortTypeName)
                    {
                        WTOA((char *)lpszShortTypeName, wszShortTypeName, uLen);
                    }
                    OleStdFree(wszShortTypeName);
                }
#else
                hrErr = lpOleObj->GetUserType(
                                USERCLASSTYPE_SHORT,
                                (LPTSTR FAR*)&lpszShortTypeName);
#endif
                OLEDBG_END2

                if (NOERROR != hrErr) {
                        OleDbgOutHResult(TEXT("IOleObject::GetUserType returned"), hrErr);
                }
        }

        // check if the object is a link
        fIsLink = OleStdIsOleLink((LPUNKNOWN)lpOleObj);

        // Get the verb enumerator from the OLE object
        OLEDBG_BEGIN2(TEXT("IOleObject::EnumVerbs called\r\n"))
        hrErr = lpOleObj->EnumVerbs(
                        (LPENUMOLEVERB FAR*)&lpEnumOleVerb
        );
        OLEDBG_END2

        if (NOERROR != hrErr) {
                OleDbgOutHResult(TEXT("IOleObject::EnumVerbs returned"), hrErr);
        }

        if (!(*lphMenu = CreatePopupMenu()))
                goto AVMError;

        // loop through all verbs
        while (lpEnumOleVerb != NULL)
        {
                hrErr = lpEnumOleVerb->Next(
                                1,
                                (LPOLEVERB)&oleverb,
                                NULL
                );
                if (NOERROR != hrErr)
                        break;              // DONE! no more verbs

                /* OLE2NOTE: negative verb numbers and verbs that do not
                **    indicate ONCONTAINERMENU should NOT be put on the verb menu
                */
                if (oleverb.lVerb < 0 ||
                                ! (oleverb.grfAttribs & OLEVERBATTRIB_ONCONTAINERMENU))
                {
                        /* OLE2NOTE: we must still free the verb name string */
                        if (oleverb.lpszVerbName)
                                OleStdFree(oleverb.lpszVerbName);
                        continue;
                }

                // we must free the previous verb name string
                if (lpszVerbName)
                        OleStdFree(lpszVerbName);

#if defined(WIN32) && !defined(UNICODE)
                lpszVerbName = NULL;
                if (NULL != oleverb.lpszVerbName)
                {
                    UINT uLen = WTOALEN(oleverb.lpszVerbName);
                    lpszVerbName = (LPTSTR) OleStdMalloc(uLen);
                    if (NULL != lpszVerbName)
                    {
                        WTOA(lpszVerbName, oleverb.lpszVerbName, uLen);
                    }
                    OleStdFree(oleverb.lpszVerbName);
                }
#else
                lpszVerbName = oleverb.lpszVerbName;
#endif
                if ( 0 == uIDVerbMax || 
                        (uIDVerbMax >= uIDVerbMin+(UINT)oleverb.lVerb) )
                {
                        fStatus = InsertMenu(
                                        *lphMenu,
                                        (UINT)-1,
                                        MF_BYPOSITION | (UINT)oleverb.fuFlags,
                                        uIDVerbMin+(UINT)oleverb.lVerb,
                                        lpszVerbName
                        );
                        if (! fStatus)
                                goto AVMError;

                        cVerbs++;
                }
        }

        // Add the separator and "Convert" menu item.
        if (fAddConvertItem)
        {
                if (0 == cVerbs)
                {
                        LPTSTR lpsz;

                        // if object has no verbs, then use "Convert" as the obj's verb
                        lpsz = lpszVerbName = OleStdCopyString(szConvert);
                        uIDVerbMin = (UINT)idConvert;

                        // remove "..." from "Convert..." string; it will be added later
                        if (lpsz)
                        {
                                while(*lpsz && *lpsz != '.')
                                        lpsz = CharNext(lpsz);
                                *lpsz = '\0';
                        }
                }

                if (cVerbs > 0)
                {
                        fStatus = InsertMenu(*lphMenu,
                                                (UINT)-1,
                                                MF_BYPOSITION | MF_SEPARATOR,
                                                (UINT)0,
                                                (LPCTSTR)NULL);
                        if (! fStatus)
                                goto AVMError;
                }

                /* add convert menu */
                fStatus = InsertMenu(*lphMenu,
                                        (UINT)-1,
                                        MF_BYPOSITION,
                                        idConvert,
                                        (LPCTSTR)szConvert);
                if (! fStatus)
                        goto AVMError;

                cVerbs++;
        }


        /*
         * Build the appropriate menu based on the number of verbs found
         *
         */
        if (cVerbs == 0)
        {
                // there are NO verbs (not even Convert...). set the menu to be
                // "<short type> &Object/Link" and gray it out.
                wsprintf(
                        szBuffer,
                        (fIsLink ? szLinkCmdNVerb : szObjectCmdNVerb),
                        (lpszShortTypeName ? lpszShortTypeName : TEXT(""))
                );
                uFlags |= MF_GRAYED;

                fResult = FALSE;
                DestroyMenu(*lphMenu);
                *lphMenu = NULL;

        }
        else if (cVerbs == 1)
        {
                //One verb without Convert, one item.
                LPTSTR       lpsz = (fIsLink ? szLinkCmd1Verb : szObjectCmd1Verb);

                // strip ampersands from lpszVerbName to ensure that
                // the right character is used as the menu key
                LPTSTR pchIn;
                LPTSTR pchOut;
                pchIn = pchOut = lpszVerbName;
                while (*pchIn)
                {
                    while (*pchIn && '&' == *pchIn)
                    {
                        pchIn++;
                    }
                    *pchOut = *pchIn;
                    pchOut++;
                    pchIn++;
                }
                *pchOut = 0;

                FormatString2(szBuffer, lpsz, lpszVerbName, lpszShortTypeName);

                // if only "verb" is "Convert..." then append the ellipses
                if (fAddConvertItem)
                        lstrcat(szBuffer, TEXT("..."));

                DestroyMenu(*lphMenu);
                *lphMenu=NULL;
        }
        else
        {

                //Multiple verbs or one verb with Convert, add the cascading menu
                wsprintf(
                        szBuffer,
                        (fIsLink ? szLinkCmdNVerb: szObjectCmdNVerb),
                        (lpszShortTypeName ? lpszShortTypeName : TEXT(""))
                );
                uFlags |= MF_ENABLED | MF_POPUP;
#ifdef _WIN64
//
// Sundown: Checking with JerrySh for the validity of the HMENU truncation...........
//          If not valid, this'd require modifying the prototype of this function for
//          uIDVerbMin & uIDVerbMax and modifying sdk\inc\oledlg.h exposed interface.
//
                OleDbgAssert( !(((ULONG_PTR)*lphMenu) >> 32) )
#endif // _WIN64
                uIDVerbMin=(UINT)HandleToUlong(*lphMenu);
        }

        if (!InsertMenu(hMenu, uPos, uFlags, uIDVerbMin, szBuffer))
        {
AVMError:
                InsertMenu(hMenu, uPos, MF_GRAYED | uFlags,
                        uIDVerbMin, szNoObjectCmd);
                fResult = FALSE;
        }

	// Redraw the menu bar, if possible
	HWND hWndActive   = GetActiveWindow();
	HMENU hMenuActive = GetMenu(hWndActive);

	if(hMenuActive == hMenu)
	{
		DrawMenuBar(hWndActive);
	}

        if (lpszVerbName)
                OleStdFree(lpszVerbName);
        if (!lpszShortType && lpszShortTypeName)
                OleStdFree((LPVOID)lpszShortTypeName);
        if (lpEnumOleVerb)
                lpEnumOleVerb->Release();
        return fResult;
}

/////////////////////////////////////////////////////////////////////////////
// Support for special error prompts

typedef struct tagPROMPTUSER
{
        va_list argptr;
        UINT    nIDD;           // dialog/help ID
        LPTSTR  szTitle;
} PROMPTUSER, *PPROMPTUSER, FAR* LPPROMPTUSER;

/* PromptUserDlgProc
 * -----------------
 *
 *  Purpose:
 *      Dialog procedure used by OleUIPromptUser(). Returns when a button is
 *      clicked in the dialog box and the button id is return.
 *
 *  Parameters:
 *      hDlg
 *      iMsg
 *      wParam
 *      lParam
 *
 *  Returns:
 *
 */
INT_PTR CALLBACK PromptUserDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        switch (iMsg)
        {
        case WM_INITDIALOG:
                {
                        SendDlgItemMessage(hDlg, IDC_PU_ICON,
                                STM_SETICON, (WPARAM)LoadIcon(NULL, IDI_EXCLAMATION), 0L);

                        LPPROMPTUSER lpPU = (LPPROMPTUSER)lParam;
                        SetProp(hDlg, STRUCTUREPROP, lpPU);
                        SetWindowText(hDlg, lpPU->szTitle);

                        TCHAR szFormat[256];
                        GetDlgItemText(hDlg, IDC_PU_TEXT, szFormat,
                                sizeof(szFormat)/sizeof(TCHAR));
                        TCHAR szBuf[256];
                        wvsprintf(szBuf, szFormat, lpPU->argptr);
                        SetDlgItemText(hDlg, IDC_PU_TEXT, szBuf);
                }
                return TRUE;

        case WM_COMMAND:
                EndDialog(hDlg, wParam);
                return TRUE;

        default:
                return FALSE;
        }
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUIPromptUserInternal
//
//  Synopsis:   internal entry point to start the PromptUser dialog
//              Used to support both ANSI and Unicode entrypoints
//
//  Arguments:  [nTemplate]  - dialog template ID
//              [szTitle]    - the title string
//              [hwndParent] - the dialog's parent window
//              [arglist]    - variable argument list
//
//  History:    12-01-94   stevebl   Created
//
//----------------------------------------------------------------------------

int OleUIPromptUserInternal(int nTemplate, HWND hwndParent, LPTSTR szTitle, va_list arglist)
{
    PROMPTUSER pu;
    pu.szTitle = szTitle;
    pu.argptr = arglist;
    pu.nIDD = nTemplate;
    return ((int)DialogBoxParam(_g_hOleStdResInst, MAKEINTRESOURCE(nTemplate), hwndParent,
                    PromptUserDlgProc, (LPARAM)&pu));
}

/* OleUIPromptUser
 * ---------------
 *
 *  Purpose:
 *      Popup a dialog box with the specified template and returned the
 *      response (button id) from the user.
 *
 *  Parameters:
 *      nTemplate       resource number of the dialog
 *      hwndParent      parent of the dialog box
 *      ...             title of the dialog box followed by argument list
 *                      for the format string in the static control
 *                      (IDC_PU_TEXT) of the dialog box.
 *                      The caller has to make sure that the correct number
 *                      and type of argument are passed in.
 *
 *  Returns:
 *      button id selected by the user (template dependent)
 *
 *  Comments:
 *      the following message dialog boxes are supported:
 *
 *      IDD_LINKSOURCEUNAVAILABLE -- Link source is unavailable
 *          VARARG Parameters:
 *              None.
 *          Used for the following error codes:
 *              OLE_E_CANT_BINDTOSOURCE
 *              STG_E_PATHNOTFOUND
 *              (sc >= MK_E_FIRST) && (sc <= MK_E_LAST) -- any Moniker error
 *              any unknown error if object is a link
 *
 *      IDD_SERVERNOTFOUND -- server registered but NOT found
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of object
 *          Used for the following error codes:
 *              CO_E_APPNOTFOUND
 *              CO_E_APPDIDNTREG
 *              any unknown error if object is an embedded object
 *
 *      IDD_SERVERNOTREG -- server NOT registered
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of object
 *          Used for the following error codes:
 *              REGDB_E_CLASSNOTREG
 *              OLE_E_STATIC -- static object with no server registered
 *
 *      IDD_LINKTYPECHANGED -- class of link source changed since last binding
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of ole link source
 *          Used for the following error codes:
 *              OLE_E_CLASSDIFF
 *
 *      IDD_LINKTYPECHANGED -- class of link source changed since last binding
 *          VARARG Parameters:
 *              LPSTR lpszUserType -- user type name of ole link source
 *          Used for the following error codes:
 *              OLE_E_CLASSDIFF
 *
 *      IDD_OUTOFMEMORY -- out of memory
 *          VARARG Parameters:
 *              None.
 *          Used for the following error codes:
 *              E_OUTOFMEMORY
 *
 */

int FAR CDECL OleUIPromptUser(int nTemplate, HWND hwndParent, ...)
{
        va_list arglist;
        va_start(arglist, hwndParent);
        LPTSTR szTitle = va_arg(arglist, LPTSTR);
        int nRet = OleUIPromptUserInternal(nTemplate, hwndParent, szTitle, arglist);
        va_end(arglist);

        return nRet;
}

/* UpdateLinksDlgProc
 * ------------------
 *
 *  Purpose:
 *      Dialog procedure used by OleUIUpdateLinks(). It will enumerate all
 *      all links in the container and updates all automatic links.
 *      Returns when the Stop Button is clicked in the dialog box or when all
 *      links are updated
 *
 *  Parameters:
 *      hDlg
 *      iMsg
 *      wParam
 *      lParam          pointer to the UPDATELINKS structure
 *
 *  Returns:
 *
 */

#define UPDATELINKS_STARTDELAY  2000    // delay before 1st link updates

INT_PTR CALLBACK UpdateLinksDlgProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        LPUPDATELINKS FAR*      lplpUL = NULL;
        HANDLE                  gh;
        static BOOL             fAbort = FALSE;

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                gh = RemoveProp(hDlg, STRUCTUREPROP);
                if (NULL != gh)
                {
                        GlobalUnlock(gh);
                        GlobalFree(gh);
                }
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
        case WM_INITDIALOG:
        {
                gh = GlobalAlloc(GHND, sizeof(LPUPDATELINKS));
                SetProp(hDlg, STRUCTUREPROP, gh);

                if (NULL == gh)
                {
                        PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC,0L);
                        return FALSE;
                }

                fAbort = FALSE;
                lplpUL = (LPUPDATELINKS FAR*)GlobalLock(gh);

                if (!lplpUL)
                {
                        PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC,0L);
                        return FALSE;
                }

                if (bWin4)
                {
                        if (StandardInitCommonControls() >= 0)
                        {
                                // get rect of the existing "progress" control
                                RECT rect;
                                GetWindowRect(GetDlgItem(hDlg, IDC_UL_METER), &rect);
                                ScreenToClient(hDlg, ((POINT*)&rect)+0);
                                ScreenToClient(hDlg, ((POINT*)&rect)+1);

                                // create progress control in that rect
                                HWND hProgress = CreateWindowEx(
                                        0, PROGRESS_CLASS, NULL, WS_CHILD|WS_VISIBLE,
                                        rect.left, rect.top,
                                        rect.right-rect.left, rect.bottom-rect.top, hDlg,
                                        (HMENU)IDC_UL_PROGRESS, _g_hOleStdInst, NULL);
                                if (hProgress != NULL)
                                {
                                        // initialize the progress control
                                        SendMessage(hProgress, PBM_SETRANGE, 0, MAKELONG(0, 100));

                                        // hide the other "meter" control
                                        StandardShowDlgItem(hDlg, IDC_UL_METER, SW_HIDE);
                                }
                        }
                }

                *lplpUL = (LPUPDATELINKS)lParam;
                if ((*lplpUL)->lpszTitle)
                {
                    SetWindowText(hDlg, (*lplpUL)->lpszTitle);
                }
                SetTimer(hDlg, 1, UPDATELINKS_STARTDELAY, NULL);
                return TRUE;
        }

        case WM_TIMER:
                KillTimer(hDlg, 1);
                gh = GetProp(hDlg, STRUCTUREPROP);

                if (NULL!=gh)
                {
                        // gh was locked previously, lock and unlock to get lplpUL
                        lplpUL = (LPUPDATELINKS*)GlobalLock(gh);
                        GlobalUnlock(gh);
                }
                if (! fAbort && lplpUL)
                        PostMessage(hDlg, WM_U_UPDATELINK, 0, (LPARAM)(*lplpUL));
                else
                        PostMessage(hDlg,uMsgEndDialog,OLEUI_CANCEL,0L);

                return 0;

        case WM_COMMAND:    // Stop button
                fAbort = TRUE;
                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                return TRUE;

        case WM_U_UPDATELINK:
                {
                        HRESULT         hErr;
                        int             nPercent;
                        RECT            rc;
                        TCHAR           szPercent[5];       // 0% to 100%
                        HBRUSH          hbr;
                        HDC             hDC;
                        HWND            hwndMeter;
                        MSG             msg;
                        DWORD           dwUpdateOpt;
                        LPUPDATELINKS   lpUL = (LPUPDATELINKS)lParam;

                        lpUL->dwLink=lpUL->lpOleUILinkCntr->GetNextLink(lpUL->dwLink);

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                if (! IsDialogMessage(hDlg, &msg))
                                {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                }
                        }

                        if (fAbort)
                                return FALSE;

                        if (!lpUL->dwLink)
                        {
                                // all links processed
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                                return TRUE;
                        }

                        hErr = lpUL->lpOleUILinkCntr->GetLinkUpdateOptions(
                                lpUL->dwLink, (LPDWORD)&dwUpdateOpt);

                        if ((hErr == NOERROR) && (dwUpdateOpt == OLEUPDATE_ALWAYS))
                        {
                                hErr = lpUL->lpOleUILinkCntr->UpdateLink(lpUL->dwLink, FALSE, FALSE);
                                lpUL->fError |= (hErr != NOERROR);
                                lpUL->cUpdated++;

                                nPercent = (lpUL->cLinks > 0) ? (lpUL->cUpdated * 100 / lpUL->cLinks) : 100;
                                if (nPercent <= 100)
                                {
                                        // update percentage
                                        wsprintf(szPercent, TEXT("%d%%"), nPercent);
                                        SetDlgItemText(hDlg, IDC_UL_PERCENT, szPercent);

                                        HWND hProgress = GetDlgItem(hDlg, IDC_UL_PROGRESS);
                                        if (hProgress == NULL)
                                        {
                                                // update indicator
                                                hwndMeter = GetDlgItem(hDlg, IDC_UL_METER);
                                                GetClientRect(hwndMeter, (LPRECT)&rc);
                                                InflateRect((LPRECT)&rc, -1, -1);
                                                rc.right = (rc.right - rc.left) * nPercent / 100 + rc.left;
                                                hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
                                                if (hbr)
                                                {
                                                        hDC = GetDC(hwndMeter);
                                                        if (hDC)
                                                        {
                                                                FillRect(hDC, (LPRECT)&rc, hbr);
                                                                ReleaseDC(hwndMeter, hDC);
                                                        }
                                                        DeleteObject(hbr);
                                                }
                                        }
                                        else
                                        {
                                                // update the progress indicator
                                                SendMessage(hProgress, PBM_SETPOS, nPercent, 0);
                                        }
                                }
                        }

                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                if (! IsDialogMessage(hDlg, &msg))
                                {
                                        TranslateMessage(&msg);
                                        DispatchMessage(&msg);
                                }
                        }
                        PostMessage(hDlg, WM_U_UPDATELINK, 0, lParam);
                }
                return TRUE;

        case WM_U_SHOWWINDOW:
                ShowWindow(hDlg, SW_SHOW);
                return TRUE;
        }
        return FALSE;
}


/* OleUIUpdateLinkS
 * ----------------
 *
 *  Purpose:
 *      Update all links in the Link Container and popup a dialog box which
 *      shows the progress of the updating.
 *      The process is stopped when the user press Stop button or when all
 *      links are processed.
 *
 *  Parameters:
 *      lpOleUILinkCntr         pointer to Link Container
 *      hwndParent              parent window of the dialog
 *      lpszTitle               title of the dialog box
 *      cLinks                  total number of links
 *
 *  Returns:
 *      TRUE                    all links updated successfully or user aborted dialog
 *      FALSE                   oherwise
 */
STDAPI_(BOOL) OleUIUpdateLinks(
        LPOLEUILINKCONTAINER lpOleUILinkCntr, HWND hwndParent, LPTSTR lpszTitle, int cLinks)
{
        LPUPDATELINKS lpUL = (LPUPDATELINKS)OleStdMalloc(sizeof(UPDATELINKS));
        if (lpUL == NULL)
            return FALSE;

        BOOL          fError = TRUE;


        // Validate interface.
        if (NULL == lpOleUILinkCntr || IsBadReadPtr(lpOleUILinkCntr, sizeof(IOleUILinkContainer)))
                goto Error;


        // Validate parent-window handle.  NULL is considered valid.
        if (NULL != hwndParent && !IsWindow(hwndParent))
                goto Error;

        // Validate the dialog title.  NULL is considered valid.
        if (NULL != lpszTitle && IsBadReadPtr(lpszTitle, 1))
                goto Error;

        if (cLinks < 0)
                goto Error;

        OleDbgAssert(lpOleUILinkCntr && hwndParent && lpszTitle && (cLinks>0));
        OleDbgAssert(lpUL);

        lpUL->lpOleUILinkCntr = lpOleUILinkCntr;
        lpUL->cLinks           = cLinks;
        lpUL->cUpdated         = 0;
        lpUL->dwLink           = 0;
        lpUL->fError           = FALSE;
        lpUL->lpszTitle    = lpszTitle;

        DialogBoxParam(_g_hOleStdResInst, MAKEINTRESOURCE(IDD_UPDATELINKS),
                        hwndParent, UpdateLinksDlgProc, (LPARAM)lpUL);

        fError = lpUL->fError;
Error:
        OleStdFree((LPVOID)lpUL);

        return !fError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\iconbox.cpp ===
/*
 * ICONBOX.CPP
 *
 * Implemenatation of an IconBox control for OLE 2.0 UI dialogs that we'll
 * use wherever a dialog needs an icon/label display.  Through the control's
 * interface we can change the image or control label visibility.
 *
 * The IconBox discusses images in CF_METAFILEPICT format.  When drawing
 * such a metafile, the entire aspect is centered in the IconBox, so long
 * labels are chopped at either end.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "iconbox.h"
#include "utility.h"
#include "uiclass.h"

OLEDBGDATA

//Flag indicating if we've registered the class
static BOOL fRegistered;


/*
 * FIconBoxInitialize
 *
 * Purpose:
 *  Registers the IconBox control class.
 *
 * Parameters:
 *  hInst           HINSTANCE instance of the DLL.
 *
 *  hPrevInst       HINSTANCE of the previous instance.  Used to
 *                  determine whether to register window classes or not.
 *
 * Return Value:
 *  BOOL            TRUE if all initialization succeeded, FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL FIconBoxInitialize(HINSTANCE hInst, HINSTANCE hPrevInst)
{
        // Only register class if we're the first instance
        if (hPrevInst)
                fRegistered = TRUE;
        else
        {
                // Static flag fRegistered guards against calling this function more
                // than once
                if (!fRegistered)
                {
                        WNDCLASS wc;
                        wc.lpfnWndProc   =IconBoxWndProc;
                        wc.cbClsExtra    =0;
                        wc.cbWndExtra    =CBICONBOXWNDEXTRA;
                        wc.hInstance     =hInst;
                        wc.hIcon         =NULL;
                        wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
                        wc.hbrBackground =(HBRUSH)NULL;
                        wc.lpszMenuName  =NULL;
                        wc.style         =CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

                        wc.lpszClassName = TEXT(SZCLASSICONBOX1);
                        fRegistered = RegisterClass(&wc);

                        wc.lpszClassName = TEXT(SZCLASSICONBOX2);
                        fRegistered = RegisterClass(&wc);

                        wc.lpszClassName = TEXT(SZCLASSICONBOX3);
                        fRegistered = RegisterClass(&wc);
                }
        }
        return fRegistered;
}

#pragma code_seg()


/*
 * IconBoxUninitialize
 *
 * Purpose:
 *  Cleans up anything done in FIconBoxInitialize.  Currently there is
 *  nothing, but we do this for symmetry.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void IconBoxUninitialize(void)
{
        return;
}

/*
 * IconBoxWndProc
 *
 * Purpose:
 *  Window Procedure for the IconBox custom control.  Only handles
 *  WM_CREATE, WM_PAINT, and private messages to manipulate the image.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LRESULT CALLBACK IconBoxWndProc(HWND hWnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        //Handle standard Windows messages.
        switch (iMsg)
        {
        case WM_CREATE:
                SetWindowLongPtr(hWnd, IBWW_HIMAGE, 0);
                SetWindowWord(hWnd, IBWW_FLABEL, TRUE);
                return (LRESULT)0;

        case WM_ERASEBKGND:
                {

                        RECT rect;
                        GetClientRect(hWnd, &rect);
                        HBRUSH hBrush = (HBRUSH)SendMessage(GetParent(hWnd), WM_CTLCOLORDLG,
                                wParam, (LPARAM)GetParent(hWnd));

                        if (!hBrush)
                                return FALSE;

                        UnrealizeObject(hBrush);

                        SetBrushOrgEx((HDC)wParam, 0, 0, NULL);
                        FillRect((HDC)wParam, &rect, hBrush);
                        return TRUE;
                }

        case WM_PAINT:
                {
                        HGLOBAL hMF = (HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);

                        //BeginPaint and EndPaint clear us even if hMF is NULL.
                        PAINTSTRUCT ps;
                        HDC hDC = BeginPaint(hWnd, &ps);

                        if (NULL != hMF)
                        {
                                //Now we get to paint the metafile, centered in our rect.
                                RECT rc;
                                GetClientRect(hWnd, &rc);

                                /*
                                 * If we're doing icon only, then place the metafile
                                 * at the center of our box minus half the icon width.
                                 * Top is top.
                                 */
                                BOOL fLabel = GetWindowWord(hWnd, IBWW_FLABEL);

                                //Go draw where we decided to place it.
                                OleUIMetafilePictIconDraw(hDC, &rc, hMF, !fLabel);
                        }
                        EndPaint(hWnd, &ps);
                }
                break;

        case IBXM_IMAGESET:
                {
                        /*
                         * wParam is a flag to delete the old or not.
                         * lParam contains the new handle.
                         */
                        HGLOBAL hMF = (HGLOBAL)SetWindowLongPtr(hWnd, IBWW_HIMAGE, lParam);
                        InvalidateRect(hWnd, NULL, TRUE);
                        UpdateWindow(hWnd);

                        //Delete the old handle if requested
                        if (0L!=wParam)
                        {
                                OleUIMetafilePictIconFree(hMF);
                                hMF=NULL;
                        }
                        return (LRESULT)hMF;
                }

        case IBXM_IMAGEGET:
                {
                        //Return the current index.
                        HGLOBAL hMF=(HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);
                        return (LRESULT)hMF;
                }

        case IBXM_IMAGEFREE:
                {
                        //Free up whatever we're holding.
                        HGLOBAL hMF=(HGLOBAL)GetWindowLongPtr(hWnd, IBWW_HIMAGE);
                        OleUIMetafilePictIconFree(hMF);
                        SetWindowLongPtr(hWnd, IBWW_HIMAGE, 0);
                        return (LRESULT)1;
                }

        case IBXM_LABELENABLE:
                //wParam has the new flag, returns the previous flag.
                return (LRESULT)SetWindowWord(hWnd, IBWW_FLABEL, (WORD)wParam);

        default:
                return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

        return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\insobj.cpp ===
/*
 * INSOBJ.CPP
 *
 * Implements the OleUIInsertObject function which invokes the complete
 * Insert Object dialog.  Makes use of the OleChangeIcon function in
 * ICON.CPP.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved
 */

#include "precomp.h"
#include "common.h"
#include <commdlg.h>
#include <memory.h>
#include <dos.h>
#include <stdlib.h>
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"

#include "strcache.h"

OLEDBGDATA

#if USE_STRING_CACHE==1
extern CStringCache gInsObjStringCache; //defined in strcache.cpp
DWORD g_dwOldListType = 0;
#endif

// Internally used structure
typedef struct tagINSERTOBJECT
{
        LPOLEUIINSERTOBJECT lpOIO;              // Original structure passed.
        UINT                    nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */
        DWORD               dwFlags;
        CLSID               clsid;
        TCHAR               szFile[MAX_PATH];
        BOOL                fFileSelected;      // Enables Display As Icon for links
        BOOL                fAsIconNew;
        BOOL                fAsIconFile;
        BOOL                fFileDirty;
        BOOL                fFileValid;
        UINT                nErrCode;
        HGLOBAL             hMetaPictFile;
        UINT                nBrowseHelpID;      // Help ID callback for Browse dlg
        BOOL                            bObjectListFilled;
        BOOL                            bControlListFilled;
        BOOL                            bControlListActive;

} INSERTOBJECT, *PINSERTOBJECT, FAR *LPINSERTOBJECT;

// Internal function prototypes
// INSOBJ.CPP

void EnableChangeIconButton(HWND hDlg, BOOL fEnable);
INT_PTR CALLBACK InsertObjectDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FInsertObjectInit(HWND, WPARAM, LPARAM);
UINT UFillClassList(HWND, UINT, LPCLSID, BOOL, BOOL);
LRESULT URefillClassList(HWND, LPINSERTOBJECT);
BOOL FToggleObjectSource(HWND, LPINSERTOBJECT, DWORD);
void UpdateClassType(HWND, LPINSERTOBJECT, BOOL);
void SetInsertObjectResults(HWND, LPINSERTOBJECT);
BOOL FValidateInsertFile(HWND, BOOL, UINT FAR*);
void InsertObjectCleanup(HWND);
static void UpdateClassIcon(HWND hDlg, LPINSERTOBJECT lpIO, HWND hList);
BOOL CALLBACK HookDlgProc(HWND, UINT, WPARAM, LPARAM);

#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':')

BOOL CALLBACK HookDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
#ifdef CHICO
    switch (uMsg)
    {
    case WM_INITDIALOG:
        TCHAR szTemp[MAX_PATH];
        LoadString(_g_hOleStdResInst, IDS_INSERT , szTemp, MAX_PATH);
        CommDlg_OpenSave_SetControlText(GetParent(hDlg), IDOK, szTemp);
        return(TRUE);
    default:
        break;
    }
#endif
    return(FALSE);
}

/*
 * OleUIInsertObject
 *
 * Purpose:
 *  Invokes the standard OLE Insert Object dialog box allowing the
 *  user to select an object source and classname as well as the option
 *  to display the object as itself or as an icon.
 *
 * Parameters:
 *  lpIO            LPOLEUIINSERTOBJECT pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            OLEUI_SUCCESS or OLEUI_OK if all is well, otherwise
 *                  an error value.
 */

STDAPI_(UINT) OleUIInsertObject(LPOLEUIINSERTOBJECT lpIO)
{
        HGLOBAL hMemDlg = NULL;
        UINT uRet = UStandardValidation((LPOLEUISTANDARD)lpIO, sizeof(OLEUIINSERTOBJECT),
                &hMemDlg);

        if (OLEUI_SUCCESS != uRet)
                return uRet;

        //Now we can do Insert Object specific validation.

        if (NULL != lpIO->lpszFile &&
                (lpIO->cchFile <= 0 || lpIO->cchFile > MAX_PATH))
        {
                uRet = OLEUI_IOERR_CCHFILEINVALID;
        }

        // NULL is NOT valid for lpszFile
        if (lpIO->lpszFile == NULL)
        {
            uRet = OLEUI_IOERR_LPSZFILEINVALID;
        }
        else
        {
            if (IsBadWritePtr(lpIO->lpszFile, lpIO->cchFile*sizeof(TCHAR)))
                    uRet = OLEUI_IOERR_LPSZFILEINVALID;
        }

        if (0 != lpIO->cClsidExclude &&
                IsBadReadPtr(lpIO->lpClsidExclude, lpIO->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        //If we have flags to create any object, validate necessary data.
        if (lpIO->dwFlags & (IOF_CREATENEWOBJECT | IOF_CREATEFILEOBJECT | IOF_CREATELINKOBJECT))
        {
                if (NULL != lpIO->lpFormatEtc
                        && IsBadReadPtr(lpIO->lpFormatEtc, sizeof(FORMATETC)))
                        uRet = OLEUI_IOERR_LPFORMATETCINVALID;

                if (NULL != lpIO->ppvObj && IsBadWritePtr(lpIO->ppvObj, sizeof(LPVOID)))
                        uRet = OLEUI_IOERR_PPVOBJINVALID;

                if (NULL != lpIO->lpIOleClientSite
                        && IsBadReadPtr(*(VOID**)&lpIO->lpIOleClientSite, sizeof(DWORD)))
                        uRet = OLEUI_IOERR_LPIOLECLIENTSITEINVALID;

                if (NULL != lpIO->lpIStorage
                        && IsBadReadPtr(*(VOID**)&lpIO->lpIStorage, sizeof(DWORD)))
                        uRet = OLEUI_IOERR_LPISTORAGEINVALID;
        }

        if (OLEUI_ERR_STANDARDMIN <= uRet)
        {
                return uRet;
        }
#if USE_STRING_CACHE==1
        // Inform the string cache about a fresh InsertObject invocation.
        gInsObjStringCache.NewCall(lpIO->dwFlags, lpIO->cClsidExclude);
#endif

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(InsertObjectDialogProc, (LPOLEUISTANDARD)lpIO,
                hMemDlg, MAKEINTRESOURCE(IDD_INSERTOBJECT));

        //Stop here if we cancelled or had an error.
        if (OLEUI_SUCCESS !=uRet && OLEUI_OK!=uRet)
                return uRet;

        /*
         * If any of the flags specify that we're to create objects on return
         * from this dialog, then do so.  If we encounter an error in this
         * processing, we return OLEUI_IOERR_SCODEHASERROR.  Since the
         * three select flags are mutually exclusive, we don't have to
         * if...else here, just if each case (keeps things cleaner that way).
         */

        lpIO->sc = S_OK;

        // Check if Create New was selected and we have IOF_CREATENEWOBJECT
        if ((lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL)) &&
                (lpIO->dwFlags & IOF_CREATENEWOBJECT))
        {
                HRESULT hrErr = OleCreate(lpIO->clsid, lpIO->iid, lpIO->oleRender,
                        lpIO->lpFormatEtc, lpIO->lpIOleClientSite, lpIO->lpIStorage,
                        lpIO->ppvObj);
                lpIO->sc = GetScode(hrErr);
        }

        // Try Create From File
        if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE))
        {
                if (!(lpIO->dwFlags & IOF_CHECKLINK) && (lpIO->dwFlags & IOF_CREATEFILEOBJECT))
                {
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszFile[MAX_PATH];
                        ATOW(wszFile, lpIO->lpszFile, MAX_PATH);
                        HRESULT hrErr=OleCreateFromFile(CLSID_NULL, wszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
#else
                        HRESULT hrErr=OleCreateFromFile(CLSID_NULL, lpIO->lpszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
#endif
                        lpIO->sc = GetScode(hrErr);
                }

                if ((lpIO->dwFlags & IOF_CHECKLINK) && (lpIO->dwFlags & IOF_CREATELINKOBJECT))
                {
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszFile[MAX_PATH];
                        ATOW(wszFile, lpIO->lpszFile, MAX_PATH);
                        HRESULT hrErr=OleCreateLinkToFile(wszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
#else
                        HRESULT hrErr=OleCreateLinkToFile(lpIO->lpszFile, lpIO->iid,
                                lpIO->oleRender, lpIO->lpFormatEtc, lpIO->lpIOleClientSite,
                                lpIO->lpIStorage, lpIO->ppvObj);
#endif
                        lpIO->sc = GetScode(hrErr);
                }
        }

        //If we tried but failed a create option, then return the appropriate error
        if (S_OK != lpIO->sc)
                uRet = OLEUI_IOERR_SCODEHASERROR;

        return uRet;
}

/*
 * InsertObjectDialogProc
 *
 * Purpose:
 *  Implements the OLE Insert Object dialog as invoked through the
 *  OleUIInsertObject function.
 */

INT_PTR CALLBACK InsertObjectDialogProc(HWND hDlg, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT uRet = 0;
        LPINSERTOBJECT lpIO = (LPINSERTOBJECT)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &uRet);

        // If the hook processed the message, we're done.
        if (0 != uRet)
                return (BOOL)uRet;

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
                if (lpIO != NULL)
                    PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp, wParam, lParam);
                return FALSE;
        }

        // Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        // The following messages do not require lpio to be non-null.
        switch (iMsg)
        {
        case WM_INITDIALOG:
            return FInsertObjectInit(hDlg, wParam, lParam);
        }

        // The following messages DO require lpIO to be non-null, so don't
        // continue processing if lpIO is NULL.
        if (NULL == lpIO)
            return FALSE;

        switch (iMsg)
        {
        case WM_DESTROY:
            InsertObjectCleanup(hDlg);
            StandardCleanup(lpIO, hDlg);
            break;

        case WM_COMMAND:
            switch (wID)
            {
            case IDC_IO_CREATENEW:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATENEW))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATENEW);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_CREATENEW));
                }
                break;
                
            case IDC_IO_CREATEFROMFILE:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATEFROMFILE))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATEFROMFILE);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_CREATEFROMFILE));
                }
                break;
                
            case IDC_IO_INSERTCONTROL:
                if (1 == IsDlgButtonChecked(hDlg, IDC_IO_INSERTCONTROL))
                {
                    FToggleObjectSource(hDlg, lpIO, IOF_SELECTCREATECONTROL);
                    SetFocus(GetDlgItem(hDlg, IDC_IO_INSERTCONTROL));
                }
                break;
                
            case IDC_IO_LINKFILE:
                {
                    BOOL fCheck=IsDlgButtonChecked(hDlg, wID);
                    if (fCheck)
                        lpIO->dwFlags |=IOF_CHECKLINK;
                    else
                        lpIO->dwFlags &=~IOF_CHECKLINK;
                    
                    // Results change here, so be sure to update it.
                    SetInsertObjectResults(hDlg, lpIO);
                    UpdateClassIcon(hDlg, lpIO, NULL);
                }
                break;

            case IDC_IO_OBJECTTYPELIST:
                switch (wCode)
                {
                case LBN_SELCHANGE:
                    UpdateClassIcon(hDlg, lpIO, hWndMsg);
                    SetInsertObjectResults(hDlg, lpIO);
                    break;
                    
                case LBN_DBLCLK:
                    SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                    break;
                }
                break;

            case IDC_IO_FILEDISPLAY:
                // If there are characters, enable OK and Display As Icon
                if (EN_CHANGE == wCode)
                {
                    lpIO->fFileDirty = TRUE;
                    lpIO->fFileValid = FALSE;
                    lpIO->fFileSelected = (0L != SendMessage(hWndMsg, EM_LINELENGTH, 0, 0L));
                    StandardEnableDlgItem(hDlg, IDC_IO_LINKFILE, lpIO->fFileSelected);
                    StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, lpIO->fFileSelected);
                    EnableChangeIconButton(hDlg, lpIO->fFileSelected);
                    StandardEnableDlgItem(hDlg, IDOK, lpIO->fFileSelected);
                }
                if (EN_KILLFOCUS == wCode && NULL != lpIO)
                {
                    if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                    {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = TRUE;
                        UpdateClassIcon(hDlg, lpIO, NULL);
                        UpdateClassType(hDlg, lpIO, TRUE);
                    }
                    else
                    {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = FALSE;
                        UpdateClassType(hDlg, lpIO, FALSE);
                    }
                }
                break;

            case IDC_IO_DISPLAYASICON:
                {
                    BOOL fCheck = IsDlgButtonChecked(hDlg, wID);
                    if (fCheck)
                        lpIO->dwFlags |=IOF_CHECKDISPLAYASICON;
                    else
                        lpIO->dwFlags &=~IOF_CHECKDISPLAYASICON;
                    
                    // Update the internal flag based on this checking
                    if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                        lpIO->fAsIconNew = fCheck;
                    else
                        lpIO->fAsIconFile = fCheck;
                    
                    // Re-read the class icon on Display checked
                    if (fCheck)
                    {
                        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                        {
                            if (FValidateInsertFile(hDlg, TRUE,&lpIO->nErrCode))
                            {
                                lpIO->fFileDirty = FALSE;
                                lpIO->fFileValid = TRUE;
                                UpdateClassIcon(hDlg, lpIO,
                                                GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                                UpdateClassType(hDlg, lpIO, TRUE);
                            }
                            else
                            {
                                lpIO->fAsIconFile= FALSE;
                                lpIO->fFileDirty = FALSE;
                                lpIO->fFileValid = FALSE;
                                SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY,
                                                   IBXM_IMAGESET, 0, 0L);
                                UpdateClassType(hDlg, lpIO, FALSE);
                                
                                lpIO->dwFlags &=~IOF_CHECKDISPLAYASICON;
                                CheckDlgButton(hDlg, IDC_IO_DISPLAYASICON, 0);
                                
                                HWND hWndEC = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                                SetFocus(hWndEC);
                                SendMessage(hWndEC, EM_SETSEL, 0, -1);
                                return TRUE;
                            }
                        }
                        else
                            UpdateClassIcon(hDlg, lpIO,
                                            GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                    }
                    
                    // Results change here, so be sure to update it.
                    SetInsertObjectResults(hDlg, lpIO);

                    /*
                     * Show or hide controls as appropriate.  Do the icon
                     * display last because it will take some time to repaint.
                     * If we do it first then the dialog looks too sluggish.
                     */
                    UINT i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
                    StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, i);
                    StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, i);
                    EnableChangeIconButton(hDlg, fCheck);
                }
                break;

            case IDC_IO_CHANGEICON:
                {
                    // if we're in SELECTCREATEFROMFILE mode, then we need to Validate
                    // the contents of the edit control first.

                    if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                    {
                        if (lpIO->fFileDirty &&
                            !FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            HWND hWndEC;
                            lpIO->fFileValid = FALSE;
                            hWndEC = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWndEC);
                            SendMessage(hWndEC, EM_SETSEL, 0, -1);
                            return TRUE;
                        }
                        else
                        {
                            lpIO->fFileDirty = FALSE;
                        }
                    }
                    
                    // Initialize the structure for the hook.
                    OLEUICHANGEICON ci; memset(&ci, 0, sizeof(ci));
                    ci.cbStruct = sizeof(ci);
                    ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                        IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                    ci.hWndOwner= hDlg;
                    ci.dwFlags  = CIF_SELECTCURRENT;
                    if (lpIO->dwFlags & IOF_SHOWHELP)
                        ci.dwFlags |= CIF_SHOWHELP;
                    
                    HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                    int iCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);
                    if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                    {
                        LPTSTR pszString = (LPTSTR)OleStdMalloc(
                            OLEUI_CCHKEYMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);
                        
                        SendMessage(hList, LB_GETTEXT, iCurSel, (LPARAM)pszString);
                        
                        LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
                        ATOW(wszCLSID, pszCLSID, OLEUI_CCHKEYMAX);
                        CLSIDFromString(wszCLSID, &ci.clsid);
#else
                        CLSIDFromString(pszCLSID, &ci.clsid);
#endif
                        OleStdFree((LPVOID)pszString);
                    }
                    else  // IOF_SELECTCREATEFROMFILE
                    {
                        TCHAR  szFileName[MAX_PATH];
                        GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszFileName[MAX_PATH];
                        ATOW(wszFileName, szFileName, MAX_PATH);
                        if (S_OK != GetClassFile(wszFileName, &ci.clsid))
#else
                            if (S_OK != GetClassFile(szFileName, &ci.clsid))
#endif
                            {
                                int istrlen = lstrlen(szFileName);
                                LPTSTR lpszExtension = szFileName + istrlen -1;

                                while (lpszExtension > szFileName &&
                                       *lpszExtension != '.')
                                {
                                    lpszExtension = CharPrev(szFileName, lpszExtension);
                                }

                                GetAssociatedExecutable(lpszExtension, ci.szIconExe);
                                ci.cchIconExe = lstrlen(ci.szIconExe);
                                ci.dwFlags |= CIF_USEICONEXE;
                            }
                    }

                    // Let the hook in to customize Change Icon if desired.
                    uRet = UStandardHook(lpIO, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

                    if (0 == uRet)
                        uRet = (UINT)(OLEUI_OK == OleUIChangeIcon(&ci));
                    
                    // Update the display and itemdata if necessary.
                    if (0 != uRet)
                    {
                        /*
                         * OleUIChangeIcon will have already freed our
                         * current hMetaPict that we passed in when OK is
                         * pressed in that dialog.  So we use 0L as lParam
                         * here so the IconBox doesn't try to free the
                         * metafilepict again.
                         */
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY,
                                           IBXM_IMAGESET, 0, (LPARAM)ci.hMetaPict);
                        
                        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                            SendMessage(hList, LB_SETITEMDATA, iCurSel, (LPARAM)ci.hMetaPict);
                    }
                }
                break;

            case IDC_IO_FILE:
                {
                    /*
                     * To allow the hook to customize the browse dialog, we
                     * send OLEUI_MSG_BROWSE.  If the hook returns FALSE
                     * we use the default, otherwise we trust that it retrieved
                     * a filename for us.  This mechanism prevents hooks from
                     * trapping IDC_IO_BROWSE to customize the dialog and from
                     * trying to figure out what we do after we have the name.
                     */
                    TCHAR szTemp[MAX_PATH];
                    int nChars = GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szTemp, MAX_PATH);
                    
                    TCHAR szInitialDir[MAX_PATH];
                    BOOL fUseInitialDir = FALSE;
                    if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                    {
                        StandardGetFileTitle(szTemp, lpIO->szFile, MAX_PATH);
                        int istrlen = lstrlen(lpIO->szFile);
                        
                        lstrcpyn(szInitialDir, szTemp, nChars - istrlen);
                        fUseInitialDir = TRUE;
                    }
                    else  // file name isn't valid...lop off end of szTemp to get a
                          // valid directory
                    {
                        TCHAR szBuffer[MAX_PATH];
                        lstrcpyn(szBuffer, szTemp, sizeof(szBuffer)/sizeof(TCHAR));
                        
                        if ('\\' == szBuffer[nChars-1])
                            szBuffer[nChars-1] = '\0';
                        
                        DWORD Attribs = GetFileAttributes(szBuffer);
                        if (Attribs != 0xffffffff &&
                            (Attribs & FILE_ATTRIBUTE_DIRECTORY) )
                        {
                            lstrcpy(szInitialDir, szBuffer);
                            fUseInitialDir = TRUE;
                        }
                        *lpIO->szFile = '\0';
                    }
                    
                    uRet = UStandardHook(lpIO, hDlg, uMsgBrowse,
                                         MAX_PATH, (LPARAM)(LPSTR)lpIO->szFile);

                    if (0 == uRet)
                    {
                        DWORD dwOfnFlags = OFN_FILEMUSTEXIST | OFN_ENABLEHOOK;
                        if (lpIO->lpOIO->dwFlags & IOF_SHOWHELP)
                            dwOfnFlags |= OFN_SHOWHELP;
                        
                        uRet = (UINT)Browse(hDlg, lpIO->szFile,
                                            fUseInitialDir ? szInitialDir : NULL, MAX_PATH,
                                            IDS_FILTERS, dwOfnFlags, ID_BROWSE_INSERTFILE, (LPOFNHOOKPROC)HookDlgProc);
                    }
                    
                    // Only update if the file changed.
                    if (0 != uRet && 0 != lstrcmpi(szTemp, lpIO->szFile))
                    {
                        SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, lpIO->szFile);
                        lpIO->fFileSelected=TRUE;
                        
                        if (FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = TRUE;
                            UpdateClassIcon(hDlg, lpIO, NULL);
                            UpdateClassType(hDlg, lpIO, TRUE);
                            // auto set OK to be default button if valid file
                            SendMessage(hDlg, DM_SETDEFID,
                                        (WPARAM)GetDlgItem(hDlg, IDOK), 0L);
                            SetFocus(GetDlgItem(hDlg, IDOK));
                        }
                        else  // filename is invalid - set focus back to ec
                        {
                            HWND hWnd;
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = FALSE;
                            hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWnd);
                            SendMessage(hWnd, EM_SETSEL, 0, -1);
                        }

                        // Once we have a file, Display As Icon is always enabled
                        StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, TRUE);
                        
                        // As well as OK
                        StandardEnableDlgItem(hDlg, IDOK, TRUE);
                    }
                }
                break;

            case IDC_IO_ADDCONTROL:
                {
                    TCHAR szFileName[MAX_PATH];
                    szFileName[0] = 0;
                    
                    // allow hook to customize
                    uRet = UStandardHook(lpIO, hDlg, uMsgAddControl,
                                         MAX_PATH, (LPARAM)szFileName);
                    
                    if (0 == uRet)
                    {
                        DWORD dwOfnFlags = OFN_FILEMUSTEXIST | OFN_ENABLEHOOK;
                        if (lpIO->lpOIO->dwFlags & IOF_SHOWHELP)
                            dwOfnFlags |= OFN_SHOWHELP;
                        uRet = (UINT)Browse(hDlg, szFileName, NULL, MAX_PATH,
                                            IDS_OCX_FILTERS, dwOfnFlags, ID_BROWSE_ADDCONTROL , (LPOFNHOOKPROC)HookDlgProc);
                    }
                    
                    if (0 != uRet)
                    {
                        // try to register the control DLL
                        HINSTANCE hInst = LoadLibrary(szFileName);
                        if (hInst == NULL)
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_CANNOTLOADOCX,
                                         MB_OK | MB_ICONEXCLAMATION);
                            break;
                        }
                        
                        HRESULT (FAR STDAPICALLTYPE* lpfn)(void);
                        (FARPROC&)lpfn = GetProcAddress(hInst, "DllRegisterServer");
                        if (lpfn == NULL)
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_NODLLREGISTERSERVER,
                                         MB_OK | MB_ICONEXCLAMATION);
                            FreeLibrary(hInst);
                            break;
                        }
                        
                        if (FAILED((*lpfn)()))
                        {
                            PopupMessage(hDlg, IDS_ADDCONTROL, IDS_DLLREGISTERFAILED,
                                         MB_OK | MB_ICONEXCLAMATION);
                            FreeLibrary(hInst);
                            break;
                        }
                        
                        // cleanup the DLL from memory
                        FreeLibrary(hInst);
                        
                        // registered successfully -- refill the list box
                        lpIO->bControlListFilled = FALSE;
                        lpIO->bObjectListFilled = FALSE;
                        URefillClassList(hDlg, lpIO);
                    }
                }
                break;

            case IDOK:
                {
                    if ((HWND)lParam != GetFocus())
                        SetFocus((HWND)lParam);
                    
                    // If the file name is clean (already validated), or
                    // if Create New is selected, then we can skip this part.
                    
                    if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE) &&
                        lpIO->fFileDirty)
                    {
                        if (FValidateInsertFile(hDlg, TRUE, &lpIO->nErrCode))
                        {
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = TRUE;
                            UpdateClassIcon(hDlg, lpIO, NULL);
                            UpdateClassType(hDlg, lpIO, TRUE);
                        }
                        else  // filename is invalid - set focus back to ec
                        {
                            HWND hWnd;
                            lpIO->fFileDirty = FALSE;
                            lpIO->fFileValid = FALSE;
                            hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                            SetFocus(hWnd);
                            SendMessage(hWnd, EM_SETSEL, 0, -1);
                            UpdateClassType(hDlg, lpIO, FALSE);
                        }
                        return TRUE;  // eat this message
                    }
                    else if ((lpIO->dwFlags & IOF_SELECTCREATEFROMFILE) &&
                             !lpIO->fFileValid)
                    {
                        // filename is invalid - set focus back to ec
                        HWND hWnd;
                        TCHAR szFile[MAX_PATH];
                        
                        if (0 != GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY,
                                                szFile, MAX_PATH))
                        {
                            OpenFileError(hDlg, lpIO->nErrCode, szFile);
                        }
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = FALSE;
                        hWnd = GetDlgItem(hDlg, IDC_IO_FILEDISPLAY);
                        SetFocus(hWnd);
                        SendMessage(hWnd, EM_SETSEL, 0, -1);
                        UpdateClassType(hDlg, lpIO, FALSE);
                        return TRUE;  // eat this message
                    }
                    
                    // Copy the necessary information back to the original struct
                    LPOLEUIINSERTOBJECT lpOIO = lpIO->lpOIO;
                    lpOIO->dwFlags = lpIO->dwFlags;
                    
                    if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
                    {
                        HWND hListBox = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                        UINT iCurSel = (UINT)SendMessage(hListBox, LB_GETCURSEL, 0, 0);
                        
                        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
                        {
                            lpOIO->hMetaPict=(HGLOBAL)SendMessage(hListBox,
                                                                  LB_GETITEMDATA, iCurSel, 0L);
                            
                            /*
                             * Set the item data to 0 here so that the cleanup
                             * code doesn't delete the metafile.
                             */
                            SendMessage(hListBox, LB_SETITEMDATA, iCurSel, 0L);
                        }
                        else
                            lpOIO->hMetaPict = (HGLOBAL)NULL;
                        
                        TCHAR szBuffer[OLEUI_CCHKEYMAX+OLEUI_CCHCLSIDSTRING];
                        SendMessage(hListBox, LB_GETTEXT, iCurSel, (LPARAM)szBuffer);
                        
                        LPTSTR lpszCLSID = PointerToNthField(szBuffer, 2, '\t');
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
                        ATOW(wszCLSID, lpszCLSID, OLEUI_CCHKEYMAX);
                        CLSIDFromString(wszCLSID, &lpOIO->clsid);
#else
                        CLSIDFromString(lpszCLSID, &lpOIO->clsid);
#endif
                    }
                    else  // IOF_SELECTCREATEFROMFILE
                    {
                        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
                        {
                            // get metafile here
                            lpOIO->hMetaPict = (HGLOBAL)SendDlgItemMessage(
                                hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                        }
                        else
                            lpOIO->hMetaPict = (HGLOBAL)NULL;
                    }
                    
                    GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY,
                                   lpIO->szFile, lpOIO->cchFile);
                    lstrcpyn(lpOIO->lpszFile, lpIO->szFile, lpOIO->cchFile);
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                }
                break;
                
            case IDCANCEL:
                SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                break;
                
            case IDC_OLEUIHELP:
                PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_INSERTOBJECT, 0));
                break;
            }
            break;
            
        default:
            if (iMsg == lpIO->nBrowseHelpID)
            {
                PostMessage(lpIO->lpOIO->hWndOwner, uMsgHelp,
                            (WPARAM)hDlg, MAKELPARAM(IDD_INSERTFILEBROWSE, 0));
            }
            if (iMsg == uMsgBrowseOFN &&
                lpIO->lpOIO && lpIO->lpOIO->hWndOwner)
            {
                SendMessage(lpIO->lpOIO->hWndOwner, uMsgBrowseOFN, wParam, lParam);
            }
            break;
        }

        return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckButton
//
//  Synopsis:   Handles checking the radio buttons
//
//  Arguments:  [hDlg] - dialog handle
//              [iID]  - ID of the button to check
//
//  Returns:    nothing
//
//  History:    1-19-95   stevebl   Created
//
//  Notes:      Used in place of CheckRadioButtons to avoid a GP fault under
//              win32s that arises from IDC_IO_CREATENEW, IDC_IO_CREATEFROMFILE
//              and IDC_IO_INSERTCONTROL not being contiguous.
//
//----------------------------------------------------------------------------

void CheckButton(HWND hDlg, int iID)
{
    CheckDlgButton(hDlg, IDC_IO_CREATENEW, iID == IDC_IO_CREATENEW ? 1 : 0);
    CheckDlgButton(hDlg, IDC_IO_CREATEFROMFILE, iID == IDC_IO_CREATEFROMFILE ? 1 : 0);
    CheckDlgButton(hDlg, IDC_IO_INSERTCONTROL, iID == IDC_IO_INSERTCONTROL ? 1 : 0);
}


/*
 * FInsertObjectInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Insert Object dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FInsertObjectInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPINSERTOBJECT lpIO = (LPINSERTOBJECT)LpvStandardInit(hDlg, sizeof(INSERTOBJECT), &hFont);

        // PvStandardInit send a termination to us already.
        if (NULL == lpIO)
                return FALSE;

        LPOLEUIINSERTOBJECT lpOIO = (LPOLEUIINSERTOBJECT)lParam;

        // Save the original pointer and copy necessary information.
        lpIO->lpOIO = lpOIO;
        lpIO->nIDD = IDD_INSERTOBJECT;
        lpIO->dwFlags = lpOIO->dwFlags;
        lpIO->clsid = lpOIO->clsid;

        if ((lpOIO->lpszFile) && ('\0' != *lpOIO->lpszFile))
                lstrcpyn(lpIO->szFile, lpOIO->lpszFile, MAX_PATH);
        else
                *(lpIO->szFile) = '\0';

        lpIO->hMetaPictFile = (HGLOBAL)NULL;

        // If we got a font, send it to the necessary controls.
        if (NULL != hFont)
        {
                SendDlgItemMessage(hDlg, IDC_IO_RESULTTEXT,  WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_IO_FILETYPE,  WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Initilize the file name display to cwd if we don't have any name.
        if ('\0' == *(lpIO->szFile))
        {
                TCHAR szCurDir[MAX_PATH];
                int nLen;
                GetCurrentDirectory(MAX_PATH, szCurDir);
                nLen = lstrlen(szCurDir);
                if (nLen != 0 && szCurDir[nLen-1] != '\\')
                        lstrcat(szCurDir, _T("\\"));
                SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szCurDir);
                lpIO->fFileDirty = TRUE;  // cwd is not a valid filename
        }
        else
        {
                SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, lpIO->szFile);
                if (FValidateInsertFile(hDlg, FALSE, &lpIO->nErrCode))
                {
                        lpIO->fFileDirty = FALSE;
                        lpIO->fFileValid = TRUE;
                }
                else
                {
                        lpIO->fFileDirty = TRUE;
                        lpIO->fFileValid = FALSE;
                }
        }

        // Initialize radio button and related controls
        if (lpIO->dwFlags & IOF_CHECKDISPLAYASICON)
        {
            if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                    lpIO->fAsIconNew = TRUE;
            else
                    lpIO->fAsIconFile = TRUE;
        }
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                CheckButton(hDlg, IDC_IO_CREATENEW);
        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
                CheckButton(hDlg, IDC_IO_CREATEFROMFILE);
        if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                CheckButton(hDlg, IDC_IO_INSERTCONTROL);
        CheckDlgButton(hDlg, IDC_IO_LINKFILE, (BOOL)(0L != (lpIO->dwFlags & IOF_CHECKLINK)));

        lpIO->dwFlags &=
                ~(IOF_SELECTCREATENEW|IOF_SELECTCREATEFROMFILE|IOF_SELECTCREATECONTROL);
        FToggleObjectSource(hDlg, lpIO, lpOIO->dwFlags &
                (IOF_SELECTCREATENEW|IOF_SELECTCREATEFROMFILE|IOF_SELECTCREATECONTROL));

        // Show or hide the help button
        if (!(lpIO->dwFlags & IOF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpIO->dwFlags & IOF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_IO_CHANGEICON));

        // Hide Insert Control button if necessary
        if (!(lpIO->dwFlags & IOF_SHOWINSERTCONTROL))
                StandardShowDlgItem(hDlg, IDC_IO_INSERTCONTROL, SW_HIDE);

        // Initialize the result display
        UpdateClassIcon(hDlg, lpIO, GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
        SetInsertObjectResults(hDlg, lpIO);

        // Change the caption
        if (NULL!=lpOIO->lpszCaption)
                SetWindowText(hDlg, lpOIO->lpszCaption);

        // Hide all DisplayAsIcon related controls if it should be disabled
        if (lpIO->dwFlags & IOF_DISABLEDISPLAYASICON)
        {
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, SW_HIDE);
        }

        lpIO->nBrowseHelpID = RegisterWindowMessage(HELPMSGSTRING);

        // All Done:  call the hook with lCustData
        UStandardHook(lpIO, hDlg, WM_INITDIALOG, wParam, lpOIO->lCustData);

        /*
         * We either set focus to the listbox or the edit control.  In either
         * case we don't want Windows to do any SetFocus, so we return FALSE.
         */
        return FALSE;
}

/*
 * URefillClassList
 *
 * Purpose:
 *  Fills the class list box with names as appropriate for the current
 *  flags.  This function is called when the user changes the flags
 *  via the "exclusion" radio buttons.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  hDlg                HWND to the dialog box.
 *  lpIO                        pointer to LPINSERTOBJECT structure
 *
 * Return Value:
 *  LRESULT            Number of strings added to the listbox, -1 on failure.
 */
LRESULT URefillClassList(HWND hDlg, LPINSERTOBJECT lpIO)
{
        OleDbgAssert(lpIO->dwFlags & (IOF_SELECTCREATECONTROL|IOF_SELECTCREATENEW));

        // always the same dialog ID because they are swapped
        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);

        // determine if already filled
        BOOL bFilled;
        if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                bFilled = lpIO->bControlListFilled;
        else
                bFilled = lpIO->bObjectListFilled;

        if (!bFilled)
        {
                // fill the list
                LPOLEUIINSERTOBJECT lpOIO = lpIO->lpOIO;
                UINT uResult = UFillClassList(hList, lpOIO->cClsidExclude, lpOIO->lpClsidExclude,
                        (BOOL)(lpIO->dwFlags & IOF_VERIFYSERVERSEXIST),
                        (lpIO->dwFlags & IOF_SELECTCREATECONTROL));

                // mark the list as filled
                if (lpIO->dwFlags & IOF_SELECTCREATECONTROL)
                        lpIO->bControlListFilled = TRUE;
                else
                        lpIO->bObjectListFilled = TRUE;
        }

        // return number of items now in the list
        return SendMessage(hList, LB_GETCOUNT, 0, 0);
}


/*
 * UFillClassList
 *
 * Purpose:
 *  Enumerates available OLE object classes from the registration
 *  database and fills a listbox with those names.
 *
 *  Note that this function removes any prior contents of the listbox.
 *
 * Parameters:
 *  hList           HWND to the listbox to fill.
 *  cIDEx           UINT number of CLSIDs to exclude in lpIDEx
 *  lpIDEx          LPCLSID to CLSIDs to leave out of the listbox.
 *  fVerify         BOOL indicating if we are to validate existence of
 *                  servers before putting them in the list.
 *
 * Return Value:
 *  UINT            Number of strings added to the listbox, -1 on failure.
 */

UINT UFillClassList(HWND hList, UINT cIDEx, LPCLSID lpIDEx, BOOL fVerify,
        BOOL fExcludeObjects)
{
    OleDbgAssert(hList != NULL);

    // Set the tab width in the list to push all the tabs off the side.
    RECT rc;
    GetClientRect(hList, &rc);
    DWORD dw = GetDialogBaseUnits();
    rc.right =(8*rc.right)/LOWORD(dw);  //Convert pixels to 2x dlg units.
    SendMessage(hList, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&rc.right);

    // Clean out the existing strings.
    SendMessage(hList, LB_RESETCONTENT, 0, 0L);
    UINT cStrings = 0;

#if USE_STRING_CACHE==1
    if (gInsObjStringCache.OKToUse() && gInsObjStringCache.IsUptodate())
    {
        // IsUptodate returns false if the cache is not yet populated
        // or if any CLSID key changed in the registry since the last
        // time the cache was populated.
        
        LPCTSTR lpStr;
        // Reset enumerator in the cache.
        gInsObjStringCache.ResetEnumerator();
        while ( (lpStr = gInsObjStringCache.NextString()) != NULL)
        {
            SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)lpStr);
            cStrings++;
        }

    }
    else
    {
        // Setup the cache if it was successfully initialized and 
        // there were no errors in a previous use.
        if (gInsObjStringCache.OKToUse())
        {
            // Clear the string counter and enumerator.
            // We will fill up the cache with strings in this round.
            gInsObjStringCache.FlushCache(); 
        }
#endif
        LPTSTR pszExec = (LPTSTR)OleStdMalloc(OLEUI_CCHKEYMAX_SIZE*4);
        if (NULL == pszExec)
            return (UINT)-1;

        LPTSTR pszClass = pszExec+OLEUI_CCHKEYMAX;
        LPTSTR pszKey = pszClass+OLEUI_CCHKEYMAX;

        // Open up the root key.
        HKEY hKey;
        LONG lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);
        if ((LONG)ERROR_SUCCESS!=lRet)
        {
            OleStdFree((LPVOID)pszExec);
            return (UINT)-1;
        }

        // We will now loop over all ProgIDs and add candidates that
        // pass various insertable tests to the ListBox one by one.
        while (TRUE)
        {
            // assume not yet (for handling of OLE1.0 compat case)
            BOOL bHaveCLSID = FALSE;
            LPTSTR pszID = pszKey+OLEUI_CCHKEYMAX;

            lRet = RegEnumKey(hKey, cStrings++, pszClass, OLEUI_CCHKEYMAX_SIZE);
            if ((LONG)ERROR_SUCCESS != lRet)
                    break;
            if (!iswalpha(pszClass[0])) 
            {
                // avoids looking into ".ext" type entries under HKCR
                continue;
            }

            // Cheat on lstrcat by using lstrcpy after this string, saving time
            UINT cch = lstrlen(pszClass);

            // Check for \NotInsertable. If this is found then this overrides
            // all other keys; this class will NOT be added to the InsertObject
            // list.

            lstrcpy(pszClass+cch, TEXT("\\NotInsertable"));
            HKEY hKeyTemp = NULL;
            lRet = RegOpenKey(hKey, pszClass, &hKeyTemp);
            if (hKeyTemp != NULL)
                RegCloseKey(hKeyTemp);

            if ((LONG)ERROR_SUCCESS == lRet)
                continue;    // NotInsertable IS found--skip this class

            // check if ProgId says "Insertable"
            lstrcpy(pszClass+cch, TEXT("\\Insertable"));
            hKeyTemp = NULL;
            lRet = RegOpenKey(hKey, pszClass, &hKeyTemp);
            if (hKeyTemp != NULL)
                RegCloseKey(hKeyTemp);

            if (lRet == ERROR_SUCCESS || fExcludeObjects)
            {
                // ProgId says insertable (=> can't be OLE 1.0)
                // See if we are displaying Objects or Controls

                // Check for CLSID

                lstrcpy(pszClass+cch, TEXT("\\CLSID"));

                dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszClass, pszID, (LONG*)&dw);
                if ((LONG)ERROR_SUCCESS != lRet)
                    continue;   // CLSID subkey not found
                bHaveCLSID = TRUE;

                // CLSID\ is 6, dw contains pszID length.
                cch = 6 + ((UINT)dw/sizeof(TCHAR)) - 1;
                lstrcpy(pszExec, TEXT("CLSID\\"));
                lstrcpy(pszExec+6, pszID);


                //  fExcludeObjects is TRUE for the Insert Control box.
                //  It's FALSE for the Insert Object box.

                lstrcpy(pszExec+cch, TEXT("\\Control"));
                hKeyTemp = NULL;
                lRet = RegOpenKey(hKey, pszExec, &hKeyTemp);
                if (hKeyTemp != NULL)
                    RegCloseKey(hKeyTemp);

                if (!fExcludeObjects)
                {
                    // We are listing Objects.
                    if (lRet == ERROR_SUCCESS)
                    {   
                        // this is a control
                        continue;
                    }
                }
                else 
                {    
                    // We are listing controls
                    if (lRet != ERROR_SUCCESS)
                    {
                        // This is an Object
                        continue;
                    }
                    // Some generous soul at some point of time in the past
                    // decided that for controls it is OK to have the 
                    // Inertable key on the clsid too. So we have to perform 
                    // that additional check before we decide if the control
                    // entry should be listed or not.
                    
                    lstrcpy(pszExec+cch, TEXT("\\Insertable"));
                    hKeyTemp = NULL;
                    lRet = RegOpenKey(hKey, pszExec, &hKeyTemp);
                    if (hKeyTemp != NULL)
                        RegCloseKey(hKeyTemp);
                    if ((LONG)ERROR_SUCCESS != lRet)
                        continue;
                }

                
                // This is beginning to look like a probable list candidate

                // Check \LocalServer32, LocalServer, and \InprocServer
                // if we were requested to (IOF_VERIFYSERVERSEXIST)
                if (fVerify)
                {
                    // Try LocalServer32
                    lstrcpy(pszExec+cch, TEXT("\\LocalServer32"));
                    dw = OLEUI_CCHKEYMAX_SIZE;
                    lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                    if ((LONG)ERROR_SUCCESS != lRet)
                    {
                        // Try LocalServer
                        lstrcpy(pszExec+cch, TEXT("\\LocalServer"));
                        dw = OLEUI_CCHKEYMAX_SIZE;
                        lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                        if ((LONG)ERROR_SUCCESS != lRet)
                        {
                            // Try InprocServer32
                            lstrcpy(pszExec+cch, TEXT("\\InProcServer32"));
                            dw = OLEUI_CCHKEYMAX_SIZE;
                            lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                            if ((LONG)ERROR_SUCCESS != lRet)
                            {
                                // Try InprocServer
                                lstrcpy(pszExec+cch, TEXT("\\InProcServer"));
                                dw = OLEUI_CCHKEYMAX_SIZE;
                                lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                                if ((LONG)ERROR_SUCCESS != lRet)
                                    continue;
                            }
                        }
                    }

                    if (!DoesFileExist(pszKey, OLEUI_CCHKEYMAX))
                        continue;

                } //fVerify

                // Get the readable name for the server.
                // We'll needed it for the listbox.

                *(pszExec+cch) = 0;   //Remove \\*Server

                dw = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszExec, pszKey, (LONG*)&dw);
                if ((LONG)ERROR_SUCCESS!=lRet)
                    continue;

            }
            else
            {
                // We did not see an "Insertable" under ProgId, can
                // this be an OLE 1.0 time server entry?

                // Check for a \protocol\StdFileEditing\server entry.
                lstrcpy(pszClass+cch, TEXT("\\protocol\\StdFileEditing\\server"));
                DWORD dwTemp = OLEUI_CCHKEYMAX_SIZE;
                lRet = RegQueryValue(hKey, pszClass, pszKey, (LONG*)&dwTemp);
                if ((LONG)ERROR_SUCCESS == lRet)
                {
                    // This is not a control
                    // skip it if excluding non-controls
                    if (fExcludeObjects)
                        continue;

                    // Check if the EXE actually exists.  
                    // (By default we don't do this for speed.
                    // If an application wants to, it must provide 
                    // IOF_VERIFYSERVERSEXIST flag in the request)

                    if (fVerify && !DoesFileExist(pszKey, OLEUI_CCHKEYMAX))
                        continue;

                    // get readable class name
                    dwTemp = OLEUI_CCHKEYMAX_SIZE;
                    *(pszClass+cch) = 0;  // set back to rootkey
                    lRet=RegQueryValue(hKey, pszClass, pszKey, (LONG*)&dwTemp);

                    // attempt to get clsid directly from registry
                    lstrcpy(pszClass+cch, TEXT("\\CLSID"));
                    dwTemp = OLEUI_CCHKEYMAX_SIZE;
                    lRet = RegQueryValue(hKey, pszClass, pszID, (LONG*)&dwTemp);
                    if ((LONG)ERROR_SUCCESS == lRet)
                        bHaveCLSID = TRUE;
                    *(pszClass+cch) = 0;    // set back to rootkey
                }
                else 
                {   
                    // This is not OLE 1.0 either!
                    continue;
                }
            }

            // At this point we have an insertable candidate.
            // or OLE 1.0 time.

            // get CLSID to add to listbox.
            CLSID clsid;
            if (!bHaveCLSID)
            {
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszClass[OLEUI_CCHKEYMAX];
                ATOW(wszClass, pszClass, OLEUI_CCHKEYMAX);
                if (FAILED(CLSIDFromProgID(wszClass, &clsid)))
                    continue;
                LPOLESTR wszID;
                if (FAILED(StringFromCLSID(clsid, &wszID)))
                    continue;
                UINT uLen = WTOALEN(wszID);
                pszID = (LPTSTR) OleStdMalloc(uLen);
                WTOA(pszID, wszID, uLen);
#else
                if (FAILED(CLSIDFromProgID(pszClass, &clsid)))
                    continue;
                if (FAILED(StringFromCLSID(clsid, &pszID)))
                    continue;
#endif
            }
            else
            {
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszID[OLEUI_CCHKEYMAX];
                ATOW(wszID, pszID, OLEUI_CCHKEYMAX);
                if (FAILED(CLSIDFromString(wszID, &clsid)))
                    continue;
#else
                if (FAILED(CLSIDFromString(pszID, &clsid)))
                    continue;
#endif
            }

            // ##### WARNING #####: using 'continue' after this point 
            // would leak memory so don't use it!

            // check if this CLSID is in the exclusion list.
            BOOL fExclude = FALSE;
            for (UINT i=0; i < cIDEx; i++)
            {
                if (IsEqualCLSID(clsid, lpIDEx[i]))
                {
                    fExclude=TRUE;
                    break;
                }
            }

            // don't add objects without names
            if (lstrlen(pszKey) > 0 && !fExclude)
            {
                // We got through all the conditions, add the string.
                if (LB_ERR == SendMessage(hList, LB_FINDSTRING, 0, (LPARAM)pszKey))
                {
                    pszKey[cch = lstrlen(pszKey)] = '\t';
                    lstrcpy(pszKey+cch+1, pszID);
                    SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)pszKey);
#if USE_STRING_CACHE==1
                    if (gInsObjStringCache.OKToUse())
                    {   
                        if (!gInsObjStringCache.AddString(pszKey))
                        {
                            // Adding the string failed due to some reason
                            OleDbgAssert(!"Failure adding string");
                            
                            // A failed Add() should mark the    
                            // Cache not OK to use any more.
                            OleDbgAssert(!gInsObjStringCache.OKToUse())
                        }
                    }
#endif
                }
            }

            if (!bHaveCLSID)
                OleStdFree((LPVOID)pszID);
        }   // While (TRUE)
        RegCloseKey(hKey);
        OleStdFree((LPVOID)pszExec);

#if USE_STRING_CACHE
    }
#endif

    // Select the first item by default
    SendMessage(hList, LB_SETCURSEL, 0, 0L);

    return cStrings;
}

/*
 * FToggleObjectSource
 *
 * Purpose:
 *  Handles enabling, disabling, showing, and flag manipulation when the
 *  user changes between Create New, Insert File, and Link File in the
 *  Insert Object dialog.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  dwOption        DWORD flag indicating the option just selected:
 *                  IOF_SELECTCREATENEW or IOF_SELECTCREATEFROMFILE
 *
 * Return Value:
 *  BOOL            TRUE if the option was already selected, FALSE otherwise.
 */

BOOL FToggleObjectSource(HWND hDlg, LPINSERTOBJECT lpIO, DWORD dwOption)
{
        // Skip all of this if we're already selected.
        if (lpIO->dwFlags & dwOption)
                return TRUE;

#ifdef USE_STRING_CACHE
        // if we're using string cache, we need to flush the cache if
        // the list previously displayed was of different type

        if(IOF_SELECTCREATECONTROL == dwOption)
        {
            if(g_dwOldListType == IOF_SELECTCREATENEW)
                gInsObjStringCache.FlushCache();
            g_dwOldListType = IOF_SELECTCREATECONTROL;
        }
        else if(IOF_SELECTCREATENEW == dwOption)
        {
            if(g_dwOldListType == IOF_SELECTCREATECONTROL)
                gInsObjStringCache.FlushCache(); 
            g_dwOldListType = IOF_SELECTCREATENEW;
        }
#endif


        // if we're switching from "from file" to "create new" and we've got
        // an icon for "from file", then we need to save it so that we can
        // show it if the user reselects "from file".

        if ((IOF_SELECTCREATENEW == dwOption) &&
                (lpIO->dwFlags & IOF_CHECKDISPLAYASICON))
        {
                lpIO->hMetaPictFile = (HGLOBAL)SendDlgItemMessage(hDlg,
                        IDC_IO_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
        }

        /*
         * 1.  Change the Display As Icon checked state to reflect the
         *     selection for this option, stored in the fAsIcon* flags.
         */
        BOOL fTemp;
        if (IOF_SELECTCREATENEW == dwOption)
                fTemp = lpIO->fAsIconNew;
        else if (IOF_SELECTCREATEFROMFILE == dwOption)
                fTemp = lpIO->fAsIconFile;
        else
                fTemp = FALSE;

        if (fTemp)
                lpIO->dwFlags |= IOF_CHECKDISPLAYASICON;
        else
                lpIO->dwFlags &= ~IOF_CHECKDISPLAYASICON;

        CheckDlgButton(hDlg, IDC_IO_DISPLAYASICON,
                 (BOOL)(0L!=(lpIO->dwFlags & IOF_CHECKDISPLAYASICON)));

        EnableChangeIconButton(hDlg, fTemp);

        /*
         *      Display Icon:  Enabled on Create New or on Create from File if
         *     there is a selected file.
         */
        if (IOF_SELECTCREATENEW == dwOption)
                fTemp = TRUE;
        else if (IOF_SELECTCREATEFROMFILE == dwOption)
                fTemp = lpIO->fFileSelected;
        else
                fTemp = FALSE;

        if (IOF_SELECTCREATECONTROL == dwOption)
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_HIDE);
        else if (!(lpIO->dwFlags & IOF_DISABLEDISPLAYASICON))
                StandardShowDlgItem(hDlg, IDC_IO_DISPLAYASICON, SW_SHOW);

        StandardEnableDlgItem(hDlg, IDC_IO_DISPLAYASICON, fTemp);

        // OK and Link follow the same enabling as Display As Icon.
        StandardEnableDlgItem(hDlg, IDOK,
                fTemp || IOF_SELECTCREATECONTROL == dwOption);
        StandardEnableDlgItem(hDlg, IDC_IO_LINKFILE, fTemp);

        // Enable Browse... when Create from File is selected.
        fTemp = (IOF_SELECTCREATEFROMFILE != dwOption);
        StandardEnableDlgItem(hDlg, IDC_IO_FILE, !fTemp);
        StandardEnableDlgItem(hDlg, IDC_IO_FILEDISPLAY, !fTemp);

        // Switch Object Type & Control Type listboxes if necessary
        HWND hWnd1 = NULL, hWnd2 = NULL;
        if (lpIO->bControlListActive && IOF_SELECTCREATENEW == dwOption)
        {
                hWnd1 = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                hWnd2 = GetDlgItem(hDlg, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd1, GWL_ID, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd2, GWL_ID, IDC_IO_OBJECTTYPELIST);
                lpIO->bControlListActive = FALSE;
        }
        else if (!lpIO->bControlListActive && IOF_SELECTCREATECONTROL == dwOption)
        {
                hWnd1 = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
                hWnd2 = GetDlgItem(hDlg, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd1, GWL_ID, IDC_IO_CONTROLTYPELIST);
                SetWindowLong(hWnd2, GWL_ID, IDC_IO_OBJECTTYPELIST);
                lpIO->bControlListActive = TRUE;
        }

        // Clear out any existing selection flags and set the new one
        DWORD dwTemp = IOF_SELECTCREATENEW | IOF_SELECTCREATEFROMFILE |
                IOF_SELECTCREATECONTROL;
        lpIO->dwFlags = (lpIO->dwFlags & ~dwTemp) | dwOption;

        if (dwOption & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
        {
                // refill class list box if necessary
                if ((lpIO->bControlListActive && !lpIO->bControlListFilled) ||
                        (!lpIO->bControlListActive && !lpIO->bObjectListFilled))
                {
                        URefillClassList(hDlg, lpIO);
                }
        }

        if (hWnd1 != NULL && hWnd2 != NULL)
        {
                ShowWindow(hWnd1, SW_HIDE);
                ShowWindow(hWnd2, SW_SHOW);
        }

        /*
         * Switch between Object Type listbox on Create New and
         *              file buttons on others.
         */
        UINT uTemp = (fTemp) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_OBJECTTYPELIST, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_OBJECTTYPETEXT, uTemp);

        uTemp = (fTemp) ? SW_HIDE : SW_SHOWNORMAL;
        StandardShowDlgItem(hDlg, IDC_IO_FILETEXT, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILETYPE, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILEDISPLAY, uTemp);
        StandardShowDlgItem(hDlg, IDC_IO_FILE, uTemp);

        // Link is always hidden if IOF_DISABLELINK is set.
        if (IOF_DISABLELINK & lpIO->dwFlags)
                uTemp = SW_HIDE;

        StandardShowDlgItem(hDlg, IDC_IO_LINKFILE, uTemp);  //last use of uTemp

        // Remove add button when not in Insert control mode
        uTemp = (IOF_SELECTCREATECONTROL == dwOption) ? SW_SHOW : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_ADDCONTROL, uTemp);

        /*
         * Show or hide controls as appropriate.  Do the icon
         * display last because it will take some time to repaint.
         * If we do it first then the dialog looks too sluggish.
         */

        int i = (lpIO->dwFlags & IOF_CHECKDISPLAYASICON) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_IO_CHANGEICON, i);
        StandardShowDlgItem(hDlg, IDC_IO_ICONDISPLAY, i);
        EnableChangeIconButton(hDlg, SW_SHOWNORMAL == i);

        // Change result display
        SetInsertObjectResults(hDlg, lpIO);

        /*
         *      For Create New, twiddle the listbox to think we selected it
         *  so it updates the icon from the object type. set the focus
         *  to the list box.
         *
         *  For Insert or Link file, set the focus to the filename button
         *  and update the icon if necessary.
         */
        if (fTemp)
        {
                UpdateClassIcon(hDlg, lpIO, GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
                SetFocus(GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST));
        }
        else
        {
                if (lpIO->fAsIconFile && (NULL != lpIO->hMetaPictFile) )
                {
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET, 0,
                                (LPARAM)lpIO->hMetaPictFile);
                        lpIO->hMetaPictFile = 0;
                }
                else
                {
                        UpdateClassIcon(hDlg, lpIO, NULL);
                }
                SetFocus(GetDlgItem(hDlg, IDC_IO_FILE));
        }

        return FALSE;
}


/*
 * UpdateClassType
 *
 * Purpose:
 *  Updates static text control to reflect current file type.  Assumes
 *  a valid filename.
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  fSet            TRUE to set the text, FALSE to explicitly clear it
 *
 * Return Value:
 *  None
 */

void UpdateClassType(HWND hDlg, LPINSERTOBJECT lpIO, BOOL fSet)
{
        LPTSTR lpszFileType = NULL;
        if (fSet)
        {
                TCHAR szFileName[MAX_PATH];
                GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);

                CLSID clsid;
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszFileName[MAX_PATH];
                LPOLESTR wszFileType = NULL;
                ATOW(wszFileName, szFileName, MAX_PATH);
                if (S_OK == GetClassFile(wszFileName, &clsid))
                        OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &wszFileType);
                if (NULL != wszFileType)
                {
                    UINT uLen = WTOALEN(wszFileType);
                    lpszFileType = (LPTSTR)OleStdMalloc(uLen);
                    if (NULL != lpszFileType)
                    {
                        WTOA(lpszFileType, wszFileType, uLen);
                    }
                    OleStdFree(wszFileType);
                }
#else
                if (S_OK == GetClassFile(szFileName, &clsid))
                        OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &lpszFileType);
#endif
        }

		if (lpszFileType != NULL)
		{
			SetDlgItemText(hDlg, IDC_IO_FILETYPE, lpszFileType);
			OleStdFree(lpszFileType);
		}
}


/*
 * UpdateClassIcon
 *
 * Purpose:
 *  Handles LBN_SELCHANGE for the Object Type listbox.  On a selection
 *  change, we extract an icon from the server handling the currently
 *  selected object type using the utility function HIconFromClass.
 *  Note that we depend on the behavior of FillClassList to stuff the
 *  object class after a tab in the listbox string that we hide from
 *  view (see WM_INITDIALOG).
 *
 * Parameters
 *  hDlg            HWND of the dialog box.
 *  lpIO            LPINSERTOBJECT pointing to the dialog structure
 *  hList           HWND of the Object Type listbox.
 *
 * Return Value:
 *  None
 */

static void UpdateClassIcon(HWND hDlg, LPINSERTOBJECT lpIO, HWND hList)
{
        // If Display as Icon is not selected, exit
        if (!(lpIO->dwFlags & IOF_CHECKDISPLAYASICON))
                return;

        /*
         * When we change object type selection, get the new icon for that
         * type into our structure and update it in the display.  We use the
         * class in the listbox when Create New is selected or the association
         * with the extension in Create From File.
         */

        DWORD cb = MAX_PATH;
        UINT iSel;
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
        {
                iSel = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);

                if (LB_ERR==(int)iSel)
                        return;

                // Check to see if we've already got the hMetaPict for this item
                LRESULT dwRet = SendMessage(hList, LB_GETITEMDATA, (WPARAM)iSel, 0L);

                HGLOBAL hMetaPict=(HGLOBAL)dwRet;
                if (hMetaPict)
                {
                        // Yep, we've already got it, so just display it and return.
                        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET,
                                0, (LPARAM)hMetaPict);
                        return;
                }
                iSel = (UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
                if (LB_ERR==(int)iSel)
                        return;

                // Allocate a string to hold the entire listbox string
                cb = (DWORD)SendMessage(hList, LB_GETTEXTLEN, iSel, 0L);
        }

        LPTSTR pszName = (LPTSTR)OleStdMalloc((cb+1)*sizeof(TCHAR));
        if (NULL == pszName)
                return;
        *pszName = 0;

        // Get the clsid we want.
        HGLOBAL hMetaPict;
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
        {
                // Grab the classname string from the list
                SendMessage(hList, LB_GETTEXT, iSel, (LPARAM)pszName);

                // Set pointer to CLSID (string)
                LPTSTR pszCLSID = PointerToNthField(pszName, 2, '\t');

                // Get CLSID from the string and then accociated icon
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
                ATOW(wszCLSID, pszCLSID, OLEUI_CCHKEYMAX);
                HRESULT hr = CLSIDFromString(wszCLSID, &lpIO->clsid);
#else
                HRESULT hr = CLSIDFromString(pszCLSID, &lpIO->clsid);
#endif
                if (FAILED(hr))
                    lpIO->clsid = GUID_NULL;
                hMetaPict = OleGetIconOfClass(lpIO->clsid, NULL, TRUE);
        }

        else
        {
                // Get the class from the filename
                GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, pszName, MAX_PATH);
#if defined(WIN32) && !defined(UNICODE)
                OLECHAR wszName[MAX_PATH];
                ATOW(wszName, pszName, MAX_PATH);
                hMetaPict = OleGetIconOfFile(wszName,
                        lpIO->dwFlags & IOF_CHECKLINK ? TRUE : FALSE);
#else
                hMetaPict = OleGetIconOfFile(pszName,
                        lpIO->dwFlags & IOF_CHECKLINK ? TRUE : FALSE);
#endif
        }

        // Replace the current display with this new one.
        SendDlgItemMessage(hDlg, IDC_IO_ICONDISPLAY, IBXM_IMAGESET,
                0, (LPARAM)hMetaPict);

        // Enable or disable "Change Icon" button depending on whether
        // we've got a valid filename or not.
        EnableChangeIconButton(hDlg, hMetaPict ? TRUE : FALSE);

        // Save the hMetaPict so that we won't have to re-create
        if (lpIO->dwFlags & IOF_SELECTCREATENEW)
                SendMessage(hList, LB_SETITEMDATA, (WPARAM)iSel, (LPARAM)hMetaPict);

        OleStdFree(pszName);
}


/*
 * SetInsertObjectResults
 *
 * Purpose:
 *  Centralizes setting of the Result and icon displays in the Insert Object
 *  dialog.  Handles loading the appropriate string from the module's
 *  resources and setting the text, displaying the proper result picture,
 *  and showing the proper icon.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box so we can access controls.
 *  lpIO            LPINSERTOBJECT in which we assume that the
 *                  current radiobutton and Display as Icon selections
 *                  are set.  We use the state of those variables to
 *                  determine which string we use.
 *
 * Return Value:
 *  None
 */

void SetInsertObjectResults(HWND hDlg, LPINSERTOBJECT lpIO)
{
        /*
         * We need scratch memory for loading the stringtable string, loading
         * the object type from the listbox, and constructing the final string.
         * We therefore allocate three buffers as large as the maximum message
         * length (512) plus the object type, guaranteeing that we have enough
         * in all cases.
         */
        UINT i = (UINT)SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETCURSEL, 0, 0L);

        UINT cch = 512;

        if (i != LB_ERR)
        {
            cch += (UINT)SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETTEXTLEN, i, 0L);
        }

        LPTSTR pszTemp= (LPTSTR)OleStdMalloc((DWORD)(4*cch)*sizeof(TCHAR));
        if (NULL == pszTemp)
                return;

        LPTSTR psz1 = pszTemp;
        LPTSTR psz2 = psz1+cch;
        LPTSTR psz3 = psz2+cch;
        LPTSTR psz4 = psz3+cch;

        BOOL fAsIcon = (0L != (lpIO->dwFlags & IOF_CHECKDISPLAYASICON));
        UINT iImage=0, iString1=0, iString2=0;

        if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
        {
                iString1 = fAsIcon ? IDS_IORESULTNEWICON : IDS_IORESULTNEW;
                iString2 = 0;
                iImage   = fAsIcon ? RESULTIMAGE_EMBEDICON : RESULTIMAGE_EMBED;
        }

        if (lpIO->dwFlags & IOF_SELECTCREATEFROMFILE)
        {
                // Pay attention to Link checkbox
                if (lpIO->dwFlags & IOF_CHECKLINK)
                {
                        iString1 = fAsIcon ? IDS_IORESULTLINKFILEICON1 : IDS_IORESULTLINKFILE1;
                        iString2 = fAsIcon ? IDS_IORESULTLINKFILEICON2 : IDS_IORESULTLINKFILE2;
                        iImage =fAsIcon ? RESULTIMAGE_LINKICON : RESULTIMAGE_LINK;
                }
                else
                {
                        iString1 = IDS_IORESULTFROMFILE1;
                        iString2 = fAsIcon ? IDS_IORESULTFROMFILEICON2 : IDS_IORESULTFROMFILE2;
                        iImage =fAsIcon ? RESULTIMAGE_EMBEDICON : RESULTIMAGE_EMBED;
                }
        }

        // Default is an empty string.
        *psz1=0;

        if (0 != LoadString(_g_hOleStdResInst, iString1, psz1, cch))
        {
                // Load second string, if necessary
                if (0 != iString2 &&
                        0 != LoadString(_g_hOleStdResInst, iString2, psz4, cch))
                {
                        lstrcat(psz1, psz4);  // concatenate strings together.
                }

                // In Create New, do the extra step of inserting the object type string
                if (lpIO->dwFlags & (IOF_SELECTCREATENEW|IOF_SELECTCREATECONTROL))
                {
                        if (i == LB_ERR)
                        {
                                SetDlgItemText(hDlg, IDC_IO_RESULTTEXT, NULL);

                                // Change the image.
                                SendDlgItemMessage(hDlg, IDC_IO_RESULTIMAGE, RIM_IMAGESET, RESULTIMAGE_NONE, 0L);

                                OleStdFree((LPVOID)pszTemp);
                                return;
                        }

                        *psz2=NULL;
                        SendDlgItemMessage(hDlg, IDC_IO_OBJECTTYPELIST, LB_GETTEXT, i, (LPARAM)psz2);

                        // Null terminate at any tab (before the classname)
                        LPTSTR pszT = psz2;
                        while (_T('\t') != *pszT && 0 != *pszT)
                                pszT++;
                        OleDbgAssert(pszT < psz3);
                        *pszT=0;

                        // Build the string and point psz1 to it.
                        wsprintf(psz3, psz1, psz2);
                        psz1 = psz3;
                }
        }

        // If LoadString failed, we simply clear out the results (*psz1=0 above)
        SetDlgItemText(hDlg, IDC_IO_RESULTTEXT, psz1);

        // Go change the image and Presto!  There you have it.
        SendDlgItemMessage(hDlg, IDC_IO_RESULTIMAGE, RIM_IMAGESET, iImage, 0L);

        OleStdFree((LPVOID)pszTemp);
}

/*
 * FValidateInsertFile
 *
 * Purpose:
 *  Given a possibly partial pathname from the file edit control,
 *  attempt to locate the file and if found, store the full path
 *  in the edit control IDC_IO_FILEDISPLAY.
 *
 * Parameters:
 *  hDlg            HWND of the dialog box.
 *  fTellUser       BOOL TRUE if function should tell user, FALSE if
 *                   function should validate silently.
 *
 * Return Value:
 *  BOOL            TRUE if the file is acceptable, FALSE otherwise.
 */

BOOL FValidateInsertFile(HWND hDlg, BOOL fTellUser, UINT FAR* lpnErrCode)
{
        *lpnErrCode = 0;

        /*
         * To validate we attempt OpenFile on the string.  If OpenFile
         * fails then we display an error.  If not, OpenFile will store
         * the complete path to that file in the OFSTRUCT which we can
         * then stuff in the edit control.
         */
        TCHAR szFile[MAX_PATH];
        if (0 == GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFile, MAX_PATH))
                return FALSE;   // #4569 : return FALSE when there is no text in ctl

        // if file is currently open (ie. sharing violation) OleCreateFromFile
        // and OleCreateLinkToFile can still succeed; do not consider it an
        // error.
        if (!DoesFileExist(szFile, MAX_PATH))
        {
           *lpnErrCode = ERROR_FILE_NOT_FOUND;
           if (fTellUser)
                   OpenFileError(hDlg, ERROR_FILE_NOT_FOUND, szFile);
           return FALSE;
        }

        // get full pathname, since the file exists
        TCHAR szPath[MAX_PATH];
        LPTSTR lpszDummy;
        GetFullPathName(szFile, sizeof(szPath)/sizeof(TCHAR), szPath, &lpszDummy);
        SetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szPath);

        return TRUE;
}


/*
 * InsertObjectCleanup
 *
 * Purpose:
 *  Clears cached icon metafiles from those stored in the listbox.
 *
 * Parameters:
 *  hDlg            HWND of the dialog.
 *
 * Return Value:
 *  None
 */

void InsertObjectCleanup(HWND hDlg)
{
        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
        UINT iItems= (UINT)SendMessage(hList, LB_GETCOUNT, 0, 0L);
        for (UINT i = 0; i < iItems; i++)
        {
                LRESULT dwRet = SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                HGLOBAL hMetaPict=(HGLOBAL)dwRet;
                if (hMetaPict)
                        OleUIMetafilePictIconFree(hMetaPict);
        }
}

void EnableChangeIconButton(HWND hDlg, BOOL fEnable)
{

    HRESULT hr = S_OK;

    if(fEnable){

        HWND hList = GetDlgItem(hDlg, IDC_IO_OBJECTTYPELIST);
        int iCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);

        CLSID clsid = {0};

        if (1 == IsDlgButtonChecked(hDlg, IDC_IO_CREATENEW))
        {
            LPTSTR pszString = (LPTSTR)OleStdMalloc(
                OLEUI_CCHKEYMAX_SIZE + OLEUI_CCHCLSIDSTRING_SIZE);

            if(NULL == pszString)
            { 
                fEnable = FALSE;
                goto CLEANUP;
            }
            
            SendMessage(hList, LB_GETTEXT, iCurSel, (LPARAM)pszString);

            if(0 == *pszString)
            { 
                fEnable = FALSE;
                OleStdFree((LPVOID)pszString);
                goto CLEANUP;
            }

            
            LPTSTR pszCLSID = PointerToNthField(pszString, 2, '\t');

            if(NULL == pszCLSID || 0 == *pszCLSID)
            { 
                fEnable = FALSE;
                OleStdFree((LPVOID)pszString);
                goto CLEANUP;
            }

            
#if defined(WIN32) && !defined(UNICODE)
            OLECHAR wszCLSID[OLEUI_CCHKEYMAX];
            ATOW(wszCLSID, pszCLSID, OLEUI_CCHKEYMAX);

            
            hr = CLSIDFromString(wszCLSID, &clsid);
#else
            hr = CLSIDFromString(pszCLSID, &clsid);
#endif
            OleStdFree((LPVOID)pszString);

            if(FAILED(hr))
            {
                fEnable = FALSE;
            }
        }
        else  // IOF_SELECTCREATEFROMFILE
        {
            TCHAR  szFileName[MAX_PATH] = {0};
            GetDlgItemText(hDlg, IDC_IO_FILEDISPLAY, szFileName, MAX_PATH);
            
#if defined(WIN32) && !defined(UNICODE)

            OLECHAR wszFileName[MAX_PATH] = {0};
            ATOW(wszFileName, szFileName, MAX_PATH);

            if (S_OK != GetClassFile(wszFileName, &clsid))
#else
                if (S_OK != GetClassFile(szFileName, &clsid))
#endif
                {
                    int istrlen = lstrlen(szFileName);
                    LPTSTR lpszExtension = szFileName + istrlen -1;

                    while (lpszExtension > szFileName &&
                           *lpszExtension != '.')
                    {
                        lpszExtension = CharPrev(szFileName, lpszExtension);
                    }

                    *szFileName = 0;

                    GetAssociatedExecutable(lpszExtension, szFileName);

                    if(0 == *szFileName){ 
                        fEnable = FALSE;
                    }
                }
        }
    }

CLEANUP:

    StandardEnableDlgItem(hDlg, IDC_IO_CHANGEICON, fEnable);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\resimage.h ===
/*
 * RESIMAGE.H
 *
 * Structures and definitions for the ResultImage control.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _RESIMAGE_H_
#define _RESIMAGE_H_

/*
 * Indices into the bitmaps to extract the right image.  Each bitmap
 * contains five images arranged vertically, so the offset to the correct
 * image is (iImage*cy)
 */

#define RESULTIMAGE_NONE                0xFFFF
#define RESULTIMAGE_PASTE               0
#define RESULTIMAGE_EMBED               1
#define RESULTIMAGE_EMBEDICON           2
#define RESULTIMAGE_LINK                3
#define RESULTIMAGE_LINKICON            4
#define RESULTIMAGE_LINKTOLINK          5
#define RESULTIMAGE_LINKTOLINKICON      6
#define RESULTIMAGE_EDITABLE                    7

#define RESULTIMAGE_MIN                 0
#define RESULTIMAGE_MAX                 7

// Total number of images in each bitmap.
#define CIMAGESX                                           (RESULTIMAGE_MAX+1)

// The color to use for transparancy (cyan)
#define RGBTRANSPARENT                  RGB(0, 255, 255)

// Function prototypes
LRESULT CALLBACK ResultImageWndProc(HWND, UINT, WPARAM, LPARAM);

BOOL FResultImageInitialize(HINSTANCE, HINSTANCE);
void ResultImageUninitialize(void);
void TransparentBlt(HDC, UINT, UINT, HBITMAP, UINT, UINT, UINT, UINT, COLORREF);

// Window extra bytes contain the bitmap index we deal with currently.
#define CBRESULTIMAGEWNDEXTRA          sizeof(UINT)
#define RIWW_IMAGEINDEX                0

// Control messages
#define RIM_IMAGESET                   (WM_USER+0)
#define RIM_IMAGEGET                   (WM_USER+1)

// Special ROP code for TransparentBlt.
#define ROP_DSPDxax  0x00E20746

#endif //_RESIMAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\precomp.h ===
/*
 * PRECOMP.H
 *
 * This file is used to precompile the OLEDLG.H header file
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

// only STRICT compiles are supported
#ifndef STRICT
#define STRICT
#endif

#include "oledlg.h"
#include "olestd.h"
#include "resource.h"
#include "commctrl.h"
#ifndef WM_NOTIFY

// WM_NOTIFY is new in later versions of Win32
#define WM_NOTIFY 0x004e
typedef struct tagNMHDR
{
        HWND hwndFrom;
        UINT idFrom;
        UINT code;
} NMHDR;
#endif  //!WM_NOTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\pastespl.cpp ===
/*
 * PASTESPL.CPP
 *
 * Implements the OleUIPasteSpecial function which invokes the complete
 * Paste Special dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Rights Reserved
 */

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"
#include <stdlib.h>

OLEDBGDATA

// Length of buffers to hold the strings 'Unknown Type', Unknown Source'
//   and 'the application which created it'
// Extra long to allow room for localization.
#define PS_UNKNOWNSTRLEN               200
#define PS_UNKNOWNNAMELEN              256

// Property label used to store clipboard viewer chain information
#define NEXTCBVIEWER        TEXT("NextCBViewer")

// Internally used structure
typedef struct tagPASTESPECIAL
{
        // Keep this item first as the Standard* functions depend on it here.
        LPOLEUIPASTESPECIAL  lpOPS;                //Original structure passed.
        UINT            nIDD;   // IDD of dialog (used for help info)

        /*
         * What we store extra in this structure besides the original caller's
         * pointer are those fields that we need to modify during the life of
         * the dialog but that we don't want to change in the original structure
         * until the user presses OK.
         */

        DWORD                dwFlags;              // Local copy of paste special flags

        int                  nPasteListCurSel;     // Save the selection the user made last
        int                  nPasteLinkListCurSel; //    in the paste and pastelink lists
        int                  nSelectedIndex;       // Index in arrPasteEntries[] corresponding to user selection
        BOOL                 fLink;                // Indicates if Paste or PasteLink was selected by user

        HGLOBAL              hBuff;                // Scratch Buffer for building up strings
        TCHAR                szUnknownType[PS_UNKNOWNSTRLEN];    // Buffer for 'Unknown Type' string
        TCHAR                szUnknownSource[PS_UNKNOWNSTRLEN];  // Buffer for 'Unknown Source' string
        TCHAR                szAppName[OLEUI_CCHKEYMAX]; // Application name of Source. Used in the result text
                                                                                                         //   when Paste is selected. Obtained using clsidOD.

        // Information obtained from OBJECTDESCRIPTOR. This information is accessed when the Paste
        //    radio button is selected.
        CLSID                clsidOD;              // ClassID of source
        SIZEL                sizelOD;              // sizel transfered in
                                                                                           //  ObjectDescriptor
        TCHAR                szFullUserTypeNameOD[PS_UNKNOWNNAMELEN]; // Full User Type Name
        TCHAR                szSourceOfDataOD[PS_UNKNOWNNAMELEN];     // Source of Data
        BOOL                 fSrcAspectIconOD;     // Does Source specify DVASPECT_ICON?
        BOOL                 fSrcOnlyIconicOD;     // Does Source specify OLEMISC_ONLYICONIC?
        HGLOBAL              hMetaPictOD;          // Metafile containing icon and icon title
        HGLOBAL              hObjDesc;             // Handle to OBJECTDESCRIPTOR structure from which the
                                                                                           //   above information is obtained

        // Information obtained from LINKSRCDESCRIPTOR. This infomation is accessed when the PasteLink
        //   radio button is selected.
        CLSID                clsidLSD;             // ClassID of source
        SIZEL                sizelLSD;             // sizel transfered in
                                                                                           //  LinkSrcDescriptor
        TCHAR                szFullUserTypeNameLSD[PS_UNKNOWNNAMELEN];// Full User Type Name
        TCHAR                szSourceOfDataLSD[PS_UNKNOWNNAMELEN];    // Source of Data
        BOOL                 fSrcAspectIconLSD;    // Does Source specify DVASPECT_ICON?
        BOOL                 fSrcOnlyIconicLSD;    // Does Source specify OLEMISC_ONLYICONIC?
        HGLOBAL              hMetaPictLSD;         // Metafile containing icon and icon title
        HGLOBAL              hLinkSrcDesc;         // Handle to LINKSRCDESCRIPTOR structure from which the
                                                                                           //   above information is obtained

        BOOL                 fClipboardChanged;    // Has clipboard content changed
                                                                                           //   if so bring down dlg after
                                                                                           //   ChangeIcon dlg returns.
} PASTESPECIAL, *PPASTESPECIAL, FAR *LPPASTESPECIAL;

// Data corresponding to each list item. A pointer to this structure is attached to each
//   Paste\PasteLink list box item using LB_SETITEMDATA
typedef struct tagPASTELISTITEMDATA
{
   int                   nPasteEntriesIndex;   // Index of arrPasteEntries[] corresponding to list item
   BOOL                  fCntrEnableIcon;      // Does calling application (called container here)
                                                                                           //    specify OLEUIPASTE_ENABLEICON for this item?
} PASTELISTITEMDATA, *PPASTELISTITEMDATA, FAR *LPPASTELISTITEMDATA;

// Internal function prototypes
// PASTESPL.CPP
INT_PTR CALLBACK PasteSpecialDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL FPasteSpecialInit(HWND hDlg, WPARAM, LPARAM);
BOOL FTogglePasteType(HWND, LPPASTESPECIAL, DWORD);
void ChangeListSelection(HWND, LPPASTESPECIAL, HWND);
void EnableDisplayAsIcon(HWND, LPPASTESPECIAL);
void ToggleDisplayAsIcon(HWND, LPPASTESPECIAL);
void ChangeIcon(HWND, LPPASTESPECIAL);
void SetPasteSpecialHelpResults(HWND, LPPASTESPECIAL);
BOOL FAddPasteListItem(HWND, BOOL, int, LPPASTESPECIAL, LPTSTR, LPTSTR);
BOOL FFillPasteList(HWND, LPPASTESPECIAL);
BOOL FFillPasteLinkList(HWND, LPPASTESPECIAL);
BOOL FHasPercentS(LPCTSTR, LPPASTESPECIAL);
HGLOBAL AllocateScratchMem(LPPASTESPECIAL);
void FreeListData(HWND);
BOOL FPasteSpecialReInit(HWND hDlg, LPPASTESPECIAL lpPS);

/*
 * OleUIPasteSpecial
 *
 * Purpose:
 *  Invokes the standard OLE Paste Special dialog box which allows the user
 *  to select the format of the clipboard object to be pasted or paste linked.
 *
 * Parameters:
 *  lpPS         LPOLEUIPasteSpecial pointing to the in-out structure
 *               for this dialog.
 *
 * Return Value:
 *  UINT        One of the following codes or one of the standard error codes (OLEUI_ERR_*)
 *              defined in OLEDLG.H, indicating success or error:
 *              OLEUI_OK                           User selected OK
 *              OLEUI_CANCEL                       User cancelled the dialog
 *              OLEUI_IOERR_SRCDATAOBJECTINVALID   lpSrcDataObject field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRPASTEENTRIESINVALID arrPasteEntries field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRLINKTYPESINVALID    arrLinkTypes field of OLEUIPASTESPECIAL invalid
 *              OLEUI_PSERR_CLIPBOARDCHANGED       Clipboard contents changed while dialog was up
 */
STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL lpPS)
{
        UINT        uRet;
        HGLOBAL     hMemDlg=NULL;

        uRet = UStandardValidation((LPOLEUISTANDARD)lpPS, sizeof(OLEUIPASTESPECIAL),
                &hMemDlg);

        if (uRet != OLEUI_SUCCESS)
                return uRet;

        // Validate PasteSpecial specific fields
        if (NULL != lpPS->lpSrcDataObj && IsBadReadPtr(lpPS->lpSrcDataObj,  sizeof(IDataObject)))
        {
                uRet = OLEUI_IOERR_SRCDATAOBJECTINVALID;
        }
        if (NULL == lpPS->arrPasteEntries ||
                IsBadReadPtr(lpPS->arrPasteEntries,  lpPS->cPasteEntries * sizeof(OLEUIPASTEENTRY)))
        {
                uRet = OLEUI_IOERR_ARRPASTEENTRIESINVALID;
        }
        if (0 > lpPS->cLinkTypes || lpPS->cLinkTypes > PS_MAXLINKTYPES ||
                IsBadReadPtr(lpPS->arrLinkTypes, lpPS->cLinkTypes * sizeof(UINT)))
        {
                uRet = OLEUI_IOERR_ARRLINKTYPESINVALID;
        }

        if (0 != lpPS->cClsidExclude &&
                IsBadReadPtr(lpPS->lpClsidExclude, lpPS->cClsidExclude * sizeof(CLSID)))
        {
                uRet = OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

        // If IDataObject passed is NULL, collect it from the clipboard
        if (NULL == lpPS->lpSrcDataObj)
        {
                if (OleGetClipboard(&lpPS->lpSrcDataObj) != NOERROR)
                        uRet = OLEUI_PSERR_GETCLIPBOARDFAILED;

                if (NULL == lpPS->lpSrcDataObj)
                        uRet = OLEUI_PSERR_GETCLIPBOARDFAILED;
        }

        if (uRet >= OLEUI_ERR_STANDARDMIN)
        {
                return uRet;
        }

        UINT nIDD = bWin4 ? IDD_PASTESPECIAL4 : IDD_PASTESPECIAL;

        //Now that we've validated everything, we can invoke the dialog.
        uRet = UStandardInvocation(PasteSpecialDialogProc, (LPOLEUISTANDARD)lpPS,
                hMemDlg, MAKEINTRESOURCE(nIDD));

        return uRet;
}

/*
 * PasteSpecialDialogProc
 *
 * Purpose:
 *  Implements the OLE Paste Special dialog as invoked through the
 *  OleUIPasteSpecial function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */
INT_PTR CALLBACK PasteSpecialDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
        // Declare Win16/Win32 compatible WM_COMMAND parameters.
        COMMANDPARAMS(wID, wCode, hWndMsg);

        // This will fail under WM_INITDIALOG, where we allocate it.
        UINT fHook = FALSE;
        LPPASTESPECIAL lpPS = (LPPASTESPECIAL)LpvStandardEntry(
                hDlg, iMsg, wParam, lParam, &fHook);
        LPOLEUIPASTESPECIAL lpOPS = NULL;
        if (lpPS != NULL)
                lpOPS = lpPS->lpOPS;

        //If the hook processed the message, we're done.
        if (0!=fHook)
                return (INT_PTR)fHook;

        // Process help message from Change Icon
        if (iMsg == uMsgHelp)
        {
			    // if lPS is NULL (in low memory situations, just ignore it.
                if (lpPS != NULL)
				{
                    PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp, wParam, lParam);
				}
                return FALSE;
        }

        //Process the temination message
        if (iMsg == uMsgEndDialog)
        {
                EndDialog(hDlg, wParam);
                return TRUE;
        }

        switch (iMsg)
        {
            case WM_DESTROY:
                    if (lpPS)
                    {
                    HWND    hwndNextViewer;

                    // Free the icon/icon-title metafile corresponding to Paste/PasteList option which is not selected
                    if (lpPS->fLink)
                            OleUIMetafilePictIconFree(lpPS->hMetaPictOD);
                    else
                            OleUIMetafilePictIconFree(lpPS->hMetaPictLSD);

                    // Free data associated with each list box entry
                    FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELIST));
                    FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELINKLIST));

                    //Free any specific allocations before calling StandardCleanup
                    if (lpPS->hObjDesc) GlobalFree(lpPS->hObjDesc);
                    if (lpPS->hLinkSrcDesc) GlobalFree(lpPS->hLinkSrcDesc);
                    if (lpPS->hBuff)
                        {
                            GlobalFree(lpPS->hBuff);
                            lpPS->hBuff = NULL;
                        }

                    // Change the clipboard notification chain
                    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                    if (hwndNextViewer != HWND_BROADCAST)
                    {
                            SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
                            ChangeClipboardChain(hDlg, hwndNextViewer);
                    }
                    RemoveProp(hDlg, NEXTCBVIEWER);

                    StandardCleanup(lpPS, hDlg);
                    }
                    break;
                case WM_INITDIALOG:
                        FPasteSpecialInit(hDlg, wParam, lParam);
                        return FALSE;

                case WM_DRAWCLIPBOARD:
                        {
                                HWND    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                HWND    hDlg_ChgIcon;

                                if (hwndNextViewer == HWND_BROADCAST)
                                        break;

                                if (hwndNextViewer)
                                {
                                        SendMessage(hwndNextViewer, iMsg, wParam, lParam);
                                        // Refresh next viewer in case it got modified
                                        //    by the SendMessage() (likely if multiple
                                        //    PasteSpecial dialogs are up simultaneously)
                                        hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                }

                                if (!(lpPS->dwFlags & PSF_STAYONCLIPBOARDCHANGE))
                                {
                                        SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
                                        ChangeClipboardChain(hDlg, hwndNextViewer);

                                        /* OLE2NOTE: if the ChangeIcon dialog is currently up, then
                                        **    we need to defer bringing down PasteSpecial dialog
                                        **    until after ChangeIcon dialog returns. if the
                                        **    ChangeIcon dialog is NOT up, then we can bring down
                                        **    the PasteSpecial dialog immediately.
                                        */
                                        if ((hDlg_ChgIcon=(HWND)GetProp(hDlg,PROP_HWND_CHGICONDLG))!=NULL)
                                        {
                                                // ChangeIcon dialog is UP
                                                lpPS->fClipboardChanged = TRUE;
                                        }
                                        else
                                        {
                                                // ChangeIcon dialog is NOT up

                                                //  Free icon and icon title metafile
                                                SendDlgItemMessage(
                                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);
                                                SendMessage(
                                                                hDlg, uMsgEndDialog, OLEUI_PSERR_CLIPBOARDCHANGED,0L);
                                        }
                                }
                                else
                                {
                                        // skip refresh, ignoring clipboard change if PSF_NOREFRESHDATAOBJECT
                                        if (lpPS->dwFlags & PSF_NOREFRESHDATAOBJECT)
                                                break;

                                        // release current data object
                                        if (lpOPS->lpSrcDataObj != NULL)
                                        {
                                                lpOPS->lpSrcDataObj->Release();
                                                lpOPS->lpSrcDataObj = NULL;
                                        }

                                        // obtain new one
                                        if (OleGetClipboard(&lpOPS->lpSrcDataObj) != NOERROR)
                                        {
                                                SendMessage(hDlg, uMsgEndDialog, OLEUI_PSERR_GETCLIPBOARDFAILED, 0);
                                                break;
                                        }

                                        // otherwise update the display to the new clipboard object
                                        FPasteSpecialReInit(hDlg, lpPS);
                                }
                        }
                        break;

                case WM_CHANGECBCHAIN:
                        {
                                HWND    hwndNextViewer = (HWND)GetProp(hDlg, NEXTCBVIEWER);
                                if ((HWND)wParam == hwndNextViewer)
                                        SetProp(hDlg, NEXTCBVIEWER, (hwndNextViewer = (HWND)lParam));
                                else if (hwndNextViewer && hwndNextViewer != HWND_BROADCAST)
                                        SendMessage(hwndNextViewer, iMsg, wParam, lParam);
                        }
                        break;

                case WM_COMMAND:
                        switch (wID)
                        {
                        case IDC_PS_PASTE:
                                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
                                break;

                        case IDC_PS_PASTELINK:
                                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
                                break;

                        case IDC_PS_DISPLAYLIST:
                                switch (wCode)
                                {
                                case LBN_SELCHANGE:
                                        ChangeListSelection(hDlg, lpPS, hWndMsg);
                                        break;
                                case LBN_DBLCLK:
                                        // Same as pressing OK
                                        if (IsWindowEnabled(GetDlgItem(hDlg, IDOK)))
                                                SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                                        break;
                                }
                                break;

                        case IDC_PS_DISPLAYASICON:
                                ToggleDisplayAsIcon(hDlg, lpPS);
                                break;

                        case IDC_PS_CHANGEICON:
                                ChangeIcon(hDlg, lpPS);
                                if (lpPS->fClipboardChanged)
                                {
                                        // Free icon and icon title metafile
                                        SendDlgItemMessage(
                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE,0,0L);
                                        SendMessage(hDlg, uMsgEndDialog,
                                                OLEUI_PSERR_CLIPBOARDCHANGED, 0L);
                                }
                                break;

                        case IDOK:
                                {
                                        BOOL fDestAspectIcon =
                                                        ((lpPS->dwFlags & PSF_CHECKDISPLAYASICON) ?
                                                                        TRUE : FALSE);
                                        // Return current flags
                                        lpOPS->dwFlags = lpPS->dwFlags;
                                        // Return index of arrPasteEntries[] corresponding to format selected by user
                                        lpOPS->nSelectedIndex = lpPS->nSelectedIndex;
                                        // Return if user selected Paste or PasteLink
                                        lpOPS->fLink = lpPS->fLink;

                                        /* if user selected same ASPECT as displayed in the
                                        **    source, then sizel passed in the
                                        **    ObjectDescriptor/LinkSrcDescriptor is
                                        **    applicable. otherwise, the sizel does not apply.
                                        */
                                        if (lpPS->fLink)
                                        {
                                                if (lpPS->fSrcAspectIconLSD == fDestAspectIcon)
                                                        lpOPS->sizel = lpPS->sizelLSD;
                                                else
                                                        lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                                        }
                                        else
                                        {
                                                if (lpPS->fSrcAspectIconOD == fDestAspectIcon)
                                                        lpOPS->sizel = lpPS->sizelOD;
                                                else
                                                        lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                                        }
                                        // Return metafile with icon and icon title that the user selected
                                        lpOPS->hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg,
                                                IDC_PS_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
                                        SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                                }
                                break;

                        case IDCANCEL:
                                // Free icon and icon title metafile
                                SendDlgItemMessage(
                                                hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);
                                SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                                break;

                        case IDC_OLEUIHELP:
                                PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp,
                                        (WPARAM)hDlg, MAKELPARAM(IDD_PASTESPECIAL, 0));
                                break;
                        }
                        break;
        }
        return FALSE;
}

BOOL FPasteSpecialReInit(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;

        // free the icon/icon-title metafiel
        if (lpPS->fLink)
                OleUIMetafilePictIconFree(lpPS->hMetaPictOD);
        else
                OleUIMetafilePictIconFree(lpPS->hMetaPictLSD);

        // Free data assocatiated with each list box entry
        FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELIST));
        FreeListData(GetDlgItem(hDlg, IDC_PS_PASTELINKLIST));
        SendDlgItemMessage(hDlg, IDC_PS_DISPLAYLIST, LB_RESETCONTENT, 0, 0);

        // Initialize user selections in the Paste and PasteLink listboxes
        lpPS->nPasteListCurSel = 0;
        lpPS->nPasteLinkListCurSel = 0;

        // Free previous object descriptor/link descriptor data
        if (lpPS->hObjDesc != NULL)
        {
                GlobalFree(lpPS->hObjDesc);
                lpPS->hObjDesc = NULL;
        }
        if (lpPS->hLinkSrcDesc != NULL)
        {
                GlobalFree(lpPS->hLinkSrcDesc);
                lpPS->hLinkSrcDesc = NULL;
        }

        lpPS->szAppName[0] = '\0';

        // GetData CF_OBJECTDESCRIPTOR. If the object on the clipboard in an
        // OLE1 object (offering CF_OWNERLINK) or has been copied to
        // clipboard by FileMaager (offering CF_FILENAME), an
        // OBJECTDESCRIPTOR will be created will be created from CF_OWNERLINK
        // or CF_FILENAME. See OBJECTDESCRIPTOR for more info.

        STGMEDIUM medium;
        CLIPFORMAT cfFormat;
        lpPS->hObjDesc = OleStdFillObjectDescriptorFromData(
                lpOPS->lpSrcDataObj, &medium, &cfFormat);
        if (lpPS->hObjDesc)
        {
                LPOBJECTDESCRIPTOR lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(lpPS->hObjDesc);

                // Get FullUserTypeName, SourceOfCopy and CLSID
                if (lpOD->dwFullUserTypeName)
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpPS->szFullUserTypeNameOD, (LPWSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
#else
                        lstrcpyn(lpPS->szFullUserTypeNameOD, (LPTSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
#endif
                else
                        lstrcpyn(lpPS->szFullUserTypeNameOD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);

                if (lpOD->dwSrcOfCopy)
                {
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpPS->szSourceOfDataOD, (LPWSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
#else
                        lstrcpyn(lpPS->szSourceOfDataOD, (LPTSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
#endif
                        // If CF_FILENAME was offered, source of copy is a
                        // path name. Fit the path to the static control that will display it.
                        if (cfFormat == _g_cfFileName)
                        {
                                lstrcpyn(lpPS->szSourceOfDataOD, ChopText(GetDlgItem(hDlg, IDC_PS_SOURCETEXT), 0,
                                        lpPS->szSourceOfDataOD, 0), PS_UNKNOWNNAMELEN);
                        }
                }
                else
                        lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);

                lpPS->clsidOD = lpOD->clsid;
                lpPS->sizelOD = lpOD->sizel;

                // Does source specify DVASPECT_ICON?
                if (lpOD->dwDrawAspect & DVASPECT_ICON)
                        lpPS->fSrcAspectIconOD = TRUE;
                else
                        lpPS->fSrcAspectIconOD = FALSE;

                // Does source specify OLEMISC_ONLYICONIC?
                if (lpOD->dwStatus & OLEMISC_ONLYICONIC)
                        lpPS->fSrcOnlyIconicOD = TRUE;
                else
                        lpPS->fSrcOnlyIconicOD = FALSE;

                // Get application name of source from auxusertype3 in the registration database
                LPOLESTR lpszAppName = NULL;
                if (OleRegGetUserType(lpPS->clsidOD, USERCLASSTYPE_APPNAME,
                        &lpszAppName) == NOERROR)
                {
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpPS->szAppName, lpszAppName, OLEUI_CCHKEYMAX);
#else
                        lstrcpyn(lpPS->szAppName, lpszAppName, OLEUI_CCHKEYMAX);
#endif
                        OleStdFree(lpszAppName);
                }
                else
                {
                         if (0 == LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNAPP, lpPS->szAppName,
                                PS_UNKNOWNSTRLEN))
                         {
                                 PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                                 return FALSE;
                         }
                }

                // Retrieve an icon from the object
                if (lpPS->fSrcAspectIconOD)
                {
                        lpPS->hMetaPictOD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                (CLIPFORMAT) CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );

                }
                // If object does not offer icon, obtain it from the CLSID
                if (NULL == lpPS->hMetaPictOD)
                        lpPS->hMetaPictOD = OleGetIconOfClass(lpPS->clsidOD, NULL, TRUE);
        }

        // Does object offer CF_LINKSRCDESCRIPTOR?
        lpPS->hLinkSrcDesc = OleStdGetData(
                        lpOPS->lpSrcDataObj,
                        (CLIPFORMAT) _g_cfLinkSrcDescriptor,
                        NULL,
                        DVASPECT_CONTENT,
                        &medium);
        if (lpPS->hLinkSrcDesc)
        {
                // Get FullUserTypeName, SourceOfCopy and CLSID
                LPLINKSRCDESCRIPTOR lpLSD = (LPLINKSRCDESCRIPTOR)GlobalLock(lpPS->hLinkSrcDesc);
                if (lpLSD->dwFullUserTypeName)
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpPS->szFullUserTypeNameLSD, (LPWSTR)((LPBYTE)lpLSD+lpLSD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
#else
                        lstrcpyn(lpPS->szFullUserTypeNameLSD, (LPTSTR)((LPBYTE)lpLSD+lpLSD->dwFullUserTypeName), PS_UNKNOWNNAMELEN);
#endif
                else
                        lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);

                if (lpLSD->dwSrcOfCopy)
#if defined(WIN32) && !defined(UNICODE)
                        WTOA(lpPS->szSourceOfDataLSD, (LPWSTR)((LPBYTE)lpLSD+lpLSD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
#else
                        lstrcpyn(lpPS->szSourceOfDataLSD, (LPTSTR)((LPBYTE)lpLSD+lpLSD->dwSrcOfCopy), PS_UNKNOWNNAMELEN);
#endif
                else
                        lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);

                // if no ObjectDescriptor, then use LinkSourceDescriptor source string
                if (!lpPS->hObjDesc)
                        lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szSourceOfDataLSD, PS_UNKNOWNNAMELEN);

                lpPS->clsidLSD = lpLSD->clsid;
                lpPS->sizelLSD = lpLSD->sizel;

                // Does source specify DVASPECT_ICON?
                if (lpLSD->dwDrawAspect & DVASPECT_ICON)
                        lpPS->fSrcAspectIconLSD = TRUE;
                else
                        lpPS->fSrcAspectIconLSD = FALSE;

                // Does source specify OLEMISC_ONLYICONIC?
                if (lpLSD->dwStatus & OLEMISC_ONLYICONIC)
                        lpPS->fSrcOnlyIconicLSD = TRUE;
                else
                        lpPS->fSrcOnlyIconicLSD = FALSE;

                // Retrieve an icon from the object
                if (lpPS->fSrcAspectIconLSD)
                {
                        lpPS->hMetaPictLSD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );
                }
                // If object does not offer icon, obtain it from the CLSID
                if (NULL == lpPS->hMetaPictLSD)
                {
                        HWND hIconWnd = GetDlgItem(hDlg, IDC_PS_ICONDISPLAY);
                        RECT IconRect; GetClientRect(hIconWnd, &IconRect);

                        LPTSTR lpszLabel = OleStdCopyString(lpPS->szSourceOfDataLSD);
                        // width is 2 times width of iconbox because it can wrap
                        int nWidth = (IconRect.right-IconRect.left) * 2;
                        // limit text to the width or max characters
                        LPTSTR lpszChopLabel = ChopText(hIconWnd, nWidth, lpszLabel,
                                lstrlen(lpszLabel));
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszChopLabel[MAX_PATH];
                        ATOW(wszChopLabel, lpszChopLabel, MAX_PATH);
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, wszChopLabel, FALSE);
#else
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, lpszChopLabel, FALSE);
#endif
                        OleStdFree(lpszLabel);
                }
        }
        else if (lpPS->hObjDesc)     // Does not offer CF_LINKSRCDESCRIPTOR but offers CF_OBJECTDESCRIPTOR
        {
                // Copy the values of OBJECTDESCRIPTOR
                lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szFullUserTypeNameOD, PS_UNKNOWNNAMELEN);
                lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szSourceOfDataOD, PS_UNKNOWNNAMELEN);
                lpPS->clsidLSD = lpPS->clsidOD;
                lpPS->sizelLSD = lpPS->sizelOD;
                lpPS->fSrcAspectIconLSD = lpPS->fSrcAspectIconOD;
                lpPS->fSrcOnlyIconicLSD = lpPS->fSrcOnlyIconicOD;

                // Don't copy the hMetaPict; instead get a separate copy
                if (lpPS->fSrcAspectIconLSD)
                {
                        lpPS->hMetaPictLSD = OleStdGetData(
                                lpOPS->lpSrcDataObj,
                                CF_METAFILEPICT,
                                NULL,
                                DVASPECT_ICON,
                                &medium
                        );
                }
                if (NULL == lpPS->hMetaPictLSD)
                {
                        HWND hIconWnd = GetDlgItem(hDlg, IDC_PS_ICONDISPLAY);
                        RECT IconRect; GetClientRect(hIconWnd, &IconRect);

                        LPTSTR lpszLabel = OleStdCopyString(lpPS->szSourceOfDataLSD);
                        // width is 2 times width of iconbox because it can wrap
                        int nWidth = (IconRect.right-IconRect.left) * 2;
                        // limit text to the width or max characters
                        LPTSTR lpszChopLabel = ChopText(hIconWnd, nWidth, lpszLabel,
                                lstrlen(lpszLabel));
#if defined(WIN32) && !defined(UNICODE)
                        OLECHAR wszChopLabel[MAX_PATH];
                        ATOW(wszChopLabel, lpszChopLabel, MAX_PATH);
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, wszChopLabel, FALSE);
#else
                        lpPS->hMetaPictLSD =
                                OleGetIconOfClass(lpPS->clsidLSD, lpszChopLabel, FALSE);
#endif
                        OleStdFree(lpszLabel);
                }
        }

        // Not an OLE object
        if (lpPS->hObjDesc == NULL && lpPS->hLinkSrcDesc == NULL)
        {
                 lstrcpyn(lpPS->szFullUserTypeNameLSD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szFullUserTypeNameOD, lpPS->szUnknownType, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szSourceOfDataLSD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);
                 lstrcpyn(lpPS->szSourceOfDataOD, lpPS->szUnknownSource, PS_UNKNOWNNAMELEN);
                 lpPS->hMetaPictLSD = lpPS->hMetaPictOD = NULL;
        }

        // Allocate scratch memory to construct item names in the paste and pastelink listboxes
        if (lpPS->hBuff != NULL)
        {
                GlobalFree(lpPS->hBuff);
                lpPS->hBuff = NULL;
        }

        lpPS->hBuff = AllocateScratchMem(lpPS);
        if (lpPS->hBuff == NULL)
        {
           PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
           return FALSE;
        }

        // Select the Paste Link Button if specified. Otherwise select
        //      Paste Button by default
        if (lpPS->dwFlags & PSF_SELECTPASTELINK)
                lpPS->dwFlags = (lpPS->dwFlags & ~PSF_SELECTPASTE) | PSF_SELECTPASTELINK;
        else
                lpPS->dwFlags =(lpPS->dwFlags & ~PSF_SELECTPASTELINK) | PSF_SELECTPASTE;

        // Mark which PasteEntry formats are available from source data object
        OleStdMarkPasteEntryList(
                        lpOPS->lpSrcDataObj, lpOPS->arrPasteEntries, lpOPS->cPasteEntries);

        // Check if items are available to be pasted
        BOOL fPasteAvailable = FFillPasteList(hDlg, lpPS);
        if (!fPasteAvailable)
                lpPS->dwFlags &= ~PSF_SELECTPASTE;
        StandardEnableDlgItem(hDlg, IDC_PS_PASTE, fPasteAvailable);

        // Check if items are available to be paste-linked
        BOOL fPasteLinkAvailable = FFillPasteLinkList(hDlg, lpPS);
        if (!fPasteLinkAvailable)
                lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
        StandardEnableDlgItem(hDlg, IDC_PS_PASTELINK, fPasteLinkAvailable);

        // If one of Paste or PasteLink is disabled, select the other one
        //    regardless of what the input flags say
        if (fPasteAvailable && !fPasteLinkAvailable)
                lpPS->dwFlags |= PSF_SELECTPASTE;
        if (fPasteLinkAvailable && !fPasteAvailable)
                lpPS->dwFlags |= PSF_SELECTPASTELINK;

        BOOL bEnabled = TRUE;
        if (lpPS->dwFlags & PSF_SELECTPASTE)
        {
                // FTogglePaste will set the PSF_SELECTPASTE flag, so clear it.
                lpPS->dwFlags &= ~PSF_SELECTPASTE;
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, IDC_PS_PASTE);
                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
        }
        else if (lpPS->dwFlags & PSF_SELECTPASTELINK)
        {
                // FTogglePaste will set the PSF_SELECTPASTELINK flag, so clear it.
                lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, IDC_PS_PASTELINK);
                FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
        }
        else  // Items are not available to be be Pasted or Paste-Linked
        {
                // Enable or disable DisplayAsIcon and set the result text and image
                EnableDisplayAsIcon(hDlg, lpPS);
                SetPasteSpecialHelpResults(hDlg, lpPS);
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataOD);
                CheckRadioButton(hDlg, IDC_PS_PASTE, IDC_PS_PASTELINK, 0);
                bEnabled = FALSE;
        }
        StandardEnableDlgItem(hDlg, IDOK, bEnabled);

        return TRUE;
}

/*
 * FPasteSpecialInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Paste Special dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */
BOOL FPasteSpecialInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
        // Copy the structure at lParam into our instance memory.
        HFONT hFont;
        LPPASTESPECIAL lpPS = (LPPASTESPECIAL)LpvStandardInit(hDlg, sizeof(PASTESPECIAL), &hFont);

        // PvStandardInit sent a termination to us already.
        if (NULL == lpPS)
                return FALSE;

        LPOLEUIPASTESPECIAL lpOPS = (LPOLEUIPASTESPECIAL)lParam;

        // Copy other information from lpOPS that we might modify.
        lpPS->lpOPS = lpOPS;
        lpPS->nIDD = IDD_PASTESPECIAL;
        lpPS->dwFlags = lpOPS->dwFlags;

        // If we got a font, send it to the necessary controls.
        if (NULL!=hFont)
        {
                SendDlgItemMessage(hDlg, IDC_PS_SOURCETEXT, WM_SETFONT, (WPARAM)hFont, 0L);
                SendDlgItemMessage(hDlg, IDC_PS_RESULTTEXT, WM_SETFONT, (WPARAM)hFont, 0L);
        }

        // Hide the help button if required
        if (!(lpPS->lpOPS->dwFlags & PSF_SHOWHELP))
                StandardShowDlgItem(hDlg, IDC_OLEUIHELP, SW_HIDE);

        // Show or hide the Change icon button
        if (lpPS->dwFlags & PSF_HIDECHANGEICON)
                DestroyWindow(GetDlgItem(hDlg, IDC_PS_CHANGEICON));

        // Hide all DisplayAsIcon related controls if it should be disabled
        if (lpPS->dwFlags & PSF_DISABLEDISPLAYASICON)
        {
                StandardShowDlgItem(hDlg, IDC_PS_DISPLAYASICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
        }

        // clear PSF_CHECKDISPLAYASICON -> it's an output parameter only
        lpPS->dwFlags &= ~ PSF_CHECKDISPLAYASICON;

        // Change the caption if required
        if (NULL != lpOPS->lpszCaption)
                SetWindowText(hDlg, lpOPS->lpszCaption);

        // Load 'Unknown Source' and 'Unknown Type' strings
        int n = LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNTYPE, lpPS->szUnknownType, PS_UNKNOWNSTRLEN);
        if (n)
                n = LoadString(_g_hOleStdResInst, IDS_PSUNKNOWNSRC, lpPS->szUnknownSource, PS_UNKNOWNSTRLEN);
        if (!n)
        {
                PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                return FALSE;
        }

        if (!FPasteSpecialReInit(hDlg, lpPS))
                return FALSE;

        // Give initial focus to the list box
        SetFocus(GetDlgItem(hDlg, IDC_PS_DISPLAYLIST));

        // Set property to handle clipboard change notifications
        SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
        SetProp(hDlg, NEXTCBVIEWER, SetClipboardViewer(hDlg));

        lpPS->fClipboardChanged = FALSE;

        /*
         * PERFORM OTHER INITIALIZATION HERE.
         */

        // Call the hook with lCustData in lParam
        UStandardHook(lpPS, hDlg, WM_INITDIALOG, wParam, lpOPS->lCustData);
        return TRUE;
}

/*
 * FTogglePasteType
 *
 * Purpose:
 *  Toggles between Paste and Paste Link. The Paste list and PasteLink
 *  list are always invisible. The Display List is filled from either
 *  the Paste list or the PasteLink list depending on which Paste radio
 *  button is selected.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  dwOption        Paste or PasteSpecial option
 *
 * Return Value:
 *  BOOL            Returns TRUE if the option has already been selected.
 *                  Otherwise the option is selected and FALSE is returned
 */
BOOL FTogglePasteType(HWND hDlg, LPPASTESPECIAL lpPS, DWORD dwOption)
{
        DWORD dwTemp;
        HWND hList, hListDisplay;
        LRESULT dwData;
        int i, nItems;
        LPTSTR lpsz;

        // Skip all this if the button is already selected
        if (lpPS->dwFlags & dwOption)
                return TRUE;

        dwTemp = PSF_SELECTPASTE | PSF_SELECTPASTELINK;
        lpPS->dwFlags = (lpPS->dwFlags & ~dwTemp) | dwOption;

        // Hide IconDisplay. This prevents flashing if the icon display is changed
        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);

        hListDisplay = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        // If Paste was selected
        if (lpPS->dwFlags & PSF_SELECTPASTE)
        {
                // Set the Source of the object in the clipboard
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataOD);

                // If an icon is available
                if (lpPS->hMetaPictOD)
                        // Set the icon display
                        SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGESET,
                                  0, (LPARAM)lpPS->hMetaPictOD);

                hList = GetDlgItem(hDlg, IDC_PS_PASTELIST);
                // We are switching from PasteLink to Paste. Remember current selection
                //    in PasteLink list so it can be restored.
                lpPS->nPasteLinkListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
                if (lpPS->nPasteLinkListCurSel == LB_ERR)
                        lpPS->nPasteLinkListCurSel = 0;
                // Remember if user selected Paste or PasteLink
                lpPS->fLink = FALSE;
        }
        else    // If PasteLink was selected
        {
                // Set the Source of the object in the clipboard
                SetDlgItemText(hDlg, IDC_PS_SOURCETEXT, lpPS->szSourceOfDataLSD);

                // If an icon is available
                if (lpPS->hMetaPictLSD)
                        // Set the icon display
                        SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY, IBXM_IMAGESET,
                                  0, (LPARAM)lpPS->hMetaPictLSD);

                hList = GetDlgItem(hDlg, IDC_PS_PASTELINKLIST);
                // We are switching from Paste to PasteLink. Remember current selection
                //    in Paste list so it can be restored.
                lpPS->nPasteListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
                if (lpPS->nPasteListCurSel == LB_ERR)
                        lpPS->nPasteListCurSel = 0;
                // Remember if user selected Paste or PasteLink
                lpPS->fLink = TRUE;
        }

        // Turn drawing off while the Display List is being filled
        SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)FALSE, 0L);

        // Move data to Display list box
        SendMessage(hListDisplay, LB_RESETCONTENT, 0, 0L);
        nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
        lpsz = (LPTSTR)GlobalLock(lpPS->hBuff);
        for (i = 0; i < nItems; i++)
        {
                SendMessage(hList, LB_GETTEXT, (WPARAM)i, (LPARAM)lpsz);
                dwData = SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                SendMessage(hListDisplay, LB_INSERTSTRING, (WPARAM)i, (LPARAM)lpsz);
                SendMessage(hListDisplay, LB_SETITEMDATA, (WPARAM)i, dwData);
        }
        GlobalUnlock(lpPS->hBuff);

        // Restore the selection in the Display List from user's last selection
        if (lpPS->dwFlags & PSF_SELECTPASTE)
                SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteListCurSel, 0L);
        else
                SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteLinkListCurSel, 0L);

        // Paint Display List
        SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)TRUE, 0L);
        InvalidateRect(hListDisplay, NULL, TRUE);
        UpdateWindow(hListDisplay);

        // Auto give the focus to the Display List
        if (GetForegroundWindow() == hDlg)
                SetFocus(hListDisplay);

        // Enable/Disable DisplayAsIcon and set the help result text and bitmap corresponding to
        //    the current selection
        ChangeListSelection(hDlg, lpPS, hListDisplay);

        return FALSE;
}

/*
 * ChangeListSelection
 *
 * Purpose:
 *  When the user changes the selection in the list, DisplayAsIcon is enabled or disabled,
 *  Result text and bitmap are updated and the index of the arrPasteEntries[] corresponding
 *  to the current format selection is saved.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  hList           HWND of the List
 *
 * Return Value:
 *  No return value
 */
void ChangeListSelection(HWND hDlg, LPPASTESPECIAL lpPS, HWND hList)
{
        LPPASTELISTITEMDATA lpItemData;
        int nCurSel;

        EnableDisplayAsIcon(hDlg, lpPS);
        SetPasteSpecialHelpResults(hDlg, lpPS);

        // Remember index of arrPasteEntries[] corresponding to the current selection
        nCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (nCurSel == LB_ERR)
                return;
        lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA,
                                (WPARAM)nCurSel, 0L);
        if ((LRESULT)lpItemData == LB_ERR)
                return;
        lpPS->nSelectedIndex = lpItemData->nPasteEntriesIndex;
}

/*
 * EnableDisplayAsIcon
 *
 * Purpose:
 *  Enable or disable the DisplayAsIcon button depending on whether
 *  the current selection can be displayed as an icon or not. The following table describes
 *  the state of DisplayAsIcon. The calling application is termed CONTAINER, the source
 *  of data on the clipboard is termed SOURCE.
 *  Y = Yes; N = No; Blank = State does not matter;
 * =====================================================================
 * SOURCE          SOURCE             CONTAINER             DisplayAsIcon
 * specifies       specifies          specifies             Initial State
 * DVASPECT_ICON   OLEMISC_ONLYICONIC OLEUIPASTE_ENABLEICON
 *
 *                                    N                     Unchecked&Disabled
 *                 Y                  Y                     Checked&Disabled
 * Y               N                  Y                     Checked&Enabled
 * N               N                  Y                     Unchecked&Enabled
 * =====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */
void EnableDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        int nIndex;
        BOOL fCntrEnableIcon;
        BOOL fSrcOnlyIconic = (lpPS->fLink) ? lpPS->fSrcOnlyIconicLSD : lpPS->fSrcOnlyIconicOD;
        BOOL fSrcAspectIcon = (lpPS->fLink) ? lpPS->fSrcAspectIconLSD : lpPS->fSrcAspectIconOD;
        HWND hList;
        LPPASTELISTITEMDATA lpItemData;
        HGLOBAL hMetaPict = (lpPS->fLink) ? lpPS->hMetaPictLSD : lpPS->hMetaPictOD;

        hList = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        // Get data corresponding to the current selection in the listbox
        nIndex = (int)SendMessage(hList, LB_GETCURSEL, 0, 0);
        if (nIndex != LB_ERR)
        {
                lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA, (WPARAM)nIndex, 0L);
                if ((LRESULT)lpItemData != LB_ERR)
                        fCntrEnableIcon = lpItemData->fCntrEnableIcon;
                else fCntrEnableIcon = FALSE;
        }
        else fCntrEnableIcon = FALSE;

        // If there is an icon available
        if (hMetaPict != NULL)
        {
                if (!fCntrEnableIcon)          // Does CONTAINER specify OLEUIPASTE_ENABLEICON?
                {
                        // Uncheck & Disable DisplayAsIcon
                        lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                        CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                        StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                        // Hide IconDisplay and ChangeIcon button
                        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
                }
                else if (fSrcOnlyIconic)       // Does SOURCE specify OLEMISC_ONLYICONIC?
                {
                        // Check & Disable DisplayAsIcon
                        lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
                        CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, TRUE);
                        StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                        // Show IconDisplay and ChangeIcon button
                        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_SHOWNORMAL);
                        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_SHOWNORMAL);
                }
                else if (fSrcAspectIcon)       // Does SOURCE specify DVASPECT_ICON?
                {
                         // Check & Enable DisplayAsIcon
                         lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
                         CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, TRUE);
                         StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, TRUE);

                         // Show IconDisplay and ChangeIcon button
                         StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_SHOWNORMAL);
                         StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_SHOWNORMAL);
                }
                else
                {
                         //Uncheck and Enable DisplayAsIcon
                         lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                         CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                         StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, TRUE);

                         // Hide IconDisplay and ChangeIcon button
                         StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                         StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);

                }
        }
        else  // No icon available
        {
                // Unchecked & Disabled
                lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
                CheckDlgButton(hDlg, IDC_PS_DISPLAYASICON, FALSE);
                StandardEnableDlgItem(hDlg, IDC_PS_DISPLAYASICON, FALSE);

                // Hide IconDisplay and ChangeIcon button
                StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, SW_HIDE);
                StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, SW_HIDE);
        }
}

/*
 * ToggleDisplayAsIcon
 *
 * Purpose:
 *  Toggles the DisplayAsIcon button. Hides or shows the Icon Display and
 *  the ChangeIcon button and changes the help result text and bitmap.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */
void ToggleDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        BOOL fCheck;
        int i;

        fCheck = IsDlgButtonChecked(hDlg, IDC_PS_DISPLAYASICON);

        if (fCheck)
                lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
        else lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;

        // Set the help result text and bitmap
        SetPasteSpecialHelpResults(hDlg, lpPS);

        // Show or hide the Icon Display and ChangeIcon button depending
        // on the check state
        i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
        StandardShowDlgItem(hDlg, IDC_PS_ICONDISPLAY, i);
        StandardShowDlgItem(hDlg, IDC_PS_CHANGEICON, i);
}

/*
 * ChangeIcon
 *
 * Purpose:
 *  Brings up the ChangeIcon dialog which allows the user to change
 *  the icon and label.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */

void ChangeIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
        OLEUICHANGEICON ci;
        UINT uRet;
        CLSID   clsid     = (lpPS->fLink) ? lpPS->clsidLSD : lpPS->clsidOD;

        //Initialize the structure
        memset((LPOLEUICHANGEICON)&ci, 0, sizeof(ci));

        ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY,
                IBXM_IMAGEGET, 0, 0L);
        ci.cbStruct = sizeof(ci);
        ci.hWndOwner = hDlg;
        ci.clsid = clsid;
        ci.dwFlags  = CIF_SELECTCURRENT;

        // Only show help in the ChangeIcon dialog if we're showing it in this dialog.
        if (lpPS->dwFlags & PSF_SHOWHELP)
                ci.dwFlags |= CIF_SHOWHELP;

        // Let the hook in to customize Change Icon if desired.
        uRet = UStandardHook(lpPS, hDlg, uMsgChangeIcon, 0, (LPARAM)&ci);

        if (0 == uRet)
                uRet=(UINT)(OLEUI_OK==OleUIChangeIcon(&ci));

        // Update the display if necessary.
        if (0!=uRet)
        {
                /*
                * OleUIChangeIcon will have already freed our
                * current hMetaPict that we passed in when OK is
                * pressed in that dialog.  So we use 0L as lParam
                * here so the IconBox doesn't try to free the
                * metafilepict again.
                */
                SendDlgItemMessage(hDlg, IDC_PS_ICONDISPLAY,
                        IBXM_IMAGESET, 0, (LPARAM)ci.hMetaPict);
                // Remember the new icon chosen by the user. Note that Paste and PasteLink have separate
                //    icons - changing one does not change the other.
                if (lpPS->fLink)
                        lpPS->hMetaPictLSD = ci.hMetaPict;
                else
                        lpPS->hMetaPictOD = ci.hMetaPict;
        }
}

/*
 *SetPasteSpecialHelpResults
 *
 * Purpose:
 *  Sets the help result text and bitmap according to the current
 *  list selection. The following state table indicates which ResultText
 *  and ResultImage are selected. If %s in the lpstrFormatName is present,
 *  it is assumed that an object is being pasted/paste-linked, otherwise it
 *  is assumed that data is being pasted/paste-linked.
 *  Y = Yes; N = No; Blank = State does not matter;
 *  The numbers in the the ResultText and ResultImage columns refer to the table
 *  entries that follow.
 * =====================================================================
 * Paste/       lpstrFormatName in                DisplayAsIcon Result      Result
 * PasteLink    arrPasteEntry[]contains %s        checked       Text        Image
 *              (Is Object == Y, Is Data == N)
 * Paste        N                                               1           1
 * Paste        Y                                 N             2           2
 * Paste        Y                                 Y             3           3
 * PasteLink    N                                               4           4
 * PasteLink    Y                                 N             5           4
 * PasteLink    Y                                 Y             6           5
 * =====================================================================
 * Result Text:
 *
 * 1. "Inserts the contents of the Clipboard into your document as <native type name,
 *     and optionally an additional help sentence>"
 * 2. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>"
 * 3. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>.  It will be displayed as an icon."
 * 4. "Inserts the contents of the Clipboard into your document as <native type name>.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * 5. "Inserts a picture of the Clipboard contents into your document.  Paste Link
 *     creates a link to the source file so that changes to the source file will be
 *     reflected in your document."
 * 6. "Inserts an icon into your document which represents the Clipboard contents.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * =====================================================================
 * Result Image:
 *
 * 1. Clipboard Image
 * 2. Paste image, non-iconic.
 * 3. Paste image, iconic.
 * 4. Paste Link image, non-iconic
 * 5. Paste Link image, iconic
 * ====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */
void SetPasteSpecialHelpResults(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPTSTR          psz1, psz2, psz3, psz4;
        UINT            i, iString, iImage, cch;
        int             nPasteEntriesIndex;
        BOOL            fDisplayAsIcon;
        BOOL            fIsObject;
        HWND            hList;
        LPPASTELISTITEMDATA  lpItemData;
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        LPTSTR          szFullUserTypeName = (lpPS->fLink) ?
                                        lpPS->szFullUserTypeNameLSD : lpPS->szFullUserTypeNameOD;
        LPTSTR          szInsert;

        hList = GetDlgItem(hDlg, IDC_PS_DISPLAYLIST);

        i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
        if (i != LB_ERR)
        {
                lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, i, 0L);
                if ((LRESULT)lpItemData == LB_ERR) return;
                nPasteEntriesIndex = lpItemData->nPasteEntriesIndex;
                // Check if there is a '%s' in the lpstrFormatName, then an object is being
                //   pasted/pastelinked. Otherwise Data is being pasted-pastelinked.
                fIsObject = FHasPercentS(lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
                                                                                lpPS);
        }
        else
            return;

        // Is DisplayAsIcon checked?
        fDisplayAsIcon=(0L!=(lpPS->dwFlags & PSF_CHECKDISPLAYASICON));

        szInsert = szFullUserTypeName;

        if (lpPS->dwFlags & PSF_SELECTPASTE)     // If user selected Paste
        {
                if (fIsObject)
                {
                        iString = fDisplayAsIcon ? IDS_PSPASTEOBJECTASICON : IDS_PSPASTEOBJECT;
                        iImage  = fDisplayAsIcon ? RESULTIMAGE_EMBEDICON   : RESULTIMAGE_EMBED;
                        szInsert = lpPS->szAppName;
                }
                else
                {
                        iString = IDS_PSPASTEDATA;
                        iImage  = RESULTIMAGE_PASTE;
                }
        }
        else if (lpPS->dwFlags & PSF_SELECTPASTELINK)   // User selected PasteLink
        {
                if (fIsObject)
                {
                        iString = fDisplayAsIcon ? IDS_PSPASTELINKOBJECTASICON : IDS_PSPASTELINKOBJECT;
                        iImage  = fDisplayAsIcon ? RESULTIMAGE_LINKICON : RESULTIMAGE_LINK;
                }
                else
                {
                        iString = IDS_PSPASTELINKDATA;
                        iImage  = RESULTIMAGE_LINK;
                }

        }
        else   // Should never occur.
        {
                iString = IDS_PSNONOLE;
                iImage = RESULTIMAGE_PASTE;
        }

        // hBuff contains enough space for the 4 buffers required to build up the help
        //   result text.
        cch = (UINT)(GlobalSize(lpPS->hBuff) / sizeof(TCHAR)) / 4;

        psz1 = (LPTSTR)GlobalLock(lpPS->hBuff);
        psz2 = psz1 + cch;
        psz3 = psz2 + cch;
        psz4 = psz3 + cch;

        // Default is an empty string.
        *psz1 = 0;

        if (0 != LoadString(_g_hOleStdResInst, iString, psz1, cch) &&
                nPasteEntriesIndex != -1)
        {
                // Insert the FullUserTypeName of the source object into the partial result text
                //   specified by the container.
                wsprintf(psz3, lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrResultText,
                        (LPTSTR)szInsert);
                // Insert the above partial result text into the standard result text.
                wsprintf(psz4, psz1, (LPTSTR)psz3);
                psz1 = psz4;
        }

        // If LoadString failed, we simply clear out the results (*psz1 = 0 above)
        SetDlgItemText(hDlg, IDC_PS_RESULTTEXT, psz1);

        GlobalUnlock(lpPS->hBuff);

        // Change the result bitmap
        SendDlgItemMessage(hDlg, IDC_PS_RESULTIMAGE, RIM_IMAGESET, iImage, 0L);
}

/*
 * FAddPasteListItem
 *
 * Purpose:
 *  Adds an item to the list box
 *
 * Parameters:
 *  hList            HWND List into which item is to be added
 *  fInsertFirst     BOOL Insert in the beginning of the list?
 *  nPasteEntriesIndex int Index of Paste Entry array this list item corresponsds to
 *  lpPS             Paste Special Dialog Structure
 *  lpszBuf          LPSTR Scratch buffer to build up string for list entry
 *  lpszFullUserTypeName LPSTR full user type name for object entry
 *
 * Return Value:
 *  BOOL            TRUE if sucessful.
 *                  FALSE if unsucessful.
 */
BOOL FAddPasteListItem(
                HWND hList, BOOL fInsertFirst, int nPasteEntriesIndex,
                LPPASTESPECIAL lpPS, LPTSTR lpszBuf, LPTSTR lpszFullUserTypeName)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        LPPASTELISTITEMDATA lpItemData;
        int                 nIndex;

        // Allocate memory for each list box item
        lpItemData = (LPPASTELISTITEMDATA)OleStdMalloc(sizeof(PASTELISTITEMDATA));
        if (NULL == lpItemData)
                return FALSE;

        // Fill data associated with each list box item
        lpItemData->nPasteEntriesIndex = nPasteEntriesIndex;
        lpItemData->fCntrEnableIcon = ((lpOPS->arrPasteEntries[nPasteEntriesIndex].dwFlags &
                        OLEUIPASTE_ENABLEICON) ? TRUE : FALSE);

        // Build list box entry string, insert the string and add the data the corresponds to it
        wsprintf(
                        lpszBuf,
                        lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
                        lpszFullUserTypeName
        );

        // only add to listbox if not a duplicate
        if (LB_ERR!=SendMessage(hList,LB_FINDSTRING, 0, (LPARAM)lpszBuf))
        {
                // item is already in list; SKIP this one
                OleStdFree((LPVOID)lpItemData);
                return TRUE;    // this is NOT an error
        }

        nIndex = (int)SendMessage(
                        hList,
                        (fInsertFirst ? LB_INSERTSTRING : LB_ADDSTRING),
                        0,
                        (LPARAM)lpszBuf
        );
        SendMessage(
                        hList,
                        LB_SETITEMDATA,
                        nIndex,
                        (LPARAM)(LPPASTELISTITEMDATA)lpItemData
        );
        return TRUE;
}


/*
 * FFillPasteList
 *
 * Purpose:
 *  Fills the invisible paste list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteList(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        HWND                hList;
        int                 i, j;
        int                 nItems = 0;
        int                 nDefFormat = -1;
        BOOL                fTryObjFmt = FALSE;
        BOOL                fInsertFirst;
        BOOL                fExclude;

        hList = GetDlgItem(hDlg, IDC_PS_PASTELIST);
        SendMessage(hList, LB_RESETCONTENT, 0, 0);

        // Loop over the target's priority list of formats
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
                if (lpOPS->arrPasteEntries[i].dwFlags != OLEUIPASTE_PASTEONLY &&
                                !(lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_PASTE))
                        continue;

                fInsertFirst = FALSE;

                if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfFileName
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfEmbeddedObject
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfEmbedSource)
                {
                        if (! fTryObjFmt)
                        {
                                fTryObjFmt = TRUE;      // only use 1st object format
                                fInsertFirst = TRUE;    // OLE obj format should always be 1st

                                //Check if this CLSID is in the exclusion list.
                                fExclude=FALSE;

                                for (j=0; j < (int)lpOPS->cClsidExclude; j++)
                                {
                                        if (IsEqualCLSID(lpPS->clsidOD, lpOPS->lpClsidExclude[j]))
                                        {
                                                fExclude=TRUE;
                                                break;
                                        }
                                }

                                if (fExclude)
                                        continue;   // don't add the object entry to list

                        }
                        else
                        {
                                continue;   // already added an object format to list
                        }
                }

                // add to list if entry is marked TRUE
                if (lpOPS->arrPasteEntries[i].dwScratchSpace)
                {
                        if (nDefFormat < 0)
                                nDefFormat = (fInsertFirst ? 0 : nItems);
                        else if (fInsertFirst)
                                nDefFormat++;   // adjust for obj fmt inserted 1st in list

                        LPTSTR lpszBuf  = (LPTSTR)GlobalLock(lpPS->hBuff);
                        if (lpszBuf)
                        {
                            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS,
                                    lpszBuf, lpPS->szFullUserTypeNameOD))
                            {
                                GlobalUnlock(lpPS->hBuff);
                                goto error;
                            }
                            GlobalUnlock(lpPS->hBuff);
                        }
                        nItems++;
                }
        }

        // initialize selection to first format matched in list
        if (nDefFormat >= 0)
                lpPS->nPasteListCurSel = nDefFormat;

        // Clean up

        // If no items have been added to the list box (none of the formats
        //   offered by the source matched those acceptable to the container),
        //   return FALSE
        if (nItems > 0)
                return TRUE;
        else
                return FALSE;

error:
        FreeListData(hList);

        return FALSE;
}


/*
 * FFillPasteLinkList
 *
 * Purpose:
 *  Fills the invisible paste link list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteLinkList(HWND hDlg, LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS        = lpPS->lpOPS;
        LPDATAOBJECT        lpSrcDataObj = lpOPS->lpSrcDataObj;
        LPENUMFORMATETC     lpEnumFmtEtc = NULL;
        OLEUIPASTEFLAG      pasteFlag;
        UINT arrLinkTypesSupported[PS_MAXLINKTYPES];  // Array of flags that
                                                                                                  // indicate which link types
                                                                                                  // are supported by source.
        FORMATETC           fmtetc;
        int                 i, j;
        int                 nItems = 0;
        BOOL                fLinkTypeSupported = FALSE;
        HWND                hList;
        int                 nDefFormat = -1;
        BOOL                fTryObjFmt = FALSE;
        BOOL                fInsertFirst;
        HRESULT             hrErr;

        // Remember which link type formats are offered by lpSrcDataObj.
        memset(&fmtetc, 0, sizeof(FORMATETC));
        for (i = 0; i < lpOPS->cLinkTypes; i++)
        {
                if (lpOPS->arrLinkTypes[i] == _g_cfLinkSource)
                {
                        OLEDBG_BEGIN2(TEXT("OleQueryLinkFromData called\r\n"))
                        hrErr = OleQueryLinkFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                        {
                                arrLinkTypesSupported[i] = 1;
                                fLinkTypeSupported = TRUE;
                        }
                        else
                                arrLinkTypesSupported[i] = 0;
                }
                else
                {
                        fmtetc.cfFormat = (CLIPFORMAT)lpOPS->arrLinkTypes[i];
                        fmtetc.dwAspect = DVASPECT_CONTENT;
                        fmtetc.tymed    = 0xFFFFFFFF;       // All tymed values
                        fmtetc.lindex   = -1;
                        OLEDBG_BEGIN2(TEXT("IDataObject::QueryGetData called\r\n"))
                        hrErr = lpSrcDataObj->QueryGetData(&fmtetc);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                        {
                                arrLinkTypesSupported[i] = 1;
                                fLinkTypeSupported = TRUE;
                        }
                        else arrLinkTypesSupported[i] = 0;
                }
        }
        // No link types are offered by lpSrcDataObj
        if (! fLinkTypeSupported)
        {
                nItems = 0;
                goto cleanup;
        }

        hList = GetDlgItem(hDlg, IDC_PS_PASTELINKLIST);
        SendMessage(hList, LB_RESETCONTENT, 0, 0);

        // Enumerate the formats acceptable to container
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
                fLinkTypeSupported = FALSE;

                // If container will accept any link type offered by source object
                if (lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_LINKANYTYPE)
                        fLinkTypeSupported = TRUE;
                else
                {
                        // Check if any of the link types offered by the source
                        //    object are acceptable to the container
                        // This code depends on the LINKTYPE enum values being powers of 2
                        for (pasteFlag = OLEUIPASTE_LINKTYPE1, j = 0;
                                 j < lpOPS->cLinkTypes;
                                 (UINT&)pasteFlag *= 2, j++)
                        {
                                if ((lpOPS->arrPasteEntries[i].dwFlags & pasteFlag) &&
                                                arrLinkTypesSupported[j])
                                {
                                        fLinkTypeSupported = TRUE;
                                        break;
                                }
                        }
                }

                fInsertFirst = FALSE;

                if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfFileName
                                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat == _g_cfLinkSource)
                                {
                        if (! fTryObjFmt)
                        {
                                fTryObjFmt = TRUE;      // only use 1st object format
                                fInsertFirst = TRUE;    // OLE obj format should always be 1st
                        }
                        else
                        {
                                continue;   // already added an object format to list
                        }
                }

                // add to list if entry is marked TRUE
                if (fLinkTypeSupported && lpOPS->arrPasteEntries[i].dwScratchSpace)
                {
                        if (nDefFormat < 0)
                                nDefFormat = (fInsertFirst ? 0 : nItems);
                        else if (fInsertFirst)
                                nDefFormat++;   // adjust for obj fmt inserted 1st in list

                        LPTSTR lpszBuf  = (LPTSTR)GlobalLock(lpPS->hBuff);
                        if (lpszBuf)
                        {
                            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS,
                                            lpszBuf, lpPS->szFullUserTypeNameLSD))
                            {
                                GlobalUnlock(lpPS->hBuff);
                                goto error;
                            }
                            GlobalUnlock(lpPS->hBuff);
                        }
                        nItems++;
                }
        } // end FOR

        nItems = (int)SendMessage(hList, LB_GETCOUNT, 0, 0L);

        // initialize selection to first format matched in list
        if (nDefFormat >= 0)
                lpPS->nPasteLinkListCurSel = nDefFormat;

cleanup:
        // Clean up

        // If no items have been added to the list box (none of the formats
        //   offered by the source matched those acceptable to the destination),
        //   return FALSE
        if (nItems > 0)
                return TRUE;
        else
                return FALSE;

error:
        FreeListData(hList);

        return FALSE;
}

/*
 * FreeListData
 *
 * Purpose:
 *  Free the local memory associated with each list box item
 *
 * Parameters:
 *  hList           HWND of the list
 *
 * Return Value:
 *  None
 */
void FreeListData(HWND hList)
{
        int                nItems, i;
        LPPASTELISTITEMDATA lpItemData;

        nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
        for (i = 0; i < nItems; i++)
        {
                lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
                if ((LRESULT)lpItemData != LB_ERR)
                        OleStdFree((LPVOID)lpItemData);
        }
}

/*
 * FHasPercentS
 *
 * Purpose:
 *  Determines if string contains %s.
 *
 * Parameters:
 *  lpsz            LPCSTR string in which occurence of '%s' is looked for
 *
 * Return Value:
 *  BOOL            TRUE if %s is found, else FALSE.
 */
BOOL FHasPercentS(LPCTSTR lpsz, LPPASTESPECIAL lpPS)
{
   int n = 0;
   LPTSTR lpszTmp;

   if (!lpsz) return FALSE;
   // Copy input string to buffer. This allows caller to pass a
   //   code-based string. Code segments may be swapped out in low memory situations
   //   and so code-based strings need to be copied before string elements can be accessed.
   lpszTmp = (LPTSTR)GlobalLock(lpPS->hBuff);
   lstrcpy(lpszTmp, lpsz);

   while (*lpszTmp)
   {
           if (*lpszTmp == '%')
           {
                   lpszTmp = CharNext(lpszTmp);
                   if (*lpszTmp == 's')     // if %s, return
                   {
                           GlobalUnlock(lpPS->hBuff);
                           return TRUE;
                   }
                   else if (*lpszTmp == '%')    // if %%, skip to next character
                           lpszTmp = CharNext(lpszTmp);
           }
           else
                  lpszTmp = CharNext(lpszTmp);
   }

   GlobalUnlock(lpPS->hBuff);
   return FALSE;
}

/*
 * AllocateScratchMem
 *
 * Purpose:
 *  Allocates scratch memory for use by the PasteSpecial dialog. The memory is
 *  is used as the buffer for building up strings using wsprintf. Strings are built up
 *  using the buffer while inserting items into the Paste & PasteLink lists and while
 *  setting the help result text. It must be big  enough to handle the string that results after
 *  replacing the %s in the lpstrFormatName and lpstrResultText in arrPasteEntries[]
 *  by the FullUserTypeName. It must also be big enough to build the dialog's result text
 *  after %s substitutions by the FullUserTypeName or the ApplicationName.
 *
 * Parameters:
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  HGLOBAL         Handle to allocated global memory
 */
HGLOBAL AllocateScratchMem(LPPASTESPECIAL lpPS)
{
        LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
        int nLen, i;
        int nSubstitutedText = 0;
        int nAlloc = 0;

        // Get the maximum length of the FullUserTypeNames specified by OBJECTDESCRIPTOR
        //   and the LINKSRCDESCRIPTOR and the Application Name. Any of these may be substituted
        //   for %s in the result-text/list entries.
        if (lpPS->szFullUserTypeNameOD)
                nSubstitutedText = lstrlen(lpPS->szFullUserTypeNameOD);
        if (lpPS->szFullUserTypeNameLSD)
                nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szFullUserTypeNameLSD));
        if (lpPS->szAppName)
                nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szAppName));

        // Get the maximum length of lpstrFormatNames & lpstrResultText in arrPasteEntries
        nLen = 0;
        for (i = 0; i < lpOPS->cPasteEntries; i++)
        {
           nLen = max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrFormatName));
           nLen = max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrResultText));
        }

        // Get the maximum length of lpstrFormatNames and lpstrResultText after %s  has
        //   been substituted (At most one %s can appear in each string).
        //   Add 1 to hold NULL terminator.
        nAlloc = (nLen+nSubstitutedText+1)*sizeof(TCHAR);

        // Allocate scratch memory to be used to build strings
        // nAlloc is big enough to hold any of the lpstrResultText or lpstrFormatName in arrPasteEntries[]
        //   after %s substitution.
        // We also need space to build up the help result text. 512 is the maximum length of the
        //   standard dialog help text before substitutions. 512+nAlloc is the maximum length
        //   after %s substition.
        // SetPasteSpecialHelpResults() requires 4 such buffers to build up the result text
        return GlobalAlloc(GHND, (DWORD)4*(512 * sizeof(TCHAR) + nAlloc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\resimage.cpp ===
/*
 * RESIMAGE.CPP
 *
 * Implementation of the Results Image control for OLE 2.0 UI dialogs.
 * We need a separate control for dialogs in order to control the repaints
 * properly and to provide a clean message interface for the dialog
 * implementations.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#include "precomp.h"
#include "resimage.h"
#include "uiclass.h"
OLEDBGDATA

//Reference counter indicating how many times fResultImageInitialize has been
//successfully called
static UINT     uRegistered = 0;

//Bitmap and image dimensions for result images.
static HBITMAP  hBmpResults = NULL;
static UINT     cxBmpResult;
static UINT     cyBmpResult;

/*
 * FResultImageInitialize
 *
 * Purpose:
 *  Attempts to load result bitmaps for the current display driver
 *  for use in OLE 2.0 UI dialogs.  Also registers the ResultImage
 *  control class.
 *
 * Parameters:
 *  hInst           HINSTANCE instance of the DLL.
 *
 *  hPrevInst       HINSTANCE of the previous instance.  Used to
 *                  determine whether to register window classes or not.
 *
 * Return Value:
 *  BOOL            TRUE if all initialization succeeded, FALSE otherwise.
 */

#pragma code_seg(".text$initseg")

BOOL FResultImageInitialize(HINSTANCE hInst, HINSTANCE hPrevInst)
{
        int         cx, iBmp;
        HDC         hDC;
        BITMAP      bm;

        WNDCLASS        wc;

        /*
         * Determine the aspect ratio of the display we're currently
         * running on and load the appropriate bitmap into the global
         * hBmpResults (used from the ResultImage control only).
         *
         * By retrieving the logical Y extent of the display driver, you
         * only have limited possibilities:
         *      LOGPIXELSY      Display
         *      ----------------------------------------
         *         48             CGA    (unsupported)
         *         72             EGA
         *         96             VGA
         *        120             8514/a (i.e. HiRes VGA)
         */

        hDC=GetDC(NULL);

        if (NULL==hDC)
                return FALSE;

        cx=GetDeviceCaps(hDC, LOGPIXELSY);
        ReleaseDC(NULL, hDC);

        /*
         * Instead of single comparisons, check ranges instead, so in case
         * we get something funky, we'll act reasonable.
         */
        if (72 >=cx)             iBmp=IDB_RESULTSEGA;
        if (72 < cx && 120 > cx) iBmp=IDB_RESULTSVGA;
        if (120 <=cx)            iBmp=IDB_RESULTSHIRESVGA;

        if (NULL == hBmpResults)
        {
            hBmpResults=LoadBitmap(hInst, MAKEINTRESOURCE(iBmp));

            if (NULL==hBmpResults)
            {
                    //On error, fail loading the DLL
                    OleDbgOut1(TEXT("FResultImageInitialize:  Failed LoadBitmap.\r\n"));
                    return FALSE;
            }
            OleDbgOut4(TEXT("FResultImageInitialize:  Loaded hBmpResults\r\n"));

            // Now that we have the bitmap, calculate image dimensions
            GetObject(hBmpResults, sizeof(BITMAP), &bm);
            cxBmpResult = bm.bmWidth/CIMAGESX;
            cyBmpResult = bm.bmHeight;
        }


        // Only register class if we're the first instance
        if (hPrevInst)
                uRegistered++;
        else
        {
                // Static flag fRegistered guards against calling this function more
                // than once in the same instance

                if (0 == uRegistered)
                {
                        wc.lpfnWndProc   =ResultImageWndProc;
                        wc.cbClsExtra    =0;
                        wc.cbWndExtra    =CBRESULTIMAGEWNDEXTRA;
                        wc.hInstance     =hInst;
                        wc.hIcon         =NULL;
                        wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
                        wc.hbrBackground =NULL;
                        wc.lpszMenuName  =NULL;
                        wc.style         =CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE1);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE2);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;

                        wc.lpszClassName = TEXT(SZCLASSRESULTIMAGE3);
                        uRegistered = RegisterClass(&wc) ? 1 : 0;
                }
                else
                     uRegistered++;
        }

        return (uRegistered > 0);
}

#pragma code_seg()


/*
 * ResultImageUninitialize
 *
 * Purpose:
 *  Cleans up anything done in FResultImageInitialize, such as freeing
 *  the bitmaps.  Call from WEP.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void ResultImageUninitialize(void)
{
    --uRegistered;
    if (0 == uRegistered)
    {
        if (NULL != hBmpResults)
        {
                DeleteObject(hBmpResults);
                hBmpResults = NULL;
        }
    }
}


/*
 * ResultImageWndProc
 *
 * Purpose:
 *  Window Procedure for the ResultImage custom control.  Only handles
 *  WM_CREATE, WM_PAINT, and private messages to manipulate the bitmap.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LRESULT CALLBACK ResultImageWndProc(HWND hWnd, UINT iMsg,
        WPARAM wParam, LPARAM lParam)
{
        UINT            iBmp;
        PAINTSTRUCT     ps;
        HDC             hDC;

        //Handle standard Windows messages.
        switch (iMsg)
        {
                case WM_CREATE:
                        SetWindowWord(hWnd, RIWW_IMAGEINDEX, RESULTIMAGE_NONE);
                        return (LRESULT)0;

                case WM_PAINT:
                        iBmp = GetWindowWord(hWnd, RIWW_IMAGEINDEX);
                        hDC = BeginPaint(hWnd, &ps);

                        RECT            rc;
                        UINT            x, y;
                        HDC             hDCDlg;
                        HBRUSH          hBr;
                        LOGBRUSH        lb;
                        HWND            hDlg;

                        /*
                         * Our job before using TransparentBlt is to figure out
                         * where to position the result image.  We place it centered
                         * on this control, so get our rect's center and subtract
                         * half of the image dimensions.
                         */
                        GetClientRect(hWnd, &rc);
                        x = (rc.right+rc.left-cxBmpResult)/2;
                        y = (rc.bottom+rc.top-cyBmpResult)/2;

                        // Get the backgroup color the dialog is using.
                        hDlg=GetParent(hWnd);
                        hDCDlg=GetDC(hDlg);
                        if (hDCDlg)
                        {
                            //hDCDlg might be NULL in low-memory situations.
                            hBr = (HBRUSH)SendMessage(hDlg,
                                                      WM_CTLCOLORDLG,
                                                      (WPARAM)hDCDlg,
                                                      (LPARAM)hDlg);
                            ReleaseDC(hDlg, hDCDlg);
                            GetObject(hBr, sizeof(LOGBRUSH), &lb);
                            SetBkColor(hDC, lb.lbColor);
                        }


                        if (RESULTIMAGE_NONE != iBmp)
                        {

                            TransparentBlt(hDC, x, y, hBmpResults, iBmp*cxBmpResult, 0,
                                    cxBmpResult, cyBmpResult, RGBTRANSPARENT);
                        }
                        else
                        {
                            FillRect(hDC, &rc, hBr);
                        }
                        EndPaint(hWnd, &ps);
                        break;

                case RIM_IMAGESET:
                        // wParam contains the new index.
                        iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);

                        // Validate the index before changing it and repainting
                        if (RESULTIMAGE_NONE==wParam ||
                                ((RESULTIMAGE_MAX >= wParam)))
                        {
                                SetWindowWord(hWnd, RIWW_IMAGEINDEX, (WORD)wParam);
                                InvalidateRect(hWnd, NULL, FALSE);
                                UpdateWindow(hWnd);
                        }
                        // Return the previous index.
                        return (LRESULT)iBmp;

                case RIM_IMAGEGET:
                        // Return the current index.
                        iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);
                        return (LRESULT)iBmp;

                default:
                        return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

        return (LRESULT)0;
}


/*
 * TransparentBlt
 *
 * Purpose:
 *  Given a DC, a bitmap, and a color to assume as transparent in that
 *  bitmap, BitBlts the bitmap to the DC letting the existing background
 *  show in place of the transparent color.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  x, y            UINT location at which to draw the bitmap
 *  hBmp            HBITMIP to draw from
 *  xOrg, yOrg      UINT coordinates from which to draw the bitamp
 *  cx, cy          UINT dimensions of the bitmap to Blt.
 *  cr              COLORREF to consider as transparent.
 *
 * Return Value:
 *  None
 */

void TransparentBlt(HDC hDC, UINT x, UINT y, HBITMAP hBmp, UINT xOrg, UINT yOrg,
        UINT cx, UINT cy, COLORREF cr)
{
    if (hBmp)
	{
		// Get three intermediate DC's
		HDC hDCSrc = CreateCompatibleDC(hDC);
		if (hDCSrc)
		{
			HDC hDCMid = CreateCompatibleDC(hDC);
			if (hDCMid)
			{
				HDC hMemDC = CreateCompatibleDC(hDC);
				if (hMemDC)
				{ 
					SelectObject(hDCSrc, hBmp);

					// Create a monochrome bitmap for masking
					HBITMAP hBmpMono = CreateCompatibleBitmap(hDCMid, cx, cy);
					if (hBmpMono)
					{
						SelectObject(hDCMid, hBmpMono);

						// Create a middle bitmap
						HBITMAP hBmpT = CreateCompatibleBitmap(hDC, cx, cy);
						if (hBmpT)
						{
							SelectObject(hMemDC, hBmpT);

							// Create a monochrome mask where we have 0's in the image, 1's elsewhere.
							COLORREF crBack = SetBkColor(hDCSrc, cr);
							BitBlt(hDCMid, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);
							SetBkColor(hDCSrc, crBack);

							// Put the unmodified image in the temporary bitmap
							BitBlt(hMemDC, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);

							// Create an select a brush of the background color
							HBRUSH hBr = CreateSolidBrush(GetBkColor(hDC));
							if (hBr)
							{
								HBRUSH hBrT = (HBRUSH)SelectObject(hMemDC, hBr);

								// Force conversion of the monochrome to stay black and white.
								COLORREF crText = SetTextColor(hMemDC, 0L);
								crBack = SetBkColor(hMemDC, RGB(255, 255, 255));

								/*
								 * Where the monochrome mask is 1, Blt the brush; where the mono mask
								 * is 0, leave the destination untouches.  This results in painting
								 * around the image with the background brush.  We do this first
								 * in the temporary bitmap, then put the whole thing to the screen.
								 */
								BitBlt(hMemDC, 0, 0, cx, cy, hDCMid, 0, 0, ROP_DSPDxax);
								BitBlt(hDC,    x, y, cx, cy, hMemDC, 0, 0, SRCCOPY);

								SetTextColor(hMemDC, crText);
								SetBkColor(hMemDC, crBack);

								SelectObject(hMemDC, hBrT);
								DeleteObject(hBr);
							}								// if (hBr)
							DeleteObject(hBmpT);
						}									// if (hBmpT)
						DeleteObject(hBmpMono);
					}										// if (hBmpMono)
					DeleteDC(hMemDC);
				}											// if (hMemDC)
				DeleteDC(hDCMid);
			}												// if (hDCMid)
			DeleteDC(hDCSrc);
		}													// if (hDCSrc)
	}														// if (hBmp)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\olestd.h ===
/*************************************************************************
**
**    OLE 2.0 Utility Library
**
**    olestd.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for the common OLE 2.0
**    utilities.
**    These utilities include the following:
**          Debuging Assert/Verify macros
**          HIMETRIC conversion routines
**          reference counting debug support
**          OleStd API's for common compound-document app support
**
**    (c) Copyright Microsoft Corp. 1990 - 1995 All Rights Reserved
**
*************************************************************************/

#ifndef _OLESTD_H_
#define _OLESTD_H_

#include <commdlg.h>    // needed for LPPRINTDLG
#include <shellapi.h>   // needed for HKEY
#include <oledlg.h>     // need some paste special defines

#ifdef __cplusplus
extern "C" {
#endif

STDAPI_(void) OleStdInitialize(HINSTANCE hInstance, HINSTANCE hResInstance);

// Clipboard Copy/Paste & Drag/Drop support support

// Clipboard format strings
#define CF_EMBEDSOURCE          TEXT("Embed Source")
#define CF_EMBEDDEDOBJECT       TEXT("Embedded Object")
#define CF_LINKSOURCE           TEXT("Link Source")
#define CF_OBJECTDESCRIPTOR     TEXT("Object Descriptor")
#define CF_LINKSRCDESCRIPTOR    TEXT("Link Source Descriptor")
#define CF_OWNERLINK            TEXT("OwnerLink")
#define CF_FILENAME             TEXT("FileName")
#define CF_FILENAMEW            TEXT("FileNameW")

// Other useful defines
#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

/****** DEBUG Support *****************************************************/

#ifdef _DEBUG

#ifndef _DBGTRACE
        #define _DEBUGLEVEL 2
#else
        #define _DEBUGLEVEL _DBGTRACE
#endif

#ifdef NOASSERT

#define OLEDBGASSERTDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)
#define OleDbgVerifySz(a, b)

#else   // ! NOASSERT

STDAPI OleStdAssert(LPTSTR lpstrExpr, LPTSTR lpstrMsg,
        LPTSTR lpstrFileName, UINT iLine);

#define OLEDBGASSERTDATA    \
                static TCHAR _szAssertFile[]= TEXT(__FILE__);

#define OleDbgAssert(a) \
                (!(a) ? OleStdAssert(TEXT(#a), NULL, _szAssertFile, __LINE__) : (HRESULT)1)

#define OleDbgAssertSz(a, b)    \
                (!(a) ? OleStdAssert(TEXT(#a), b, _szAssertFile, __LINE__) : (HRESULT)1)

#endif

#define OleDbgVerify(a) \
                OleDbgAssert(a)

#define OleDbgVerifySz(a, b)    \
                OleDbgAssertSz(a, b)

#define OLEDBGDATA_MAIN(szPrefix)   \
                TCHAR g_szDbgPrefix[] = szPrefix;    \
                OLEDBGASSERTDATA
#define OLEDBGDATA  \
                extern TCHAR g_szDbgPrefix[];    \
                OLEDBGASSERTDATA

#define OLEDBG_BEGIN(lpsz) \
                OleDbgPrintAlways(g_szDbgPrefix,lpsz,1);

#define OLEDBG_END  \
                OleDbgPrintAlways(g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOut(lpsz) \
                OleDbgPrintAlways(g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix(lpsz) \
                OleDbgPrintAlways(TEXT(""),lpsz,0)

#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)      \
                OleDbgPrintRefCntAlways(g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect(lpsz,lpRect)      \
                OleDbgPrintRectAlways(g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOutHResult(lpsz,hr)   \
                OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,GetScode(hr))

#define OleDbgOutScode(lpsz,sc) \
                OleDbgPrintScodeAlways(g_szDbgPrefix,lpsz,sc)

#define OleDbgOut1(lpsz)    \
                OleDbgPrint(1,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix1(lpsz)    \
                OleDbgPrint(1,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN1(lpsz)    \
                OleDbgPrint(1,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END1 \
                OleDbgPrint(1,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(1,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect1(lpsz,lpRect)     \
                OleDbgPrintRect(1,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut2(lpsz)    \
                OleDbgPrint(2,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix2(lpsz)    \
                OleDbgPrint(2,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN2(lpsz)    \
                OleDbgPrint(2,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END2 \
                OleDbgPrint(2,g_szDbgPrefix, TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(2,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect2(lpsz,lpRect)     \
                OleDbgPrintRect(2,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut3(lpsz)    \
                OleDbgPrint(3,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix3(lpsz)    \
                OleDbgPrint(3,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN3(lpsz)    \
                OleDbgPrint(3,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END3 \
                OleDbgPrint(3,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(3,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect3(lpsz,lpRect)     \
                OleDbgPrintRect(3,g_szDbgPrefix,lpsz,lpRect)

#define OleDbgOut4(lpsz)    \
                OleDbgPrint(4,g_szDbgPrefix,lpsz,0)

#define OleDbgOutNoPrefix4(lpsz)    \
                OleDbgPrint(4,TEXT(""),lpsz,0)

#define OLEDBG_BEGIN4(lpsz)    \
                OleDbgPrint(4,g_szDbgPrefix,lpsz,1);

#define OLEDBG_END4 \
                OleDbgPrint(4,g_szDbgPrefix,TEXT("End\r\n"),-1);

#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)     \
                OleDbgPrintRefCnt(4,g_szDbgPrefix,lpsz,lpObj,(ULONG)refcnt)

#define OleDbgOutRect4(lpsz,lpRect)     \
                OleDbgPrintRect(4,g_szDbgPrefix,lpsz,lpRect)

#else   //  !_DEBUG

#define OLEDBGDATA_MAIN(szPrefix)
#define OLEDBGDATA
#define OleDbgAssert(a)
#define OleDbgAssertSz(a, b)
#define OleDbgVerify(a)         (a)
#define OleDbgVerifySz(a, b)    (a)
#define OleDbgOutHResult(lpsz,hr)
#define OleDbgOutScode(lpsz,sc)
#define OLEDBG_BEGIN(lpsz)
#define OLEDBG_END
#define OleDbgOut(lpsz)
#define OleDbgOut1(lpsz)
#define OleDbgOut2(lpsz)
#define OleDbgOut3(lpsz)
#define OleDbgOut4(lpsz)
#define OleDbgOutNoPrefix(lpsz)
#define OleDbgOutNoPrefix1(lpsz)
#define OleDbgOutNoPrefix2(lpsz)
#define OleDbgOutNoPrefix3(lpsz)
#define OleDbgOutNoPrefix4(lpsz)
#define OLEDBG_BEGIN1(lpsz)
#define OLEDBG_BEGIN2(lpsz)
#define OLEDBG_BEGIN3(lpsz)
#define OLEDBG_BEGIN4(lpsz)
#define OLEDBG_END1
#define OLEDBG_END2
#define OLEDBG_END3
#define OLEDBG_END4
#define OleDbgOutRefCnt(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt1(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt2(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt3(lpsz,lpObj,refcnt)
#define OleDbgOutRefCnt4(lpsz,lpObj,refcnt)
#define OleDbgOutRect(lpsz,lpRect)
#define OleDbgOutRect1(lpsz,lpRect)
#define OleDbgOutRect2(lpsz,lpRect)
#define OleDbgOutRect3(lpsz,lpRect)
#define OleDbgOutRect4(lpsz,lpRect)

#endif  //  _DEBUG

/*************************************************************************
** Function prototypes
*************************************************************************/

// OLESTD.CPP
STDAPI_(int) XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int) XformHeightInHimetricToPixels(HDC, int);

STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk);
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid);
STDAPI_(HGLOBAL) OleStdGetData(
                LPDATAOBJECT        lpDataObj,
                CLIPFORMAT          cfFormat,
                DVTARGETDEVICE FAR* lpTargetDevice,
                DWORD               dwAspect,
                LPSTGMEDIUM         lpMedium
);
STDAPI_(void) OleStdMarkPasteEntryList(
                LPDATAOBJECT        lpSrcDataObj,
                LPOLEUIPASTEENTRY   lpPriorityList,
                int                 cEntries
);
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
                CLSID               clsid,
                DWORD               dwAspect,
                SIZEL               sizel,
                POINTL              pointl,
                DWORD               dwStatus,
                LPTSTR               lpszFullUserTypeName,
                LPTSTR               lpszSrcOfCopy
);
STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
                LPDATAOBJECT       lpDataObject,
                LPSTGMEDIUM        lpmedium,
                CLIPFORMAT FAR*    lpcfFmt
);

STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize);
STDAPI_(void) OleStdFree(LPVOID pmem);
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem);
STDAPI_(LPTSTR) OleStdCopyString(LPTSTR lpszSrc);
STDAPI_(LPTSTR) OleStdLoadString(HINSTANCE hInst, UINT nID);
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk);

STDAPI_(BOOL) OleStdCompareTargetDevice
        (DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight);

STDAPI_(void) OleDbgPrint(
                int     nDbgLvl,
                LPTSTR   lpszPrefix,
                LPTSTR   lpszMsg,
                int     nIndent
);
STDAPI_(void) OleDbgPrintAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, int nIndent);
STDAPI_(void) OleDbgSetDbgLevel(int nDbgLvl);
STDAPI_(int) OleDbgGetDbgLevel( void );
STDAPI_(void) OleDbgIndent(int n);
STDAPI_(void) OleDbgPrintRefCnt(
                int         nDbgLvl,
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPVOID      lpObj,
                ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRefCntAlways(
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPVOID      lpObj,
                ULONG       refcnt
);
STDAPI_(void) OleDbgPrintRect(
                int         nDbgLvl,
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintRectAlways(
                LPTSTR       lpszPrefix,
                LPTSTR       lpszMsg,
                LPRECT      lpRect
);
STDAPI_(void) OleDbgPrintScodeAlways(LPTSTR lpszPrefix, LPTSTR lpszMsg, SCODE sc);

#ifdef __cplusplus
}
#endif

#define ATOW(wsz, sz, cch) MultiByteToWideChar(CP_ACP, 0, sz, -1, wsz, cch)
#define WTOA(sz, wsz, cch) WideCharToMultiByte(CP_ACP, 0, wsz, -1, sz, cch, NULL, NULL)
#define ATOWLEN(sz) MultiByteToWideChar(CP_ACP, 0, sz, -1, NULL, 0)
#define WTOALEN(wsz) WideCharToMultiByte(CP_ACP, 0, wsz, -1, NULL, 0, NULL, NULL)

#endif // _OLESTD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\olestd.cpp ===
/*************************************************************************
**
**    OLE 2 Standard Utilities
**
**    olestd.c
**
**    This file contains utilities that are useful for most standard
**        OLE 2.0 compound document type applications.
**
**    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
**
*************************************************************************/

#include "precomp.h"
#include "common.h"
#include "utility.h"
#include <stdlib.h>
#include <shellapi.h>
#include <wchar.h>

OLEDBGDATA

#ifdef _DEBUG
static TCHAR szAssertMemAlloc[] = TEXT("CoGetMalloc failed");
#endif

static int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight);

/* OleStdInitialize
** ----------------
**    Call to initialize this library sample code
**
*/

UINT _g_cfObjectDescriptor;
UINT _g_cfLinkSrcDescriptor;
UINT _g_cfEmbedSource;
UINT _g_cfEmbeddedObject;
UINT _g_cfLinkSource;
UINT _g_cfOwnerLink;
UINT _g_cfFileName;
UINT _g_cfFileNameW;

HINSTANCE _g_hOleStdInst;
HINSTANCE _g_hOleStdResInst;

#pragma code_seg(".text$initseg")

STDAPI_(void) OleStdInitialize(HINSTANCE hInstance, HINSTANCE hResInstance)
{
        _g_hOleStdInst = hInstance;
        _g_hOleStdResInst = hResInstance ? hResInstance : hInstance;

        _g_cfObjectDescriptor  = RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);
        _g_cfLinkSrcDescriptor = RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR);
        _g_cfEmbedSource       = RegisterClipboardFormat(CF_EMBEDSOURCE);
        _g_cfEmbeddedObject    = RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
        _g_cfLinkSource        = RegisterClipboardFormat(CF_LINKSOURCE);
        _g_cfOwnerLink         = RegisterClipboardFormat(CF_OWNERLINK);
        _g_cfFileName          = RegisterClipboardFormat(CF_FILENAME);
        _g_cfFileNameW         = RegisterClipboardFormat(CF_FILENAMEW);
}

#pragma code_seg()

/* OleStdIsOleLink
** ---------------
**    Returns TRUE if the OleObject is infact an OLE link object. this
**    checks if IOleLink interface is supported. if so, the object is a
**    link, otherwise not.
*/
STDAPI_(BOOL) OleStdIsOleLink(LPUNKNOWN lpUnk)
{
        LPUNKNOWN lpOleLink;
        lpOleLink = OleStdQueryInterface(lpUnk, IID_IOleLink);
        if (lpOleLink)
        {
                OleStdRelease(lpOleLink);
                return TRUE;
        }
        return FALSE;
}


/* OleStdQueryInterface
** --------------------
**    Returns the desired interface pointer if exposed by the given object.
**    Returns NULL if the interface is not available.
**    eg.:
**      lpDataObj = OleStdQueryInterface(lpOleObj, &IID_DataObject);
*/
STDAPI_(LPUNKNOWN) OleStdQueryInterface(LPUNKNOWN lpUnk, REFIID riid)
{
        LPUNKNOWN lpInterface;
        HRESULT hrErr;

        hrErr = lpUnk->QueryInterface(
                        riid,
                        (LPVOID FAR*)&lpInterface
        );

        if (hrErr == NOERROR)
                return lpInterface;
        else
                return NULL;
}


/* OleStdGetData
** -------------
**    Retrieve data from an IDataObject in a specified format on a
**    global memory block. This function ALWAYS returns a private copy
**    of the data to the caller. if necessary a copy is made of the
**    data (ie. if lpMedium->pUnkForRelease != NULL). The caller assumes
**    ownership of the data block in all cases and must free the data
**    when done with it. The caller may directly free the data handle
**    returned (taking care whether it is a simple HGLOBAL or a HANDLE
**    to a MetafilePict) or the caller may call
**    ReleaseStgMedium(lpMedium). this OLE helper function will do the
**    right thing.
**
**    PARAMETERS:
**        LPDATAOBJECT lpDataObj  -- object on which GetData should be
**                                                         called.
**        CLIPFORMAT cfFormat     -- desired clipboard format (eg. CF_TEXT)
**        DVTARGETDEVICE FAR* lpTargetDevice -- target device for which
**                                  the data should be composed. This may
**                                  be NULL. NULL can be used whenever the
**                                  data format is insensitive to target
**                                  device or when the caller does not care
**                                  what device is used.
**        LPSTGMEDIUM lpMedium    -- ptr to STGMEDIUM struct. the
**                                  resultant medium from the
**                                  IDataObject::GetData call is
**                                  returned.
**
**    RETURNS:
**       HGLOBAL -- global memory handle of retrieved data block.
**       NULL    -- if error.
*/
STDAPI_(HGLOBAL) OleStdGetData(
        LPDATAOBJECT        lpDataObj,
        CLIPFORMAT          cfFormat,
        DVTARGETDEVICE FAR* lpTargetDevice,
        DWORD               dwDrawAspect,
        LPSTGMEDIUM         lpMedium)
{
        HRESULT             hrErr;
        FORMATETC           formatetc;
        HGLOBAL             hGlobal = NULL;
        HGLOBAL             hCopy;
        LPVOID              lp;

        formatetc.cfFormat = cfFormat;
        formatetc.ptd = lpTargetDevice;
        formatetc.dwAspect = dwDrawAspect;
        formatetc.lindex = -1;

        switch (cfFormat)
        {
                case CF_METAFILEPICT:
                        formatetc.tymed = TYMED_MFPICT;
                        break;

                case CF_BITMAP:
                        formatetc.tymed = TYMED_GDI;
                        break;

                default:
                        formatetc.tymed = TYMED_HGLOBAL;
                        break;
        }

        OLEDBG_BEGIN2(TEXT("IDataObject::GetData called\r\n"))
        hrErr = lpDataObj->GetData(
                        (LPFORMATETC)&formatetc,
                        lpMedium
        );
        OLEDBG_END2

        if (hrErr != NOERROR)
                return NULL;

        if ((hGlobal = lpMedium->hGlobal) == NULL)
                return NULL;

        // Check if hGlobal really points to valid memory
        if ((lp = GlobalLock(hGlobal)) != NULL)
        {
                if (IsBadReadPtr(lp, 1))
                {
                        GlobalUnlock(hGlobal);
                        return NULL;    // ERROR: memory is NOT valid
                }
                GlobalUnlock(hGlobal);
        }

        if (hGlobal != NULL && lpMedium->pUnkForRelease != NULL)
        {
                /* OLE2NOTE: the callee wants to retain ownership of the data.
                **    this is indicated by passing a non-NULL pUnkForRelease.
                **    thus, we will make a copy of the data and release the
                **    callee's copy.
                */

                hCopy = OleDuplicateData(hGlobal, cfFormat, GHND|GMEM_SHARE);
                ReleaseStgMedium(lpMedium); // release callee's copy of data

                hGlobal = hCopy;
                lpMedium->hGlobal = hCopy;
                lpMedium->pUnkForRelease = NULL;
        }
        return hGlobal;
}


/* OleStdMalloc
** ------------
**    allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize)
{
        LPVOID pout;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return NULL;
        }
        pout = (LPVOID)pmalloc->Alloc(ulSize);
        pmalloc->Release();

        return pout;
}


/* OleStdRealloc
** -------------
**    re-allocate memory using the currently active IMalloc* allocator
*/
STDAPI_(LPVOID) OleStdRealloc(LPVOID pmem, ULONG ulSize)
{
        LPVOID pout;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return NULL;
        }
        pout = (LPVOID)pmalloc->Realloc(pmem, ulSize);
        pmalloc->Release();

        return pout;
}


/* OleStdFree
** ----------
**    free memory using the currently active IMalloc* allocator
*/
STDAPI_(void) OleStdFree(LPVOID pmem)
{
        LPMALLOC pmalloc;

        if (pmem == NULL)
                return;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return;
        }
        if (1 == pmalloc->DidAlloc(pmem))
        {
            pmalloc->Free(pmem);
        }
        pmalloc->Release();
}


/* OleStdGetSize
** -------------
**    Get the size of a memory block that was allocated using the
**    currently active IMalloc* allocator.
*/
STDAPI_(ULONG) OleStdGetSize(LPVOID pmem)
{
        ULONG ulSize;
        LPMALLOC pmalloc;

        if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR)
        {
                OleDbgAssertSz(0, szAssertMemAlloc);
                return (ULONG)-1;
        }
        ulSize = (ULONG) pmalloc->GetSize(pmem);
        pmalloc->Release();

        return ulSize;
}


/* OleStdLoadString
** ----------------
**    Load a string from resources.  The string is allocated
**        with the active IMalloc allocator.
*/
STDAPI_(LPTSTR) OleStdLoadString(HINSTANCE hInst, UINT nID)
{
        LPTSTR lpszResult = (LPTSTR)OleStdMalloc(256 * sizeof(TCHAR));
        if (lpszResult == NULL)
                return NULL;
        LoadString(hInst, nID, lpszResult, 256);
        return lpszResult;
}

/* OleStdCopyString
** ----------------
**    Copy a string into memory allocated with the currently active
**    IMalloc* allocator.
*/
STDAPI_(LPTSTR) OleStdCopyString(LPTSTR lpszSrc)
{
        UINT nSize = (lstrlen(lpszSrc)+1) * sizeof(TCHAR);
        LPTSTR lpszResult = (LPTSTR)OleStdMalloc(nSize);
        if (lpszResult == NULL)
                return NULL;
        memcpy(lpszResult, lpszSrc, nSize);
        return lpszResult;
}

/*
 * OleStdGetObjectDescriptorData
 *
 * Purpose:
 *  Fills and returns a OBJECTDESCRIPTOR structure.
 *  See OBJECTDESCRIPTOR for more information.
 *
 * Parameters:
 *  clsid           CLSID   CLSID of object being transferred
 *  dwDrawAspect    DWORD   Display Aspect of object
 *  sizel           SIZEL   Size of object in HIMETRIC
 *  pointl          POINTL  Offset from upper-left corner of object where mouse went
 *                          down for drag. Meaningful only when drag-drop is used.
 *  dwStatus        DWORD   OLEMISC flags
 *  lpszFullUserTypeName  LPSTR Full User Type Name
 *  lpszSrcOfCopy   LPSTR   Source of Copy
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */
STDAPI_(HGLOBAL) OleStdGetObjectDescriptorData(
        CLSID       clsid,
        DWORD       dwDrawAspect,
        SIZEL       sizel,
        POINTL      pointl,
        DWORD       dwStatus,
        LPTSTR      lpszFullUserTypeName,
        LPTSTR      lpszSrcOfCopy)
{
        HGLOBAL     hMem = NULL;
        IBindCtx FAR    *pbc = NULL;
        LPOBJECTDESCRIPTOR lpOD;
        DWORD       dwObjectDescSize, dwFullUserTypeNameLen, dwSrcOfCopyLen;

        // Get the length of Full User Type Name; Add 1 for the null terminator
#if defined(WIN32) && !defined(UNICODE)
        dwFullUserTypeNameLen = lpszFullUserTypeName ? ATOWLEN(lpszFullUserTypeName) : 0;
        // Get the Source of Copy string and it's length; Add 1 for the null terminator
        if (lpszSrcOfCopy)
           dwSrcOfCopyLen = ATOWLEN(lpszSrcOfCopy);
        else
        {
           // No src moniker so use user type name as source string.
           lpszSrcOfCopy =  lpszFullUserTypeName;
           dwSrcOfCopyLen = dwFullUserTypeNameLen;
        }
#else
        dwFullUserTypeNameLen = lpszFullUserTypeName ? lstrlen(lpszFullUserTypeName)+1 : 0;
        // Get the Source of Copy string and it's length; Add 1 for the null terminator
        if (lpszSrcOfCopy)
           dwSrcOfCopyLen = lstrlen(lpszSrcOfCopy)+1;
        else
        {
           // No src moniker so use user type name as source string.
           lpszSrcOfCopy =  lpszFullUserTypeName;
           dwSrcOfCopyLen = dwFullUserTypeNameLen;
        }
#endif
        // Allocate space for OBJECTDESCRIPTOR and the additional string data
        dwObjectDescSize = sizeof(OBJECTDESCRIPTOR);
        hMem = GlobalAlloc(GHND|GMEM_SHARE, dwObjectDescSize +
           (dwFullUserTypeNameLen + dwSrcOfCopyLen) * sizeof(OLECHAR));
        if (!hMem)
                return NULL;

        lpOD = (LPOBJECTDESCRIPTOR)GlobalLock(hMem);

        // Set the FullUserTypeName offset and copy the string
        if (lpszFullUserTypeName)
        {
                lpOD->dwFullUserTypeName = dwObjectDescSize;
#if defined(WIN32) && !defined(UNICODE)
                ATOW((LPWSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), lpszFullUserTypeName, dwFullUserTypeNameLen);
#else
                lstrcpy((LPTSTR)((LPBYTE)lpOD+lpOD->dwFullUserTypeName), lpszFullUserTypeName);
#endif
        }
        else
                lpOD->dwFullUserTypeName = 0;  // zero offset indicates that string is not present

        // Set the SrcOfCopy offset and copy the string
        if (lpszSrcOfCopy)
        {
                lpOD->dwSrcOfCopy = dwObjectDescSize + dwFullUserTypeNameLen * sizeof(OLECHAR);
#if defined(WIN32) && !defined(UNICODE)
                ATOW((LPWSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), lpszSrcOfCopy, dwSrcOfCopyLen);
#else
                lstrcpy((LPTSTR)((LPBYTE)lpOD+lpOD->dwSrcOfCopy), lpszSrcOfCopy);
#endif
        }
        else
                lpOD->dwSrcOfCopy = 0;  // zero offset indicates that string is not present

        // Initialize the rest of the OBJECTDESCRIPTOR
        lpOD->cbSize       = dwObjectDescSize +
                (dwFullUserTypeNameLen + dwSrcOfCopyLen) * sizeof(OLECHAR);
        lpOD->clsid        = clsid;
        lpOD->dwDrawAspect = dwDrawAspect;
        lpOD->sizel        = sizel;
        lpOD->pointl       = pointl;
        lpOD->dwStatus     = dwStatus;

        GlobalUnlock(hMem);
        return hMem;
}

/*
 * OleStdFillObjectDescriptorFromData
 *
 * Purpose:
 *  Fills and returns a OBJECTDESCRIPTOR structure. The source object will
 *  offer CF_OBJECTDESCRIPTOR if it is an OLE2 object, CF_OWNERLINK if it
 *  is an OLE1 object, or CF_FILENAME if it has been copied to the clipboard
 *  by FileManager.
 *
 * Parameters:
 *  lpDataObject    LPDATAOBJECT Source object
 *  lpmedium        LPSTGMEDIUM  Storage medium
 *  lpcfFmt         CLIPFORMAT FAR * Format offered by lpDataObject
 *                  (OUT parameter)
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */

STDAPI_(HGLOBAL) OleStdFillObjectDescriptorFromData(
        LPDATAOBJECT    lpDataObject,
        LPSTGMEDIUM     lpmedium,
        CLIPFORMAT FAR* lpcfFmt)
{
        CLSID           clsid;
        SIZEL           sizelHim;
        POINTL          pointl;
        LPTSTR          lpsz, szFullUserTypeName, szSrcOfCopy, szClassName, szDocName, szItemName;
        int             nClassName, nDocName, nItemName, nFullUserTypeName;
        LPTSTR          szBuf = NULL;
        HGLOBAL         hMem = NULL;
        HKEY            hKey = NULL;
        DWORD           dw = OLEUI_CCHKEYMAX_SIZE;
        HGLOBAL         hObjDesc;
        HRESULT         hrErr;


        // GetData CF_OBJECTDESCRIPTOR format from the object on the clipboard.
        // Only OLE 2 objects on the clipboard will offer CF_OBJECTDESCRIPTOR
        hMem = OleStdGetData(
            lpDataObject,
            (CLIPFORMAT) _g_cfObjectDescriptor,
            NULL,
            DVASPECT_CONTENT,
            lpmedium);
        if (hMem)
        {
                *lpcfFmt = (CLIPFORMAT)_g_cfObjectDescriptor;
                return hMem;  // Don't drop to clean up at the end of this function
        }
        // If CF_OBJECTDESCRIPTOR is not available, i.e. if this is not an OLE2 object,
        //     check if this is an OLE 1 object. OLE 1 objects will offer CF_OWNERLINK
        else
        {
            hMem = OleStdGetData(
                lpDataObject,
                (CLIPFORMAT) _g_cfOwnerLink,
                NULL,
                DVASPECT_CONTENT,
                lpmedium);
            if (hMem)
            {
                    *lpcfFmt = (CLIPFORMAT)_g_cfOwnerLink;
                    // CF_OWNERLINK contains null-terminated strings for class name, document name
                    // and item name with two null terminating characters at the end
                    szClassName = (LPTSTR)GlobalLock(hMem);
                    nClassName = lstrlen(szClassName);
                    szDocName   = szClassName + nClassName + 1;
                    nDocName   = lstrlen(szDocName);
                    szItemName  = szDocName + nDocName + 1;
                    nItemName  =  lstrlen(szItemName);

                    // Find FullUserTypeName from Registration database using class name
                    if (RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey) != ERROR_SUCCESS)
                       goto error;

                    // Allocate space for szFullUserTypeName & szSrcOfCopy. Maximum length of FullUserTypeName
                    // is OLEUI_CCHKEYMAX_SIZE. SrcOfCopy is constructed by concatenating FullUserTypeName, Document
                    // Name and ItemName separated by spaces.
                    szBuf = (LPTSTR)OleStdMalloc(
                                                            (DWORD)2*OLEUI_CCHKEYMAX_SIZE+
                                    (nDocName+nItemName+4)*sizeof(TCHAR));
                    if (NULL == szBuf)
                            goto error;
                    szFullUserTypeName = szBuf;
                    szSrcOfCopy = szFullUserTypeName+OLEUI_CCHKEYMAX_SIZE+1;

                    // Get FullUserTypeName
                    if (RegQueryValue(hKey, NULL, szFullUserTypeName, (LONG*)&dw) != ERROR_SUCCESS)
                       goto error;

                    // Build up SrcOfCopy string from FullUserTypeName, DocumentName & ItemName
                    lpsz = szSrcOfCopy;
                    lstrcpy(lpsz, szFullUserTypeName);
                    nFullUserTypeName = lstrlen(szFullUserTypeName);
                    lpsz[nFullUserTypeName]= ' ';
                    lpsz += nFullUserTypeName+1;
                    lstrcpy(lpsz, szDocName);
                    lpsz[nDocName] = ' ';
                    lpsz += nDocName+1;
                    lstrcpy(lpsz, szItemName);

                    sizelHim.cx = sizelHim.cy = 0;
                    pointl.x = pointl.y = 0;

#if defined(WIN32) && !defined(UNICODE)
                    OLECHAR wszClassName[OLEUI_CCHKEYMAX];
                    ATOW(wszClassName, szClassName, OLEUI_CCHKEYMAX);
                    CLSIDFromProgID(wszClassName, &clsid);
#else
                    CLSIDFromProgID(szClassName, &clsid);
#endif
                    hObjDesc = OleStdGetObjectDescriptorData(
                                    clsid,
                                    DVASPECT_CONTENT,
                                    sizelHim,
                                    pointl,
                                    0,
                                    szFullUserTypeName,
                                    szSrcOfCopy
                    );
                    if (!hObjDesc)
                       goto error;
             }
             else
             {
                 BOOL fUnicode = TRUE;

                 hMem = OleStdGetData(
                    lpDataObject,
                    (CLIPFORMAT) _g_cfFileNameW,
                    NULL,
                    DVASPECT_CONTENT,
                    lpmedium);

                 if (!hMem)
                 {
                    hMem = OleStdGetData(
                       lpDataObject,
                       (CLIPFORMAT) _g_cfFileName,
                       NULL,
                       DVASPECT_CONTENT,
                       lpmedium);

                    fUnicode = FALSE;
                 }

                 if (hMem)
                 {
                         *lpcfFmt = fUnicode ? (CLIPFORMAT)_g_cfFileNameW : (CLIPFORMAT)_g_cfFileName;
                         lpsz = (LPTSTR)GlobalLock(hMem);
                         if (!fUnicode)
                         {
                             OLECHAR wsz[OLEUI_CCHKEYMAX];
                             ATOW(wsz, (LPSTR)lpsz, OLEUI_CCHKEYMAX);
                             hrErr = GetClassFile(wsz, &clsid);
                         }
                         else
                             hrErr = GetClassFile((LPWSTR)lpsz, &clsid);

                         /* OLE2NOTE: if the file does not have an OLE class
                         **    associated, then use the OLE 1 Packager as the class of
                         **    the object to be created. this is the behavior of
                         **    OleCreateFromData API
                         */
                         if (hrErr != NOERROR)
                                CLSIDFromProgID(OLESTR("Package"), &clsid);
                         sizelHim.cx = sizelHim.cy = 0;
                         pointl.x = pointl.y = 0;

#if defined(WIN32) && !defined(UNICODE)
                         LPOLESTR wszBuf = NULL;
                         szBuf = NULL;
                         if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &wszBuf) != NOERROR)
                         {
                                OleStdFree(wszBuf);
                                goto error;
                         }
                         if (NULL != wszBuf)
                         {
                             UINT uLen = WTOALEN(wszBuf) + 1;
                             szBuf = (LPTSTR) OleStdMalloc(uLen);
                             if (NULL != szBuf)
                             {
                                 WTOA(szBuf, wszBuf, uLen);
                             }
                             else
                             {
                                 OleStdFree(wszBuf);
                                 goto error;
                             }
                             OleStdFree(wszBuf);
                         }
#else
                         if (OleRegGetUserType(clsid, USERCLASSTYPE_FULL, &szBuf) != NOERROR)
                                goto error;
#endif

                         hObjDesc = OleStdGetObjectDescriptorData(
                                        clsid,
                                        DVASPECT_CONTENT,
                                        sizelHim,
                                        pointl,
                                        0,
                                        szBuf,
                                        lpsz
                        );
                        if (!hObjDesc)
                           goto error;
                 }
                 else
                        goto error;
             }
        }
         // Check if object is CF_FILENAME

         // Clean up
         OleStdFree(szBuf);
         if (hMem)
         {
                 GlobalUnlock(hMem);
                 GlobalFree(hMem);
         }
         if (hKey)
                 RegCloseKey(hKey);
         return hObjDesc;

error:
        OleStdFree(szBuf);
         if (hMem)
         {
                 GlobalUnlock(hMem);
                 GlobalFree(hMem);
         }
         if (hKey)
                 RegCloseKey(hKey);
         return NULL;
}

/* Call Release on the object that is NOT necessarily expected to go away.
*/
STDAPI_(ULONG) OleStdRelease(LPUNKNOWN lpUnk)
{
        ULONG cRef;
        cRef = lpUnk->Release();

#ifdef _DEBUG
        {
                TCHAR szBuf[80];
                wsprintf(
                                szBuf,
                                TEXT("refcnt = %ld after object (0x%lx) release\n"),
                                cRef,
                                lpUnk
                );
                OleDbgOut4(szBuf);
        }
#endif
        return cRef;
}


/*
 * OleStdMarkPasteEntryList
 *
 * Purpose:
 *  Mark each entry in the PasteEntryList if its format is available from
 *  the source IDataObject*. the dwScratchSpace field of each PasteEntry
 *  is set to TRUE if available, else FALSE.
 *
 * Parameters:
 *  LPOLEUIPASTEENTRY   array of PasteEntry structures
 *  int                 count of elements in PasteEntry array
 *  LPDATAOBJECT        source IDataObject* pointer
 *
 * Return Value:
 *   none
 */
STDAPI_(void) OleStdMarkPasteEntryList(
        LPDATAOBJECT        lpSrcDataObj,
        LPOLEUIPASTEENTRY   lpPriorityList,
        int                 cEntries)
{
        LPENUMFORMATETC     lpEnumFmtEtc = NULL;
        #define FORMATETC_MAX 20
        FORMATETC           rgfmtetc[FORMATETC_MAX];
        int                 i;
        HRESULT             hrErr;
        DWORD               j, cFetched;

        // Clear all marks
        for (i = 0; i < cEntries; i++)
        {
                lpPriorityList[i].dwScratchSpace = FALSE;
                if (! lpPriorityList[i].fmtetc.cfFormat)
                {
                        // caller wants this item always considered available
                        // (by specifying a NULL format)
                        lpPriorityList[i].dwScratchSpace = TRUE;
                }
                else if (lpPriorityList[i].fmtetc.cfFormat == _g_cfEmbeddedObject
                                || lpPriorityList[i].fmtetc.cfFormat == _g_cfEmbedSource
                                || lpPriorityList[i].fmtetc.cfFormat == _g_cfFileName)
                {
                        // if there is an OLE object format, then handle it
                        // specially by calling OleQueryCreateFromData. the caller
                        // need only specify one object type format.
                        OLEDBG_BEGIN2(TEXT("OleQueryCreateFromData called\r\n"))
                        hrErr = OleQueryCreateFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr)
                                lpPriorityList[i].dwScratchSpace = TRUE;
                }
                else if (lpPriorityList[i].fmtetc.cfFormat == _g_cfLinkSource)
                {
                        // if there is OLE 2.0 LinkSource format, then handle it
                        // specially by calling OleQueryLinkFromData.
                        OLEDBG_BEGIN2(TEXT("OleQueryLinkFromData called\r\n"))
                        hrErr = OleQueryLinkFromData(lpSrcDataObj);
                        OLEDBG_END2
                        if(NOERROR == hrErr) {
                                lpPriorityList[i].dwScratchSpace = TRUE;
                        }
                }
        }

        OLEDBG_BEGIN2(TEXT("IDataObject::EnumFormatEtc called\r\n"))
        hrErr = lpSrcDataObj->EnumFormatEtc(
                        DATADIR_GET,
                        (LPENUMFORMATETC FAR*)&lpEnumFmtEtc
        );
        OLEDBG_END2

        if (hrErr != NOERROR)
                return;    // unable to get format enumerator

        // Enumerate the formats offered by the source
        // Loop over all formats offered by the source
        cFetched = 0;
        memset(rgfmtetc,0,sizeof(rgfmtetc));
        if (lpEnumFmtEtc->Next(
                        FORMATETC_MAX, rgfmtetc, &cFetched) == NOERROR
                || (cFetched > 0 && cFetched <= FORMATETC_MAX) )
        {
                for (j = 0; j < cFetched; j++)
                {
                        for (i = 0; i < cEntries; i++)
                        {
                                if (!lpPriorityList[i].dwScratchSpace &&
                                        IsCloseFormatEtc(&lpPriorityList[i].fmtetc, &rgfmtetc[j]))
                                {
                                        lpPriorityList[i].dwScratchSpace = TRUE;
                                }
                        }
                }
        } // endif

        OleStdRelease((LPUNKNOWN)lpEnumFmtEtc);
}


// returns 1 for a close match
//  (all fields match exactly except the tymed which simply overlaps)
// 0 for no match

int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight)
{
        if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
                return 0;
        else if (!OleStdCompareTargetDevice (pFetcLeft->ptd, pFetcRight->ptd))
                return 0;
        if (pFetcLeft->dwAspect != pFetcRight->dwAspect)
                return 0;
        return((pFetcLeft->tymed | pFetcRight->tymed) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\oledlgs.h ===
/*++ BUILD Version: 0002    Increment this if a change has global effects

Copyright (c) 1993-1995, Microsoft Corporation

Module Name:

        oledlgs.h

Abstract:

        Resource ID identifiers for the OLE common dialog boxes.

--*/

// Help Button Identifier
#define IDC_OLEUIHELP                   99

// Insert Object Dialog identifiers
#define IDC_IO_CREATENEW                2100
#define IDC_IO_CREATEFROMFILE           2101
#define IDC_IO_INSERTCONTROL            2102
#define IDC_IO_LINKFILE                 2103
#define IDC_IO_OBJECTTYPELIST           2104
#define IDC_IO_DISPLAYASICON            2105
#define IDC_IO_CHANGEICON               2106
#define IDC_IO_FILE                     2107
#define IDC_IO_FILEDISPLAY              2108
#define IDC_IO_RESULTIMAGE              2109
#define IDC_IO_RESULTTEXT               2110
#define IDC_IO_ICONDISPLAY              2111
#define IDC_IO_OBJECTTYPETEXT           2112
#define IDC_IO_FILETEXT                 2113
#define IDC_IO_FILETYPE                 2114
#define IDC_IO_ADDCONTROL               2115
#define IDC_IO_CONTROLTYPELIST          2116

// Paste Special Dialog identifiers
#define IDC_PS_PASTE                    500
#define IDC_PS_PASTELINK                501
#define IDC_PS_SOURCETEXT               502
#define IDC_PS_PASTELIST                503     //{{NOHELP}}
#define IDC_PS_PASTELINKLIST            504     //{{NOHELP}}
#define IDC_PS_DISPLAYLIST              505
#define IDC_PS_DISPLAYASICON            506
#define IDC_PS_ICONDISPLAY              507
#define IDC_PS_CHANGEICON               508
#define IDC_PS_RESULTIMAGE              509
#define IDC_PS_RESULTTEXT               510

// Change Icon Dialog identifiers
#define IDC_CI_GROUP                    120     //{{NOHELP}}
#define IDC_CI_CURRENT                  121
#define IDC_CI_CURRENTICON              122
#define IDC_CI_DEFAULT                  123
#define IDC_CI_DEFAULTICON              124
#define IDC_CI_FROMFILE                 125
#define IDC_CI_FROMFILEEDIT             126
#define IDC_CI_ICONLIST                 127
#define IDC_CI_LABEL                    128     //{{NOHELP}
#define IDC_CI_LABELEDIT                129
#define IDC_CI_BROWSE                   130
#define IDC_CI_ICONDISPLAY              131

// Convert Dialog identifiers
#define IDC_CV_OBJECTTYPE               150
#define IDC_CV_DISPLAYASICON            152
#define IDC_CV_CHANGEICON               153
#define IDC_CV_ACTIVATELIST             154
#define IDC_CV_CONVERTTO                155
#define IDC_CV_ACTIVATEAS               156
#define IDC_CV_RESULTTEXT               157
#define IDC_CV_CONVERTLIST              158
#define IDC_CV_ICONDISPLAY              165

// Edit Links Dialog identifiers
#define IDC_EL_CHANGESOURCE             201
#define IDC_EL_AUTOMATIC                202
#define IDC_EL_CANCELLINK               209
#define IDC_EL_UPDATENOW                210
#define IDC_EL_OPENSOURCE               211
#define IDC_EL_MANUAL                   212
#define IDC_EL_LINKSOURCE               216
#define IDC_EL_LINKTYPE                 217
#define IDC_EL_LINKSLISTBOX             206
#define IDC_EL_COL1                     220
#define IDC_EL_COL2                     221
#define IDC_EL_COL3                     222

// Busy dialog identifiers
#define IDC_BZ_RETRY                    600
#define IDC_BZ_ICON                     601
#define IDC_BZ_MESSAGE1                 602     //{{NOHELP}}
#define IDC_BZ_SWITCHTO                 604

// Update Links dialog identifiers
#define IDC_UL_METER                    1029    //{{NOHELP}}
#define IDC_UL_STOP                     1030    //{{NOHELP}}
#define IDC_UL_PERCENT                  1031    //{{NOHELP}}
#define IDC_UL_PROGRESS                 1032    //{{NOHELP}}

// User Prompt dialog identifiers
#define IDC_PU_LINKS                    900     //{{NOHELP}}
#define IDC_PU_TEXT                     901     //{{NOHELP}}
#define IDC_PU_CONVERT                  902     //{{NOHELP}}
#define IDC_PU_ICON                     908     //{{NOHELP}}

// General Properties identifiers
#define IDC_GP_OBJECTNAME               1009
#define IDC_GP_OBJECTTYPE               1010
#define IDC_GP_OBJECTSIZE               1011
#define IDC_GP_CONVERT                  1013
#define IDC_GP_OBJECTICON               1014    //{{NOHELP}}
#define IDC_GP_OBJECTLOCATION           1022

// View Properties identifiers
#define IDC_VP_PERCENT                  1000
#define IDC_VP_CHANGEICON               1001
#define IDC_VP_EDITABLE                 1002
#define IDC_VP_ASICON                   1003
#define IDC_VP_RELATIVE                 1005
#define IDC_VP_SPIN                     1006
#define IDC_VP_SCALETXT                 1034
#define IDC_VP_ICONDISPLAY              1021
#define IDC_VP_RESULTIMAGE              1033

// Link Properties identifiers
#define IDC_LP_OPENSOURCE               1006
#define IDC_LP_UPDATENOW                1007
#define IDC_LP_BREAKLINK                1008
#define IDC_LP_LINKSOURCE               1012
#define IDC_LP_CHANGESOURCE             1015
#define IDC_LP_AUTOMATIC                1016
#define IDC_LP_MANUAL                   1017
#define IDC_LP_DATE                     1018
#define IDC_LP_TIME                     1019

// Dialog Identifiers as passed in Help messages to identify the source.
#define IDD_INSERTOBJECT                1000
#define IDD_CHANGEICON                  1001
#define IDD_CONVERT                     1002
#define IDD_PASTESPECIAL                1003
#define IDD_EDITLINKS                   1004
#define IDD_BUSY                        1006
#define IDD_UPDATELINKS                 1007
#define IDD_CHANGESOURCE                1009
#define IDD_INSERTFILEBROWSE            1010
#define IDD_CHANGEICONBROWSE            1011
#define IDD_CONVERTONLY                 1012
#define IDD_CHANGESOURCE4               1013
#define IDD_GNRLPROPS                   1100
#define IDD_VIEWPROPS                   1101
#define IDD_LINKPROPS                   1102

// The following Dialogs are message dialogs used by OleUIPromptUser API
#define IDD_CANNOTUPDATELINK            1008
#define IDD_LINKSOURCEUNAVAILABLE       1020
#define IDD_SERVERNOTFOUND              1023
#define IDD_OUTOFMEMORY                 1024
#define IDD_SERVERNOTREGW               1021
#define IDD_LINKTYPECHANGEDW            1022
#define IDD_SERVERNOTREGA               1025
#define IDD_LINKTYPECHANGEDA            1026
#ifdef UNICODE
#define IDD_SERVERNOTREG                IDD_SERVERNOTREGW
#define IDD_LINKTYPECHANGED             IDD_LINKTYPECHANGEDW
#else
#define IDD_SERVERNOTREG                IDD_SERVERNOTREGA
#define IDD_LINKTYPECHANGED             IDD_LINKTYPECHANGEDA
#endif
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\oleutl.cpp ===
/*
 * OLEUTL.CPP
 *
 * Miscellaneous utility functions for OLE 2.0 Applications:
 *
 *  Function                      Purpose
 *  -------------------------------------------------------------------
 *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units
 *  XformHeightInHimetricToPixels Converts an int height from HiMetric units
 *
 *  CommitStorage                 Commits all changes in a docfile
 *  CreateChildStorage            Creates child storage in another storage
 *  OpenChildStorage              Opens child storage in another storage
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#include "precomp.h"
#include <stdlib.h>

//Internal function to this module. No need for UNICODE in this function
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst);

/*
 * XformWidthInHimetricToPixels
 * XformHeightInHimetricToPixels
 *
 * Functions to convert an int between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */
STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
{
        int     iXppli;     //Pixels per logical inch along width
        int     iWidthInPix;
        BOOL    fSystemDC=FALSE;

        if (NULL==hDC)
        {
                hDC=GetDC(NULL);

                if (NULL==hDC)
                {
                    //What can we do if hDC is NULL here?  Just don't
                    //transform, I guess.
                    return iWidthInHiMetric;
                }

                fSystemDC=TRUE;
        }

        iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

        //We got logical HIMETRIC along the display, convert them to pixel units
        iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

        if (fSystemDC)
                ReleaseDC(NULL, hDC);

        return iWidthInPix;
}


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
{
        int     iYppli;     //Pixels per logical inch along height
        int     iHeightInPix;
        BOOL    fSystemDC=FALSE;

        if (NULL==hDC)
        {
                hDC=GetDC(NULL);
                
                if (NULL==hDC)
                {
                    //What can we do if hDC is NULL here?  Just don't
                    //transform, I guess.
                    return iHeightInHiMetric;
                }

                fSystemDC=TRUE;
        }

        iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

        //* We got logical HIMETRIC along the display, convert them to pixel units
        iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

        if (fSystemDC)
                ReleaseDC(NULL, hDC);

        return iHeightInPix;
}

/* GetWord
 * -------
 *
 * LPSTR lpszSrc - Pointer to a source string
 * LPSTR lpszDst - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * returns: pointer to next character following the word.
 */
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst)
{
        while (*lpszSrc && !(*lpszSrc == ' ' || *lpszSrc == '\t' || *lpszSrc == '\n'))
                *lpszDst++ = *lpszSrc++;

        *lpszDst = '\0';
        return lpszSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by oledlg.rc
//
#define IDB_RESULTSEGA                  10
#define IDB_RESULTSVGA                  11
#define IDB_RESULTSHIRESVGA             12
#define IDS_FILTERS                     64
#define IDS_ICONFILTERS                 65
#define IDS_BROWSE                      66
#define IDS_OCX_FILTERS                 67
#define IDS_INSERT                      68
#define IDS_CHNGSRCOKBUTTON             69
#define IDS_IORESULTNEW                 256
#define IDS_IORESULTNEWICON             257
#define IDS_IORESULTFROMFILE1           258
#define IDS_IORESULTFROMFILE2           259
#define IDS_IORESULTFROMFILEICON2       260
#define IDS_IORESULTLINKFILE1           261
#define IDS_IORESULTLINKFILE2           262
#define IDS_IORESULTLINKFILEICON1       263
#define IDS_IORESULTLINKFILEICON2       264
#define IDS_CINOICONSINFILE             288
#define IDS_CIINVALIDFILE               289
#define IDS_CIFILEACCESS                290
#define IDS_CIFILESHARE                 291
#define IDS_CIFILEOPENFAIL              292
#define IDS_OLE2UIUNKNOWN               300
#define IDS_OLE2UILINK                  301
#define IDS_OLE2UIOBJECT                302
#define IDS_OLE2UIEDIT                  303
#define IDS_OLE2UICONVERT               304
#define IDS_OLE2UIEDITLINKCMD_1VERB     305
#define IDS_OLE2UIEDITOBJECTCMD_1VERB   306
#define IDS_OLE2UIEDITLINKCMD_NVERB     307
#define IDS_OLE2UIEDITOBJECTCMD_NVERB   308
#define IDS_OLE2UIEDITNOOBJCMD          309
#define IDS_DEFICONLABEL                310
#define IDS_OLE2UIPASTELINKEDTYPE       311
#define IDS_PSPASTEDATA                 400
#define IDS_PSPASTEOBJECT               401
#define IDS_PSPASTEOBJECTASICON         402
#define IDS_PSPASTELINKDATA             403
#define IDS_PSPASTELINKOBJECT           404
#define IDS_PSPASTELINKOBJECTASICON     405
#define IDS_PSNONOLE                    406
#define IDS_PSUNKNOWNTYPE               407
#define IDS_PSUNKNOWNSRC                408
#define IDS_PSUNKNOWNAPP                409
#define IDS_CVRESULTCONVERTLINK         500
#define IDS_CVRESULTCONVERTTO           501
#define IDS_CVRESULTNOCHANGE            502
#define IDS_CVRESULTDISPLAYASICON       503
#define IDS_CVRESULTACTIVATEAS          504
#define IDS_CVRESULTACTIVATEDIFF        505
#define IDS_BZRESULTTEXTBUSY            601
#define IDS_BZRESULTTEXTNOTRESPONDING   602
#define IDS_OLESTDNOCREATEFILE          700
#define IDS_OLESTDNOOPENFILE            701
#define IDS_OLESTDDISKFULL              702
#define IDS_LINK_AUTO                   800
#define IDS_LINK_MANUAL                 801
#define IDS_LINK_UNKNOWN                802
#define IDS_LINKS                       803
#define IDS_FAILED                      804
#define IDS_CHANGESOURCE                805
#define IDS_INVALIDSOURCE               806
#define IDS_ERR_GETLINKSOURCE           807
#define IDS_ERR_GETLINKUPDATEOPTIONS    808
#define IDS_ERR_ADDSTRING               809
#define IDS_CHANGEADDITIONALLINKS       810
#define IDS_CLOSE                       811
#define IDS_OBJECTPROPERTIES            812
#define IDS_LINKOBJECTPROPERTIES        813
#define IDS_LINKPROPS                   814
#define IDS_CONFIRMBREAKLINK            815
#define IDS_BYTES                       816
#define IDS_ORDERKB                     817
#define IDS_ORDERMB                     818
#define IDS_ORDERGB                     819
#define IDS_ORDERTB                     820
#define IDS_OBJECTSIZE                  821
#define IDS_CANNOTLOADOCX               822
#define IDS_NODLLREGISTERSERVER         823
#define IDS_DLLREGISTERFAILED           824
#define IDS_ADDCONTROL                  825
#define IDS_RANGEERROR                  826
#define IDS_INVALIDPERCENTAGE           827
#define IDS_VIEWPROPS                   828
#define RT_HELPINFO                     4096

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        110
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\strcache.h ===
//+---------------------------------------------------------------------------
//
//  File:       strcache.h
//
//  Contents:   Insert object string caching support
//
//  Classes:    CStringCache
//
//  History:    02-May-99   MPrabhu      Created
//
//----------------------------------------------------------------------------
#ifndef _STRCACHE_H_
#define _STRCACHE_H_

#if USE_STRING_CACHE==1 

// Allocate enough memory to carry 64 UNICODE strings of MAX length each at init
#define CACHE_MAX_BYTES_INITIAL  (64 * (OLEUI_CCHKEYMAX_SIZE*2) * sizeof(TCHAR))

// Allocate enough memory for 128 string offsets at Init time
#define MAX_INDEX_ENTRIES_INITIAL   128

//+---------------------------------------------------------------------------
//
//  Class:      CStringCache
//
//  Contents:   Maintains the cache of insert object strings.
//
//  History:    02-May-99   MPrabhu      Created
//
//----------------------------------------------------------------------------
class CStringCache {
public:
    CStringCache();
    ~CStringCache(); 
    BOOL Init();
    void CleanUp();
    
    void NewCall(DWORD flags, DWORD cClsidExclude);

    BOOL AddString(LPTSTR lpStrAdd);
    LPCTSTR NextString();
    void ResetEnumerator();
    BOOL FlushCache();
    
    BOOL IsUptodate();
    BOOL OKToUse();
    
private:
    BOOL ExpandStringTable();
    BOOL ExpandOffsetTable();

    BYTE    *m_pStrings;        // All strings are stored sequentially in this.
    ULONG   *m_pOffsetTable;    // Array of offsets points to location of 
                                // strings in m_pStrings.
    ULONG   m_ulStringCount;    // Current count of strings.
    ULONG   m_ulMaxStringCount; // Current limit for # of strings cache can hold
    ULONG   m_ulMaxBytes;       // Current limit for byte size of string cache
                           // Since the cache grows as needed, both of these can
                           // change over time. However, that will be very rare.
    ULONG   m_ulNextStringNum;  // 1 based string sequence # for enumeration
    HANDLE  m_hRegEvent;        // We use these to watch changes to HKCR\ClsId
    HKEY    m_hRegKey;          // Set to HKCR\ClsID if Init() succeeds
    DWORD   m_ioFlagsPrev;      // Flags passed to a previous InsertObject call
    DWORD   m_cClsidExcludePrev;// cClsidExclude from a previous InsertObj call 
};

// Functions called through OleUIInitialize/OleUIUninitialize during
// DLL_PROCESS_ATTACH/DETACH.
BOOL InsertObjCacheInitialize();
void InsertObjCacheUninitialize();

#endif // USE_STRING_CACHE==1
#endif //_STRCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole2ui32\strcache.cpp ===
//+----------------------------------------------------------------------------
//
//  File:       strcache.cpp
//
//  Contents:   String cache for insert object dialog.
//
//  Classes:    CStringCache
//
//  History:    02-May-99   MPrabhu      Created
//
//-----------------------------------------------------------------------------
#include "precomp.h"
#include "common.h"
#include "strcache.h"
#if USE_STRING_CACHE==1 

// Global instance of the string Cache object.
CStringCache gInsObjStringCache;

// Was the cache initialized successfully?
BOOL    gbCacheInit = FALSE;

// Is the cache in good shape currently?
// This is needed because errors may occur post-initialization
// during caching strings, setting up RegNotify etc. 
// If there is any error we do not take further risk and flag the cache 
// as useless all the way till process detach.
BOOL    gbOKToUseCache = FALSE;

// REVIEW: the above two globals could probably be folded into a single 
// dwFlags member in the cache.

//+-------------------------------------------------------------------------
//
//  Function:   InsertObjCacheInitialize, public
//
//  Synopsis:   Calls Init() method on the string cache and records 
//              success/failure for later use.
//
//  History:    02-May-99   MPrabhu      Created.
//
//--------------------------------------------------------------------------
BOOL InsertObjCacheInitialize()
{
    OleDbgAssert(gbCacheInit == FALSE);
    OleDbgAssert(gInsObjStringCache);
    if (gInsObjStringCache.Init())
    {
        gbCacheInit = TRUE;
        gbOKToUseCache = TRUE;
    }
    return gbCacheInit;
}

//+-------------------------------------------------------------------------
//
//  Function:   InsertObjCacheUninitialize, public
//
//  Synopsis:   Calls CleanUp method on the string cache if it was 
//              successfully initialized.
//
//  History:    02-May-99   MPrabhu      Created.
//
//--------------------------------------------------------------------------
void InsertObjCacheUninitialize()
{
    OleDbgAssert(gInsObjStringCache);
    if (gbCacheInit)
    {
        gInsObjStringCache.CleanUp();
    }
}
   
//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::CStringCache, Public
//
//  Synopsis:   Ctor (empty)
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
CStringCache::CStringCache()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::~CStringCache, Public
//
//  Synopsis:   Dtor (empty) 
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
CStringCache::~CStringCache()
{
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::Init, Public
//
//  Synopsis:   Called during dll_proc_attach to set up the initial state
//              and allocate memory for the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::Init()
{
    m_ulMaxBytes = 0;   //We will alloc this below
    m_ulMaxStringCount = 0;
    m_ulNextStringNum = 1;
    m_ulStringCount = 0;
    m_pOffsetTable = NULL;
    m_pStrings = NULL;
    m_cClsidExcludePrev = 0xFFFFFFFF;   // bogus initial values
    m_ioFlagsPrev = 0xFFFFFFFF;
    m_hRegEvent = CreateEventW( NULL,   // pointer to security attributes 
                                        // (NULL=>can't inherit)
                                FALSE,  // not Manual Reset
                                FALSE,  // not Signaled initially
                                NULL ); // pointer to event-object name
                                
    LONG ret = RegOpenKeyW( HKEY_CLASSES_ROOT, 
                            L"CLSID",           // szSubKey
                            &m_hRegKey );
                            
    if ( (!m_hRegEvent) || ((LONG)ERROR_SUCCESS!=ret) )
    {
        // No point in using the cache if we cannot watch key changes.
        return FALSE;  
    }
    
    ret = RegNotifyChangeKeyValue(  m_hRegKey,         // key to watch
                                    TRUE,              // watch subTree
                                    REG_NOTIFY_CHANGE_NAME            // name
                                      | REG_NOTIFY_CHANGE_LAST_SET, // value
                                    m_hRegEvent,        // event to signal
                                    TRUE );             // report asynchronously                                    
    if (ERROR_SUCCESS!=ret)
    {
        // No point in using the cache if we cannot watch key changes.
        return FALSE;
    }
    
    return (ExpandStringTable() && ExpandOffsetTable());
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::CleanUp, Public
//
//  Synopsis:   Called during dll_proc_detach to clean up the state
//              and free the memory allocated for the cache.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    

void CStringCache::CleanUp()
{
    FlushCache();
    CoTaskMemFree(m_pStrings); 
    CoTaskMemFree(m_pOffsetTable); 
    if (m_hRegEvent) 
        CloseHandle(m_hRegEvent);
    if (m_hRegKey)
        CloseHandle(m_hRegKey);
    gbCacheInit = FALSE;
    gbOKToUseCache = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ExpandStringTable, Private
//
//  Synopsis:   Called to expand the memory block used to keep strings
//
//  History:    02-May-99   MPrabhu       Created
//
//  Notes:      This relies on MemRealloc to copy the existing contents.
//              Caller *must* mark cache state as bad if this fails.
//+-------------------------------------------------------------------------    

BOOL CStringCache::ExpandStringTable()
{
    // Note: we rely on the constructor to set m_ulMaxBytes to 0.
    if (m_ulMaxBytes == 0)  //first expansion
    {        
        OleDbgAssert(m_pStrings==NULL);
        m_ulMaxBytes = CACHE_MAX_BYTES_INITIAL;
    }
    else
    {
        // Each expansion doubles the current size.
        m_ulMaxBytes = m_ulMaxBytes*2;
    }

    // CoTaskMemRealloc does a simple alloc when m_pStrings is NULL.
    BYTE *pStrings = (BYTE *)CoTaskMemRealloc( m_pStrings, m_ulMaxBytes); 
    if (!pStrings) 
    {
        // Caller must mark cache as bad.
        return FALSE;
    }
    m_pStrings = pStrings;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::ExpandOffsetTable, Private
//
//  Synopsis:   Called to expand the memory block used to keep strings
//
//  History:    02-May-99   MPrabhu       Created
//
//  Notes:      This relies on MemRealloc to copy the existing contents.
//              Caller *must* mark cache state as bad if this fails.
//+-------------------------------------------------------------------------    
BOOL CStringCache::ExpandOffsetTable()
{
    // Note: we rely on the contructor to set m_ulMaxStringCount to 0.
    if (m_ulMaxStringCount == 0)
    {
        // first expansion
        OleDbgAssert(m_pOffsetTable==NULL);
        m_ulMaxStringCount =  MAX_INDEX_ENTRIES_INITIAL;
    }
    else
    {
        // at each expansion we double the current size.
        m_ulMaxStringCount = m_ulMaxStringCount*2;
    }
 
    // CoTaskMemRealloc does a simple alloc when m_pOffsetTable is NULL.
    ULONG *pTable = (ULONG *) CoTaskMemRealloc( m_pOffsetTable, 
                                sizeof(ULONG)*(m_ulMaxStringCount+1)); 
    if (!pTable) 
    {
        // Caller must mark the cache as bad.
        return FALSE;
    }
    m_pOffsetTable = pTable;
    if (m_ulMaxStringCount == (ULONG) MAX_INDEX_ENTRIES_INITIAL)
    {
        // initial expansion case
        m_pOffsetTable[0] = 0;  //byte offset for first string
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::NewCall, Public
//
//  Synopsis:   Called to notify the cache of a fresh OleUIInsertObject call
//
//  Parameters: [idFlags]       - dwFlags passed in LPOLEUIINSERTOBJECT struct
//              [cClsidExclude] - cClsidExclude   - do - 
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    

void CStringCache::NewCall(DWORD ioFlags, DWORD cClsidExclude)
{
    if ( (ioFlags != m_ioFlagsPrev)
        ||(cClsidExclude != m_cClsidExcludePrev) )
    {
        // We clear cache state if either:
        //       i) InsertObject call flags change from previous call
        //      ii) Number of clsIds to exclude has changed
        m_ioFlagsPrev = ioFlags;
        m_cClsidExcludePrev = cClsidExclude;
        
        FlushCache();
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CStringCache::IsUptodate, Public
//
//  Synopsis:   Called to check if the cache is up to date.
//
//  History:    02-May-99   MPrabhu       Created
//
//+-------------------------------------------------------------------------    
BOOL CStringCache::IsUptodate()
{
    if (m_ulStringCount==0)
    {
        // The cache has never been setup or has been Flushed recently
        return FALSE;
    }

    BOOL bUptodate;
    
    // Check the notify event if it h