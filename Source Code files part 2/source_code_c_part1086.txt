                 ; no, max count is 8
        cmp     cl,12                   ; otherwise check for 12 chars
        ja      gpFv                    ; if more, no good
        mov     al,cl
        sub     al,ah
        cmp     al,3+1                  ; more than 3 chars in extension?
        ja      gpFv
        jmp     gp0                     ; continue

gpT1:   cmp     cl,8                    ; did we find 8 chars between / and .
        ja      gpFv                    ; if more, we fail
        jmp     gp0
gpx:
        ;** UNC names are invalid if they are SHORTER than the following:
        ;**     \\server\share\f
        cmp     fUNC,0                  ;UNC name?
        jz      PF_EnoughSlashes        ;No
        cmp     cSlash,3                ;We count \\ as one slash
        jb      gpFv                    ;Not enough, so fail it
PF_EnoughSlashes:

        cmp     ch,1
        je      gpx1
        ja      gpFv                    ; if more than 1 we fail
        mov     ah,cl                   ; No extension given
gpx1:
        mov     es:[di],al              ; Zero terminate destination
        xchg    al,ah                   ; Get length of name in CX

        or      ax,ax
        jnz     gpx2
gpFv:   jmp     gpFail
gpx2:
        cmp     ax,8                    ; but no more than 8
        ja      gpFv

        pop     ax
        sub     dx,ax                   ;Get length of path in DX
        inc     dx                      ;Add drive letter and :, less one

        ;** Never a drive letter or colon for the UNC name case
        cmp     fUNC,0                  ;UNC name?
        jz      @F                      ;Yes, don't do this
        dec     dx                      ;UNC names ALWAYS have >=3 slashes
        dec     dx
@@:     mov     ax,dx                   ;AX = length of entire path
        xor     ch,ch                   ;Clear high byte for 16 bit add
        add     ax,cx
        cmp     dx,1                    ;If length is one, we have C:\ case
        jne     @F                      ;Nope
        inc     dx                      ;Bump it
@@:
gpexit:
        mov     di,cSlash               ;DI retured as cSlash
cEnd

;---------------------------------------------------------------
;
; Return the drive letter of last drive a disk was swapped in
;
cProc   GetLastDiskChange, <PUBLIC,FAR>
cBegin  nogen
        xor     ax,ax
        push    ds
        SetKernelDS
        xchg    al,[LastDriveSwapped]
        pop     ds
        UnSetKernelDS
        ret
cEnd    nogen

        assumes ds,nothing
        assumes es,nothing

cProc   MyOpenFile,<PUBLIC,FAR>,<si,di>
        ParmD   srcFile
        ParmD   dstFile
        ParmW   Command
cBegin
        SetKernelDS
        xor     ax,ax
        cmp     [wMyOpenFileReent], ax  ; Prevent reentering this procedure
        jne     myoffail

ifdef WOW
        and     Command, NOT OF_VERIFY  ; Don't Bother with verify for internal
                                        ; It slows us down
endif
        mov     es,[CurTDB]
        mov     ax,es:[TDB_ErrMode]     ; Enable INT 24h processing
        and     es:[TDB_ErrMode],NOT 1
        mov     [myofint24],ax          ; Save old INT 24h flag
        mov     [wMyOpenFileReent],1

        cCall   IOpenFile,<srcFile,dstFile,Command>

        mov     es,[CurTDB]             ; Restore old INT 24h processing flag
        mov     dx,[myofint24]
        mov     es:[TDB_ErrMode],dx

        mov     [wMyOpenFileReent],0
        jmps    mof_ret

myoffail:
        krDebugOut DEB_ERROR, "MyOpenFile not reentrant"
        dec     ax
mof_ret:
        UnSetKernelDS
cEnd

sEnd    CODE

sBegin  MISCCODE
assumes CS,MISCCODE
assumes ds,nothing
assumes es,nothing

externNP MISCMapDStoDATA
externFP GetWindowsDirectory

cProc   DeletePathname,<PUBLIC,FAR>
;       ParmD   path
cBegin  nogen
        pop     bx
        pop     cx
        mov     ax,4100h                ; dos delete file function
        push    ax
        push    cx
        push    bx
        errn$   OpenPathname
cEnd    nogen

cProc   OpenPathname,<PUBLIC,FAR>,<ds,si,di>
        ParmD   path
        ParmW   attr

        LocalV  Buffer,MaxFileLen
cBegin
        mov     ax,attr         ; get attribute
        or      ah,ah           ; function code already set...
        jnz     opn0            ; ...yes, otherwise...
        mov     ah,3dh          ; ...default to open
opn0:   mov     di,ax

; We don't use open test for existance, rather we use get
; file attributes.  This is because if we are using Novell
; netware, opening a file causes Novell to execute its
; own path searching logic, but we want our code to do it.

        call    MISCMapDStoDATA
        ReSetKernelDS
        cmp     fNovell, 0
        lds     dx,path                 ; get pointer to pathname
        UnSetKernelDS
        je      opnNoNovell
        mov     ax,4300h                ; Get file attributes
        DOSFCALL                        ; Does the file exist?
        jc      opnnov                  ; No, then dont do the operation
opnNoNovell:
        mov     ax,di                   ; Yes, restore operation to AX
        DOSFCALL
        jnc     opn2
opnnov:
        lea     ax,Buffer
        regptr  dsdx,ds,dx
        regptr  ssax,ss,ax
        cCall   SearchPath,<dsdx,ssax,di>
opn2:   mov     bx,ax
cEnd

;---------------------------------------------------------------
;
; Return the drive letter of a good disk to put a temp file on
;
;
cProc   GetTempDrive,<PUBLIC,FAR>
;       ParmB   Drive
cBegin  nogen
        mov     bx,sp
        push    si
        push    di
        mov     ax,ss:[bx+4]
        and     al,not TF_FORCEDRIVE
        jnz     gtd1
        mov     ah,19h          ; get the current disk
        DOSFCALL
        add     al,'A'
gtd1:   and     al,01011111b    ; convert to upper case (always a-z)
        test    byte ptr ss:[bx+4],TF_FORCEDRIVE        ; Forcing drive letter?
        jnz     gtdz            ; Yes, all done
        sub     al,'A'          ; A: = 0, etc.
        cbw
        mov     si,ax           ; SI = drive to return if no hard disk
        xor     di,di           ; start with drive A
gtd2:   call    FarIsFloppy     ; while drive = floppy, keep looking
        cmp     al,3            ; did we find a hard disk?
        mov     dx,1            ; return we have a hard disk
        jz      gtdx            ; yes, return it
        inc     di
        cmp     di,"Z"-"A"
        jbe     gtd2
        xor     dx,dx           ; indicate its a floppy
        mov     di,si           ; return default disk

gtdx:   mov     ax,di
        add     al,"A"

gtdz:   mov     ah,":"
        pop     di
        pop     si
        ret     2
cEnd    nogen

cProc   hextoa,<PUBLIC,NEAR>
cBegin  nogen
        mov     ah,al
        mov     cl,4
        shr     al,cl
        and     ah,0Fh
        add     ax,3030h
        cmp     al,39h
        jbe     hextoa1
        add     al,7
hextoa1:
        cmp     ah,39h
        jbe     hextoa2
        add     ah,7
hextoa2:
        ret
cEnd    nogen

;---------------------------------------------------------------
;
cProc   IGetTempFileName,<PUBLIC,FAR>,<si,di>
        parmW   drive
        parmD   lpPrefix
        parmW   nUnique
        parmD   lpBuf
        localW  myUnique
        localW  mydx
        localW  mybuf
cBegin
        sub     sp, 128                 ; local buffer for buiding lpBuf
        mov     di, sp
        mov     mybuf, sp               ; save
        cCall   GetTempDrive,<drive>
        mov     mydx,dx
        ;les    di,lpBuf
        smov    es, ss
        stosw                           ; AX = 'drive:'
        mov     ax,drive
        test    al,TF_FORCEDRIVE
        jnz     stmpForce
        call    FarGetEnv               ; look for environ TEMP=
stmp2:
        lodsw
        or      al,al                   ; no more enviroment
        jz      stmpNo

        cmp     ax,'ET'                 ; Look for TEMP=
        jne     stmp3
        lodsw
        cmp     ax,'PM'
        jne     stmp3
        lodsb
        cmp     al,'='
        je      stmpYes
stmp3:  lodsb                           ; find end of string
        or      al,al
        jnz     stmp3
        jmp     stmp2

stmpYes:
ifdef FE_SB
        mov     al,[si]
        mov     ah,0
        call    FarMyIsDBCSLeadByte
        jnc     stmpnodrive
endif
        cmp     byte ptr [si+1],':'     ; TEMP has drive?
        jne     stmpnodrive
        dec     di
        dec     di
stmpnodrive:                            ; copy path to ES:DI
        lodsb
        or      al,al
        jz      stmpPath
        stosb
        jmp     stmpnodrive

stmpForce:
        mov     al,'~'
        stosb
        jmps    stmpNo1

stmpNo:                                 ; ES:DI points to "drive:"
        dec     di
        dec     di
        cCall   GetWindowsDirectory, <esdi, 144>
        add     di, ax

stmpPath:                               ; ES:DI points to "drive:path"
        mov     ax,'~\'
        cmp     es:[di-1],al            ; does it already end in \
        jnz     stmpNoF                 ; no, just store it
        dec     di                      ; override it
stmpNoF:
        stosw
stmpNo1:
        lds     si,lpPrefix
        mov     cx,3
stmpPfx:
        lodsb
        or      al,al
        jz      stmpPfx1
        stosb
        loop    stmpPfx
stmpPfx1:
        mov     dx,nUnique
        or      dx,dx
        jnz     stmpNum
        mov     ah,2Ch
        DOSFCALL
        xor     dx,cx
stmpNum:
        mov     myUnique,dx
        jnz     stmpNum1
        inc     dx                      ; Dont ever use 0 as the unique num.
        jmp     stmpNum
stmpNum1:
        mov     al,dh
        call    hextoa
        stosw
        mov     al,dl
        call    hextoa
        stosw
        mov     ax,'T.'
        stosw
        mov     ax,'PM'
        stosw
        xor     ax,ax
        stosb

; Don't call AnsiUpper on this string because it has OEM characters
; in it (from the app and the temp environment variable).

        cmp     nUnique,0
        jne     stmpDone
        ;lds    dx,lpBuf
        mov     dx, mybuf
        smov    ds, ss
        mov     ax,5B00h
        xor     cx,cx
        DOSFCALL
        jnc     stmpClose
        cmp     al,80                   ; Did we fail because the file
        jnz     stmpfail                ;  already exists?
        sub     di,9
        mov     dx,myUnique
        inc     dx
        jmp     stmpNum

stmpClose:
        mov     bx,ax
        mov     ah,3Eh
        DOSFCALL
        jmps    stmpdone

stmpfail:
        xor     ax,ax
        mov     myunique,ax
stmpdone:
        mov     di, mybuf               ; robustness crap
        smov    es, ss                  ; bug #15493 ami pro
        RegPtr  esdi, es, di
        cCall   lstrcpy <lpBuf,esdi>    ; now copy to user spc
        mov     ax,myunique
        mov     dx,mydx
        add     sp, 128
cEnd

;-----------------------------------------------------------------------;
; GetDriveType
;
; Entry:
;       parmW   drive    Disk Drive Information (Drive A = 0)
;
; Returns:
;       ax = 0 means the drive does not exist.  if dx != 0 then the drive
;           maps to the drive in dx instead (A = 1) AND the drive is
;           REMOVEABLE.
;       ax = 1 means the drive does not exist.  if dx != 0 then the drive
;           maps to the drive in dx instead (A = 1) AND the drive is
;           FIXED.
;       ax = 2 means the drive is removable media
;       ax = 3 means the drive is fixed media
;       ax = 4 means the drive is fixed media and remote
;
; Registers Destroyed:
;
; History:
;  Mon 16-Oct-1989 21:14:27  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

ifndef WOW - We thunk this API its too slow

cProc   GetDriveType,<PUBLIC,FAR>
;       parmW   drive
cBegin nogen
        mov     bx,sp
        push    ds
        call    MISCMapDStoDATA
        ResetKernelDS
        mov     ax,1            ; 1 = Get Drive Info from InquireSystem
        mov     bx,ss:[bx+4]
        cCall   pSysProc,<ax,bx>
        pop     ds
        ret     2
cEnd nogen
endif; WOW


sEnd    MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldreloc.asm ===
PAGE    ,132
        TITLE   LDRELOC - SegReloc procedure

.xlist
include gpfix.inc
include kernel.inc
include newexe.inc
include protect.inc
.list

;externFP FatalExit
externFP GlobalLock
externFP GlobalUnLock
externFP Int21Handler
externFP IFatalAppExit

DataBegin

if PMODE32 and ROM
externW gdtdsc
endif

externW f8087
externB fastFP
;externW WinFlags
ifndef WINDEBUG
externB szUndefDyn
endif
DataEnd

sBegin  CODE
assumes CS,CODE

externNP GetStringPtr
externNP FindOrdinal
externNP EntProcAddress
externNP LoadSegment
externNP GetOwner

ife ROM and PMODE32
externW  gdtdsc
endif

externNP GetAccessWord
externNP DPMIProc

DPMICALL        MACRO   callno
        mov     ax, callno
        call    DPMIProc
        ENDM

ifdef WOW_x86
externNP get_physical_address
endif



;-----------------------------------------------------------------------;
; UndefDynlink
;
; If an application has a dynamic link to a loaded library that
; we can't find we fix up to this think.  This way the app
; will blow up only if it tries to call the entry point.
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
; Added this nifty comment block!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   UndefDynlink,<PUBLIC,FAR>,<ds>
        localW  foo                     ; force stack frame
cBegin
        SetKernelDS
if KDEBUG
        cCall   GetOwner,<[bp].savedCS>
        mov     es,[bp].savedCS
        mov     bx,[bp].savedIP
        sub     bx,5
        krDebugOut DEB_FERROR, "%AX1 #ES:#BX called undefined dynalink"
;       kerror  ERR_LDNAME,<Call to undefined dynlink entry point at >,es,bx
else
        push    0
        push    ds
        push    dataOffset szUndefDyn
        cCall   IFatalAppExit   ;,<0, ds, dataOffset szUndefDyn>
endif
cEnd


;-----------------------------------------------------------------------;
; SegReloc
;
;
; Entry:
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Thu 25-May-1989 20:16:09  -by-  David N. Weise  [davidw]
; Removed the special case code for version 1.01 (linker or windows?) that
; If BASE fixup for moveable code segment within a DATA segment (V1.01 only)
; Then force to be PTR fixup.
;
;  Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
; Added this nifty comment block!
;-----------------------------------------------------------------------;

        assumes ds, nothing
        assumes es, nothing

ifdef WOW_x86
.386
cProc   SegReloc,<NEAR,PUBLIC>,<si,edi,ds>
else
cProc   SegReloc,<NEAR,PUBLIC>,<si,di,ds>
endif
        parmW   hexe
        parmD   prleinfo
        parmW   creloc
        parmD   pseginfo
        parmW   fdataseg
        parmW   fh
        localW  himpexe
        localW  hseg
        localW  pseg
        localW  hifileoff
        localW  lofileoff
        localV  rlerec,<SIZE NEW_RLC>
        localW  fOsfixup                ;bool set if a floating-pt osfixup.
        localW  old_access
ifdef WOW_x86
        localD  rover_2
endif
cBegin
        les     si, pseginfo
        mov     dx, es:[si].ns_handle   ; Get handle to segment
        mov     hseg, dx
        test    dl, GA_FIXED
        jnz     sr_nolock
        cCall   GlobalLock,<dx>
sr_nolock:

        mov     pseg, dx

;; WOW - refer to original win 3.1 code on \\pucus, there were too many ifdefs
;; in the code.   It would have become unreadable to add any more.   mattfe
;; mar 29 93
;;; Restored the "too many ifdef's" because this code doesn't just
;;; assemble right for all our platform permutations. I also tried to make it 
;;; readable by adding comments. -neilsa

;; For 386 version of WOW we use selector 23h to write to vdm memory without
;; worrying about setting up a selector.

ifndef WOW 
;------------------Original win31 source--------------------------------
ife PMODE32
        cCall   GetAccessWord,<dx>
else
.386p
        lar     eax, edx
        shr     eax, 8
.286
endif
        mov     old_access, ax
        test    al, DSC_CODE_BIT
        jz      short access_ok
        mov     al, DSC_PRESENT+DSC_DATA
        mov     bx, dx

        push    ds
if ROM and PMODE32
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, ax
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     ds

else ; ******** WOW ADDED SOURCE

ifdef WOW_x86
;------------------WOW source for X86 platforms-------------------------
ife PMODE32
        cCall   GetAccessWord,<dx>
        mov     old_access, ax
        test    al, DSC_CODE_BIT
        jz      short access_ok
        mov     al, DSC_PRESENT+DSC_DATA
        mov     bx, dx
        mov     cx,ax
        DPMICALL 0009h
endif; PMODE32

else; WOW_x86
;------------------WOW source for NON-X86 platforms---------------------
ife PMODE32
        cCall   GetAccessWord,<dx>
else
.386p
        lar     eax, edx
        shr     eax, 8
.286
endif
        mov     old_access, ax
        test    al, DSC_CODE_BIT
        jz      short access_ok
        mov     al, DSC_PRESENT+DSC_DATA
        mov     bx, dx
ife PMODE32
        mov     cx,ax
        DPMICALL 0009h
else
        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, ax
        pop     ds
endif; PMODE32
endif; WOW_x86
endif; ******** WOW ADDED SOURCE
;----------------------End of WOW changes-------------------------------

access_ok:

        mov     fOsfixup,0              ; set flag initially to false.
        mov     si,OFF_prleinfo
        mov     ax,SEG_prleinfo
        or      ax,ax
        jz      @F
        jmp     srloop1
@@:

        xor     dx,dx
        xor     cx,cx
        mov     bx,fh
        mov     ax,4201h
        DOSCALL                         ; Get current file offset
        jnc     @F
        krDebugOut <DEB_ERROR or DEB_krLoadSeg>, "Get file offset failed"
;       Debug_Out "Get file offset failed."
        jmps    srbadrle1
@@:
        mov     hifileoff,dx
        mov     lofileoff,ax
srloop:
        mov     ax,SEG_prleinfo
        or      ax,ax                   ; Did we get a handle to RLE?
        jnz     srloop1                 ; No, continue


        mov     cx,hifileoff            ; OPTIMIZE this to read in more
        mov     dx,lofileoff            ;  than one record at a time!!
        mov     bx,fh
        mov     ax,4200h
        DOSCALL                         ; Seek to current offset
        jnc     @F
        krDebugOut DEB_ERROR, "Seek failed."
;       Debug_Out "Seek failed."
srbadrle1:
        jmp     srbadrle
@@:
        push    ss
        pop     ds
        lea     dx,rlerec
        mov     cx,SIZE NEW_RLC
        add     lofileoff,cx
        adc     hifileoff,0
        mov     ah,3Fh
        DOSCALL                         ; Read next record
        jnc     @F
        krDebugOut DEB_ERROR, "Read record failed"
;       Debug_Out "Read record failed"
        jmps    srbadrle1
@@:
        cmp     ax,cx
        je      @F
        krDebugOut DEB_ERROR, "Read #AX bytes, expecting #CX."
        jmp     srbadrle

srosfijmp:
        jmp     srosfixup

@@:
        mov     ax,ss
        mov     si,dx

srloop1:
        mov     ds,ax
        mov     ax,ds:[si].nr_proc
        mov     cx,NRRTYP
        and     cl,ds:[si].nr_flags
        or      cx,cx
        jz      srint                   ; Internal Reference
        cmp     cl,OSFIXUP
        je      srosfijmp
        .errnz  NRRINT
        mov     bx,ds:[si].nr_mod       ; Here if Import Ordinal/Name
        sub     bx,1
        jnc     @F
        krDebugOut DEB_ERROR, "Zero import module."
        jmps    srbadrle
@@:
        shl     bx,1
        mov     es,hexe
        add     bx,es:[ne_modtab]
        mov     bx,es:[bx]
        mov     himpexe,bx
        or      bx,bx
        jz      srbadimp
        dec     cx                      ; (sleaze) if cx == 2, then Import Name
        jz      srrord                  ; else Import Ordinal
        .errnz  NRRORD - 1
        .errnz  NRRNAM - 2

srrnam:                                         ; Convert name to ordinal
        cCall   GetStringPtr,<hexe,fh,ax>
        cCall   FindOrdinal,<himpexe,dxax,fh>
        mov     bx,himpexe
        or      ax,ax
        jz      srbadimp
srrord:
if KDEBUG
        cCall   EntProcAddress,<bx,ax,0>; we do want to RIP for failure
else
        cCall   EntProcAddress,<bx,ax>
endif
        jcxz    srbadimp
        jmp     dorle

srbadimp:
if kdebug
        mov     dx, hExe
        mov     ax, himpexe
        krDebugOut <DEB_WARN or DEB_krLoadSeg>, "%dx1 failed implicit link to %ax0"
endif
        mov     dx,cs
        mov     ax,codeOFFSET UndefDynlink
        jmp     dorle

srbadrle:
        jmp     srfail

srdone1:
        jmp     srdone

srint:
        mov     dl,NRSTYP               ; DL = fixup type
        and     dl,ds:[si].nr_stype
        mov     cl,ds:[si].nr_segno
        or      cx,cx
        jnz     @F
        krDebugOut DEB_ERROR, "NULL segment in fixup."
        jmp     srbadrle
@@:
        mov     bx,hexe
        cmp     cl,ENT_MOVEABLE
        je      srrord
        mov     es,bx
        mov     bx,cx
        dec     bx
        cmp     es:[ne_cseg],bx
        jnbe    @F
        krDebugOut DEB_ERROR, "Invalid segment in fixup."
        jmp     srbadrle                ; Error if invalid segno
@@:
        push    ax                      ; Save offset
        shl     bx,1
        mov     ax,bx
        shl     bx,1
        shl     bx,1
        add     bx,ax                   ; BX *= 10
        .errnz  10 - SIZE NEW_SEG1
        add     bx,es:[ne_segtab]
        cmp     dl,NRSOFF               ; Offset only fixup?
        je      srint2                  ; Yes, go do it then (DX ignored then)
if ROM
        test    byte ptr es:[bx].ns_flags, NSALLOCED OR NSLOADED
else
        test    byte ptr es:[bx].ns_flags, NSALLOCED
endif
        jz      srint1
        mov     ax, es:[bx].ns_handle
        or      ax,ax
        jnz     @F
        krDebugOut DEB_ERROR, "NULL handle."
        jmp     srbadrle
@@:

        test    al,GA_FIXED
        jnz     srint2
        HtoS    ax
        mov     cx,ax                   ; for the jcxz below
        jmps    srint2

srbadrlej:
        jmp     srbadrle

srint1:
int 3
int 3
        cCall   LoadSegment,<es,cx,fh,fh>
srint2:
        mov     dx,ax
        pop     ax
        or      cx,cx
        jnz     @F
        krDebugOut DEB_ERROR, "Can't load segment."
        jmp     srbadrlej

@@:
dorle:
        push    ax
        push    dx
        mov     ax,SEG_prleinfo
        or      ax,ax                   ; Did we get a handle to RLE?
        jnz     @F                      ; No, continue
        mov     ax,ss                   ; Assume reading from stack
@@:
        mov     ds,ax
        mov     bl,NRSTYP
        and     bl,ds:[si].nr_stype
        mov     cx,NRADD
        and     cl,ds:[si].nr_flags
        mov     di,ds:[si].nr_soff

ifdef WOW_x86
.386
;; WOW selector optimiaztion
        cCall   get_physical_address,<pseg>
        shl     edx,16
        mov     dx,ax
        mov     rover_2,edx

        mov     ax,FLAT_SEL
        mov     ds,ax

        movzx   edi,di
        add     edi,edx                 ; es:edi -> pseg:0
else
        mov     ds, pseg
endif
        pop     dx
        pop     ax
        cmp     bl,NRSSEG
        je      srsseg
        cmp     bl,NRSPTR
        je      srsptr
        cmp     bl,NRSOFF
        je      srsoff
        cmp     bl,NRSBYTE
        je      srsbyte

        krDebugOut DEB_ERROR, "Unknown fixup #BX"
ife     KDEBUG
        jmps    nextrle
endif

nextrlenz:                              ; if NZ at this point, something broke
        jz      nextrle
;       jnz     srfail
        jmp     srfail

nextrle:
        mov     ax,1
        add     si,SIZE NEW_RLC
        dec     creloc
        jle     srdone2
        jmp     srloop

srdone2:jmp     srdone

; Lo-byte fixup chain (always additive)



beg_fault_trap  srfailGP
srsbyte:
ifdef WOW_x86
        add     ds:[edi],al
else
        add     ds:[di],al
endif
        jmp     nextrle

; Offset fixup chain
srsoff:
        cmp     fOsfixup,0              ; is it a floating-pt. osfixup?
        jnz     srsosfixup              ; yes, goto special case code.

        mov     dx, ax                  ; fall through into segment fixup

; Segment fixup chain
srsseg:
        jcxz    srsseg1
ifdef WOW_x86
        add     ds:[edi],dx
else
        add     ds:[di],dx
endif
        jmp     nextrle

srsseg1:
        or      cx, -1
srsseg2:
        mov     bx,dx
ifdef WOW_x86
        xchg    word ptr ds:[edi],bx
        movzx   edi,bx
        add     edi,rover_2
else
        xchg    ds:[di],bx
        mov     di,bx
endif
        inc     bx
        loopnz  srsseg2                 ; if CX == 0, we're broken
        jmp     nextrlenz

; Segment:Offset fixup chain
srsptr:
        jcxz    srsptr1
ifdef WOW_x86
        add     word ptr ds:[edi],ax
        add     word ptr ds:[edi+2],dx
else
        add     ds:[di],ax
        add     ds:[di+2],dx
endif
        jmp     nextrle

srsptr1:
        or      cx, -1
srsptr2:
        mov     bx,ax
ifdef WOW_x86
        xchg    word ptr ds:[edi],bx
        mov     word ptr ds:[edi+2],dx
        movzx   edi,bx
        add     edi,rover_2
else
        xchg    ds:[di],bx
        mov     ds:[di+2],dx
        mov     di,bx
endif
        inc     bx
        loopnz  srsptr2
        jmp     nextrlenz

; osfixup for floating-point instructions

fINT    EQU     0CDH
fFWAIT  EQU     09BH
fESCAPE EQU     0D8H
fFNOP   EQU     090H
fES     EQU     026H
fCS     EQU     02Eh
fSS     EQU     036h
fDS     EQU     03Eh
BEGINT  EQU     034h

FIARQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fDS)
FISRQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fSS)
FICRQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fCS)
FIERQQ  EQU     (fINT + 256*(BEGINT + 8)) - (fFWAIT + 256*fES)
FIDRQQ  EQU     (fINT + 256*(BEGINT + 0)) - (fFWAIT + 256*fESCAPE)
FIWRQQ  EQU     (fINT + 256*(BEGINT + 9)) - (fFNOP  + 256*fFWAIT)
FJARQQ  EQU     256*(((0 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
FJSRQQ  EQU     256*(((1 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)
FJCRQQ  EQU     256*(((2 shl 6) or (fESCAPE and 03Fh)) - fESCAPE)

osfixuptbl  label word                  ; table has 12 entries - six for int
        DW      FIARQQ, FJARQQ
        DW      FISRQQ, FJSRQQ
        DW      FICRQQ, FJCRQQ
        DW      FIERQQ, 0h
        DW      FIDRQQ, 0h
        DW      FIWRQQ, 0h
osfixuptbllen = $-osfixuptbl            ; six to convert FWAIT to NOP
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      fFNOP - fFWAIT, 0
        DW      FIWRQQ, 0h              ; leave this one in for emulator

srsosfixup:
ifdef WOW_x86
        add     word ptr ds:[edi][0],ax
        add     word ptr ds:[edi][1],dx
else
        add     ds:[di][0],ax
        add     ds:[di][1],dx
endif
        mov     fOsfixup,0              ; clear flag for next record.
        jmp     nextrle
end_fault_trap

srfailGP:
;       fault_fix_stack
        pop     ax
        pop     dx
        krDebugOut DEB_ERROR, "Fault in SegReloc #AX #DX"
srfail:
if KDEBUG
        mov     bx,hexe
;       xor     bx,bx
        krDebugOut DEB_ERROR, "%BX1 has invalid relocation record"
;       kerror  ERR_LDRELOC,<Invalid relocation record in >,es,bx
endif
        xor     ax,ax
        jmps    srdone


; OSFIXUPs for floating-point instructions.
;
; The fixup is applied by adding the first word (ax) to the
; coprocessor intruction, and for fixups 1-3 also adding the
; second word (dx) to the instruction+1. Generalize, by having
; dx=0 for fixups 4-6 and always adding dx to instruction+1.
;
; Note: the relocation type is marked NRSOFF by the linker,
; but we must apply these fixups differently.  Here we know
; it is an osfixup, so set the flag fOsfixup so that later
; when we test the type, we can apply the fixup correctly.
;
; 06-Oct-1987. davidhab.

; Wed 10-May-1989 19:28:50  -by-  David N. Weise  [davidw]
;
; Actually, due to the way the emulator does fwait polling
; of exceptions we must send the NOP FWAIT pairs to the
; emulator even if a math coprocessor is available.

srosfixup:
        mov     es,hexe
        test    es:[ne_flags],NEPROT    ; OS/2 app
        jnz     srosf_skip              ;  then never fix up!
        SetKernelDS     es
        mov     bx,ds:[si].nr_mod       ; get OSFIXUP id
        cmp     bx,6                    ; is it NOP, FWAIT?
        jz      srosfixup1              ;  if so always fix up!
        cmp     f8087,94                ; 8087 installed?
        jnz     srosfixup1              ; No, do OSFIXUP processing
        cmp     fastFP,0
        je      srosf_skip
        dec     bx
        shl     bx, 2
        cmp     bx, osfixuptbllen
        jae     srosfixup2
        add     bx, osfixuptbllen
        jmps    fast


srosf_skip:
        jmp     nextrle                 ; Yes, skip OSFIXUP processing

srosfixup1:
        dec     bx                      ; offset into table is (n-1) * 4
        shl     bx,1
        shl     bx,1
        cmp     bx,osfixuptbllen        ; Make sure it is within table bounds
        jae     srosfixup2              ; No, bad relocation
fast:   mov     ax,osfixuptbl[bx+0]     ; Yes, get relocation value from table
        mov     dx,osfixuptbl[bx+2]     ; get second part of fixup
        mov     fOsfixup,1              ; set flag to mark our special type.
        jmp     dorle                   ; Go apply relocation

srosfixup2:
        jmp     srbadrle
        UnSetKernelDS   es

srdone:
        push    ax

ifndef WOW 
;------------------Original win31 source--------------------------------
        mov     cx, old_access
        test    cl, DSC_CODE_BIT
        jz      short no_reset_access
        mov     bx, pseg

        push    ds
if ROM and PMODE32
        SetKernelDS
        mov     ds, gdtdsc
        UnsetKernelDS
else
        mov     ds, gdtdsc
endif
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
if 0 ;;ROM and KDEBUG
        call    CheckROMSelector
endif
        pop     ds

else ; ******** WOW ADDED SOURCE

ifdef WOW_x86
;------------------WOW source for X86 platforms-------------------------
ife PMODE32
        mov     cx, old_access
        test    cl, DSC_CODE_BIT
        jz      short no_reset_access
        mov     bx, pseg
        DPMICALL 0009h
endif; PMODE32

else; WOW_x86
;------------------WOW source for NON-X86 platforms---------------------
        mov     cx, old_access
        test    cl, DSC_CODE_BIT
        jz      short no_reset_access
        mov     bx, pseg

ife PMODE32
        DPMICALL 0009h
else
        push    ds
        mov     ds, gdtdsc
        and     bl, not 7
        mov     word ptr ds:[bx].dsc_access, cx
        pop     ds

endif; PMODE32
endif; WOW_x86
endif; ******** WOW ADDED SOURCE
;----------------------End of WOW changes-------------------------------

no_reset_access:
        mov     ax, hseg
        test    al, 1
        jnz     srdone_nounlock
        cCall   GlobalUnLock,<ax>
srdone_nounlock:
        pop     ax
cEnd


sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\mapdata.asm ===
TITLE	MAPDATA - Map DS to kernel's data segment

include kernel.inc


; This code could go almost anywhere, but didn't really belong in kdata.asm


sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes SS,NOTHING

KDataSeg	dw	seg _DATA
public	KDataSeg

cProc	MapDStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	ds,ax
;;;	pop	ax
	mov	ds, cs:KDataSeg
	ret
cEnd	nogen

sEnd	NRESCODE



sBegin	MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing
assumes	ss, nothing

MKDataSeg	dw	seg _DATA
public	MKDataSeg

cProc	MISCMapDStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	ds,ax
;;;	pop	ax
	mov	ds, cs:MKDataSeg
	ret
cEnd	nogen


if 0	;----------------------------------------------------------------
cProc	MISCMapEStoDATA,<PUBLIC,NEAR>
cBegin	nogen
;;;	push	ax
;;;	mov	ax,seg _DATA
;;;	mov	es,ax
;;;	pop	ax
	mov	es, cs:MKDataSeg
	ret
cEnd	nogen
endif	;----------------------------------------------------------------

sEnd	MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lhandle.asm ===
TITLE	HANDLE - Handle Table Manager

include kernel.inc

; This code assumes the following conditions
;
errnz	<lhe_address>

DataBegin

;externW <pGlobalHeap,hGlobalHeap>

DataEnd

sBegin	CODE
assumes CS,CODE

; These are all of the internal subroutines defined in this source file.
;
;	PUBLIC	halloc, lhdref, henum


;-----------------------------------------------------------------------;
; halloc								;
;									;
; Allocates a local handle for a block.					;
;									;
; Arguments:								;
;	AX = block that needs a handle					;
;	DS:DI = address of local arena infomation structure		;
;									;
; Returns:								;
;	AX,BX,CX = handle for that block				;
;	DX preserved							;
;									;
; Error Returns:							;
;	AX = 0	if no handles available					;
;	DX = original AX						;
;									;
; Registers Preserved:							;
;	DI,SI,DS,ES							;
;									;
; Registers Destroyed:							;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Wed Oct 01, 1986 05:44:44p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	halloc,<PUBLIC,NEAR>
cBegin nogen
	mov	bx,[di].hi_hfree
	or	bx,bx
	jnz	have_a_handle
	push	ax
	push	dx
	mov	cx,[di].hi_hdelta
	jcxz	hafail
	push	si
	push	es
	call	[di].hi_hexpand
	pop	es
	pop	si
	jcxz	hafail
	mov	bx,ax
	pop	dx
	pop	ax
have_a_handle:
	xor	cx,cx
	errnz	<lhe_flags - he_flags>
	mov	word ptr [bx].lhe_flags,cx	; Zero lock count and flags
	errnz	<lhe_count-lhe_flags-1>
	errnz	<lhe_link - he_link>
	xchg	[bx].lhe_link,ax		; Remove handle from head of chain
	errnz	<lhe_address-lhe_link>	; and store true address of object
	mov	[di].hi_hfree,ax	; Update head of handle free list
	mov	ax,bx			; Return handle to caller
	mov	cx,ax
	ret

hafail:
	xor	ax,ax
	pop	dx			; Flush stack
	pop	dx			; Return original AX in DX
	ret				; return error
cEnd nogen

;-----------------------------------------------------------------------;
; lhfree 								;
; 									;
; Frees the given local handle and returns a handle to the freelist.	;
; 									;
; Arguments:								;
;	SI = handle to free						;
; 									;
; Returns:								;
;	AX =  0 if valid handle						;
; 									;
; Error Returns:							;
;	AX = -1 if handle already free					;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:14:25p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhfree,<PUBLIC,NEAR>
cBegin nogen
	or	si,si			; Ignore zero handles
	jz	hf1
	mov	ax,HE_FREEHANDLE	; Mark handle as free
	xchg	word ptr [si].lhe_flags,ax
	errnz	<2-lhe_flags>
	inc	ax			; Already free?
	jz	hf2			; Yes, return error
	errnz	<1+HE_FREEHANDLE>
	mov	ax,si			; Push handle on head of freelist
	xchg	[di].hi_hfree,ax
	mov	[si].lhe_link,ax
hf1:
	xor	ax,ax			; Return zero
	ret
hf2:
	dec	ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lhdref								;
; 									;
; Dereferences a local handle.						;
; 									;
; Arguments:								;
;	SI = handle							;
; 									;
; Returns:								;
;	AX = address of client data or zero for discarded objects	;
;	CH = lock count							;
;	CL = zero or LHE_DISCARDED flag					;
;	ZF = 1 AX = 0 and CL != 0					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:16:49p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhdref,<PUBLIC,NEAR>
cBegin nogen
	xor	ax,ax
	mov	cx,word ptr [si].lhe_flags
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>
	inc	cx
	jz	lhdref1
	errnz	<1+LHE_FREEHANDLE>
	dec	cx
	and	cl,LHE_DISCARDED
	jnz	lhdref1
	mov	ax,[si].lhe_address
lhdref1:
	or	ax,ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; henum									;
; 									;
; Enumerates the allocated handles in the local handle table with the	;
; specified discard level.						;
; 									;
; Arguments:								;
;	SI = zero first time called.  Otherwise contains a pointer	;
;	     to the last handle returned.				;
;	CX = #handles remaining.  Zero first time called.		;
;	DI = address of local arena information structure.		;
; 									;
; Returns:								;
;	SI = address of handle table entry				;
;	CX = #handles remaining, including the one returned.		;
;	ZF = 1 if SI = 0 and no more handle table entries.		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	AX								;
;									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 04:19:15p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	henum,<PUBLIC,NEAR>
cBegin nogen
	or	si,si		    ; Beginning of enumeration?
	jnz	lcdhenext	    ; No, return next handle
	mov	ax,[di].hi_htable   ; Yes, start with last handle table block

lcdhtloop:
	mov	si,ax		    ; SI = address of handle table block
	or	si,si		    ; Any more handle table blocks?
	jz	lcdheall	    ; No, return zero
	lodsw			    ; Get # handles in this block
	errnz	ht_count
	mov	cx,ax		    ; into CX
lcdheloop:			    ; Loop to process each handle table entry
	mov	ax,word ptr [si].lhe_flags
	errnz	<lhe_flags - he_flags>
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>

	inc	ax		    ; Free handle?
	jz	lcdhenext	    ; Yes, skip this handle
	errnz	<1+LHE_FREEHANDLE>
	errnz	<LHE_FREEHANDLE - HE_FREEHANDLE >
	dec	ax

	cmp	[di].hi_dislevel,0  ; Enumerating all allocated handles?
	je	lcdheall	    ; Yes, return this handle

	test	al,LHE_DISCARDED    ; No, handle already discarded?
	jnz	lcdhenext	    ; Yes, skip this handle

	and	al,LHE_DISCARDABLE  ; Test if DISCARDABLE
	cmp	[di].hi_dislevel,al ; at the current discard level
	jne	lcdhenext	    ; No, skip this handle

	or	ah,ah		    ; Is handle locked?
	jnz	lcdhenext	    ; Yes, skip this handle

lcdheall:
	or	si,si		    ; No, then return handle to caller
	ret			    ; with Z flag clear

lcdhenext:
	lea	si,[si].SIZE LocalHandleEntry    ; Point to next handle table entry
	errnz	<LocalHandleEntry - HandleEntry>
	loop	lcdheloop	    ; Process next handle table entry
	lodsw			    ; end of this block, go to next
	jmp	lcdhtloop
cEnd nogen

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ldutil.asm ===
TITLE	LDUTIL - Loader support procedures

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include protect.inc
.list

;externFP GetCurrentPDB

if ROM and PMODE32
externFP HocusROMBase
endif

DataBegin

;externB Kernel_Flags
;externW AltfEEMS
externW headTDB
externW hExeHead
;externW pGlobalHeap
;externW MyCSDS
externW topPDB
externW cur_dos_pdb
externW Win_PDB
externW curTDB
;externW segSwapArea

DataEnd

externFP CallWEP

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyUpper
externNP MyLock
externNP LoadNRTable
externNP LoadSegment
externNP GetOwner
externNP GetCachedFileHandle

if SDEBUG
externNP DebugFreeSegment
endif

externFP IGlobalAlloc
externFP IGlobalFree
;externFP IGlobalLock
externFP IGlobalUnfix
externFP IGlobalHandle
externFP GlobalFlags
externFP FreeNRTable
externFP Int21Handler

ifdef	FE_SB			;declare it.
externNP MyIsDBCSLeadByte	;Use near one as we are in the same seg
endif

if ROM
externFP FreeSelector
externNP alloc_data_sel16
endif

cProc	SafeCall,<PUBLIC,FAR>
	parmD	Addr
cBegin
	call	Addr
cEnd

;-----------------------------------------------------------------------;
; GetExePtr								;
; 									;
; Returns the exe header pointer for the passed handle.			;
; 									;
; Arguments:								;
;	parmW   hinstance						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon Aug 03, 1987 04:40:45p  -by-  David N. Weise   [davidw]          ;
; Rewrote it to work with expanded memory.  Note that if the handle	;
; passed is truly bogus we could still catch a page fault under		;
; Win386.								;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetExePtr,<PUBLIC,FAR>
	parmW   hinstance
cBegin
	mov	ax,hinstance
	test	ax,GA_FIXED		; Passed a segment address?
	jz	not_module
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC	;  Yes, does it point to a Module?
	jz	gxdone

not_module:
	SetKernelDS	es
	mov	cx,headTDB
	assumes	es, nothing
find_TDB:
	jcxz	last_chance
	mov	es,cx
	cmp	ax,es:[TDB_module]
	jz	found_it
	mov	cx,es:[TDB_next]
	jmp	find_TDB
found_it:
	mov	ax,es:[TDB_pModule]
	jmps	gxdone

last_chance:				; The problem here is that USER
	cCall	MyLock,<ax>		;  KNOWS that hinstance is but
	or	ax,ax			;  the handle to his data segment.
	jz	gxdone
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	je	gxdone

	cCall	GetOwner,<ax>
	or	ax,ax
	jz	gxfail
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	je	gxdone

	; The owner,ax, is now a PDB. We gotta find the TDB
	SetKernelDS	es
	mov	cx,headTDB
	assumes	es, nothing
find_PDB:
	jcxz	gxfail
	mov	es,cx
	cmp	ax,es:[TDB_PDB]
	jz	found_PDB
	mov	cx,es:[TDB_next]
	jmp	find_PDB
found_PDB:
	mov	ax,es:[TDB_pModule]
	jmps	gxdone


gxfail:
if KDEBUG
	xor	cx,cx
	kerror	ERR_LDMODULE,<Invalid module handle>,cx,hinstance
endif
	xor	ax,ax
gxdone:	mov	cx,ax

cEnd

;-----------------------------------------------------------------------;
;									;
;  GetExpWinVer - return the expected Windows version for a given	;
;		  module handle						;
;									;
; Arguments:								;
;	parmW   hinstance						;
; 									;
; Returns:								;
;	AX = expected windows version					;
;	DX = BOOL proportional font flag				;
;									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
; Fri 06 Jan 1989  -- Written by Sankar.				;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetExpWinVer,<PUBLIC,FAR>, <si,di>
	parmW   hInstance
cBegin	
	cCall	GetExePtr,<hInstance>
	or	ax,ax
	jz	err_GetExpWinVer
	mov	es,ax
	mov	ax,es:[ne_expver]
	mov	dx,es:[ne_flags]
	and	dx,NEWINPROT
; error if offsets don't match our defines - In which case find the right
; offsets and changes the defines in mvdm\inc\tdb16.h

.erre (NE_LOWINVER_OFFSET EQ ne_expver)
.erre (NE_HIWINVER_OFFSET EQ ne_flags)

err_GetExpWinVer:

cEnd	


;-----------------------------------------------------------------------;
; MyAlloc								;
;									;
; Private interface to memory manager                                   ;
; 									;
; Arguments:								;
;	parmW   aflags							;
;	parmW   nsize							;
;	parmW   nelem							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = Handle							;
;	DX = Seg Address						;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	BX,CX,ES							;
; 									;
; Calls:								;
;	GlobalAlloc							;
;	MyLock								;
; 									;
; History:								;
; 									;
;  Wed Apr 08, 1987 06:22:57a  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;
	assumes	ds, nothing
	assumes	es, nothing


cProc	MyAllocLinear,<PUBLIC,NEAR>
	; Same as MyAlloc, except for size parameter
	parmW   aflags
	parmD   dwBytes
cBegin
	jmps	MyAllocNBD
cEnd


	assumes	ds, nothing
	assumes	es, nothing

cProc	MyAlloc,<PUBLIC,NEAR>
	parmW   aflags
	parmD	dwBytes
;	parmW   nsize
;	parmW   nelem
cBegin
	xor	dx,dx
	mov	ax,seg_dwBytes	;nsize
	mov	cx,off_dwBytes	;nelem
	jcxz	ma3
ma2:
	shl	ax,1
	rcl	dx,1
	loop	ma2
ma3:
	mov	seg_dwBytes, dx
	mov	off_dwBytes, ax
MyAllocNBD:
	SetKernelDS	es
	mov	cx,aflags
	mov	al,NSTYPE
	and	al,cl			; al has SEGTYPE
	mov	bx,NSDISCARD
	and	bx,cx
	jz	@F
	shr	bx,1
	shr	bx,1
	shr	bx,1
	shr	bx,1			; BX has GA_DISCARDABLE
	cmp	al,NSCODE
	jne	@F
	or	bl,GA_DISCCODE		; Allocating discardable code
@@:

	cmp	al,NSDATA
	jne	@F
	and	cx,NOT NSWINCODE	; undo Excel bogusness
	or	bl,GA_DGROUP		; Allocating automatic data segment
@@:

	test	cl,NSMOVE
	jz	@F
	or	bl,GA_MOVEABLE
@@:

	cmp	al,NSTYPE
	jz	@F
	or	bh,GA_CODE_DATA
@@:

	cCall	IGlobalAlloc,<bx,dwBytes>	 ;dxax>

	assumes	es, nothing
	push	ax
	test	al,GA_FIXED
	jnz	@F
	cCall	MyLock,<ax>
@@:
	pop	dx
cEnd


;
; MyLock( hseg ) - Procedure to return the physical segment address of
; the passed handle.
;
;;;cProc	MyLock,<PUBLIC,NEAR>
;;;	parmW   hseg
;;;cBegin
;;;	cCall	IGlobalHandle,<hseg>
;;;	xchg	dx,ax
;;;cEnd


;-----------------------------------------------------------------------;
; MyFree								;
; 									;
; Frees a segment allocated by MyAlloc.					;
; 									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Dec 09, 1986 12:48:43p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	MyFree,<PUBLIC,NEAR>
	parmW   hseg
	localW  pseg
cBegin
	mov	bx,hseg
	or	bx,bx
	jz	mf3
	mov	ax,bx
	xor	cx,cx
	test	bl,GA_FIXED
	jnz	mf0a

	push	bx
	cCall	GlobalFlags,<bx>
	mov	cx, ax
	xor	ax, ax
	pop	bx
	xchg	ch, cl
	test	cl, HE_DISCARDED
	jnz	mf0a
	mov	ax, bx
	HtoS	ax

mf0a:
if KDEBUG
	push	cx
endif
	mov	pseg,ax
	or	ax,ax
	jz	mf1
mf0:
if SDEBUG
	cCall	DebugFreeSegment,<pseg,0>
endif
mf1:
if KDEBUG
	pop	cx
	or	ch,ch
	jz	mf2
mf1a:
	push	cx
	cCall	IGlobalUnfix,<hseg>	 ; Prevent RIP if freeing locked DS
	pop	cx
	dec	ch
	or	ch,ch			; If still lock, do it again
	jnz	mf1a
endif
mf2:
	cCall	IGlobalFree,<hseg>
mf3:
cEnd

;-----------------------------------------------------------------------;
; EntProcAddress
;
; Returns the fixed address of a procedure.
;
; Entry:
;
; Returns:
;	DX:AX = thunk for moveable
;	DX:AX = procedure for fixed
;	AX = constant, ES:BX => constant for absolutes
; Registers Destroyed:
;
; History:
;  Wed 30-Nov-1988 19:39:05  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	EntProcAddress,<PUBLIC,NEAR>,<si,di>
	parmW	hExe
	parmW	entno
if KDEBUG
	parmW	bNoRip		; if 1 don't RIP for error, 0 -> do the RIP
endif

cBegin
	mov	es,hExe
	mov	cx,entno
	and	cx,7fffh		; clear ResidentName bit (#5108 donc)
	jcxz	entfail
	dec	cx
	mov	si,es:[ne_enttab]

entloop:
	mov	ax, es:[si.PM_entstart]
	cmp	cx, ax			; Below this block?
	jb	entfail			;   yes, must be invalid!
	cmp	cx, es:[si.PM_entend]	; Above this block?
	jae	entnext			;  yes, go to next block
	sub	cx, ax			; Found the right block, get offset
	mov	bx, cx
	shl	cx, 1
	add	bx, cx
	add	bx, cx			; bx = cx*5
	lea	si, [si+bx+size PM_entstruc]
	mov	bx, si
	jmps	gotent
entnext:
	mov	si, es:[si.PM_entnext]	; Next block
	or	si, si
	jnz	entloop
	jmps	entfail

entfail:
if KDEBUG
	cmp	bNoRip,0
	jnz	dont_rip_here
	mov	bx,entno
	krDebugOut <DEB_WARN or DEB_krLoadSeg>, "Invalid ordinal reference (##BX) to %ES1"
;	kerror	ERR_LDORD,<Invalid ordinal reference to >,es,bx
dont_rip_here:
endif
	xor	dx,dx
	xor	ax,ax
	jmps	entdone

; Here if the current block has the entry we want

gotabs:
	add	bx,pentoffset		; make ES:BX point to constant (SLIME!)
	mov	dx,-1			; make != 0 since abs might be!
	jmps	gotent1			; Offset is symbol value

gotent:
	xor	ax, ax
	mov	al, es:[bx].penttype 	; Get segno/type field
	mov	si,es:[bx].pentoffset
	cmp	al,ENT_ABSSEG		; If segno field absoulute segment
	je	gotabs			; Yes, have absolute symbol

	cmp	al, ENT_MOVEABLE
	je	gotmoveable

	.errnz	10 - SIZE NEW_SEG1
	; ax = segno
	push	bx
	mov	bx, es:[ne_segtab]	; see if really fixed
	mov	cx, ax			; look up in seg table
	dec	cx
	shl	cx, 1			; get segtable + (segno-1)*10
	add	bx, cx
	shl	cx, 2
	add	bx, cx
	test	es:[bx].ns_flags, NSMOVE + NSALLOCED
	pop	bx
	jnz	gotmoveable

	mov	cx,-1			; Fixed, make sure it's loaded
	cCall	LoadSegment,<es,ax,cx,cx>
	or	ax,ax
	mov	dx,ax
	jnz	gotent1
	jmp	entfail

gotmoveable:
	xor	ax,ax
	mov	al,es:[bx].pentsegno	; Segment number
	dec	ax
	shl	ax,1
	mov	di,ax
	shl	ax,2
	add	di,ax
	.errnz	10 - SIZE NEW_SEG1
	add	di,es:[ne_segtab]

	mov	dx,es:[di].ns_handle
	or	dx, dx
	jnz	ok
	mov	ax, dx			; No handle, probably from an aborted
	jmps	entdone			; LoadModule - just return 0:0
ok:

	Handle_To_Sel	dl

gotent1:
	mov	ax,si

entdone:
	mov	cx,ax
	or	cx,dx
cEnd


;-----------------------------------------------------------------------;
; FindOrdinal								;
; 									;
; Searches the resident and non-resident name tables for a procedure	;
; name and return its corresponding entry ordinal.			;
; 									;
; Arguments:								;
;	parmW   hExe							;
;	parmD	lpname	pointer name, strings starts with length	;
;	parmW	fh	file handle NOT to be discarded from cache	;
; 									;
; Returns:								;
;	AX = ordinal number						;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	MyUpper								;
;	LoadNRTable							;
;	FreeNRTable							;
; 									;
; History:								;
; 									;
;  Tue 09-May-1989 18:38:04  -by-  David N. Weise  [davidw]		;
; Added the batching if out of memory.					;
;									;
;  Thu Sep 17, 1987 08:55:05p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block and fixed it.				;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

CLNRBUFFER	equ	150

cProc	FindOrdinal,<PUBLIC,NEAR>,<si,di>
	parmW   hExe
	parmD	lpname
	parmW	fh

if ROM
	localW	fInROM
endif
	localD	oNRTable		; if batching, continue here
	localV	LoadNRbuffer,CLNRBUFFER ; if batching this is temp buffer
cBegin
	xor	ax,ax
	mov	oNRTable.hi,ax
	mov	oNRTable.lo,ax
if ROM
	mov	fInROM,ax		; assume module not in ROM
endif
	les	si,lpname
	cmp	byte ptr es:[si+1],'#'
	je	foint

fonorm:	push	ds
	mov	ds,hExe
if ROM
	test	ds:[ne_flags],NEMODINROM	; is module actually in ROM?
	jz	@f
	inc	fInROM
@@:
endif
	mov	si,ds:[ne_restab]
	cld

foinit:	xor	ax,ax			; Skip module name or description
	lodsb
	add	si,ax
	inc	si
	inc	si

foloop: lodsb				; get length of entry
	les	di,lpname
	mov	cx,ax
	jcxz	fodone			; no more entries?
	cmp	es:[di],al		; do lengths match?
	jne	noteq
	inc	di
fo_find:
	mov	al,es:[di]
	call	MyUpper
	mov	bl,ds:[si]
	inc	si
	inc	di
	cmp	al,bl
	jne	noteq1
	loop	fo_find
;	repe	cmpsb
;	jne	noteq
	lodsw				; get ordinal number!
	mov	bx,ds
	pop	ds
	cmp	hExe,bx 		; did we load the nrtable?
	jnz	foexit_j
	jmp	foexit1
foexit_j:
	jmp	foexit

noteq1:	dec	cx
noteq:	add	si,cx
	inc	si
	inc	si
	jmps	foloop

; Here if pName points to string of the form:  #nnnn

foint:	lods	byte ptr es:[si]	; nbytes = *pName++
	mov	cl,al
	xor	ch,ch

	dec	cx			; ignore #
	inc	si

	xor	ax,ax			; sum = 0
foint0:	mov	dx,ax
	lods	byte ptr es:[si]	; c = *pName++
	sub	al,'0'			; if (!isdigit(c))
	cmp	al,9
	ja	fonorm			;	treat like normal
	xor	ah,ah
	mov	bx,ax			; sum = (sum * 10) + (c - '0')
	mov	al,10
	mul	dx
	add	ax,bx
	loop	foint0
	jmp	foexit1

fodone:	mov	bx,ds
	pop	ds
;%out help me				; what was this line for?
	mov	cx,oNRTable.hi
	cmp	cx,oNRTable.lo
	jnz	fo_batching
	cmp	hExe,bx 		; have we looked at NRTable yet?
if ROM
	jne	foexit_j
else
	jne	foexit
endif

if ROM
	cmp	fInROM,0		; this module in ROM?
	jz	fo_nr_not_in_rom
	cCall	FindROMNRTable,<hExe>	; yes, get selector to ROM NR Table
	mov	fInROM,ax
	push	ds
	mov	ds,ax			; ds -> ROM NR table
	xor	bx,bx
	mov	bl,ds:[0]		; skip over first NR table entry
	lea	si,[bx+3]		;   (the module description string)
	xor	ax,ax
	jmp	foloop
fo_nr_not_in_ROM:
endif

fo_batching:
	xor	bx,bx
	mov	ax,fh
;;;	cmp	ax,-1
;;;	jz	no_file_handle

	SetKernelDS	ES
;;;	mov	dx, topPDB
;;;	mov	es, curTDB
;;;	UnSetKernelDS	es
;;;	mov	ax, es:[TDB_PDB]
;;;
;;;	cmp	dx, cur_dos_pdb
;;;	jz	@F
;;;	mov	bx,ax
;;;@@:
	mov	bx, Win_PDB
	UnSetKernelDS

	mov	dx, -1
	cCall	GetCachedFileHandle,<hexe,ax,dx>
no_file_handle:
	push	bx
	lea	cx,LoadNRbuffer
	mov	dx,CLNRBUFFER
	cCall	LoadNRTable,<hexe,ax,oNRTable,ss,cx,dx>
if KDEBUG
	push	es
	push	di
	les	di, [lpName]
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "    looking for @ES:DI"
	pop	di
	pop	es
endif
	pop	si
	or	si,si
	jz	@F
;;;	push	ax
;;;	push	bx
;;;	mov	bx,si
;;;	mov	ah,50h
;;;	DOSCALL
;;;	pop	bx
;;;	pop	ax
	push	es
	SetKernelDS	ES
	mov	Win_PDB, si
	pop	es
	UnSetKernelDS	ES
@@:	mov	oNRTable.hi,cx
	mov	oNRTable.lo,bx
	push	ds
	mov	ds,dx
	mov	si,ax
	or	ax,dx			; did we get a table?
	jz	@F
	xor	ax,ax
	jmp	foloop
@@:	pop	ds
foexit: push	ax
if ROM
	cmp	fInROM,0		; this module in ROM
	jz	@f
	cCall	FreeSelector,<fInROM>	; yes, free ROM NR table selector
	jmps	foexit0
@@:
endif
	mov	ax,ne_nrestab
	cCall	FreeNRTable,<hExe,ax>
foexit0:
	pop	ax
foexit1:

;??? commented out 3/7/88 by rong
;??? we should put this back in once everyone has the new keyboard driver
;if KDEBUG
;	or	ax,ax
;	jnz	foexit2
;	les	bx,lpname
;	inc	bx
;	kerror	ERR_LDNAME,<Invalid procedure name >,es,bx
;	xor	ax,ax
;foexit2:
;endif
cEnd


if ROM	;----------------------------------------------------------------

;-----------------------------------------------------------------------
; FindROMNRTable
;
; Returns a selector to the ROM copy of the Non-Resident name table for
; a module stored in ROM.
;
; Arguments:
;	parmW	hExe
;
; Returns:
;	AX = selector mapping NR table
;
;-----------------------------------------------------------------------

	assumes	ds, nothing
	assumes	es, nothing

cProc	FindROMNRTable,<PUBLIC,NEAR>,<ds>
	parmW   hExe
cBegin
	mov	ds,hExe
	mov	ax,word ptr ds:[ne_nrestab]
	mov	bx,word ptr ds:[ne_nrestab+2]
	cCall	alloc_data_sel16,<bx,ax,1000h>
if PMODE32
	cCall	HocusROMBase, <ax>
endif
if KDEBUG
	or	ax,ax
	jnz	@f
	int	3
@@:
endif
cEnd

endif ;ROM	---------------------------------------------------------

; Search the list of new EXE headers for the passed executable file name
; (no path)
;
; this must be resident so we can search for modules in the file handle
; cache from the int 21 handler -- craigc
;

cProc	ResidentFindExeFile,<PUBLIC,FAR>,<ds,si,di>
    parmD   pname
cBegin
	SetKernelDS

	mov	ax,hExeHead
ffloop:
	or	ax,ax
	jz	ffdone
	mov	es,ax
	mov	di,es:[ne_pfileinfo]
	or	di,di
	jz	ffnext

;
;	Double Byte Character is not able to search from the end of string,
;	so this function must search from the top of string.
;
ifdef FE_SB
	lea	si,[di.opFile]		; get address of file name
	mov	cl,es:[di.opLen]	; get structure length
	xor	ch,ch
	add	cx,di
	mov	di,cx			; save end address
	sub	cx,si			; get length of file name
	mov	bx,si			; save top address of file name
	cld
delineator_loop:
	lods	byte ptr es:[si]
	call	MyIsDBCSLeadByte
	jc	delineator_notlead	; if not DBCS lead byte
	dec	cx
	jcxz	delineator_next
	inc	si
	loop	delineator_loop
	jmp	delineator_next
delineator_notlead:
	cmp	al,"\"
	jz	found_delineator
	cmp	al,":"
	jz	found_delineator
	loop	delineator_loop
	jmp	delineator_next
found_delineator:
	mov	bx,si			; save delineator address
	loop	delineator_loop
delineator_next:
	xchg	bx,di			; set address of file name to di
	sub	bx,di			; get lenfth of file name
else
	mov	si,di
	xor	cx,cx
	mov	cl,es:[di]
	add	si,cx
	dec	si
	std
	xor	bx,bx
delineator_loop:			; look for beginning of name
	lods	byte ptr es:[si]
	cmp	al,"\"
	jz	found_delineator
	cmp	al,":"
	jz	found_delineator
	inc	bx
	loop	delineator_loop
	dec	si
found_delineator:			; ES:SI -> before name
	mov	di,si
	inc	di
	inc	di
endif

	lds	si,pname
	UnSetKernelDS
	mov	cx,bx
	cld
	repe	cmpsb
	mov	ax,es
	je	ffdone
ffnext:
	mov	ax,word ptr es:[ne_pnextexe]
	jmp	ffloop
ffdone:
cEnd

sEnd	CODE

externFP FarLoadSegment

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP DelModule
externNP MapDStoDATA

cProc	FindExeFile,<PUBLIC,NEAR>
    parmD   pFile
cBegin
    cCall   ResidentFindExeFile, <pFile>
cEnd


; Search the list of new EXE headers for the passed executable name

cProc	FindExeInfo,<PUBLIC,NEAR>,<ds,si,di>
    parmD   pname
    parmW   nchars
cBegin

	cCall	MapDStoDATA
	ReSetKernelDS

	mov	bx,nchars
	mov	ax,hExeHead
feloop:
	or	ax,ax
	jz	fedone
	mov	es,ax
	mov	di,es:[ne_restab]
	cmp	es:[di],bl
	jne	fenext
	inc	di
	lds	si,pname
	UnSetKernelDS
	mov	cx,bx
	repe	cmpsb
	je	fedone
fenext:
	mov	ax,word ptr es:[ne_pnextexe]
	jmp	feloop
fedone:
cEnd

cProc	FarFindExeInfo,<PUBLIC,FAR>
	parmD	pname
	parmW	nchars
cBegin
	cCall	FindExeInfo,<pname,nchars>
cEnd


;
; IncExeUsage( hExe ) - procedure to increment the usage count of this
; EXE header.  Indirectly increments the usage count of all the EXE
; headers it points to.
;
cProc	IncExeUsage,<PUBLIC,NEAR>,<ax,di>
	parmW   hexe
cBegin
	mov	cx,hexe
	jcxz	iexj
	mov	es,cx
	cmp	es:[ne_magic],NEMAGIC
	jne	iexj
	test	es:[ne_usage],8000h
	jz	iego
iexj:
	krDebugOut	<DEB_ERROR or DEB_KRLOADMOD>, "IncExeUsage(#ES) not DLL"
	jmp	iex
iego:

	cmp	es:[ne_usage], 4000h
	jb	OKusage
	krDebugOut	DEB_FERROR, "IncExeUsage: ne_usage overflow"
OKusage:

		;
		; Save time and space by saving stuff on stack
		; rather than recursing.
		;

	or	es:[ne_usage], 8000h
NextExe0:
	or	es:[ne_usage], 4000h		; Mark node visited
	inc	es:[ne_usage]
;if kdebug
;	push	ax
;	mov	ax, es:[ne_usage]
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "IncExeUsage(%ES0) #ax"
;	pop	ax
;endif
	mov	cx,es:[ne_cmod]
	jcxz	NoDeps0
	mov	di,es:[ne_modtab]
ieloop:
	push	es
	cmp	word ptr es:[di], 0
	je	ieloop1
	lar	ax, es:[di]			; Make sure valid selector
	jnz	ieloop1
	mov	es, es:[di]
	cmp	es:[ne_magic],NEMAGIC
	jne	ieloop1
	test	es:[ne_usage], 0C000h
	jnz	ieloop1
	push	cx
	push	di				; Fake recursion
	jmp	NextExe0
NextExeDone0:					; Return from fake recursion
	pop	di
	pop	cx
ieloop1:
	pop	es
	add	di,2
	loop	ieloop

NoDeps0:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone0

NextExe1:
	and	es:[ne_usage], NOT 4000h	; Mark node visited
	mov	cx,es:[ne_cmod]
	jcxz	NoDeps1
	mov	di,es:[ne_modtab]
UnMarkLoop:
	push	es
	cmp	word ptr es:[di], 0
	je	UnMarkLoop1
	lar	ax, es:[di]			; Make sure valid selector
	jnz	UnMarkLoop1
	mov	es, es:[di]
	cmp	es:[ne_magic],NEMAGIC
	jne	UnMarkLoop1
	test	es:[ne_usage], 08000h
	jnz	UnMarkLoop1
	test	es:[ne_usage], 04000h
	jz	UnMarkLoop1
	push	cx
	push	di				; Fake recursion
	jmp	NextExe1
NextExeDone1:					; Return from fake recursion
	pop	di
	pop	cx
UnMarkLoop1:
	pop	es
	add	di,2
	loop	UnMarkLoop

NoDeps1:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone1

	xor	es:[ne_usage], 8000h
iex:
cEnd

;-----------------------------------------------------------------------;
; DecExeUsage								;
; 									;
; Decrements the usage count of the given EXE header.  Indirectly	;
; decrements the usage count of all the EXE headers it points to.	;
; 									;
; Arguments:								;
;	parmW   hexe							;
; 									;
; Returns:								;
;	ZF = 1 if usage count is now zero.				;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
; 	AX,BX,CX,DX,ES							;
;									;
; Calls:								;
;	DecExeUsage							;
;	DelModule							;
; 									;
; History:								;
; 									;
;  Mon Sep 21, 1987 01:21:00p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	DecExeUsage,<PUBLIC,NEAR>,<ds,di,si>
	parmW   hexe
cBegin
	call	MapDStoDATA
	ReSetKernelDS

	xor	si,si
	mov	cx,hexe
	xor	ax,ax
	jcxz	dexj
	mov	es,cx
	cmp	es:[si].ne_magic,NEMAGIC
	jne	dexj
	test	es:[si].ne_usage,8000h
	jz	dego
dexj:
	krDebugOut	<DEB_ERROR or DEB_KRLOADMOD>, "DecExeUsage(#ES) not DLL"
	jmp	dex
dego:

		;
		; Save time and space by saving stuff on stack
		; rather than recursing.
		;

	dec	es:[si].ne_usage
	or	es:[si].ne_usage, 8000h
;if kdebug
;	push	ax
;	mov	ax, es:[si].ne_usage
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "DecExeUsage(%ES0) #ax"
;	pop	ax
;endif
NextExe2:
	or	es:[si].ne_usage, 4000h		; Mark node visited
	mov	cx,es:[si].ne_cmod
	jcxz	NoDeps2
	mov	di,es:[si].ne_modtab
MarkLoop2:
	push	es
	cmp	si, es:[di]
	je	MarkLoop3
	lar	ax, es:[di]			; Make sure valid selector
	jnz	MarkLoop3
	mov	es, es:[di]
	cmp	es:[si].ne_magic,NEMAGIC
	jne	MarkLoop3
	test	es:[si].ne_usage, 0C000h
	jnz	MarkLoop3
	push	cx
	push	di				; Fake recursion
	jmp	NextExe2
NextExeDone2:					; Return from fake recursion
	pop	di
	pop	cx
MarkLoop3:
	pop	es
	add	di,2
	loop	MarkLoop2

NoDeps2:
	mov	cx, es
	cmp	cx, hExe
	jne	NextExeDone2

        xor     cx, cx
        push    cx                              ; End of list of Exes to delete
	mov	di, hExeHead			; Scan Exes once to dec them
scan_exes:
	or	di, di
	jz	de_done
	mov	es, di
	mov	di, es:[si].ne_pnextexe
	test	es:[si].ne_usage, 4000h
	jz	scan_exes
	and	es:[si].ne_usage, NOT 4000h	; Remove the mark
	test	es:[si].ne_usage, 8000h		; Skip this one?
	jnz	scan_exes
;	krDebugOut <DEB_TRACE or DEB_krLoadMod>, "DecExeUsage dependent %ES0"
	dec	es:[si].ne_usage
        jnz     scan_exes
        push    es                              ; We will delete this one
        jmps    scan_exes


de_done:				; Call WEP each module before
	mov	bx, sp			; we free any modules
de_done0:
	mov	cx, ss:[bx]
	add	bx, 2
	jcxz	de_done1
	push	bx
	cCall	CallWEP, <cx, 0>
	pop	bx
	jmps	de_done0


de_done1:
        pop     cx                              ; Get next module to delete
        jcxz    all_deleted
        cCall   DelModule,<cx>                  ; Delete him
	jmps    de_done1

all_deleted:
	mov	es, hExe
	and	es:[si].ne_usage,NOT 0C000h
dex:
cEnd


;
; StartProcAddress( hExe ) - procedure to return the fixed address of
; a new EXE start procedure
;
cProc	StartProcAddress,<PUBLIC,NEAR>,<di>
	parmW   hexe
	parmW   fh
cBegin
	mov	es,hexe
	mov	di,ne_csip
	xor	dx,dx
	mov	ax,es:[di+2]
	or	ax,ax
	jz	sp1
	mov	di,es:[di]
	cCall	FarLoadSegment,<es,ax,fh,fh>
	jcxz	sp1
	mov	ax,di			; DX:AX is start address of module
sp1:					; (DX is really a handle)
	mov	cx,ax
	or	cx,dx
cEnd



; GetStackPtr - returns the initial SS:SP for a module.
;
cProc GetStackPtr,<PUBLIC,NEAR>,<si>
	parmW   hExe
cBegin
	mov	es,hExe
if KDEBUG
	cmp	es:[ne_sssp].sel,0
	jnz	@F
	mov	cx,ne_sssp
	fkerror 0,<Invalid stack segment>,es,cx
@@:
endif
	cmp	es:[ne_sssp].off,0
	jne	re3
	mov	dx,es:[ne_stack]
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	re2
	add	dx,es:[bx].ns_minalloc
re2:	and	dx,0FFFEh		; Word aligned stack
	mov	word ptr es:[ne_sssp],dx

re3:	mov	dx,es:[ne_sssp].sel
	mov	ax,es:[ne_sssp].off
	push	ax
	mov	cx,-1
	cCall	FarLoadSegment,<es,dx,cx,cx>
	pop	ax			; Handle in DX and offset in AX
cEnd




;
; GetInstance( hExe ) - Procedure to return the instance handle for
; the current automatic data segment associated with the passed exe
;
cProc	GetInstance,<PUBLIC,NEAR>
	parmW   hexe
cBegin
	mov	es,hexe
	mov	ax,es:[ne_flags]
	test	ax,NEINST+NESOLO
	mov	ax,es
	jz	gidone
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	gidone
	mov	ax,es:[bx].ns_handle
gidone:
	mov	cx,ax
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\linterf.asm ===
TITLE	LINTERF - Local memory allocator, interface procedures

.xlist
include tdb.inc
include kernel.inc
.list

.errnz	 la_prev		; This code assumes la_prev = 0

if KDEBUG
CheckHeap  MACRO n
local	a
	extrn	CheckLocalHeap:NEAR
	cCall	CheckLocalHeap
	or	ax,ax
	jz	a
	or	ax,ERR_LMEM
	kerror	<>,<&n: Invalid local heap>
a:
	endm
else
CheckHeap  MACRO n
	endm
endif

externW pLocalHeap

externFP <GlobalHandle,GlobalReAlloc,GlobalSize,GlobalCompact,GlobalFlags>
externFP <GlobalLock,GlobalUnlock>
externFP <GlobalMasterHandle,GetCurrentTask>
externFP FarValidatePointer
externFP DibRealloc

DataBegin

externW curTDB
;externW MyCSDS

if KDEBUG
externW DebugOptions
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP <halloc,lhfree,lhdref,hthread>		; LHANDLE.ASM
externNP <ljoin,lrepsetup,lzero>		; LALLOC.ASM
externNP <lalloc,lfree,lfreeadd,lfreedelete>	; LALLOC.ASM
externNP <lcompact,lshrink>			; LCOMPACT.ASM

if KDEBUG
externNP <CheckLAllocBreak>
endif   ;KDEBUG

;-----------------------------------------------------------------------;
; lenter								;
;									;
; Enters a critical region for the local heap.				;
;									;
; Arguments:								;
;	DS = automatic data segment containing local heap		;
;									;
; Returns:								;
;	DS:DI = address of LocalInfo for local heap			;
;	(li_lock field has been incremented)				;
;									;
; Error Returns:							;
;	CX == 1 if heap is busy						;
;									;
; Registers Preserved:							;
;	AX,BX,DX,SI,ES							;
;									;
; Registers Destroyed:							;
;	CX								;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Sun Oct 13, 2086 09:27:27p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lenter,<PUBLIC,NEAR>
cBegin nogen
	mov	di,pLocalHeap
	mov	cx,1
	xchg	[di].li_lock,cx
	jcxz	enter1

; Should really do a WaitEvent

if KDEBUG
	xor	bx,bx
	kerror	ERR_LMEMCRIT,<lenter: local heap is busy>,bx,cx
endif

enter1: ret

cEnd nogen

;-----------------------------------------------------------------------;
; lleave								;
;									;
; Leaves a critical region for the local heap.				;
;									;
; Arguments:								;
;	DS = automatic data segment containing local heap		;
;									;
; Returns:								;
;	DS:DI = address of LocalInfo for local heap			;
;	(li_lock field has been cleared)				;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	AX,BX,DX,SI,ES							;
;									;
; Registers Destroyed:							;
;	CX								;
;									;
; Calls:								;
;	nothing								;
;									;
; History:								;
;									;
;  Sun Oct 13, 2086 09:30:01p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lleave,<PUBLIC,NEAR>
cBegin nogen
	mov	di,pLocalHeap
	xor	cx,cx
	xchg	ds:[di].li_lock,cx
	jcxz	leave1
	ret
leave1:

; Should really do a PostEvent
if KDEBUG
	kerror	ERR_LMEMCRIT,<lleave: local heap was not busy>
endif

cEnd nogen

;-----------------------------------------------------------------------;
; lhexpand								;
; 									;
; Expands a local handle table.						;
; 									;
; Arguments:								;
;	CX    = #handle entries to allocate				;
;	DS:DI = local info structure					;
; 									;
; Returns:								;
;	AX = address of handle table block of requested size		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
;	lalloc								;
;	hthread 							;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 01:48:21p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lhexpand,<PUBLIC,NEAR>
cBegin nogen
	xor	ax,ax			; Allocate fixed local block
	mov	bx,cx
	inc	bx			; plus 1 for word at beginning & end
	shl	bx,1
	shl	bx,1
	errnz	<4-SIZE LocalHandleEntry>
	push	cx
	call	lalloc
	pop	cx
        or      ax,ax
	jz	lhfail
	mov	bx,ax
	xchg	[di].hi_htable,bx
	push	di			; Save DI
	mov	di,ax
	mov	ds:[di],cx
	inc	di
	inc	di
	call	hthread
	mov	ds:[di],bx		; Store pointer to next block
	pop	di			; Restore DI
lhfail:	mov	cx,ax
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; lalign								;
; 									;
; Aligns the size request for a local item to a multiple of 4 bytes.	;
; 									;
; Arguments:								;
;	CF = 0								;
;	  BX = #bytes							;
;	CF = 1	get max amount						;
; 									;
; Returns:								;
;	DX = #bytes aligned to next higher multiple of 4		;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Tue March 10, 1987 -by- Bob Gunderson [bobgu]			;
; To accomidate free list, must impose a minimum block size to prevent	;
; allocating a block on top of the extended header of previous block.	;
;									;
;  Tue Oct 14, 1986 01:56:42p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lalign,<PUBLIC,NEAR>
cBegin nogen
	jnc	align0
	mov	bx,LA_MASK
align0:	cmp	bx,SIZE LocalArenaFree
	jae	align2
	mov	bx,SIZE LocalArenaFree	; Must impose a minimum size
align2:	lea	dx,[bx+LA_ALIGN]
	and	dl,LA_MASK
	cmp	dx,bx			; Test for overflow
	jae	align1			; No, continue
	mov	dx,LA_MASK		; Yes, return largest possible size
align1:	ret
cEnd nogen


;-----------------------------------------------------------------------;
; ldref									;
; 									;
; Dereferences a local handle.						;
; 									;
; Arguments:								;
;	SI = handle							;
; 									;
; Returns:								;
;	AX = address of client data					;
;	BX = address of arena header					;
;	CH = lock count or zero for fixed objects			;
;	SI = handle table entry address or zero for fixed objects	;
;	ZF = 1 if NULL handle passed in					;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	CL 								;
;									;
; Calls:								;
;	lhdref								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 01:58:58p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	ldref,<PUBLIC,NEAR>
cBegin nogen
	xor	cx,cx			; Zero lock count
	mov	ax,si			; Return handle if fixed object
	test	al,LA_MOVEABLE		; Is it moveable?
	jnz	dref3			; Yes, go dereference handle
	xor	si,si			; Set SI to zero for fixed objects
	or	ax,ax			; No, were we passed NULL?
	jz	dref2			; Yes, then all done
dref1:	mov	bx,ax			; No, return BX pointing
	and	bl,LA_MASK		; ...to arena header
	sub	bx,la_fixedsize		; Leaving ZF = 0
dref2:	ret

dref3:	call	lhdref			; Get true address in AX
					;  and lock count in CH
ife KDEBUG
	jz	done			; Compute arena header if valid true address
	mov	bx,ax			; See if arena header points to
	sub	bx,SIZE LocalArena
done:	ret				; No, return with ZF = 1
else
	test	cl,LHE_DISCARDED	; Discarded?
	jnz	dref5			; Yes, all done
	or	ax,ax			; Is there a true address?
	jz	dref4			; No, then must be error
	mov	bx,ax			; See if arena header points to
	sub	bx,SIZE LocalArena
	cmp	[bx].la_handle,si	; handle table entry?
	je	dref5			; Yes, continue
dref4:	xor	bx,bx
	kerror	ERR_LMEMHANDLE,<LDREF: Invalid local handle>,bx,si
	xor	ax,ax
dref5:	or	ax,ax
	ret
endif

cEnd nogen


;-----------------------------------------------------------------------;
; lnotify								;
; 									;
; Calls the local heap's notify proc (if any).				;
; 									;
; Arguments:								;
;	AL = message code						;
;	BX = handle or largest free block				;
;	CX = optional argument 		 				;
; 									;
; Returns:								;
;	AX = return value from notify proc or AL			;
;	ZF = 1 if AX = 0						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Oct 14, 1986 02:03:14p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

cProc	lnotify,<PUBLIC,NEAR>
cBegin nogen
	cmp	word ptr [di+2].li_notify,0
	je	notify1
	xor	ah,ah
	cCall	[di].li_notify,<ax,bx,cx>
notify1:
	or	ax,ax
	ret
cEnd nogen


; The remainder of this file implements the exported interface to the
; local memory manager.  A summary follows:
;
;   HANDLE  far PASCAL LocalAlloc( WORD, WORD );
;   HANDLE  far PASCAL LocalReAlloc( HANDLE, WORD, WORD );
;   HANDLE  far PASCAL LocalFree( HANDLE );
;   WORD    far PASCAL LocalSize( HANDLE );
;   char *  far PASCAL LocalLock( HANDLE );
;   BOOL    far PASCAL LocalUnlock( HANDLE );
;   WORD    far PASCAL LocalCompact( WORD );
;   WORD    far PASCAL LocalShrink( HANDLE , WORD );
;   FARPROC far PASCAL LocalNotify( FARPROC );
;   #define LocalDiscard( h ) LocalReAlloc( h, 0, LMEM_MOVEABLE )
;   BOOL    far PASCAL LocalInit( char *, char * );
;
;   extern WORD * PASCAL pLocalHeap;
;
;   #define dummy 0
;   #define LocalFreeze( dummy ) ( *(pLocalHeap+1) += 1 )
;   #define LocalThaw( dummy )	 ( *(pLocalHeap+1) -= 1 )
;

cProc	ILocalAlloc,<PUBLIC,FAR>,<si,di>
	parmW   flags
	parmW   nbytes
cBegin
	WOWTrace "LocalAlloc(#AX,#BX)",<<ax,flags>,<bx,nbytes>>
	CheckHeap LocalAlloc
	call	lenter			; About to modify memory arena
	jcxz	la_ok
	xor	ax, ax
	jmp	la_crit
la_ok:
	mov	ax,flags		; Allocate space for object
	test	al,LA_NOCOMPACT
	jz	all0
	inc	[di].hi_freeze
all0:	mov	bx,nbytes
	or	bx,bx			; Zero length?
	jnz	alloc0			; No, continue
	and	ax,LA_MOVEABLE		; Yes, moveable?
	jz	alloc1			; No, return error
	call	halloc			; Yes, allocate handle
	or	ax,ax			; failure??
	jz	alloc1			; yep... return a NULL
	xor	byte ptr [bx].lhe_address,LA_MOVEABLE ; and zero address field
	or	byte ptr [bx].lhe_flags,LHE_DISCARDED ; and mark as discarded
	jmps	alloc1			; all done

alloc0:	test	al,LA_MOVEABLE		; Is this a moveable object?
	jz	dont_need_handle
	push	ax
	push	bx
	call	halloc			; Allocate handle first.

	or	ax,ax
	jnz	all2			; error?
	pop	bx			; yes, DON'T destroy the NULL in AX
	pop	bx
	jmps	alloc1
all2:
	pop	bx
	pop	ax

;	pop	bx
;	pop	ax
;	jcxz	alloc1

	push	cx			; this is handle
	call	lalloc
	pop	si			; get handle in index register
	jnz	got_space
	call	lhfree			; free the allocated handle
	jmps	alloc1

got_space:
	mov	[si].lhe_address,ax	; Store address away.
	mov	bx,ax			; Store back link to handle in header
	mov	[bx-SIZE LocalArena].la_handle,si  ; Mark as moveable block
	or	byte ptr [bx-SIZE LocalArena].la_prev,LA_MOVEABLE
	mov	ax,si			; return the handle
	and	dh,LHE_DISCARDABLE	; Discardable object?
	jz	alloc1			; No, continue
	mov	[si].lhe_flags,dh	; Yes, save discard level in handle
	jmps	alloc1			;  table entry

dont_need_handle:
	call	lalloc
alloc1:	test	byte ptr flags,LA_NOCOMPACT
	jz	all1
	dec	[di].hi_freeze
all1:	call	lleave			; Arena is consistent now
la_crit:
ifdef WOW
        ; We don't want this debug spew
else
        or      ax,ax
        jnz     @F
        KernelLogError DBF_WARNING,ERR_LALLOC,"LocalAlloc failed"  ; LocalAlloc failure
        xor     ax, ax                  ; preserve the return value
@@:
endif
        mov     cx,ax                   ; Let caller do jcxz to test failure
	WOWTrace "LocalAlloc: #AX"
cEnd


cProc	ILocalReAlloc,<PUBLIC,FAR>,<si,di>
	parmW   h
	parmW   nbytes
	parmW   rflags
cBegin
	WOWTrace "LocalReAlloc(#AX,#BX,#CX)",<<ax,h>,<bx,nbytes>,<cx,rflags>>
	CheckHeap   LocalReAlloc
	call	lenter			; About to modify memory arena
	jcxz	lr_ok
	xor	ax, ax
	jmp	lr_crit
lr_ok:
	test	byte ptr rflags,LA_NOCOMPACT
	jz	rel0
	inc	[di].hi_freeze
rel0:
	mov	si,h			; Dereference handle
	call	ldref
	jz	racreate		; If zero handle, check for re-creation.
	test	byte ptr rflags,LA_MODIFY   ; Want to modify handle table flags
	jnz	ramodify		; Yes, go do it
	mov	si,bx			; SI = arena header
	mov	bx,ax			; Compute address of new next header
	mov	dx,nbytes		;  assuming there is room.
	cmp	dx,SIZE LocalArenaFree	; Minimum size must be large enough
	jae	@F			;  to a hold free header.
	mov	dx,SIZE LocalArenaFree
@@:	add	bx,dx
	call	lalign
	mov	bx,[si].la_next		; Get address of current next header
	cmp	nbytes,0		; Are we reallocing to zero length?
	jne	raokay			; No, continue
	jcxz	radiscard		; Yes, discard if not locked
rafail:
ifdef WOW
        ; We don't want this debug spew
else
        KernelLogError  DBF_WARNING,ERR_LREALLOC,"LocalReAlloc failed"
endif
        xor     ax,ax
        jmp     raexit

radiscard:

; Here to discard object, when reallocating to zero size.  This
;  feature is only enabled if the caller passes the moveable flag

	test	byte ptr rflags,LA_MOVEABLE	; Did they want to discard?
	jz	rafail			; No, then return failure.
	mov	al,LN_DISCARD		; AL = discard message code
	xor	cx,cx			; CX = disc level of 0 (means realloc)
	mov	bx,h			; BX = handle
	call	lnotify			; See if okay to discard
	jz	rafail			; No, do nothing
	xor	ax,ax			; Yes, free client data
	mov	bx,si
	call	lfree
	jz	rax			; Return NULL if freed a fixed block
	mov	[si].lhe_address,ax	; No, zero addr in handle table entry
	or	[si].lhe_flags,LHE_DISCARDED  ; and mark as discarded
	jmps	rasame			; Return original handle, except
					; LocalLock will now return null.

ramodify:
	mov	ax,rflags		; Get new flags
	or	si,si			; Moveable object?
	jz	rasame			; No, all done
	and	[si].lhe_flags,not LHE_USERFLAGS ; Clear old flags
	and	ah,LHE_USERFLAGS; Get new flags
	or	[si].lhe_flags,ah	; Store new flags in handle table entry
	jmps	rasame

racreate:
	test	cl,LHE_DISCARDED	; Is this a discarded handle?
	jz	rasame			; No, return original value
	mov	bx,nbytes		; BX = new requested size
	push	si			; save handle
	mov	ax,LA_MOVEABLE		; Reallocating a moveable object
	or	ax,rflags		; ...plus any flags from the caller
	call	lalloc			; Allocate a new block
	pop	si			; restore existing handle
	jz	rafail
	xor	[si].lhe_flags,LHE_DISCARDED  ; and mark as not discarded
	jmp	ram2

raokay:
; Here if not trying to realloc this block to zero
; SI = arena header of current block
; AX = client address of current block
; BX = arena header of next block
; CH = lock count of current block
; DX = new next block, based on new requested size
	cmp	dx,bx			; Are we growing or shrinking?
	ja	ragrow			; We are growing
rashrink:				; We are shrinking
; Here to shrink a block
; SI = arena header of current block
; BX = arena header of next block
; DX = new next block, based on new requested size
	push	si
	mov	si,dx			; SI = new next block
	add	dx,LA_MINBLOCKSIZE	; Test for small shrinkage
        jnc     @F                      ;   No overflow
        pop     bx			;   Overflowed, obviously no room!
	jmp     rasame                  ;   Clear stack and return same handle
@@:	cmp	dx,bx		  	; Is there room from for free block?
	pop	bx			; BX = current block
	jae	rasame			; No, then no change to make
					; Splice extra free space into arena
	mov	cx,si			; [si].la_next = [bx].la_next
	xchg	[bx].la_next,cx		; [bx].la_next = si
	mov	[si].la_prev,bx		; [si].la_prev = bx
	xchg	si,cx
	and	[si].la_prev,LA_ALIGN
	jz	splice1			; If free then coelesce
	inc	[di].hi_count		; No, adding new arena entry
	jmps	splice2
splice1:

; next block is free, must make the new block a larger free block

; first remove the current free block [SI] from the free list

	xchg	bx,si
	call	lfreedelete
	xchg	bx,si
	mov	si,[si].la_next
	and	[si].la_prev,LA_ALIGN

splice2:
	or	[si].la_prev,cx		; [[si].la_next].la_prev = si
	xchg	si,cx
	mov	[si].la_next,cx
	mov	bx,si			; BX = new block
	xor	si,si			; don't know where to insert
	call	lfreeadd		; add to free list
rasame:
	mov	ax,h			; Return the same handle
rax:	jmps	raexit			; All done

; Here to try to grow the current block
; AX = client address of current block
; SI = arena header of current block
; BX = arena header of next block
; DX = new next block, based on new requested size
ragrow:
if KDEBUG
        call    CheckLAllocBreak
        jc      rafail1
endif

	test	byte ptr [bx].la_prev,LA_BUSY	; Is next block free?
	jnz	ramove			; No, try to move the current block
	cmp	dx,[bx].la_next		; Yes, is free block big enough?
	ja	ramove			; No, try to move the current block
	mov	cx,bx			; Yes, save free block address in CX
	call	ljoin			; and attach to end of current block
	test	rflags,LA_ZEROINIT	; Zero fill extension?
	jz	ranz			; No, continue
	call	lzero			; Yes, zero fill
ranz:
	jmp	rashrink		; Now shrink block to correct size

; Here to try to move the current block
; AX = client address of current block
; SI = arena header of current block
; CH = lock count of current block
ramove:
	mov	dx,rflags		; get the passed in flags
	mov	bx,LA_MOVEABLE		; Determine if okay to move this guy
	jcxz	ramove1			; Continue if this handle not locked
	test	dx,bx			; Locked.  Did they say move anyway?
	jnz	ramove1			; Yes, go do it
rafail1:jmp	rafail
ramove1:
	or	dx,bx			; make sure moveable bit set
	test	h,bx			; Is it a moveable handle?
	jnz	ram1			; Yes, okay to move
	test	rflags,bx		; No, did they say it's okay to move?
	jz	rafail1			; No, then fail
	xor	dx,bx			; turn off moveable bit
ram1:
;   We do this because the lalloc can move the old block to a
;   block that is larger than the requested new block.	This can
;   happen if we LocalCompact durring the lalloc call.	(bobgu 8/27/87)
	mov	bx,[si].la_next
	sub	bx,ax			; # client bytes in current block
	push	bx			; save it for later

	mov	ax,dx			; AX = allocation flags
	mov	bx,nbytes		; BX = new requested size
	call	lalloc			; Allocate a new block

	pop	cx			; CX = client size of old block
	jz	rafail1
	push	cx			; save it away again

	push	ax			; Call notify proc
	mov	cx,ax			; with new location
	mov	bx,h			; handle
	mov	al,LN_MOVE
	call	lnotify			; Notify client of new location
	mov	si,h
	call	ldref			; BX = old arena header address
	mov	si,ax			; SI = old client address
	pop	ax			; AX = new client address

	pop	cx			; get back size of old client
;	mov	cx,[bx].la_next 	; Compute length of old client data
;	sub	cx,si
	call	lrepsetup		; Setup for copy of words
	push	di
	mov	di,ax			; DI = new client data address
	rep	movsw			; Copy old client data to new area
	pop	di			; Restore DI
	call	lfree			; Free old block
	jz	raexit
ram2:
	mov	[si].lhe_address,ax	; Set new client data address
	xchg	ax,si			; Return original handle
					; Set back link to handle in new block
	or	byte ptr [si-SIZE LocalArena].la_prev,LA_MOVEABLE
	mov	[si-SIZE LocalArena].la_handle,ax
raexit:
	test	byte ptr rflags,LA_NOCOMPACT
	jz	rel1
	dec	[di].hi_freeze
rel1:
	call	lleave			; Arena is consistent now
lr_crit:
	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalReAlloc: #AX"
cEnd


cProc	ILocalFree,<PUBLIC,FAR>,<si,di>
	parmW   h
cBegin
	WOWTrace "LocalFree(#AX)",<<ax,h>>
	call	lenter			; About to modify memory arena
	jcxz	lf_ok
	xor	ax, ax
	jmp	lf_crit
lf_ok:
	CheckHeap   LocalFree
	mov	si,h			; Dereference handle
	call	ldref
	jz	free1			; Free handle if object discarded
if KDEBUG
	push	ds
	SetKernelDS
	mov	ds,curTDB
	assumes	ds, nothing
	cmp	ds:[TDB_ExpWinVer],201h
	pop	ds
	jb	dont_do_error_checking

	or	ch,ch			; No, is the handle locked?
	jz	freeo			; Yes, then don't free
	xor	bx,bx
	kerror	ERR_LMEMUNLOCK,<LocalFree: freeing locked object>,bx,h
	mov	si,h			; Dereference handle again
	call	ldref
freeo:
dont_do_error_checking:
endif
	call	lfree			; No, free the object
free1:	call	lhfree			; and any handle
freex:	call	lleave			; Arena is consistent now
lf_crit:
	WOWTrace "LocalFree: #AX"
cEnd

cProc	ILocalSize,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
;	CheckHeap   LocalSize
	push	si
	mov	si,sp
	mov	si,ss:[si+6]		; Dereference handle
	call	ldref			; into BX
	jz	size1			; Done if AX = zero
	sub	ax,[bx].la_next		; Otherwise size =
	neg	ax			;  - (client address - next block address)
size1:	mov	cx,ax			; Let caller do jcxz to test failure
	pop	si
	ret	2
cEnd	nogen


cProc	ILocalFlags,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
;	CheckHeap   LocalFlags
	push	si
	mov	si,sp
	mov	si,ss:[si+6]		; Dereference handle
	call	ldref			; into BX
	mov	cx,si
	jcxz	flags1			; Done if not moveable
	mov	cx,word ptr [si].lhe_flags   ; Return flags and lock count
flags1:
	xchg	cl,ch			; Return lock count in low half
	mov	ax,cx			; Let caller do jcxz to test failure
	pop	si
	ret	2
cEnd	nogen



if KDEBUG
cProc	ILocalLock,<PUBLIC,FAR>,<si>
	parmW   h
cBegin
	WOWTrace "LocalLock(#AX)",<<ax,h>>
;	CheckHeap   LocalLock
	mov	si,h
	call	ldref			; SI = handle table entry
	jz	lock2			; Done if invalid handle or discarded
	or	si,si
	jz	lock2			; or if not moveable

	inc	[si].lhe_count		; Increment usage count
	jnz	lock1
	xor	cx,cx
	kerror	ERR_LMEMLOCK,<LocalLock: Object usage count overflow>,cx,h
	dec	[si].lhe_count		; Keep pinned at max value
lock1:	mov	ax,[si].lhe_address	; Return true address in AX
lock2:	
	or	ax, ax
	jnz	@F
        KernelLogError  DBF_WARNING,ERR_LLOCK,"LocalLock failed"
        xor     ax,ax                   ; Get back the NULL value in ax
@@:	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalLock: #AX"
cEnd

else
cProc	ILocalLock,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp			; Get handle parameter from stack
	mov	bx,SS:[bx+4]
	mov	ax,bx			; Return in AX
	test	bl,LA_MOVEABLE		; Test for moveable (also null)
	jz	lock2			; Return if not moveable or null
	test	[bx].lhe_flags,LHE_DISCARDED  ; Return zero if discarded
	jnz	lock1
	inc	[bx].lhe_count		; Increment usage count
	jz	lock3			; Special case if overflow
lock1:
	mov	ax,[bx].lhe_address	; Return true address in AX or zero
lock2:	mov	cx,ax			; Let caller do jcxz to test failure
	ret	2
lock3:
	dec	[bx].lhe_count		; Ooops, keep pinned at max value
	jmp	lock1

cEnd nogen
endif


if KDEBUG
cProc	ILocalUnlock,<PUBLIC,FAR>,<si>
	parmW   h
cBegin
	WOWTrace "LocalUnlock(#AX)",<<ax,h>>
;	CheckHeap   LocalUnlock
	mov	si,h
	call	ldref			; SI = handle table entry
	jz	unlock1			; Done if invalid handle or discarded
	xor	ax,ax
	or	si,si
	jz	unlock1			; or if not moveable

	or	ch, ch
	jz	unlockerr
	dec	ch			; Decrement usage count
	cmp	ch,0FFh-1		; 0 -> ff, ff -> fe
	jae	unlock1			; Return if pinned or already unlocked
	mov	[si].lhe_count,ch
;	mov	ax,bx
	mov	al,ch
	cbw
	jmps	unlock1
unlockerr:
	xor	cx,cx
	kerror	ERR_LMEMUNLOCK,<LocalUnlock: Object usage count underflow>,cx,h
	xor	ax,ax
unlock1:
	mov	cx,ax			; Let caller do jcxz to test failure
	WOWTrace "LocalUnlock: #AX"
cEnd

else
cProc	ILocalUnlock,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp			; Get handle parameter from stack
	mov	bx,SS:[bx+4]
	xor	ax,ax
	test	bl,LA_MOVEABLE		; Test for moveable (also null)
	jz	unlock1			; Return if not moveable or null
	mov	cx,word ptr [bx].lhe_flags
	errnz	<2-lhe_flags>
	errnz	<3-lhe_count>
	and	cl,LHE_DISCARDED
	jnz	unlock1			; Return if discarded
	dec	ch			; Decrement usage count
	cmp	ch,0FFh-1		; 0 -> ff, ff -> fe
	jae	unlock1			; Return if pinned or already unlocked
	mov	[bx].lhe_count,ch
;	mov	ax,bx
	mov	al,ch
	cbw
unlock1:
	mov	cx,ax			; Let caller do jcxz to test failure
	ret	2
cEnd nogen
endif



cProc	LocalHandle,<PUBLIC,FAR>
;	parmW   h
cBegin	nogen
	mov	bx,sp
	mov	bx,SS:[bx+4]
	test	bl,LA_MOVEABLE
	jz	lh1
	mov	ax,bx
	mov	bx,[bx-SIZE LocalArena].la_handle
	cmp	[bx].lhe_address,ax
	je	lh1
	xor	bx,bx
lh1:
	mov	ax,bx
	ret	2
cEnd	nogen


cProc	LocalCompact,<PUBLIC,FAR>,<si,di>
	parmW   minBytes
cBegin
	CheckHeap   LocalCompact
	call	lenter			; About to modify memory arena
	jcxz	lc_ok
	xor	ax, ax
	jmp	lc_crit
lc_ok:
	mov	bx,minBytes
	clc
	call	lalign
	call	lcompact
	or	ax,ax
	jz	compact1
	sub	ax,SIZE LocalArena	; Reduce available size by header size
compact1:
	call	lleave			; Arena is consistent now
lc_crit:
cEnd


cProc	LocalShrink,<PUBLIC,FAR>,<si,di>
	parmW  hseg
	parmW  wsize
cBegin
	mov	ax,hseg
	or	ax,ax			; use heap in current DS ?
	jz	ls_useds		; yes

; Use the segment handle passed
	push	ax
	call	GlobalHandle
	or	ax,ax			; valid handle ?
	jz	ls_errexit		; no....
	mov	ds,dx			; set the proper DS
ls_useds:
; check the heap and lock it
	CheckHeap   LocalShrink
	call	lenter			; About to modify memory arena
	jcxz	ls_ok
	xor	ax, ax
	jmp	short ls_crit
ls_ok:

	mov	bx,wsize		; get requested min size
	call	lshrink 		; Let's get small
; AX = new local heap size
	call	lleave			; Arena is consistent now
ls_crit:
ls_errexit:

cEnd


cProc	LocalNotifyDefault,<PUBLIC,FAR>,<si,di>
	parmW   msg
	parmW	handle		; or largest free block
	parmW   arg1
cBegin
	mov	ax,msg
	or	ax,ax
	jnz	dlnexit1
	cCall	GlobalHandle,<ds>
	or	ax,ax
	jz	dlnexit1
			; Fix for FORMBASE who uses a fixed
			; segment for a local heap.  This blows
			; up if we cause the calling segment
			; to be discarded since the DS saved by
			; Local???? is a fixed segment which
			; SearchStack can't handle.  Confused?
			; This was not a problem in 2.x because
			; 2.x failed to grow a fixed object.
			; Using a fixed segment for a local heap
			; is not valid and this is really a problem
			; with FORMBASE.
	mov	si,ax
	cCall	GlobalFlags,<si>	; Get flags
	xchg	ah, al
	push	ax
	cCall	GlobalSize,<si>
	sub	ax, handle		; Temorarily subtract out largest free
	pop	bx			; Get flags in BX
	xor	cx,cx
	add	ax,arg1
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	dln_too_large		;  beyond 64k.
	add	ax,18h			; since li_extra isn't guaranteed
	adc	dx,cx
	jnz	dln_too_large
	add	ax,[di].li_extra
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	@F			;  beyond 64k.
	add	ax, handle		; add back largest free
	adc	dx, cx					       
	jnz	@F
	cmp	ax,0FFF0h
	jbe	dln0
@@:	mov	ax,0FFF0h
	xor	dx,dx
	jmps	dln0
dln_too_large:
	xor	ax,ax
dlnexit1:
	jmp	dlnexit
dln0:
	test	si,GA_FIXED		; Is DS fixed?
	jnz	dln1			; Yes, must grow in place
	cmp	bh,1			; No, is lock count 1?
	jne	dln1			; No must grow in place if locked
	or	cl,GA_MOVEABLE		; Yes, okay to move even though locked
dln1:
	push	bx
grow_DS:
	cCall	GlobalReAlloc,<si,dxax,cx>
	pop	bx
	jcxz	dlnexit
	push	bx
	cCall	GlobalSize,<ax>

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	@F			; No, OK
	mov	ax,0FFFFh		 ; This only happens under 386pmode
@@:
	mov	bx,ax
	sub	bx,la_freefixedsize
	and	bl,LA_MASK
	mov	di,ds:[pLocalHeap]
	mov	si,[di].hi_last
	mov	[bx].la_next,bx
	mov	[bx].la_prev,si
	or	byte ptr [bx].la_prev,LA_BUSY
	mov	[si].la_next,bx

; Maintain the free list.

	mov	ax,[si].la_free_prev
	mov	[bx].la_free_prev,ax
	mov	[bx].la_free_next,bx
	mov	[bx].la_size,WORD PTR la_freefixedsize
	push	si
	mov	si,ax
	mov	[si].la_free_next,bx
	pop	si

	mov	[di].hi_last,bx
	inc	[di].hi_count
	mov	bx,si
	call	lfree

;   Don't do this... (bobgu 8/4/87)
;	stc
;	call	lalign
;	call	lcompact

	mov	ax,1
	pop	bx
	mov	ax,1
dlnexit:
cEnd

cProc   LocalNotifyDib,<PUBLIC,FAR>,<si,di>
	parmW   msg
	parmW	handle		; or largest free block
	parmW   arg1
cBegin
	mov	ax,msg
	or	ax,ax
        jnz     dlnexit1dib
	cCall	GlobalHandle,<ds>
	or	ax,ax
        jz      dlnexit1dib
			; Fix for FORMBASE who uses a fixed
			; segment for a local heap.  This blows
			; up if we cause the calling segment
			; to be discarded since the DS saved by
			; Local???? is a fixed segment which
			; SearchStack can't handle.  Confused?
			; This was not a problem in 2.x because
			; 2.x failed to grow a fixed object.
			; Using a fixed segment for a local heap
			; is not valid and this is really a problem
			; with FORMBASE.
	mov	si,ax
	cCall	GlobalFlags,<si>	; Get flags
	xchg	ah, al
	push	ax
	cCall	GlobalSize,<si>
	sub	ax, handle		; Temorarily subtract out largest free
	pop	bx			; Get flags in BX
	xor	cx,cx
	add	ax,arg1
	adc	dx,cx			; Fail if DS attempts to grow
        jnz     dib_too_large           ;  beyond 64k.
	add	ax,18h			; since li_extra isn't guaranteed
	adc	dx,cx
        jnz     dib_too_large
	add	ax,[di].li_extra
	adc	dx,cx			; Fail if DS attempts to grow
	jnz	@F			;  beyond 64k.
	add	ax, handle		; add back largest free
	adc	dx, cx					       
	jnz	@F
	cmp	ax,0FFF0h
        jbe     dln0dib
@@:	mov	ax,0FFF0h
	xor	dx,dx
        jmps    dln0dib
dib_too_large:
	xor	ax,ax
dlnexit1Dib:
        jmp     dlnexitdib
dln0dib:
	test	si,GA_FIXED		; Is DS fixed?
        jnz     dln1dib                 ; Yes, must grow in place
	cmp	bh,1			; No, is lock count 1?
        jne     dln1dib                 ; No must grow in place if locked
	or	cl,GA_MOVEABLE		; Yes, okay to move even though locked
dln1dib:
	push	bx
        cCall   DibReAlloc,<ds,ax>
        or      ax,ax
        jz      dlnexitdib0
        cCall   GlobalSize,<si>

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	@F			; No, OK
	mov	ax,0FFFFh		 ; This only happens under 386pmode
@@:
	mov	bx,ax
	sub	bx,la_freefixedsize
	and	bl,LA_MASK
	mov	di,ds:[pLocalHeap]
	mov	si,[di].hi_last
	mov	[bx].la_next,bx
	mov	[bx].la_prev,si
	or	byte ptr [bx].la_prev,LA_BUSY
	mov	[si].la_next,bx

; Maintain the free list.

	mov	ax,[si].la_free_prev
	mov	[bx].la_free_prev,ax
	mov	[bx].la_free_next,bx
	mov	[bx].la_size,WORD PTR la_freefixedsize
	push	si
	mov	si,ax
	mov	[si].la_free_next,bx
	pop	si

	mov	[di].hi_last,bx
	inc	[di].hi_count
	mov	bx,si
	call	lfree

;   Don't do this... (bobgu 8/4/87)
;	stc
;	call	lalign
;	call	lcompact


        mov     ax,1
dlnexitdib0:
	pop	bx
dlnexitdib:
cEnd

sEnd	CODE

externFP Far_lalign
externFP Far_lrepsetup
if KDEBUG
externFP Far_lfillCC
endif

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

cProc	ILocalNotify,<PUBLIC,FAR>
;	parmD   lpProc
cBegin	nogen
	mov	bx,sp
	mov	ax,SS:[bx+4]
	mov	dx,SS:[bx+6]
	mov	bx,ds:[pLocalHeap]
	xchg	word ptr [bx].li_notify,ax
	xchg	word ptr [bx].li_notify+2,dx
	ret	4
cEnd	nogen


cProc	LocalInit,<PUBLIC,FAR>,<ds,si,di>
	parmW	pseg
	parmW	pstart
	parmW	pend
cBegin

; Init current DS if none passed.

	mov	cx,pseg
	jcxz	li1
	mov	ds,cx
li1:

; Place local arena info at the beginning

	mov	bx,pstart
	or	bx,bx
	jnz	li2
	cCall	GlobalSize,<ds>

; Here we must do a little checking... The global memory manager may have
;  rounded up the size on us so that the DS is >=64K! If this has happened,
;  we can simply ignore the extra (since app can't look  at it anyway) and
;  pretend the DS is actually 0000FFFFH bytes big.

	or	dx,dx			; Did we get rounded up >= 64K?
	jz	li1a			; No, OK
	mov	ax,0FFFFH		; Pretend heap is 64K-1
li1a:
	mov	bx,ax
	dec	bx
	xchg	pend,bx
	sub	bx,pend
	neg	bx			; BX = first byte in arena
li2:
	clc
	call	Far_lalign
	mov	bx,dx			; DX = addr of first block to use

; OK, so here's how it works... In order to keep a free block list, there
; are 4 blocks allocated initially.  First is a dummy marker block that is
; free but marked busy.  Second is the local arena information block which
; is a standard busy block.  Third is the really big free block.  And lastly
; is another busy type free block.  All free blocks have an extended header
; in order to keep a free block list.

; Reserve room for the first free busy block.

	lea	bx,[bx].la_freefixedsize ; move over first free block
	push	dx			; preserve first free block address
	clc
	call	Far_lalign
	mov	bx,dx			; BX = arena info block address
	pop	dx			; DX = first block address
	push	dx			; * Save the address of the first
	push	bx			; * two block on the stack for later

; DI = client address of info block.

	lea	di,[bx].la_fixedsize
	xor	ax,ax			; Zero local arena info
	mov	cx,pend
	cmp	bx,cx			; start > end?

;;;;;;; jae	lix
	jb	li21
	pop	dx			; clean up the stack first
	pop	dx
	jmp	lix
li21:
	sub	cx,di
	call	Far_lrepsetup
	push	di
	rep	stosw
	pop	di
	lea	bx,[di].SIZE LocalInfo
if KDEBUG
	mov	[di].hi_pstats,bx
	add	bx,SIZE LocalStats

ifdef DISABLE

; Set the heap checking flag.

	push	es
	push	dx
	cCall	GlobalMasterHandle
	mov	es,dx
	mov	ax,es:[hi_check]
	pop	dx
	pop	es
else
        push    es
        push    _DATA
        pop     es
assumes es,DATA
;
; hi_check = 0;
; if (DebugOptions & DBO_CHECKHEAP)
; {
;    hi_check = 1
;    if (DebugOptions & DBO_CHECKFREE)
;       hi_check = 2;
; }
;
        xor     ax,ax
        test    es:DebugOptions,DBO_CHECKHEAP
        jz      @F
        inc     ax
        test    es:DebugOptions,DBO_CHECKFREE
        jz      @F
        inc     ax
@@:
assumes es,NOTHING
        pop     es
endif
	mov	[di].hi_check,ax
endif

; set the rest of the heap info

	mov	byte ptr [di].hi_hdelta,32
	mov	byte ptr [di].hi_count,4
	mov	[di].hi_first,dx
	mov	word ptr [di].li_notify,codeOFFSET LocalNotifyDefault
	mov	word ptr [di].li_notify+2,codeBASE
	mov	word ptr [di].hi_hexpand,codeOFFSET lhexpand
	mov	[di].li_extra,512
	mov	[di].li_sig,LOCALHEAP_SIG

; Move SI to first aligned block after info record

	clc
	call	Far_lalign
	mov	si,dx

; Move BX to last aligned block at end of local heap

	mov	bx,pend			; BX = end address
	sub	bx,la_freefixedsize	; Make room for an arena header
	and	bl,LA_MASK		; Align downwards to 4 byte boundary

	cmp	bx, si			; If heap is too small, the
	ja	@f			;   supposed free block could be
	xor	ax, ax			;   beyond the end block
	jmp	lix
@@:

; Setup reserved pointer in DS to point to LocalInfo

	mov	[di].hi_last,bx
	mov	ds:[pLocalHeap],di

; Finish linking entries in the local heap.
;
;	DX = address of the first arena block.	Free busy marker.
;	DI = address of the element which contains the local heap
;	 information struc.
;	SI = address of large free block that is the initial heap.
;	BX = address of a zero length arena element that is used to
;	     mark the end of the local heap.
;
;
; This last arena element is always busy, with a length of
; zero.  This allows us to always calculate the length of an
; arena entry by subtracting the address of the arena element
; from the hi_next field of the arena element (see lsize subr)

	pop	di			; Get the address of the first two
	pop	dx			; ... blocks off the stack

; Setup first block in arena, busy free block.

	xchg	bx,dx			;bx = first block (temporarily)
	lea	ax,[bx+LA_BUSY]		; ...as a busy block
	mov	[bx].la_prev,ax		; point to self
	mov	[bx].la_next,di		; point to next
	mov	[bx].la_free_prev,bx	; previous free block is self
	mov	[bx].la_free_next,si	; next free is large block
	mov	[bx].la_size,WORD PTR la_freefixedsize ; set the block size
	xchg	bx,dx			; back to normal

; Setup block that contains info structure.

	xchg	dx,bx
	lea	ax,[bx+LA_BUSY]		; ...as a busy block
	xchg	dx,bx
	mov	[di].la_prev,ax		; point to previous block
	mov	[di].la_next,si		; point to next block

; Setup large free block with extended free block header.

	mov	[si].la_prev,di		; Point middle block to first and
	mov	[si].la_next,bx		;  last blocks
	mov	[si].la_free_prev,dx	; previous free block
	mov	[si].la_free_next,bx	; next free block
	mov	ax,bx
	sub	ax,si
	mov	[si].la_size,ax		; length of free block

if KDEBUG
	xchg	si,bx			; BX = large free block
	call	Far_lfillCC		; Fill with 0CCh
	xchg	si,bx
endif

; Setup last free block with extended header.

	mov	[bx].la_next,bx		; Point last block to middle and itself
	lea	ax,[si+LA_BUSY]		; ...as a busy block
	mov	[bx].la_prev,ax
	mov	[bx].la_free_prev,si	; previous free block
	mov	[bx].la_free_next,bx	; next free block is self
	mov	[bx].la_size,WORD PTR la_freefixedsize ; set the block size

; Set the minimum size in arena header.

	mov	bx,ds:[pLocalHeap]
	mov	ax,[bx].hi_last
	add	ax,SIZE LocalArenaFree
	sub	ax,[bx].hi_first
	mov	[bx].li_minsize,ax

	cCall	GlobalLock,<ds>		; Make moveable DS initially locked.
					; (see LocalNotifyDefault)
	mov	al,1
lix:
	mov	cx,ax
cEnd


;-----------------------------------------------------------------------;
; LocalCountFree							;
; 									;
; Return the count of free bytes in the local heap.  This was motivated	;
; by the InitApp routines that want at least 4K available to continue	;
; the app running.							;
; 									;
; Arguments:								;
;	DS = heap segment						;
;									;
; Returns:								;
;	AX = free bytes in local heap					;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Aug 15, 1987 04:35:55p  -by-  Bob Gunderson [bobgu]		;
; Wrote it.								;
;-----------------------------------------------------------------------;


cProc	LocalCountFree,<PUBLIC,FAR>
cBegin nogen
	push	di
	push	si
	mov	di,pLocalHeap
	lea	si, [di].li_sig
	cCall	FarValidatePointer,<ds,si>
	or	ax, ax			; OK pointer?
	jz	countexit		;   no, just exit
	xor	ax,ax			; start with 0 bytes free
	cmp	[di].li_sig, LOCALHEAP_SIG	
	jne	countexit		;   No local heap!!
	mov	si,[di].hi_last 	; sentenal block
	mov	di,[di].hi_first	; arena header
	mov	di,[di].la_free_next	; first free block
countloop:
	cmp	di,si
	jz	countexit
	add	ax,[di].la_size 	; count size of this block
	sub	ax,SIZE LocalArenaFree	; less block overhead
	mov	di,[di].la_free_next	; next free block
	jmp	countloop
countexit:
	pop	si
	pop	di
	ret
cEnd nogen



;-----------------------------------------------------------------------;
; LocalHeapSize								;
; 									;
; Return the # bytes allocated to the local heap.			;
; 									;
; Arguments:								;
;	DS = heap segment						;
; 									;
; Returns:								;
;	AX = size of local heap						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
; 	BX								;
;									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sat Aug 15, 1987 04:35:55p  -by-  Bob Gunderson [bobgu]		;
; Wrote it.								;
;-----------------------------------------------------------------------;


cProc	LocalHeapSize,<PUBLIC,FAR>
cBegin nogen
	mov	bx,pLocalHeap
	mov	ax,[bx].hi_last
	sub	ax,[bx].hi_first
	ret
cEnd nogen


;-----------------------------------------------------------------------;
; LocalHandleDelta							;
; 									;
; Change the number of handles to allocate each time			;
; 	     								;
; Arguments:								;
;	delta = new # of handles or 0					;
;	DS = heap segment      						;
; 									;
; Returns:								;
;	AX = new number of handles					;
; 	     								;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,SI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
; 	BX								;
;									;
; Calls:								;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;


cProc	LocalHandleDelta,<PUBLIC,FAR>
	parmW 	delta
cBegin
	mov	bx,pLocalHeap
	mov	ax, delta
	or	ax, ax			; Zero means return present value
	jz	return_present_value
	mov	ax, delta
	mov	[bx].hi_hdelta, ax	; Set new value
return_present_value:
	mov	ax, [bx].hi_hdelta
cEnd
    
sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\module.asm ===
.xlist
include kernel.inc
include newexe.inc
include tdb.inc
.list

;externFP GlobalCompact
externFP GlobalFreeAll
externFP GetExePtr
externFP FarMyFree
externFP Far_genter
externFP FlushCachedFileHandle
externFP GetProcAddress
externFP FarUnlinkObject
externFP CallWEP
externFP lstrcpy


if SDEBUG
externFP FarDebugDelModule
endif

DataBegin

externB fBooting
;externW EMScurPID
externW curTDB
externW loadTDB
externW headTDB
externW hExeHead
externW pGlobalHeap
externW MyCSDS
externD pSignalProc

ifdef WOW
externW hWinnetDriver
externW hUser
endif ; WOW

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;-----------------------------------------------------------------------;
; UnlinkObject								;
;									;
; Removes an object from a singly linked list of objects.		;
;									;
; Arguments:								;
;	CS:BX = head of chain						;
;	ES    = object to delete					;
;	DX    = offset of next pointer in object			;
;									;
; Returns:								;
;	AX = deleted object						;
;									;
; Error Returns:							;
;	none								;
;									;
; Registers Preserved:							;
;	BX,DI,SI,BP,DS							;
;									;
; Registers Destroyed:							;
;	CX,DX,ES							;
;									;
; Calls:								;
;									;
; History:								;
;									;
;  Mon Sep 29, 1986 11:29:32a  -by-  Charles Whitmer  [chuckwh]		;
; Wrote it to remove this code from the three different places where	;
; it was included inline.						;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	UnlinkObject,<PUBLIC,NEAR>
cBegin	nogen
	push	di
	mov	di,dx

; keep DX = next object

	mov	dx,es:[di]

; see if the object is at the head

	push	ds
	SetKernelDS
	mov	cx,ds:[bx]		; start CX at head
	mov	ax,es			; AX = object to delete
	cmp	ax,cx
	jnz	not_at_head
	mov	ds:[bx],dx
	pop	ds
	UnSetKernelDS
	jmp	short unlink_done
not_at_head:
	pop	ds
	UnSetKernelDS

; run down the chain looking for the object

unlink_loop:
	jcxz	unlink_done
	mov	es,cx
	mov	cx,es:[di]
	cmp	ax,cx
	jnz	unlink_loop
	mov	es:[di],dx
unlink_done:
	pop	di
	ret
cEnd	nogen


sEnd	CODE

sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA
externNP DecExeUsage
externNP FlushPatchAppCache
IFNDEF NO_APPLOADER
externNP ExitAppl
ENDIF ;!NO_APPLOADER


;-----------------------------------------------------------------------;
; KillLibraries								;
;									;
; Scans the list of EXEs looking for Libraries.  For all Libraries	;
; it looks for a procedure called 'WEP'.  If found, WEP is called with	;
; fSystemExit set.							;
;									;
; Arguments:								;
;	None								;
;									;
; Returns:								;
;	None								;
;									;
; Error Returns:							;
;	none								;
;									;
; Registers Preserved:							;
;	DI,SI,BP,DS							;
;									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetProcAddress							;
;									;
; History:								;
;									;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	KillLibraries,<PUBLIC,FAR>,<DS>
	localW	hExe
cBegin
	SetKernelDSNRes
	mov	cx, hExeHead
kl_NextExe:
	UnSetKernelDS
	mov	ds, cx			; This skips first module (kernel)
	mov	cx, ds:[ne_pnextexe]
	jcxz	kl_done
	push	cx
	cCall	CallWEP, <cx, 1>	; Call for any module (call is fast)
	pop	cx
	jmp	kl_NextExe
kl_done:
cEnd

;-----------------------------------------------------------------------;
; AddModule								;
; 									;
; Adds a module to the end of the list of modules.			;
; 									;
; Arguments:								;
;	parmW   hExe	seg of module to add				;
; 									;
; Returns:								;
;	AX != 0 if successful						;
;									;
; Error Returns:							;
;	AX == 0 if error detected					;
;									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES 							;
;									;
; Calls:								;
;	GlobalCompact							;
;	CalcMaxNRSeg							;
;	FarRedo_library_entries 					;
; 									;
; History:								;
;  Wed 24-Jul-1991 -by- Don Corbitt [donc]				;
; Finish removal of Real mode code, dead code.  Remove module from 	;
; list if insufficient memory.  Directly set DS on entry.		;
; 									;
;  Thu 23-Mar-1989 23:00:40  -by-  David N. Weise  [davidw]		;
; Made tasks and libraries be separate on the module chain.		;
;									;
;  Thu Feb 25, 1988 08:00:00a  -by-  Tim Halvorsen    [iris]            ;
; Check new error return from Redo_library_entries, returned when	;
; we totally run out of space for another library's entry table		;
; in EMS (the entry table is for ALL tasks, not just this task).	;
; Fix comments above to reflect correct returns from this routine.	;
; 									;
;  Wed May 06, 1987 00:07:20a  -by-  David N. Weise      [davidw]	;
; Added support for EMS and library entrys.				;
; 									;
;  Thu Dec 11, 1986 12:10:26p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block, and made it set calculate and set	;
; ne_swaparea.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	AddModule,<PUBLIC,NEAR>,<ds>
	parmW   hExe
	localW	hLast			; last module in current list
cBegin
	SetKernelDSNRes
	xor	bx,bx
	mov	cx,hExeHead

am0:	mov	es,cx			; find end of linked list of exe's
	mov	cx,es:[bx].ne_pnextexe
	or	cx, cx
	jnz	am0

; Here to add a module to the end of the chain.  BX == 0.

	mov	hLast, es		; so we can remove hExe on failure
	mov	ax,hExe
	mov	es:[bx].ne_pnextexe,ax
	mov	es,ax
	mov	es:[bx].ne_pnextexe,bx

        xor     bx,bx
am_done:
	mov	ax,hExe
am_exit:
cEnd


;-----------------------------------------------------------------------;
; DelModule								;
; 									;
; Deletes a module from the list of modules.				;
; 									;
; Arguments:								;
;	parmW   hExe	seg of module to delete				;
; 									;
; Returns:								;
;	AX = 0								;
;									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
;	AX,BX,CX,DX,ES							;
; 									;
; Calls:								;
;	FarUnlinkObject 						;
;	GlobalFreeAll							;
;	CalcMaxNRSeg							;
;	EMSDelModule							;
;									;
; History:								;
; 									;
;  Wed May 06, 1987 00:07:20a  -by-  David N. Weise      [davidw]	;
; Added support for EMS and library entrys.				;
; 									;
;  Tue May 05, 1987 10:36:29p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DelModule,<PUBLIC,NEAR>,<ds,di>
	parmW	pExe
cBegin
	SetKernelDSNRes

if SDEBUG
	mov	es, pExe
	call	FarDebugDelModule	; is ES preserved?
endif

	cCall	CallWEP,<pExe,0>

	mov	es, pExe
	test	es:[ne_flags],NENOTP
	jz	dm_not_a_lib


; call user to clean up any stuff
	test	es:[ne_flags],NEPROT	; OS/2 app?  is this necessary???
	jnz	no_user_yet
	cmp	pSignalProc.sel,0
	jz	no_user_yet
	xor	ax,ax
	mov	bx,80h
	mov	es:[ne_usage],1
	push	es
	cCall	pSignalProc,<pExe,bx,ax,ax,ax>
	pop	es
	mov	es:[ne_usage],0
no_user_yet:

dm_not_a_lib:
					; Following code moved here
					; from FreeModule  1/18/89
	mov	es,pExe
	mov	bx,es:[ne_pautodata]
	or	bx,bx
	jz	fm00
	cCall	FarMyFree,<es:[bx].ns_handle>	; Free DS separately to free thunks
fm00:
IFNDEF NO_APPLOADER
	mov	es,pExe
	test	es:[ne_flags],NEAPPLOADER
	jz	normal_unload
;*	* special unload for AppLoader
	cCall	ExitAppl,<es>
normal_unload:
ENDIF ;!NO_APPLOADER			; END code from FreeModule
    cCall   FlushPatchAppCache, <pExe>      ; Flush out Module Patch  cache
    cCall   FlushCachedFileHandle,<pExe>    ; Flush out of file handle cache
	cCall	Far_genter		; so we don't interfere with lrusweep
	SetKernelDSNRes
	mov	es,pExe
	mov	dx,ne_pnextexe
	mov	bx,dataOffset hExeHead
	call	FarUnlinkObject
	mov	es,pGlobalHeap
	xor	di,di
	dec	es:[di].gi_lrulock

	mov	es,pExe 		; Make sure no one mistakes this for
	mov	es:[di].ne_magic,di	; an exe header anymore.
	cCall	GlobalFreeAll,<pExe>
        xor     ax,ax
cEnd





;-----------------------------------------------------------------------;
; FreeModule								;
; 									;
; Deletes the given module from the system.  First it decs the usage	;
; count checking to see if this is the last instance, ( this may 	;
; indirectly free other modules).  If this is the last instance then	;
; it frees the automatic data segment to free any thunks associated	;
; with this module.  Then the module is deleted.  If this was not the	;
; last instance then the ns_handle for the automatic data seg may have	;
; to be updated.							;
;									;
; Arguments:								;
;	parmW   hInstance						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 03-Apr-1989 22:22:01  -by-  David N. Weise  [davidw]		;
; Removed the GlobalCompact at the end of this routine. 		;
;									;
;  Fri Jul 10, 1987 11:54:51p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

labelFP <PUBLIC, IFreeLibrary>

	assumes ds,nothing
	assumes es,nothing

cProc	IFreeModule,<PUBLIC,FAR>,<si,di>
	parmW   hInstance
cBegin
	cCall	GetExePtr,<hInstance>	; Get exe header address
	or	ax,ax
	jz	fmexit1
	mov	si,ax

ifdef WOW
    ; we can't allow anybody except user.exe take the ref count for 16-bit net 
    ; driver down to 0 (see pNetInfo in user16\net.c winnet.asm) bug #393078
	mov	es,si
	cmp	es:[ne_usage],1
    jnz  fmNoProb  ; if usage ref count isn't 1 -- no worries
    
    mov dx,word ptr [bp+4]   ; selector of calling module

    ; See if it is user.exe freeing the net driver.
    cCall <far ptr IsOKToFreeThis>,<dx,ax> 
    or   ax,ax            ; Will be 0 if & only if the module being freed is 
                          ; 16-bit net driver & the module freeing it is NOT 
                          ; user.exe. Otherwise ax will = si
	jz   fmexit1   ; lie & say we freed 16-bit net driver & return ref count = 0
    
fmNoProb:
endif  ; WOW

    cCall   DecExeUsage,<si>        ; Decrement usage count
	jnz	fmfree			; If non-zero, then just free inst.
ifdef WOW
        ; Word Perfect v5.2 needs DX to contain a number >= 0x17 inorder
        ; to print properly.  Since on Win 3.1, the DX value came from
        ; this point, lets save it for them.  (On Win 3,1, the printer
        ; driver was being free'd here, but not deleted, GDI or spooler
        ; still has it open).
        push    dx
endif
        cCall   DelModule,<si>          ; If zero, free entire module
ifdef WOW
        pop     dx
endif

fmexit1:
	jmps	fmexit
fmfree:
	mov	es,si
	test	byte ptr es:[ne_flags],NEINST
	jz	fmexit			; All done if not a multiple inst
	mov	bx,es:[ne_pautodata]
	push	es:[bx].ns_handle
	cCall	FarMyFree,<hInstance>	; Free instance
	pop	dx
	cmp	dx,hInstance		; Did we free current instance?
	jne	fmexit			; No, then continue

	cCall	MapDStoDATA
	ReSetKernelDS
	xor	ax,ax
	xor	bx,bx
	mov	cx,headTDB		; Yes, search TDBs looking for
	UnSetKernelDS
fm0:	jcxz	fm1			;  another instance handle
	mov	es,cx
	cmp	si,es:[bx].TDB_pModule
	mov	cx,es:[bx].TDB_next
	jnz	fm0

	mov	ax,es:[bx].TDB_module
	cmp	ax,hInstance		; Is this the instance we're quitting?
	jz	fm0

fm1:	mov	es,si
	mov	bx,es:[bx].ne_pautodata
	mov	es:[bx].ns_handle,ax	; Remember handle of data seg
fmexit:

cEnd

sEnd	NRESCODE



ifdef WOW
sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;
; called by user.exe\net.c\LW_InitNetInfo()
;
; Arguments:
;	parmW   hInstNetDrv - hInstance of net driver library loaded by user.exe
;
; Returns:
;    nothing
;
cProc   TellKrnlWhoNetDrvIs, <PUBLIC,FAR>,<si,di>
    parmW   hInstNetDrv
cBegin
	SetKernelDS
    cCall getexeptr,<hInstNetDrv> 
    mov hWinnetDriver,ax     ; save hMod of net driver
	UnSetKernelDS
cEnd


;
; Should only be called if the ref (usage) count for module being freed is 1.
; (ie. about to go to zero)
;
; Arguments:
;	parmW   modsel   - selector of code calling FreeModule
;   parmW   hModFree - hModule of module being freed
;
; Returns:
;    0  if & only if the module being freed is hWinnetDriver as set by user.exe
;       AND the module calling FreeModule is NOT user.exe
;    Otherwise: the hMod of the module being freed
;
cProc   IsOKToFreeThis, <PRIVATE,FAR>,<si,di>
    parmW modsel
    parmW hModFree
cBegin
	SetKernelDS
    mov  ax,hModFree
    cmp  ax,hWinnetDriver               ; is hMod of the net driver module?
    jnz  IOKExit                        ; Exit if not -- no worries

    ; Danger! hMod being freed is the net driver
    cCall getexeptr,<modsel>             ; get hMod of caller
     
    cmp ax,hUser                        ; See if caller is user.exe
    jz  IOK2FT1                         ; yep, that's OK   

    xor ax,ax                           ; ret 0 so we don't free the net driver
    jmp IOKExit

IOK2FT1:
    mov  ax,hModFree
IOKExit:
	UnSetKernelDS
cEnd
    
endif  ; WOW

sEnd	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lzexp.c ===
/*
 * LZEXP.C
 *
 * Routines used in Lempel-Ziv expansion.
 *
 */

#include	"kernel.h"

#if ROM  //--------------------------------------------------------------


#define API _far _pascal _loadds

#define RING_BUF_LEN       4096        // size of ring buffer
#define MAX_RING_BUF_LEN   4224        // size of ring buffer - from LZFile
                                       // struct declaration in lzexpand.h

#define BUF_CLEAR_BYTE     ((BYTE) ' ')   // rgbyteRingBuf[] initializer

#define MAX_LITERAL_LEN    2           // encode string into position and
                                       // length if match length greater than
                                       // this value (== # of bytes required
                                       // to encode position and length)

#define LZ_MAX_MATCH_LEN      (0x10 + MAX_LITERAL_LEN)
                                       // upper limit for match length
                                       // (n.b., assume length field implies
                                       // length += 3)

#define END_OF_INPUT	   500	    // EOF flag for input file

#define FOREVER   for(;;)

#define ReadByte(byte)	       ((byte = (BYTE)(cbSrc ? *pSrc++ : 0)), \
				(cbSrc ? (cbSrc--, TRUE) : END_OF_INPUT))
#define WriteByte(byte)        ((*pDst++ = byte), cblOutSize++)

typedef struct COMPHEAD _far * LPCOMPHEAD;

struct COMPHEAD {		    // Compressed segment/resource header
    BYTE  Sig;				// signature
    BYTE  Method;			// compression method
    DWORD cbSize;			// # compressed bytes following
};

#define CMP_SIG     ('C')
#define CMP_LZ	    ('L')


/*
 * LZDecode
 *
 * Parameters:
 *	selDst			Selector pointing to destination buffer
 *	selSrc			Selector pointing to compressed data
 *	lpBuf			Pointer to optional ring buffer
 *
 * Returns:
 *	count (in bytes) of uncompressed data written to selDst buffer
 *
 * Note:  This routine does not use any static or external data.
 *	This allows it to be used to uncompress Kernel's own
 *	data segment.
 */

DWORD FAR API
LZDecode(WORD selDst, WORD selSrc, LPSTR lpBuf) {

   int i,
       cb,                          // number of bytes to unpack
       f;                           // holds ReadByte() return values
   int oStart;                      // buffer offset for unpacking
   BYTE byte1, byte2;               // input byte holders
   unsigned uFlags;		    // LZ decoding description byte
   int iCurRingBufPos;		    // ring buffer offset
   int cbMaxMatchLen;
   LPSTR rgbyteRingBuf;
   HANDLE hRingBuf;
   LPCOMPHEAD lpHead;
   DWORD cblOutSize, cbSrc;
   char _based((_segment)selDst) *pDst = NULL;
   char _based((_segment)selSrc) *pSrc = NULL;
   struct COMPHEAD _based((_segment)selSrc) *pHead = NULL;

   pSrc += sizeof(struct COMPHEAD);

   cblOutSize = 0;
   cbSrc = pHead->cbSize;
   cbMaxMatchLen = LZ_MAX_MATCH_LEN;

   // Make sure we know how to expand this object

   if (pHead->Sig != CMP_SIG || pHead->Method != CMP_LZ)
       return(0);

   // Set up a fresh buffer state.
   if (lpBuf) {
	hRingBuf = NULL;
	rgbyteRingBuf = lpBuf;
   } else {
	if (!(hRingBuf = GlobalAlloc(GMEM_MOVEABLE,MAX_RING_BUF_LEN)))
	    return(0);
	rgbyteRingBuf = GlobalLock(hRingBuf);
   }

   // Initialize ring buffer.
   for (i = 0; i < RING_BUF_LEN - cbMaxMatchLen; i++)
       rgbyteRingBuf[i] = BUF_CLEAR_BYTE;

   // Initialize decoding globals.
   uFlags = 0U;
   iCurRingBufPos = RING_BUF_LEN - cbMaxMatchLen;

   f = ReadByte(byte1);

   // Decode one encoded unit at a time.
   FOREVER
   {
      if (f == END_OF_INPUT)  // EOF reached
         break;

      // High order byte counts the number of bits used in the low order
      // byte.
      if (((uFlags >>= 1) & 0x100) == 0)
      {
         // Set bit mask describing the next 8 bytes.
         uFlags = ((unsigned)byte1) | 0xff00;

         if ((f = ReadByte(byte1)) != TRUE)
	    break;
      }

      if (uFlags & 1)
      {
         // Just store the literal byte in the buffer.
	 WriteByte(byte1);

         rgbyteRingBuf[iCurRingBufPos++] = byte1;
         iCurRingBufPos &= RING_BUF_LEN - 1;
      }
      else
      {
         // Extract the offset and count to copy from the ring buffer.
         if ((f = ReadByte(byte2)) != TRUE)
	    break;

         cb = (int)byte2;
         oStart = (cb & 0xf0) << 4 | (int)byte1;
         cb = (cb & 0x0f) + MAX_LITERAL_LEN;

         for (i = 0; i <= cb; i++)
         {
            byte1 = rgbyteRingBuf[(oStart + i) & (RING_BUF_LEN - 1)];

	    WriteByte(byte1);

            rgbyteRingBuf[iCurRingBufPos++] = byte1;
            iCurRingBufPos &= RING_BUF_LEN - 1;
         }
      }

      f = ReadByte(byte1);
   }

   if (hRingBuf) {
      GlobalUnlock(hRingBuf);
      GlobalFree(hRingBuf);
   }

   return(cblOutSize);
}

#endif //ROM	  -------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\lstring.asm ===
TITLE   LSTRING

include kernel.inc
include gpfix.inc
include wowcmpat.inc

DataBegin

externB fFarEast		; non zero if far eastern keyboard
externB KeyInfo			; Info returned by KEYBOARD.Inquire
ifdef	FE_SB
externB fDBCSLeadTable	    ; DBCS Lead byte flag array
endif

if ROM
externD pStringFunc	    ; Entry point of string functions in USER.
endif

DataEnd

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

ifdef WOW
externNP MyGetAppWOWCompatFlags
endif
ife ROM
externD pStringFunc	    ; Entry point of string functions in USER.
endif


; Function codes for all the string functions in USER
;
ANSINEXT_ID	equ	1
ANSIPREV_ID	equ	2
ANSIUPPER_ID	equ	3
ANSILOWER_ID	equ	4

;
; lstrlen: Same as strlen except for taking long ptrs
;

cProcVDO lstrlen,<PUBLIC,FAR>
;       parmD   pStr
cBegin  nogen
	mov     bx,sp
	push    di
beg_fault_trap  sl_trap
	les     di,ss:[bx+4]
	cld
	xor     ax,ax			; get zero in ax
	mov     cx,-1			; at most 64 k to move
	repnz   scasb			; look for end
	mov     ax,cx
	neg     ax
	dec     ax
	dec     ax
end_fault_trap
sl_exit:
	pop     di
	ret     4
cEnd    nogen

sl_trap:
	fault_fix_stack
	xor     ax,ax
	jmp     sl_exit

lstr_trap:
	fault_fix_stack

lstrfinish  proc    far
	pop     di
	pop     si
	pop     ds
	ret     8
lstrfinish  endp


; lstrcpyn - lstrcpy with a limit length -- NEVER null-padded, but ALWAYS
; null-terminated.
cProc   lstrcpyn,<PUBLIC,FAR>,<ds,si,di>
        parmD   pDst
        parmD   pSrc
        parmW   wLen
cBegin
        xor     dx,dx
        jmp     lstrn
cEnd	nogen

; lstrcatn - lstrcat with a limit length -- NEVER null-padded, but ALWAYS
; wLen is the pDst buffer size
cProc	lstrcatn,<PUBLIC,FAR>,<ds,si,di>
        parmD   pDst
        parmD   pSrc
        parmW   wLen
cBegin
        mov     dx,1
lstrn:
        mov     bx, [wLen]
        or	bx, bx
        jz	lstrn_err1
beg_fault_trap  lstrn_err
        cld
        les     di, [pSrc]              ; Find length of source string
        mov     cx, -1
        xor     ax, ax
        repnz   scasb
        not     cx                      ; length now in CX (incl null term)

        lds     si, [pSrc]              ; Set up for copy
        les     di, [pDst]

        cmp     dx,0                    ; check for lstrcatn or lstrcpyn
        je      lstrn_prepcopy
        push    cx                      ; Store source string length
        xor     ax,ax                   ; get zero in ax
        mov     cx,-1                   ; at most 64 k to look
        repnz   scasb                   ; look for end
        not     cx
        mov     ax, cx
        pop     cx
        cmp     bx, ax
        jle     lstrn_finish
        dec     di                      ; Point at null byte
        dec     ax                      ; remove null terminator
        sub     bx, ax
lstrn_prepcopy:
        cmp     cx, bx                  ; Check destination length
        jbe     lstrn_copy
        mov     cx, bx
lstrn_copy:
        xor     ax,ax           ; do we really need this ??
        dec     cx                      ; save space for null
        shr     cx, 1                   ; Copy the string
        rep     movsw
        adc     cx, cx
        rep     movsb

        stosb                           ; null terminate string

end_fault_trap
lstrn_finish:
        mov     ax, [OFF_pDst]          ; ptr to dest in DX:AX
        mov     dx, es
lstrn_exit:
cEnd

lstrn_err:
        fault_fix_stack
        krDebugOut      DEB_ERROR, "GP fault in lstrcatn / lstrcpyn"
lstrn_err1:
        xor     ax, ax
        cwd
        jmps    lstrn_exit


lstrsetup:
	pop     dx
	mov     bx,sp

	push    ds
	push    si
	push    di

beg_fault_trap  lstr_trap
	lds     si,ss:[bx+4]
	les     di,ss:[bx+8]
	cld
	jmp     dx
;
;lstrcpy: strcpy with long pointers
;
cProcVDO lstrcpy,<PUBLIC,FAR>
;       parmD   pDst			; [bx+8]
;       parmD   pSrc			; [bx+4]

cBegin  nogen
	call    lstrsetup
        mov     dx,di                   ; save for return

lcp1:   lodsb
	stosb
	or      al,al
	jnz     lcp1

        xchg    ax,dx                   ; return ds:ax = original dest
        mov     dx,es
	jmp     lstrfinish
cEnd    nogen


;
;lstrcat: Same as strcat except with long ptrs.
;
cProcVDO lstrcat,<PUBLIC,FAR>
;   parmD   pDst
;   parmD   pSrc

cBegin  nogen
	call    lstrsetup
        mov     dx,di                   ; save original dest for return
	xor     ax,ax			; get zero in ax
	mov     cx,-1			; at most 64 k to look
	repnz   scasb			; look for end
	dec     di			; Point at null byte
ifndef WOW
	jmp     lcp1			; jump to lstrcpy loop
else
lcp1_wow:   lodsb
	stosb
	or      al,al
	jnz     lcp1_wow

        ; normal lstrcat is now complete.
        ;
        ; Now begins a GROSS HACK HACK HACK for fixing wordperfect
        ; For compatibility reasons we want to check if the function call
        ; was of type lstrcat(lpsz, ".WRS");
        ;
        ; the checks are:
        ;                 let lpDest = ".WRS"
        ;                 if (lstrlen(lpDest)+NULLCHAR == 5) &&
        ;                     !lstrcmp(lpDest, ".WRS")) {
        ;                     if (wordperfect) {
        ;                        remove all backslashes in lpsz
        ;                     }
        ;                 }
        ;
        ; we do these checks after the concatenation 'cause it means that
        ; source string is valid and we wont GP fault while accessing the
        ; source string
        ;                                                - Nanduri

        sub     si, 5
        cmp     si, ss:[bx+4]
        jnz     @F
        cmp     [si], 'W.'    ; ".W"
        jnz     @F
        cmp     [si+2], 'SR'  ; "RS"
        jnz     @F

lscat_DOTWRS:
        ; here if lstrcat (lpString, ".WRS")
        ; now make sure that it is wordperfect. this is a gross hack so
        ; why care for efficiency.

        push dx
        call MyGetAppWOWCompatFlags
        test dx, word ptr cs:[gacf_dotwrs+2]
        pop  dx
        jz   @F
        jmp  short replace_slashes

gacf_dotwrs:
        DD WOWCF_SANITIZEDOTWRSFILES

replace_slashes:

        ; yes it is. strip backslashes if any.
        ; if there are any backslashes the lpString would be of the form
        ; \\blahblah or \\blah\blah. note that 'blah' is not important, the
        ; backslashes are.
        ;

        push    es
        pop     ds
        mov     si, dx
        mov     di, dx
slash_a_slash:
        lodsb
        cmp al, '\'
        je slash_a_slash
        stosb
        or  al, al
        jnz slash_a_slash
@@:
        xchg    ax,dx                   ; return ds:ax = original dest
        mov     dx,es
	jmp     lstrfinish
endif


cEnd    nogen

;
;lstrOriginal: This is language independent version of lstrcmp
;  specially made for kernel.
;           (i made it case insensitive...chrisp)
;
cProcVDO lstrOriginal,<PUBLIC,FAR>
;       parmD   ps1
;       parmD   ps2
cBegin  nogen
	call    lstrsetup
lcmploop:
	xor     ax,ax
	cmp     es:byte ptr [di],al
	jz      ldidone			; left hand side finished <=
	cmp     byte ptr [si],al
	jz      lsismall		; right hand side finished, >
	lodsb
ifdef FE_SB
	call    MyIsDBCSLeadByte
	jc      cmp1
	mov     ah,ds:[si]
	inc     si
	jmp     short cmp2
endif
cmp1:   call    MyLower
	xor     ah,ah

cmp2:   mov     bx,ax
	mov     al,es:[di]
	inc     di
ifdef FE_SB
	call    MyIsDBCSLeadByte
	jc      cmp3
	mov     ah,es:[di]
	inc     di
	jmp     short cmp4
endif
cmp3:   call    MyLower
	xor     ah,ah

cmp4:   cmp     ax,bx			; effectlively es:[di],ds:[si]
	jz      lcmploop		; still equal
	mov     ax,0			; preverve flags
	jb      ldismall		; di is less than si
lsismall:
	inc     ax
	jmp     short lstrcmpend
ldidone:
	cmp     byte ptr ds:[si],0
	jz      lequal
ldismall:
	dec     ax
lequal:
lstrcmpend:
	jmp     lstrfinish
cEnd    nogen

end_fault_trap

;--------------------------------------------------------
;
;  ANSI compatible string routines
;

	public	AnsiUpper, AnsiLower, AnsiPrev, AnsiNext

AnsiUpper:
	mov     cl,ANSIUPPER_ID
	jmpnext
AnsiLower:
	mov     cl,ANSILOWER_ID
	jmpnext
AnsiPrev:
	mov     cl,ANSIPREV_ID
	jmpnext
AnsiNext:
	mov     cl,ANSINEXT_ID
	jmpnext end

	xor	ch,ch
if ROM
	push	ds
	SetKernelDS
endif
	cmp	pStringFunc.sel,0	; Is there a USER around?
	jz	no_user_function
if ROM
	push	bp
	mov	bp,sp
	push	pStringFunc.sel
	push	pStringFunc.off
	mov	ds,[bp][2]
	UnSetKernelDS
	mov	bp,[bp]
	retf	4
else
	jmp	pStringFunc
endif

no_user_function:
if KDEBUG
	int	3
endif
if ROM
	pop	ds
	UnSetKernelDS
endif
	cmp	cl,ANSIPREV_ID
	jz	@F
	retf	4
@@:	retf	8

;----------------------------------------------------------------------------
; MyUpper: Called from LDSelf.ASM
; convert lower case to upper, must preserve es,di,cx
;---------------------------------------------------------------------------

	public  MyUpper
MyUpper:
	cmp     al,'a'
	jb      myu2
	cmp     al,'z'
	jbe     myu1
ifdef FE_SB
	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; Far east ?
	pop	ds
	UnSetKernelDS
	jge	myu2		; yes do nothing to the Microsoft fonts.
endif
	cmp     al,0E0H		; this is lower case a with a back slash
	jb      myu2
	cmp	al, 0F7H ; This is division mark in Microsoft fonts; So, don't
	je	myu2	 ; convert this; Fix for Bug #1356 -SANKAR-08-28-89;
	cmp     al,0FEH
	ja      myu2
myu1:   sub     al,'a'-'A'
myu2:   ret

;----------------------------------------------------------------------------
; MyLower:  Called from Atom.asm, LdOpen.asm, ldUtil.asm, ldself.asm
; convert upper case to lower, must preserve es,di,cx
;----------------------------------------------------------------------------
	public  MyLower
MyLower:
	cmp     al,'A'
	jb      myl2
	cmp     al,'Z'
	jbe     myl1

	push	ds
	SetKernelDS
	cmp	[fFarEast],1	; this is a far east kbd 1/12/87 linsh
	pop	ds
	UnSetKernelDS
	jge	myl2		; yes do nothing to the 0C0H - 0DEH range

	cmp     al,0C0H		; this is lower case a with a back slash
	jb      myl2

	cmp	al, 0D7H ; This is multiply mark in Microsoft fonts; So, don't
	je	myl2	 ; translate this; Fix for Bug #1356;-SANKAR-08-28-89;

	cmp     al,0DEH
	ja      myl2
myl1:   add     al,'a'-'A'
myl2:   ret


;-----------------------------------------------------------------------;
; IsDBCSLeadByte							;
;
; This Function will be exist on US Windows, but it
; returns FALSE always.
;
;-----------------------------------------------------------------------;

cProc	IsDBCSLeadByte,<PUBLIC,FAR>
;	parmW	char	ss:[bx+04]
cBegin	nogen
ifdef FE_SB
	mov	bx,sp
	push	ds
	SetKernelDS
;;	push	di
;;
;;	mov	ax,ss:[bx+04]
;;	call	MyIsDBCSLeadByte
;;	jnc	id1
;;	xor	ax,ax
;;	jmp	idx
;;id1:	mov	ax,1
;;idx:
;;
;;	pop	di
	mov	al, byte ptr ss:[bx+4]
	mov	bx, offset fDBCSLeadTable
	xlat
	xor	ah,ah
	pop	ds
	UnSetKernelDS
else
	xor	ax,ax
endif
	ret	2
cEnd	nogen


ifdef FE_SB

; This API returns DBCS lead byte table for applications which
; in turn can speed up DBCS checking without making calls to
; IsDBCSLeadByte.
;-----------------------------------------------------------------------;
; GetDBCSEnv								;
;
; int GetDBCSEnv(LPSTR lpsz, int cbMax)
; lpsz: long ptr points to buffer to receive DBCS lead byte table
; cbMax: how many bytes the buffer pointed to by lpsz.
;	 0 if inquire buffer size required to receive the table
; return (ax) 0 if failed else the size of the table.
; use:	AX, BX, CX, DX
;
;
;-----------------------------------------------------------------------;

;
cProc	GetDBCSEnv,<PUBLIC,FAR>
;	parmD	ss:[bx+6]		    ;lpsz
;	parmW	ss:[bx+4]		    ;cbMax
cBegin	nogen
	mov	bx,sp			    ;frame ptr
	push	es
	push	di
	push	si
;;; 12 bytes should be enough to accumulate our result.
;;; However, if fDBCSLeadTable corrupt then we are dead!!!!
	sub	sp,12			    ;temp private storage
	mov	si,sp			    ;
	SetKernelDS	es		    ;
	mov	di, offset fDBCSLeadTable   ;
	cld
	mov	al,1			    ;
	mov	cx,256			    ;256 bytes in table
GDE_loop:
	xor	al,1			    ;toggle the match pattern (0/1)
	repe	scasb			    ;
	jz	GDE_done		    ;not found then CX must be 0
	mov	ah,cl			    ;calc the index
	sub	ah,255
	neg	ah
	sub	ah,al			    ;
	mov	ss:[si],ah		    ;save it
	inc	si
	jmps	GDE_loop
GDE_done:
	mov	word ptr ss:[si],0	    ;terminated with 0,0
	mov	ax,si
	sub	ax,sp			    ;how many bytes we got?
	jz	GDE_Exit		    ;none, return
	add	ax,2			    ;count the terminated bytes
	inc	si			    ;and advance ptr to the last 0
	mov	cx,ss:[bx+4]		    ;get cbMax
	jcxz	GDE_Exit		    ;return if inquire buffer size
	cmp	cx,ax			    ;enough buffer provided ?
	jge	@F
	xor	ax,ax			    ;no, return error
	jmps	GDE_Exit

@@:
beg_fault_trap	GDE_gp
	les	di, ss:[bx+6]		    ;lpsz
	mov	cx,ax			    ;how many bytes to copy
	add	di,ax
	dec	di			    ;offset started from 0
	std
rep	movs	byte ptr [di],ss:[si]

end_fault_trap

GDE_Exit:
	cld
	UnSetKernelDS	es
	add	sp, 12
	pop	si
	pop	di
	pop	es
	ret	6
cEnd	nogen

GDE_gp:
	fault_fix_stack
	xor	ax, ax			    ;invalide lpsz, return ax=0
	jmps	GDE_Exit


;--------------------------------------------------------------------------
;
; return carry clear if character in AL is first byte of DBCS
;
;--------------------------------------------------------------------------
	public  MyIsDBCSLeadByte
MyIsDBCSLeadByte:
	push	ds
	SetKernelDS
	push	ax		; Save AX for caller
	push    bx		; Save BX for caller
	mov	bx, offset fDBCSLeadTable
	xlat
	shr	al,1		; refrect to carry flag
	cmc
	pop	bx
	pop	ax
;;	cmp	[fFarEast],1	; not in far east?
;;	jb	ikx		; carry set if not far east keyboard
;;	mov	cx,[KeyInfo].kbRanges.lo
;;	cmp	cl,ch
;;	ja	iknk		; lower range invalid, not kanji
;;	cmp	al,cl
;;	jb	ik1		; below lower range, try second range
;;	cmp	al,ch
;;	jbe	ikgk		; inside lower range, valid kanji char
;;
;;ik1:	mov	cx,[KeyInfo].kbRanges.hi
;;	cmp     cl,ch                                   ; valid upper range?
;;	ja      iknk                                    ; no, not kanji
;;	cmp     al,cl           ; is it within range?
;;	jb      ikx             ; trick...carry already set
;;	cmp     al,ch
;;	ja      iknk
;;ikgk:   clc                     ; within range...valid kanji char
;;	jmp     short ikx
;;
;;iknk:   stc
;;ikx:
;;	pop     cx
	pop	ds
	UnSetKernelDS
	ret

	public	FarMyIsDBCSLeadByte
FarMyIsDBCSLeadByte proc far
	call	MyIsDBCSLeadByte
	ret
FarMyIsDBCSLeadByte endp


	public	MyIsDBCSTrailByte
MyIsDBCSTrailByte   proc    near
;----------------------------------------------------------
; IsDBCSTrailByte
; Check if the indexed byte is a DBCS char trailing byte.
;
; Input:
; ES:SI = char	*ach[]
; ES:DI -> position of character of interested.
;
; Output:
; Carry flag clear if it is a DBCS trailing byte
; Carry flag set if it is a SBCS or DBCS leading byte
;
; Use:
; flags
;
;----------------------------------------------------------
	cmp	si,di			    ;if beginning >= index?
	jae	IDTB_Exit		    ;yes, SBCS or DBCS 1st (CF=1)

	push	si
	push	ax
	cld				    ;no chance
@@:
	lods	byte ptr es:[si]	    ;
	call	MyIsDBCSLeadByte
	cmc
	adc	si,0			    ;si++ if DBCS
	cmp	di,si			    ;hit the target yet?
	ja	@B			    ;go to loop if not yet
	pop	ax			    ;di=si, we have a SBCS or DBCS 1st
	pop	si			    ;di < si, we have a DBCS 2nd
IDTB_Exit:
	cmc
	ret
MyIsDBCSTrailByte   endp

;---------------------------------------------------------------
	public	FarMyIsDBCSTrailByte
FarMyIsDBCSTrailByte proc far
	call	MyIsDBCSTrailByte
	ret
FarMyIsDBCSTrailByte endp
endif	; FE_SB

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\miscapi.asm ===
.xlist
include kernel.inc
include pdb.inc
include tdb.inc
include newexe.inc
include eems.inc
.list

externFP GlobalDOSAlloc
externFP GlobalDOSFree
externFP GetProfileString

DataBegin

externB kernel_flags
externW MyCSAlias
externW curTDB
externW headTDB
if 0 ; EarleH
externW LastCriticalError
endif
externW LastExtendedError

externD FatalExitProc

if ROM
externD PrevInt21Proc
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes	ds, nothing
assumes	es, nothing

ife ROM
externD PrevInt21Proc
endif

externNP SetOwner

;-----------------------------------------------------------------------;
; A20Proc								;
; 	Enable / Disable the A20 line by calling an XMS driver		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu Mar 31, 1988 -by-  Tony Gosling					;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	A20Proc,<PUBLIC,FAR>,<si,di>
	parmW	enable
cBegin
cEnd


;**
;
; NETBIOSCALL -- Issue an INT 5C for caller
;
;	This call is provided as a Kernel service to applications that
;	wish to issue NETBIOS INT 5Ch calls WITHOUT coding an INT 5Ch, which
;	is incompatible with protected mode.
;
;   ENTRY:
;	All registers as for INT 5Ch
;
;   EXIT:
;	All registers as for particular INT 5Ch call
;
;   USES:
;	As per INT 5Ch call
;
;
cProc	NETBIOSCALL,<PUBLIC,FAR>
cBegin
	int	5Ch
cEnd


;**
;
; SetHandleCount -- Set the handle count in the PDB
;
;	Sets the per process handle count to a new value
;	and allocates space for these file handles
;
;   ENTRY:
;	nFiles - new number of file handles required
;
;   EXIT:
;	returns new number of file handles
;
;   USES:
;	C call
;
;
cProc	ISetHandleCount,<PUBLIC,FAR>,<di,si>
	parmW	nFiles
cBegin
	SetKernelDS
	mov	si, CurTDB
	mov	ds, si
	UnSetKernelDS
	mov	ds, ds:[TDB_PDB]

        ;** We allow no more than 255.  Also, if something smaller than what
        ;**     we have, we just do nothing and respond with the number we
        ;**     already have.
	mov	ax, ds:[PDB_JFN_Length]	; How many now
        cmp     nFiles,255              ;Validate the parameter
        jbe     SHC_OK                  ;Parm OK

IF KDEBUG
	push	ax
	kerror	ERR_PARAMETER,<SetHandleCount:  Too many files requested:>,nFiles,0
	pop	ax
ENDIF
	mov     nFiles,255              ;Force it to do no more than 255
SHC_OK:	mov	bx, nFiles
	cmp	ax, bx			; Don't want more?
        jae     no_change

        ;** Allocate memory for a new file handle table
	add	bx, 2
	cCall	GlobalDOSAlloc, <0, bx>
	or	ax, ax
	jnz	ok_we_got_it
	mov	ax, ds:[PDB_JFN_Length]	; Return original number
	jmp     SHORT no_change
ok_we_got_it:

        ;** Prepare the new table and update the PDB for the new table
	cCall	SetOwner,<ax,si>	;Hide it from GlobalFreeAll
        mov     es, ax                  ;Point to new table with ES
	mov	WORD PTR ds:[PDB_JFN_Pointer][2], dx ;Save seg address
	xor	di, di
	mov	si, word ptr ds:[PDB_JFN_Pointer] ;Offset of old table
	mov	cx, ds:[PDB_JFN_Length] ;Bytes to copy (one byte per handle)
	mov	WORD PTR ds:[PDB_JFN_Pointer][0], di ;Save new offset
	mov	bx, nFiles              ;Save new number of files
	mov	ds:[PDB_JFN_Length], bx
	push	ds                      ;Save PDB selector for later

        ;** We use the PDB selector to copy if we're copying the original
        ;**     table which is always in the PDB.  Note that we only have a
        ;**     non-zero offset if the table is in the PDB.  We can't save
        ;**     the selector in the table in this case until AFTER
        or      si, si                  ;Table in PDB?
        jnz     @F                      ;Yes
	mov     ds, WORD PTR ds:[PDB_JFN_Table] ;Get old selector to copy from
@@:

        ;** Copy the existing table into the new one
	cld
	rep	movsb			;Copy existing files
	mov	al, -1
	mov	cx, nFiles
	sub	cx, di
	rep	stosb                   ;Pad new files with -1
	mov	ax, ds
	pop	bx			;Retrieve PDB selector
	mov	ds, bx
        mov     WORD PTR ds:[PDB_JFN_Table], es ;Save new selector

        ;** We only free the old table if it wasn't in the PDB
        cmp     ax, bx                  ;Were we using the PDB selector?
        je      SHC_OldTableInPDB       ;Yes.  Don't free it
	cCall	GlobalDOSFree, <ax>     ;Free old table
SHC_OldTableInPDB:

	mov	ax, nFiles
no_change:
cEnd

;-----------------------------------------------------------------------;
; GetSetKernelDOSProc							;
;	Set the address kernel calls for DOS				;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetSetKernelDOSProc,<PUBLIC,FAR>
	parmD	NewProc
cBegin
	SetKernelDS
ife ROM
	mov	ds, MyCSAlias
	assumes ds, CODE
endif
	mov	ax, word ptr NewProc[0]
	xchg	ax, word ptr PrevInt21Proc[0]
	mov	dx, word ptr NewProc[2]
	xchg	dx, word ptr PrevInt21Proc[2]
cEnd				


;-----------------------------------------------------------------------;
; FatalExitHook								;
; 	Hooks FatalExit							;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	FatalExitHook,<PUBLIC,FAR>
	parmD	NewProc
cBegin
	SetKernelDS
	mov	ax, word ptr NewProc[0]
	xchg	ax, word ptr FatalExitProc[0]
	mov	dx, word ptr NewProc[2]
	xchg	dx, word ptr FatalExitProc[2]
cEnd			     	

if 0		; EarleH

;-----------------------------------------------------------------------;
; GetLastCriticalError							;
;    	Get the last int 24h error and extended error code		;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Fri Dec 31, 1990 -by-  Tony Gosling					;
;      		 							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	GetLastCriticalError,<PUBLIC,FAR>
cBegin	
	SetKernelDS
	mov	ax, -1
	mov	dx, ax
	xchg	ax, LastExtendedError
	xchg	dx, LastCriticalError
cEnd				
endif ;0		      	

;-----------------------------------------------------------------------;
; DWORD GetAppCompatFlags(HTASK hTask)                                  ;
;                                                                       ;
; Returns win.ini [Compatibility] flags for hTask (or current task      ;
; if hTask is NULL).                                                    ;
;									;
; Arguments:								;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
;   All but DX:AX                                                       ;
; 									;
; Registers Destroyed:							;
; 									;
;   DX, AX                                                              ;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc   GetAppCompatFlags,<PUBLIC,FAR>,<DS>
parmW   hTask
cBegin
        SetKernelDS
        mov     ax,hTask
        or      ax,ax
        jnz     got_tdb
        mov     ax,curTDB               ; If no current task (e.g., during boot)
        cwd                             ; just return 0L.
        or      ax,ax
        jz      gacf_exit
got_tdb:
        mov     ds,ax
        UnSetKernelDS
        mov     ax,ds:[TDB_CompatFlags]
        mov     dx,ds:[TDB_CompatFlags2]
gacf_exit:
        UnSetKernelDS
cEnd

; Simpler (faster) NEAR version for Kernel -- only works for current task!
;
; Preserves all regs except dx:ax
;
cProc	MyGetAppCompatFlags,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
	jz	mygacf_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_CompatFlags]
	mov	dx, ds:[TDB_CompatFlags2]

mygacf_exit:
	pop	ds
	UnSetKernelDS
	ret

cEnd	nogen

ifdef WOW
cProc   MyGetAppWOWCompatFlags,<PUBLIC,NEAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
	jz	wow_mygacf_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_WOWCompatFlags]
	mov	dx, ds:[TDB_WOWCompatFlags2]

wow_mygacf_exit:
	pop	ds
	UnSetKernelDS
	ret

cEnd	nogen

;
; Returns WOW extended compatiblity flags
;
; Preserves all regs except dx:ax
;
cProc   MyGetAppWOWCompatFlagsEx,<PUBLIC,FAR>
cBegin	nogen
	push	ds
	SetKernelDS

	mov	ax, curTDB
	cwd
	or	ax, ax			; No current task while booting
        jz      wow_mygacfex_exit

	mov	ds, ax
	UnSetKernelDS
	mov	ax, ds:[TDB_WOWCompatFlagsEx]
	mov	dx, ds:[TDB_WOWCompatFlagsEx2]

wow_mygacfex_exit:
	pop	ds
	UnSetKernelDS
        retf

cEnd	nogen


;---------------------------------------------------------------------------
; This gets called from FreeProcInstance. If the proc being freed is an
; AbortProc that was set by the app, we reset it to NULL. This way we dont
; callback to a proc that's garbage.
;
; This case happens with Aldus Pagemaker ver 5.0 when one prints to EPS file.
; The app sets the AbortProc and then later calls freeprocinstance.
; Subsequently when it make the call Escape(..OPENCHANNEL..) the callback
; occurs and we die randomly.
;
; This solution is a general solution.
;                                                           - Nanduri
;---------------------------------------------------------------------------

cProc	HandleAbortProc, <PUBLIC,FAR>, <ds, ax>
     ParmD pproc
cBegin	
	SetKernelDS

	mov	ax, curTDB
	or	ax, ax			; No current task while booting
	jz	wow_aproc_exit

	mov	ds, ax
	UnSetKernelDS
	mov     ax, ds:[TDB_vpfnAbortProc+2]
        or      ax, ax
        je      wow_aproc_exit          ; sel = 0 - no abort proc. done
        cmp     ax, word ptr [pproc+2]
        jnz     wow_aproc_exit          ; selectors don't match
	mov     ax, ds:[TDB_vpfnAbortProc]
        cmp     ax, word ptr [pproc]
        jnz     wow_aproc_exit          ; offsets don't match

	mov     ds:[TDB_vpfnAbortProc], 0          ; set abort proc to NULL.
	mov     ds:[TDB_vpfnAbortProc+2], 0
wow_aproc_exit:
	UnSetKernelDS
cEnd	

endif ; WOW

sEnd	CODE

sBegin NRESCODE
assumes CS,NRESCODE

ifndef WOW          ; WOW thunks SetAppCompatFlags for special processing
CompatSection	DB  'Compatibility'
DefVal		DB	0

cProc	SetAppCompatFlags, <PUBLIC, NEAR>, <ds, es, si, di>
	localV	szHex,12			; read string to here
	localV	key, <SIZE TDB_Modname + 2>	; ModName of loading app
cBegin
	xor	ax, ax
	cwd
        cmp     es:[TDB_ExpWinVer], 400h ; Hacks don't apply to 4.0 or above
        jae     sa_exit

	push	es			; Copy ModName to zero-terminate it
	pop	ds
	lea	si, es:[TDB_ModName]
	push	ss
	pop	es
	lea	di, key
	mov	cx, SIZE TDB_Modname
	cld
	rep	movsb
	stosb

	push	cs
	push	NREScodeoffset CompatSection

	push	ss
	lea	ax, key
	push	ax

	push	cs
	push	NREScodeoffset DefVal

	push	ss
	lea	ax, szHex
	push	ax

        push    12

	call	GetProfileString
	cwd
	or	ax, ax
	jz	sa_exit
        xor     dx,dx                   ; zero our value in dx:bx
        xor     bx,bx
	push	ss
	pop	ds
	lea	si, szHex

	lodsw				; String starts with '0x'
	and	ah, not 20h
	cmp	ax, 'X0'
	jnz	sa_done
sa_again:
	lodsb
	sub	al, '0'
	jc	sa_done
        cmp     al, '9'-'0'
	jbe	@F
        add     al, '0'-'A'+10          ; map 'A'..F' to 10..15
                                        ; (lower case guys are 0x20 apart!)
@@:
        add     bx,bx                   ; value << 4;
        adc     dx,dx
        add     bx,bx
        adc     dx,dx
        add     bx,bx
        adc     dx,dx
        add     bx,bx
        adc     dx,dx

        and     al,0fh                  ; value |= (al & 0x0f);
        or      bl,al
        jmps    sa_again

sa_done:	; DX:BX contains flags
        mov     ax, bx
        cmp     es:[TDB_ExpWinVer], 30Ah ; SOME hacks don't apply to 3.1 or above
        jb      sa_end
        and     dx, HIW_GACF_31VALIDMASK
        and     ax, LOW_GACF_31VALIDMASK
sa_end:

sa_exit:	; DX:AX contains flags, or 0x00000000
cEnd
endif  ; WOW

cProc	ValidateCodeSegments,<PUBLIC,FAR>
cBegin	nogen
	ret
cEnd	nogen

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\patch.asm ===
.xlist
include kernel.inc
include gpfix.inc
include pdb.inc
include tdb.inc
include newexe.inc
include protect.inc
.list

.386

ERROR_NO_MORE_ITEMS        EQU     259

;-----------------------------------------------------------------------
;-----------------------------------------------------------------------
; App patching defines


externFP RegCloseKey32
externFP RegOpenKey32
externFP RegEnumKey32
externFP RegEnumValue32

externFP FarGetCachedFileHandle
externFP GlobalRealloc
externFP GlobalSize
externFP Far_genter
externFP Far_gleave
externFP Far_htoa0
externFP Far_pdref
externFP FreeSelector

; MultiThreading version of change PDB
;externFP GetCurPDB
;externFP SetCurPDB
;externFP TopPDB
; MultiThreading version of change PDB

externW topPDB
externW Win_PDB
externW gdtdsc

REG_BINARY           equ     3

HKEY_LOCAL_MACHINE      equ 80000002h
HKEY_LOCAL_MACHINE_HI   equ 8000h
HKEY_LOCAL_MACHINE_LO   equ 0002h

; Under HKEY_LOCAL_MACHINE
REGSTR_PATH_APPPATCH equ <"System\CurrentControlSet\Control\Session Manager\AppPatches">
; There is one value for each modification to a given segment.
; The values for a segment are stored under the key
;     REGSTR_PATH_APPPATCH\<AppName>\<AppVersion>\<signature>
; where <signature> lists bytes in the module to match.


BY_HANDLE_FILE_INFORMATION STRUC
bhfi_dwFileAttributes       DD  ?
bhfi_ftCreationTime         DD  2 dup (?)
bhfi_ftLastAccessTime       DD  2 dup (?)
bhfi_ftLastWriteTime        DD  2 dup (?)
bhfi_dwVolumeSerialNumber   DD  ?
bhfi_nFileSizeHigh          DD  ?
bhfi_nFileSizeLow           DD  ?
bhfi_nNumberOfLinks         DD  ?
bhfi_nFileIndexHigh         DD  ?
bhfi_nFileIndexLow          DD  ?
BY_HANDLE_FILE_INFORMATION ENDS


;-----------------------------------------------------------------------
; Signature definitions
;
AP_SIG STRUC
sig_format      DB      ?       ; formatType for the struc
; rest of the data depends on the value in the sig_format field
AP_SIG ENDS

; Supported values for the sig_format field
AP_SIG_FORMAT_HEXE      equ     01h   ; match hExe bytes, 1B offset
AP_SIG_FORMAT_HEXE2     equ     02h   ; match hExe bytes, 2B offset
AP_SIG_FORMAT_FILE2     equ     03h   ; match file bytes, 2B offset
AP_SIG_FORMAT_FILE3     equ     04h   ; match file bytes, 3B offset
AP_SIG_FORMAT_FILE4     equ     05h   ; match file bytes, 4B offset
AP_SIG_FORMAT_FILESIZE2 equ     06h   ; match file size, 2B size
AP_SIG_FORMAT_FILESIZE3 equ     07h   ; match file size, 3B size
AP_SIG_FORMAT_FILESIZE4 equ     08h   ; match file size, 4B size
AP_SIG_FORMAT_META      equ    0ffh   ; contains other signatures

;AP_SIG_FORMAT_HEXE
AP_SIG_HEXE STRUC
es_format           DB      ?       ; AP_SIG_FORMAT_HEXE
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
es_cb               DB      ?       ; number of bytes to compare
es_offset           DB      ?       ; offset to begin signature compare
es_abSignature      DB      ?       ; cb DUP (?) ; signature bytes
AP_SIG_HEXE ENDS

;AP_SIG_FORMAT_HEXE2
AP_SIG_HEXE2 STRUC
es2_format          DB      ?       ; AP_SIG_FORMAT_HEXE2
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
es2_cb              DB      ?       ; number of bytes to compare
es2_offset          DW      ?       ; offset to begin signature compare
es2_abSignature     DB      ?       ; cb DUP (?) ; signature bytes
AP_SIG_HEXE2 ENDS

;AP_SIG_FORMAT_FILE2
AP_SIG_FILE2 STRUC
fs2_format          DB      ?       ; AP_SIG_FORMAT_FILE2
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs2_cb              DB      ?       ; number of bytes to compare
fs2_offset          DB 2    DUP (?) ; offset to begin signature compare
fs2_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE2 ENDS

;AP_SIG_FORMAT_FILE3
AP_SIG_FILE3 STRUC
fs3_format          DB      ?       ; AP_SIG_FORMAT_FILE3
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs3_cb              DB      ?       ; number of bytes to compare
fs3_offset          DB 3    DUP (?) ; offset to begin signature compare
fs3_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE3 ENDS

;AP_SIG_FORMAT_FILE4
AP_SIG_FILE4 STRUC
fs4_format          DB      ?       ; AP_SIG_FORMAT_FILE4
; There can be multiple signature strings, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
fs4_cb              DB      ?       ; number of bytes to compare
fs4_offset          DB 4    DUP (?) ; offset to begin signature compare
fs4_abSignature     DB      ?       ; cb DUP (?) ; bytes to match
AP_SIG_FILE4 ENDS

;AP_SIG_FORMAT_FILESIZE
AP_SIG_FILESIZE STRUC
fss_format          DB      ?       ; AP_SIG_FORMAT_FILESIZE[2,3,4]
fss_cbFile          DB      ?       ; file size in bytes
AP_SIG_FILESIZE ENDS

;AP_SIG_FORMAT_FILESIZE2
AP_SIG_FILESIZE2 STRUC
fss2_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE2
fss2_cbFile         DB 2    DUP (?) ; file size in bytes
AP_SIG_FILESIZE2 ENDS

;AP_SIG_FORMAT_FILESIZE3
AP_SIG_FILESIZE3 STRUC
fss3_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE3
fss3_cbFile         DB 3    DUP (?) ; file size in bytes
AP_SIG_FILESIZE3 ENDS

;AP_SIG_FORMAT_FILESIZE4
AP_SIG_FILESIZE4 STRUC
fss4_format         DB      ?       ; AP_SIG_FORMAT_FILESIZE4
fss4_cbFile         DB 4    DUP (?) ; file size in bytes
AP_SIG_FILESIZE4 ENDS

;AP_SIG_FORMAT_META
AP_SIG_META STRUC
ms_format           DB      ?       ; AP_SIG_FORMAT_META
; There can be multiple sub-signatures, packed one after the other.
; All must match to give a match.
; cb==0 signals the end.
ms_cb               DB      ?       ; number of bytes in the sub-signature
ms_abSubSignature   DB      ?       ; the sub-signature
AP_SIG_META ENDS

;-----------------------------------------------------------------------
; Patch definitions
;
AP_COMMON STRUC
ap_format       DB      ?       ; formatType for the struc
ap_cbSize       DB      ?       ; number of bytes in the whole struct
; rest of the data depends on the value in the ap_format field
AP_COMMON ENDS

; Supported values for the ap_format field:
AP_FORMAT_REPLACE         equ     1
AP_FORMAT_ADD             equ     2

;AP_FORMAT_REPLACE
AP_REPLACE STRUC
apr_format      DB      ?       ; AP_FORMAT_REPLACE
apr_cbSize      DB      ?       ; number of bytes in the whole struct
apr_offset      DW      ?       ; offset within the segment
apr_cb          DB      ?       ; number of bytes to replace
apr_abOld       DB      ?       ; cb DUP (?) ; old bytes
apr_abNew       DB      ?       ; cb DUP (?) ; new bytes
AP_REPLACE ENDS

;AP_FORMAT_ADD
AP_ADD STRUC
apa_format      DB      ?       ; AP_FORMAT_ADD
apa_cbSize      DB      ?       ; number of bytes in the whole struct
apa_offset      DW      ?       ; offset within the segment
apa_cb          DB      ?       ; number of bytes to replace
apa_abNew       DB      ?       ; cb DUP (?) ; new bytes
AP_ADD ENDS



DataBegin

szREGSTR_PATH_APPPATCH  db      REGSTR_PATH_APPPATCH, "\", 0

; app-patching cache
globalW  hExePatchAppCache    0
globalD  hkeyPatchAppCache    0


DataEnd



sBegin NRESCODE
assumes CS,NRESCODE

;  GetPatchAppCache
;
;	Gets an hkeyReg from the PatchApp cache if hExe in cache.
;
; Arguments:
;	hExe
;
; Returns:
;       dx:ax   -1 if cache miss
;               registry key associated with hExe if cache hit
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;HKEY
cProc	GetPatchAppCache, <PUBLIC, NEAR>, <ds>
        parmW   hExe
cBegin
        SetKernelDSNRes

        ; Set up dx==ax==-1 (indicates cache miss)
        sub     ax, ax
        dec     ax
        mov     dx, ax

        mov     cx, hExe
        cmp     cx, hExePatchAppCache
        jne short gpac_exeunt

        mov     dx, hkeyPatchAppCache.hi
        mov     ax, hkeyPatchAppCache.lo
        krDebugOut  DEB_WARN,"GetPatchAppCache: hit (#cx, #dx#ax)"
gpac_exeunt:
        UnSetKernelDS
cEnd


;  AddPatchAppCache
;
;	Adds an (hExe,hkeyReg) pair to the PatchApp cache.
;
; Arguments:
;	hExe
;       hkeyReg
;
; Returns:
;
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;VOID
cProc	AddPatchAppCache, <PUBLIC, NEAR>, <ds>
        parmW   hExe
        parmD   hkeyReg
cBegin
        SetKernelDSNRes

        mov     ax, hExe
        mov     hExePatchAppCache, ax

        mov     edx, hkeyReg
        mov     hkeyPatchAppCache, edx
if KDEBUG
        push    cx
        mov     cx, hkeyPatchAppCache.hi
        krDebugOut  DEB_WARN,"AddPatchAppCache: (#ax, #cx#dx)"
        pop     cx
endif

        UnSetKernelDS
cEnd


;  FlushPatchAppCache
;
;	Flushes an hExe from the PatchApp cache.
;       If the cache has a reg key for the hExe, closes the key.
;
; Arguments:
;	hExe
;
; Returns:
;
; Remarks:
;       called by DelModule
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;VOID
cProc	FlushPatchAppCache, <PUBLIC, NEAR>, <>
        parmW   hExe
cBegin
;        CheckKernelDS
        ReSetKernelDS

        mov     ax, hExe
        krDebugOut  DEB_TRACE,"FlushPatchAppCache: (hExe #ax)"
        cmp     ax, hExePatchAppCache
        jne short fpac_exeunt

        sub     eax, eax
        cmp     eax, hkeyPatchAppCache
        je short fpac_after_close_key
        cCall  RegCloseKey32, <hkeyPatchAppCache>
if KDEBUG
        mov     cx, hExe
        mov     bx, hkeyPatchAppCache.lo
        mov     dx, hkeyPatchAppCache.hi
        krDebugOut  DEB_WARN,"FlushPatchAppCache: flushing (hExe #cx) (hkey #dx#bx)"
endif

fpac_after_close_key:
        mov     hExePatchAppCache, ax
if KDEBUG
        mov     hkeyPatchAppCache, eax          ; a little extra for debug
endif

fpac_exeunt:
        UnSetKernelDS
cEnd


;  PatchGetFileSize
;
;	Get the size of a file, given the DOS file handle.
;
; Arguments:
;	dfh     - DOS file handle
;
; Returns:
;	DWORD file size
;
; Remarks:
;       Since these patches are only for old (<4.0) apps, only support
;       DWORD file size.
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;DWORD
cProc   PatchGetFileSize, <PUBLIC, NEAR>, <ds,si,di>
        parmW   dfh

        localV  FileInformation,<SIZE BY_HANDLE_FILE_INFORMATION>
        localW  HiPosition
        localW  LoPosition

        localW  SavePDB

cBegin
; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS
; MultiThreading version of change PDB
        SetKernelDSNRes                 ; ds is a scratch reg -> no need restore
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        mov     SavePDB, ax             ; saving current PDB

	mov	bx, dfh
        smov    ds, ss
        lea     dx, FileInformation
        stc                         ; Real-mode drivers don't set CY on error
	mov	ax, 71a6h
        int     21h
        jc short gfs_try_offsets

        mov     dx, FileInformation.bhfi_nFileSizeLow.hi
        mov     ax, FileInformation.bhfi_nFileSizeLow.lo
        jmp short gfs_exeunt

gfs_try_offsets:
        ; Real-mode drivers don't support 71a6, so we do it the hard way.
        ; Move from current by 0 to get the current postion
	mov	bx, dfh
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4201h
        int     21h
        jc short gfs_fail

        ; Save current position
        mov     HiPosition, dx
        mov     LoPosition, ax

        ; Get file size by moving from end by 0
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4202h
        int     21h
        jc short gfs_fail

        push    dx
        push    ax

        ; Restore current position
        mov     cx, HiPosition
        mov     dx, LoPosition
        mov     ax, 4200h
        int     21h
        ; Don't check for error, since we can't recover any more anyway...

        pop     ax
        pop     dx
        jmp short gfs_exeunt

gfs_fail:
        sub     ax, ax
        mov     dx, ax
gfs_exeunt:
; MultiThreading version of change PDB
        push    ax
        mov     ax, SavePDB
        SetKernelDSNRes                  ; ds restored on proc exit
        mov     Win_PDB, ax
        UnSetKernelDS
;        cCall   SetCurPDB,<SavePDB>     ; preserves dx
        pop     ax
; MultiThreading version of change PDB

cEnd


;  CompareFileBytes
;
;	Compares a sequence of bytes with those at a given offset in a file.
;
; Arguments:
;	dfh
;       lpBytes
;       cb
;       dwFileOffset
;
; Returns:
;	WORD, zero iff match
;
; Remarks:
;       The caller is responsible for preserving the offset in the file.
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;WORD
cProc   CompareFileBytes, <PUBLIC, NEAR>, <si,di,ds>
        parmW   dfh
        parmD   lpBytes
        parmW   cb
        parmD   dwFileOffset
cBegin
        ; Seek to dwFileOffset.
        mov     bx, dfh
        mov     cx, dwFileOffset.hi
        mov     dx, dwFileOffset.lo
        mov     ax, 4200h
        int     21h
        jc short cfb_fail

if KDEBUG
        ; The high byte of cb _must_ be 0.
        mov     cx, cb
        cmp     ch, 0
        je short @F
        krDebugOut  DEB_FERROR,"CompareFileBytes: cb (#cx) > 0ffh"
@@:
endif
        mov     byte ptr [cb].1, 0      ; force cb < 100h

        ; Read from file.
        mov     cx, cb
        smov    ds, ss
        sub     sp, cx
        mov     dx, sp                  ; ds:dx = read buffer
        mov     ah, 3fh
        int     21h
        jc short cps_fail_restore_stack

        ; Make sure we filled the buffer.
        cmp     ax, cx
        jne short cps_fail_restore_stack

        ; Compare the bytes.
        les     di, lpBytes             ; es:di = signature bytes
        smov    ds, ss
        mov     si, sp                  ; ds:si = read buffer
        rep     cmpsb
        jne short cps_fail_restore_stack

        sub     ax, ax
        add     sp, cb
        jmp short cfb_exit

cps_fail_restore_stack:
        add     sp, cb
cfb_fail:
        or      al, 1
cfb_exit:
cEnd


;  ComparePatchSignature
;
;	Tests a patch signature against an hExe.
;
; Arguments:
;	hExe
;       lpPatchSignature
;
; Returns:
;	WORD, zero iff match
;
; Registers Preserved:
;	DI, SI, DS

	assumes ds,nothing
	assumes es,nothing

;WORD
cProc   ComparePatchSignature, <PUBLIC, NEAR>, <si,di,ds>
        parmW   hExe
        parmD   lpPatchSignature

        localW  SavePDB
        localW  dfh
        localW  cbNonZero
        localD  dwFileOffset
cBegin
beg_fault_trap cps_fault
        mov     es, hExe
        lds     si, lpPatchSignature

        cld
        .errnz  AP_SIG.sig_format
        lodsb
;---------------------------------------------------
        cmp     al, AP_SIG_FORMAT_META
        jne short cps_maybe_hexe

        .errnz  (AP_SIG_HEXE.ms_cb - AP_SIG_HEXE.ms_format) - 1
cps_loop_meta:
        lodsb
        mov     ah, 0
        mov     cx, ax          ; cx = size of sub-signature
        jcxz    cps_meta_exeunt ; end of list. must be match.

        mov     di, si
        add     di, cx          ; ds:di = next sub-signature
        cCall   ComparePatchSignature,<hExe,ds,si>
        test    ax, ax
        jnz     cps_fail
        ; Got a match. Try the next one.
        mov     si, di          ; ds:si = next sub-signature
        jmp     cps_loop_meta

cps_meta_exeunt:
        jmp     cps_exeunt

;---------------------------------------------------
; AP_SIG_FORMAT_HEXE
; AP_SIG_FORMAT_HEXE2
cps_maybe_hexe:
        .errnz (AP_SIG_FORMAT_HEXE2-AP_SIG_FORMAT_HEXE)-1
        cmp     al, AP_SIG_FORMAT_HEXE
        jb short cps_maybe_filesize
        cmp     al, AP_SIG_FORMAT_HEXE2
        ja short cps_maybe_filesize

        ; Compute number of bytes in offset after first byte.
        mov     dl, al
        sub     dl, AP_SIG_FORMAT_HEXE

        .errnz  (AP_SIG_HEXE.es_cb - AP_SIG_HEXE.es_format) - 1
        mov     ah, 0
cps_hexe_loop:
        lodsb
        mov     cx, ax          ; cx = size of signature block
        jcxz    cps_hexe_match  ; end of list. must be match.

        ; Set up bx with the offset in the hExe
        sub     bx, bx          ; bx = default offset (0)
        lodsb
        mov     bl, al          ; bl = low byte of offset
        test    dl, dl          ; more bytes?
        jz short @F
        lodsb
        mov     bh, al          ; bh = high byte of offset
@@:
        mov     di, bx          ; es:di points to bytes in hExe
        rep     cmpsb
        jne     cps_fail
        jmp     cps_hexe_loop

cps_hexe_match:
        ; ax already 0
        jmp     cps_exeunt

;---------------------------------------------------
; AP_SIG_FORMAT_FILESIZE2
; AP_SIG_FORMAT_FILESIZE3
; AP_SIG_FORMAT_FILESIZE4
cps_maybe_filesize:
        .errnz (AP_SIG_FORMAT_FILESIZE3-AP_SIG_FORMAT_FILESIZE2)-1
        .errnz (AP_SIG_FORMAT_FILESIZE4-AP_SIG_FORMAT_FILESIZE3)-1
        cmp     al, AP_SIG_FORMAT_FILESIZE2
        jb short cps_maybe_file
        cmp     al, AP_SIG_FORMAT_FILESIZE4
        ja short cps_maybe_file

        ; Compute number of non-zero bytes in file size high word
        mov     cl, al
        sub     cl, AP_SIG_FORMAT_FILESIZE2
        push    cx

; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes es
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS es
; MultiThreading version of change PDB
        push    ds
        SetKernelDSNRes
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        pop     ds
        mov     SavePDB, ax             ; saving current PDB

        ; Since these patches are only for old (<4.0) apps, only support
        ; DWORD file size.
        or      ax, -1
        cCall   FarGetCachedFileHandle,<hExe,ax,ax>
        cmp     ax, -1
        je short cps_filesize_fh_cache_miss

        cCall   PatchGetFileSize,<ax>
        pop     cx              ; cl = non-zero bytes in file size high word

        ; Low word of file size must match.
        ; [si] = low byte of signature file size
        cmp     ax, [si]
        jne short cps_filesize_fail

        mov     ch, 0
        sub     bx, bx          ; bx = default high word of file size (0)
        jcxz    cps_filesize_compare_high

        ; [si] = low word of signature file size
        inc     si
        inc     si
        ; [si] = low byte of high word of signature file size (if exists)
        ; bx = 0
        ; cx = [1|2], non-zero bytes in file size high word
        lodsb
        mov     bl, al
        dec     cl
        jcxz    cps_filesize_compare_high
        lodsb
        mov     bh, al
cps_filesize_compare_high:
        cmp     bx, dx
        jne short cps_filesize_fail

cps_filesize_match:
        ; File size matches.
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        sub     ax, ax
        jmp     cps_exeunt

cps_filesize_fh_cache_miss:
        krDebugOut DEB_ERROR,"ComparePatchSignature: filesize fh cache miss"

cps_filesize_fail:
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        jmp     cps_fail

;---------------------------------------------------
; AP_SIG_FORMAT_FILE2
; AP_SIG_FORMAT_FILE3
; AP_SIG_FORMAT_FILE4
cps_maybe_file:
        .errnz (AP_SIG_FORMAT_FILE3-AP_SIG_FORMAT_FILE2)-1
        .errnz (AP_SIG_FORMAT_FILE4-AP_SIG_FORMAT_FILE3)-1
        cmp     al, AP_SIG_FORMAT_FILE2
        jb      cps_bad_format
        cmp     al, AP_SIG_FORMAT_FILE4
        ja      cps_bad_format

        ; Compute number of non-zero bytes in file offset high word
        mov     cl, al
        sub     cl, AP_SIG_FORMAT_FILE2
        mov     ch, 0
        mov     cbNonZero, cx

; MultiThreading version of change PDB
;        cCall   GetCurPDB
;        mov     SavePDB, ax
;        SetKernelDSNRes es
;        cCall   SetCurPDB,<topPDB>              ; kernel's PSP
;        UnSetKernelDS es
; MultiThreading version of change PDB
        push    ds
        SetKernelDSNRes
        mov     ax, topPDB
        xchg    Win_PDB, ax             ; Switch to Kernel's PDB,
        UnSetKernelDS
        pop     ds
        mov     SavePDB, ax             ; saving current PDB

        mov     es, hExe

        or      ax, -1
        push    es
        cCall   FarGetCachedFileHandle,<es,ax,ax>
        pop     es
        cmp     ax, -1
        je short cps_file_fh_cache_miss

        mov     bx, ax          ; bx = dos file handle
        mov     dfh, ax
        sub     cx, cx
        mov     dx, cx
        mov     ax, 4201h
        int     21h
        jc      cps_fail

        mov     dwFileOffset.hi, dx
        mov     dwFileOffset.lo, ax

cps_file_loop:
        lodsb
        mov     ah, 0
        mov     cx, ax          ; cx = size of signature block
        jcxz    cps_file_match  ; end of list. must be match.

        mov     di, cx          ; di = number of bytes to match

        ; Get the file offset into dx:bx
        ; First get the low word.
        lodsw
        mov     bx, ax          ; bx = low word of file offset

        ; Get one or both bytes of the high word.
        sub     dx, dx          ; dx = default high word of file offset (0)
        mov     cx, cbNonZero
        jcxz    cps_file_compare
        ; [si] = low byte of high word of file offset
        ; dx = 0
        ; cx = [1|2], non-zero bytes in file offset high word
        lodsb
        mov     dl, al
        dec     cl
        jcxz    cps_file_compare
        lodsb
        mov     dh, al

cps_file_compare:
        ; ds:[si] = bytes to match in file
        ; di      = byte count
        ; dx:bx   = offset in file
        cCall   CompareFileBytes,<dfh,ds,si,di,dx,bx>
        test    ax, ax
        jnz short cps_file_fail

        add     si, di          ; ds:si = next signature block
        jmp     cps_file_loop

cps_file_fh_cache_miss:
        krDebugOut DEB_ERROR,"ComparePatchSignature: file fh cache miss"

cps_file_fail:
        or      al, 1
        jmp short cps_file_exit

cps_file_match:
        sub     ax, ax

cps_file_exit:
        mov     si, ax          ; si = return value

        ; Restore file position
        mov     bx, dfh         ; bx = dos file handle
        mov     cx, dwFileOffset.hi
        mov     dx, dwFileOffset.lo
        mov     ax, 4200h
        int     21h
        ; Don't check error, since we can't do anything anyway.
if KDEBUG
        jnc short @F
        krDebugOut DEB_ERROR,"ComparePatchSignature: failure restoring file position"
@@:
endif
; MultiThreading version of change PDB
;        cCall   SetCurPDB,<SavePDB>
; MultiThreading version of change PDB
        mov     ax, SavePDB
        push    ds
        SetKernelDSNRes
        mov     Win_PDB, ax
        UnSetKernelDS
        pop     ds

        mov     ax, si
        jmp short cps_exeunt

;---------------------------------------------------
end_fault_trap
cps_fault:
        fault_fix_stack
        krDebugOut  DEB_ERROR,"ComparePatchSignature: trapped fault"

cps_bad_format:
        krDebugOut  DEB_ERROR,"ComparePatchSignature: invalid format"
cps_fail:
        or      al, 1           ; ensure we return "no_match"
cps_exeunt:
cEnd


;  GetPatchAppRegKey
;
;	Determines if we patch an app at load time, gets reg key if so.
;
; Arguments:
;	hExe
;
; Returns:
;	HKEY, non-zero iff we segment-patch info in the registry for this app.
;
; Registers Preserved:
;	DI, SI, DS, ES

	assumes ds,nothing
	assumes es,nothing

;HKEY
cProc	GetPatchAppRegKey, <PUBLIC, FAR>, <si,di,ds,es>
        parmW   hExe

szKey_size             = 200
abPatchSignature_size  = 100

        localD  hkeyModule
        localD  hkeySignature
        localD  dwIndex
        localV  szKey,szKey_size                          ; BUGBUG need a better size
        localV  abPatchSignature,abPatchSignature_size    ; BUGBUG need a better size

cBegin
        ; We must refuse to patch system modules.
        ; Should be ok because of version check (in caller).
if KDEBUG
        mov     es, hExe
        cmp     es:[ne_expver], 400h    ; Hacks don't apply to 4.0 or above
        jb short @F
        ; Should never get here since the caller should have already checked.
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: (#es) version later than 4.0"
@@:
endif
        cCall   GetPatchAppCache,<hExe>
        ; ffff:ffff means a cache miss
        or      cx, -1
        cmp     cx, dx
        jne     gpark_exeunt
        cmp     cx, ax
        jne     gpark_exeunt

        ; Not in the cache. Get it from the registry and add to the cache.

        ; Copy the subkey prefix to the buffer.
        lea     di, szKey
        smov    es, ss
        SetKernelDSNRes
        lea     si, szREGSTR_PATH_APPPATCH
	mov	cx, szKey_size
@@:
	lodsb
	stosb
	test	al, al
	loopnz	@B
if KDEBUG
        jz short @F
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: len(szREGSTR_PATH_APPPATCH) > szKey_size"
@@:
endif
        dec     di
        UnSetKernelDS

        ; Append the module's base name (pascal format).
        mov     ds, hExe
        mov     si, ds:[ne_restab]
        lodsb
if KDEBUG
        mov     ah, 0
        cmp     cx, ax
        ja short @F
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: len(reg path) > szKey_size"
@@:
endif
        movzx   cx, al
        rep     movsb
        sub     al, al
        stosb                           ; NULL terminator

        ; Get the key for this module.
        mov     hkeySignature, 0        ; In case we fail.
        mov     eax, HKEY_LOCAL_MACHINE
        lea     si, szKey
        lea     di, hkeyModule
        ccall   RegOpenKey32, <eax, ss, si, ss, di>
        or      ax,dx
        jnz     gpark_fail2

        or      dwIndex, -1             ; == mov dwIndex,-1 (but smaller)
gpark_loop:
        inc     dwIndex
        lea     si, szKey
        ccall   RegEnumKey32, <hkeyModule, dwIndex, ss, si, 0, szKey_size>
        or      ax, dx
        jnz short gpark_loop_done

        ; First, convert string to binary.
        ; Reuse szKey since we don't need path any more (we have hKeyModule).
        lea     si, abPatchSignature
        lea     di, szKey
        krDebugOut  DEB_WARN,"GetPatchAppRegKey: checking signature (@ss:di)"
        cCall   ConvertPatchStringToBinary,<ss,si,abPatchSignature_size,ss,di>
        ; Skip a badly formatted patch signature.
        test    ax, ax
if KDEBUG
        jnz short @F
        lea     cx, szKey
        krDebugOut  DEB_ERROR,"PatchAppSeg: bad patch signature in registry, @ss:cx"
@@:
endif
        jz      gpark_loop

        cCall   ComparePatchSignature,<hExe,ss,si>
        test    ax, ax
        jne     gpark_loop

if KDEBUG
        mov     ax, hExe
        krDebugOut  DEB_WARN,"GetPatchAppRegKey: (#ax) sig matches (@ss:di)"
endif
        ; We have a match. Get the corresponding key.
        lea     si, szKey
        lea     di, hkeySignature
        ccall   RegOpenKey32, <hkeyModule, ss, si, ss, di>
        or      ax,dx
        jz short gpark_add

        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: RegOpenKey failed, #dx#ax"
        jmp short gpark_fail

gpark_loop_done:

if KDEBUG
        test    dx, dx
        jnz short @F
        cmp     ax, ERROR_NO_MORE_ITEMS
        je short gpark_after_loop_done_err
@@:
        krDebugOut  DEB_ERROR,"GetPatchAppRegKey: unexpected error #dx#ax"
gpark_after_loop_done_err:
endif

gpark_fail:
        ; Mark that there are no patches in the registry.
        mov     hkeySignature, 0
gpark_add:
        ; Close the reg key for the path to the end of the module name
        cCall  RegCloseKey32, <hkeyModule>

gpark_fail2:
        ; Add hkeySignature to the cache and set up return regs.
        cCall   AddPatchAppCache,<hExe, hkeySignature>

        mov     ax, hkeySignature.lo
        mov     dx, hkeySignature.hi
gpark_exeunt:
cEnd

;  ConvertPatchStringToBinary
;
;	Convert a string of [0-9,A-F] with nibble-swapped bytes to binary.
;
; Arguments:
;	lpBinary - output buffer
;	cbBinary - size of output buffer in bytes
;       lpString - input NULL-terminated string
;
; Returns:
;	Boolean, TRUE iff we convert the entire string.
;
; Registers Preserved:
;	DI, SI, DS, ES

	assumes	ds, nothing
	assumes	es, nothing

;BOOL
cProc   ConvertPatchStringToBinary, <PUBLIC, NEAR>,<di,si,ds>
        parmD   lpBinary
        parmW   cbBinary
        parmD   lpString
cBegin
        krDebugOut  DEB_WARN,"ConvertPatchStringToBinary: enter"
        mov     cx, cbBinary
        jcxz    cpstb_bad

        les     di, lpBinary
        lds     si, lpString
        sub     ah, ah

cpstb_loop:
        lodsb
        cmp     al, 0
        je short cpstb_maybe_good
        cmp     al, ' '
        je      cpstb_loop
        cmp     al, ','
        je      cpstb_loop
        cmp     al, '0'
        jb short cpstb_bad
        cmp     al, '9'
        ja short cpstb_maybe_lower

        ; digit
        sub     al, '0'
        jmp short cpstb_have_nibble

cpstb_maybe_lower:
        or      al, 20h                 ; map upper-case to lower-case
        cmp     al, 'f'
        ja short cpstb_bad
        cmp     al, 'a'
        jb short cpstb_bad

        ; lower-case
        sub     al, 'a'-10

cpstb_have_nibble:
        cmp     ah, 0
        jne short cpstb_store_byte
        mov     ah, al
        or      ah, 80h
        jmp     cpstb_loop

cpstb_store_byte:
        shl     ah, 4
        or      al, ah
        stosb
        sub     ah, ah
        loop    cpstb_loop
cpstb_bad:
        krDebugOut DEB_ERROR, "ConvertPatchStringToBinary: bad char #al, or bad buffer size"
        sub     ax, ax
        jmp short cpstb_end
cpstb_maybe_good:
        cmp     ah, 0           ; odd-length input string ?
        jne     cpstb_bad
cpstb_good:
        or      al, 1
cpstb_end:
cEnd


;  PatchAppSegWorker
;
;	Do the work of patching an app segment.
;
; Arguments:
;	wSeg            - the segment we are about to patch
;   wPartySeg       - a data aliase of the segment we are about to patch
;   cbOriginalSeg   - the value returned by GlobalSize(wSeg)
;	lpcbCurrentSeg  - ptr to the current size of the segment
;       lpBinaryPatch   - the APPPATCH struct to apply to wSeg
;
; Returns:
;	VOID
;
; Registers Preserved:
;	DI, SI, DS

	assumes	ds, nothing
	assumes	es, nothing

;VOID
cProc   PatchAppSegWorker, <PUBLIC, NEAR>,<si,di,ds>
        parmW   wSeg
        parmW   wPartySeg
        parmW   cbOriginalSeg
        parmD   lpcbCurrentSeg
        parmD   lpBinaryPatch

        localW  wAddPartySeg

cBegin
        lds     si, lpBinaryPatch
        mov     es, wPartySeg
        krDebugOut  DEB_WARN,"PatchAppSegWorker: applying patch to party seg #es"

        mov     al, [si].AP_COMMON.ap_format
        cmp     al, AP_FORMAT_REPLACE
        jne short pasw_maybe_add

        ; Replace some code in a segment.
        krDebugOut  DEB_WARN,"PatchAppSegWorker: type==replace"

        ; Check size
        mov     ch, 0
        mov     cl, [si].AP_REPLACE.apr_cb
        mov     al, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        add     al, cl
        add     al, cl
        cmp     al, [si].AP_REPLACE.apr_cbSize

if KDEBUG
        je short @F
        mov     ah, ch
        mov     dh, ch
        mov     dl, [si].AP_REPLACE.apr_cbSize
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: actual size (#ax) != apa_cbSize (#dx)"
@@:
endif
        jne     pasw_end
        mov     di, [si].AP_REPLACE.apr_offset
        add     di, cx
        cmp     di, cbOriginalSeg
        ja      pasw_replace_offset_too_large

        sub     di, cx
        add     si, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        repe    cmpsb                   ; compare old bytes to hExe bytes
        jne     pasw_repl_no_match

        mov     si, lpBinaryPatch.lo
        mov     ch, 0
        mov     cl, [si].AP_REPLACE.apr_cb
        add     si, (AP_REPLACE.apr_abOld - AP_REPLACE.apr_format)
        add     si, cx                  ; skip over the old bytes
        sub     di, cx                  ; rewind to the patch area start
        rep     movsb                   ; replace the bytes
        jmp     pasw_end
pasw_maybe_add:
        cmp     al, AP_FORMAT_ADD
        jne pasw_bad_format

        ; Add some code to the segment.
        krDebugOut  DEB_WARN,"PatchAppSegWorker: type==add"

        ; Check size
        mov     ch, 0
        mov     cl, [si].AP_ADD.apr_cb
        mov     al, (AP_ADD.apa_abNew - AP_ADD.apa_format)
        add     al, cl
        cmp     al, [si].AP_ADD.apa_cbSize
if KDEBUG
        je short @F
        mov     ah, ch
        mov     dh, ch
        mov     dl, [si].AP_ADD.apa_cbSize
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: actual size (#ax) != apa_cbSize (#dx)"
@@:
endif
        jne     pasw_end

        ; Make sure the add is beyond the original segment.
        mov     di, [si].AP_ADD.apa_offset
        cmp     di, cbOriginalSeg
        jb short pasw_offset_too_small

        ; Grow the segment if necessary.
        mov     ah, 0
        mov     al, [si].AP_ADD.apa_cb
        add     di, ax

        ; See if the segment is already big enough.
        les     bx, lpcbCurrentSeg
        cmp     di, es:[bx]
        jbe short pasw_do_add

        ; Segment too small. Grow it.
        cCall   GlobalRealloc,<wSeg,0,di,0>
        ; Make sure we got the same sel back.
        mov     cx, wSeg
        and     al, not 1
        and     cl, not 1
        cmp     ax, cx
        jne short pasw_repl_realloc_failed

        ; Save the new size of the segment.
        les     bx, lpcbCurrentSeg
        mov     es:[bx], di

pasw_do_add:
        mov     ch, 0
        mov     cl, [si].AP_ADD.apa_cb

        ;Since wSeg may have grown, create a new party seg.
        mov     bx, wSeg
        mov     ax, 000Ah               ;DPMI, Create Code Segment Alias
        int     031h
        mov     es, ax

        sub     di, cx
        add     si, (AP_ADD.apa_abNew - AP_ADD.apa_format)
        rep     movsb                   ; add the bytes
        cCall   FreeSelector, <es>

if KDEBUG
        jmp short  pasw_end
endif

pasw_bad_format:
if KDEBUG
        sub     ah, ah
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: unknown format #ax"
        jmp short  pasw_end
endif
pasw_repl_realloc_failed:
if KDEBUG
        mov     ax, wSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: realloc failed on seg #ax"
        jmp short  pasw_end
endif
pasw_repl_no_match:
if KDEBUG
        krDebugOut  DEB_WARN,"PatchAppSegWorker: replace failed in seg #es"
        jmp short  pasw_end
endif
pasw_offset_too_small:
if KDEBUG
        mov     cx, cbOriginalSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: add offset (#di) < size (#cx)"
        jmp short  pasw_end
endif
pasw_replace_offset_too_large:
if KDEBUG
        mov     cx, cbOriginalSeg
        krDebugOut  DEB_ERROR,"PatchAppSegWorker: replace offset (#di) > size (#cx)"
endif
pasw_end:

cEnd


;  PatchAppSeg
;
;	Apply any patches for the given segment.
;
; Arguments:
;       hkeyPatchApp - reg key containing patches for this app
;	wSegNo       - number of the segment in the module
;       wSeg         - selector of the segment
;
; Returns:
;	BOOL - ax!=0 iff one or more patches applied
;
; Registers Preserved:
;	CX, DI, SI, DS, ES

	assumes	ds, nothing
	assumes	es, nothing

;BOOL
cProc   PatchAppSeg, <PUBLIC, FAR>,<cx,si,di,ds,es>
        parmD   hkeyPatchApp
        parmW   wSegNo
        parmW   wSeg

szKey_size          =   5
szValString_size    =  32
abValData_size      = 100
abBinaryPatch_size  = 100

        localD  hkey
        localV  szKey,szKey_size                    ; BUGBUG need a better size
        localV  szValString,szValString_size        ; BUGBUG need a better size
        localV  abValData,abValData_size            ; BUGBUG need a better size
        localV  abBinaryPatch,abBinaryPatch_size    ; BUGBUG need a better size
        localD  cbValString
        localD  cbValData
        localD  dwType
        localD  dwIndex
        localW  cbOriginalSeg
        localW  cbCurrentSeg
        localW  wPartySeg

cBegin
if KDEBUG
        mov     ax, wSegNo
        mov     bx, wSeg
        krDebugOut  DEB_WARN,"PatchAppSeg: enter, (wSegNo #ax) (wSeg #bx)"
endif
        push    wSeg
        call    GlobalSize
        mov     cbOriginalSeg,ax
        mov     cbCurrentSeg,ax

        ; Segment number is the subkey.

        lea     si, szKey
        cCall   Far_htoa0, <ss, si, wSegNo>
        mov     bx, ax
        mov     byte ptr ss:[bx], 0     ; NULL terminator

        ; Get the key for this module/seg pair.
        lea     si, szKey
        lea     di, hKey
        cCall   RegOpenKey32, <hkeyPatchApp, ss, si, ss, di>
        or      ax,dx
        jnz     pas_no_patches

        ; Turn off the code bit for the seg to make it writeable.
        ; NB - Bail if this is a data segment.



        mov     bx, seg gdtdsc
        mov     ds, bx
        assume  ds:nothing
        mov     ds, ds:gdtdsc
        mov     bx, wSeg
        and     bl, not 7
        test    byte ptr ds:[bx+5], DSC_CODE_BIT
        jz      pas_no_patches                  ; bail if data seg

        mov     bx, wSeg
        mov     ax, 000Ah               ;DPMI, Create Code Segment Alias
        int     031h
        mov     wPartySeg, ax

        ; Mark this code segment not discardable so we don't have to deal
        ; with patching it again.
        call    Far_genter
        mov dx, wSeg
        call    Far_pdref
        ; ds:esi = arena record
        and ds:[esi].pga_flags, not (GA_DISCARDABLE or GA_DISCCODE)
        call    Far_gleave

        or      dwIndex, -1
pas_loop:
        sub     ecx, ecx
        inc     dwIndex

        push    dword ptr hkey
        push    dword ptr dwIndex
        mov     cbValString, szValString_size
        mov     cbValData, abValData_size
        push    ss
        lea     ax, szValString
        push    ax
        push    ss
        lea     ax, cbValString
        push    ax
        push    ecx
        push    ss
        lea     ax, dwType
        push    ax
        push    ss
        lea     ax, abValData
        push    ax
        push    ss
        lea     ax, cbValData
        push    ax
        cCall   RegEnumValue32
        or      ax, dx
        jnz     pas_loop_done
if KDEBUG
        lea     bx, szValString
        krDebugOut  DEB_WARN,"PatchAppSeg: found patch @ss:bx"
endif

        cmp     dwType, REG_BINARY
        jne short pas_bad_type

        lea     bx, abValData                   ; ss:bx points to patch
        movzx   ecx, ss:[bx].AP_COMMON.ap_cbSize
        cmp     cbValData, ecx
if KDEBUG
        je short @F
        push    bx
        mov     eax, cbValData
        mov     edx, eax
        ror     edx, 16
        mov     ebx, ecx
        ror     ebx, 16
        krDebugOut  DEB_ERROR,"PatchAppSeg: actual size (#dx:#ax) != ap_cbSize (#bx:#cx)"
        pop     bx
@@:
endif
        jne     pas_loop

pas_apply_patch:
        lea     ax, cbCurrentSeg                ; ss:ax points to curr seg size
        ; Now apply the patch.

        cCall   PatchAppSegWorker,<wSeg,wPartySeg,cbOriginalSeg,ss,ax,ss,bx>
        jmp     pas_loop

pas_bad_type:
if KDEBUG
        mov     eax, dwType
        mov     edx, eax
        ror     edx, 16
        krDebugOut  DEB_WARN,"PatchAppSeg: unimplemented type #dx:#ax"
endif
        jmp     pas_loop

pas_no_patches:
        sub     ax, ax
        jmp short pas_end

pas_loop_done:
if KDEBUG
        test    dx, dx
        jnz short @F
        cmp     ax, ERROR_NO_MORE_ITEMS
        je short  pas_cleanup
@@:
        krDebugOut  DEB_WARN,"PatchAppSeg: unexpected error #dx#ax"
endif
pas_cleanup:
        cCall   FreeSelector, <wPartySeg>

        cCall   RegCloseKey32, <hkey>
        or      al, 1                       ; ax!=0 marks patch found in reg
pas_end:
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\pdb.inc ===
;
; MSDOS 2.xx Process Data Block
;
;   Contains all DOS specific data.
;

FilPerProc      EQU     20

; Process Data located in the Program Segment Prefix, just before the
; code and data for the loaded program.
;
PDB             STRUC
PDB_Exit_Call   DW  ?
PDB_block_len   DW  ?
                DB  ?
PDB_CPM_Call    DB  5 DUP (?)
PDB_Exit        DD  ?
PDB_Ctrl_C      DD  ?
PDB_Fatal_Abort DD  ?
PDB_Parent_PID  DW  ?
PDB_JFN_Table   DB  FilPerProc DUP (?)
PDB_environ     DW  ?
PDB_User_stack  DD  ?
PDB_JFN_Length	DW  ?			; DOS 3.x only
PDB_JFN_Pointer DD  ?			; DOS 3.x only
PDB_Next_PDB	DD  ?			; DOS 3.x only
PDB_InterCon	DB  ?			; DOS 4.x only
PDB_Append	DB  ?			; DOS 4.x only
PDB_Novell_Used	DB  02h DUP (?)
PDB_Version	DW  ?			; DOS 5.x only
PDB_Chain	DW  ?			; Windows only
PDB_Partition	DW  ?			; Windows only
PDB_NextPDB	DW  ?			; Windows only
PDB_GlobalHeap	DD  ?			; Windows only
PDB_Entry_stack DD  ?			; Windows only
PDB_Call_system DB  5h DUP (?)
PDB_PAD2        DB  7h DUP (?)
PDB_5C_FCB      DB  10h DUP (?)
PDB_6C_FCB      DB  14h DUP (?)
PDB_DEF_DTA     DB  80h DUP (?)
PDB             ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\newexe.h ===
/*static char *SCCSID = "@(#)newexe.h:2.9";*/
/*
 *  Title
 *
 *      newexe.h
 *      Pete Stewart
 *      (C) Copyright Microsoft Corp 1984
 *      17 August 1984
 *
 *  Description
 *
 *      Data structure definitions for the DOS 4.0/Windows 2.0
 *      executable file format.
 *
 *  Modification History
 *
 *      84/08/17        Pete Stewart    Initial version
 *      84/10/17        Pete Stewart    Changed some constants to match OMF
 *      84/10/23        Pete Stewart    Updates to match .EXE format revision
 *      84/11/20        Pete Stewart    Substantial .EXE format revision
 *      85/01/09        Pete Stewart    Added constants ENEWEXE and ENEWHDR
 *      85/01/10        Steve Wood      Added resource definitions
 *      85/03/04        Vic Heller      Reconciled Windows and DOS 4.0 versions
 *      85/03/07        Pete Stewart    Added movable entry count
 *      85/04/01        Pete Stewart    Segment alignment field, error bit
 */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words in header */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERESWDS]; /* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NERESBYTES      0

struct new_exe                          /* New .EXE header */
  {
    unsigned short int  ne_magic;       /* Magic number NE_MAGIC */
    char                ne_ver;         /* Version number */
    char                ne_rev;         /* Revision number */
    unsigned short int  ne_enttab;      /* Offset of Entry Table */
    unsigned short int  ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short int  ne_flags;       /* Flag word */
    unsigned short int  ne_autodata;    /* Automatic data segment number */
    unsigned short int  ne_heap;        /* Initial heap allocation */
    unsigned short int  ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short int  ne_cseg;        /* Count of file segments */
    unsigned short int  ne_cmod;        /* Entries in Module Reference Table */
    unsigned short int  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short int  ne_segtab;      /* Offset of Segment Table */
    unsigned short int  ne_rsrctab;     /* Offset of Resource Table */
    unsigned short int  ne_restab;      /* Offset of resident name table */
    unsigned short int  ne_modtab;      /* Offset of Module Reference Table */
    unsigned short int  ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short int  ne_cmovent;     /* Count of movable entries */
    unsigned short int  ne_align;       /* Segment alignment shift count */
    unsigned short int  ne_cres;        /* Count of resource segments */

#ifdef NEVER
    unsigned short int  ne_psegcsum;    /* offset to segment chksums */
#else
    unsigned char	ne_exetyp;	/* Target Operating system */
    unsigned char	ne_flagsothers;	/* Other .EXE flags */
#endif
    unsigned short int  ne_pretthunks;  /* offset to return thunks */
    unsigned short int  ne_psegrefbytes;/* offset to segment ref. bytes */
    unsigned short int  ne_swaparea;    /* Minimum code swap area size */
    unsigned short int  ne_expver;      /* Expected Windows version number */
  };

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_RES(x)       (x).ne_res
#define NE_EXETYPE(x)	(x).ne_exetyp

#define NE_USAGE(x)     (WORD)*((WORD FAR *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_PAUTODATA(x) (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

#ifdef DOS5
#define NE_MTE(x)   (x).ne_psegcsum /* DOS 5 MTE handle for this module */
#endif


/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   c                                  Non-conforming
 *    e                                 Errors in image
 *     xxxxxxxxx                        Unused
 *              P                       Runs in protected mode
 *               r                      Runs in real mode
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NENONC          0x4000          /* Non-conforming program */
#define NEIERR          0x2000          /* Errors in image */
#define NEPROT          0x0008          /* Runs in protected mode */
#define NEREAL          0x0004          /* Runs in real mode */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */

struct new_seg                          /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
  };

struct new_seg1                         /* New .EXE segment table entry */
  {
    unsigned short      ns_sector;      /* File sector of start of segment */
    unsigned short      ns_cbseg;       /* Number of bytes in file */
    unsigned short      ns_flags;       /* Attribute flags */
    unsigned short      ns_minalloc;    /* Minimum allocation in bytes */
    unsigned short      ns_handle;      /* Handle of segment */
  };

#define NS_SECTOR(x)    (x).ns_sector
#define NS_CBSEG(x)     (x).ns_cbseg
#define NS_FLAGS(x)     (x).ns_flags
#define NS_MINALLOC(x)  (x).ns_minalloc

/*
 *  Format of NS_FLAGS(x):
 *
 *  xxxx                                Unused
 *      DD                              286 DPL bits
 *        d                             Segment has debug info
 *         r                            Segment has relocations
 *          e                           Execute/read only
 *           p                          Preload segment
 *            P                         Pure segment
 *             m                        Movable segment
 *              i                       Iterated segment
 *               ttt                    Segment type
 */
#define NSTYPE          0x0007          /* Segment type mask */
#define NSCODE          0x0000          /* Code segment */
#define NSDATA          0x0001          /* Data segment */
#define NSITER          0x0008          /* Iterated segment flag */
#define NSMOVE          0x0010          /* Movable segment flag */
#define NSPURE          0x0020          /* Pure segment flag */
#define NSPRELOAD       0x0040          /* Preload segment flag */
#define NSEXRD          0x0080          /* Execute-only (code segment), or
                                        *  read-only (data segment)
                                        */
#define NSRELOC         0x0100          /* Segment has relocations */
#define NSDEBUG         0x0200          /* Segment has debug info */
#define NSDPL           0x0C00          /* 286 DPL bits */
#define NSDISCARD       0x1000          /* Discard bit for segment */

#define NSALIGN 9       /* Segment data aligned on 512 byte boundaries */

struct new_segdata                      /* Segment data */
  {
    union
      {
        struct
          {
            unsigned short      ns_niter;       /* number of iterations */
            unsigned short      ns_nbytes;      /* number of bytes */
            char                ns_iterdata;    /* iterated data bytes */
          } ns_iter;
        struct
          {
            char                ns_data;        /* data bytes */
          } ns_noniter;
      } ns_union;
  };

struct new_rlcinfo                      /* Relocation info */
  {
    unsigned short      nr_nreloc;      /* number of relocation items that */
  };                                    /* follow */

struct new_rlc                          /* Relocation item */
  {
    char                nr_stype;       /* Source type */
    char                nr_flags;       /* Flag byte */
    unsigned short      nr_soff;        /* Source offset */
    union
      {
        struct
          {
            char        nr_segno;       /* Target segment number */
            char        nr_res;         /* Reserved */
            unsigned short nr_entry;    /* Target Entry Table offset */
          }             nr_intref;      /* Internal reference */
        struct
          {
            unsigned short nr_mod;      /* Index into Module Reference Table */
            unsigned short nr_proc;     /* Procedure ordinal or name offset */
          }             nr_import;      /* Import */
      }                 nr_union;       /* Union */
  };

#define NR_STYPE(x)     (x).nr_stype
#define NR_FLAGS(x)     (x).nr_flags
#define NR_SOFF(x)      (x).nr_soff
#define NR_SEGNO(x)     (x).nr_union.nr_intref.nr_segno
#define NR_RES(x)       (x).nr_union.nr_intref.nr_res
#define NR_ENTRY(x)     (x).nr_union.nr_intref.nr_entry
#define NR_MOD(x)       (x).nr_union.nr_import.nr_mod
#define NR_PROC(x)      (x).nr_union.nr_import.nr_proc

/*
 *  Format of NR_STYPE(x):
 *
 *  xxxxx                               Unused
 *       sss                            Source type
 */
#define NRSTYP          0x07            /* Source type mask */
#define NRSSEG          0x02            /* 16-bit segment */
#define NRSPTR          0x03            /* 32-bit pointer */
#define NRSOFF          0x05            /* 16-bit offset */

/*
 *  Format of NR_FLAGS(x):
 *
 *  xxxxx                               Unused
 *       a                              Additive fixup
 *        rr                            Reference type
 */
#define NRADD           0x04            /* Additive fixup */
#define NRRTYP          0x03            /* Reference type mask */
#define NRRINT          0x00            /* Internal reference */
#define NRRORD          0x01            /* Import by ordinal */
#define NRRNAM          0x02            /* Import by name */
#define OSFIXUP 	0x03		/* Floating point fixup */


/* Resource type or name string */
struct rsrc_string
    {
    char rs_len;            /* number of bytes in string */
    char rs_string[ 1 ];    /* text of string */
    };

#define RS_LEN( x )    (x).rs_len
#define RS_STRING( x ) (x).rs_string

/* Resource type information block */
struct rsrc_typeinfo
    {
    unsigned short rt_id;
    unsigned short rt_nres;
    long rt_proc;
    };

#define RT_ID( x )   (x).rt_id
#define RT_NRES( x ) (x).rt_nres
#define RT_PROC( x ) (x).rt_proc

/* Resource name information block */
struct rsrc_nameinfo
    {
    /* The following two fields must be shifted left by the value of  */
    /* the rs_align field to compute their actual value.  This allows */
    /* resources to be larger than 64k, but they do not need to be    */
    /* aligned on 512 byte boundaries, the way segments are           */
    unsigned short rn_offset;   /* file offset to resource data */
    unsigned short rn_length;   /* length of resource data */
    unsigned short rn_flags;    /* resource flags */
    unsigned short rn_id;       /* resource name id */
    unsigned short rn_handle;   /* If loaded, then global handle */
    unsigned short rn_usage;    /* Initially zero.  Number of times */
                                /* the handle for this resource has */
                                /* been given out */
    };

#define RN_OFFSET( x ) (x).rn_offset
#define RN_LENGTH( x ) (x).rn_length
#define RN_FLAGS( x )  (x).rn_flags
#define RN_ID( x )     (x).rn_id
#define RN_HANDLE( x ) (x).rn_handle
#define RN_USAGE( x )  (x).rn_usage

#define RSORDID     0x8000      /* if high bit of ID set then integer id */
                                /* otherwise ID is offset of string from
                                   the beginning of the resource table */

                                /* Ideally these are the same as the */
                                /* corresponding segment flags */
#define RNMOVE      0x0010      /* Moveable resource */
#define RNPURE      0x0020      /* Pure (read-only) resource */
#define RNPRELOAD   0x0040      /* Preloaded resource */
#define RNDISCARD   0x1000      /* Discard bit for resource */

#define RNLOADED    0x0004	/* True if handler proc return handle */

#define RNCOMPR     0x0200	/* Resource is compressed in ROM */

/* Resource table */
struct new_rsrc
    {
    unsigned short rs_align;    /* alignment shift count for resources */
    struct rsrc_typeinfo rs_typeinfo;
    };

#define RS_ALIGN( x ) (x).rs_align

/* Target operating systems:  Possible values of ne_exetyp field */

#define NE_UNKNOWN	0	/* Unknown (any "new-format" OS) */
#define NE_OS2		1	/* Microsoft/IBM OS/2 (default)  */
#define NE_WINDOWS	2	/* Microsoft Windows		 */
#define NE_DOS4 	3	/* Microsoft MS-DOS 4.x		 */
#define NE_DEV386	4	/* Microsoft Windows 386	 */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\protect.inc ===
ifdef WOW
DPMICALL MACRO	callno
        mov     ax, callno
        call    DPMIProc
        ENDM
else
DPMICALL	MACRO	func
	mov	ax, func
	int	31h
		ENDM
endif; WOW


RING		equ	3		; RING 1 we be

SEL_LDT		equ	4
SEG_RING	equ	(RING+SEL_LDT)
SEG_RING_MASK	equ	7

IS_SELECTOR	equ	1		; Selectors are odd, handles even

					; Bits in dsc_access
DSC_PRESENT	equ	80h
DSC_CODEDATA	equ	10h		; Code or data descriptor
DSC_RING	equ	(RING SHL 5)
DSC_CODE	equ	(1Bh+DSC_RING)	; Code, readable, accessed
DSC_CODE_BIT	equ	08h		; Identifies code
DSC_RW_BIT	equ	02h		; Code readable, data writable bit
DSC_DATA	equ	(13h+DSC_RING)	; Data, writable, accessed
DSC_ACCESSED	equ	01h		; Segment was accessed

DSC_USED	equ	0Fh		; Access rights to mark descriptor used

					; Bits in dsc_hlimit
DSC_GRANULARITY	equ	80h		; Page granularity segment
DSC_DEFAULT	equ	40h		; Default word size
DSC_DISCARDABLE	equ	10h		; Available bit in descriptor
					; (using access as a word)

GDT_FREEDSC	equ	-1
GDT_NPDSC	equ	07FFFh

if PMODE
if PMODE32
GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = (NOT GA_ALIGN_BYTES)
endif
endif

DscPtr	struc			;Descriptor
dsc_limit	dw	?	;Descriptor max length
dsc_lbase	dw	?	;Descriptor base bits 15-0
dsc_mbase	db	?	;Descriptor base bits 23-16
dsc_access	db	?	;Descriptor access byte
dsc_hlimit	db	?	;High limit, granularity and 2 custom bits
dsc_hbase	db	?	;Descriptor base bits 31-24
DscPtr	ends


DSC_LEN		equ	(size DscPtr)
.ERRNZ		DSC_LEN-8		; Paranoia

dsc386		equ	word ptr dsc_hlimit
dsc_owner	equ	word ptr dsc_limit

if PMODE
if PMODE32
GENTER32	MACRO

	push	esi
	push	edi
	call	genter
	mov	gs, di

		ENDM


GLEAVE32	MACRO

	mov	es, di		; Zero ES for now
	mov	fs, di		; And FS
	call	gleave
	pop	edi
	pop	esi

		ENDM

MIN_FREE_ARENAS		equ	30h	; Minimum number of free arenas desired
ARENA_INCR_BYTES	equ	8192	; Space for more arenas
endif
endif

if PMODE
ife RING-3

;
; Change selector or handle to a handle
;	Handles are RING 2
;	Selectors are RING 3
;
Sel_To_Handle	MACRO	xsel
	and	xsel, NOT 1
		ENDM

;
; Change handle or selector to a selector
;
Handle_To_Sel	MACRO	xsel
	or	xsel, 1
		ENDM

;
; Change known selector into corresponding handle
;
StoH			MACRO	sel
	dec	sel
		ENDM

;
; Change known handle into corresponding selector
;
HtoS			MACRO	h
	inc	h
		ENDM

;
; Given a segment limit, calculate the
; number of selectors in the array
;
Limit_To_Selectors	MACRO	reg
	shr	reg, 16		; Now divide by 64k to get # of selectors - 1
	inc	reg
		ENDM

endif

ife RING-1
;
; Change selector or handle to a handle
;	Handles are RING 2
;	Selectors are RING 1
;
Sel_To_Handle	MACRO	xsel
	test	xsel, 1
	jz	short @F
	inc	xsel	
@@:
		ENDM

;
; Change handle or selector to a selector
;
Handle_To_Sel	MACRO	xsel
	test	xsel, 1
	jnz	short @F
	dec	xsel
@@:
		ENDM

;
; Change known selector into corresponding handle
;
StoH			MACRO	sel
	inc	sel
		ENDM

;
; Change known handle into corresponding selector
;
HtoS			MACRO	h
	dec	h
		ENDM

endif


IsFixed		MACRO	xh
	test	xh, 1
		ENDM

endif	; PMODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\resaux.asm ===
TITLE	RESAUX - support routines for resource manager

.xlist
include kernel.inc
include newexe.inc
include tdb.inc
include	protect.inc
.list

ifdef WOW
     WOW_OPTIMIZE_PRELOADRESOURCE = 1
endif

externA	 __AHINCR
externFP _lclose
externFP GlobalFree
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalFlags
externFP GlobalReAlloc
externFP GlobalHandle
externFP GetExePtr
externFP MyOpenFile
externFP FarMyUpper
;externFP GlobalAlloc
externFP lstrlen
externFP lstrOriginal
externFP Int21Handler

externFP AllocSelector
externFP FreeSelector
externFP LongPtrAdd
ifdef WOW
externFP WOWFreeResource
endif

ifdef WOW_OPTIMIZE_PRELOADRESOURCE
externFP LongPtrAddWOW
externFP AllocSelectorWOW
endif

if KDEBUG
externFP OutputDebugString
endif
	 
if ROM
externFP LZDecode
externFP FindROMModule
externNP SetROMOwner
externNP GetROMOwner
endif


DataBegin

externW  Win_PDB

if KDEBUG
externB  fLoadTrace
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MyAlloc
externNP MyLock
externNP GetOwner
externNP SetOwner
externNP GetCachedFileHandle
externNP CloseCachedFileHandle

externFP AllocSelectorArray
externFP set_discarded_sel_owner
externNP SetResourceOwner
if PMODE32
externNP AllocResSelArray
endif
ifdef WOW
externFP hMemCpy
externFP _HREAD
externW  gdtdsc
endif

if ROM
externFP <FreeSelector,GetSelectorBase,SetSelectorBase,SetSelectorLimit>
endif


;-----------------------------------------------------------------------;
;									;
;  DirectResAlloc - This allocates memory for creating cursors and icons;
;	"on the fly".							;
;									;
; Arguments:								;
;	parmW   hinstance ; Identifies the instance that allocates	;
;	parmW	resFlags  ; Flags to be used in memory allocation	;
;	parmW	nBytes	  ; The size of the memory to be allocated	;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
; Fri 06 Jan 1989  -- Written by Sankar.				;
;									;
;-----------------------------------------------------------------------;

cProc	DirectResAlloc, <PUBLIC, FAR>, <si,di>
	parmW	hInstance
	parmW	resFlags
	parmW	nBytes

cBegin
	cCall	GetExePtr, <hInstance>
	or	ax, ax
	jz	err_end
        push    ax	 ; Save ptr to EXE header
	
	xor	bx, bx
	cCall	MyResAlloc, <ax, resFlags, nBytes, bx>
	xchg	ax,dx
	pop	cx			; restore exe header address
	or	ax,ax
	jz	err_end
	cCall	SetOwner,<ax,cx>
	xchg	ax,dx
 err_end:
cEnd


cProc	MyResAlloc,<PUBLIC,NEAR>
	parmW   hExe
	parmW   resFlags
	parmW   nBytes
	parmW   nAlign
cBegin
	mov	bx,resFlags		; Allocate memory for
	or	bl,NSTYPE or RNMOVE	; non-code, non-data segment
	cCall	MyAlloc,<bx,nBytes,nAlign>
	test	dl,GA_FIXED
	jnz	mysox
	mov	bx,dx

	HtoS	bx			; Make it ring 1
	lar	cx, bx
	jnz	mysox
	test	ch, 80h			; Present?
	jnz	mysox
int 3
	mov	es, hExe		; Set limit to the owner ie. hExe.
	cCall	set_discarded_sel_owner

mysox:
	xchg	ax,dx
cEnd

cProc	IAllocResource,<PUBLIC,FAR>,<si>
	parmW   hResFile
	parmW   hResInfo
	parmD   newSize
cBegin
	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jz	arx
	mov	es,ax
	push	es			; Save exe header address
	mov	si,hResInfo
	push	es			; push hexe
	mov	bx,es:[si].rn_flags
	or	bl,NSTYPE		; non-code, non-data segment
	push	bx			; push flags
	push	es:[si].rn_length	; push default size
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	mov	dx,OFF_newSize
	or	dx,SEG_newSize		; Want a different size?
	jz	ar1			; No, continue
	pop	dx			; Yes discard default size
	push	cx			; Save alignment shift
	mov	dx,newSize.hi		; Round up new size by alignment
	xor	ax,ax
	not	ax
	shl	ax,cl
	not	ax
	add	ax,newSize.lo
	adc	dx, 0
ar0:
	shr	dx,1			; convert to alignment units
	rcr	ax,1
	loop	ar0
	pop	cx			; Restore alignment shift
	push	ax			; Push new size
ar1:
	cmp	es:[si].rn_handle,0	; Already a handle?
	je	ar2			; No, continue
	pop	ax			; AX = length
	add	sp,4			; ignore flags and hExe
	xor	dx,dx
	jcxz	ma3
ma2:
	shl	ax,1
	rcl	dx,1
	loop	ma2
ma3:
	xor	cx,cx
	cCall	GlobalReAlloc,<es:[si].rn_handle,dxax,cx>
	cwd				; zero dx (may not be needed)
	or	ax,ax			; did it fail?
	jz	ar3

	cCall	GlobalHandle,<ax>
	jmps	ar3
ar2:
	push	cx			; push alignment shift count
	cCall	MyResAlloc		; rn_flags, rn_length, rs_align
ar3:
	xchg	ax,dx
	pop	cx			; restore exe header address
	or	ax,ax
	jz	arx
	cCall	SetOwner,<ax,cx>
	xchg	ax,dx
arx:
	or	ax, ax
	jnz	@F
        KernelLogError  DBF_WARNING,ERR_ALLOCRES,"AllocResource failed"
	xor	ax, ax			; Restore the NULL value in ax
@@:
	mov	cx,ax
cEnd


cProc	ResAlloc,<PUBLIC,FAR>,<si,di>
	parmD   pResInfo
	parmW   fh
	parmW   isfh
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        parmW    hiResOffset
        parmW    loResOffset
endif
	localW  hres
cBegin
	xor	ax,ax
	cCall	IAllocResource,<pResInfo,ax,ax>
	les	si,pResInfo
	mov	hres,ax			; Returns handle in AX
	mov	ax,dx			; Segment address in DX
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	mov	dx,es:[si].rn_length
	xor	bx,bx
	cmp	hres,bx
;	jnz	ra1
	jz	rax

ra1:	shl	dx,1
	rcl	bx,1
	loop	ra1
if ROM
	test	es:[si].rn_flags,RNCOMPR	; is this a compressed ROM res?
	jz	not_rom_comp
	xor	si,si
	cCall	LZDecode,<ax,fh,si,si>		; ax=dest, fh=src
	or	ax,ax
	jz	rafail2
	jmps	ra4
not_rom_comp:
endif
	push	ds
	mov	cx,dx
	mov	si, bx			; Save hi word of length
	mov	bx,fh
	cmp	isfh,bx			; is bx a file handle?
	je	ra2			; if so, load from file
ifdef WOW
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        cmp     hiResOffset, 0
        jz      @F
        push    ax
        mov     al, __AHINCR
        mul     byte ptr hiResOffset
        add     bx,ax
        pop     ax
@@:
	cCall	hMemCpy,<ax,0,bx,loResOffset,si,cx>
else
	cCall	hMemCpy,<ax,0,bx,0,si,cx>
endif
	jmps	ra3
ra2:
	cCall	_hRead,<bx,ax,0,si,cx>
	cmp	dx, si			; If we didn't read what we wanted
	jnz	rafail			; then fail
	cmp	ax, cx
	jnz	rafail
else ; NOT WOW
	cCall	CopyResource,<ax,bx,si,cx>
	jmps	ra3
ra2:
	cCall	ReadResource,<ax,bx,si,cx>
	jc	rafail
endif ; WOW
ra3:
	pop	ds
ra4:
	mov	ax,hres
	jmps	rax
rafail:
	mov	bx,ds
	pop	ds
rafail2:
	cCall	GlobalFree,<hres>
if KDEBUG
        push    es
        mov     bx,SEG_pResInfo
        mov     es,bx
        xor     bx,bx
        KernelLogError <DBF_WARNING>,ERR_BADRESREAD,"Unable to read resource from @ES:BX"
        pop     es
endif
	xor	ax,ax
rax:
cEnd

cProc	CopyResource,<PUBLIC,NEAR>
	parmW	DestSeg
	parmW	SrcSeg
	parmD	nBytes
cBegin
	push	es
	mov	ds, SrcSeg			; bx is segment of resource
	mov	es, DestSeg
	xor	si, si
	xor	di, di
	cld
rc_next:
	mov	cx, 8000h
	cmp	word ptr [nBytes+2], 0
	clc					; No odd byte to copy
	jne	big_copy
	mov	cx, word ptr [nBytes]
	shr	cx, 1				; Word count
big_copy:
	rep	movsw
	rcl	cx, 1				; Rescue low bit
	rep	movsb				; Any odd byte

	dec	word ptr [nBytes+2]
	js	rc_done

	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
	mov	ax, es
	add	ax, __AHINCR
	mov	es, ax
	jmp	rc_next

rc_done:
	pop	es
cEnd

cProc	ReadResource,<PUBLIC,NEAR>
	parmW	DestSeg
	parmW	fh
	parmD	nBytes
cBegin
	mov	bx, fh
	xor	dx, dx
	mov	ds, DestSeg
	mov	di, word ptr nBytes
	mov	si, word ptr [nBytes+2]
around_again:
	mov	cx, 8000h
	or	si, si
	jnz	big_xfer
	cmp	di, cx
	jae	big_xfer
	mov	cx, di
big_xfer:
	mov	ah, 3Fh
	DOSCALL
	jc	rrfail
	cmp	ax, cx
	jne	rrfail

	sub	di, cx
	sbb	si, 0
	jnz	incr_address
	or	di, di
	jz	rrdone
incr_address:
	add	dx, cx
	jnc	around_again
	mov	ax, ds
	add	ax, __AHINCR
	mov	ds, ax
	jmp	around_again

rrfail:
	stc
	jmps	rrx
rrdone:
	clc
rrx:
cEnd

cProc	IAccessResource,<PUBLIC,FAR>
	parmW   hResFile
	parmW   hResInfo
cBegin
	xor	ax, ax
	cCall	InternalAccessResource,<hResFile,hResInfo,ax>
cEnd

cProc	InternalAccessResource,<PUBLIC>
	parmW   hResFile
	parmW   hResInfo
	parmW	CachedFile
cBegin
	cCall	GetExePtr,<hResFile>
	mov	es,ax
	mov	bx, hResInfo
	mov	ax,es:[bx].rn_flags
if ROM
	test	es:[ne_flags],NEMODINROM
	jnz	@f
	test	ax, RNINROM or RNCOMPR
	jz	iar_ok
@@:
if KDEBUG
	Debug_Out "InternalAccessResource called for ROM resource!"
endif
	jmps	ra2b
iar_ok:
endif
	push	es:[bx].rn_length
	push	es:[bx].rn_offset
	mov	dx,es:[ne_pfileinfo]
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	push	cx
	push	es
	cmp	CachedFile, 0
	je	open_it
	mov	cx, -1
	cCall	GetCachedFileHandle,<es,cx,cx>
	mov	bx, ax
	jmps	got_fh
open_it:
if SHARE_AWARE
	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT or OF_SHARE_DENY_WRITE
else
	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
endif
	regptr	esdx,es,dx
	push	es
	push	dx
	cCall	MyOpenFile,<esdx,esdx,bx>	; returns handle in ax & bx
	pop	dx
	pop	es
;;;	cmp	ax, -1				; Success?
;;;	jne	got_fh				;  yes.
;;;						;  no, try compatibility mode
;;;	mov	bx,OF_REOPEN or OF_VERIFY or OF_NO_INHERIT
;;;	regptr	esdx,es,dx				   
;;;	cCall	MyOpenFile,<esdx,esdx,bx>	; returns handle in ax & bx
got_fh:
	pop	es
	pop	cx
	pop	dx
	inc	ax
	jnz	ra2c
	pop	dx
ra2b:
	mov	bx,-1
	jmps	ra2x
ra2c:
	xor	ax,ax
	push	cx
AR_shift:
	shl	dx,1
	rcl	ax,1
	loop	AR_shift
	mov	cx,ax
	mov	ax,4200h
	DOSCALL
	pop	cx
	pop	dx
	jc	ra2b
	xor	ax,ax
AR_shift1:
	shl	dx,1
	rcl	ax,1
	loop	AR_shift1
	mov	cx,ax			; CX:DX is size of resource
ra2x:
	mov	ax,bx			; AX and BX are file handle
cEnd

cProc	ILockResource,<PUBLIC,FAR>,<si>
	parmW   hres
	localD	lpfn
cBegin
	mov	ax,hres			; Get object handle
	or	ax,ax
	jnz	short_rel
lrfail0:
	jmp	lrfail
short_rel:

ifdef WOW
	test	ax, GA_WOWHANDLE	; should we call WOW32 FreeResource?
	jnz	@f
        jmp     lrfail

@@:
endif; WOW

	cCall	GlobalLock,<ax>		; Attempt to lock it
	jcxz	yawn
	jmp	lrx
yawn:
if ROM
	cCall	GetROMOwner,<hres>	; GlobalLock failed, is it in ROM?
	or	ax,ax
	jz	not_in_rom
	mov	dx,hres 		; It's in ROM so just return
	xor	ax,ax			;   the pointer to it
	jmp	lrx
not_in_rom:
endif
	mov	bx,hres 		; Failed, is it fixed?
	test	bl,GA_FIXED
	jnz	lrfail0			; Yes, fail all the way

	HtoS	bx
if PMODE32
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

        push    cx
        lar     cx, bx
        pop     cx
        jnz     lrfail0                 ; NZ -> LAR failed
	mov	es,cs:gdtdsc
	and	bl, not 7
	mov	bx,es:[bx].dsc_owner
else
	lsl	bx, bx			; No, get the owner
	jnz	lrfail0
endif
	mov	es,bx
	assumes es,nothing
	cmp	es:[ne_magic],NEMAGIC	; Does owner point to EXE header?
	jne	lrfail			; No, fail.
	mov	bx,es:[ne_rsrctab]	; Yes, scan resource table
	cmp	es:[ne_restab],bx	; Is there a resource table?
	je	lrfail			; No, just free the global object
	push	ds
	SetKernelDS
	pop	ds
	assumes	ds, nothing
	mov	dx,hres			; Yes, look for this handle
	add	bx,SIZE NEW_RSRC	; Point to first resource type
lrloop0:
	cmp	es:[bx].rt_id,ax	; End of table?
	je	lrfail			; Yes, just return failure
	lea	si,[bx].rt_proc		; Remember address of type proc.
	mov	cx,es:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO	; Point to first resource of this type
lrloop:
	cmp	es:[bx].rn_handle,dx	; Is this the one?
	je	lr3			; Yes, go see if type proc to call
	add	bx,SIZE RSRC_NAMEINFO	; No, point to next resource
	loop	lrloop			; Any more resources for this type?
	jmps	lrloop0			; No, advance to next type
lr3:
	cmp	word ptr es:[si+2],0	; Was there a proc defined for this type
	je	lrfail			; No, return failure.

if KDEBUG
	jmp	PrintInfo
PrintedInfo:
endif
	push	ds			; preserve these registers across call
	push	es
	push	bx

	mov	ax,word ptr es:[si]	; set up proc addr to call on stack
	mov	word ptr lpfn,ax
	mov	ax,word ptr es:[si]+2
	mov	word ptr lpfn+2,ax

	mov	cx,es			; cx = es for later push

	mov	ax,ss			; Zap segment registers so he can't
	mov	es,ax			; diddle DS
	mov	ds,ax

	cCall	lpfn,<dx,cx,bx> 	; Yes, call proc to reload

	xchg	ax,cx			; cx = result
	jcxz	@F			; skip lock if NULL

	cCall	GlobalLock,<cx> 	; Attempt to lock result
@@:
	pop	bx
	pop	es
	pop	ds
	jcxz	lrfail
	or	byte ptr es:[bx].rn_flags,RNLOADED  ; Mark loaded
	jmps	lrx
lrfail:					; Here to return failure.
        KernelLogError  DBF_WARNING,ERR_LOCKRES,"LockResource failed"
	xor	ax,ax
	cwd
lrx:
cEnd

if KDEBUG
RCTypes:
	db	'Custom', 0
	db	'Cursor', 0
	db	'Bitmap', 0
	db	'Icon', 0
	db	'Menu', 0
	db	'Dialog', 0
	db	'String', 0
	db	'FontDir', 0
	db	'Font', 0
	db	'Accelerator', 0
	db	'RCData', 0
	db	'Type11', 0
	db	'GroupCursor', 0
	db	'Type13', 0
	db	'GroupIcon', 0
	db	0
PrintInfo:
	pusha
	mov	cx, word ptr es:[si][rt_id-rt_proc]
	and	ch, not 80h
	mov	si, offset RCTypes
pi_1:	inc	si
pi_2:	cmp	byte ptr cs:[si], 0
	jnz	pi_1
	inc	si
	cmp	byte ptr cs:[si], 0
	loopnz	pi_2
	jnz	@F
	mov	si, offset RCTypes
@@:
	mov	ax, es:[bx].rn_id
;	test    ah, 80h
;	jz      pi_name
	and	ah, not 80h
	krDebugOut	<DEB_TRACE or DEB_krLoadSeg>, "%es0: reading resource @CS:SI.#ax"
;	jmps    pi_done
;pi_name:
;	int 3
;	krDebugOut      <DEB_TRACE or DEB_krLoadSeg>, "%es0: reading resource @CS:SI.@ES:AX"
;pi_done:
        popa
	jmp	PrintedInfo
endif	   


cProc	IFreeResource,<PUBLIC,FAR>,<ds,si>
	parmW   hres
cBegin
	mov	ax,hres			; Get segment address of resource
	or	ax,ax
	jz	frxj
ifdef WOW
	test	ax, GA_WOWHANDLE	; should we call WOW32 FreeResource?
	jnz	@f
	cCall	WOWFreeResource,<ax>	; you bet !
	xor	ax, ax
	jmp	frxx

@@:
endif; WOW
	cCall	MyLock,<ax>
	or	ax,ax			; Discarded or invalid handle?
	jnz	fr0a			; No, continue
	mov	bx,hres

	test	bl,GA_FIXED
	jnz	fr2			; Return NULL
	HtoS	bx			; Fix RPL so we can do LAR
	lar	cx, bx
	jnz	fr2			; LAR failed, return NULL
	test	ch, 80h			; Present?
	jnz	fr2			;  yes, return NULL
if PMODE32
;   On WOW we don't copy the owner to the real LDT since it is slow to call
;   the NT Kernel, so we read our copy of it directly.
;   see set_discarded_sel_owner   mattfe mar 23 93

	mov	ds,cs:gdtdsc
	and	bl, not 7
	mov	cx,ds:[bx].dsc_owner
	mov	ds,cx
else
	lsl	cx, bx			; Get owner
	mov	ds, cx
endif
	jmps	fr0b
frxj:
	jmps	frx

fr0a:
	cCall	GetOwner,<ax>
	mov	ds,ax
	xor	ax,ax

fr0b:
	cmp	ds:[ne_magic],NEMAGIC	; Is it an exe header?
	jne	fr1			; No, just free the handle
	mov	bx,ds:[ne_rsrctab]
	cmp	ds:[ne_restab],bx	; Is there a resource table?
	je	fr1			; No, just free the handle
	mov	dx,hres
	add	bx,SIZE NEW_RSRC	; Point to first resource type
frloop0:
	cmp	ds:[bx].rt_id,ax	; End of table?
	je	fr1			; Yes, just free the handle
	mov	cx,ds:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO	; Point to first resource of this type
frloop:
	cmp	ds:[bx].rn_handle,dx	; Is this the one?
	je	fr0			; Yes, go decrement usage count
	add	bx,SIZE RSRC_NAMEINFO	; No, point to next resource
	loop	frloop			; Any more resources for this type?
	jmps	frloop0			; No, advance to next type
fr0:
	cmp	ds:[bx].rn_usage,ax	; Already zero?
	je	fr1a			; Yes, then free this resource now
	dec	ds:[bx].rn_usage	; Decrement use count
	jg	frx			; Positive means still in use
	test	ds:[bx].rn_flags,RNDISCARD  ; Discardable?
	jnz	fr2			; Yes, let discard logic toss it
fr1a:
	mov	ds:[bx].rn_handle,ax	; o.w. free memory now
	and	byte ptr ds:[bx].rn_flags,not RNLOADED	; Mark not loaded
if ROM
	mov	ax,ds:[bx].rn_flags		; If the resource is in ROM,
	and	ax,RNINROM OR RNPURE OR RNCOMPR ;   uncompressed, and pure,
	cmp	ax,RNINROM OR RNPURE		;   only it's selector needs
	jnz	fr1				;   to be freed
	cCall	FreeSelector,<hres>
	jmps	frxx
endif
fr1:
	cCall	GlobalFree,<hres>	; Free global object
fr2:
	mov	hres,ax
frx:
	mov	ax,hres			; Return zero if freed, hres o.w.
frxx:
cEnd


cProc	ISizeofResource,<PUBLIC,FAR>
	parmW   hResFile
	parmW   hResInfo
cBegin
	cCall	GetExePtr,<hResFile>
	mov	es,ax
	mov	bx,hResInfo
	mov	ax,es:[bx].rn_length
	xor	dx,dx
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
sr0:	shl	ax,1
	rcl	dx,1
	loop	sr0
cEnd


cProc	DefaultResourceHandler,<PUBLIC,FAR>,<si,di>
	parmW   hRes
	parmW   hResFile
	parmW   hResInfo
	localW	SavePDB
cBegin
	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jz	drhx
	mov	si,ax
	mov	cx,hRes 	; if hRes == NULL, we need to allocate.
	jcxz	@F
	cCall	GlobalHandle,<cx>
	or	dx,dx		; Nothing to do for allocated resources
	jnz	drhx
@@:
if ROM
	mov	es,si
	mov	bx, hResInfo
	test	es:[bx].rn_flags, RNINROM or RNCOMPR
	jz	drh_file
	cCall	DefROMResHandler,<si,hResInfo>
	jmps	drhx
drh_file:
endif
	SetKernelDS
	mov	ax, Win_PDB	; Save current PDB
	mov	SavePDB, ax
	mov	ax, 1
	cCall	InternalAccessResource,<si,hResInfo,ax>
	mov	di,ax
	inc	ax
	jz	drhx
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
	cCall	ResAlloc,<si,hResInfo,di,di, 0, 0>
else
	cCall	ResAlloc,<si,hResInfo,di,di>
endif
	push	ax
;;;	cCall	_lclose,<di>
	push	bx
	cCall	CloseCachedFileHandle,<di>
	mov	bx, SavePDB
	mov	Win_PDB, bx	; Restore PDB
	pop	bx
	pop	ax
drhx:
cEnd

if ROM

cProc	DefROMResHandler,<PUBLIC,NEAR>
	parmW	hExe
	parmW   hResInfo
	localW	selTemp
cBegin
	cCall	FindROMModule,<hExe>	; allocates a selector to ROM EXE header
	mov	selTemp,ax		;   returns 0 if not in ROM
	inc	ax
	jz	@F
	dec	ax
	jz	@F
@@:
	jmp	short drr_gotsel
if KDEBUG				;shouldn't happen except out of sels...
	int	3			;*******************************
endif
	jmp	drrx

drr_gotsel:
	mov	es, hExe
	mov	si,hResInfo
	mov	bx,es:[ne_rsrctab]
	mov	cx,es:[bx].rs_align
	mov	ax,es:[si].rn_offset
	xor	bx,bx
@@:	shl	ax,1
	rcl	bx,1
	loop	@b
	mov	cx,ax			; bx:cx = offset of resource from hdr

	cCall	GetSelectorBase,<selTemp>
	add	ax,cx
	adc	dx,bx			; dx:ax = lma of resource

	if1
	%out	Doesn't work if resource > 64k!
	endif

	cCall	SetSelectorBase,<selTemp,dx,ax>

	; Pure uncompressed resources can be used as is in ROM.

	mov	es,hExe
	test	byte ptr es:[si].rn_flags+1,(RNCOMPR SHR 8)
	jnz	res_to_ram
	test	byte ptr es:[si].rn_flags,RNPURE
	jz	res_to_ram

	mov	si,hResInfo			; set selector limit for
	mov	bx,es:[ne_rsrctab]		;   this resource
	mov	cx,es:[bx].rs_align
	mov	ax,es:[si].rn_length
	xor	bx,bx
@@:	shl	ax,1
	rcl	bx,1
	loop	@b

	sub	ax,1				; limit is len - 1
	sbb	bx,0

	cCall	SetSelectorLimit,<selTemp,bx,ax>

	cCall	SetROMOwner,<selTemp,hExe>	; this EXE owns the resource
	mov	ax,selTemp
	jmps	drrx

res_to_ram:

ifdef WOW_OPTIMIZE_PRELOADRESOURCE
	cCall	ResAlloc,<es,hResInfo,ax,-1, 0, 0>	; has to be loaded into ram...
else
	cCall	ResAlloc,<es,hResInfo,ax,-1>	; has to be loaded into ram...
endif

	push	ax
	cCall	FreeSelector,<selTemp>		; don't need sel in this case
	pop	ax
drrx:
cEnd

endif ;ROM

;-----------------------------------------------------------------------;
; LoadResource								;
; 									;
; Called by each task ONCE to load a resource.				;
; If this is the VERY FIRST time this resource is loaded		;
;   AND it is fixed, then the resource handler proc is called.		;
;   AND it is discardable then only a handle is allocated.  We wait	;
;    until LockResource to actually load the resource.			;
;									;
; If the resource had been loaded by a previous task			;
;  then we load it if it has been discarded.				;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	HANDLE hResInfo							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Tue Jan 01, 1980 07:23:34p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;-----------------------------------------------------------------------;

cProc	ILoadResource,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmW	hResInfo
	localV	DscBuf,DSC_LEN
	localD	lpfn
cBegin
	mov	di,hResInfo		; DI = pName
	or	di,di
	jnz	got_a_hResInfo
	jmp	lr_error_ret
got_a_hResInfo:

	cCall	GetExePtr,<hResFile>
	or	ax,ax
	jnz	got_a_resource_file
	jmp	lr_error_ret
got_a_resource_file:

	mov	ds,ax			; DS = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jnz	got_a_resource_table
	jmp	lr_error_ret
got_a_resource_table:

; If first LoadResource on resource, then call resource handler proc
;  associated with resource type.

	mov	ax,[di].rn_usage
	or	ax,ax
	jz	maybe_load_it
got_it:	inc	[di].rn_usage
	mov	ax,[di].rn_handle
	jmp	lr_ret

; IF
;    1) the resource is discardable
;    2) and has been loaded before
;    3) and has been FreeResource'd
;    4) but not yet discarded (See FreeResource for this madness!)
; THEN
;    1) the usage count is zero
;    2) it's still marked loaded
;    3) it's still in memory 

maybe_load_it:
	cmp	ax,[di].rn_handle	; we know that ax == rn_usage == 0
	jz	not_loaded_before
	test	[di].rn_flags,RNLOADED
	jz	load_it
	cCall	GlobalFlags,<[di].rn_handle>
	test	ah,HE_DISCARDED
	jz	got_it
	jmps	load_it

not_loaded_before:
	test	[di].rn_flags,RNDISCARD
	jz	load_it

; Allocate a zero length object to get a handle.

	push	si
	mov	ax, [di].rn_length
	xor	dx, dx
	mov	bx, ds:ne_rsrctab
	mov	cx, [bx].rs_align
fred:
	shl	ax, 1
	rcl	dx, 1
	loop	fred

	add	ax, 15
	adc	dx, 0
	mov	cx, dx
	inc	cx			; # selectors
if PMODE32
;; WOW x86 only
	cCall	AllocResSelArray,<cx,ds>
	jz	no_sel
else
	push	cx
	cCall	AllocSelectorArray,<cx>
	pop	cx
	or	ax, ax
	jz	no_sel			; got selectors?
	or	al, SEG_RING
	cCall	SetResourceOwner,<ax,ds,cx>
endif; WOW
	StoH	al
no_sel:
	pop	si
	mov	[di].rn_handle,ax
	jmp	got_it
load_it:
	lea	si,[si].SIZE new_rsrc	; DS:SI = pType
lr_type_loop:
	cmp	[si].rt_id,0
	jz	lr_error_ret
	lea	bx,[si].SIZE rsrc_typeinfo	; BX =pName1
	mov	ax,word ptr [si].rt_proc[0]
	or	ax,word ptr [si].rt_proc[2]
	jz	lr_skip_name
	mov	cx,[si].rt_nres
	jcxz	lr_next_type
lr_name_loop:
	cmp	bx,di
	jnz	lr_next_name

	push	ds		; Zap segment registers to prevent

	mov	ax,word ptr [si].rt_proc
	mov	word ptr lpfn,ax
	mov	ax,word ptr [si].rt_proc+2
	mov	word ptr lpfn+2,ax

	push	[di].rn_handle
	push	hResFile
	push	hResInfo

	mov	ax,ss		; callee from trashing our DS.
	mov	ds,ax
	mov	es,ax

	call	lpfn

	pop	ds

	or	ax,ax
	jz	lr_ret
	mov	[di].rn_handle,ax
	or	[di].rn_flags,RNLOADED
	jmp	got_it

lr_next_name:
	add	bx,SIZE rsrc_nameinfo
	loop	lr_name_loop
	jmps	lr_next_type

lr_skip_name:
	mov	ax,[si].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	bx,ax

lr_next_type:
	mov	si,bx
	jmp	lr_type_loop


lr_error_ret:
if KDEBUG
	xor	bx,bx
	kerror	ERR_BADRESFILE,<Error loading from resource file - >,ds,bx
endif
	xor	ax,ax
lr_ret:

cEnd

sEnd	CODE


sBegin	MISCCODE
assumes CS,MISCCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MISCMapDStoDATA

cProc	GetResOrd,<PUBLIC,NEAR>,<si,di>
	parmW	hResFile
	parmD	lpszType
        parmD   lpszName
        localW  hRes
cBegin
	cCall	OrdinalOrString, <lpszType>
        mov	si,ax
	cCall	OrdinalOrString, <lpszName>
	mov	di,ax

gro_maybe_search_nametable:
;	
; First see if we need to search the name table at all (if we have ordinals
; already, we don't need to do the search).
;
	xor	ax,ax
        cmp	si,ax
        jz	gro_do_search_nametable
	or	ax,di
        jnz	gro_exit1	; Both are ordinals - just exit
	or	ax,seg_lpszName	; If lpszName is NULL, exit because
	jnz	gro_do_search_nametable ; we have the type ordinal.

gro_exit1:
	jmp	gro_exit

gro_do_search_nametable:
	cCall	GetExePtr,<hResFile>
        mov	es,ax
        mov	bx,es:[ne_rsrctab]
	cmp	bx,es:[ne_restab]
        jz	gro_exit1

	add	bx,SIZE new_rsrc

gro_check_resource_type:
	cmp	es:[bx].rt_id,0
	jz	gro_exit1
	cmp	es:[bx].rt_id,(RT_NAMETABLE OR RSORDID)
	jz	gro_found_resource_table_entry

	mov	cx,es:[bx].rt_nres
	add	bx,SIZE RSRC_TYPEINFO

	; add 12*nres to bx (12*size of resource)

	.errnz	((SIZE RSRC_NAMEINFO) - 12)

	shl	cx,1
	shl	cx,1
	add	bx,cx
	shl	cx,1
	add	bx,cx
	jmps	gro_check_resource_type


gro_found_resource_table_entry:
	add	bx,SIZE RSRC_TYPEINFO
	mov	ax,es:[bx].rn_handle
	or	ax,ax
        jnz	gro_have_handle_nametable

	xor	ax,ax
        mov	dx,1
	mov	bx,RT_NAMETABLE
	cCall	<far ptr IFindResource>,<hResFile,ax,dx,ax,bx>
        or	ax,ax
	jz	gro_exit1

	push	ds		; DS not even really used probably
	cCall	MISCMapDStoDATA ; Hack, need DS pointing to something
	cCall	ILoadResource,<hResFile,ax>    ;  with a handle
	pop	ds
	or	ax,ax
	jnz	gro_have_handle_nametable
gro_exit2:
	jmp	gro_exit

gro_have_handle_nametable:

	mov	hRes,ax
	push	ds		; DS not even really used probably
	cCall	MISCMapDStoDATA ; Hack, need DS pointing to something
	cCall	ILockResource,<ax> ;  with a handle
	pop	ds

	mov	cx,ax
        or	cx,dx
	jcxz	gro_exit2

	mov	es,dx	; es:bx is a pointer to resource
        mov	bx,ax

;
; Now we have a pointer to the resource. Scan through the name table and
; find a match in the table with the passed type/name.
; SI = type ordinal, 0 if string type
; DI = name ordinal, 0 if string name
;
gro_nametable_loop:
	
	or	si,si
        jz	gro_do_type_string_match

	cmp	si,es:[bx].ntbl_idType
        jnz	gro_next_nametable_entry
	jmps	gro_do_name_match

gro_do_type_string_match:

	push	es	; Save pntbl
        push	bx

	lea	ax,es:[bx].ntbl_achTypeName
	push	es
        push	ax
	push	seg_lpszType
        push	off_lpszType
	call	lstrOriginal	; compare against type name

	pop	bx	; Restore pntbl
        pop	es

	or	ax,ax
        jnz	gro_next_nametable_entry

gro_do_name_match:

	or	di,di
        jz	gro_do_name_string_match

        cmp	di,es:[bx].ntbl_idName
        jnz	gro_next_nametable_entry
	jmps	gro_found_nametable_match

gro_do_name_string_match:

	cmp	seg_lpszName, 0
	jne	want_name
        mov	si,es:[bx].ntbl_idType		; Hey man, can't check name!
	jmps	gro_unlock_resource

want_name:
	push	es	; push pntbl for later restoration
        push	bx

	push	es	; push pntbl for later strcmp
        push	bx
	lea	ax,es:[bx].ntbl_achTypeName
	
        push	es
        push	ax
        call	lstrlen	; get string length

	mov	bx,sp	; Adjust pointer on stack to point
	add	ss:[bx],ax	; past first string
        add	word ptr ss:[bx],ntbl_achTypeName + 1
	push	seg_lpszName
        push	off_lpszName
        call	lstrOriginal

	pop	bx
        pop	es

        or	ax,ax
	jz	gro_found_nametable_match

gro_next_nametable_entry:

	add	bx,es:[bx].ntbl_cbEntry
	cmp	es:[bx].ntbl_cbEntry,0
        jnz	gro_nametable_loop        
	jmps	gro_unlock_resource

gro_found_nametable_match:

	mov	ax,es:[bx].ntbl_idType
	test	ax,RSORDID
        jz	gro_try_replace_name
        mov	si,ax

gro_try_replace_name:

	mov	ax,es:[bx].ntbl_idName
        test	ax,RSORDID
        jz	gro_unlock_resource
        mov	di,ax

gro_unlock_resource:

	push	hRes
        call	GlobalUnlock

gro_exit:
	xor	ax,ax
        cwd
	or	ax,si
	jz	gro_test_name_ordinal
	or	ax,RSORDID

gro_test_name_ordinal:
	or	dx,di
        jz	gro_leave
	or	dx,RSORDID	

gro_leave:
cEnd

cProc OrdinalOrString, <PUBLIC, NEAR>, <si>
	parmD	s
cBegin
	les	si,s
	mov	cx,si
	mov	ax,es
	or	ax,ax
	jz	codone
	xor	cx,cx			; sum = zero
	cld
	lods	byte ptr es:[si]	; c = *pName++
	cmp	al,'#'
	jne	codone
coloop:
	lods	byte ptr es:[si]	; c = *pName++
	or	al,al			; if (!c) break;
	jz	codone
	sub	al,'0'			; if (!isdigit(c))
	cmp	al,9
	ja	codone			;
	xor	ah,ah
	mov	bx,ax			; sum = (sum * 10) + (c - '0')
	mov	al,10
	mul	cx
	add	ax,bx
	mov	cx,ax
	jmp	coloop
codone:
	mov	ax,cx
coexit:
cEnd

cProc	CmpResStr,<PUBLIC,NEAR>,<ds,si>
	parmD pRes
	parmW id
	parmD s
cBegin
	mov	ax,id
	test	ax,RSORDID
	jnz	crsneq
	lds	si,pRes
	add	si,ax
	xor	ax,ax
	cld
	lodsb
	mov	cx,ax
	les	bx,s
crsloop:
	mov	al,es:[bx]
	inc	bx
	or	al,al
	jz	crsneq
	call	FarMyUpper
	mov	ah,al
	lodsb
	cmp	ah,al
	jne	crsneq
	loop	crsloop
	xor	ax,ax
	cmp	es:[bx],al
	jne	crsneq
	not	ax
	jmps	crsexit
crsneq:
	xor	ax,ax
crsexit:
cEnd


;-----------------------------------------------------------------------;
; SetResourceHandler							;
; 									;
; Sets the resource handler for the given type.				;
;									;
; Note that the string pointed to can be the resource ID.  In this	;
; case the string should have the form #ID.				;
;									;
; If the seg of pointer = 0, then the offset is	taken as the ID.	;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	char far *lpszType						;
;	FARPROC lpHandler						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	GetExePtr							;
;	GetResOrd							;
;	CmpResStr							;
;									;
; History:								;
; 									;
;  Tue Jan 01, 1980 04:13:03p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;-----------------------------------------------------------------------;

cProc	ISetResourceHandler,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmD	lpszType
	parmD	lpHandler
cBegin
	cCall	GetExePtr,<hResFile>
	mov	ds,ax			; DS  = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jz	srh_type_not_found	; No resources in this module!

;
; Pass the type string and NULL for the name string. AX = type ordinal, 0
; if it doesn't exist.
;
	push	hResFile
        push	seg_lpszType
        push	off_lpszType
        xor	ax,ax
        push	ax
        push	ax
	call	GetResOrd

	lea	di,[si].SIZE new_rsrc	; DS:DI = pType
srh_type_loop:
	mov	cx,[di].rt_id
	jcxz	srh_type_not_found
	push	ax			; typeord
	or	ax,ax
	jz	srh_compare_string
	cmp	ax,cx
	jz	srh_type_found
	jmps	srh_next_type
srh_compare_string:
	cCall	CmpResStr,<ds,si,cx,lpszType>
	or	ax,ax
	jnz	srh_type_found
srh_next_type:
	mov	ax,[di].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	ax, SIZE rsrc_typeinfo
	add	di,ax
	pop	ax
	jmp	srh_type_loop

srh_type_found:
	pop	ax			; clean stack
	mov	dx,word ptr lpHandler[2]
	mov	ax,word ptr lpHandler[0]
	xchg	dx,word ptr [di].rt_proc[2]
	xchg	ax,word ptr [di].rt_proc[0]
	jmps	srh_ret

srh_type_not_found:
	xor	ax,ax
	xor	dx,dx
srh_ret:

cEnd


;-----------------------------------------------------------------------;
; FindResource								;
; 									;
; Returns a near pointer (into the module database) to the resource	;
; description structure.						;
;									;
; Note that the string pointed to can be the resource ID.  In this	;
; case the string should have the form #ID.				;
;									;
; If the seg of pointer = 0, then the offset is	taken as the ID.	;
;									;
; Arguments:								;
;	HANDLE hResFile							;
;	char far *lpszName						;
;	char far *lpszType						;
; 									;
; Returns:								;
;	AX = near pointer to resource description structure.		;
;									;
; Error Returns:							;
;	AX = 0								;
;									;
; Registers Preserved:							;
;	DI,SI,DS							;
;									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
;									;
; Calls:								;
;	GetExePtr							;
;	GetResOrd							;
;	CmpResStr							;
;									;
; History:								;
; 									;
;  Tue Jan 01, 1980 10:00:15p  -by-  David N. Weise   [davidw]          ;
; ReWrote it from C into assembly and added this nifty comment block.	;
;  Wed May 31, 1989 09:17:00a  -by-  Scott R. Ludwig  [scottlu]		
; Rewrote so that string identifiers map to ordinals through an indirection
; table called a 'name table'. For OS/2 .EXE Compatibility.
;-----------------------------------------------------------------------;

cProc	IFindResource,<PUBLIC,FAR>,<di,si>

	parmW	hResFile
	parmD	lpszName
	parmD	lpszType
	localW	typeord
	localW	nameord
cBegin
	cCall	GetExePtr,<hResFile>
	mov	ds,ax	; DS = pExe
	mov	si,ds:[ne_rsrctab]	; DS:SI = pRes
	cmp	si,ds:[ne_restab]
	jz	fr_error_ret

;
; Get resource ordinals. ax = type ordinal, dx = name ordinal. (0 if not
; ordinals).
;
	cCall	GetResOrd,<hResFile, lpszType, lpszName>
	mov	typeord,ax
        mov	nameord,dx

; First find the resource type.

	lea	di,[si].SIZE new_rsrc	; DS:DI = pType
fr_type_loop:
	mov	cx,[di].rt_id
	jcxz	fr_error_ret
	mov	ax,typeord
	or	ax,ax
	jz	fr_compare_type_string
	cmp	ax,cx
	jz	fr_found_type
	jmps	fr_next_type
fr_compare_type_string:
	cCall	CmpResStr,<ds,si,cx,lpszType>
	or	ax,ax
	jnz	fr_found_type
fr_next_type:
	mov	ax,[di].rt_nres
	mov	cx,SIZE rsrc_nameinfo
	mul	cx
	add	ax,SIZE rsrc_typeinfo
	add	di,ax
	jmp	fr_type_loop
fr_found_type:

; Now find the resource name.

	mov	cx,[di].rt_nres
	lea	di,[di].SIZE rsrc_typeinfo	; DS:DI = pName
fr_name_loop:
	mov	bx,nameord
	or	bx,bx
	mov	ax,[di].rn_id
	jz	fr_compare_name_string
	cmp	ax,bx
	jz	fr_found_name
	jmps	fr_next_name
fr_compare_name_string:
	push	cx
	cCall	CmpResStr,<ds,si,ax,lpszName>
	pop	cx
	or	ax,ax
	jnz	fr_found_name
fr_next_name:
	add	di,SIZE rsrc_nameinfo
	loop	fr_name_loop
fr_error_ret:
	xor	ax,ax
	jmps	fr_ret

fr_found_name:
	mov	ax,di
fr_ret:
cEnd

sEnd MISCCODE


sBegin	NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING


cProc	PreloadResources,<PUBLIC,NEAR>,<si,di>
	parmW   hExe
	parmW   fh
	parmW	hBlock
	parmD	FileOffset
if ROM
	parmW	selROMHdr

	localW	rtid
endif
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        localW  hiResOffset
        localW  loResOffset
endif

cBegin
	mov	es,hExe
	xor	bx,bx
	mov	si,es:[bx].ne_rsrctab
	cmp	es:[bx].ne_restab,si
	jne	prnotdone
prdonej:
	jmp	prdone
ife ROM
prnextj:
	jmp	prnext
endif

prnotdone:
	mov	di,es:[si].rs_align
	add	si,SIZE new_rsrc
prtype:
	cmp	es:[si].rt_id,0
	je	prdonej
	mov	cx,es:[si].rt_nres
	mov	word ptr es:[si].rt_proc[0],codeOffset DefaultResourceHandler
	mov	word ptr es:[si].rt_proc[2],codeBase
if ROM
	mov	ax, es:[si].rt_id
	mov	rtid, ax
endif
	add	si,SIZE rsrc_typeinfo
prname:
	push	cx
	mov	ax,es:[si].rn_flags
;	cmp	word ptr es:[ne_ver],4	; Produced by version 4.0 LINK?
;	ja	prname2
;	test	ah,0Fh			; Is old discard field set?
;	jz	prname1
;	or	ax,RNDISCARD		; Yes, convert to bit
;prname1:
;	and	ax,not RNUNUSED		; Clear unused bits in 4.0 LINK files
prname2:
	or	ax,NENOTP
	errnz	<NENOTP - 8000h>
	test	es:[ne_flags],NENOTP
	jnz	prname4			; Mark as EMSable if resource belongs
	xor	ax,NENOTP		;  to a task.
prname4:
if ROM
	;   don't preload yet if ROM, but make sure that if its a patch
	;   file using a resource in ROM, the resource table gets patched...
	;

	test	es:[si].rn_flags, RNINROM or RNCOMPR
	jz	PL_not_rom_res

	cmp	selROMHdr, 0
	jz	PL_no_patch

	mov	ax, es:[si].rn_id
	push	es
	mov	es, selROMHdr

	mov	bx, es:[ne_rsrctab]
	add	bx, size NEW_RSRC
PL_patch_loop1:
	cmp	es:[bx].rt_id, 0
	jz	PL_patch_fubar
	mov	cx, es:[bx].rt_nres
	mov	dx, es:[bx].rt_id
	add	bx, size RSRC_TYPEINFO
	cmp	dx, rtid
	jz	PL_right_type
	.errnz	size RSRC_NAMEINFO - 12
	shl	cx, 2
	add	bx, cx		; nres*4
	shl	cx, 1
	add	bx, cx		; + nres*8 = nres*12
	jmp	short PL_patch_loop1
PL_right_type:
PL_patch_loop2:
	cmp	es:[bx].rn_id, ax
	jz	PL_patch_foundit
	add	bx, size RSRC_NAMEINFO
	loop	PL_patch_loop2

PL_patch_fubar:
if KDEBUG
	int	3
endif
	sub	dx, dx
	sub	ax, ax
	jmp	short PL_patch_resource

PL_patch_foundit:
	mov	ax, es:[bx].rn_flags
	mov	dx, es:[bx].rn_offset

PL_patch_resource:
	pop	es
	mov	es:[si].rn_offset, dx
	mov	es:[si].rn_flags, ax

PL_no_patch:
prnextj:
	jmp	prnext
PL_not_rom_res:
endif
	mov	es:[si].rn_flags,ax
	test	al,RNPRELOAD
	jz	prnextj

	mov	cx, seg_FileOffset
	or	cx, off_FileOffset
	jcxz	PL_file

	cmp	di, 4			; Must be at least paragraph aligned
	jb	PL_file

	push	es
	cCall	GlobalLock,<hBlock>
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        mov     ax,dx          ; no need to alloc a selector. we will use the
                               ; the current one.
if KDEBUG                      
        or      ax, ax
        jnz     @F
        int     3 ;           // should never happen
@@:
endif

else
	cCall	AllocSelector,<dx>
endif
       
	pop	es
	mov	bx,es:[si].rn_offset
	xor	dx,dx
	mov	cx,di
PL_shift:
	shl	bx,1
	rcl	dx,1
	loop	PL_shift

	sub	bx, off_FileOffset
	sbb	dx, seg_FileOffset
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
        ; call to longptraddwow basically is a nop. it doesn't set the 
        ; descriptor. it is called 'cause it sets some registers.

        mov     hiResOffset, dx
        mov     loResOffset, bx
	push	ax
	push	es
	cCall	LongPtrAddWOW,<ax,cx,dx,bx, 0, 0>	; (cx is 0)
	pop	es
	dec	cx
	cCall	ResAlloc,<essi,dx,cx, hiResOffset, loResOffset>
	pop	cx
	push	ax
else
	push	ax
	push	es
	cCall	LongPtrAdd,<ax,cx,dx,bx>	; (cx is 0)
	pop	es
	dec	cx
	cCall	ResAlloc,<essi,dx,cx, 0, 0>
	pop	cx
	push	ax
	cCall	FreeSelector,<cx>
endif
	cCall	GlobalUnlock,<hBlock>
	pop	ax
	jmps	PL_loaded

PL_file:
	mov	dx,es:[si].rn_offset
	xor	ax,ax
	mov	cx,di
PL_shift1:
	shl	dx,1
	rcl	ax,1
	loop	PL_shift1
	mov	cx,ax
	mov	ax,4200h
	mov	bx,fh
	DOSFCALL
ifdef WOW_OPTIMIZE_PRELOADRESOURCE
	cCall	ResAlloc,<essi,bx,bx, 0, 0>
else
	cCall	ResAlloc,<essi,bx,bx>
endif

PL_loaded:
	mov	es,hExe
	mov	es:[si].rn_handle,ax
prnext:
	pop	cx
	add	si,SIZE rsrc_nameinfo
	dec	cx
	jz	prtypej
	jmp	prname
prtypej:
	jmp	prtype
prdone:
cEnd

sEnd	NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\reboot.asm ===
;***************************************************************************
;*  REBOOT.ASM
;*
;*      Contains routines used to support a local reboot in the Sys
;*      VM.  To do this, we interact with USER and the Reboot VxD.
;*
;*      This functionality is only present in the 386 KERNEL.
;*
;*      The KRebootInit function is called just after USER is loaded.
;*
;*      The Reboot VxD calls the local reboot proc to terminate an app.
;*      The local reboot proc may fail and cause the VxD to trace until
;*      it is able to kill the task.  See comments in the local reboot
;*      proc for more details.
;*
;*      This code must be located in KERNEL due to the internal KERNEL
;*      information it must access.
;*
;*      Created by JonT starting 12 July 1991
;*
;***************************************************************************

	TITLE	REBOOT - Local Reboot Routines

.xlist
include kernel.inc
include tdb.inc
include protect.inc
include newexe.inc
.list

.386p

MAX_TRACE       EQU     5000h

HookInt1 MACRO
        mov     ax,0204h                ;;Tell VxD to hook/unhook Int 1
        mov     cx,cs                   ;;Point to ISR
        mov     dx,codeOFFSET TraceOut
        movzx   edx,dx
        call    [lpReboot]              ;;Call the VxD API
ENDM

UnhookInt1 MACRO
        mov     ax,0204h                ;;Tell VxD to hook/unhook Int 1
        xor     cx,cx                   ;;Pass a zero in CX to unhook
        call    [lpReboot]              ;;Call the VxD API
ENDM

DataBegin

externD lpReboot
externW curTDB
externW hExeHead
externW hUser
externB Kernel_Flags
externB fTaskSwitchCalled
externW wMyOpenFileReent
externB OutBuf
externW pGlobalHeap

EVEN
globalW wLastSeg, 0
globalW wTraceCount, 0
lpOldInt1       DD      0
szUser          DB      'USER'

DataEnd

externFP Int21Handler
externFP GetPrivateProfileInt
IFDEF FE_SB
externFP FarMyIsDBCSLeadByte
ENDIF

;** Note that this goes in the fixed code segment
sBegin	CODE
assumes CS,CODE

;  KRebootInit
;       Initializes the KERNEL Local Reboot functionality and talks with
;       the Reboot VxD.

cProc   KRebootInit, <FAR,PUBLIC>, <si,di,ds>
cBegin
        SetKernelDS

        ;** Get the reboot device entry point if it exists
        xor     di,di                   ;Get a NULL pointer
        mov     es,di                   ;  in case there's no reboot device
        mov     bx,0009h            
        mov     ax,1684h                ;Get device entry point
        int     2fh
        mov     ax,es
        or      ax,di
        jz      SHORT RI_NoRebootDev
        mov     WORD PTR lpReboot[0],di
        mov     WORD PTR lpReboot[2],es

        ;** Set the reboot device call back
        mov     ax, 0201h               ;Reboot VxD #201:  Set callback addr
        mov     di,cs
        mov     es,di
        lea     di,KRebootProc
        lea     si, fTaskSwitchCalled   ;DS:SI points to task switch flag
        call    [lpReboot]

RI_NoRebootDev:

cEnd


;  LocalRebootProc
;
;       Called by the Reboot VxD to cause the current Windows app to be
;       terminated.

cProc   KRebootProc, <FAR,PUBLIC>
cBegin  nogen

        ;** Save all the registers so we can restart if necessary
        pusha                           ;16 bytes
        push    ds                      ;2 bytes
        push    es                      ;2 bytes
        SetKernelDS
        mov     bp,sp                   ;Point with BP

        ;** If the KERNEL debugger is installed, DON'T trace!
	test	Kernel_Flags[2],KF2_SYMDEB ;Debugger installed
IF KDEBUG
        jz      SHORT RP_CheckSeg       ;No debugger, try to trace
        Trace_Out <'LocalReboot:  Debugger installed, nuking app without tracing'>
	jmp	SHORT RP_NukeIt         ;Just try to nuke it here!
ELSE
	jnz	SHORT RP_NukeIt         ;Just try to nuke it here!
ENDIF

        ;** Get the code segment we were executing in
RP_CheckSeg:
        mov     ax,[bp + 22]            ;Get CS from stack (IRET frame)

        ;** See if the owner of the code segment was loaded before USER
        cCall   IsBootSeg               ;Returns TRUE if owned by boot mod
        or      ax,ax                   ;Ok to nuke?
        jnz     RP_TraceOut             ;No, must trace out

RP_NukeIt:

        ;** First, we need to get the filename of the .EXE we're about to
        ;**     nuke.  We do this by getting the name out of the module
        ;**     database.  Module databases are not page locked and also
        ;**     have the fully qualified pathname.  So, we copy just the
        ;**     module name into a buffer in our pagelocked data segment
        cld
        push    ds
        pop     es
        mov     di, dataOFFSET OutBuf   ;Point to start of buffer
        mov     ds, curTDB              ;Get the current TDB
        UnSetKernelDS
        mov     ds, ds:[TDB_pModule]    ;Point to the module database
        mov     si, WORD PTR ds:[ne_crc + 2] ;Points to length byte of module EXE
        mov     cl, [si]                ;Get length byte
        xor     ch, ch
        sub     cl, 8                   ;8 bytes of garbage
        add     si, 8
        mov     bx, si                  ;In case we don't find a slash (bad)
RP_SlashLoop:
        lodsb                           ;Get this char
IFDEF FE_SB
        call    FarMyIsDBCSLeadByte
        jc      SHORT RP_NoDBCSChar
        lodsb
        dec     cx
        jmp     SHORT RP_NoSlash        ;It is, can't be a slash
RP_NoDBCSChar:
ENDIF
        cmp     al, '\'                 ;Is this a slash?
        je      SHORT RP_Slash          ;Yes
        cmp     al, '/'
        jne     SHORT RP_NoSlash
RP_Slash:
        mov     bx, si                  ;BX points after last slash
RP_NoSlash:
        loop    RP_SlashLoop
        mov     cx, si                  ;Compute count of characters in 8.3 name
        sub     cx, bx
        mov     si, bx                  ;Point to 8.3 name
        rep     movsb                   ;Copy the string into OutBuf
        xor     al, al                  ;Zero byte
        stosb

        ;** Call the VxD to put up the app name
        push    es                      ;ES points to kernel DS
        pop     ds
        ReSetKernelDS
        mov     di, dataOFFSET OutBuf   ;Point to module name with ES:DI
        mov     ax, 203h                ;Display message through VxD
        call    [lpReboot]
        or      ax, ax                  ;If non-zero, we nuke it
        jz      SHORT RP_NoNuke

IF KDEBUG
        krDebugOut DEB_WARN, <'LocalReboot:  Trying to nuke @ES:DI'>
ENDIF

        ;** Clean out some static info
        mov     wMyOpenFileReent, 0     ;Clear reentrant flag for MyOpenFile

        ;** Call USER's signal proc for the task
        mov     es,curTDB               ;Get the current TDB
        cmp     WORD PTR es:[TDB_USignalProc] + 2,0 ;USER signal proc?
        jz      SHORT @F                ;No
        mov     bx,0666h                ;Death knell
        mov     di,-1
        cCall   es:[TDB_USignalProc],<es,bx,di,es:[TDB_Module],es:[TDB_Queue]>
@@:

        ;** Nuke the app.  Does not return
        mov     ax,4c00h
        DOSCALL

        ;** We're somewhere in a boot module.  Try to trace out by telling
        ;**      VxD to do another instruction
RP_TraceOut:
        mov     ax,[bp + 22]            ;Get CS from stack (IRET frame)
IF KDEBUG
        krDebugOut DEB_WARN, <'LocalReboot:  Tracing out of boot module %AX2'>
ENDIF
        mov     wLastSeg,ax             ;Save for next time
        mov     wTraceCount,0           ;Clear the trace count
        HookInt1

        ;** Set the trace flag
        or      WORD PTR [bp + 24],0100h
        jmp     SHORT RP_SetFlag
        
        ;** Force the trap flag clear on the no nuke case
RP_NoNuke:
        and     WORD PTR [bp + 24],NOT 0100h
        
RP_SetFlag:
        pop     es
        pop     ds
        popa
        STIRET                          ;VxD calls as an interrupt
cEnd    nogen


;  TraceOut
;
;       This routine continues to trace until it traces out of a boot module
;       or until the trace count is up.  If it needs to nuke the app,
;       it jumps to RP_NukeIt which depends only on DS being set.  This
;       call returns via an IRET since it is called as an INT 1 handler.

cProc   TraceOut, <FAR,PUBLIC>
cBegin  nogen

        ;** Save all the registers so we can restart if necessary
        pusha                           ;16 bytes
        push    ds                      ;2 bytes
        push    es                      ;2 bytes
        SetKernelDS
        mov     bp,sp                   ;Point with BP

        ;** We keep tracing forever if the heap is locked
        push    es
	mov	es, pGlobalHeap         ;Point to GlobalInfo structure
	cmp     es:[gi_lrulock], 0      ;Is the global heap busy
        pop     es
        jne     SHORT TO_10             ;Force the trace out
        
        ;** See if the CS is the same as last time
        inc     wTraceCount             ;Bump the count
        cmp     wTraceCount,MAX_TRACE   ;Too many instructions?
IF KDEBUG
        jb      SHORT TO_10             ;Count not exceeded
        mov     cx,MAX_TRACE            ;Get trace count
        Trace_Out <'LocalReboot:  Trace count (#CXh instructions) exceeded'>
        jmp     SHORT TO_Reboot
ELSE
        jae     SHORT TO_Reboot         ;Yes, too many, nuke it
ENDIF

TO_10:  mov     ax,[bp + 22]            ;Get the CS from the IRET frame
        cmp     ax,wLastSeg             ;Same as last time?
        je      SHORT TO_StillBad       ;Yes, don't bother looking up
        mov     wLastSeg,ax             ;Save as last executed segment
        mov     bx,cs                   ;Get our CS
        cmp     ax,bx                   ;Our segment?
        je      SHORT TO_StillBad       ;Yes, can't nuke here!
        cCall   IsBootSeg               ;Returns TRUE if owned by boot mod
        or      ax,ax                   ;Ok to nuke?
        jnz     SHORT TO_StillBad       ;No, must continue tracing
IF KDEBUG
        mov     cx,wTraceCount          ;Get trace count
        Trace_Out <'LocalReboot:  Traced out after #CXh instructions'>
ENDIF

        ;** Unhook the interrupt handler and kill the app now
TO_Reboot:
        UnhookInt1
        jmp     RP_NukeIt               ;Try to nuke the app

        ;** Restore the registers and restart
TO_StillBad:
        or      WORD PTR [bp + 24],0100h ;Set the trace flag
        pop     es
        pop     ds
        popa
        iret                            ;VxD calls as an interrupt

cEnd    nogen


;  IsBootSeg
;
;       Tries to find a code segment somewhere in the initial segments
;       loaded before USER.  The CS value is passed in AX.  Returns
;       TRUE iff the CS was found in a boot module.

cProc   IsBootSeg, <NEAR,PUBLIC>
cBegin  nogen
        SetKernelDS
        mov     dx,ax                   ;Put CS in DX for call
        mov     es,hExeHead             ;Get the first module on chain

IBS_Loop:
        cCall   IsModuleOwner           ;See if we can find the owner
        or      ax,ax                   ;Found?
        jnz     SHORT IBS_End           ;Yes, return TRUE
        mov     ax,es                   ;Get the module handle
        cmp     ax,hUser                ;If we just tried USER, we're done
        je      SHORT IBS_NotFound      ;Not found
        mov     es,es:[6]               ;Nope, get next module to try
        jmp     IBS_Loop

IBS_NotFound:
        xor     ax,ax                   ;Return FALSE

IBS_End:
cEnd


;  IsModuleOwner
;
;       Checks in the EXE header to see if the given segment is in this
;       module.
;       DX is the segment, ES points to the module database
;       Returns TRUE/FALSE in AX.  Doesn't trash DX.

cProc   IsModuleOwner, <NEAR,PUBLIC>
cBegin  nogen
        xor     ax,ax                   ;Get a FALSE just in case
        mov     cx,es:[ne_cseg]         ;Get max number of segments
        jcxz    SHORT IMO_End           ;No segments
        mov     di,es:[ne_segtab]       ;Point to the segment table
IMO_SegLoop:
        cmp     dx,es:[di].ns_handle    ;Is this the correct segment entry?
        jz      SHORT IMO_FoundIt       ;Yes, get out
        add     di,SIZE new_seg1        ;Bump to next entry
        loop    IMO_SegLoop             ;Loop back to check next entry
        jmp     SHORT IMO_End           ;Didn't find it

IMO_FoundIt:
        mov     ax,1                    ;Return that we found it here

IMO_End:

cEnd

sEnd

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\rom.asm ===
PAGE	,132
	TITLE	ROM - Kernel ROM specific code

.xlist
include kernel.inc
include protect.inc
include pdb.inc
.list

if ROM	;----------------------------------------------------------------

;------------------------------------------------------------------------
;  Local Macros & Equates
;------------------------------------------------------------------------

DPMICALL MACRO	callno
	ifnb	<callno>
	mov	ax,callno
	endif
	int	31h
	ENDM

GA_ALIGN_BYTES = (((GA_ALIGN+1) SHL 4) - 1)
GA_MASK_BYTES = NOT GA_ALIGN_BYTES


;------------------------------------------------------------------------
;  External Routines
;------------------------------------------------------------------------

externFP LZDecode

;------------------------------------------------------------------------
;  Data Segment Variables
;------------------------------------------------------------------------

DataBegin

if PMODE32
externW gdtdsc
externB MS_DOS_Name_String
endif

externW MyDSSeg
externW WinFlags
externD linHiROM
externD lmaHiROM

DataEnd


;------------------------------------------------------------------------
;  INITDATA Variables
;------------------------------------------------------------------------

DataBegin INIT

DataEnd INIT


;------------------------------------------------------------------------


sBegin	INITCODE
assumes cs,CODE


;-----------------------------------------------------------------------;
; ROMInit								;
;									;
; Performs ROM specific initialization. 				;
;									;
; Arguments:								;
;	DS = ES = SS = selector to conventional RAM mem block & PSP	;
;		       for kernel use.					;
;	SP = offset in conventional RAM block				;
;	SS:SP = [near ret to ldboot] [far ret to invoker]		;
;	CX:DX = linear address of hi rom (as opposed to physical)	;
;		set by DOSX or the fake KRNL386 which enh exec's        ;
;									;
; Returns:								;
;	BX   = 0							;
;	DS:0 = Kernel's RAM Data segment                                ;
;	ES:0 = Kernel's PSP                                             ;
;									;
; Regs Used:								;
;	AX, CX, DX, DI							;
;									;
;									;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing
	assumes ss,nothing


cProc	ROMInit,<PUBLIC,NEAR>,<es>
	localW	selNewDS
	localW	selBaseMem
	localD	lpProc
if PMODE32
	localD	romhilinear
	localD	 linDOSBlock
	localD	 cbDOSBlock
endif
cBegin
if PMODE32
	mov	word ptr romhilinear[0], dx
	mov	word ptr romhilinear[2], cx
endif

; On entry we do not have a RAM copy of our data segment, set up a
; selector for on in the conventional memory block.  This will become
; the first block in the global heap...

	mov	cx,1			;allocate 1 selector to use for DS
	DPMICall 0000h
;;;	jc	RIFailed		; worry about this?

	mov	selNewDS,ax		;save new selector

	DPMICall 0000h			;and another for base memory ptr
;;;	jc	RIFailed		; worry about this?

	mov	selBaseMem,ax

	mov	bx,ds			;get base of conventional memory blk
	DPMICall 0006h			;  and PSP

if PMODE32
	mov	word ptr linDOSBlock[0], dx
	mov	word ptr linDOSBlock[2], cx
endif

	add	dx,100h+GA_ALIGN_BYTES	;point selBaseMem past PSP and
	adc	cx,0			;  align for initial heap sentinal
	and	dl,GA_MASK_BYTES
	mov	bx,selBaseMem
	DPMICall 0007h

ife PMODE32
	add	dx,10h+GA_ALIGN_BYTES	;align DS selector and leave room
	adc	cx,0			;  for heap sentinel & arena
	and	dl,GA_MASK_BYTES	;  (where DS arena goes)
	add	dx,10h
	adc	cx,0			;  (where DS goes)
endif

	push	cx			;save RAM DS base on stack
	push	dx

	mov	bx,selNewDS		;set base of new DS selector
	DPMICall 0007h

	xor	cx,cx			;set limit of new DS selector
	xor	dx,dx			;  to 64k for now
	dec	dx
	DPMICall 0008h


	xor	ax,ax
	mov	si,seg _DATA
	mov	dx,0E000h		;ASSUMES kernel ds < E000 & uncompress
					;  buffer < 2000 bytes
	push	es
	cCall	LZDecode,<bx,si,bx,dx>	; uncompress our DS
	pop	es

	mov	dx,ax			;ax = # expanded bytes, make this
	dec	dx			;  the new limit for selNewDS
	xor	cx,cx
	mov	bx,selNewDS
	DPMICall 0008h

	mov	ds,bx
	ReSetKernelDS


; Update the original data selector to point to the RAM copy

	mov	bx,seg _DATA		;orig DS selector
	pop	dx			;base of RAM data seg
	pop	cx
	DPMICall 0007h

	push	cx
	push	dx
	mov	cx,ds
	lsl	dx,cx			;increase limit of DS selector
	add	dx,ROMEXTRASTACKSZ	;  to include extra stack space
	xor	cx,cx
	DPMICall 0008h

	mov	cl,DSC_PRESENT OR DSC_DATA	; and make sure it's writable
	DPMICall 0009h

	pop	dx
	pop	cx

	mov	ds,bx			;use orig DS selector and free temp
	ReSetKernelDS

	mov	bx,selNewDS
	DPMICall 0001h

	mov	bx,cx			;convert RAM DS base to segment & save
	mov	cx,4
@@:	shr	bx,1
	rcr	dx,1
	loop	@b

	mov	MyDSSeg,dx

if PMODE32
.386p
	; now that we're looking at our ds, set the linear address of the
	; high ROM
	mov	eax, romhilinear
	or	eax, eax
	jnz	@F
	mov	eax, lmaHiROM
@@:	mov	linHiROM, eax
endif

; Set WinFlags to have the CPU type

	DPMICall 0400h			;returns CPU type in CL

	mov	ax,WF_CPU286
	cmp	cl,2
	jbe	@f
	mov	al,WF_CPU386
	cmp	cl,3
	je	@f
	mov	al,WF_CPU486
@@:
	mov	WinFlags,ax

if PMODE32
	push	es
	mov	ax, 168Ah		; See if we have MS-DOS extensions
	mov	si, dataoffset MS_DOS_Name_String
	int	2Fh			; DS:SI -> MS-DOS string
	cmp	al, 8Ah			; Have extensions?
	je	short NoLDTParty	;  no extensions, screwed
			 
	mov	word ptr [lpProc][0], di	 ; Save CallBack address
	mov	word ptr [lpProc][2], es
	
	mov	ax, 0100h		; Get base of LDT
	call	[lpProc]
	jc	short NoLDTParty
	verw	ax			; Writeable?
	jnz	short NoLDTParty	;  nope, don't bother with it yet

	mov	gdtdsc, ax

NoLDTParty:		  
	pop	es

	;; now page-unlock the DOS block
	;;
	mov	bx, es:[PDB_Block_Len]
	DPMICALL    0006h
	mov	si, cx
	mov	di, dx
	mov	cx, word ptr linDOSBlock[0]
	mov	bx, word ptr linDOSBlock[2]
	sub	di, cx
	sbb	si, bx
	DPMICALL    0602h
endif
	
	xor	bx,bx			;return 0 in BX (for LDT_Init)
	mov	si,selBaseMem		;return selector to memory base in SI

cEnd

sEnd	INITCODE

endif	;ROM	---------------------------------------------------------

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\stack.asm ===
TITLE	STACK - Kernel stack switching code


include kernel.inc
ifdef WOW
include vint.inc
endif


;------------------------------------------------------------------------
;	T M P S T A C K    S E G M E N T   V A R I A B L E S
;------------------------------------------------------------------------

sBegin	DATA
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes SS,NOTHING

	EVEN

if KDEBUG
externW gmove_stack_sig
endif			

externW	gmove_stack

externW	prev_gmove_SP
externW	prev_gmove_SS
externW	ss_sel

sEnd	DATA


;------------------------------------------------------------------------

sBegin	CODE
assumes CS,CODE
assumes SS,NOTHING

	assumes ds,nothing
	assumes es,nothing

cProc	Enter_gmove_stack,<PUBLIC,NEAR>
cBegin	nogen
	mov	ax,ds
	SetKernelDS
	cmp	prev_gmove_SS,0
	jne	gs_fail
    FCLI
	pop	gmove_stack
;;;if PMODE
;;;	mov	ss_sel,ss
;;;endif
	mov	prev_gmove_SS,cx
	mov	prev_gmove_SP,sp
if KDEBUG
	mov	gmove_stack_sig,STACK_SIGNATURE
endif
	smov	ss,ds
	mov	sp,dataOffset gmove_stack
    FSTI
	mov	ds,ax
	ret
cEnd	nogen

gs_fail:
	kerror	ERR_GMEM,<gmove_stack usage error>,prev_gmove_SS,prev_gmove_SP
	jmp	gs_fail

	assumes ds,nothing
	assumes es,nothing

cProc	Leave_gmove_stack,<PUBLIC,NEAR>
cBegin	nogen
	mov	ax,ds
	SetKernelDS
	cmp	prev_gmove_SS,0
	je	gs_fail
if KDEBUG
	push	ax
	push	cx
	push	es
	push	di
	lea	di, gmove_stack_sig
	smov	es, ss
	mov	ax, STACK_SIGNATURE
	mov	cx, 16
	cld
	repe	scasw
	pop	di
	pop	es
	pop	cx
	pop	ax
	jne	gs_fail
	cmp	sp,dataOffset gmove_stack
	jne	gs_fail
endif

;;;if PMODE
;;;externNP get_physical_address
;;;externNP set_physical_address
;;;	push	ax
;;;	push	dx
;;;	cCall	get_physical_address,<prev_gmove_SS>
;;;	cCall	set_physical_address,<ss_sel>
;;;	pop	dx
;;;	pop	ax
;;;  FCLI
;;;	mov	ss,ss_sel
;;;else

    FCLI
	mov	ss,prev_gmove_SS
;;;endif
	mov	sp,prev_gmove_SP
	push	gmove_stack
	mov	prev_gmove_SS,0
    FSTI
	mov	ds,ax
	ret
cEnd	nogen

sEND	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\task.asm ===
page	,132
	title	TASK - task create/destroy procedures
.xlist
include kernel.inc
include tdb.inc
include pdb.inc
include eems.inc
include newexe.inc
include dbgsvc.inc
include bop.inc
.list

outd	macro	msg,n
%out msg n
endm
if2
; outd <TDBsize =>,%TDBsize
endif

externW pStackBot
externW pStackMin
externW pStackTop

if ROM
externFP FarIsROMObject
endif

externFP SafeCall
externFP BuildPDB
externFP LockSegment
externFP UnlockSegment
;externFP Yield
externFP LocalInit
externFP GlobalAlloc
externFP GlobalFree
;externFP GlobalLock
externFP GlobalUnLock
externFP GlobalCompact
externFP IGlobalHandle
externFP GlobalLRUOldest
externFP AllocDStoCSAlias
;;;externFP FarMyLock
externFP FarSetOwner
externFP default_sig_handler
externFP CVW_Hack
externFP GlobalDOSAlloc
externFP GlobalDOSFree
externFP AllocSelector
externFP LongPtrAdd
externFP MyFarDebugCall
externFP Int21Handler
if PMODE32
externFP far_get_arena_pointer32
externFP FarAssociateSelector32
externFP KRebootInit
else
externFP far_get_arena_pointer
externFP FarAssociateSelector
endif

if KDEBUG
externFP SetupAllocBreak
endif

ifdef WOW
externFP SetAppCompatFlags
externFP WowReserveHtask
externFP FreeSelector
externFP WowPassEnvironment
externFP ExitCall
endif

DataBegin

;externB fEMM
externB fBooting
externB kernel_flags
externB num_tasks
;externW hexehead
externW pGlobalHeap
externW curTDB
externW loadTDB
externW headTDB
externW headPDB
externW topPDB
externW cur_DOS_PDB
externW Win_PDB
;if PMODE32
;externW ArenaSel
;endif
externW MyCSAlias
externD pUserInitDone
externD ptrace_app_entry
externD ptrace_DLL_entry
externD pSignalProc

if KDEBUG
globalW allocTask,0
globalD allocCount,0
globalD allocBreak,0
globalB allocModName,0,8
endif   ;KDEBUG

if ROM
externD prevInt00proc
endif

ifdef WOW
externD FastBop
externW DebugWOW
endif

DataEnd

sBegin	CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

ife ROM
externD prevInt00proc
endif

externNP SaveState
externNP UnlinkObject
externNP genter
externNP gleave

nullcomline	DB  0,0Dh

;-----------------------------------------------------------------------;
; GetCurrentTask							;
; 									;
; Returns the current task.						;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	AX = curTDB							;
;	DX = headTDB							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 07:45:40p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetCurrentTask,<PUBLIC,FAR>
cBegin	nogen
	push	es
	SetKernelDS ES
	mov	ax,curTDB
	mov	dx,headTDB
;	 mov	 bx,codeOffset headTDB
;	 mov	 cx,codeOffset curTDB
	pop	es
	ret
	assumes es,nothing
cEnd	nogen


;-----------------------------------------------------------------------;
; InsertTask								;
; 									;
; Inserts a task into the task list.					;
; 									;
; Arguments:								;
;	parmW	hTask							;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,DI,SI,DS							;
; 									;
; Registers Destroyed:							;
; 	AX,BX,ES							;
;									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 09:41:24p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InsertTask,<PUBLIC,NEAR>,<ds>
	parmW	hTask
cBegin
	mov	es,hTask		; get task handle
	SetKernelDS
	mov	ax,headTDB		; get head of task list
	UnSetKernelDS
	or	ax,ax			; anybody here?
	jz	ins1			; no, just do trivial case

ins0:	mov	ds,ax			; point to head TDB
	mov	bl,es:[TDB_priority]	; get insert priority
	cmp	bl,ds:[TDB_priority]	; is it less than head task?
	jg	ins2			; no, insert elsewhere
	mov	es:[TDB_next],ax
ins1:	SetKernelDS
	mov	headTDB,es
	UnSetKernelDS
	jmps	ins4

ins2:	mov	ds,ax			; save segment of previous TDB
	mov	ax,ds:[TDB_next]	; get segment of next tdb
	or	ax,ax			; if zero, insert now
	jz	ins3
	mov	es,ax			; point to new TDB
	cmp	bl,es:[TDB_priority]
	jg	ins2
ins3:	mov	es,hTask
	mov	ds:[TDB_next],es
	mov	es:[TDB_next],ax
ins4:
cEnd


;-----------------------------------------------------------------------;
; DeleteTask								;
; 									;
; Deletes a task from the task list.					;
; 									;
; Arguments:								;
;	parmW	hTask							;
; 									;
; Returns:								;
;	AX = hTask							;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	UnlinkObject							;
; 									;
; History:								;
; 									;
;  Sun Feb 01, 1987 09:41:24p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	DeleteTask,<PUBLIC,NEAR>
	parmW	hTask
cBegin
	mov	es,hTask
	mov	bx,dataOffset headTDB
	mov	dx,TDB_next
	call	UnlinkObject		; returns AX = hTask
cEnd


cProc	FarCreateTask,<PUBLIC,FAR>	; Called from CreateTask
;	parmW	fPrev			; Calls several 'near' CODE funcs
cBegin
	cCall	SaveState,<ds>
	SetKernelDS	es
	mov	loadTDB,ds
	cCall	InsertTask,<ds>
	clc
cEnd

if KDEBUG

;-----------------------------------------------------------------------
;
; CheckGAllocBreak
;
; Checks to see if the allocation break count has been reached.
; Returns CARRY SET if the allocation should fail, CLEAR otherwise.
; Increments the allocation count.
;
;-----------------------------------------------------------------------

LabelNP <PUBLIC, CheckGAllocBreak>
        errn$   CheckLAllocBreak

cProc   CheckLAllocBreak,<PUBLIC,NEAR>,<DS,AX>
cBegin
	SetKernelDS
assumes ds,DATA

        mov     ax,allocTask        ; if allocTask != curTDB, exit.
        or      ax,ax               ; curTDB may be NULL during boot.
        jz      cab_nofail
        cmp     ax,curTDB
        jnz     cab_nofail

        mov     ax,word ptr allocBreak
        cmp     ax,word ptr allocCount   ; if allocBreak != allocCount
        jnz     cab_increment       ;   inc allocCount
        mov     ax,word ptr allocBreak+2
        cmp     ax,word ptr allocCount+2
        jnz     cab_increment

        or      ax,word ptr allocBreak   ; if allocBreak is 0L, just inc.
        jz      cab_increment

	krDebugOut <DEB_ERROR>, "Alloc break: Failing allocation"

        stc                         ; return carry set
        jmp     short cab_exit

cab_increment:
        inc     word ptr allocCount      ; increment allocCount
        jnz     cab_nofail
        inc     word ptr allocCount+2
cab_nofail:
        clc
cab_exit:
assumes ds,NOTHING
cEnd

endif   ;KDEBUG

sEnd	CODE

sBegin  NRESCODE
assumes CS,NRESCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MapDStoDATA
externNP GetInstance
externNP StartProcAddress

;-----------------------------------------------------------------------;
; CreateTask								;
; 									;
; "Creates" a new task.  It allocates the memory for the TDB+PDB struc,	;
; builds the PDB, constructs the TDB, initializes the EEMS memory	;
; arena, and sets the signature word in the TDB.  TDB actually added	;
; to task queue by StartTask.						;
;									;
; Arguments:								;
;	parmD	pParmBlk						;
;	parmW	pExe							;
;	parmW	hPrev instance						;
;	parmW	fWOA							;
; 									;
; Returns:								;
;	AX = segment of TDB						;
; 									;
; Error Returns:							;
;	AX = 0								;
; 									;
; Registers Preserved:							;
;	DI,SI,DS							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 21:18:25  -by-  David N. Weise  [davidw]		;
; Added support for OS/2 apps.						;
;									;
;  Mon 07-Aug-1989 23:28:15  -by-  David N. Weise  [davidw]		;
; Added support for long command lines to winoldap.			;
;									;
;  Thu Apr 09, 1987 03:53:16p  -by-  David N. Weise   [davidw]		;
; Added the initialization for EMS a while ago, recently added the	;
; switching of stacks to do it.						;
; 									;
;  Sun Feb 01, 1987 07:46:53p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	CreateTask,<PUBLIC,FAR>,<si,di>
	parmD	pParmBlk
	parmW	pExe
;	parmW	fPrev
	parmW	fWOA

	localW	env_seg
	localW	comline_start
cBegin
	call	MapDStoDATA
	ReSetKernelDS
	cld
	xor	si,si
	mov	env_seg,si
	mov	comline_start,si
	cmp	si,pParmBlk.sel
	jz	parm_block_considered
	cCall	pass_environment,<pExe,pParmBlk>
	inc	ax
	jnz	@F
	jmp	ats6
@@:	dec	ax
	mov	env_seg,ax
	mov	comline_start,dx
	mov	si,size PDB		; start with size of PDB
	cmp	fWOA,0
	jz	parm_block_considered
	les	di,pParmBlk
	les	di,es:[di].lpcmdline
	mov	cx,es:[di]
	sub	cx,127			; account for terminating 0Dh
	jbe	parm_block_considered
	add	si,cx
	add	si,15
	and	si,NOT 15
parm_block_considered:
	add	si,TDBsize+15		; Room for task data and paragraph aligned.
;	xor	ax,ax			; Room for EMM save area if needed.
;	mov	al,fEMM
;	add	si,ax
	and	si,0FFF0h
	mov	di,si
	mov	cl,4
	shr	si,cl
ifdef WOW
; We need to ensure task handles are unique across multiple WOW VDMs
; on Windows NT, so that for example the undocumented feature of
; passing a 16-bit htask to Win32 Post(App|Thread)Message instead
; of a thread ID will work reliably with multiple WOW VDMs.
;
; To accomplish this we call WowReserveHtask, which will return
; the htask if the htask (ptdb) was previously unused and has
; been reserved for us.  If it returns 0 another VDM is already
; using that value and so we need to allocate another and try again.
; To avoid risking exhausting low memory, we allocate memory for the
; TDB once using GlobalDOSAlloc, then clone it using AllocSelector.
; We test this cloned selector value using WowReserveHtask, if it
; fails we get another clone until one works.  Then we free all but
; the clone we'll return, and magically swap things around so that
; the cloned selector owns the TDB memory and then free the original
; selector from GlobalDOSAlloc
;

        xor     dx,dx                   ; Make size of allocation a dword
        regptr  xsize,dx,di
        cCall   GlobalDOSAlloc,<xsize>
        or      ax,ax
        jnz     @f
        jmp     ats6                    ; Return zero for failure.

@@:     push    di                      ; save TDB size on stack
        push    ax                      ; save GlobalDOSAlloc selector on stack
        mov     di,ax                   ; and in DI
        cCall   WowReserveHtask,<ax>    ; returns htask or 0
        or      ax,ax                   ; Is this selector value avail as htask?
        jz      MustClone               ; no, start cloning loop
        pop     ax                      ; htask to return
        pop     di                      ; TDB size
        jmps    NoClone
MustClone:
        xor     cx,cx                   ; count of clone selectors
        xor     si,si                   ; no selector to return yet
AnotherHtask:
        push    cx
        cCall   AllocSelector,<di>      ; clone the selector
        pop     cx
        or      ax,ax
        jz      FreeAnyHtasks           ; Out of selectors cleanup and exit
        push    ax                      ; save cloned selector on stack
        inc     cx
        push    cx
        cCall   WowReserveHtask,<ax>    ; returns htask or 0
        pop     cx
        or      ax,ax
        jz      AnotherHtask            ; conflict
        mov     si,ax                   ; SI = selector to return
        pop     bx                      ; pop the selector we're returning
        dec     cx
        jcxz    @f
FreeLoop:
        pop     bx                      ; pop an allocated selector from stack
        push    cx
        cCall   FreeSelector,<bx>
        pop     cx
        dec     cx
FreeAnyHtasks:
        jcxz    @f                      ; have we popped all the allocated selectors? Yes
        jmps    FreeLoop                ; No

@@:     mov     ax,si
        or      si,si
        jnz     @f
        pop     ax                      ; original selector from GlobalDOSAlloc
        cCall   GlobalDOSFree,<ax>
        pop     di
        jmp     ats6

@@:
        ; SI is selector to return, top of stack is original GlobalDOSAlloc
        ; selector.  We need to free the original selector and make the clone
        ; selector "own" the memory so it will be freed properly by GlobalDOSFree
        ; during task cleanup.

        pop     di                              ; DI = original GlobalDOSAlloc selector
        push    ds
        mov     ds, pGlobalHeap
        UnSetKernelDS
        .386
        cCall   far_get_arena_pointer32,<di>
        push    eax
        cCall   FarAssociateSelector32,<di,0,0>
        pop     eax
        mov     ds:[eax].pga_handle, si
        cCall   FarAssociateSelector32,<si,eax>
        .286p
        pop     ds
        ReSetKernelDS
        cCall   FreeSelector,<di>
        mov     ax,si                           ; AX is the final TDB selector/handle.
        pop     di                              ; TDB size
NoClone:

else
        xor     dx,dx                   ; Make size of allocation a dword
        regptr  xsize,dx,di
	cCall	GlobalDOSAlloc,<xsize>
	or	ax,ax
	jnz	@f
	jmp	ats6			; Return zero for failure.
@@:
endif
	mov	es, ax
	xor	ax, ax			; zero allocated block
	mov	cx, di
	shr	cx, 1
	xor	di, di
	rep	stosw

	mov	ax, es

ats2a:
	cCall	FarSetOwner,<ax,ax>	; Set TDB owner to be itself
	cmp	fWOA,0			; Is this WinOldApp?
	mov	ds,ax
	UnSetKernelDS
	jz	no_it_isnt
	or	ds:[TDB_flags],TDBF_WINOLDAP
no_it_isnt:

; Initialize the task stack.

	mov	si,1			; 1 for show means open window
	les	di,pParmBlk
	mov	ax,es
	or	ax,di
	jnz	@F
	jmp	ats4			; AX = DI = 0 if no parmblock

@@:	xor	ax,ax			; Skip past EMM save area and
	push	ds
	xor	dx, dx
	push	es
	mov	es,pExe
	mov	dx,es:[ne_flags]
	pop	es
	test	dx,NEPROT
	jz	@F
	or	ds:[TDB_flags],TDBF_OS2APP
	or	ds:[TDB_ErrMode],08000h ; don't prompt for .DLL's
@@:
	call	MapDStoDATA
	ReSetKernelDS
	test	dx,NEPROT		; OS/2 app?
	mov	dx,TopPDB		; DX has segment of parent PDB
	jz	use_kernel_TDB
; %OUT This should probably be Win_PDB
	mov	dx,cur_DOS_PDB		; inherit parent's stuff
use_kernel_TDB:
	pop	ds
	UnSetKernelDS

	push	dx			; yes, get address of PDB
	push	es
	mov	si,(TDBsize+15) and not 15	; Round up TDB size

	cCall	AllocSelector,<ds>	; Get us an alias selector
	or	ax, ax			;   did we get it?
	jnz	ats_gotsel
	mov	bx, ds			; No, tidy up
	mov	ds, ax			; We will current ds, so zero it
	cCall	GlobalDOSFree,<bx>	; Free the memory
	pop	es
	pop	dx
	xor	ax, ax
	jmp	ats6

ats_gotsel:
	xor	dx, dx
	cCall	LongPtrAdd,<ax,dx,dx,si>
	mov	si, dx			; SI = selector of new PDB
	pop	es
	pop	dx
	regptr	esbx,es,bx		; es:bx points at parm block
	mov	bx,di
	mov	cx,256			; just include enough room for PDB
	cCall	BuildPDB,<dx,si,esbx,cx,fWOA>; go build it
	mov	ax,si			; link on another PDB
	push	ds
	call	MapDStoDATA
	ReSetKernelDS
	xchg	HeadPDB,ax
	mov	es,si
	mov	es:[PDB_Chain],ax

	les	di,pParmBlk
	push	si
	lds	si,es:[di].lpfcb1
	UnSetKernelDS
	mov	di,PDB_5C_FCB
	pop	es
	mov	cx,ds
	or	cx,si
	jz	ats3b
	mov	cx,ds:[si]
	inc	cx
	inc	cx
	cmp	cx,24h
	jbe	ats3a
	mov	cx,24h
ats3a:	rep	movsb
ats3b:	mov	si,es
	pop	ds

	mov	ax,env_seg
	or	ax,ax
	jz	no_new_env
	mov	es:[PDB_environ],ax
no_new_env:

ats4:	mov	es,pExe
	mov	ds:[TDB_pModule],es	; Do this before InitTaskEMS

	mov	ax,comline_start	;!!! just for now os2
	mov	ds:[TDB_Validity],ax

	push	si
	push	ds
	push	ds
	push	es
	pop	ds
	pop	es

	mov	di,TDB_ModName
	mov	si,ds:[ne_restab]
	lodsb				; get no of bytes in name
	cbw
	cmp	ax,8
	jbe	@F
	mov	ax, ds
	krDebugOut <DEB_WARN or DEB_krLoadMod>, "Module Name %AX0 (%AX1) too long"
	mov	ax,8
@@:	mov	cx,ax
	cld
	rep	movsb

ifdef WOW
;  (see other bug #74369 note)
; Load the App compatibility flags
;  This ifdef WOW chunk is the same place as Win'95 task.asm to help get compat
;  flags loaded sooner
    mov cx,ds:[ne_expver]
    mov es:[TDB_ExpWinVer],cx

    cCall   SetAppCompatFlags, <es>
    mov es:[TDB_CompatFlags], ax
    mov es:[TDB_CompatFlags2], dx
if KDEBUG
    mov	bx, ax
    or	bx, dx
    jz      @F
    krDebugOut DEB_WARN, "Backward compatibility hack enabled: #dx#AX"
@@:
endif
endif

; initialize the interrupt vectors

	mov	di,TDB_INTVECS
	call	MapDStoDATA
	ReSetKernelDS
ife ROM
	mov	ds,MyCSAlias
	assumes ds,CODE
	mov	si,codeOffset prevInt00proc
else
	mov	si,dataOffset prevInt00proc
endif
	mov	cx,(4 * numTaskInts)/2
	rep	movsw
	assumes ds,nothing
	pop	ds
	pop	si

	cCall	FarCreateTask	;,<fPrev>
	jnc	@F
	jmp	ats6
@@:
	push	ds
	call	MapDStoDATA
	ReSetKernelDS
	mov	es,curTDB		; inherit the parents
	pop	ds
	UnSetKernelDS

	mov	ds:[TDB_PDB],si		; save new PDB
	or	si,si			; do we have a new PDB?
	jnz	@F			; zero means no
	mov	si,es:[TDB_PDB]
	mov	ds:[TDB_PDB],si
@@:	mov	ds:[TDB_Parent],es
;
; Inherit parent's wow compatibiltiy flags
; Special code is required in wkman.c to exploit this
	mov	ax,es:[TDB_WOWCompatFlags]
	mov	ds:[TDB_WOWCompatFlags],ax
	mov	ax,es:[TDB_WOWCompatFlags2]
	mov	ds:[TDB_WOWCompatFlags2],ax
	mov	ax,es:[TDB_WOWCompatFlagsEx]
	mov	ds:[TDB_WOWCompatFlagsEx],ax
	mov	ax,es:[TDB_WOWCompatFlagsEx2]
	mov	ds:[TDB_WOWCompatFlagsEx2],ax

	mov	ds:[TDB_thread_tdb],ds
	mov	ds:[TDB_DTA].off,80h	; set initial DTA
	mov	ds:[TDB_DTA].sel,si
	mov	ds:[TDB_sig],TDB_SIGNATURE	; Set signature word.

	mov	ax,SEG default_sig_handler
	mov	ds:[TDB_ASignalProc].sel,ax
	mov	ax,codeOffset default_sig_handler
	mov	ds:[TDB_ASignalProc].off,ax

; Initialize the MakeProcInstance Thunks.

	cCall	AllocDStoCSAlias,<ds>
	mov	ds:[TDB_MPI_Sel],ax
	mov	ds:[TDB_MPI_Thunks],0
	mov	ds:[TDB_MPI_Thunks].2,MPIT_SIGNATURE
	mov	bx,TDB_MPI_Thunks + THUNKSIZE-2
	mov	cx,THUNKELEM-1
	mov	dx,bx
mp1:	add	dx,THUNKSIZE
	.errnz	THUNKELEM and 0FF00h
	mov	ds:[bx],dx
	mov	bx,dx
	loop	mp1
	mov	ds:[bx],cx

	mov	si, ds
	mov	di, ax
	call	MapDStoDATA
	ReSetKernelDS
	mov	ds, pGlobalHeap
	UnSetKernelDS
if PMODE32
	.386
	cCall	far_get_arena_pointer32,<si>
	cCall	FarAssociateSelector32,<di, eax>
	.286p
else
	cCall	far_get_arena_pointer,<si>
	cCall	FarAssociateSelector,<di, ax>
endif
	mov	ax, si
	mov	ds, si
ats6:
cEnd

;-----------------------------------------------------------------------;
; pass_environment
;
;
; Entry:
;
; Returns:
;	AX = seg of new env if any
;	DX = start of comline
;
; Error Return:
;	AX = -1
;
; Registers Destroyed:
;
; History:
;  Wed 27-Dec-1989 23:36:25  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

ifdef WOW
cProc   pass_environment,<PUBLIC,NEAR>,<di,si,ds>
        parmW pExe
        parmD pParmBlk
cBegin
        ReSetKernelDS
        test    fBooting,1
        jz      @F
	xor	ax,ax
	jmp	pe_exit
@@:
        cCall   WowPassEnvironment,<cur_DOS_PDB, pParmBlk, pExe>
        or      ax,ax
        jz      pe_error_exit
        cCall   FarSetOwner,<ax,pExe>   ; Make this new guy the owner
        jmps    pe_exit

pe_error_exit:
        mov     ax, -1
pe_exit:
cEnd

else

cProc	pass_environment,<PUBLIC,NEAR>,<di,si,ds>

	parmW	pExe
	parmD	pParmBlk

	localW	myEnv
cBegin

	ReSetKernelDS

	cld
        test    fBooting,1
        jz      @F
	xor	ax,ax
	jmp	pe_exit
@@:

        cCall   WowPassEnvironment,<Win_PDB, cur_DOS_PDB, pParmBlk, pExe>

	mov	es,curTDB
	mov	bl,es:[TDB_flags]

@@:


; massage environment

	les	di,pParmBlk
	mov	ax,es:[di].envseg
	or	ax,ax
	jnz	pe_given_env
; %OUT This should probably be Win_PDB
	mov	ds,cur_DOS_PDB
	UnsetKernelDS
	mov	ax,ds:[PDB_environ]

pe_given_env:
	mov	myEnv,ax
	mov	es,ax			; ES => environment
	xor	ax,ax
	mov	cx,-1
	xor	di,di
@@:	repnz	scasb
	cmp	es:[di],al
	jnz	@B
	neg	cx
;	dec	cx			; include space for extra 0
	push	cx			; length of environment
        mov     dx,cx

; MORE TEST CODE TO SEE IF IT FIXES THE PROBLEM.
        mov     es,pExe
        test    es:[ne_flags],NEPROT
        jnz     @f

        mov     cx,3                    ; Save room for magic word and nul
        add     dx,cx
        push    8000h                   ; No command line after the env.

        jmps    pe_got_com_len

@@:
	les	di,pParmBlk
	test	bl,TDBF_OS2APP		; execer an OS/2 app?
	jz	pe_execer_dos_app
	les	di,es:[di].lpCmdLine
	mov	cx,-1
	repnz	scasb
	repnz	scasb			; get both strings
	neg	cx
	add	dx,cx
        dec     cx                      ; length of command line
	or	ch,80h			; mark special
	push	cx
	jmps	pe_got_com_len

pe_execer_dos_app:
	inc	es:[di].lpCmdLine.off
	les	di,es:[di].lpCmdLine
	xor	cx,cx
        mov     cl,es:[di][-1]          ; length of command line
	add	dx,cx
        inc     dx                      ; We add a '\0' when we move it anyway
	push	cx

pe_got_com_len:
	mov	es,pExe
	mov	di,es:[ne_pfileinfo]
	lea	di,[di].opfile
	mov	cx,-1
	repnz	scasb
	neg	cx
	dec	cx
	push	cx			; length of file name
	shl	cx,1			; for program pointer and arg 1
	add	dx,cx

        cCall   GlobalAlloc,<ax,ax,dx>
	or	ax,ax
	jz	@f
	push	ax
        cCall   FarSetOwner,<ax,pExe>   ; Make this new guy the owner
	pop	ax
@@:
	mov	es,ax
	pop	dx			; length of filename
	pop	bx			; length of command line
	pop	cx			; length of environment
	or	ax,ax
        jz      pe_error_exit

	mov	ds,myEnv
	xor	di,di
	xor	si,si
	rep	movsb

        mov     ds,pExe

; MORE TEST CODE TO SEE IF IT FIXED THE PROBLEM

        test    ds:[ne_flags],NEPROT
        jnz     @f

        mov     ax,1
        stosw

@@:
	mov	si,ds:[ne_pfileinfo]
	lea	si,[si].opfile
	mov	cx,dx			; length of filename
        rep     movsb
	mov	ax,di			; save position of comline start

	test	bh,80h			; if OS/2 execer comline is correct
	jnz	@F
	mov	si,ds:[ne_pfileinfo]
	lea	si,[si].opfile
	mov	cx,dx			; length of filename
	rep	movsb

@@:	and	bh,NOT 80h
	lds	si,pParmBlk
	lds	si,ds:[si].lpCmdLine
	mov	cx,bx
	rep	movsb
	mov	byte ptr es:[di],0	; zero terminate
	mov	dx,ax			; comline start
	mov	ax,es
	jmps	pe_exit

pe_error_exit:
	mov	ax,-1

pe_exit:

cEnd

endif

;-----------------------------------------------------------------------;
; StartLibrary								;
; 									;
; Initialize library registers.						;
; 									;
; Arguments:								;
;	parmW   hExe							;
;	parmD   lpParms							;
;	parmD   startAddr						;
; 									;
; Returns:								;
; 									;
; Error Returns:							;
;	AX = 0								;
; 	DS = data segment						;
;									;
; Registers Preserved:							;
;	DI,SI								;
; 									;
; Registers Destroyed:							;
;	BX,CX,DX,ES							;
; 									;
; Calls:								;
;	GetInstance							;
;	FarMyLock							;
; 									;
; History:								;
; 									;
;  Thu 04-Jan-1990 22:48:25  -by-  David N. Weise  [davidw]		;
; Added support for OS/2 apps.						;
;									;
;  Sat Apr 18, 1987 08:54:50p  -by-  David N. Weise   [davidw]		;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	StartLibrary,<PUBLIC,NEAR>,<ds,si,di>
	parmW   hExe
	parmD   lpParms
	parmD   startAddr
	localW	hStartSeg
cBegin
	cCall	MapDStoDATA
	ReSetKernelDS
	cmp	loadTDB,0
	je	notloading
	test	kernel_flags,KF_pUID	; All done booting?
	jz	notloading
	mov	es,loadTDB
	test	es:[TDB_Flags],TDBF_OS2APP
	jnz	notloading
	mov	ax,hExe
	mov	es,es:[TDB_LibInitSeg]
	mov	bx,es:[pStackTop]
	xchg	es:[bx-2],ax
	mov	es:[bx],ax
	add	es:[pStackTop],2
	mov	ax,hExe
	jmp	slxx

notloading:
	mov	si,hExe
	mov	es,si
	test	es:[ne_flags],NEPROT
	jnz	no_user_yet
	cmp	pSignalProc.sel,0
	jz	no_user_yet
	xor	ax,ax
	mov	bx,40h
	cCall	pSignalProc,<hExe,bx,ax,ax,ax>	; SignalProc(hModule,40h,wParam,lParam)
no_user_yet:
	cCall	GetInstance,<si>
	mov	di,ax
if ROM
	cCall	FarIsROMObject, <SEG_startAddr>
	or	ax, ax
	jz	not_rom_code_segment
	mov	hStartSeg, 0
	jmp	sl_got_handle
not_rom_code_segment:
endif
	cCall	IGlobalHandle,<SEG_startAddr>
	xchg	startAddr.sel,dx
	mov	hStartSeg,ax

if ROM
sl_got_handle:
endif

        ;** Send the SDM_LOADDLL notification
	mov	bx,startAddr.off
	mov	cx,startAddr.sel
	mov	ax,SDM_LOADDLL
        cCall   MyFarDebugCall

	cmp	SEG_startAddr, 0
	jnz	HaveStart
	mov	ax, di
        jmps    slxx
HaveStart:
	cCall	IGlobalHandle,<di>
	mov	ds,si
	UnSetKernelDS
	mov	cx,ds:[ne_heap]
	mov	ds,dx
	les	si,lpParms
	mov	ax,es
	or	ax,ax
	jz	dont_fault
	les	si,es:[si].lpcmdline
dont_fault:
	mov	ax,1			; An Arts & Letters lib init doesn't
        push    di                      ;  touch AX!!
ifdef WOW
        push    cs
        push    offset RetAddr
        pushf
        push    startAddr.sel
        push    startAddr.off

        push    ax

        push    ds

        push    ax
        mov     ax,hExe
        mov     ds,ax
        pop     ax

        push    0                       ; hTask (meaningless for a DLL)

        push    ds                      ; hModule

        push    ds                      ; Pointer to module name
        push    ds:ne_restab
        push    ds                      ; Pointer to module path
        push    word ptr ds:ne_crc+2

        cCall   MapDStoDATA
        ReSetKernelDS ds
        push    DBG_DLLSTART

        test    DebugWOW,DW_DEBUG
        jz      skip_bop

	FBOP BOP_DEBUGGER,,FastBop
.286p

skip_bop:
        add     sp,+14

        pop     ds
        UnSetKernelDS ds
        pop     ax
        iret

RetAddr equ $

else
        cCall   SafeCall,<startAddr>
endif
	pop	di			; USER.EXE didn't save DI, maybe others
	or	ax,ax
	jz	slx
	mov	ax,di
slx:
	push	ax
if ROM
	cmp	hStartSeg, 0
	jz	@F
	cCall	GlobalLRUOldest,<hStartSeg>
@@:
endif
	pop	ax
slxx:
cEnd


;-----------------------------------------------------------------------;
; StartTask								;
;									;
; Sets up the standard register values for a Windows task.		;
;									;
; Arguments:								;
;	HANDLE hPrev   = a previous instance				;
;	HANDLE hExe    = the EXE header					;
;	FARP stackAddr = the normal task stack address (initial SS:SP)	;
;	FARP startAddr = the normal task start address (initial CS:IP)	;
; 									;
; Returns:								;
;	AX = HANDLE							;
; 									;
; Error Returns:							;
;	AX = NULL							;
;									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	GetInstance							;
;	FarMyLock							;
; 									;
; History:								;
;									;
;  Tue Apr 21, 1987 06:41:05p  -by-  David N. Weise      [davidw]	;
; Added the EMS initialization of the entry tables in page 0.		;
; 									;
;  Thu Dec 11, 1986 11:38:53a  -by-    David N. Weise     [dnw]		;
; Removed the superfluous call to calculate the largesr NR seg.		;
; 									;
;  Fri Sep 19, 1986 12:08:23p  -by-    Charles Whitmer	  [cxw]		;
; Made it return 0000 on error rather than terminate.			;
;									;
;  Thu Sep 18, 1986 02:33:39p  -by-  Charles Whitmer	[cxw]		;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	StartTask,<PUBLIC,NEAR>,<si,di>
	parmW   hPrev
	parmW   hExe
	parmD   stackAddr
	parmD   startAddr
cBegin
	cCall	MapDStoDATA
	ReSetKernelDS
	xor	di,di
	cmp	loadTDB,di
	jnz	st1
	jmp	stx

stfail0:
	xor	ax,ax
	pop	ds
	jmp	stfail

st1:	push	ds
	cmp	stackAddr.sel,di
	jz	stfail0

	cmp	startAddr.sel,di
	jz	stfail0

	mov	ds,loadTDB
	UnSetKernelDS
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jnz	stfail0

; Get new task stack

	cCall	IGlobalHandle,<SEG_stackAddr>
	mov	ds:[TDB_taskSS],dx
	mov	ax,stackAddr.off
	sub	ax,(SIZE TASK_REGS)
	mov	ds:[TDB_taskSP],ax

; get my instance

        cCall   GetInstance,<hExe>
        mov     di,ax
	mov	ds:[TDB_Module],ax

; find my real code segment

	cCall	IGlobalHandle,<SEG_startAddr>
        or      dx,dx
	jz	stfail0
	mov	startAddr.sel,dx

; find my real data segment

        cCall   IGlobalHandle,<di>      ; DI = handle of DGROUP
	mov	si,dx			; SI = address of DGROUP

if KDEBUG

; Set up the allocBreak globals if needed

        cCall   SetupAllocBreak,<ds>

endif   ;KDEBUG

; copy junk from hExe -> TDB

	mov	es,hExe
	mov	cx,es:[ne_expver]
	mov	ds:[TDB_ExpWinVer],cx
	mov	cx,es:[ne_stack]	; CX = STACKSIZE
	mov	dx,es:[ne_heap] 	; DX = HEAPSIZE



; set up the task registers

	test	es:[ne_flags],NEPROT
	jnz	st_OS2_binary

	les	bx,dword ptr ds:[TDB_TaskSP]
	mov	es:[bx].TASK_AX,0	; Task AX = NULL
	mov	ax,ds:[TDB_PDB]
	mov	es:[bx].TASK_ES,ax	; Task ES = PDB
	mov	es:[bx].TASK_DI,di	; Task DI = hInstance or hExe
	mov	es:[bx].TASK_DS,si	; Task DS = data segment
	mov	ax,hPrev
	mov	es:[bx].TASK_SI,ax	; Task SI = previous instance
	mov	es:[bx].TASK_BX,cx	; Task BX = STACKSIZE
	mov	es:[bx].TASK_CX,dx	; Task CX = HEAPSIZE
	mov	es:[bx].TASK_BP,1	; Task BP = 1 (far frame)
	jmps	st_regs_set

st_OS2_binary:
	push	di
	mov	es,ds:[TDB_PDB]
	mov	di,es:[PDB_environ]
	les	bx,dword ptr ds:[TDB_TaskSP]
	mov	es:[bx].TASK_AX,di	; Task AX = environment
	mov	es:[bx].TASK_DX,cx	; Task DX = STACKSIZE
	lsl	cx,si
	inc	cx
	mov	es:[bx].TASK_CX,cx	; Task CX = Length of data segment
	mov	ax,ds:[TDB_pModule]
	mov	es:[bx].TASK_DI,ax	; Task DI = hExe
	mov	es:[bx].TASK_SI,dx	; Task SI = HEAPSIZE
	mov	es:[bx].TASK_DS,si	; Task DS = data segment
	mov	es:[bx].TASK_ES,0	; Task ES = 0
	mov	es:[bx].TASK_BP,1	; Task BP = 1 (far frame)
	xor	ax,ax
	xchg	ax,ds:[TDB_Validity]
	mov	es:[bx].TASK_BX,ax	; Task BX = offset in env of comline
	pop	di

st_regs_set:

        pop     ds
	push	ds
	ReSetKernelDS

        test    Kernel_Flags[2],KF2_PTRACE ;TOOLHELP.DLL and/or WINDEBUG.DLL?
        jz      st_NoPTrace

	mov	ax,startAddr.sel
	mov	ptrace_app_entry.sel,ax
	mov	ax,startAddr.off
	mov	ptrace_app_entry.off,ax

	mov	ax,SEG CVW_HACK
	mov	ds,ax
	UnSetKernelDS
	mov	ax,codeOffset CVW_Hack
	jmps	st_PTraceHere

st_NoPTrace:
	lds	ax,startAddr		; Task CS:IP = start address
	UnSetKernelDS
st_PTraceHere:
	mov	es:[bx].TASK_CS,ds
	mov	es:[bx].TASK_IP,ax
        pop     ds
	ReSetKernelDS

stx:	mov	ax,di
stfail:
cEnd

;-----------------------------------------------------------------------;
; InitTask								;
; 									;
; This should be the first thing called by app when first started.	;
; It massages the registers, massages the command line and inits	;
; the heap.								;
;									;
; Arguments:								;
;									;
;  When a windows application starts up the registers look		;
;  like this:								;
;									;
;  AX = 0								;
;  BX = stack size							;
;  CX = heap size							;
;  DX = ?								;
;  DI = hInstance							;
;  SI = hPrevInstance							;
;  BP = 0								;
;  ES = Segment of Program Segment Prefix (see page E-8)		;
;  DS = Applications DS							;
;  SS = DS								;
;  SP = stack area							;
;									;
;  FCB1 field at PSP:5CH contains up to 24h bytes of binary data.	;
;  Windows apps get their ShowWindow parameter in the first word of	;
;  of this data.							;
; 									;
; Returns:								;
;	AX	= PSP address						;
;	CX	= stack limit						;
;	DX	= command show						;
;	ES:BX	= command line						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	LocalInit							;
;	FarEMS_FirstTime						;
; 									;
; History:								;
; 									;
;  Mon 11-Sep-1989 19:13:52  -by-  David N. Weise  [davidw]		;
; Remove entry of AX = validity check.					;
;									;
;  Wed Mar 16, 1988 22:45:00a  -by-  T.H.	      [    ]		;
; Fix bug in exit path.  It was not popping the saved DS from the	;
; far call frame properly.  Normally, this is not a problem (since	;
; it does indeed save the DS register across the entire routine),	;
; but if the RET has to go through a RetThunk, the saved DS is not	;
; really the original DS value, but a special value needed by the	;
; INT3F RetThunk code.  This causes a crash when something in this	;
; routine (like the call to UserInitDone) causes our calling code	;
; segment to be discarded.						;
; 									;
;  Sat Apr 18, 1987 08:43:54p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

STACKSLOP   equ	    150		; stack slop for interrupt overhead

	assumes ds,nothing
	assumes es,nothing

; ES = TDB

	public	do_libinit
do_libinit  proc    near
	push	si
	push	es
	mov	si,es:[TDB_LibInitOff]
	mov	es,cx
libinit_loop:
	cld
	lods	word ptr es:[si]
	or	ax,ax
	jz	libinit_done
	push	es
	mov	es,ax
	cmp	es:[ne_magic],NEMAGIC
	jne	libinit_loop1
	mov	ax,-1
	push	es
	cCall	StartProcAddress,<es,ax>
	pop	es
;;;	jcxz	libinit_loop1
	xor	cx,cx
	cCall	StartLibrary,<es,cx,cx,dx,ax>
	or	ax,ax
        jnz     libinit_loop1
        mov     ax,4CF0h
        DOSFCALL
libinit_loop1:
	pop	es
	jmp	libinit_loop
libinit_done:

	mov	si,es
	cCall	GlobalUnlock,<si>
	cCall	GlobalFree,<si>
	pop	es
	mov	es:[TDB_LibInitSeg],0
	mov	es:[TDB_LibInitOff],0
	pop	si
	ret
do_libinit  endp


	assumes ds,nothing
	assumes es,nothing

cProc	InitTask,<PUBLIC,FAR>
cBegin	nogen
	pop	ax			; Get return address
	pop	dx
	mov	ss:[pStackMin],sp	; Save bottom of stack
	mov	ss:[pStackBot],sp
	sub	bx,sp			; Compute top of stack
	neg	bx
	add	bx,STACKSLOP
	mov	ss:[pStackTop],bx	; Setup for chkstk

	xor	bp,bp			; Initial stack frame
	push	bp			; is not a far frame as there
	mov	bp,sp			; is no return address
	push	dx			; Push return address back on
	push	ax
	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	jcxz	noheap			; Initialize local heap if any
	xor	ax,ax
	push	es
	cCall	LocalInit,<ax,ax,cx>
	pop	es
	or	ax,ax
	jnz	noheap
	push	ds
	jmp	noinit
noheap:
	push	es
	cCall	GetCurrentTask
	mov	es,ax
	mov	cx,es:[TDB_LibInitSeg]
	jcxz	no_libinit
	call	do_libinit
no_libinit:
ifdef WOW
;  (see other bug #74369 note)
;  App compatibility flags are set during CreateTask time to make them avilable
;  to .dll's that are loaded by do_libinit (this is the same as Win'95)
else
   call	SetAppCompatFlags
   mov	es:[TDB_CompatFlags], ax
   mov	es:[TDB_CompatFlags2], dx
if KDEBUG
   mov	bx, ax
   or	bx, dx
   jz      @F
   krDebugOut DEB_WARN, "Backward compatibility hack enabled: #dx#AX"
@@:
endif
endif

	pop	es

	push	ds
	cCall	MapDStoDATA
	ReSetKernelDS
	test	kernel_flags,KF_pUID	; All done booting?
	jnz	noboot			; Yes, continue
	or	kernel_flags,KF_pUID
	mov	fBooting,0
	mov	cx,ds

	pop	ds			; DS = caller's data segment
	UnSetKernelDS
	push	es			; Save ES
	push	ax
	push	cx
	cCall	IGlobalHandle,<ds>
	push	ax
	cCall	UnlockSegment,<ds>
        xor     dx,dx
        cCall   GlobalCompact,<dx,dx>   ; Compact memory
        xor     dx,dx
        cCall   GlobalCompact,<dx,dx>   ; Once more for completeness
	cCall	IGlobalHandle		 ; ,<ax> from above
	mov	ds,dx
        cCall   LockSegment,<ds>

	pop	cx
	push	ds
	mov	ds,cx
	ReSetKernelDS
	cmp	pUserInitDone.sel,0	; for Iris's server
	jz	no_User_to_call
	call	pUserInitDone		; Let USER lock down stuff.
no_USER_to_call:
	pop	ds
	UnSetKernelDS
	pop	ax
	pop	es
	push	ds

IF PMODE32
        ;** Initialize the reboot stuff here
        push    es                      ; Save across call
        cCall   KRebootInit             ; Local reboot init code
        pop     es
ENDIF


noboot:
	mov	bx,PDB_DEF_DTA		; point at command line
	mov	cx,bx			; save copy in cx
	cmp	bh,es:[bx]		; any chars in command line?
	je	ws3a			; no - exit
ws1:	inc	bx			; point to next char
	mov	al,es:[bx]		; get the char
	cmp	al,' '			; SPACE?
	je	ws1
	cmp	al,9			; TAB?
	je	ws1
	mov	cx,bx			; save pointer to beginning
	dec	bx			; compensate for next inc
ws2:	inc	bl			; move to next char
	jz	ws3a			; bailout if wrapped past 0FFh
	cmp	byte ptr es:[bx],13	; end of line?
	jne	ws2
ws3:
	mov	byte ptr es:[bx],0	; null terminate the line
ws3a:
	mov	bx,cx			; ES:BX = command line
	mov	cx,ss:[pStackTop]	; CX = stack limit
	mov	dx,1			; DX = default cmdshow
	cmp	word ptr es:[PDB_5C_FCB],2	; Valid byte count?
	jne	wsa4			; No, use default
	mov	dx,word ptr es:[PDB_5C_FCB][2]	; Yes, DX = passed cmdshow
wsa4:
	mov	ax,es			; AX = PSP address
noinit:
	pop	ds

; THIS is correct way to pop the call frame.  Must pop the saved
; DS properly from stack (might have been plugged with a RetThunk).

	sub	bp,2
	mov	sp,bp
	pop	ds
	pop	bp
	dec	bp
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; InitLib								;
; 									;
; Does what it says.							;
;									;
; Arguments:								;
;	CX = # bytes wanted for heap					;
; 									;
; Returns:								;
;	ES:SI => null command line					;
; 									;
; Error Returns:							;
;	CX = 0								;
; 									;
; Registers Preserved:							;
;	DI,DS								;
; 									;
; Registers Destroyed:							;
;	AX,BX,DX							;
; 									;
; Calls:								;
;	LocalInit							;
; 									;
; History:								;
; 									;
;  Sat Apr 18, 1987 08:31:27p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	InitLib,<PUBLIC,FAR>
cBegin	nogen
	xor	ax,ax
	jcxz	noheap1			; Done if no heap
	mov	si,cx
	cCall	LocalInit,<ax,ax,cx>
	jcxz	noheap1			; Done if no heap
	mov	cx,si
noheap1:
	push	ds
	cCall	MapDStoDATA
	push	ds
	pop	es
	pop	ds
	mov	si,codeOFFSET nullcomline
	ret
cEnd	nogen

if KDEBUG

if 0
;-----------------------------------------------------------------------
;   SetupAllocBreak
;
; Initializes the allocation break globals
; from the ALLOCBRK environment variable.
;
; ALLOCBRK=MODULE,0x12345678
;
; Assumes:
;   DS = loadTDB
;
; Trashes:
;   ES, SI, AX, BX, CX, DX
;
szALLOCBRK  db  "ALLOCBRK="
cchALLOCBRK equ $-szALLOCBRK

cProc   SetupAllocBreak,<NEAR, PUBLIC>,<SI>
cBegin
        mov     es,ds:[TDB_PDB]
        mov     es,es:[PDB_environ]

        lea     bx,szALLOCBRK
        mov     dx,cchALLOCBRK
        call    LookupEnvString
        or      bx,bx
        jz      nomatch
;
; See if TDB_ModName is the same as the ALLOCBRK= module.
;
        mov     si,TDB_ModName
modloop:
        mov     al,es:[bx]          ; get next environment char
        or      al,al
        jz      nomatch             ; if at end of environment, no match
        cmp     al,','
        jz      match               ; if at comma, then they might match
        cmp     al,ds:[si]
        jnz     nomatch
        inc     bx                  ; advance ptrs and try next char
        inc     si
        jmp     modloop
match:
        cmp     byte ptr ds:[si],0  ; at end of module name string?
        jnz     nomatch

        inc     bx                  ; skip past comma.
        call    ParseHex            ; parse hex constant into dx:ax

        SetKernelDSNRes es
        mov     word ptr es:allocBreak,ax
        mov     word ptr es:allocBreak+2,dx

        or      ax,dx               ; if allocBreak is 0, clear allocTask
        jz      @F
        mov     ax,ds               ; otherwise allocTask = loadTDB.
@@:
        mov     es:allocTask,ax

        xor     ax,ax               ; reset allocCount
        mov     word ptr es:allocCount,ax
        mov     word ptr es:allocCount+2,ax
nomatch:
cEnd

;-----------------------------------------------------------------------
; LookupEnvString
;
; ES -> environment segment
; CS:BX -> string to search for (which must include trailing '=')
; DX -> length of string to search for
;
; returns:
;   es:bx = pointer to environment string past '='
;
cProc   LookupEnvString,<NEAR, PUBLIC>,<SI,DI,DS>
cBegin
        push    cs                      ; ds = cs
        pop     ds

	cld
        xor     di,di                   ;start at beginning of environment seg
lenv_nextstring:
        mov     si,bx                   ;si = start of compare string
        mov     cx,dx                   ;cx = string length
        mov     ax,di                   ;Save current position in env seg
        repe    cmpsb
        je      lenv_foundit

        mov     di,ax                   ; start at beginning again
        xor     ax,ax                   ; and skip to end.
        xor     cx,cx
        dec     cx                      ; cx = -1
        repne   scasb
        cmp     es:[di],al              ;End of environment?
        jne     lenv_nextstring         ;No, try next string
        xor     bx,bx                   ; BX == NULL == not found.
        jmp     short lenv_exit

lenv_foundit:
        mov     bx,di
lenv_exit:
cEnd

;---------------------------------------------------------------------------
;
; ParseHex
;
; Assumes:
;   es:bx - pointer to hex string of form 0x12345678
;
; Returns:
;   Hex value in dx:ax, es:bx pointing to char past constant.
;
; Trashes:
;   cx
;
cProc   ParseHex,<NEAR, PUBLIC>
cBegin
        xor     dx,dx               ; zero break count
        xor     ax,ax
        xor     cx,cx               ; clear hi byte of char
hexloop:
        mov     cl,es:[bx]          ; get first digit
        jcxz    parse_exit
        inc     bx
        cmp     cl,' '              ; skip spaces
        jz      hexloop
        cmp     cl,'x'              ; skip 'x' or 'X'
        jz      hexloop
        cmp     cl,'X'
        jz      hexloop

        cmp     cl,'0'              ; '0'..'9'?
        jb      parse_exit
        cmp     cl,'9'
        jbe     hexdigit

        or      cl,'a'-'A'          ; convert to lower case

        cmp     cl,'a'              ; 'a'..'f'?
        jb      parse_exit
        cmp     cl,'f'
        ja      parse_exit

        sub     cl,'a'-'0'-10
hexdigit:
        sub     cl,'0'

        add     ax,ax               ; dx:ax *= 16
        adc     dx,dx
        add     ax,ax
        adc     dx,dx
        add     ax,ax
        adc     dx,dx
        add     ax,ax
        adc     dx,dx

        add     ax,cx               ; add in the new digit
        adc     dx,0

        jmp     hexloop
parse_exit:
cEnd
endif;  0

endif   ;KDEBUG

sEnd	NRESCODE


if KDEBUG

sBegin  CODE
assumes cs,CODE
;------------------------------------------------------------------------
;
; char FAR* GetTaskModNamePtr(HTASK htask)
;
; Returns a far pointer to a task's module name
; Used by SetupAllocBreak to access the task module name.
;
; Coded in assembly because no C header file that describes
; the TDB exists (and it's a little late to create one now)
;
cProc   GetTaskModNamePtr,<NEAR, PUBLIC>
ParmW   htask
cBegin
	mov     dx,htask
	mov     ax,TDB_ModName
cEnd

sEnd    CODE
endif;  KDEBUG


sBegin	MISCCODE
assumes	cs, misccode
assumes	ds, nothing
assumes	es, nothing

externNP MISCMapDStoDATA

;-----------------------------------------------------------------------;
; GetDOSEnvironment
;
; Gets a pointer to the current task's starting environment string.
; Basically used by DLL's to find the environment.
;
; Entry:
;	none
;
; Returns:
;	DX:AX = pointer to current task's starting environment string
;
; Registers Destroyed:
;
; History:
;  Tue 13-Jun-1989 20:52:58  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetDOSEnvironment,<PUBLIC,FAR>
cBegin nogen

	push	ds
	call	GetCurrentTask
	mov	ds,ax
	mov	ds,ds:[TDB_PDB]
	mov	dx,ds:[PDB_environ]
	xor	ax,ax
	pop	ds
	ret

cEnd nogen


;-----------------------------------------------------------------------;
; GetNumTasks								;
; 									;
; Gets the number of tasks (AKA TDB) in the system.			;
;									;
; Arguments:								;
;	none								;
; 									;
; Returns:								;
;	AX = number of tasks						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	all								;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
;	nothing								;
; 									;
; History:								;
; 									;
;  Thu Apr 09, 1987 11:34:30p  -by-  David N. Weise   [davidw]          ;
; Wrote it.								;
;-----------------------------------------------------------------------;

	assumes ds,nothing
	assumes es,nothing

cProc	GetNumTasks,<PUBLIC,FAR>
cBegin	nogen
	xor	ax,ax
	push	ds
	call	MISCMapDStoDATA
	ReSetKernelDS
	mov	al,num_tasks
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen

sEnd	MISCCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\schedule.asm ===
title	SCHEDULE - task scheduler

.xlist
include kernel.inc
include tdb.inc
include	eems.inc
include newexe.inc
.list

if PMODE32
.386
endif

externFP WriteOutProfiles
externFP GlobalCompact
externFP GetFreeSpace

;if KDEBUG
;externFP OutputDebugString
;endif
      	 
DataBegin

externB Kernel_InDOS
externB Kernel_flags
externB InScheduler
externB fProfileDirty
externB fProfileMaybeStale
externB fPokeAtSegments
externW WinFlags
;externW EMSCurPID
;externW cur_drive_owner
externW curTDB
externW Win_PDB
externW LockTDB
externW headTDB
externW hShell
externW	pGlobalHeap
externW hExeHead
externW f8087
externW 
if PMODE32
externW PagingFlags
externD pDisplayCritSec
endif
externD pIsUserIdle

if KDEBUG
externB fPreloadSeg
endif

staticW	PokeCount,0

DataEnd

sBegin	CODE
assumes cs,CODE
assumes ds,NOTHING
assumes es,NOTHING

externNP LoadSegment
externNP DeleteTask
externNP InsertTask
if PMODE32
externNP DiscardFreeBlocks
externNP ShrinkHeap
endif	 

if SDEBUG
externNP DebugSwitchOut
externNP DebugSwitchIn
endif

;-----------------------------------------------------------------------;
; Reschedule								;
;									;
; This routine does the task switching.					;
;									;
; Arguments:								;
;	none								;
; Returns:								;
;	nothing								;
; Error Returns:							;
;	nothnig								;
; Registers Preserved:							;
;	AX,BX,CX,DX,DI,SI,BP,DS,ES					;
; Registers Destroyed:							;
;	none								;
; Calls:								;
;	DeleteTask							;
;	InsertTask							;
;	SaveState							;
;									;
; History:								;
;									;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]		;
; Removed the WinOldApp support and DEC rainbow support.		;
;									;
;  Fri 07-Apr-1989 22:16:02  -by-  David N. Weise  [davidw]		;
; Added support for task ExeHeaders above The Line in Large		;
; Frame EMS.								;
;									;
;  Sat Aug 15, 1987 11:41:35p  -by-  David N. Weise	 [davidw]	;
; Commented out the cli and sti around the swapping of states.		;
; Sweet Lord, what will this break?					;
; 									;
;  Fri Feb 06, 1987 00:09:20a  -by-  David N. Weise   [davidw]		;
; Put in support for DirectedYield.					;
; 									;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw] 		;
; Got rid of going inside of DOS for InDOS and ErrorMode.  Task		;
; switching should be much better under Windows386 now.			;
; 									;
;  Mon Sep 29, 1986 05:27:29p  -by-  Charles Whitmer  [chuckwh]		;
; Made it recognize threads.  It now does a fast context switch if	;
; just switching between two threads in the same process.		;
;									;
;  Mon Sep 29, 1986 05:24:16p  -by-  Charles Whitmer  [chuckwh]		;
; Documented it.							;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	Reschedule,<PUBLIC,FAR>
cBegin	nogen

; get all the registers up on the stack

	inc	bp
	push	bp
	mov	bp,sp
	push	ds
	push	si
	push	di
	push	ax
	push	cx
	push	es
	push	bx
	push	dx

	public	BootSchedule
BootSchedule:
	call	TaskSwitchProfileUpdate ;Update profile information

	public	ExitSchedule
ExitSchedule:

; see if we're supposed to do a directed yield
		    
	SetKernelDS	es
	mov	cx,curTDB
	jcxz	search_the_queue	; this happens first after boot time!
	mov	ds,cx
	cmp	ds:[TDB_sig],TDB_SIGNATURE
	jnz	short search_the_queue	; task may have suicided
	xor	cx,cx
	xchg	ds:[TDB_Yield_to],cx
	jcxz	search_the_queue	; nope
	mov	ds,cx
	cmp	ds:[TDB_nevents],0	; anything for this guy?
	jnz	found_one
		
; run down the task queue looking for someone with events

search_the_queue:
	CheckKernelDS	es
	mov	ax,HeadTDB
keep_searching:
	or	ax,ax			; Anyone to schedule?
	jnz	short try_this_one		; Yes, go do it

; if no one is dispatchable, do an idle interrupt

if PMODE32
	xor	PagingFlags, 4
	test	PagingFlags, 4
	jnz	short NoDiscarding	; Every other time through!

	test	PagingFlags, 8		; An app has exited?
	jz	short NoShrink
	push	es
	call	ShrinkHeap
	pop	es
NoShrink:
	
;;;	or	PagingFlags, 2		; Causes early exit from GlobalCompact
;;;	mov	ax, -1
;;;	push	es
;;;	cCall	GlobalCompact,<ax,ax>
;;;	pop	es
;;;	and	PagingFlags, not 2

	test	byte ptr WinFlags[1], WF1_PAGING
	jz	short NoDiscarding
	test	PagingFlags, 1
	jz	short NoDiscarding
	call	DiscardFreeBlocks
	jmps	search_the_queue
NoDiscarding:
endif

	mov	ax, 1			; Assume User is idle
	cmp	word ptr pIsUserIdle[2], 0
	je	short go_idle
	call	pIsUserIdle
	SetKernelDS	es
go_idle:

	cmp	fPokeAtSegments, 0	; Disabled?
	je	short @F	 	;  yep, skip
	or	ax, ax			; Only if USER is idle
	jz	short @F
	inc	PokeCount
	test	PokeCount, 1Fh		; Only every 32 times through
	jnz	short @F
	call	PokeAtSegments
	jc	search_the_queue
@@:
	push	ax			; Ralph's paranoia
	int	28h			; No, generate DOS idle int
	pop	ax
	xor	bx, bx
	or	ax, ax
	jnz	short tell_ralph
	or	bl, 1
tell_ralph:
	mov	ax,1689h		; Do an idle to Win386.
	int	2fh
	jmp	search_the_queue

get_out_fast:
	jmp	reschedule_done

; see if the given task has events

try_this_one:
	mov	ds,ax
	mov	ax,ds:[TDB_next]
	cmp	ds:[TDB_nevents],0	; anything for this guy?
	jz	keep_searching
		
; is this the guy we're already running?

found_one:
	mov	di,ds			; DI = handle of new task
	cmp	di,curTDB
	jz	short get_out_fast

; is there a locked task?

	mov	cx,LockTDB		; are any tasks super priority?
	jcxz	no_locked_task
	cmp	cx,di			; are we it?
	jnz	short get_out_fast		; No => don't switch
no_locked_task:

; don't switch if in DOS or int 24 handler

	cmp	Kernel_InDOS,0		; if inside INT2[0,4] handler
	jnz	keep_searching		; ...don't reschedule
		
	inc	InScheduler		; set flag for INT 24...

	inc	ds:[TDB_priority]	; lower task priority
	push	es
	UnSetKernelDS	es
	cCall	DeleteTask,<ds>		; remove him from queue
	cCall	InsertTask,<ds>		; put him back further down
	dec	ds:[TDB_priority]	; restore former priority
	pop	es
	ReSetKernelDS	es

; Around saving state and restoring state go critical on memory
;  heap access because of EMS.

	push	es
	mov	es,pGlobalHeap
	UnSetKernelDS	es
	inc	es:[gi_lrulock]
	pop	es
	ReSetKernelDS	es

; Signature is trashed when we suicide so we dont save state
;   for the non-existant task.

	mov	di,ds			; DI = destination task
	xor	si,si			; SI is an argument to RestoreState
	mov	es,curTDB		; ES = current TDB
	UnSetKernelDS	es
	mov	ax,es
	or	ax,ax
	jz	short dont_save_stack
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jnz	short dont_save_stack
	mov	si,es			; SI = current task

; save the present stack

	mov	es:[TDB_taskSS],ss
	mov	es:[TDB_taskSP],sp
dont_save_stack:

; get onto a temporary stack while we switch the EEMS memory

	mov	ax,es
	or	ax,ax
	jz	short dont_save_state
	cmp	es:[TDB_sig],TDB_SIGNATURE
	jnz	short dont_save_state

	cCall	SaveState,<si>
	push	ds
	mov	ds,ax
if SDEBUG
	call	DebugSwitchOut
endif
	pop	ds
dont_save_state:
	SetKernelDS	es
	mov	curTDB,di

	mov	ax, ds:[TDB_PDB]	; Set our idea of the PDB
	mov	Win_PDB, ax
     ;;;mov	ax,ds:[TDB_EMSPID]
     ;;;mov	EMSCurPID,ax
	cmp	f8087, 0
	je	short no_fldcw
	.8087
	fnclex
	fldcw	ds:[TDB_FCW]
no_fldcw:

	or	Kernel_flags,kf_restore_CtrlC OR kf_restore_disk
if SDEBUG
	call	DebugSwitchIn
endif

fast_switch:
	mov	cx,ds:[TDB_taskSS]	; Switch to new task stack.
	mov	ax,ds:[TDB_taskSP]
	mov	ss,cx
	mov	sp,ax
	mov	curTDB,di
	dec	InScheduler		; reset flag for INT 24

if PMODE32
	mov	al,Kernel_Flags[2]
	and	Kernel_Flags[2],NOT KF2_WIN386CRAZINESS

; Tell the display driver to speak its mind. added 20 feb 1990

	test	al,KF2_WIN386CRAZINESS
	jz	short @F
	xor	ax,ax
        push    es                      ; preserve es
	cCall	pDisplayCritSec,<ax>
        pop     es
@@:
endif

; Around saving state and restoring state go critical on memory
;  arena access because of EMS.

	mov	es,pGlobalHeap
	UnSetKernelDS	es
	dec	es:[gi_lrulock]

; pop the task's registers off the stack

reschedule_done:
	pop	dx
	pop	bx
	pop	es
	pop	cx
	pop	ax
	pop	di
	pop	si
	pop	ds
	pop	bp
	dec	bp
	public	dispatch
dispatch:
	ret

cEnd nogen

;-----------------------------------------------------------------------;
; LockCurrentTask							;
; 									;
; Hack procedure to make the current task god if the passed boolean	;
; is true.								;
; If false, then demotes the current god to a mere mortal. Self		;
; inflicted by definition.						;
; 									;
; DavidDS: Note, the USER function, LockMyTask should be called for	;
; Windows apps instead of this if you expect the input queue to work    ;
; properly.                                                             ;
;                                                                       ;
; Arguments:								;
;	ParmW	lock							; 									;
; Returns:								;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	CX,DX,DI,SI,DS,ES						;
; 									;
; Registers Destroyed:							;
;	AX,BX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Sun Jan 04, 1987 04:37:11p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	LockCurrentTask,<PUBLIC,FAR>
;	ParmW	lock
cBegin	nogen				; Crock to save space
	mov	bx,sp
	mov	ax,ss:[bx][4]		; get the argument
	push	ds
	SetKernelDS
	or	ax,ax
	jz	short lct1
	mov	ax,curTDB
lct1:
	mov	LockTDB,ax
	pop	ds
	UnSetKernelDS
	ret	2
cEnd	nogen


;-----------------------------------------------------------------------;
; IsTaskLocked								;
; 									;
; Another hack procedure to determine if the current task is locked.	;
; A non-NULL value is returned if the task is locked and NULL is	;
; returned is the task is not locked.					;
; 									;
; Arguments:								;
;									;									;
; Returns:								;
;	The value of LockTDB						;
; Error Returns:							;
; 									;
; Registers Preserved:							;
;	All but AX							;
; 									;
; Registers Destroyed:							;
;	AX								;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;   (Tue 20-Oct-1987 : bobgu)	    Created this thing. 		;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	IsTaskLocked,<PUBLIC,FAR>
cBegin	nogen
	push	ds
	SetKernelDS
	mov	ax,LockTDB
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
; SaveState                                                             ;
; 									;
; Saves the state of the current MS-DOS process.  This means the per	;
; task interrupt vectors, the drive and directory, EEMS land if any,	;
; and old app stuff if any.						;
; 									;
; Arguments:								;
;	parmW	destination						;
; 									;
; Returns:								;
; 	DS returned in AX.						;
; 									;
; Error Returns:							;
; 									;
; Registers Preserved:							;
; 									;
; Registers Destroyed:							;
; 									;
; Calls:								;
; 									;
; History:								;
; 									;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]		;
; Removed the WinOldApp support.					;
;									;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw] 		;
; Got rid of the rest of the DOS version dependencies.			;
; 									;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]		;
; Took out the saving of the ^C state, DTA address, and ErrorMode.	;
; 									;
;  Sun Jan 04, 1987 04:40:44p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.					;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc	SaveState,<PUBLIC,NEAR>,<si,di,ds>
	parmW	destination
cBegin
	cld
	SetKernelDS
	mov	ax,f8087
	UnSetKernelDS
	mov	ds,destination
	or	ax,ax
	jz	short no_fstcw
	.8087
	fstcw	ds:[TDB_FCW]
no_fstcw:
	test	ds:[TDB_Drive],10000000b; if hi bit set....
	jnz	short ss_ret			; ...no need to get dir
	mov	ah,19h
	int	21h
	mov	dl,al
	inc	dl
	or	al,10000000b
	mov	ds:[TDB_Drive],al	; save it (A=0, B=1, etc.)
	mov	si,TDB_Directory
	mov	byte ptr [si],'\'	; set "\"
	inc	si
	mov	ah,47h			; get current directory...
	int	21h
	jnc	short ss_ret
	mov	byte ptr [si-1],0	; indicate error with null byte
ss_ret:	mov	ax,ds
cEnd


cProc	TaskSwitchProfileUpdate,<PUBLIC,NEAR>
cBegin
	SetKernelDS es

        ;** See if we need to write out the profile string cache.  We
        ;**     do this at task switch time.
      	cmp	es:fProfileDirty, 0
      	je	short PU_NoFlushProfiles
        push    es
	call	WriteOutProfiles
        pop     es
PU_NoFlushProfiles:

        ;** Set the flag saying that the profile cache MAY be invalid.
        ;**     If a task switch occurs, on the next Get/SetProfileXXX() we
        ;**     will have to see if the file has been modified by this
        ;**     (or any other) task
        mov     es:fProfileMaybeStale,1
cEnd

assumes	ds, nothing
assumes	es, nothing
	
if PMODE32
.386
else
.286
endif

cProc	PokeAtSegments,<PUBLIC,NEAR>
cBegin
	push	ds
	push	es
	pusha

	cCall	GetFreeSpace,<2>		; Ignore discardable
	or	dx, dx				; Insist on > 64k free
if KDEBUG
	jz	never_again
else
	jz	short never_again
endif

if PMODE32
	SetKernelDS

	test	WinFlags[1], WF1_PAGING
	jz	short have_room

	sub	sp, 30h				; Room for info
	smov	es, ss
	mov	di, sp
	mov	ax, 0500h			; Get Paging Info
	int	31h
	mov	eax, es:[di][14h]		; Free pages
	add	sp, 30h
	cmp	eax, 16				; Insist on 64k
	jb	short never_again

have_room:
	smov	es, ds
	ResetKernelDS	es
else
	SetKernelDS es
endif

	mov	ds, hExehead
	UnsetKernelDS

next_exe:
	mov	cx, ds:[ne_cseg]		; Module has segments?
	jcxz	no_segs				;  no, on to next module
	mov	di, 1				; Segment number
	mov	si, ds:[ne_segtab]		; Pointer to segment table

next_seg:
	test	ds:[si].ns_flags, NSLOADED	; This segment in memory?
	jnz	short seg_here			;  yes, look at next one
	test    ds:[si].ns_flags, NSDISCARD     ; Only load if discardable
	jz	short seg_here			; Skip this one
if KDEBUG
	push	ds
	SetKernelDS
	mov	fPreloadSeg, 1
	pop	ds
	UnsetKernelDS
endif
	cCall	LoadSegment,<ds,di,-1,-1>
if KDEBUG
	push	ds
	SetKernelDS
	mov	fPreloadSeg, 0
	pop	ds
	UnsetKernelDS
endif
	stc					; We loaded something!
	jmps	all_done

seg_here:
	lea	si, [si + size NEW_SEG1]	; On to next segment
	inc	di
	loop	next_seg			; looked at all in this module?

no_segs:
	mov	cx, ds:[ne_pnextexe]		; On to next module
	jcxz	all_done			; End of list?
	mov	ax, ds
	mov	ds, cx
	cmp	ax, hShell			; Only boot time modules
	jne	short next_exe
	UnSetKernelDS es
never_again:
	SetKernelDS
	mov	fPokeAtSegments, 0		; That's all folks
	clc
all_done:
	popa
	pop	es
	pop	ds
cEnd

sEnd	CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\selman.asm ===
include	kernel.inc
include gpfix.inc
ifdef WOW
include protect.inc
endif

sBegin	DATA
globalW	sels, <1>			; end of list is 1 to fool DOS386 DPMI
globalW selscount, <0>			; length of selman16 list 
IF KDEBUG
externW  ArenaSel
externW  SelTableLen
externD  SelTableStart
ENDIF
sEnd    DATA

sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING
assumes FS,NOTHING
assumes GS,NOTHING

externFP AllocSelectorArray
externFP IFreeSelector
externW  gdtdsc
ifdef WOW
externNP DPMIProc
endif

	.386p


IF 0  ;KDEBUG - WOW doesn't have FastAndDirty... routines from win95 krn32.asm
extern	FastAndDirtyIsMovableHandle:far16
ENDIF

WOW_DPMIFUNC_0C equ 04f2h

;*********************************************************************
; MapSL - Maps a selector:offset pair to a linear address
;
; Arguments:	dAddrFar16 - selector:offset to map
;
; Returns:	eax   = linear address
;		dx:ax = linear address
;
; Register Usage: eax,ebx,edx
;
; *Must preserve es*. Some win32s thunking code depends on this.
;*********************************************************************
cProc   MapSL, <PUBLIC, FAR>
cBegin  nogen
        mov     bx,sp
	mov	bx, ss:[bx+4+2]		;Get selector
	test	bl, 4
	jz	MapSL_mightbegdt

IF 0  ;KDEBUG - WOW doesn't have FastAndDirty... routines from win95 krn32.asm
        push    bx
	push	es
	xor	cx,cx
	mov	es,cx

	push	bx
	call	FastAndDirtyIsMovableHandle
	or	ax,ax
	jz	MapSL_memok
	
	mov	bx,sp
	add	bx, 4
	mov	ax, ss:[bx+4+2]	;Get offending selector
	mov	dx, ss:[bx+2]	;Get return address seg
	mov	bx, ss:[bx]	;Get return address off
	krDebugOut	DEB_ERROR, "*** MapSL(16) called on unfixed selector #ax. Ret addr: #dx:#bx"

MapSL_memok:


	pop	cx
beg_fault_trap	MapSL_bad_es
MapSL_restore_es:
	mov	es,cx
end_fault_trap
	pop	bx
	jmp	MapSL_memchkdone


MapSL_bad_es:
	fault_fix_stack
	xor	cx,cx
	jmp	MapSL_restore_es

	
MapSL_memchkdone:

	
ENDIF  ;KDEBUG

        mov     gs, [gdtdsc]
        and     bl, not 7       ;Mask ring bits

	beg_fault_trap MapSL_fault_Trap
	test	byte ptr gs:[bx+5], 80h
	end_fault_trap
	jz	MapSL_invalid

	mov	ah, gs:[bx+7]		; get upper 8 bits base
	mov	al, gs:[bx+4]		; get next byte of base
	shl	eax, 16			; move to proper place
	mov	ax, gs:[bx+2]		; get lower 16 bits of base
	xor	edx, edx
	mov	bx, sp
	mov	dx, ss:[bx+4]		; get offset of current pointer
	add	eax, edx		; find complete 32 bit base


MapSL_exit2:
	xor	cx,cx		;Don't give apps access to the LDT
	mov	gs,cx
MapSL_exit:
	;; dx:ax <- eax
	shld	edx, eax, 16	;dx <- hiword of eax
        retf    4


;;--------------------------------------------------------------
;; Error case: Selector out of range.
;;--------------------------------------------------------------
MapSL_fault_trap:
	fault_fix_stack
IF KDEBUG
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "MapSL(#bx): out of range selector"
ENDIF
	xor	eax,eax
	jmp	MapSL_exit2


;;--------------------------------------------------------------
;; Error case: Selector not present
;;--------------------------------------------------------------
MapSL_invalid:
IF KDEBUG
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "MapSL(#bx): selector not present."
ENDIF
	xor	eax,eax
	jmp	MapSL_exit2


;;--------------------------------------------------------------
;; Potential error case: GDT selector or NULL?
;;--------------------------------------------------------------
MapSL_mightbegdt:
	or	bx,bx
	jnz	MapSL_gdt
;; Special case: Return original argument.
	mov	bx,sp
	mov	eax, ss:[bx+4]
	shld	edx, eax, 16	;dx <- hiword of eax
	retf	4


;;--------------------------------------------------------------
;; Error case: GDT selector
;;--------------------------------------------------------------
MapSL_gdt:
IF KDEBUG
	krDebugOut DEB_ERROR, "***MapSL(16) called on GDT selector #bx"
ENDIF
	xor	eax,eax
	jmp	MapSL_exit

cEnd    nogen






;****************************************************************
; MapLS - Allocate a new 64k limit selector that maps to linear address.
;
; Returns: Selector:offset in eax & dx:ax (offset is always zero).
; *Must preserve es because some win32s thunking code depends on it.*
;****************************************************************
cProc   MapLS, <PUBLIC, FAR>
cBegin  nogen
        mov     bx, sp
	mov	dx, ss:[bx+4+2]
	or	dx,dx
	jz	MapLS_special

        mov     gs, [gdtdsc]
	SetKernelDS fs
	mov	eax, ss:[bx+2]		;put lo-word in hi-half of eax
	mov	bx, fs:[sels]
	cmp	bx, 1
	jz	MapLS_moresel		;cache is empty: go to slow case
	
	mov	cx, gs:[bx]		;remove from linked list
	mov	fs:[sels], cx
	dec	fs:[selscount]

MapLS_gotit:
	and	bl, not 7
	or	ax, -1			;Set limit to 64k
	mov	gs:[bx], eax		;Init low half of descriptor

	xchg	dh, dl
	shl	edx, 16			;Put high 16 bits of base up hi
	mov	dl, 1+2+16+32+64+128	;accessed, write, app, ring3, present
	rol	edx, 8
	mov	gs:[bx+4], edx		;init upper half of descriptor
        mov     cx, 1
        DPMICALL  WOW_DPMIFUNC_0C ; Write shadow LDT entry thru to system LDT.
        mov     dx, bx
	or	dl, 7
	mov	ax, dx
        shl     eax, 16                 ;EAX = DX:AX = NEWSEL:0 = alias
MapLS_exit2:
	xor	cx,cx
	mov	gs,cx			;Don't give apps access to LDT
MapLS_exit:
	retf	4
	UnsetKernelDS fs

MapLS_special:
	mov	eax, ss:[bx+4]
	;; dx already has correct value
	retf	4

	UnsetKernelDS fs

;------------------------------------------------------------------------
; K16 selman cache is empty. Time to get more from krnl386.
;------------------------------------------------------------------------
MapLS_moresel:				; we need some more selectors here
	push	es
;Don't use more than one here. get_sel always takes
; multi-selector requests from DPMI, and these
; usually won't be given back because we'll free
; them one by one.
	cCall	AllocSelectorArray, <1>
	or	ax,ax
	jnz	MapLS_moreselendloop

;Uh oh.
	krDebugOut	DEB_ERROR, "MapLS(16): Couldn't get any more selectors!"
	xor	ax,ax
; Fall thru.

MapLS_moreselendloop:
 	krDebugOut	DEB_TRACE, "Selman(16) allocated selector #AX from KRNL386."
	pop	cx
beg_fault_trap MapLS_bades
MapLS_restore_es:
	mov	es,cx
end_fault_trap
	cwd				; put possible failure code in DX
	cwde				; and in EAX
	or	ax, ax
	jz	MapLS_exit2

	mov	gs, [gdtdsc]
	SetKernelDS fs

	xchg	bx,ax
	and	bl, not 7 

	push	bx
	mov	bx,sp
	add	bx, 2
	mov	dx, ss:[bx+4+2]
	mov	eax, ss:[bx+2]
	pop	bx
	jmp	MapLS_gotit

MapLS_bades:
	fault_fix_stack
	xor	cx,cx
	jmp	MapLS_restore_es


	UnsetKernelDS fs
cEnd    nogen

;***********************************************************************
; UnMapLS
;***********************************************************************

cProc   UnMapLS, <PUBLIC, FAR>
cBegin  nogen

if KDEBUG	
	mov	bx, sp
	push	ds
	mov	bx, ss:[bx+4+2]
	or	bx,bx
	jz	UnMapLS_ok
	test	bl, 4
	jz	UnMapLS_gdt
	or	bl, 7
	SetKernelDS
	mov	ax, [gdtdsc]
	lsl	dx,ax
	cmp	bx,dx
	ja	UnMapLS_pastldt
	mov	ds,ax
	UnsetKernelDS
	test	byte ptr ds:[bx-2], 080h
	jz	UnMapLS_notpresent
	SetKernelDS
	and	bl, not 7
	shr	bx, 1
	cmp	bx, [SelTableLen]
	jae	UnMapLS_notgh
	movzx	ebx,bx
	add	ebx, [SelTableStart]
	mov	ds, [ArenaSel]
	UnsetKernelDS
	mov	eax, ds:[ebx]
	or	eax,eax
	jnz	UnMapLS_gh
UnMapLS_notgh:
	;Fallthru
UnMapLS_ok:
	pop	ds
endif
	mov	bx, sp
	mov	bx, ss:[bx+4+2]
	and	bl, not 7			; point to LDT entry
	jz	UnMapLS_null
		

	xor	eax,eax
	mov	es,eax		;In case es contains selector we're trashing
				; fs and gs are loaded below.

if KDEBUG
	mov	ax, ss
	and	al, not 7
	cmp	ax, bx
	je	UnMapLS_inuse
	xor	ax, ax
endif

	SetKernelDS fs
	mov	gs, [gdtdsc]
if KDEBUG
        test    WORD PTR gs:[bx+5], 80h
	jz	UnMapLS_invalid
endif
	mov	ax, fs:[sels]
	mov	gs:[bx], eax			; linked list of avail sels
	xor	eax,eax
	mov	gs:[bx+4], eax			; zero out entry
	mov	fs:[sels], bx			; new list head sel
	inc	fs:[selscount]

UnMapLS_checkcount:
if KDEBUG
	cmp	fs:[selscount], 4
else
	cmp	fs:[selscount], 42
endif
	jb	UnMapLS_Null

	dec	fs:[selscount]
	mov	bx, fs:[sels]
	mov	ax, gs:[bx]	
	mov	fs:[sels],ax

; Make it look like a valid limit-1 selector so FreeSelector doesn't
; free the ones after it.
	mov	dword ptr gs:[bx], 1
	mov	dword ptr gs:[bx+4], 0000f300h
	or	bx, 7
	push	ds
	push	es
	push	fs
	push	gs
	push	bx
	xor	cx,cx	;Just in case of one these registers contained
	mov	ds,cx	;the segment being freed.
	mov	es,cx
        cCall   IFreeSelector,<bx>
	pop	bx
	pop	gs
	pop	fs
	pop	cx
beg_fault_trap	UnMapLS_bades
UnMapLS_restore_es:
	mov	es,cx
end_fault_trap
	pop	cx
beg_fault_trap	UnMapLS_badds
UnMapLS_restore_ds:
	mov	ds,cx
end_fault_trap
	krDebugOut DEB_TRACE, "Selman(16) returning selector #BX to KRNL386"

	jmp	UnMapLS_checkcount

UnMapLS_null:
	xor	eax, eax			; EAX = DX:AX = 0 (OK)
	cwd
	mov	gs,ax				; Cut off access to LDT
UnMapLS_exit:
	retf	4

UnMapLS_bades:
	fault_fix_stack
	xor	cx,cx
	jmp	UnMapLS_restore_es

UnMapLS_badds:
	fault_fix_stack
	xor	cx,cx
	jmp	UnMapLS_restore_ds

if KDEBUG
UnMapLS_invalid:
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) invalid selector"
	or	al, 1				; AX != 0
	jmps	UnMapLS_exit

UnMapLS_inuse:
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) attempting to free ss"
	or 	al, 1                           ; AX != 0
	jmps	UnMapLS_exit
UnMapLS_gdt:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) GDT selector. Type 'k'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_pastldt:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector out of range. Type 'k'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_notpresent:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector not present. Probably part of a freelist! Type 'k' and '.wl'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.

UnMapLS_gh:
	mov	bx,sp
	add	bx,2
	mov	bx, ss:[bx+4+2]
	krDebugOut	DEB_ERROR, "UnMapLS(#bx) Selector is a global handle! Type 'k' and '.dg'"
	jmp	UnMapLS_ok  ;in trouble if ignores this.


endif

	

cEnd    nogen


sEnd	CODE
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\tasking.asm ===
TITLE   TASKING.ASM - WOW Tasking Support
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; TASKING.ASM
; WOW Tasking Support on 16 bit side - also see wkman.c
;
; History:
;   23-May-91   Matt Felton (mattfe) Created
;   12-FEB-92   Cleanup
;

.xlist
include kernel.inc
include tdb.inc
include newexe.inc
include wow.inc
include vint.inc
.list

if PMODE32
.386
else
.286
endif


if KDEBUG
externFP OutputDebugString
endif

DataBegin

externB Kernel_InDOS
externB Kernel_flags
externB InScheduler
ifndef WOW
externB fProfileDirty
endif
externW WinFlags
externW cur_drive_owner
externW curTDB
externW Win_PDB
externW LockTDB
externW headTDB
externW hShell
externW pGlobalHeap
externW hExeHead
externW f8087
externD pIsUserIdle
externW wCurTaskSS
externW wCurTaskBP

globalw gwHackpTDB,0
globalw gwHackTaskSS,0
globalw gwHackTaskSP,0

if PMODE32
externW PagingFlags
endif

DataEnd


ifdef WOW
externFP ExitKernelThunk
externFP WowInitTask
externFP Yield
externFP WOW16CallNewTaskRet
externFP WowKillTask
externFP WOW16DoneBoot
externFP WOWGetCurrentDirectory
externFP ExitCall
externFP WowSyncTask
endif


sBegin  CODE
assumes cs,CODE
assumes ds,NOTHING
assumes es,NOTHING

ife PMODE
externNP patch_cached_p
endif
externNP LoadSegment
externNP DeleteTask
externNP InsertTask
if PMODE32
externNP ShrinkHeap
endif

ifdef WOW
externNP Int21Handler
endif

if SDEBUG
externNP DebugSwitchOut
externNP DebugSwitchIn
endif

;-----------------------------------------------------------------------;
; StartWOWTask                              ;
;                                   ;
; Start a WOW 32 Task                           ;
;                                   ;
; Arguments:                                ;
;   Parmw1 -> TDB Of New Task                   ;
;   Parmw2    New Task SS                       ;
;   Parmw3    New Task SP                       ;
; Returns:                              ;
;   AX - TRUE/FALSE if we we able to create a new WOW task      ;
; Error Returns:                            ;
;   none                                ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;   BX,CX,DX                            ;
; Calls:                                ;
;   See Notes                           ;
; History:                              ;
;                                   ;
;  Fre 24-May-1991 14:30  -by-  Matthew A. Felton [mattfe]      ;
; Created                               ;
;-----------------------------------------------------------------------;

;   The 16-Bit Kernel has created the new task and its ready to go
;   1.  Temporarily Switch to New Task Stack S2
;   2.  Fake Far Return from Thunk to point to StartW16Task
;   3.  Thunk to WOW32 - This will create a new Thread and call Win32 InitTask()
;   Note InitTask() will not return from the non-preemptive scheduler until
;   This thread does a Yield.
;   4.  When the thunk returns is jmps to WOW16TaskStarted on S2 leaving
;   S2 ready for the new task when it returns
;   5.  Restore S1 - Original Task Stack
;   6.  Return Back to LoadModule who will Yield and start T2 going.

    assumes ds, nothing
    assumes es, nothing

cProc   StartWOWTask,<PUBLIC,FAR>
    parmW pTDB
    parmW wTaskSS
    parmW wTaskSP

cBegin
    SetKernelDS ds

    mov es,pTDB     ; Get New Task TDB, will use later
    push    curTDB      ; Save our TDB
    push    bp      ; save BP (we don't exit wow16cal directly)
    mov di,ss       ; Save Current Task Stack
    mov cx,sp       ; di=ss cx=sp

; switch to new task stack temporarily

    FCLI         ; Disable Ints Till We get Back
                ; To presever new fram
    mov si,wTaskSP  ; Grab this before SS goes away
    mov ss,wTaskSS  ; Switch to new task stack.
    mov sp,si       ;

    mov curTDB,es   ; Set curTDB to new task
                ;
    pushf
    pop ax
    or ax,0200h     ; Re-enable interrupts
    push ax

    push    es                      ; hTask

    mov es, es:[TDB_pModule]   ; exehdr

    mov ax, es:[ne_expver]
    mov dx, es:[ne_flags]
    and dx, NEWINPROT          ; prop. font bit

    push    es                      ; hModule
    push    es                      ; Pointer to module name
    push    es:ne_restab
    push    es                      ; Pointer to module path
    push    word ptr es:ne_crc+2

    push dx                    ; expwinver. argument for WOWINITTASK
    push ax

    mov es, curTDB             ; resotre es, just being safe


; thunk to wow32 to create a thread and task

    push    cs          ; Fake Out FAR Return to StartW16Task
    push    offset StartW16Task

    jmp WowInitTask     ; Start Up the W32 Thread

    public WOW16TaskStarted
WOW16TaskStarted:
    mov ss,di           ; Restore Calling Task Stack
    mov sp,cx
    pop bp
    pop curTDB          ; Restore real CurTDB
    FSTI             ; OK we look like old task

cEnd


;
;   First code executed By New Task - Setup Registers and Go
;

StartW16Task:
    add sp,+12
    pop ax              ; Flags
    mov bp,sp
    xchg ax,[bp+20]     ; Put flags down & pick up cs
    xchg ax,[bp+18]     ; Put cs down & pick up ip
    xchg ax,[bp+16]     ; Put ip down & pick up bp
    mov  bp,ax
    dec  bp
    pop dx
    pop bx
    pop es
    pop cx
    pop ax
    pop di
    pop si
    pop ds
    call SyncTask
    iret                ; App Code Starts From Here

;   ExitKernel
;
;   Enter When the 16 bit Kernel is going away -- never returns.
;   In WOW this is a register-args wrapper for the stack-args
;   thunk ExitKernelThunk.

    public  ExitKernel
    ExitKernel:

    cCall   ExitKernelThunk, <ax>

    INT3_NEVER                ; ExitKernel never returns.


;   BootSchedule
;
;   Entered When Bogus Boot Task goes Away - treated same as task exit.

    public  BootSchedule
BootSchedule:
    CheckKernelDS   DS      ; Make Sure we Address Kernel DS
    mov [curTDB],0      ; Make No Task the Current Task
    jmp WOW16DONEBOOT

;   ExitSchedule
;
;   We get here when a 16 bit task has exited - go kill this task
;   Win32 non-preemptive scheduler will wake someone else to run.

    public  ExitSchedule
ExitSchedule:
    CheckKernelDS   DS	    ; Make Sure we Address Kernel DS

    mov     ax,[LockTDB]    ; If I am the locked TDB then clear flag
    cmp     ax,[curTDB]
    jnz     @f
    mov     [LockTDB],0
@@:
    mov [curTDB],0	; Make No Task the Current Task
if PMODE32
    call    ShrinkHeap
endif; PMODE32
    jmp WowKillTask     ; Go Kill Myself (NEVER RETURNS)



;-----------------------------------------------------------------------;
; SwitchTask - This is NOT a subroutine DO NOT CALL IT
;
; This routine does a Win 3.1 compatible task switch.
;
; Arguments:
;   AX == Next Tasks TDB pointer
; Returns:
;   nothing
; Error Returns:
;   nothing
; Registers Preserved:
;
; Registers Destroyed:
;
; Calls:
;   SaveState
;   RestoreState
;
; History:
;   22-May-91	Matt Felton (MattFe) Created
;   Using idea's from Win 3.1 Schedule.Asm
;
;-----------------------------------------------------------------------;

    assumes ds, nothing
    assumes es, nothing

    public  SwitchTask
SwitchTask:
    CheckKernelDS ds
    ReSetKernelDS ds

    inc InScheduler	; set flag for INT 24...

    cmp curTDB,0        ; Previous Task Gone Away ?
    jnz @f		; No ->

			; Yes
    mov di,ax           ; DI = New TDB
    mov ds,ax           ; DS = New TDB
    jmps    dont_save_state     ; Get Set for this new guy

@@:
    push    ax          ; Save Next Tasks TDB pointer

; COMPAT 22-May-91 Mattfe, Idle callout for funky screen drivers is done by
; the Windows scheduler - that will not happen either from WOW. INT 28
; and Win386 1689 int2f call

; There was PokeAtSegments code which during idle time brought back segments !

; Do Debuggers Care that the stack frame of registers looks like a Windows stack frame
; when we do the debugger callout ? - check with someone in CVW land.

    mov es,curTDB       ; ES = Previous Task TDB

    mov ax,es           ; Don't SS,SP For DEAD Task
    or  ax,ax
    jz  @F

    mov ax,wCurTaskSS       ; FAKE Out TDB_taskSS,SP so that
    mov es:[TDB_taskSS],ax  ; The Old Task Task_BP looks right
    mov ax,wCurTaskBP
    sub ax,(Task_BP-Task_DX)
    mov es:[TDB_taskSP],ax

@@:
    pop ds          ; DS = Next Task TDB
    UnSetKernelDS   ds

if KDEBUG

; Assertion Check TDB_taskSS == SS for current Task

    mov ax,ds:[TDB_taskSS]
    mov di,ss
    cmp di,ax
    jz  @F

;   int 3
@@:
endif; KDEBUG

    mov di,ds           ; DI = destination task
    xor si,si           ; SI is an argument to RestoreState

    mov ax,es           ; NOTE TDB_SS,SP Are note Correct
    or  ax,ax           ; might affect debugger compatability.
    jz  short dont_save_state

    cmp es:[TDB_sig],TDB_SIGNATURE
    jnz short dont_save_state
    mov si,es           ; SI = Old Task


    cCall   SaveState,<si>
if SDEBUG
    push    ds
    mov ds,ax
    call    DebugSwitchOut      ; Note Stack Frame is not Compatible
    pop ds                      ; Do we care ?
endif
dont_save_state:
    SetKernelDS es
    mov curTDB,di

    mov ax, ds:[TDB_PDB]    ; Set our idea of the PDB
    mov Win_PDB, ax

    SetKernelDS es

    cmp di,0            ; the first task, will never get 0
    jz  dont_restore_state

ife PMODE
    call    RestoreState
endif
    or  Kernel_flags,kf_restore_CtrlC OR kf_restore_disk
if SDEBUG
    call    DebugSwitchIn
endif

dont_restore_state:
    ; Switch to new task stack.
    mov curTDB,di
    dec InScheduler     ; reset flag for INT 24

    SetKernelDS ds          ; Set the Kernel DS again

;the word at [vf_wES] is a selector that's about to be popped into
;the ES in WOW16CallNewTaskRet.  this selector could be the TDB of
;a task that just died, in which case it's invalid.  so let's
;shove something in there that won't cause a GP when we do the POP ES.
;
; In some cases we are switching tasks while returning to a callback.
; When this happens our stack is a CBVDMFRAME instead of a VDMFRAME.
; We only want to shove a safe ES,FS,GS value when it's a VDMFRAME and
; we're returning from an API call rather than calling back to
; 16-bit code.
;
; Regardless of which frame we're using, ss:sp points to wRetID.


    mov     bx, sp
    cmp     WORD PTR ss:[bx], RET_DEBUGRETURN  ; if (wRetID > RET_DEBUGRETURN)
    ja      dont_stuff_regs                    ;     goto dont_stuff_regs

    sub     bx,vf_wTDB + 2       ;bx is now start of VDMFRAME struct
    mov     ss:[bx+vf_wES],es    ;put something safe in there
;Win31 does not save fs, gs over task switches, so we zero them out here
    mov     word ptr ss:[bx+vf_wFS],0    ;put something safe in there
    mov     word ptr ss:[bx+vf_wGS],0    ;put something safe in there
dont_stuff_regs:


if KDEBUG
    mov     bx, sp
    cmp     WORD PTR ss:[bx], RET_TASKSTARTED
    jne     @f
    INT3_NEVER ; We need to stuff ES for RET_TASKSTARTED
               ; if we hit this breakpoint.
@@:
endif

; Hung App Support
; If the new task is the one we want to kill then force it to exit

    mov     bx,curTDB	    ; if ( curTDB == LockTDB )
    cmp     bx,LockTDB
    jnz     SW_DontKillIt

    mov     ax,4CFFH	    ;	YES -> Exit
    DOSCALL
    INT3_NEVER

SW_DontKillIt:
    jmp WOW16CallNewTaskRet ; Continue with the new task.


;-----------------------------------------------------------------------;
; SaveState                                                             ;
;                                   ;
; Saves the state of the current MS-DOS process.  This means the per    ;
; task interrupt vectors, the drive and directory, EEMS land if any,    ;
; and old app stuff if any.                     ;
;                                   ;
; Arguments:                                ;
;   parmW   destination                     ;
;                                   ;
; Returns:                              ;
;   DS returned in AX.                      ;
;                                   ;
; Error Returns:                            ;
;                                   ;
; Registers Preserved:                          ;
;                                   ;
; Registers Destroyed:                          ;
;                                   ;
; Calls:                                ;
;                                   ;
; History:                              ;
;                                   ;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]     ;
; Removed the WinOldApp support.                    ;
;                                   ;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw]      ;
; Got rid of the rest of the DOS version dependencies.          ;
;                                   ;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]      ;
; Took out the saving of the ^C state, DTA address, and ErrorMode.  ;
;                                   ;
;  Sun Jan 04, 1987 04:40:44p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

    assumes ds, nothing
    assumes es, nothing

cProc   SaveState,<PUBLIC,NEAR>,<si,di,ds>
    parmW   destination
cBegin
    cld
ife PMODE
    SaveTaskInts destination
endif
    SetKernelDS
    mov ax,f8087
    UnSetKernelDS
    mov ds,destination
    or  ax,ax
if 0
    jz  short no_fstcw
    .8087
    fstcw   ds:[TDB_FCW]
endif
no_fstcw:
    test    ds:[TDB_Drive],10000000b; if hi bit set....
    jnz short ss_ret            ; ...no need to get dir
    mov ah,19h
    DOSCALL
    mov dl,al
    inc dl
    or  al,10000000b
    mov ds:[TDB_Drive],al   ; save it (A=0, B=1, etc.)

    mov si,TDB_LFNDirectory
    mov byte ptr [si],'\'   ; set "\"
    inc si
    ; get Long path
    cCall WowGetCurrentDirectory,<80h, ds, si>
    or  dx, dx
    jz  short ss_ret
    mov byte ptr [si-1],0   ; indicate error with null byte
ss_ret: mov ax,ds
cEnd


;-----------------------------------------------------------------------;
; RestoreState                              ;
;                                   ;
; Restores the MS-DOS interrupt vectors in real mode.           ;
;                                   ;
; Arguments:                                ;
;   none                                ;
; Returns:                              ;
;   none                                ;
; Error Returns:                            ;
;   none                                ;
; Registers Preserved:                          ;
;   BX,CX,DX,DI,SI,DS,ES                        ;
; Registers Destroyed:                          ;
;   AX                              ;
; Calls:                                ;
;   nothing                             ;
; History:                              ;
;                                   ;
;  Mon 07-Aug-1989 21:53:42  -by-  David N. Weise  [davidw]     ;
; Removed the WinOldApp support.                    ;
;                                   ;
;  Tue Feb 03, 1987 08:21:53p  -by-  David N. Weise   [davidw]      ;
; Got rid of the rest of the DOS version dependencies.          ;
;                                   ;
;  Thu Jan 22, 1987 03:15:15a  -by-  David N. Weise   [davidw]      ;
; Took out the restoring of the ^C state, DTA address, and ErrorMode.   ;
;                                   ;
;  Sun Jan 04, 1987 04:45:31p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                   ;
;-----------------------------------------------------------------------;

ife PMODE

    assumes ds, nothing
    assumes es, nothing

cProc   RestoreState,<PUBLIC,NEAR>

cBegin nogen
    push    di
    push    si
    push    ds
    push    es
    cld
    RestTaskInts di         ; restore DOS interrupts
    pop es
    pop ds
    pop si
    pop di
    ret
cEnd nogen

endif ; PMODE

;   SyncTask
;
;   Enter: when new task starts
;          check if the new task is blocked by appshelp
cProc   SyncTask,<PUBLIC,NEAR> <ax,bx,cx,dx,di,si,es,ds>
cBegin
STL:
        cCall   WowSyncTask
        cmp     ax, 0
        je      @F
        jg      STL
        call    ExitCall
@@:
cEnd

sEnd    CODE
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ripaux.asm ===
;-----------------------------------------------------------------------;
;									;
;   RIPAUX.ASM -							;
;									;
;	Debugging Support Routines					;
;									;
;-----------------------------------------------------------------------;

		TITLE	RIPAUX.ASM - Debugging Support Routines

;-----------------------------------------------------------------------;
;   INCLUDES								;
;-----------------------------------------------------------------------;

?RIPAUX = 1
.xlist
win3deb = 1
include kernel.inc
include newexe.inc
.list

;-----------------------------------------------------------------------;
;   DATA SEGMENT DEFINITION						;
;-----------------------------------------------------------------------;

DataBegin

externD  pDisableProc

if ROM
externD prevInt21Proc
endif


if KDEBUG

externW  fWinX
externW  hExeHead
externB  szDebugStr

externW  DebugOptions
externW  DebugFilter
externB  fKTraceOut                ; Used by DebugWrite to ignore traces
else

externB  szExitStr1
externB  szExitStr2
externB  szFatalExit

endif

DataEnd

ifdef WOW
externFP FatalExitC
endif

;-----------------------------------------------------------------------;
;   CODE SEGMENT DEFINITION						;
;-----------------------------------------------------------------------;

sBegin	CODE

assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING


;-----------------------------------------------------------------------;
;   EXTERNS								;
;-----------------------------------------------------------------------;

externFP ExitKernel
externFP FatalAppExit

if KDEBUG

externFP KOutDebugStr
externNP DebugOutput2
externNP LogParamError2

else

ife ROM
externD  prevInt21Proc
endif
externFP InternalDisableDOS

endif

externNP DebugLogError
externNP DebugLogParamError


; SAVEREGS - Preserve all registers
;
SAVEREGS    macro
if PMODE32
.386
	push	ds	  ; preserve all registers
	push    es
	push    fs
	push    gs
	pushad
.286p
else
	push	ds
	push    es
	pusha
endif;  PMODE32
endm

; RESTOREREGS - Restore registeres preserved with SAVEREGS
;
RESTOREREGS macro
if PMODE32
.386
	popad
	pop	gs
	pop	fs
	pop	es
	pop	ds
.286p
else
	popa
	pop     es
	pop	ds
endif;  PMODE32
endm

; In Win3.1, different code is used for FatalExit on retail
; and debug builds.  WOW uses the code below derived from the
; debug wrapper for FatalExitC.  FatalExitC is a thunk to
; WOW32's WK32FatalExit thunk.


cProc FatalExit,<PUBLIC,FAR>
	parmW	errCode
cBegin nogen
	push	bp
	mov	bp, sp
	push	ds
	pusha
	setkernelds
        push    [bp+6]
        cCall   FatalExitC
        popa
	pop	ds
        INT3_DEBUG      ; Stop here so WDEB386 can generate same stack trace.
        pop     bp
	ret     2
cEnd nogen

if KDEBUG

BegData
szCRLF  db      13,10,0
EndData

; trashes ES - but caller saves it
cProc	KOutDSStr,<PUBLIC,FAR>,<ds>
	parmW	string
cBegin

if PMODE32
.386p
	pushad				; save upper 16 bits of EAX, etc
	push	fs
	push	gs
.286p
endif
	pushf
	push	cs
	push	ds
	push	es
	push	ss
	pusha
	SetKernelDS

	mov	si,string
	call	KOutDebugStr		; expects pusha right before call
	popa
	add	sp, 8			; don't need to restore seg regs
	popf
if PMODE32
.386p
	pop	gs
	pop	fs
	popad
.286p
endif
cEnd

cProc   _krDebugTest,<PUBLIC, FAR, NONWIN>,<DS>
	ParmW   flags
	ParmW	psz
	LocalW	axSave
	LocalW	bxSave
	LocalW	esSave
	LocalB	fBreakPrint
cBegin
	assumes ds,NOTHING
	mov	axSave,ax	; save these regs before they're trashed
	mov	bxSave,bx
	mov	esSave,es

;
; If this .exe hasn't been relocated yet, just call FatalExit.
;
	mov     ax,cs:MyCSDS
	cmp     ax,1000h        ;; DATA should be selector, not addr
	jc      @F
	jmp     kdtnobreak
@@:
	mov     es,ax
assumes es,DATA
;
; First use DebugOptions to determine whether we should print anything
; and/or break with a fatalexit.
;
	errnz   low(DBF_SEVMASK)
	errnz   low(DBF_TRACE)
	errnz   low(DBF_WARNING)
	errnz   low(DBF_ERROR)
	errnz   low(DBF_FATAL)

	mov     bx,es:DebugOptions
	mov     ax,flags
	and     ah,high(DBF_SEVMASK)
	mov     al,2                ; fBreak = FALSE, fPrint = TRUE
	cmp     ah,high(DBF_TRACE)
	jnz     notrace

	push    ax
	mov     es:fKTraceOut, 1    ; Set flag for DebugWrite
	mov     ax,flags            ; if (!((flags & DBF_FILTERMASK) & DebugFilter))
	and     ax,DBF_FILTERMASK
	test    ax,es:DebugFilter
	pop     ax
	jnz     @F
	and     al,not 2            ;    fPrint = FALSE
	jmp     short kdtnobreak
@@:
	test    bx,DBO_TRACEBREAK   ; else if (DebugOptions & DBO_TRACEBREAK)
	jnz     kdtbreak            ;    fBreak = TRUE
	jmp     short kdtnobreak

notrace:
	cmp     ah,high(DBF_WARNING)
	jnz     nowarn
	test    bx,DBO_WARNINGBREAK
	jnz     kdtbreak
	jmp     short kdtnobreak
nowarn:
	cmp     ah,high(DBF_ERROR)
	jnz     dofatal
	test    bx,DBO_NOERRORBREAK
	jnz     kdtnobreak
	jmp     short kdtbreak
dofatal:
	test    bx,DBO_NOFATALBREAK
	jnz     kdtnobreak
	errn$   kdtbreak
kdtbreak:
	or      al,1            ; fBreak = TRUE
kdtnobreak:
;
; If DBO_SILENT, then fPrint = FALSE
;
	test    bx,DBO_SILENT
	jz      @F
	and     al,not 2
@@:
	mov     fBreakPrint,al
;
; if (fBreak || fPrint)
;    print out the string
;
	or      al,al           ; if !(fBreak | fPrint)
	jz      kdtnoprint

assumes es,NOTHING
	mov	es,esSave	; restore registers
	mov	ax,axSave
	mov	bx,bxSave
	push    psz
	call    KOutDSStr       ; output the string

ifndef WOW
	push    offset szCRLF
        call    KOutDSStr
endif

kdtnoprint:
	test    fBreakPrint,1   ; if fBreak, then FatalExit
	jz      kdtexit
kdtdobreak:
	cCall   FatalExit,<flags>
kdtexit:
	SetKernelDS es
	mov	es:fKTraceOut,0 ; Clear DebugWrite flag

	mov	ax, axSave
	mov	bx, bxSave
	mov	es, esSave
cEnd

ifdef DISABLE

flags	equ	word ptr [bp+6]
msg	equ	word ptr [bp+8]
appDS	equ	word ptr [bp-2]
appAX	equ	word ptr [bp-4]
;myDS	equ	word ptr [bp-6]
_krDebugTest proc far			;Per-component - check right flags
public _krDebugTest
	push	bp
	mov	bp, sp
	push	ds			; at BP-2
	push	ax			; at BP-4
	mov	ax, _DATA
	cmp	ax, 1000h		;; DATA should be selector, not addr
	jnc	skip
	mov	ds, ax
	assume	ds:_DATA

	mov	ax, [flags]		; See if component enabled
	and	ax, [_krInfoLevel]
	and	al, byte ptr [_Win3InfoLevel] ; See if system enabled
	cmp	ax, [flags]
	jnz	skip

	push	bx            		; Print it, so format message
	test	al, DEB_ERRORS
	mov	bx, dataoffset STR_krError
	jnz	@F
	test	al, DEB_WARNS
	mov	bx, dataoffset STR_krWarn
	jnz	@F
	test	al, DEB_TRACES
	mov	bx, dataoffset STR_krTrace
	jz	short deb_no_msg_type

@@:	push	bx
	call	KOutDSStr

deb_no_msg_type:
	mov	bx, dataoffset STR_krTable
	or	ah, ah
	jz	deb_show_it
@@:     add	bx, 2			; get next string table entry
	shr	ah, 1			; find which category
	jnz	@B

deb_show_it:
	push	[bx]			;; push parameter
	call	KOutDSStr
	pop	bx			;; restore reg

	mov	ax, [appAX]		; print message passed in
	push	ds
	mov	ds, appDS               ; restore App ds for error strings
	push	[msg]
	call	KOutDSStr
	pop	ds			; restore kernel DS

	mov	ax, [flags]		; shall we have a breakpoint?
	and	ax, [_krBreakLevel]
	and	al, byte ptr _Win3BreakLevel
	cmp	ax, [flags]
	jnz	skip

	INT3_DEBUG
skip:
	test    byte ptr [flags], DEB_FERRORS
	jz	@F

        push    0
        push    cs:MyCSDS
	push	word ptr [bp+8]
	cCall	FatalAppExit	;,<0,DGROUP,[bp+8]>
@@:
	pop	ax
	pop	ds
	pop	bp
	retf
_krDebugTest endp
endif;  DISABLE

endif;  KDEBUG

ife KDEBUG			; RETAIL ONLY SECTION STARTS HERE!

ifndef WOW                      ; WOW uses only the "debug" version
                                ; of FatalExit which calls FatalExitC.
                                ; FatalExitC is thunked in WOW, the
                                ; version in rip.c is disabled.

;-----------------------------------------------------------------------;
;									;
;   FatalExit() -							;
;									;
;-----------------------------------------------------------------------;

; Retail version.  The Debug version is in RIP.C.

	assumes	ds, nothing
	assumes	es, nothing

cProc FatalExit,<PUBLIC,FAR>
	parmW	errCode
cBegin
	SetKernelDS
        push    0
	push    ds
	push    dataOffset szFatalExit
	cCall   IFatalAppExit   ;,<0, ds, dataOffset szUndefDyn>
cEnd

cProc FatalExitDeath,<PUBLIC,FAR>

	parmW	errCode

	localD	pbuf
	localV	buf,6
cBegin

if 0
	mov	ax,4CFFh
	int	21h
else
	SetKernelDS
	cCall	TextMode		; Is USER started?

;	cmp	pDisableProc.sel,0
;	je	fex1
;	cCall	pDisableProc		; Yes, Call USER's DisableOEMLayer()
;					;  to get to the text screen
;	jmps	fex1a
;fex1:
;	mov	ax, 6			; set text mode
;	int	10h
;fex1a:

; Is Int 21h hooked?

	cmp	prevInt21Proc.sel,0
	je	fex2
	cCall	InternalDisableDOS	; Yes, disable Int 21h

fex2:
	mov	cx,errCode		; No output if error code is zero
	jcxz	fe4

; Write "FatalExit = " message to STDOUT.

	mov	bx,1
	mov	dx,dataOffset szExitStr1
	mov	cx,20
	mov	ah,40h
	int	21h

; Error code of FFFF means Stack Overflow.

	mov	dx,errCode
	inc	dx
	jnz	fe1
	mov	dx,dataOffset szExitStr2 ; "Stack Overflow" message
	mov	cx,17
	mov	ah,40h
	int	21h
	jmps	fe4

	UnSetKernelDS
fe1:

; Write out error code in Hex.

	dec	dx
	push	ss
	pop	es
	lea	di,buf
	mov	ax,'x' shl 8 OR '0'
	stosw
	mov	cx,4
	rol	dx,cl			    ; Rotate most significant into view
fe2:
	mov	ax,dx
	and	ax,0Fh
	push	cx
	mov	cl,4
	rol	dx,cl			    ; Rotate next byte into view
	pop	cx
	add	al,'0'
	cmp	al,'9'
	jbe	fe3
	add	al,'A'-':'
fe3:
	stosb
	loop	fe2
	mov	ax,10 shl 8 OR 13
	stosw
	xor	ax,ax
	stosb
	lea	dx,buf
	push	ss
	pop	ds
	mov	cx,8
	mov	bx,1
	mov	ah,40h
	int	21h			    ; Write it out
fe4:
	mov	ax,errcode
	cCall	ExitKernel,<ax>
endif
cEnd

endif       ; ifndef WOW

else				    ; DEBUG ONLY SECTION STARTS HERE!

;-----------------------------------------------------------------------;
;									;
;   GetSymFileName() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetSymFileName,<PUBLIC,FAR>,<ds,si,di>
else
cProc GetSymFileName,<PUBLIC,NEAR>,<ds,si,di>
endif

ParmW hExe
ParmD lpName

cBegin
	cld
	les	di,lpName
	SetKernelDS
;;	cmp	fWinX,0
;;	je	slowboot
;;	mov	ax,hExe
;;	cmp	hExeHead,ax
;;	mov	ds,ax
;;	UnSetKernelDS
;;	je	makename
;;	mov	si,ds:[ne_pfileinfo]
;;	or	si,si
;;	jnz	havename
;;makename:
;;	mov	si,ds:[ne_restab]
;;	xor	ax,ax
;;	lodsb
;;	mov	cx,ax
;;	rep	movsb
;;appendext:
;;	mov	ax,'S.'
;;	stosw
;;	mov	ax,'MY'
;;	stosw
;;	xor	ax,ax
;;	stosb
;;	jmps	namedone
;;
;;slowboot:
	mov	ds,hExe
	mov	si,ds:[ne_pfileinfo]
havename:
	add	si,opFile
nameloop:
	lodsb
	cmp	al,'.'
	je	appendext
	stosb
	jmp	nameloop
appendext:
	mov	ax,'S.'
	stosw
	mov	ax,'MY'
	stosw
	xor	ax,ax
	stosb
	les	ax,lpName
	mov	dx,es
cEnd


;-----------------------------------------------------------------------;
;									;
;   OpenSymFile() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc OpenSymFile,<PUBLIC,FAR>,<ds,si,di>
else
cProc OpenSymFile,<PUBLIC,NEAR>,<ds,si,di>
endif

ParmD	path

LocalV	Buffer,MaxFileLen

cBegin
	lds	dx,path		; get pointer to pathname
	mov	di,3D40h	; open file function code (SHARE_DENY_NONE)

	; We don't use open test for existance, rather we use get
	; file attributes.  This is because if we are using Novell
	; netware, opening a file causes Novell to execute its
	; own path searching logic, but we want our code to do it.

	mov	ax,4300h		; Get file attributes
	int	21h			; Does the file exist?
	jc	opnnov			; No, then don't do the operation
	mov	ax,di			; Yes, open the file then
	int	21h
	jnc	opn2
opnnov:
	mov	ax, -1
opn2:	mov	bx,ax
cEnd




;-----------------------------------------------------------------------;
;									;
;   GetDebugString() -							;
;									;
;-----------------------------------------------------------------------;

; Finds the 'strIndex'-th string in 'szDebugStr'.  The strings are defined
;  in STRINGS.ASM.

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetDebugString,<PUBLIC,FAR>,<di>
else
cProc GetDebugString,<PUBLIC,NEAR>,<di>
endif

parmW	strIndex

cBegin
	SetKernelDS	es
	mov	di,dataOffset szDebugStr
	mov	bx,strIndex
	cld
gds1:
	dec	bx
	jl	gdsx
	xor	ax,ax
	mov	cx,-1
	repne	scasb
	cmp	es:[di],al
	jne	gds1
	xor	di,di
	mov	es,di
gdsx:
	mov	ax,di
	mov	dx,es
	UnSetKernelDS	es
cEnd


;-----------------------------------------------------------------------;
;									;
;   GetExeHead() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

ifdef WOW
cProc GetExeHead,<PUBLIC,FAR>
else
cProc GetExeHead,<PUBLIC,NEAR>
endif

cBegin	nogen
	push	ds
	SetKernelDS
	mov	ax,[hExeHead]
	pop	ds
	UnSetKernelDS
	ret
cEnd	nogen


;-----------------------------------------------------------------------;
;									;
;   LSHL() -								;
;									;
;-----------------------------------------------------------------------;
ifdef WOW
if KDEBUG
sEnd	CODE
sBegin  MISCCODE
assumes cs, MISCCODE
endif
endif

	assumes	ds, nothing
	assumes	es, nothing

cProc LSHL,<PUBLIC,NEAR>
cBegin	nogen
	pop	bx
	pop	cx
	pop	ax
	xor	dx,dx
lshl1:
	shl	ax,1
	rcl	dx,1
	loop	lshl1
	jmp	bx
cEnd	nogen

ifdef WOW
if KDEBUG
sEnd    MISCCODE
sBegin	CODE
assumes CS,CODE
endif
endif

;-----------------------------------------------------------------------;
;									;
;   FarKernelError() -							;
;									;
;	05-09-91 EarleH modified to save and restore all registers.	;
;									;
;-----------------------------------------------------------------------;

; Far entry point for KernelError().  Allows the multitude of calls to
; KernelError() be made as near calls.

	assumes	ds, nothing
	assumes	es, nothing

cProc FarKernelError,<PUBLIC,FAR,NODATA>

cBegin nogen
	push	bp
	mov	bp,sp

	SAVEREGS
	mov	ax, _DATA
	mov	ds, ax
;	push	[bp+14]
	push	[bp+12]
	push	ds		; seg of string
	push	[bp+10]
	push	[bp+8]
	push	[bp+6]
	mov	bp,[bp]
ifdef WOW
    cCall	<far ptr Far_KernelError>
else
    call    KernelError
endif
	or	ax, ax
	RESTOREREGS
	pop	bp
	jz	@F
	INT3_DEBUG
@@:
	ret	10
cEnd	nogen

;-----------------------------------------------------------------------;
;									;
;   NearKernelError() -							;
;									;
;	05-09-91 EarleH modified to save and restore all registers.	;
;									;
;-----------------------------------------------------------------------;
ifndef WOW

cProc NearKernelError,<PUBLIC,NEAR,NODATA>

cBegin nogen
	push	bp
	mov	bp,sp

	SAVEREGS
	mov	ax, _DATA
	mov	ds, ax

;	push	[bp+12]		; only pass 4 words now
	push	[bp+10]		; err code
	push	ds		    ; seg of string
	push	[bp+8]		; offset of string
	push	[bp+6]
	push	[bp+4]
	mov	bp,[bp]		; hide this stack frame
	call	KernelError
	or	ax, ax
	RESTOREREGS
	pop	bp
	jz	@F
	INT3_DEBUG
@@:
	ret	8
cEnd	nogen
endif  ;; ! WOW


;-----------------------------------------------------------------------;
;									;
;   IsCodeSelector() -							;
;									;
;-----------------------------------------------------------------------;

ifdef WOW
cProc IsCodeSelector,<PUBLIC,FAR>
else
cProc IsCodeSelector,<PUBLIC,NEAR>
endif

parmW Candidate

cBegin
	mov	ax,Candidate
	lar	dx,ax
	jz	lar_passed
	xor	ax,ax
	jmp	ics_ret
lar_passed:
	xor	ax,ax
	test	dh,00001000b		; Executable segment descriptor?
	jz	ics_ret			; No
	push	cs			; Yes
	pop	dx
	and	dx,3
	and	Candidate,3		; RPL matches that of CS?
	cmp	dx,Candidate
	jne	ics_ret			; No
	inc	ax			; Yes
ics_ret:
cEnd

endif;  DEBUG                           ; DEBUG ONLY SECTION ENDS HERE


;-----------------------------------------------------------------------;
;									;
;   DebugBreak() -							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

if KDEBUG
db_tab	dw	db_t, db_w, db_e, db_f, db_k, db_3
db_len	equ	($ - db_tab) / 2
endif

cProc	DebugBreak,<PUBLIC,FAR>

cBegin	nogen
if KDEBUG
	cmp	ax, 0DACh
	jnz	db_3
	cmp	bx, db_len
	jae	db_3
	shl	bx, 1
	jmp	db_tab[bx]
db_t:	krDebugOut DEB_TRACE, "Test trace"
	jmps	db_end
db_w:	krDebugOut DEB_WARN, "Test warning"
	jmps	db_end
db_e:	krDebugOut DEB_ERROR, "Test error"
	jmps	db_end
db_f:	krDebugOut DEB_FERROR, "Test fatal error"
	jmps	db_end
db_k:	kerror	0, "This is a kernel error"
	jmps	db_end
db_3:
endif

	INT3_DEBUG		    ; Jump to debugger if installed
db_end:
	ret
cEnd	nogen

;-----------------------------------------------------------------------;
;									;
;   TextMode() - Enter text mode for debugging load failure		;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc TextMode,<PUBLIC,NEAR,NODATA>,<ds>
cBegin
	SetKernelDS
	cmp	word ptr [pDisableProc+2],0
	je	tm1
	cCall	[pDisableProc]
	jmps	tm2
tm1:
ifdef   NEC_98
    mov     ah,41h          ;graphic picture stop display
    int     18h
    mov     ah,0Ch          ;text picture start disply
    int     18h
else    ; NEC_98
	mov	ax, 3
	int	10h
endif   ; NEC_98
tm2:
cEnd




;-----------------------------------------------------------------------;
;									;
;   DoAbort() - 							;
;									;
;-----------------------------------------------------------------------;

	assumes	ds, nothing
	assumes	es, nothing

cProc DoAbort,<PUBLIC,NEAR>

cBegin	nogen
	SetKernelDS
	cCall	TextMode
;	cmp	word ptr [pDisableProc+2],0
;	je	doa1
;	cCall	[pDisableProc]
;doa1:
	mov	ax,1
	cCall	ExitKernel,<ax>
	UnSetKernelDS
cEnd	nogen

;-----------------------------------------------------------------------;
;
; HandleParamError
;
; This entry point is jumped to by the parameter validation code of
; USER and GDI (and KERNEL).  Its job is to parse the error code
; and, if necessary, RIP or jmp to the error handler routine
;
; Stack on entry:   Far return addr to validation code
;                   Saved error handler offset
;                   Saved BP
;                   API far ret addr
;
;-----------------------------------------------------------------------;

ERR_WARNING             equ 08000h      ; from error.h/windows.h/layer.inc

LabelFP <PUBLIC, HandleParamError>
	push	bp
	mov	bp,sp
	push    bx          ; save err code

	push	bx	    ; push err code

        push    [bp+4]      ; push err return addr as place where error occured
        push    [bp+2]

	push	cx	    ; push parameter
	push	ax
        call    far ptr LogParamError   ; yell at the guy

	pop	bx
	pop	bp

	test	bh,high(ERR_WARNING)  ; warn or fail?
	errnz	low(ERR_WARNING)
	jnz	@F

        pop     bx
        pop     ax          ; pop far return addr

        pop     bx          ; get error handler address

	pop	bp	    ; restore BP
	and	bp,not 1    ; Make even in case "inc bp" for ATM

        push    ax
        push    bx          ; far return to handler

        xor     ax,ax       ; set dx:ax == 0 for default return value
	cwd
        xor     cx,cx       ; set cx == 0 too, for kernel error returns

        mov     es,ax       ; clear ES just in case it contains
                            ; a Windows DLL's DS...
@@:
        retf

cProc   DebugFillBuffer,<PUBLIC, FAR, PASCAL, NONWIN>,<DI>
ParmD   lpb
ParmW   cb
cBegin
if KDEBUG
assumes ES,data
        mov     ax,_DATA
        mov     es,ax
        test    es:DebugOptions,DBO_BUFFERFILL
assumes ES,nothing
        jz      dfbexit
        les     di,lpb
        mov     cx,cb
        mov     ax,(DBGFILL_BUFFER or (DBGFILL_BUFFER shl 8))
        cld
        shr     cx,1
        rep     stosw
        rcl     cx,1
        rep     stosb
dfbexit:
endif;  KDEBUG
cEnd

;========================================================================
;
; void FAR _cdecl DebugOutput(UINT flags, LPCSTR lpszFmt, ...);
;
; NOTE: there is a CMACROS bug with C that causes the parameter offsets
;       to be calculated incorrectly.  Offsets calculated by hand here.
;
cProc   DebugOutput,<PUBLIC, FAR, C, NONWIN>
flags   equ <[bp+2+4]>      ; parmW flags   point past ret addr & saved bp
lpszFmt equ <[bp+2+4+2]>    ; parmD lpszFmt
cBegin
if KDEBUG
        push    bp          ; generate a stack frame
        mov     bp,sp

        SAVEREGS            ; save all registers

        push    ds
        SetKernelDS

        lea     ax,flags    ; point at flags, lpszFmt, and rest of arguments
        push    ss
        push    ax
        call    DebugOutput2

        UnsetKernelDS
        pop     ds
        or      ax,ax       ; test break flag
        RESTOREREGS

        pop     bp

        jz      @F          ; break if needed
        INT3_DEBUG
@@:
endif
cEnd

;========================================================================
;
; void WINAPI LogError(UINT err, void FAR* lpInfo);
;
cProc   LogError,<PUBLIC, FAR, PASCAL, NONWIN>
ParmD   err
ParmW   lpInfo
cBegin
        SAVEREGS
assumes ds,NOTHING

        cCall   DebugLogError,<err, lpInfo>

        RESTOREREGS
cEnd

;========================================================================
;
; void WINAPI LogParamError(UINT err, FARPROC lpfn, void FAR* param);
;
cProc   LogParamError,<PUBLIC, FAR, PASCAL, NONWIN>
ParmW   err
ParmD   lpfn
ParmD   param
cBegin
assumes ds,NOTHING
        SAVEREGS

        ; Call debugger hook (note the reversed parameter order)
	;
	cCall   DebugLogParamError,<param, lpfn, err>

if KDEBUG
	push    ds
	SetKernelDS
assumes ds,DATA
	mov	bx, [bp+0]		; address of faulting code
	mov	bx, ss:[bx+0]
;	mov	bx, ss:[bx+0]
	mov	bx, ss:[bx+4]
	cCall   LogParamError2,<err, lpfn, param, bx>
	UnsetKernelDS
	pop     ds
assumes ds,NOTHING
        or      ax,ax               ; test break flag
endif
	RESTOREREGS
if KDEBUG
        jz      @F                  ; break if needed
        INT3_DEBUG
@@:
endif
cEnd


;-----------------------------------------------------------------------

sEnd	CODE

if KDEBUG
ifdef WOW
sBegin MISCCODE

assumes cs, MISCCODE
assumes ds, nothing
assumes es, nothing

externFP KernelError

;-----------------------------------------------------------------------;
; allows KernelError to be called from _TEXT code segment
cProc   Far_KernelError,<PUBLIC,FAR>
    parmW   errcode
    parmD   lpmsg1
    parmD   lpmsg2
cBegin
    push  [bp+14]
    push  [bp+12]
    push  [bp+10]
    push  [bp+8]
    push  [bp+6]
    call  far ptr KernelError
cEnd

sEnd MISCCODE

endif  ;; WOW
endif  ;; KDEBUG

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\rip.c ===
/****************************************************************************/
/*									    */
/*  RIP.C -								    */
/*									    */
/*	Debugging Support Routines					    */
/*									    */
/****************************************************************************/

#include "kernel.h"
#include "newexe.h"

#ifdef WOW
// Note:  The functions in this file were moved to the _MISCTEXT code segment
//        because _TEXT was exceeding the 64K segment limit   a-craigj
LPSTR htoa(LPSTR, WORD);
LPSTR htoa0(LPSTR, WORD);
LPSTR FAR far_htoa0(LPSTR, WORD);
#pragma alloc_text(_MISCTEXT,far_htoa0)
#pragma alloc_text(_MISCTEXT,htoa0)
#pragma alloc_text(_MISCTEXT,htoa)
#endif

#if KDEBUG

#include "logerror.h"
#define API	_far _pascal _loadds

extern unsigned int DebugOptions;

/* Defines for debug strings in STRINGS.ASM. */
#define DS_LOADFAIL	    0
#define DS_NEWINSTLOADFAIL  1
#define DS_RESLOADERR	    2
#define DS_CRLF 	    3
#define DS_FATALEXITCODE    4
#define DS_STACKOVERFLOW    5
#define DS_STACKTRACE	    6
#define DS_ABORTBREAKIGNORE 7
#define DS_INVALIDBPCHAIN   8
#define DS_COLON	    9
#define DS_REENTERFATALEXIT 10

#ifndef WOW
LPSTR htoa(LPSTR, WORD);
LPSTR htoa0(LPSTR, WORD);
#endif

char DebugRead(void);
void DoAbort(void);
void EnterBreak(int);
HANDLE FAR GetExeHead(void);
#ifdef WOW
LONG NEAR PASCAL LSHL(WORD, int);
#pragma alloc_text(_MISCTEXT,LSHL)
int  FAR DebugWrite(LPSTR, int);
int  FAR OpenSymFile(LPSTR);
void FAR GetSymFileName(HANDLE, LPSTR);
int  FAR FarValidatePointer(LPSTR);
BOOL FAR PASCAL IsCodeSelector(WORD);
#else
LONG PASCAL LSHL(WORD, int);
int  OpenSymFile(LPSTR);
void GetSymFileName(HANDLE, LPSTR);
int  ValidatePointer(LPSTR);
BOOL PASCAL IsCodeSelector(WORD);
#endif
WORD (far PASCAL *FatalExitProc)(WORD, WORD);
int FAR FatalExitC(WORD);
void FAR FatalAppExit(WORD, LPSTR);

#ifdef WOW
int FAR KernelError(int errCode, LPSTR lpmsg1, LPSTR lpmsg2);
static char far *GetModName(char far *exeName);
void API GetProcName(FARPROC lpfn, LPSTR lpch, int cch);
WORD far *NextFrame(WORD far *lpFrame);
void StackWalk(WORD arg);
#pragma alloc_text(_MISCTEXT,KernelError)
#pragma alloc_text(_MISCTEXT,GetModName)
#pragma alloc_text(_MISCTEXT,GetProcName)
#pragma alloc_text(_MISCTEXT,NextFrame)
#pragma alloc_text(_MISCTEXT,StackWalk)
#endif  // WOW

/* Debug Symbol Table Structures:
 *
 * For each symbol table (map): (MAPDEF)
 * -------------------------------------------------------------------------------------------------
 * | map_ptr | lsa | pgm_ent | abs_cnt | abs_ptr | seg_cnt | seg_ptr | nam_max | nam_len | name... |
 * -------------------------------------------------------------------------------------------------
 */

typedef struct tagMAPDEF
{
	unsigned	  map_ptr;    /* 16 bit ptr to next map (0 if end)    */
	unsigned	  lsa	 ;    /* 16 bit Load Segment address	      */
	unsigned	  pgm_ent;    /* 16 bit entry point segment value     */
	int 	  abs_cnt;    /* 16 bit count of constants in map     */
	unsigned	  abs_ptr;    /* 16 bit ptr to	 constant chain       */
	int 	  seg_cnt;    /* 16 bit count of segments in map      */
	unsigned	  seg_ptr;    /* 16 bit ptr to	 segment chain	      */
	char	  nam_max;    /*  8 bit Maximum Symbol name length    */
	char	  nam_len;    /*  8 bit Symbol table name length      */
}
MAPDEF;

typedef struct tagMAPEND
{
	unsigned	  chnend;     /* end of map chain (0) */
	char	  rel;	      /* release	      */
	char	  ver;	      /* version	      */
}
MAPEND;


/* For each segment/group within a symbol table: (SEGDEF)
 * --------------------------------------------------------------
 * | nxt_seg | sym_cnt | sym_ptr | seg_lsa | name_len | name... |
 * --------------------------------------------------------------
 */

typedef struct tagSEGDEF
{
	unsigned	  nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
	int 	  sym_cnt;    /* 16 bit count of symbols in sym list  */
	unsigned	  sym_ptr;    /* 16 bit ptr to symbol list	      */
	unsigned	  seg_lsa;    /* 16 bit Load Segment address	      */
	unsigned	  seg_in0;    /* 16 bit instance 0 physical address   */
	unsigned	  seg_in1;    /* 16 bit instance 1 physical address   */
	unsigned	  seg_in2;    /* 16 bit instance 2 physical address   */
	unsigned	  seg_in3;    /* 16 bit instance 3 physical address   */
	unsigned	  seg_lin;    /* 16 bit ptr to line number record     */
	char	  seg_ldd;    /*  8 bit boolean 0 if seg not loaded   */
	char	  seg_cin;    /*  8 bit current instance	      */
	char	  nam_len;    /*  8 bit Segment name length	      */
}
SEGDEF;
typedef SEGDEF FAR  *LPSEGDEF;


/*  Followed by a list of SYMDEF's..
 *  for each symbol within a segment/group: (SYMDEF)
 * -------------------------------
 * | sym_val | nam_len | name... |
 * -------------------------------
 */

typedef struct tagSYMDEF
{
	unsigned	  sym_val;    /* 16 bit symbol addr or const	      */
	char	  nam_len;    /*  8 bit symbol name length	      */
}
SYMDEF;


typedef struct tagRIPINFO
{
	char	  symName[128];
	LPSTR	  pSymName;
	DWORD	  symFPos;
	int 	  symFH;
}
RIPINFO;
typedef RIPINFO FAR *LPRIPINFO;



/*--------------------------------------------------------------------------*/
/*									    */
/*  KernelError() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Print out the module name, the message which 'lpmsg1' points to, and the
 *   value of 'lpmsg2' in hex.	Then call FatalExit.
 */

int FAR KernelError(int errCode, LPSTR lpmsg1, LPSTR lpmsg2) {
	int	n;
	char	buf[16];
	LPSTR pbuf;
	WORD	hExe;
	WORD	pfileinfo;

	struct new_exe far *pExe;

	/* Write out 'lpmsg1'. */
	if (lpmsg1)
		DebugWrite(lpmsg1, 0);

	/* Is the second pointer non-NULL? */
	if (lpmsg2)
	{
		/* Is the segment value non-NULL? */
		if ( (hExe = (WORD)((DWORD)lpmsg2 >> 16))
#ifdef WOW
		     && FarValidatePointer(lpmsg2) )
#else
		     && ValidatePointer(lpmsg2) )
#endif
		{
			/* Does it point anywhere inside a New EXE Header? */
			pExe = (struct new_exe far *)((DWORD)hExe << 16);
			if (pExe->ne_magic == NEMAGIC)
			{
				/* Write out the module name (1st in the resident names table).*/
				pbuf = (LPSTR)(((DWORD)hExe << 16) | pExe->ne_restab);
				if (n = (int)((BYTE)*pbuf++))
				{
					DebugWrite(pbuf, n);
					DebugWrite(GetDebugString(DS_COLON), 0);
				}

				/* Is the offset NULL? */
				if (!LOWORD(lpmsg2))
				{
					/* Get the pointer to the full-path name which we stuck in
					   * the checksum a long time ago.
					   */
					if (pfileinfo = NE_PFILEINFO(*pExe))
						(DWORD)lpmsg2 |= (DWORD)pfileinfo;
					else
					{
						pExe = (struct new_exe far *)((DWORD)GetExeHead() << 16);
						pfileinfo = NE_PFILEINFO(*pExe);
						lpmsg2 = (LPSTR)(((DWORD)hExe << 16) | pfileinfo);
					}
					lpmsg2 += 8;	/* HERE???? */
				}
			}

			/* Write out the full-path name. */
			pbuf = lpmsg2;
			n = 0;
			while ((BYTE)*pbuf++ >= ' ')
				n++;

			if (n && n < 64)
				DebugWrite(lpmsg2, n);
		}

		/* Write out the second pointer in hex. */
		pbuf = (LPSTR)buf;
		*pbuf++ = ' ';
		pbuf = htoa(pbuf, HIWORD(lpmsg2));
		*pbuf++ = ':';
		pbuf = htoa(pbuf, LOWORD(lpmsg2));
		*pbuf++ = '\r';
		*pbuf++ = '\n';
		*pbuf++ = 0;
		DebugWrite((LPSTR)buf, 0);
	}

	/* Print errCode and dump the stack. */
	return FatalExitC(errCode);
}


static char far *GetModName(char far *exeName) {
	int delim, dot, len, i;
	delim = 0;
	dot = 0;
	for (i=0; i<80 && exeName[i]; i++) {
		if (exeName[i] == '.')
			dot = i;
		if (exeName[i] == ':' || exeName[i] == '\\')
			delim = i+1;
	}
	if (!dot) dot = i;
	len = dot - delim;
	for (i=0; i<len; i++)
		exeName[i] = exeName[i+delim];
	exeName[len] = 0;
	return exeName+len;
} /* GetModName */


/*--------------------------------------------------------------------------*/
/*									    */
/*  FindSegSyms() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

#ifdef WOW
int FindSegSyms(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD CSvalue);
#pragma alloc_text(_MISCTEXT,FindSegSyms)
#endif
int FindSegSyms(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD CSvalue) {
	HANDLE	      hExe;
	struct new_exe far  *pExe;
	struct new_seg1 far *pSeg;
	MAPDEF	      MapDef;
	MAPEND	      MapEnd;
	LPSTR 	      pFileName;
	BYTE		      c;
	int		      i;
	int		      j;
	WORD		      seg_ptr;

	if (lpRipInfo->symFH != -1)
	{
		_lclose(lpRipInfo->symFH);
		lpRipInfo->symFH = -1;
	}

	hExe = GetExeHead();
	while (hExe)
	{
		pExe = (struct new_exe far *)((DWORD)hExe << 16);
		pSeg = (struct new_seg1 far *)(((DWORD)hExe << 16) | pExe->ne_segtab);

		for (i=0; i < pExe->ne_cseg; i++, pSeg++)
		{
#if 1
			if (HIWORD(GlobalHandleNoRIP((HANDLE)pSeg->ns_handle)) == CSvalue)
#else
				if (MyLock((HANDLE)pSeg->ns_handle) == CSvalue)
#endif
				{
					lpRipInfo->pSymName = (LPSTR)lpRipInfo->symName;
					GetSymFileName(hExe, lpRipInfo->pSymName);
					if ((lpRipInfo->symFH = OpenSymFile(lpRipInfo->pSymName)) != -1)
					{
						_lread(lpRipInfo->symFH, (LPSTR)&MapDef, sizeof(MAPDEF));
						_lread(lpRipInfo->symFH, lpRipInfo->pSymName, (int)((BYTE)MapDef.nam_len));

						if (i > MapDef.seg_cnt)	/* Too much assembly */
							goto ModName;

						lpRipInfo->pSymName += MapDef.nam_len;
						*lpRipInfo->pSymName++ = '!';
						*lpRipInfo->pSymName = 0;
						seg_ptr = (WORD)MapDef.seg_ptr;
						_llseek(lpRipInfo->symFH, -(long)sizeof(MAPEND), 2);
						_lread(lpRipInfo->symFH, (LPSTR)&MapEnd, sizeof(MAPEND));
						if (MapEnd.ver != 3) goto ModName;

						j = i + 1;
						while (j--)
						{
							if (MapEnd.rel >= 10)
								_llseek(lpRipInfo->symFH, LSHL(seg_ptr, 4), 0);
							else
								_llseek(lpRipInfo->symFH, (long)seg_ptr, 0);
							_lread( lpRipInfo->symFH, (LPSTR)lpSegDef, sizeof(*lpSegDef));
							seg_ptr = (WORD)lpSegDef->nxt_seg;
						}

						_lread(lpRipInfo->symFH, lpRipInfo->pSymName, (int)((BYTE)lpSegDef->nam_len));
						lpRipInfo->pSymName += lpSegDef->nam_len;
						*lpRipInfo->pSymName++ = ':';
						*lpRipInfo->pSymName = 0;
						lpRipInfo->symFPos = (DWORD)_llseek(lpRipInfo->symFH, 0L, 1);

						return(TRUE);
					} /* if opened file */
ModName:
					/* Put Module on line:  USER(0033)XXXX:XXXX */
					GetSymFileName(hExe, lpRipInfo->symName);
					lpRipInfo->pSymName = GetModName(lpRipInfo->symName);
					*lpRipInfo->pSymName++ = '(';
                                        lpRipInfo->pSymName = htoa0(lpRipInfo->pSymName, i+1);
					*lpRipInfo->pSymName++ = ')';
					*lpRipInfo->pSymName = 0;
					goto TermName;
				}
		}
		hExe = (HANDLE)NE_PNEXTEXE(*pExe);
	}
	lpRipInfo->pSymName = lpRipInfo->symName;
TermName:	/* Add segment:offset to line */
	lpRipInfo->pSymName = htoa((LPSTR)lpRipInfo->pSymName, CSvalue);
	*lpRipInfo->pSymName++ = ':';
	*lpRipInfo->pSymName	 = 0;
	if (lpRipInfo->symFH != -1) {
		_lclose(lpRipInfo->symFH);
		lpRipInfo->symFH = -1;
	}
	return(FALSE);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  FindSymbol() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

#ifdef WOW
int FindSymbol(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD offset);
#pragma alloc_text(_MISCTEXT,FindSymbol)
#endif
int FindSymbol(LPRIPINFO lpRipInfo, LPSEGDEF lpSegDef, WORD offset) {
	WORD		i;
	DWORD	symPos, curPos;
	LPSTR 	s;
	SYMDEF	SymDef;

	if (lpRipInfo->symFH != -1)
	{
		curPos = symPos = (DWORD)_llseek(lpRipInfo->symFH, (long)lpRipInfo->symFPos, 0);
		i = (WORD)lpSegDef->sym_cnt;
		while (i--)
		{
			_lread(lpRipInfo->symFH, (LPSTR)&SymDef, sizeof(SYMDEF));
			if ((WORD)SymDef.sym_val > offset)
			    break;

			symPos = curPos;

			curPos = _llseek(lpRipInfo->symFH, (long)SymDef.nam_len, 1);
		}
		_llseek(lpRipInfo->symFH, (long)symPos, 0);
		_lread(lpRipInfo->symFH, (LPSTR)&SymDef, sizeof(SYMDEF));
		s = lpRipInfo->pSymName;
		_lread(lpRipInfo->symFH, s, (int)((BYTE)SymDef.nam_len));
		s += SymDef.nam_len;
		if ((WORD)SymDef.sym_val < offset)
		{
			*s++ = '+';
                        s = htoa0(s, offset - SymDef.sym_val);
		}
		*s = 0;
		return(TRUE);
	}

        s = htoa(lpRipInfo->pSymName, offset);
	*s = 0;
	return(FALSE);
}




void API GetProcName(FARPROC lpfn, LPSTR lpch, int cch)
{
    RIPINFO RipInfo;
    SEGDEF  SegDef;
    static char lastName[128] = "test";
    static FARPROC lastfn = 0;

    if (lastfn == lpfn) {	/* cache last symbol name looked up */
      lstrcpy(RipInfo.symName, lastName);
    } else {
      RipInfo.pSymName = 0L;
      RipInfo.symFH    = -1;

      FindSegSyms((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, HIWORD(lpfn));
      FindSymbol((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, LOWORD(lpfn));

      if (RipInfo.symFH != -1) {
	  _lclose(RipInfo.symFH);
	  RipInfo.symFH = -1;
      }
      lstrcpy(lastName, RipInfo.symName);
      lastfn = lpfn;
    }

    if (cch > 1)
    {
	if (cch > sizeof(RipInfo.symName))
	    cch = sizeof(RipInfo.symName);

	RipInfo.symName[cch-1] = 0;
	lstrcpy(lpch, RipInfo.symName);
    }
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  NextFrame() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

WORD far *NextFrame(WORD far *lpFrame) {
	WORD w;

	/* Force BP even. */
	w = *lpFrame & 0xFFFE;

	/* Are we at the end of the BP chain? */
	if (w)
	{
		/* BPs should decrease as we move down the chain. */
		if (w <= LOWORD(lpFrame))
			goto BadBP;

		/* Are we above the top of the stack (SS:000A contains pStackTop)? */
		lpFrame = (WORD far *)(((DWORD)lpFrame & 0xFFFF0000L) | 0x0A);

		if (w < *lpFrame++)
			goto BadBP;

		/* Are we below the bottom of the stack (SS:000C contains pStackMin)? */
		if (w > *++lpFrame)
			goto BadBP;

		/* Return the address of the next BP. */
		return((WORD far *)(((DWORD)lpFrame & 0xFFFF0000L) | w));
	}
	else
		return((WORD far *)0L);

BadBP:
	DebugWrite(GetDebugString(DS_INVALIDBPCHAIN), 0);
	return((WORD far *)0L);
}


/*--------------------------------------------------------------------------*/
/*									    */
/*  StackWalk() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

void StackWalk(WORD arg) {

/* WORD arg;	    /* NOTE: 'arg' is only used as a pointer into the frame. */
/*	     If we subtract 2 words from 'arg's location, we */
/*	     get the address of the previous frame's BP!!!   */
	WORD far	 *lpFrame;
	WORD		 wCurBP;
	WORD		 wCurRetOffset;
	WORD		 curCS;
	RIPINFO	 RipInfo;
	SEGDEF	 SegDef;

	RipInfo.pSymName = 0L;
	RipInfo.symFH    = -1;

	/* Have 'lpFrame' point to the previous frame's BP. */
	lpFrame = &arg - 2;

	curCS = 0;
	while (lpFrame = NextFrame(lpFrame))
	{
		/* Get the next BP.  Stop if it is zero. */
		wCurBP = *lpFrame;
		if (!wCurBP)
			break;

		/* Get the current frame's return address offset. */
		wCurRetOffset = lpFrame[1];

		/* Have we changed code segments (Far call && Different CS)? */
		if (((wCurBP & 1) || IsCodeSelector(lpFrame[2])) && (curCS != lpFrame[2]))
		{
			/* Yes, get the new segment's name. */
			curCS = lpFrame[2];
			FindSegSyms((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, curCS);
		}

		/* Move back to the address of the actual call instruction. */
		if ((wCurBP & 1) || IsCodeSelector(lpFrame[2]))
								/* Near or Far call? */
			wCurRetOffset -= 5;
		else
			wCurRetOffset -= 3;

		FindSymbol((LPRIPINFO)&RipInfo, (LPSEGDEF)&SegDef, wCurRetOffset);

		DebugWrite((LPSTR)RipInfo.symName, 0);

		DebugWrite(GetDebugString(DS_CRLF), 0);
	}
	if (RipInfo.symFH != -1)
		_lclose(RipInfo.symFH);
}

#ifndef WOW 

/*--------------------------------------------------------------------------*/
/*									    */
/*  FatalExit() -							    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Debugging version.  Retail version in RIPAUX.ASM. */
/* Kernel DS setup by prolog code */

int FAR FatalExitC(WORD errCode) {	/* return 1 to break execution */
	char	c;
	char	buf[7];
	LPSTR pbuf;
	int rep=0;

    /* This calls the TOOLHELP RIP hook */
	if ( FatalExitProc )
    {
        _asm
        {
            push    errCode
	    push    bp
	    call    DWORD PTR FatalExitProc
	    or      ax,ax
	    jz      NoReturn
	}
	return 0;

	_asm NoReturn:;
	}

#if 0
	static BOOL fInsideFatalExit = FALSE;

	if (fInsideFatalExit)
	{
		DebugWrite(GetDebugString(DS_REENTERFATALEXIT), 0);
		return 0;
	}

	fInsideFatalExit = TRUE;
#endif

ReRip:
	/* Display "FatalExit Code =" */
	DebugWrite(GetDebugString(DS_FATALEXITCODE), 0);

	/* Did the stack overflow? */
	if (errCode == -1)
		DebugWrite(GetDebugString(DS_STACKOVERFLOW), 0);
	else
	{
		/* Display the error code in hex. */
		pbuf = (LPSTR)buf;
		*pbuf++ = '0';
		*pbuf++ = 'x';
		pbuf = htoa(pbuf, (WORD)errCode);
		*pbuf++ = 0;
		DebugWrite((LPSTR)buf, 0);
	}

	/* Display the Stack Trace. */
        if (rep /* || (DebugOptions & DBO_RIP_STACK) */) {
	    DebugWrite(GetDebugString(DS_STACKTRACE), 0);
	    StackWalk(0);
	}

	while (TRUE)
	{
		/* Display "Abort, Break, Ignore" */
		DebugWrite(GetDebugString(DS_ABORTBREAKIGNORE), 0);

		/* Get and process the user's response. */
		c = DebugRead();

		DebugWrite(GetDebugString(DS_CRLF), 0);

		if (c >= 'a' && c <= 'z')
			c += 'A' - 'a';

		switch (c)
		{
		case 'A':
			DoAbort();

		case 'B':
			/*	      fInsideFatalExit = FALSE;  */
			/* EnterBreak(2); */
			return 1;

		case 0 :
		case 'I':
			/*	      fInsideFatalExit = FALSE;  */
			return 0;

                case 'X':
                case 'E':
			FatalAppExit(0, "Terminating Application");
			break;

		case ' ':
		case 13:
			rep = 1;
			goto ReRip;
		default:
			;
		}
	}

}

#endif // ifndef WOW

#endif // if KDEBUG

/*--------------------------------------------------------------------------*/
/*									    */
/*  htoa() -								    */
/*									    */
/*--------------------------------------------------------------------------*/

/* Converts 'w' into a hex string in 's'. */

LPSTR htoa(s, w)

LPSTR s;
WORD  w;

{
	int  i;
	char c;

	i = 4;
	s += i;
	while (i--)
	{
		c = (char)(w & (WORD)0x000F);
		w >>= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		*--s = c;
	}

	return(s+4);
}



/* skip leading 0's */
LPSTR htoa0(LPSTR s, WORD w)
{
	int  i;
	char c;
	int flag = 0;

	i = 4;
	while (i--)
	{
		c = (char)((w>>12) & (WORD)0x000F);
		w <<= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		if (c > '0' || flag || !i) {
			*s++ = c;
			flag = 1;
		}
	}

	return s;
}

LPSTR FAR far_htoa0( LPSTR s, WORD w)
{
    return htoa0( s, w);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\w32sys.asm ===
TITLE   w32sys - Win32S support

.xlist
include kernel.inc
include tdb.inc
.list

DataBegin

externW curTDB

DataEnd


sBegin  CODE
assumes CS,CODE


	assumes ds,nothing
	assumes es,nothing

	public   GetW32SysInfo

cProc   GetW32SysInfo,<PUBLIC,FAR>
cBegin  nogen
if	PMODE32
	SetKernelDS ES

	mov     dx, es
	lea     ax, curTDB

endif
	ret
	assumes es,nothing
cEnd    nogen

sEnd    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\tdb.inc ===
;
; Task Data Block
;
;   Contains all task specific data.
;

;
; The following macros allow saving and restoring hardware interrupt
; vectors inline.

numTaskInts = 0
?hinum = 0

?higen  macro   x,i,r,t

if r LE 3

  ?hisav&x &macro
    ife t
      mov si,4*i
    else
      mov si,i
    endif
    rept 2*r
      movsw
    endm
  &endm

  ?hires&x &macro
    ife t
      mov di,4*i
    else
      mov di,i
    endif
    rept 2*r
      movsw
    endm
  &endm

else

  ?hisav&x &macro
    ife t
      mov si,4*i
    else
      mov si,i
    endif
    mov cx,2*r
    rep movsw
  &endm

  ?hires&x &macro
    ife t
      mov di,4*i
    else
      mov di,i
    endif
    mov cx,2*r
    rep movsw
  &endm

endif
endm

DefTaskIntGroup macro   i,r,t
?higen %?hinum,i,r,t
?hinum = ?hinum + 1
numTaskInts = numTaskInts + r
endm

?hiexp  macro   n,x
        n&x
endm


SaveTaskInts    macro   destination
mov es,destination
xor ax,ax
mov ds,ax
mov di,TDB_INTVECS
?hicnt = 0
rept ?hinum
?hiexp  &?hisav,%?hicnt
?hicnt = ?hicnt + 1
endm
endm

RestTaskInts    macro  source
mov ds,source
mov si,TDB_INTVECS
xor ax,ax
mov es,ax
?hicnt = 0
rept ?hinum
?hiexp  &?hires,%?hicnt
?hicnt = ?hicnt + 1
endm
endm

; Define the hardware interrupts we will keep on a task specific basis.
; We only save on a per task basis those interrupts related to arithmetic.
; So we save 0, 2, 4, 6, 7, 10h, 3Eh, and 75h.
;  Int 0 is divide by 0
;  Int 2 is Coprocessor Error
;  Int 4 is overflow
;  Int 6 is invalid op-code
;  Int 7 is no coprocessor,
;  Int 3Eh is use by the C compiler for 8087 emulation.
;  Int 75h is use by the C compiler for 8087 emulation.
; In Windows 1.03 we saved 0h, 1h, 2h, 3Eh.
; For DOS5 compatibility we should save 0, 4, 6, and 7.


DefTaskIntGroup (00h),1,0
DefTaskIntGroup (02h),1,0
DefTaskIntGroup (04h),1,0
DefTaskIntGroup (06h),2,0
DefTaskIntGroup (3Eh),1,0
DefTaskIntGroup (75h),1,0

ifdef WOW
    include tdb16.inc
else  ; original TDB

THUNKELEM   EQU         8       ; (62*8) = 512-16 (low arena overhead)
THUNKSIZE   EQU         8

; Task data structure


;
; DON'T YOU DARE CHANGE ANYTHING IN HERE
; OR RAOR WILL KILL YOU
; OLE DEPENDS ON THIS                           3/25/91
;

TDB             STRUC

TDB_next        DW  ?           ; next task in dispatch queue
TDB_taskSP      DW  ?           ; Saved SS:SP for this task
TDB_taskSS      DW  ?           ;
TDB_nEvents     DW  ?           ; Task event counter
TDB_priority    DB  ?           ; Task priority (0 is highest)

TDB_thread_ordinal DB ?         ; ordinal number of this thread
TDB_thread_next DW  ?           ; next thread
TDB_thread_tdb  DW  ?           ; the real TDB for this task

TDB_thread_list DW  ?           ; list of allocated thread structures
TDB_thread_free DW  ?           ; free list of availble thread structures
TDB_thread_count DW ?           ; total count of tread structures

TDB_FCW         DW  ?           ; Floating point control word

TDB_flags       DB  ?           ; Task flags
TDB_filler      DB  ?           ; keep word aligned

TDB_ErrMode     DW  ?           ; Error mode for this task
TDB_ExpWinVer   DW  ?           ; Expected Windows version for this task
TDB_Module      DW  ?           ; Task module handle to free in killtask
TDB_pModule     DW  ?           ; Pointer to the module database.
TDB_Queue       DW  ?           ; Task Event Queue pointer
TDB_Parent      DW  ?           ; TDB of the task that started this up

TDB_SigAction   DW  ?           ; Action for app task signal
TDB_ASignalProc DD  ?           ; App's Task Signal procedure address
TDB_USignalProc DD  ?           ; User's Task Signal procedure address
TDB_GNotifyProc DD  ?           ; Task global discard notify proc.

TDB_INTVECS DD  numTaskInts DUP (?) ; Task specfic hardware interrupts

if 0
        ; EMS fields are OBSOLETE!

TDB_LIMSave     DW  ?           ; Offset within TDB of LIM save area
TDB_EMSPID      DW  ?           ; EMS PID for this task
TDB_EEMSSave    DD  ?           ; LPTR to EEMS save area (in a TDB)
TDB_EMSBCnt     DW  ?           ; number of EMS banks allocated so far
TDB_EMSMaxBCnt  DW  ?           ; Maximum # banks this task wants.
TDB_EMSRegSet   DB  ?       ; The register set this TDB lives in.

else

TDB_CompatFlags DW  ?       ; Compatibility flags
TDB_CompatFlags2 DW ?       ; Upper 16 bits
        DB  9 DUP (?)   ; Filler to keep TDB size unchanged
endif

TDB_cLibrary    DB  ?           ; tracks  add/del of ALL libs in system EMS
TDB_PHT         DD  ?           ; (HANDLE:OFFSET) to private handle table
TDB_PDB         DW  ?           ; MSDOS Process Data Block (PDB)
TDB_DTA         DD  ?           ; MSDOS Disk Transfer Address
TDB_Drive       DB  ?           ; MSDOS current drive
TDB_Directory   DB 65 DUP (?)   ; MSDOS current directory
TDB_Validity    DW  ?           ; initial AX to be passed to a task
TDB_Yield_to    DW  ?           ; DirectedYield arg stored here
TDB_LibInitSeg  DW  ?           ; segment address of libraries to init
TDB_LibInitOff  DW  ?
                                ; MakeProcInstance thunks live here.
TDB_MPI_Sel     DW  ?           ; Code selector for thunks
TDB_MPI_Thunks  DW  ((THUNKELEM*THUNKSIZE)/2) dup (?)

TDB_ModName     DB  8 DUP (?)   ; Name of Module.
TDB_sig         DW  ?           ; Signature word to detect bogus code
TDB             ENDS
endif    ; original TDB_

TDBsize = SIZE TDB


; signature word used to check validity of a TDB

TDB_SIGNATURE  equ     'DT'

; TDB flags

TDBF_WINOLDAP   EQU     01h     ; This app is WinOldAp.
TDBF_EMSSHARE   EQU     02h     ; This app shares EMS banks with MSDOS EXEC.
TDBF_CACHECHECK EQU     04h     ; Used in CacheCompact to prevent revisitation.
TDBF_OS2APP     EQU     08h     ; This is an OS/2 app.
TDBF_WIN32S     EQU     10h     ; This is Win32S app.

Task_Regs       struc
Task_DX         dw      ?
Task_BX         dw      ?
Task_ES         dw      ?
Task_CX         dw      ?
Task_AX         dw      ?
Task_DI         dw      ?
Task_SI         dw      ?
Task_DS         dw      ?
Task_BP         dw      ?
Task_IP         dw      ?
Task_CS         dw      ?
Task_Regs       ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\wowdeb.asm ===
TITLE	WOWDEB.ASM
	PAGE	,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; wowdeb.ASM
; Debug Routines
;
; History:
;   19-June-91	 Matt Felton (mattfe) Created
;
	.xlist
	include kernel.inc
	include cmacros.inc
	.list

.286p

externFP WOWKernelTrace

DataBegin
externW curTDB
DataEnd


sBegin	CODE
assumes	CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

;-----------------------------------------------------------------------;
; KdDbgOut								;
;									;
; Cmacros.inc has been modified so in the debug kernel all far public	;
; routines have a preamble compiled so they call this routine with a	;
; a count of the number of arguements and a pointer to a charater string;
; with the name of the routine. 					;
; This routine then thunks to 32 bit WOW to output the paramters to the ;
; log.									;
; It assumes that if the callers CS != Our CS then its not the kernel	;
; Calling this routine							;
; Cmacros doesn't compile in the preamble for some internal routines 	;
; that are called all the time. 					;
; For retail Kernel the preamble and this routine are omitted.		;
;									;
; Arguments:								;
;	lpStr	long pointer to null terminated string			;
;	cparms	count of parameters					;
; Returns:								;
;	none								;
;									;
; Error Returns:							;
;									;
; Registers Preserved:							;
;	all								;
;									;
; Registers Destroyed:							;
;	WOWKernelTrace Thunk to 32 bits 				;
;									;
; History:								;
;									;
;   June 19 1991 Create Matt Felton [mattfe]
;-----------------------------------------------------------------------;

ifdef KDEBUG

	assumes	ds, nothing
	assumes	es, nothing

cProc KdDbgOut,<PUBLIC,FAR>,<ax,bx,dx>
	parmW	cParms
	parmD  lpRoutineName
cBegin
	SetKernelDS DS
	mov ax,curTDB		    ; if there is no CurrentTDB forget it.
	cmp ax,0
	jz  KdDbgOut_Exit

; Get the iLogLevel From ROMBIOS Hard Disk Area

	push	0040h
	pop	ds
	UnSetKernelDS ds

	iLogLevel equ 0042h	    ; use fixed disk status area
	cmp	word ptr ds:[iLogLevel],"00" ;No Output if Zero
	jz	KdDbgOut_Exit

; Log Application Calls Only

	mov	ax,cs
	mov	bx,word ptr [bp]	; (follow BP chain to user CS)
	add	bx,3

	cmp	word ptr ds:[iloglevel],"61"	; LOG IT ALL at Level 16
	jz	@f

	cmp	ax,word ptr ss:[bx]	;If Users CS != KERNEL CS
	jz	KdDbgOut_Exit		;  then ignore tracing

@@:
	sub	bx,2			; Point to Callers Return Address IP:CS Args
	cCall WOWKernelTrace,<lpRoutineName,cParms,SSBX>

KdDbgOut_Exit:
cEnd

endif

sEND	CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\userpro.asm ===
TITLE   USERPRO - interface to WIN.INI file

include kernel.inc
include pdb.inc

externFP GlobalFree
externFP GlobalAlloc
externFP GlobalLock
externFP GlobalUnlock
externFP GlobalReAlloc
externFP GlobalSize
externFP OpenFile
externFP FarMyLower
;externFP _lopen
externFP _lcreat
externFP _lclose
externFP _lread
externFP _lwrite
externFP _llseek

ifdef FE_SB                             ;Apr.26,1990 by AkiraK
externFP AnsiPrev
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP FarMyUpper
externFP GetPrivateProfileSectionNames
endif

externFP TermsrvGetWindowsDir


DataBegin

externB szUserPro
externB fBooting
externW cBytesWinDir
externD lpWindowsDir
ifndef WOW
externW cBytesSysDir
externD lpSystemDir
else
externW cBytesSys16Dir
externD lpSystem16Dir
endif
if 0
externB fUserPro
externB UserProBuf
externB PrivateProBuf
externW hBuffer
ifndef PHILISAWEENIE
externW hWBuffer
externW hPBuffer
endif
externW hFile
externD BufAddr
externD lpszUserPro
endif
externW TopPDB
;externW MyCSDS

LeftSect    DB '['
; these next two must stay together
RightSect   DB ']'
CarRetLF    DB 13,10
EquStr      DB '='

externB achTermsrvWindowsDir

DataEnd

sBegin  MISCCODE
assumes CS,MISCCODE
assumes DS,NOTHING
assumes ES,NOTHING

externNP MISCMapDStoDATA

; WOW thunks most of these APIs.
ifndef WOW

SECT_LEFT       equ     byte ptr '['
SECT_RIGHT      equ     byte ptr ']'
CARRETURN       equ     byte ptr 13
LINEFEED        equ     byte ptr 10
SPACE           equ     byte ptr ' '
TAB             equ     byte ptr 09
CRLF            equ     0A0Dh
NEWRESULT       equ     1
NOSECTION       equ     2
NOKEY           equ     4
REMOVESECTION   equ     5
REMOVEKEY       equ     6

PROUNKN         EQU     0               ; Profile unknown
PROWININI       EQU     1               ; Profile WIN.INI
PROPRIVATE      EQU     2               ; Profile specified by app
PROWASPRIVATE   EQU     3               ; Buffer contains private profile data

ScanTo  MACRO   StopAt
        mov     al, StopAt
        mov     cx, -1
        repne   scasb
ENDM

ScanBack MACRO  StopAt
        std
        mov     al, StopAt
        mov     cx, di
        inc     cx
        repne   scasb
        inc     di                      ; Leave pointing to StopAt
        cld
ENDM


;-----------------------------------------------------------------------;
; SetDefaultPro                                                         ;
;                                                                       ;
; Set lpszUserPro to point to WIN.INI if it is not already set          ;
; to point to a private file                                            ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   SetDefaultPro,<PUBLIC,NEAR>
cBegin nogen
        cmp     fUserPro, PROWASPRIVATE
        je      SDF_SetIt
        cmp     fUserPro, PROUNKN               ; No file specified
        jne     SDF_Done
SDF_SetIt:
        mov     ax, dataOffset szUserPro
        mov     word ptr [lpszUserPro], ax
        mov     word ptr [lpszUserPro+2], ds
        mov     fUserPro, PROWININI
ifndef PHILISAWEENIE
        mov     si,[hWBuffer]
        mov     [hBuffer],si
else
        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
endif
SDF_Done:
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; SetPrivatePro                                                         ;
;                                                                       ;
; Sets lpszUserPro to point to a private file                           ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   SetPrivatePro,<PUBLIC,NEAR>,<di>
        parmD   lpszProfile
        localV  NewFileBuf, 80h
cBegin
ifndef PHILISAWEENIE
        mov     si, [hPBuffer]
        mov     [hBuffer], si
else
        cmp     fUserPro, PROWASPRIVATE
        jne     SPP_SetIt
endif
        les     di,lpszProfile
        test    fBooting,1
        jnz     spr_booting
        smov    es, ss
        lea     di, NewFileBuf
        mov     byte ptr es:[di.opFile], 0      ; Zap junk on stack
        mov     ax,OF_EXIST                     ; OF_EXIST searches path!
        cCall   OpenFile,<lpszProfile,es,di,ax>
        lea     di, [di.opFile]
spr_booting:
        lea     si, [PrivateProBuf]
        xor     cx, cx
        mov     cl, [si.opLen]
        lea     si, [si.opFile]
        sub     cx, 8
        cld
ifndef PHILISAWEENIE
        test    fBooting, 1
        jz      @F
        xor     bl, bl                  ; Terminate on null
        call    strcmpi
        je      SPP_KeepBuffer
        jmps    SPP_SetIt
@@:
endif
        rep     cmpsb
        je      SPP_KeepBuffer
SPP_SetIt:
        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
SPP_KeepBuffer:
        mov     fUserPro, PROPRIVATE
        mov     ax, lpszProfile.off
        mov     [lpszUserPro].off, ax
        mov     ax, lpszProfile.sel
        mov     [lpszUserPro].sel, ax
cEnd

;-----------------------------------------------------------------------;
; ResetPrivatePro                                                       ;
;                                                                       ;
; Sets lpszUserPro to point to nothing                                  ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

        assumes ds,code
        assumes es,nothing

cProc   ResetPrivatePro,<PUBLIC,NEAR>
cBegin nogen
        mov     fUserPro, PROWASPRIVATE
        ret
cEnd nogen


;-----------------------------------------------------------------------;
; GetProfileInt                                                         ;
;                                                                       ;
; Gets the integer value for the keyword field.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmW   nDefault                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nKeyValue                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:32:04p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetProfileInt,<PUBLIC,FAR>,<si,di>
        parmD   section
        parmD   keyword
        parmW   defint
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

        cCall   GetString, <section,keyword>

; DX:AX contains pointer to return string
; CX is the length of the string, -1 if none

        mov     si,ax                   ; save pointer offset
        mov     ax,defint               ; if so, return default integer
        cmp     cx,-1                   ; was there no string?
        jz      intdone                 ; if none, use default
        push    ds                      ; save DS
        mov     ds,dx                   ; DS:SI has string

; AtoI function, CX has count of characters, AX is result, DS:SI is string.

        xor     ax,ax
AtoI:   mov     dx,10
        mov     bl,[si]
        sub     bl,'0'
        jc      AtoIDone
        cmp     bl,10
        jnc     AtoIDone
        inc     si
        mul     dx
        xor     bh,bh
        add     ax,bx
        loop    AtoI
AtoIdone:
        pop     ds                      ; restore DS
intdone:
        push    ax
        call    UnlockBuffer
        pop     ax                      ; get result to return
cEnd


;-----------------------------------------------------------------------;
; GetProfileString                                                      ;
;                                                                       ;
; Returns the string for the keyword field.                             ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpDefault                                               ;
;       parmD   lpReturnedString                                        ;
;       parmW   nSize                                                   ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nLength                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:45:20p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetProfileString,<PUBLIC,FAR>,<si,di>
        parmD   section
        parmD   keyword
        parmD   defString
        parmD   resString
        parmW   cchMax
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

if KDEBUG
        mov     dx, off_defString
        or      dx, seg_defString       ; Catch those NULL pointers
        jnz     ok_def
        mkerror ERR_BADDEFAULT,<GetProfileString: NULL lpDefault>,dx,dx
ok_def:
endif
        mov     ax,off_keyword
        mov     dx,seg_keyword
        or      ax,dx
        jnz     GPS_Normal
        cCall   GetKeys,<section,resString,cchMax>

; Carry if the section not found, AX has length of "string".

        jnc     GPS_End
        jmps    GPS_DefString

GPS_Normal:
        cCall   GetString,<section,keyword>

; DX:AX contains pointer to return string
; CX has length, -1 if string not found

        cmp     cx,-1                   ; see if there is any string
        jz      GPS_DefString
        mov     SEG_defstring,dx
        mov     OFF_defstring,ax
GPS_DefString:
        xor     ax, ax                  ; bug fixed.
        cmp     SEG_defstring, 0
        je      GPS_End                 ; Save us from the GP fault
        les     di,defString            ; DI = front of string
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    strlen                  ; CX = strlen, di = end of string
        ;get last character behind terminater
        push    si
        les     si,defString            ; SI = front of string
gps_dbcs_l1:
        mov     al,es:[si]
        call    FarMyIsDBCSLeadByte
        cmc
        adc     si,1
        cmp     si,di
        jb      gps_dbcs_l1
        pop     si
else
        call    strlen                  ; CX = strlen, di = end of string
        mov     al,es:[di-1]            ; AL = last character of string
endif
        les     di,defString            ; DI = front of string
                                        
                                        ; Strip off single and double quotes
        cmp     cx,2                    ; strlen < 2?
        jb      strdone                 ; yes, skip
        mov     ah,es:[di]              ; AH = first character in the string
        cmp     ah,al                   ; first char = last char?
        jnz     strdone                 ; if no match, then no quotes
        cmp     al,"'"
        jz      strq
        cmp     al,'"'
        jnz     strdone
strq:   sub     cx,2                    ; string is really two smaller
        inc     di                      ; and starts here
strdone:

; CX now has length of return string, use it for copying.

        mov     dx,cchMax
        dec     dx
        cmp     cx,dx
        jbe     GPS1
        mov     cx,dx
GPS1:
        push    ds                      ; save DS
        push    es
        pop     ds
        mov     si,di                   ; ds:si has string
        push    cx                      ; save length for return
        les     di,ResString
        rep     movsb                   ; copy string
        mov     byte ptr es:[di], 0     ; null terminate
        pop     ax
        pop     ds                      ; restore DS
GPS_End:
        push    ax
        call    UnlockBuffer
        pop     ax                      ; get length of returned string
cEnd

cProc GetKeys,<PUBLIC,NEAR>,<si,di,ds>
        parmD   section
        parmD   resstr
        parmW   cchMax
cBegin

        xor     di,di                   ; make sure buffer is ready
        call    BufferInit

; DX:AX has buffer address, NULL if it didn't work.

        mov     di,ax                   ; save offset
        or      ax,dx                   ; see if no address
ifdef FE_SB
        jnz     skip1
        jmp     GetKeysNone             ; if no address, done
skip1:
else
        jz      GetKeysNone             ; if no address, done
endif
        dec     cchMax                  ; Leave room for terminating null byte
        mov     es,dx

        cCall   FindSection, <section>
        jc      GetKeysNone

        lds     si,resstr
        xor     dx,dx
GK3:                                    ; Key name loop
        mov     bx,di
GK3a:
        mov     al,es:[di]
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        cmc                             ;if the char is lead byte of DBCS,
        adc     di,1                    ; then di += 2 else di += 1
else
        inc     di
endif
        cmp     al,'='
        je      GK3c
        cmp     al,LINEFEED             ; Ignore lines without =
        je      GK3
        cmp     al,SECT_LEFT            ; Done if it's a section header
        je      GK4
        or      al,al                   ; or null.
        jnz     GK3a
        jmps    GK4
GK3c:
        mov     di,bx
GK3d:
        mov     al,es:[di]
        inc     di
        cmp     al,'='
        jne     GK3e
        xor     al,al
GK3e:
        mov     [si],al
        inc     dx
        inc     si
        cmp     dx,cchMax
        jb      GK3f
        dec     si
        dec     dx
GK3f:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        jc      GK3_s1
        mov     al,es:[di]
        inc     di

        mov     [si],al
        inc     dx
        inc     si
        cmp     dx,cchMax
        jb      GK3f2
        dec     si
        dec     dx
GK3f2:

GK3_s1:
endif
        or      al,al
        jnz     GK3d
        ScanTo  LINEFEED
        jmp     GK3

GetKeysNone:
        stc
        jmps    GetKeysDone

GK4:
        mov     byte ptr [si], 0        ; Terminating null
        or      dx, dx                  ; No extra zapping if nothing found
        jz      GK4x
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        push    dx

        cCall   AnsiPrev,<resstr,ds,si>
        mov     si,ax
        mov     byte ptr [si], 0
        mov     byte ptr [si+1], 0

        pop     dx
else
        mov     byte ptr [si-1], 0      ; [si-1] already zero unless we hit
                                        ; cchMax above in which case, we must
                                        ; zap the previous character.
endif
GK4x:
        mov     ax,dx
        clc

GetKeysDone:
cEnd


; Scan through buffer, looking for section.

cProc FindSection, <PUBLIC, NEAR>
        parmD   section
cBegin

SS1:
        cmp     byte ptr es:[di],SECT_LEFT ; see if it's a section header
        jne     SS2
        inc     di
        lds     si,section
        mov     bl,SECT_RIGHT
        call    strcmpi                 ; case insensitive compare
        je      SSfound                 ;  terminate on SECT_RIGHT
SS2:
        ScanTo  LINEFEED
        cmp     byte ptr es:[di], 0
        jne     SS1

; If it gets here, there wasn't a match.

        stc                             ; Fail
        jmps    SSdone

SSfound:
        ScanTo  LINEFEED                ; read to beginning of first keyline
        clc                             ; Success

SSdone:
cEnd

cProc FindKey, <PUBLIC, NEAR>
        parmD   keyword
cBegin

        mov     ax, SEG_keyword
        or      ax, OFF_keyword         ; Do we have something to look for?
        jz      FK_NoMatch
FK_Next:
        mov     al,es:[di]
        or      al,al
        jz      FK_NoMatch
        cmp     al,SECT_LEFT
        jz      FK_NoMatch

        lds     si,keyword
        mov     bl,'='                  ; term on =.
        call    strcmpi                 ; case insensitive compare, term on 0
        je      FK_Found                ; es:di has result string

        ScanTo  LINEFEED
        jmp     FK_Next

FK_NoMatch:
        stc
        jmps    FK_Done
FK_Found:
        clc
FK_Done:

cEnd

cProc GetString,<PUBLIC,NEAR>,<si,di,ds>
        parmD   section
        parmD   key
cBegin
        xor     di,di                   ; make sure buffer is ready
        call    BufferInit

; DX:AX has buffer address, NULL if it didn't work.

        mov     di,ax                   ; save offset
        or      ax,dx                   ; see if no address
        jz      NoMatch                 ; no address, nothing to match against

        mov     es,dx

; DX:DI now has the buffer address, buffer is locked down.

        cCall   FindSection, <section>  ; Look for the section
        jc      NoMatch
        cCall   FindKey, <key>
        jnc     HaveKey

NoMatch:
        mov     cx,-1                   ; string was not found
        jmps    GetStrDone

; if it gets here, it matched

HaveKey:
        inc     di                      ; pointing at =
        mov     dx,es
        mov     bx,di
        ScanTo  CARRETURN               ; traverse string until reach end
        inc     cx
        inc     cx
        neg     cx                      ; will now contain string length
        mov     ax,bx
GetStrDone:
cEnd

; make sure the buffer has been filled


        public  BufferInit              ; this is for the debugger
BufferInit:
assumes DS,CODE
        mov     ax,[hBuffer]
        or      ax,ax
        jnz     bf0
        xor     dx,dx
        ret
bf0:
        call    LockBuffer
        mov     bx,ax
        or      bx,dx
        jz      bf1
        ret
bf1:
        mov     bx,GA_MODIFY            ; make block not discardable
        cCall   GlobalReAlloc,<hBuffer,ax,ax,bx>
        mov     ax,di
        les     dx, lpszUserPro
        cmp     fUserPro, PROPRIVATE
        jne     bf1a1
        mov     bx,codeOffset PrivateProBuf     ; Private ie not WIN.INI
        cCall   OpenFile,<es,dx,dsbx,ax>
        cmp     ax, -1                  ; File not found?
        jne     bf1a2
        or      di, di
        jz      bf1a2                   ; Don't create if we want to read it.
        mov     ax, di
        or      ax, OF_CREATE           ; Writing it, create it silently.
        les     dx, lpszUserPro
        mov     bx,codeOffset PrivateProBuf
        jmps    bf1a
bf1a1:
        or      di,di
        jz      bf1a0
        or      ax,OF_CREATE
bf1a0:
        mov     bx,codeOffset UserProBuf
        cmp     byte ptr [bx],0
        jz      bf1a
        mov     dx,dataOffset szUserPro
        and     ax,NOT OF_CREATE
        or      ax,OF_REOPEN or OF_PROMPT
bf1a:
        cCall   OpenFile,<es,dx,dsbx,ax>
bf1a2:
        mov     [hFile],ax
        inc     ax
        jnz     @F
        jmp     bf3                     ; if file not found, return 0:0
@@:     mov     ax,0002h
        call    Rewind2                 ; seek to end of file
        add     ax,3                    ; tack on room for cr,lf and 0
        adc     dx,0
        jz      bf1aa                   ; ok if less than 64k
        mov     ax, -1                  ; Limit memory used
        xor     dx, dx
bf1aa:
        push    ax                      ; Length to read
        mov     bx,GA_ZEROINIT
        regptr  LONGINT,DX,AX
        cCall   GlobalReAlloc,<hBuffer,LONGINT,bx>  ; global block
        pop     bx                      ; Stand on our head to preserve length
        or      ax,ax
        jz      bf3
        mov     hBuffer, ax
        push    bx
        call    LockBuffer
        call    Rewind                  ; rewind to beginning of file
        les     bx,[BufAddr]
        mov     es:[bx],2020h           ; space space
        pop     cx                      ; read in the whole file
        sub     cx, 3                   ; don't fill extra space in the buffer
        jcxz    bf1zz                   ; Don't bother if nothing to read
        cCall   _lread,<hFile,esbx,cx>
        inc     ax
        jz      bf2
        dec     ax
        mov     cx,ax                   ; cx has file size
bf1zz:
        cmp     cx,2
        jae     bf1z
        mov     cx,2
bf1z:
        jmps    PackBuffer
bf2:    call    UnlockBuffer
FreeBuffer:
        xor     ax,ax
        mov     dx,GA_DISCARDABLE shl 8 OR GA_MODIFY
        cCall   GlobalReAlloc,<si,ax,ax,dx>
        xor     ax,ax
        mov     dx,(GA_SHAREABLE) shl 8 OR GA_MOVEABLE
        cCall   GlobalReAlloc,<si,ax,ax,dx>

bf3:    xor     ax,ax
        xor     dx,dx
        mov     word ptr [BufAddr][0],ax
        mov     word ptr [BufAddr][2],dx
        ret

        public  packbuffer
PackBuffer:
        push    ds
        mov     dx,di
        les     di,[BufAddr]
        lds     si,[BufAddr]

pb1:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;TAB or SPACE are never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        jcxz    pb9                     ; while leading space or tab
        mov     bx, di                  ; Initialize first valid character

        lodsb
        dec     cx
        cmp     al, SPACE               ; remove leading spaces
        jz      pb1
        cmp     al, TAB                 ; and tabs
        jz      pb1

        dec     si                      ; refetch last character
        inc     cx
pb2:
        lodsb
        dec     cx
        or      dx,dx                   ; Are we writing?
        jnz     pb20                    ; Yes, leave comments in
        cmp     al,';'                  ; No, is this a comment?
        jne     pb20                    ; No, continue
        jcxz    pb9                     ; if done
pb2loop:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;LINEFEED is never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        lodsb
        dec     cx
        jz      pb9                     ; if done
        cmp     al, LINEFEED            ; if end of line, go on
        jz      pb1
        jmps    pb2loop
pb20:
        stosb                           ; first character of line
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        call    FarMyIsDBCSLeadByte
        jc      pb_dbcs_s1
        movsb
        dec     cx
        jz      pb9
pb_dbcs_s1:
endif
        cmp     al,'='                  ; if '=', then end of left hand side
        jz      pb2a
        jcxz    pb9
        cmp     al, SPACE               ; if space, might be trailing space
        jz      pb2
        cmp     al, TAB
        jz      pb2
        cmp     al, LINEFEED            ; if end of line, go on
        jz      pb1
        mov     bx,di                   ; ow save last valid character+1
        jmp     pb2

pb2a:
        mov     di,bx                   ; remove trailing spaces on left
        stosb                           ; resave '='
pb3:                                    ; now work on right hand side
        jcxz    pb9                     ; while leading space or tab
        lodsb                           ; remove leading spaces
        dec     cx
        cmp     al, SPACE
        jz      pb3                     ; and tabs
        cmp     al, TAB
        jz      pb3

        dec     si                      ; refetch last character
        inc     cx
pb5:
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
;LINEFEED is never found in lead byte of DBCS.
;so, this loop is safe in DBCS.
endif
        lodsb
        stosb                           ; store character
        dec     cx
        jz      pb9
        cmp     al, LINEFEED            ; at end of line?
        jz      pb1                     ; yes, go on
        jmp     pb5

pb9:
        or      di, di
        jz      pb9a                    ; NOTHING THERE!!
        dec     di                      ; remove trailing ^Z's
        cmp     byte ptr es:[di],"Z"-"@"
        jz      pb9
        inc     di
pb9a:

        mov     ax,CRLF
        stosw                           ; make sure there is a final
        xor     ax,ax                   ;   CARRETURN and NULL
        stosb
        pop     ds                      ; restore DS
        mov     si,[hBuffer]
        cCall   GlobalUnlock,<si>

        xor     ax,ax
        regptr  xsize,ax,di
        cCall   GlobalReAlloc,<si,xsize,ax>

        public  lockbuffer
LockBuffer:
        mov     si,ax
        cCall   GlobalLock,<ax>
        mov     word ptr BufAddr[0],ax
        mov     word ptr BufAddr[2],dx
        ret

        public  unlockbuffer
UnlockBuffer:
        mov     si,hBuffer
        cCall   GlobalUnlock,<si>
        xor     ax,ax
        mov     dx,(GA_MODIFY + (GA_DISCARDABLE SHL 8)) ; make block discardable
        cCall   GlobalReAlloc,<si,ax,ax,dx>
        mov     bx,-1
        xchg    bx,[hFile]
        inc     bx
        jz      ulbdone
        dec     bx
        cCall   _lclose,<bx>            ; close file
ulbdone:
        ret

Rewind:
        xor     ax,ax                   ; rewind the tape
Rewind2:
        xor     cx,cx
        cCall   _llseek,<hFile,cx,cx,ax>
        ret


; this proc calculates the length of the string pointed to by es:di
; and returns it in cx.  It searches for a CR and then backs thru any
; trailing spaces.
; it uses cx, es, and di

        public  strlen
strlen  PROC    NEAR
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
; Space, Carridge Return, NULL are never in lead byte of DBCS.
; So, we don't need to enable here.
endif
        push    ax                      ; Save ax
        mov     cx,di                   ; cx = start of string
        dec     di                      
str1:   inc     di                      ; Search for CR or NULL
        mov     al,es:[di]              ;  AL has CR or NULL
        cmp     al,CARRETURN
        ja      str1                    
str2:   dec     di                      ; Remove trailing blanks
        cmp     di,cx                   ; Check for start of string
        jb      str3
        cmp     byte ptr es:[di],SPACE
        jz      str2
str3:   inc     di                      ; Restore CR or NULL
        cmp     es:[di],al
        jz      maybe_in_code
        mov     es:[di],al
maybe_in_code:
        neg     cx
        add     cx,di
        pop     ax                      ; Restore ax
        ret
strlen  ENDP

        public  strcmpi
strcmpi PROC    NEAR
; es:di and ds:si have strings
; es:di should be terminated by the char in bl
; ds:si is null terminated
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
sti_l1:
        mov     al,es:[di]
        cmp     al,bl
        jz      sti_s1

        call    FarMyLower
        mov     cl,al

        mov     al,ds:[si]
        call    FarMyLower

        inc     si
        inc     di

        cmp     al,cl
        jnz     sti_exit

        call    FarMyIsDBCSLeadByte
        jc      sti_l1

        mov     al,es:[di]
        cmp     al,ds:[si]
        jnz     sti_exit

        inc     si
        inc     di
        jmp     short sti_l1


sti_exit:
        ret

sti_s1:
        mov     al,ds:[si]
        or      al,al
        ret
else
stci10:
        mov     al,es:[di]
        cmp     al,bl                   ; At the end?
        jnz     stci15                  ; yes, get out of here.
        mov     al,[si]                 ; are we at the end of the string
        or      al,al
        jmps    stciex
stci15:
        call    FarMyLower
stci30:
        mov     cl,[si]
        xchg    al,cl
        call    FarMyLower
        xchg    cl,al
stci40:
        inc     si
        inc     di
        cmp     al,cl                   ; Still matching chars?
        jz      stci10                  ; Yes, go try the next char.
stciex:
        ret
endif
strcmpi ENDP


;-----------------------------------------------------------------------;
; WriteProfileString                                                    ;
;                                                                       ;
; Copies the given character string to WIN.INI.                         ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpString                                                ;
;                                                                       ;
; Returns:                                                              ;
;       AX = bResult                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 05:12:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc WriteProfileString,<PUBLIC,FAR>,<si,di,ds>
        parmD   section
        parmD   keyword
        parmD   result
 
        localD  ptrTmp
        localW  WhatIsMissing
        localW  nBytes
        localW  fh
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ReSetKernelDS

        cCall   SetDefaultPro

;make sure buffer is ready

        mov     si,[hBuffer]
        call    FreeBuffer              ; free up any buffer we may have
        cmp     ax,SEG_section
        jne     WPS0
        cmp     ax,SEG_keyword
        jne     WPS0
        cmp     ax,SEG_result
        jne     WPS0
        jmp     WriteDone
WPS0:
        mov     di,2                    ; write
        call    BufferInit              ; read in a fresh copy

; DX:AX has buffer address, NULL if it didn't work

        mov     di,ax
        or      ax,dx
        jnz     WPS1
        jmp     WriteDone

WPS1:   push    dx                      ; save buffer selector

        cCall   GlobalSize, <hBuffer>   ; how big is he?
        or      dx, dx                  ; more than 64k, icky
        jnz     WPS_TooBig
        cmp     ax, 0FF00h              ; more than 64K-256, icky
        jb      WPS_SmallEnough

WPS_TooBig:
        pop     ax                      ; throw away saved buffer selector
        xor     ax, ax                  ; return FALSE if file too big
        jmp     WriteDone

WPS_SmallEnough:

        pop     es                      ; selector of buffer popped into es
        push    ds
        call    Rewind

; ES:DI now has the buffer address, buffer is locked down
; scan through buffer, looking for section

        cCall   FindSection, <section>
        jc      WPS5

        mov     ax, SEG_keyword
        or      ax, OFF_keyword
        jnz     WPS2
        mov     WhatIsMissing, REMOVESECTION
        ScanBack SECT_LEFT
        jmps    WPS9
WPS2:
        cCall   FindKey, <keyword>
        jnc     WPS7

; if it gets here, there wasn't a match

        mov     WhatIsMissing,NOKEY
        jmps    WPS8

; if it gets here, there wasn't a match

WPS5:
        mov     WhatIsMissing,NOSECTION
        jmps    WPS8

WPS7:
        inc     di                      ; di now points to result
        mov     WhatIsMissing,NEWRESULT
        mov     ax, SEG_result
        or      ax, OFF_result
        jnz     WPS9                    ; NEWRESULT

        ScanBack LINEFEED
        inc     di                      ; Now points to the keyword
        jmps    WPS9
WPS8:

        cmp     WhatIsMissing,NEWRESULT
        jz      WPS9
WPS14:                                  ; get rid of extra CRLF
        or      di, di
        jz      WPS9
        dec     di
        mov     al,es:[di]
        cmp     al,CARRETURN
        jz      WPS14
        cmp     al,LINEFEED
        jz      WPS14
        add     di,3
WPS9:

; write out up to here in file

        pop     ds
        push    ds
        mov     bx,[hFile]
        cmp     bx,-1
        jnz     WPS10

        lds     dx,lpszUserPro ; create win.ini
        xor     cx,cx                   ; no special attributes
        cCall   _lcreat,<ds,dx,cx>      ; create the file
        pop     ds
        push    ds
        mov     [hFile],ax
        mov     bx,ax                   ; bx has file handle
        inc     ax
        jz      WPSError                ; -1 means didn't work
        xor     dx,dx
        cCall   _lwrite,<bx,dsdx,dx>    ; Zero length write to reset file
        or      ax,ax
        jz      WPS10                   ; size on a network file (3.0 bug)
WPSError:
        pop     ds
        call    UnlockBuffer
        xor     ax,ax
        jmp     WriteDone
WPS10:
        mov     bx,[hFile]
        mov     fh,bx                   ; save file handle in local variable
        xor     cx,cx
        mov     nBytes,cx
; write file
        mov     off_ptrTmp,di
        mov     seg_ptrTmp,es
        mov     cx,di                   ; cx has file size
        push    es
        pop     ds
        xor     dx,dx
        call    WriteCheck              ; write and check the write

        cmp     WhatIsMissing,NOSECTION
        jnz     WPS11
        mov     ax, SEG_keyword         ; Wanted to delete it?
        or      ax, OFF_keyword
        jnz     WPS10a
        jmp     WPS13                   ; Yes, don't do anything
WPS10a:
        pop     ds
        push    ds
        mov     dx,codeOffset CarRetLF
        mov     cx,2
        call    WriteCheck
        mov     dx,codeOffset LeftSect
        mov     cx,1
        call    WriteCheck
        les     di,section
        call    strlen
        lds     dx,section
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset RightSect
        mov     cx,3
        call    WriteCheck
WPS11:
        cmp     WHatIsMissing, REMOVESECTION
        jne     WPS11a
        
WPS11b:
        ScanTo  LINEFEED                ; Skip Current Line
WPS11c:
        mov     al, es:[di]
        or      al, al
        jz      WPS13
        cmp     al, SECT_LEFT
        je      WPS13
        cmp     al, ';'
        jne     WPS11b                  ; Skip this line
                                        ; Preserve Comment lines
        smov    ds, es                  ; Write from ds:dx
        mov     dx, di
        ScanTo  LINEFEED
        mov     cx, di
        sub     cx, dx
        call    WriteCheck
        jmps    WPS11c

WPS11a:
        cmp     WhatIsMissing,NEWRESULT
        jz      WPS15
                                        ; WhatIsMissing == NOKEY
        mov     ax, SEG_result          ; Delete keyword?
        or      ax, OFF_result
        jz      WPS13                   ; Yes, do nothing since not there!

        les     di,keyword
        call    strlen
        lds     dx,keyword
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset EquStr
        mov     cx,1
        call    WriteCheck
        jmps    WPS15a                  ; and write out result

WPS15:                                  ; Found keyword, have new result
        mov     ax, SEG_result
        or      ax, OFF_result          ; Have result to set?
        jnz     WPS15a
        ScanTo  LINEFEED                ; No result, delete line
        jmps    WPS13
WPS15a:
        les     di,result
        call    strlen
        lds     dx,result
        call    WriteCheck
        pop     ds
        push    ds
        mov     dx,codeOffset CarRetLF
        mov     cx,2
        call    WriteCheck
WPS12:
        les     di,ptrTmp
        cmp     WhatIsMissing,NEWRESULT
        jnz     WPS13
                                        ; get rid of old result
        ScanTo  LINEFEED
WPS13:
        mov     dx,di
        xor     al,al
        mov     cx,-1
        repne   scasb
        sub     di,3                    ; one past end, plus extra CRLF
        sub     di,dx
if 1
        jbe     WPS23                   ; if di points before dx blow it off
endif
        mov     cx,di
if 0
        or      cx,cx                   ; if <= 0 then nothing to write
        jle     WPS23
endif
        mov     si,dx
        mov     dx,cx                   ; We are growing the file. Seek
        add     dx,nBytes
        xor     cx,cx                   ; to new EOF and set file size
        cCall   _llseek,<fh,cx,dx,cx>
                                        ; with zero length write (DOS 2.X
                                        ; BIOS bug with writes past current
        xor     cx,cx                   ; EOF with DTA near end of memory)
        call    WriteCheck
        mov     dx,nBytes               ; Now backup to write rest of file
        xor     cx,cx
        cCall   _llseek,<fh,cx,dx,cx>
        push    es
        pop     ds
        mov     cx,di
        mov     dx,si
        call    WriteCheck
WPS23:
        xor     cx,cx
        call    WriteCheck
        pop     ds

        call    UnlockBuffer
        call    FreeBuffer
        mov     ax,1
WriteDone:
cEnd

        public  WriteCheck
WriteCheck:
        cCall   _lwrite,<fh,dsdx,cx>
        mov     cx,ax
        inc     ax
        jz      WC1
        dec     ax
        add     [nBytes],cx
        ret
WC1:
        pop     ax                      ; return address
        jmp     WPSError


;-----------------------------------------------------------------------;
; GetPrivateProfileInt                                                  ;
;                                                                       ;
; Gets the integer value for the keyword field from a private file      ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmW   nDefault                                                ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nKeyValue                                                  ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:32:04p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetPrivateProfileInt,<PUBLIC,FAR>,<si>
        parmD   Section
        parmD   keyword
        parmW   defint
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   GetProfileInt,<section, keyword, defint>
        cCall   ResetPrivatePro
cEnd


;-----------------------------------------------------------------------;
; GetPrivateProfileString                                               ;
;                                                                       ;
; Returns the string for the keyword field from a private file          ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpDefault                                               ;
;       parmD   lpReturnedString                                        ;
;       parmW   nSize                                                   ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = nLength                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 04:45:20p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc GetPrivateProfileString,<PUBLIC,FAR>,<si>
        parmD   section
        parmD   keyword
        parmD   defString
        parmD   resString
        parmW   cchMax
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   GetProfileString,<section,keyword,defString,resString,cchMax>
        cCall   ResetPrivatePro
cEnd


;-----------------------------------------------------------------------;
; WritePrivateProfileString                                             ;
;                                                                       ;
; Copies the given character string to a private file                   ;
;                                                                       ;
; Arguments:                                                            ;
;       parmD   lpApplicationName                                       ;
;       parmD   lpKeyName                                               ;
;       parmD   lpString                                                ;
;       parmD   lpFile                                                  ;
;                                                                       ;
; Returns:                                                              ;
;       AX = bResult                                                    ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;       DI,SI,DS                                                        ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;       BX,CX,DX,ES                                                     ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;  Sat Oct 10, 1987 05:12:51p  -by-  David N. Weise   [davidw]          ;
; Added this nifty comment block.                                       ;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc WritePrivateProfileString,<PUBLIC,FAR>,<si>
        parmD   section
        parmD   keyword
        parmD   result
        parmD   lpFile
        localV  Buffer,80h
cBegin
        cCall   MISCMapDStoDATA         ; Safety
        lea     si,Buffer
        cCall   ForcePrivatePro,<ss,si,lpFile>
        cCall   SetPrivatePro,<ss,si>
        cCall   WriteProfileString,<section, keyword, result>
        cCall   ResetPrivatePro
cEnd

;-----------------------------------------------------------------------;
; ForcePrivatePro
;
; If the file pointed to is not qualified then we force
; the file into the Windows directory.
;
; Entry:
;       BX = buffer on stack
;
; Returns:
;
; Registers Destroyed:
;
; History:
;  Tue 14-Nov-1989 20:30:48  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   ForcePrivatePro,<PUBLIC,NEAR>,<di,si,ds>
        parmD   lpDest
        parmD   lpSource
cBegin
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        cld
        xor     ax,ax
        mov     bx,'/' shl 8 + '\'
        xor     dx,dx
        lds     si,lpSource             ; first get length of string
        mov     cx,si
        mov     al,ds:[si]
        call    FarMyIsDBCSLeadByte
        jnc     fpp_s1
        cmp     byte ptr ds:[si].1,':'  ; is it qualified with a drive?
        jnz     fpp_s1
        inc     dx
fpp_s1:

fpp_l1:
        lodsb
        or      al,al
        jz      fpp_got_length
        cmp     al,bh
        jz      fpp_qualified
        cmp     al,bl
        jz      fpp_qualified
fpp_s2:
        call    FarMyIsDBCSLeadByte
        jc      fpp_l1
        inc     si
        jmp     fpp_l1

fpp_qualified:
        inc     dx
        jmp     fpp_s2
else
        cld
        xor     ax,ax
        mov     bx,'/' shl 8 + '\'
        xor     dx,dx
        lds     si,lpSource             ; first get length of string
        mov     cx,si
        cmp     byte ptr ds:[si].1,':'  ; is it qualified with a drive?
        jnz     @F
        inc     dx
@@:     lodsb
        or      al,al
        jz      fpp_got_length
        cmp     al,bh
        jz      fpp_qualified
        cmp     al,bl
        jnz     @B
fpp_qualified:
        inc     dx
        jmp     @B
endif

fpp_got_length:
        sub     si,cx
        xchg    si,cx
        les     di,lpDest
        or      dx,dx
        jnz     fpp_copy_name
        push    cx
        cCall   MISCMapDStoDATA
        ResetKernelDS
        mov     cx,cBytesWinDir
        lds     si,lpWindowsDir
        rep     movsb
        mov     al,'\'
        stosb
        pop     cx
        lds     si,lpSource
fpp_copy_name:
        rep     movsb
cEnd

endif
; ndef WOW

;-----------------------------------------------------------------------;
; GetWindowsDirectory
;
;
; Entry:
;       parmD   lpBuffer   pointer to buffer
;       parmW   cbBuffer   size of buffer
;
; Returns:
;       AX = size of string copied
;
; Registers Destroyed:
;
; History:
;  Sun 24-Sep-1989 16:18:46  -by-  David N. Weise  [davidw]
; Wrote it!
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetWindowsDirectory,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
if 1 ;HYDRA
; Get the current windows directory, since it depends on the state of ini-file
; mapping (assumes lpWindowsDir already points to achCtxWindowsDir - ldboot.asm).
        mov     si, offset achTermsrvWindowsDir
        cCall   TermsrvGetWindowsDir,<ds, si, MaxFileLen>
        or      ax, ax                  ; ax != 0 -> success
        jz      short gwd_exit  

        push    es
        smov    es,ds
        mov     di, si                 ; es:di points to windows path
        mov     cx,-1
        xor     ax,ax
        repnz   scasb
        not     cx
        dec     cx
        mov     cBytesWinDir, cx
        pop     es
else    ; HYDRA
        mov     cx,cBytesWinDir
        lds     si,lpWindowsDir
endif        
        inc     cx                      ; Room for NULL
        mov     ax, cx
        cmp     cx, 3                   ; Just 3 bytes implies <drive>:
        jne     gwd_notroot
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[si+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gwd_notroot
endif
        cmp     byte ptr ds:[si+1], ':' ; Make sure
        jne     gwd_notroot
        inc     ax                      ; Allow for \
gwd_notroot:
        cmp     ax,cbBuffer             ; is there enough room in buffer?
        ja      gwd_exit
        dec     cx                      ; don't copy null
        les     di,lpBuf
        cld
ifdef WOW
;; For WOW we might be running on a file system that supports lower case
;; however some apps can't cope with lowercase names so we uppercase it here
        push    ax
gwd_loop:
        lodsb
;; LATER
;;      call    FarMyUpper                 ; Convert char to UpperCase
        stosb
ifdef FE_SB
;;      call    MyIsDBCSLeadByte
;;      jc      gwd_loop                ; copy second byte in east
;;      movsb
endif
        loop    gwd_loop
        pop     ax
else ; WOW
        rep     movsb
endif; WOW
        mov     es:[di],cl
        dec     ax
        cmp     ax, 3
        jne     gwd_exit
        mov     di, word ptr lpBuf      ; Get pointer to dest again
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[di+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gwd_exit
endif
        cmp     byte ptr es:[di+1], ':'
        jne     gwd_exit
        mov     byte ptr es:[di+2], '\'
        mov     byte ptr es:[di+3], cl
gwd_exit:
cEnd
;-----------------------------------------------------------------------;
; GetSystemDirectory
;
; Entry:
;       parmD   lpBuf   pointer to buffer
;       parmW   cbBuffer   size of buffer
;
; Returns:
;       AX = size of string copied
;
; Registers Destroyed:
;
; History:
;  Sun 24-Sep-1989 16:18:46  -by-  David N. Weise  [davidw]
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   IGetSystemDirectory,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
ifndef WOW
        mov     cx,cBytesSysDir
        lds     si,lpSystemDir
else
        mov     cx,cBytesSys16Dir
        lds     si,lpSystem16Dir
endif
        inc     cx                      ; Room for NULL
        mov     ax, cx
        cmp     cx, 3                   ; Just 3 bytes implies <drive>:
        jne     gsd_notroot
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[si+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gsd_notroot
endif
        cmp     byte ptr ds:[si+1], ':' ; Make sure
        jne     gsd_notroot
        inc     ax                      ; Allow for \
gsd_notroot:
        cmp     ax,cbBuffer             ; is there enough room in buffer?
        ja      gsd_exit
        dec     cx                      ; don't copy null
        les     di,lpBuf
        cld
ifdef WOW
;; For WOW we might be running on a file system that supports lower case
;; however some apps can't cope with lowercase names so we uppercase it here
        push    ax
gsd_loop:
        lodsb
        call    FarMyUpper                 ; Convert char to UpperCase
        stosb
ifdef FE_SB
;;      call    MyIsDBCSLeadByte
;;      jc      gsd_loop                ; copy second byte in east
;;      movsb
endif
        loop    gsd_loop
        pop     ax
else ; WOW
        rep     movsb
endif; WOW
        mov     es:[di],cl
        dec     ax                      ; return number of bytes in string
        cmp     ax, 3
        jne     gsd_exit
        mov     di, word ptr lpBuf      ; Get pointer to dest again
ifdef FE_SB                             ;Apr.26,1990 by AkiraK
        mov     al,ds:[di+0]            ;Make sure the 1st byte is not
        call    FarMyIsDBCSLeadByte     ; DBCS lead byte.
        jnc     gsd_exit
endif
        cmp     byte ptr es:[di+1], ':'
        jne     gsd_exit
        mov     byte ptr es:[di+2], '\'
        mov     byte ptr es:[di+3], cl
gsd_exit:
cEnd

;-----------------------------------------------------------------------;
; GetProfileSectionNames
;
; Entry:
;       parmD   lpBuf   pointer to buffer for section names
;       parmW   cbBuffer   size of buffer
;
; Returns:
;
; Registers Destroyed:
;
; History:
;
;-----------------------------------------------------------------------;

        assumes ds,nothing
        assumes es,nothing

cProc   GetProfileSectionNames,<PUBLIC,FAR>,<di,si>
        parmD   lpBuf
        parmW   cbBuffer
cBegin
        cCall   MISCMapDStoDATA         ; point at data segment
        ResetKernelDS
        mov     si, dataoffset szUserPro
        regptr  xWinDotIni,ds,si
        cCall GetPrivateProfileSectionNames, <lpBuf, cbBuffer, xWinDotIni>
cEnd

sEnd    MISCCODE

ifndef WOW

sBegin  INITCODE
assumes cs, CODE
assumes ds, nothing
assumes es, nothing

szWININI        db      'WININI='
lenWININI       equ     $-codeoffset szWININI

;-----------------------------------------------------------------------;
; SetUserPro                                                            ;
;                                                                       ;
; Set szUserPro to the string given in the environment variable WININI  ;
; The default is WIN.INI                                                ;
;                                                                       ;
; Arguments:                                                            ;
;                                                                       ;
; Returns:                                                              ;
;                                                                       ;
; Error Returns:                                                        ;
;                                                                       ;
; Registers Preserved:                                                  ;
;                                                                       ;
; Registers Destroyed:                                                  ;
;                                                                       ;
; Calls:                                                                ;
;                                                                       ;
; History:                                                              ;
;                                                                       ;
;-----------------------------------------------------------------------;

cProc   SetUserPro,<PUBLIC,NEAR>,<ax,cx,si,di,ds,es>
cBegin
        SetKernelDS     es
        mov     ds, TopPDB
        mov     ds, ds:[PDB_environ]
        cld
        xor     si, si

        smov    es,cs
        assumes es,CODE

FindWinIni:
        cmp     byte ptr ds:[si], 0
        je      EndEnv
        mov     di, codeoffset szWININI
        mov     cx, lenWININI
        rep     cmpsb
        je      FoundEntry
        dec     si
SkipEntry:
        lodsb
        or      al, al
        jnz     SkipEntry
        jmps    FindWinIni
FoundEntry:

        SetKernelDS     es

        mov     di, dataoffset szUserPro
CopyEntry:
        lodsb
        stosb
        or      al, al
        jnz     CopyEntry
EndEnv:
        assumes es, nothing
cEnd

sEnd    INITCODE

endif
; ndef WOW

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\wow16cal.asm ===
TITLE   WOW16CAL.ASM
    PAGE    ,132
;
; WOW v1.0
;
; Copyright (c) 1991, Microsoft Corporation
;
; WOW16CAL.ASM
; Thunk router in 16-bit space to route Windows API calls to WOW32
;
; History:
;   25-Jan-1991 Jeff Parsons (jeffpar) Created.
;   24-Apr-91   Matt Felton (mattfe) Incorporated into Kernel
;   29-May-91   Matt Felton (mattfe) Added Multi-Tasking
;   30-Apr-1992 Mike Tricker (MikeTri) Added MultiMedia callbacks
;
;   .xlist
    include kernel.inc
    include tdb.inc
    include dbgsvc.inc
    include wow.inc
    include dpmi.inc
    include cmacros.inc

; include NEW_SEG1 struc used in GetProcModule

    include newexe.inc

    .list

    HACK16  equ 1           ;enable hacks

.286p

Entry   macro name
    ;align 16
    public name
    name&:
    endm

externFP SETCURSORICONFLAG
externFP SETDDEHANDLEFLAG
externFP LOCALALLOC
externFP LOCALREALLOC
externFP LOCALLOCK
externFP LOCALHANDLE
externFP LOCALUNLOCK
externFP LOCALSIZE
externFP LOCALFREE
externFP LOCALINIT
externFP LOCKSEGMENT
externFP UNLOCKSEGMENT
externFP GLOBALALLOC
externFP GLOBALLOCK
externFP GLOBALHANDLE
externFP GLOBALUNLOCK
externFP GLOBALSIZE
externFP GLOBALFREE
externFP FINDRESOURCE
externFP LOADRESOURCE
externFP FREERESOURCE
externFP LOCKRESOURCE
externFP SIZEOFRESOURCE
externFP Int21Handler
externFP IsBadReadPtr
externFP GetSelectorLimit
externFP GetExpWinVer
externNP SwitchTask
externNP WOW16TaskStarted
externFP GetExePtr
externFP GetModuleUsage
externFP WOWGetFastAddress
externFP WOWGetFastCbRetAddress
externFP WowGetFlatAddressArray
externFP WOWNotifyWOW32
externFP GETMODULEHANDLE
externFP GETPROCADDRESS
externFP PrestoChangoSelector
externFP GetModuleFileName
externFP WinExec
externW  gdtdsc
externW  pLocalHeap
externW  hUser
externNP SetOwner
externFP WowCheckUserGdi
externFP GetExePtr
externFP FatalExit

sBegin  NRESCODE
externFP get_sel_flags
externFP set_sel_for_dib
externFP RestoreDib
sEnd    NRESCODE

DataBegin
externW wCurTaskSS
externW wCurTaskBP
externW Win_PDB              ;MikeTri - extracting DOS PDB and SFT
externD pFileTable
externB fExitOnLastApp
externD plstrcmp

if PMODE
externW THHOOK
externD FastBop
externD FastWOW
externW FastWOWCS
externD FastWOWCbRet
externW FastWOWCbRetCS
if PMODE32
externD FlatAddressArray
endif
endif
externW WOWFastBopping
externW curTDB
externW cur_drive_owner
externW LockTDB
externB num_tasks
externW DebugWOW
externW topPDB
externW TraceOff
externD pDosWowData
;ifdef FE_SB
;externW hModNotepad
;endif ; FE_SB

UserModuleName DB 'USER.EXE', 0

DataEnd


sBegin  CODE
assumes CS,CODE
assumes DS,NOTHING
assumes ES,NOTHING

        public  apfnWOW16Func       ;make public to help debugging
apfnWOW16Func   dw  WOW16Return     ;order MUST match RET_* (wow.h)
        dw  WOW16DebugReturn
        dw  WOW16Debug
        dw  WOW16WndProc
        dw  WOW16EnumFontProc
        dw  WOW16EnumWindowProc
        dw  WOW16LocalAlloc
        dw  WOW16LocalReAlloc
        dw  WOW16LocalLock
        dw  WOW16LocalUnlock
        dw  WOW16LocalSize
        dw  WOW16LocalFree
        dw  WOW16GlobalAllocLock
        dw  WOW16GlobalLock
        dw  WOW16GlobalUnlock
        dw  WOW16GlobalUnlockFree
        dw  WOW16FindResource
        dw  WOW16LoadResource
        dw  WOW16FreeResource
        dw  WOW16LockResource
        dw  WOW16GlobalUnlock   ;there is no UnlockResource
        dw  WOW16SizeofResource
        dw  WOW16LockSegment
        dw  WOW16UnlockSegment
        dw  WOW16EnumMetaFileProc
        dw  WOW16TaskStartedTmp        ; in Tasking.asm
        dw  WOW16HookProc
        dw  WOW16SubClassProc
        dw  WOW16LineDDAProc
        dw  WOW16GrayStringProc
        dw  WOW16ForceTaskExit
        dw  WOW16SetCurDir
        dw  WOW16EnumObjProc
        dw  WOW16SetCursorIconFlag
        dw  WOW16SetAbortProc
        dw  WOW16EnumPropsProc
        dw  WOW16ForceSegmentFault
        dw  WOW16lstrcmp
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  0                           ;FREE
        dw  WOW16GetExePtr
        dw  0                          ; WOW16GetModuleUsage removed
        dw  WOW16ForceTaskFault
        dw  WOW16GetExpWinVer
        dw  WOW16GetCurDir
        dw  WOW16GetDosPDB
        dw  WOW16GetDosSFT
        dw  WOW16ForegroundIdle
        dw  WOW16WinsockBlockHook
        dw  WOW16SetDdeHandleFlag
        dw  WOW16ChangeSelector
        dw  WOW16GetModuleFilename
        dw  WOW16WordBreakProc
        dw  WOW16WinExec
        dw  WOW16WOWCallback16
        dw  WOW16GetDibSize
        dw  WOW16GetDibFlags
        dw  WOW16SetDibSel
        dw  WOW16FreeDibSel
;ifdef FE_SB
;        dw  WOW16SetFNotepad           ; for Lotus Freelance for Win
;endif ; FE_SB

functableend equ $

; the aRets table looks like this: ...retf, ...retf 2, ...retf 4,  ...

CRETENTRIES equ 020h
; generate the retf n codetable

    bytes = 0
    REPT CRETENTRIES
        align 8
        IFE  bytes
aRets:
        ENDIF
        pop  bx             ;restore app BX
        pop  bp
        add  sp, 0ah          ;pop thunk ret address, wCallID/lpfn, wArgs
        retf bytes
    bytes = bytes + 2
    ENDM
align 8
rettableend equ $
RETFCODESIZE equ (rettableend - aRets) / CRETENTRIES
.errnz ((rettableend - aRets) AND 01h)  ; complain if odd
.erre (RETFCODESIZE EQ 08h)
                                   ; if the size is not 8 bytes need to
                                   ; change the code that indexes 'aRets'

;----------------------------------------------------------------------------
; these comments are a result of hard labour (so called  'fruits'
; of hard labour)
;
; 1. If you make a change in VDMFRAME or similar such change, make sure
;    tasking.asm is in sync. pay attention to the labels wow16doneboot,
;    wow16taskstarted and the resetting of vf_wES (all in tasking.asm)
;
; 2. The general purpose registers es, bx, cx which are saved around the
;    the api thunks. LATER these have to be removed with care and caution.
;    If you just remove the push/pop of these, kernel31 won't boot.
;    These registers will have to be saved around certain calls in krnl286/386
;    for it to  boot.
;
;                                            - nanduri ramakrishna
;
;-----------------------------------------------------------------------------


;-----------------------------------------------------------------------------
; NOTES:
;
; the frame at time of bop is of type VDMFRAME
; the frame at the time of a callback is CBVDMFRAME.
; VDMFRAME and CBVDMFRAME share the first few fields (the order is important)
; but the structures don't overlap.
;
;   ie stack looks like this
;
;               ss:sp = VDMFRAME
;               ...  BOP ....
;  if return from BOP:
;               ss:sp = VDMFRAME
;  if from callback16:
;               ss:sp = CBVDMFRAME
;                .....callback function...
;                                               - nanduri ramakrishna
;-----------------------------------------------------------------------------

    assumes ds, nothing
    assumes es, nothing

align 16
cProc WOW16Call,<PUBLIC,FAR>
    ; parmW   wArgs       ; # paramater bytes pushed for this API
    ; parmW   wCallID


; note that 'bp' of api thunk and callback differ

    pFrame    equ [bp-vf_wBP]
    wAppBX    equ [pFrame].vf_wBX
    wApiRetID equ [pFrame].vf_wRetID
    wAX       equ [pFrame].vf_wAX
    wArgs     equ [pFrame].vf_cbArgs

; for callback16

    pCBFrame  equ [bp-cvf_Parm16];
    vpfnProc  equ [pCBFrame].cvf_vpfnProc
    hInst     equ [pCBFrame+cvf_Parm16].wp_hInst
    hwnd      equ [pCBFrame+cvf_Parm16].wp_hwnd
    wMsg      equ [pCBFrame+cvf_Parm16].wp_wMsg
    wParam    equ [pCBFrame+cvf_Parm16].wp_wParam
    lParam    equ [pCBFrame+cvf_Parm16].wp_lParam

    vpfnWndProc equ [di-cvf_Parm16].cvf_vpfnProc

    lpstr1     equ [pCBFrame+cvf_Parm16].lstrcmpParms.lstrcmp16_lpstr1
    lpstr2     equ [pCBFrame+cvf_Parm16].lstrcmpParms.lstrcmp16_lpstr2

    cbackAX equ [pCBFrame].cvf_wAX   ;
    cbackDX equ [pCBFrame].cvf_wDX
    wGenUse1   equ [pCBFrame].cvf_wGenUse1
    wGenUse2   equ [pCBFrame].cvf_wGenUse2
    vfSP       equ [pCBFrame].cvf_vpStack   ; lo word is sp = ptr to vdmframe

; The stack frame here is defined in wow.h make sure they match
; the order is very important.

cBegin nogen

wc_set_vdmframe:
    push bp
    mov  bp, sp                     ; standard frame
    push bx                         ; REMOVE LATER APPs BX
    push es                         ; REMOVE LATER
    push cx                         ; REMOVE LATER
ifndef PM386
    ; %OUT building 286
    push    ax                      ; dummy values for fs,gs in 286
    push    ax
else
.386
    ; %OUT building 386
    push fs
    push gs
.286
endif
    push ds
    sub  sp, 4                      ; room for api dword return value
    push si                         ; standard regs
    push di

WOW16ApiCall:
    push bp
    push    RET_RETURN  ;push default wRetID (do not move see tasking.asm)
    SetKernelDS ds
    push    [curTDB]        ;save current 16bit task handle (see tasking.asm)
    mov di,ss
    mov [wCurTaskSS],di     ;save current task SS
    mov [wCurTaskBP],bp     ;save current task BP

;   We don't want to allow debuggers to trace into 32 bit land, since they
;   will get lost.

    mov     TraceOff,1h

    test    [WOWFastBopping], 0ffffh
    jz      WOW16SlowVector

WOW16FastVector:

.386
    call    fword ptr [FastWOW]
.286
    jmp     short WOW16CallContinue

    public WOW16SlowVector
Entry   WOW16SlowVector
    BOP BOP_WOW

    public WOW16CallContinue
WOW16CallContinue:  ; don't move this label!  see comment below

    SetKernelDS ds

    xor     ax,ax
    xchg    TraceOff,ax
    test    ax,2h                        ; Turn Tracing Back on ?
    jnz     turn_on_trace_bit

W16C_010:
;   Check for Task Switch
    pop ax                               ; retrieve current task ID
    cmp ax, [curTDB]                     ; Task Switch ?
    jnz jmpSwitchTask                    ; Yes -> Perform Task Switch

    public WOW16CallNewTaskRet           ; from tasking.asm
WOW16CallNewTaskRet:

    pop bx                               ;retrieve wRetID
    pop bp                               ;localbp
    cmp bx, RET_RETURN
    jnz WOW16_From_CallBack16

    public WOW16Return
WOW16Return:

    ; we don't want to return to the thunk, that's just going to
    ; do a RETF n  where n is the # of parameters to the API.
    ; doing this takes about half the time of a RETF on a 486
    ; according to the clock counts in the book.  but RETF also flushes
    ; the instruction prefetch queue, and we're touching one less page
    ; (probably a TLB miss if we're coming back from a call with a long
    ; code path).

wc_restore_regs:

    pop  di
    pop  si
    pop  ax             ;
    pop  dx
    pop  ds
ifndef PM386
    pop  cx             ; trash cx for two dumy words, as real cx is going
    pop  cx             ; to be popped after this.
else
.386
    pop  gs
    pop  fs
.286
endif

    pop  cx                         ; REMOVE LATER
    pop  es                         ; REMOVE LATER
    mov  bx,wArgs       ; get the # of bytes this API took
if KDEBUG
    or   bx, bx
    jz   @F
    test bx, 01h
    jz   @F
    int 3               ; error. odd #bytes to pop
@@:
    cmp  bx, CRETENTRIES * 2
    jl   @F
    int 3               ; error. outside aRets tablerange
@@:
endif
    shl  bx, 2          ; convert it to offset into aRets table
    add  bx, codeoffset aRets
    jmp  bx             ; dispatch to the right RETF n


;
;   If a debugger was tracing the app then reenable on the 16 bit side again
;

turn_on_trace_bit:
    pushf
    pop     ax
    or      ax,FLG_TRAP
    push    ax
    popf
    jmps    W16C_010


    public WOW16_From_CallBack16
WOW16_From_CallBack16:      ; exception RET_DEBUGRETURN and RET_TASKSTARTED
    mov si, bp              ; save bp, dont push on stack
    mov bp, sp              ; for convenience.

    mov ax, ss
    mov es, ax
    mov ds, ax

    mov ax, cbackAX         ; for prolog initialization
    add bx,bx
    jmp apfnWOW16Func[bx]   ;route to appropriate function handler


    public WOW16DebugReturn
Entry   WOW16DebugReturn
     ; undo the 'callback' munging
    mov bp, si
    int 3               ;that's all folks
    jmps WOW16Return

jmpSwitchTask:
    jmp SwitchTask  ; Go perform a Task Switch

    public WOW16TaskStartedTmp
Entry  WOW16TaskStartedTmp
     ; undo the 'callback' munging
    mov  bp, si

    pop  di
    pop  si
    pop  ax             ;
    pop  dx
    pop  ds

ifndef PM386
    pop  cx             ; trash cx for two dumy words, as real cx is going
    pop  cx             ; to be popped after this.
else
.386
    pop  gs
    pop  fs
.286
endif
    pop  cx                         ; REMOVE LATER
    pop  es                         ; REMOVE LATER
    pop  bx                         ; pop  bx  ; REMOVE LATER;
    mov  wApiRetID, RET_RETURN
    jmp  WOW16TaskStarted

;
; Call Back Routines
; On entry, SS:SP points to PARM16 structure
; Assumes PARM16 is followed by vpfn
;

    public WOW16WOWCallback16
Entry   WOW16WOWCallback16    ; 32-bit generic callback

    call    [vpfnProc]        ; call the target proc
    mov     si, [wGenUse1]    ; si = cbArgs
    sub     sp, si            ; undo effect of "RET cbArgs"
    jmp WOW16Done

    public WOW16WndProc
Entry   WOW16WndProc

; don't expect si and di to be saved by the callback function - so save the
; critical info elsewhere like on stack.

; we set 'si' to 'hwnd'. this fixes a bug in QuickCase (qcasew.exe) where
; options.tools.add doesn't bring up a dialog box.
;
    mov     cx,hwnd         ;for later use
    mov     di,bp           ;MSAccess debug version walks BP chain.  they're
    mov     bp,si           ; testing it for us, let's make it easier for them.
    mov     wAX,di          ;save current bp in vdmframe.wAX - temporary
                            ;note:
                            ;   current 'bp (ie di) = 'sp' ,also vdmFrame can be
                            ;   accessed with the new 'bp' (ie 'si').
    mov     si,cx           ;si has hwnd
    call    [vpfnWndProc]   ;call the window proc (AX already set)
    mov     bp,wAX          ;restore pre-callback bp
    mov     sp,bp           ;restore pre-callback sp
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumFontProc
Entry   WOW16EnumFontProc

    call    [vpfnProc]      ;call the font proc
ifdef FE_SB  ; HACK for Golf , MS-GolfJ has ( retf  0x34 )!!!
    mov     sp,bp
else
    sub     sp,size PARMEFP ;undo the effect of the proc's RET 0Eh
endif ;FE_SB
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumObjProc
Entry   WOW16EnumObjProc
    call    [vpfnProc]      ;call the obj proc
    sub     sp,size PARMEOP ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumWindowProc
Entry   WOW16EnumWindowProc
    call    [vpfnProc]      ;call the font proc
    sub     sp,size PARMEWP ;undo the effect of the proc's RET 06h
    jmp     WOW16Done       ;call back to WOW32

    public WOW16LineDDAProc
Entry   WOW16LineDDAProc
    call    [vpfnProc]      ;call the Line DDA proc
    sub     sp,size PARMDDA     ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16GrayStringProc
Entry   WOW16GrayStringProc
    call    [vpfnProc]      ;call the Graystring proc
    sub     sp,size PARMGST     ;undo the effect of the proc's RET 0Eh
    jmp     WOW16Done       ;call back to WOW32

    public WOW16EnumPropsProc
Entry   WOW16EnumPropsProc
    call    [vpfnProc]      ;call the obj proc
    sub     sp,size PARMEPP ;undo the effect of the proc's RET
    jmp     WOW16Done       ;call back to WOW32

    public WOW16WordBreakProc
Entry   WOW16WordBreakProc
    call    [vpfnProc]      ;call the wordbreak proc
    sub     sp,size PARMWBP ;undo the effect of the proc's RET
    jmp     WOW16Done       ;call back to WOW32

if 0
;
; MultiMedia callbacks - MikeTri 30-Apr-1992
;

Entry   WOW16MidiInFunc
    call    [vpfnProc]      ;call the MidiIn proc
    sub sp,size PARMMIF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16MidiOutFunc
    call    [vpfnProc]      ;call the MidiOut proc
    sub sp,size PARMMOF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16IOProc
    call    [vpfnProc]      ;call the MMIO proc
    sub sp,size PARMIOP     ;undo the effect of the proc's RET 0Eh
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16TimeFunc
    call    [vpfnProc]      ;call the Time proc
    sub sp,size PARMTIF     ;undo the effect of the proc's RET 10h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16WaveInFunc
    call    [vpfnProc]      ;call the WaveIn proc
    sub sp,size PARMWIF     ;undo the effect of the proc's RET 12h
    jmp WOW16Done           ;call back to WOW32

Entry   WOW16WaveOutFunc
    call    [vpfnProc]      ;call the WaveOut proc
    sub     sp,size PARMWOF ;undo the effect of the proc's RET 12h
    jmp     WOW16Done       ;call back to WOW32
endif

Entry   WOW16LocalAlloc
    mov     ax,wMsg         ; set up DS with hInstance
    mov     ds,ax

    cmp     ds:[pLocalHeap], 0  ; already have a local heap in this DS?
    jnz     @f                  ;   yes

    ; we need to LocalInit this segment
    ; note: Win3.1 doesn't check return codes on GlobalSize, LocalInit

    push    ds
    call    far ptr GLOBALSIZE
    sub     ax, 64

    push    ds
    push    0
    push    ax
    call    far ptr LOCALINIT

    push    ds
    call    far ptr UNLOCKSEGMENT

@@:

    push    wParam          ;push wFlags
    push    lParam.lo       ;push wBytes
    call    far ptr LOCALALLOC  ;get hmem in AX
    mov     dx,ds           ; return DS in hiword of handle
    jmp     WOW16Done       ;

Entry   WOW16LocalReAlloc
    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    push    wMsg            ;push wBytes
    push    wParam          ;push wFlags
    call    far ptr LOCALREALLOC;get hmem in AX
    mov     dx,ds           ;hiword of handle=DS
    jmp     WOW16Done

Entry   WOW16LocalLock

if  0

; HACK32   remove this!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALLOCK   ;
    sub     dx,dx       ;
    or      ax,ax           ;
    jz      short lalock_done   ;
    IFDEF   HACK16
    push    ax
    push    -1
    call    far ptr LOCKSEGMENT
    pop     ax
    ENDIF
    mov dx,ds           ;if success, return full address in DX:AX
lalock_done:                ;

endif

    jmp WOW16Done       ;

Entry   WOW16LocalUnlock
if  0

; HACK32   remove this!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALUNLOCK ;
    or      ax,ax       ;
    jnz     short lufree_done   ;
    IFDEF   HACK16
    push    -1
    call    far ptr UNLOCKSEGMENT
    sub     ax,ax   ;
    ENDIF
lufree_done:                ;
    cwd             ;

endif

    jmp WOW16Done       ;

Entry   WOW16LocalSize
    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALSIZE   ;
    sub     dx,dx
    jmp     WOW16Done

Entry   WOW16LocalFree
    push    es              ; IsBadReadPtr can trash ES and BX
    push    bx
    mov     ax,lParam.hi    ; get selector of current local heap
    push    ax              ; set up for call to IsBadReadPtr
    push    0
    push    1
    call    far ptr IsBadReadPtr  ; is selector still valid?
    pop     bx
    pop     es
    or      ax,ax
    jnz     wlf_done              ; ax != 0 -> nope!

    mov     ax,lParam.hi    ; set up DS with value from alloc
    mov     ds,ax

    push    lParam.lo       ;push hMem
    call    far ptr LOCALFREE   ;
wlf_done:
    jmp WOW16Done       ;


Entry   WOW16GlobalAllocLock
    push    wParam          ;push wFlags
    push    lParam.hi       ;push dwBytes
    push    lParam.lo       ;
    call    far ptr GLOBALALLOC ;get hmem in AX
    sub     dx,dx           ;
    or      ax,ax           ;
    jz      short galock_done   ;
    push    ax          ;save hmem
    push    ax          ;push hmem
    call    far ptr GLOBALLOCK  ;get seg:off in DX:AX
    pop     bx          ;recover hmem in BX
galock_done:                ;
    mov     wGenUse1, bx
    jmp     WOW16Done       ;

Entry   WOW16GlobalLock
    push    wParam          ;push hMem
    call    far ptr GLOBALLOCK  ;
    push    ax          ;save return value
    push    dx          ;
    or      ax,dx
    jz      glock_exit
    push    wParam          ;push hMem
    call    far ptr GLOBALSIZE  ;
glock_exit:
    mov     wGenUse2,ax           ;save size
    mov     wGenUse1,dx           ;
    pop     dx          ;
    pop     ax          ;
    jmp     WOW16Done       ;

Entry   WOW16GlobalUnlock
    push    wParam          ;push hMem
    call    far ptr GLOBALUNLOCK;
    cmp     ax,1            ;
    sbb     ax,ax           ;
    cwd             ;make return code a full 32-bits
    jmp WOW16Done       ;

Entry   WOW16GlobalUnlockFree
    push    lParam.hi       ;push segment of address to free
    call    far ptr GLOBALHANDLE;
    or      dx,ax           ;valid handle?
    jz      short gufree_done   ;no
    push    ax          ;save a copy of hmem for the free
    push    ax          ;push hmem to unlock
    call    far ptr GLOBALUNLOCK;
    pop     cx          ;recover copy of hmem
    or      ax,ax           ;is lock count now zero?
    jnz     short gufree_err    ;no
    push    cx          ;push hmem to free
    call    far ptr GLOBALFREE  ;
gufree_exit:                ;
    or      ax,ax           ;
    mov     ax,1            ;if success, return TRUE; otherwise, FALSE
    jz      short gufree_done   ;
gufree_err:             ;
    sub     ax,ax           ;
gufree_done:                ;
    cwd             ;
    jmp     WOW16Done       ;

Entry   WOW16FindResource
    push    wParam          ;push hTask
    call    far ptr GetExpWinVer
    push    ax              ;save expwinver

    push    wParam          ;push hTask
    push    lParam.hi       ;push vpName
    push    lParam.lo       ;
    push    hwnd            ;push vpType
    push    wMsg            ;
    call    far ptr FINDRESOURCE;
;    or  ax,ax              ;
;    jz  short findres_done ;
;findres_done:              ;
    cwd                     ;make return code a full 32-bits
    pop     cx              ; expwinver
    mov     wGenUse1, cx
    jmp  WOW16Done     ;

Entry   WOW16LoadResource
    push    wParam          ;push hTask
    push    lParam.lo       ;push hResInfo
    call    far ptr LOADRESOURCE;
    cwd             ;make return code a full 32-bits
    jmp  WOW16Done     ;

Entry   WOW16FreeResource
    push    wParam          ;push hResData
    call    far ptr FREERESOURCE;
    cmp ax,1
    sbb ax,ax
    cwd              ;make return code a full 32-bits
    jmp WOW16Done

Entry   WOW16LockResource
    push    wParam       ;hResData
    call    far ptr LOCKRESOURCE;
    push    ax          ; save res pointer
    push    dx
    or      dx,dx

; I commented out the following code because it is breaking the US builds
; in the case where hResData is bad.  If you put code like this in, please
; comment in *detail* (with bug number perhaps) why you did.  
; In this case, jz lres_err isn't accounting for the push ax, push dx 
; instructions above.  If there is a case where the stack is off by 4 bytes
; please put a note in as to how & why.  - cmjones
;
;ifdef FE_SB             ;avoid to break stack
;    jz      lres_err
;else
    jz      lres_exit
;endif ; FE_SB
    push    wParam       ;push hResData
    call    far ptr GLOBALSIZE
lres_exit:
    mov     wGenUse2,ax           ;save size
    mov     wGenUse1,dx           ;
    pop     dx
    pop     ax
    jmp     WOW16Done

; see "I commented out..." note above
;ifdef FE_SB            ;avoid to break stack
;lres_err:
;    xor     ax,ax
;    jmp     WOW16Done
;endif ; FE_SB

Entry   WOW16SizeofResource
    push    wParam       ;push hTask
    push    lParam.lo        ;push hResInfo
    call    far ptr SIZEOFRESOURCE          ; DX:AX is DWORD size
    jmp     WOW16Done

Entry   WOW16LockSegment
    push    wParam       ;push wSeg
    call    far ptr LOCKSEGMENT
    sub     dx,dx
    jmp     WOW16Done

Entry   WOW16UnlockSegment
    push    wParam          ;push wSeg
    call    far ptr UNLOCKSEGMENT
    cmp ax,1
    sbb ax,ax
    cwd              ;make return code a full 32-bits
    jmp  WOW16Done

;MikeTri Beginning of temporary hack for testing - 17-Aug-1992

Entry   WOW16GetDosPDB
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    mov  dx, Win_PDB            ;Copy Windows PDB to DX (selector)
    mov  ax,0                   ;Move 0 to AX (offset)
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmp  WOW16Done              ;Exit

Entry   WOW16GetDosSFT
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    mov  dx,pFileTable.sel      ;Move SFT selector value to DX
    mov  ax,pFileTable.off      ;Move SFT offset value to AX
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmp  WOW16Done

;MikeTri End of temporary hack for testing - 17-Aug-1992

Entry   WOW16EnumMetaFileProc
    call    [vpfnProc]          ;call the apps MetaFile proc
    sub     sp,size PARMEMP     ;undo the effect of the proc's RET 0x10h
    jmp     WOW16Done   ;call back to WOW32

Entry   WOW16HookProc

    call    [vpfnProc]          ;call the apps Hook Proc.
    sub     sp,size PARMHKP      ;undo the effect of the proc's RET 0x08h
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16SetAbortProc
    call    [vpfnProc]          ;call the apps abort proc
;   sub     sp,size PARMSAP     ;undo the effect of the proc's RET 0x04h
;
;   Use 'bp' to restore 'sp' instead of subtracting 4bytes from sp. this is
;   because Wordperfect's Informs doesn't pop the arguments off the stack.
;   However it preserves 'bp'.
;
;   Here in wow, sp is same as bp .  The correct value  is in 'bp' - see
;   WOW16_From_CallBack16
;
;   Similar fix can also be found in win31 - core\gdi, function queryabort()
;
;                                   - nandurir
;

    mov     sp, bp
    jmp     WOW16Done           ;call back to WOW32


Entry   WOW16SubClassProc

    push    ds
    SetKernelDS ds
    mov     ax, hUser
    pop     ds                       ; restore ds
    UnSetKernelDS ds
    pop     cx                       ; cx = the ordinal number
    push    cx                       ; restore stack pointer
    push    ax                       ; hModule
    push    0                        ; hiword of ordinal number
    push    cx                       ; the ordinal
    call    GetProcAddress
    jmp     WOW16Done   ;call back to WOW32

Entry   WOW16SetCurDir
    call    SetCurrentDrive           ; on the stack is drive number;
    call    WOW16SetCurrentDirectory  ; on the stack is directory name;
    sub     sp,size PARMDIR           ; restore stack
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16SetDdeHandleFlag
    push    wParam          ;push hMem
    push    wMsg            ;push fSet
    call    far ptr SETDDEHANDLEFLAG
    jmp     WOW16Done       ;


Entry   WOW16SetCursorIconFlag
    push    wParam          ;push hMem
    push    wMsg            ;push fSet
    call    far ptr SETCURSORICONFLAG
    jmp     WOW16Done       ;


Entry   WOW16GetExePtr
    push    wParam          ;push hInstance
    call    GetExePtr
    jmp     WOW16Done

;ifdef FE_SB
;Entry   WOW16SetFNotepad
;    push    ds
;    SetKernelDS                 ; pick up Kernel DS
;    mov     ax,wParam
;    mov     hModNotepad,ax      ; handle of notepad32
;    pop     ds                  ; restore ds
;    UnSetKernelDS ds
;    jmp     WOW16Done
;endif ; FE_SB

Entry   WOW16ForceTaskExit
    mov     ax,4CFFH        ; Hung App Support Forces Current Task to Exit
    DOSCALL
    INT3_NEVER

Entry   WOW16GetModuleFilename
    push    wParam      ; hInstance
    push    lParam.hi   ; selector of filename buffer
    push    lParam.lo   ; offset   of filename buffer
    push    wMsg        ; bytes    in filename buffer
    call    far ptr GetModuleFileName
    jmp     WOW16Done       ; Just return return value

Entry   WOW16WinExec
    push    lParam.hi   ; selector of lpszCmdLine
    push    lParam.lo   ; offset   of lpszCmdLine
    push    wParam      ; fuCmdShow
    call    far ptr WinExec
    jmp    WOW16Done       ; Just return return value

Entry   WOW16GetExpWinVer
    push    wParam          ;push hInstance
    call    GetExpWinVer
    jmp     WOW16Done

Entry   WOW16GetCurDir
    call    WOW16GetCurrentDirectory
    sub     sp,size PARMDIR           ; restore stack
    jmp     WOW16Done   ;call back to WOW32


Entry   WOW16ForceTaskFault
    ; %OUT    Ignore Impure warning A4100 its required for Forcing a GP Fault
    mov     cs:gdtdsc,0     ; Force a GP Fault - Write to our CS
    jmp     WOW16ForceTaskFault

Entry   WOW16ForceSegmentFault
    push    es          ; IsBadReadPtr can trash ES & BX
    push    bx
    push    lParam.hi   ; selector of lp
    push    lParam.lo   ; offset   of lp
    push    1           ; min byte size
    call    far ptr IsBadReadPtr  ; force segment fault or handle GPF
    pop     bx
    pop     es
    jmps    WOW16Done

Entry   WOW16lstrcmp
    push ds                     ;Save DS
    SetKernelDS                 ;Pick up Kernel DS
    push    word ptr lpstr1[2]
    push    word ptr lpstr1[0]
    push    word ptr lpstr2[2]
    push    word ptr lpstr2[0]
    call    [plstrcmp]
    UnSetKernelDS               ;Get rid of kernel DS
    pop  ds                     ;Restore callers DS
    jmps    WOW16Done

Entry   WOW16ForegroundIdle
    mov     ax,1689h        ;notify application that the foreground
    int     2fh             ;task has gone idle
    jmps    WOW16Done

Entry   WOW16WinsockBlockHook
    call    [vpfnProc]          ;call the apps Hook Proc.
    jmps    WOW16Done           ;call back to WOW32

Entry   WOW16ChangeSelector
    push    wParam          ;push wSeg
    push    wParam          ;push wSeg
    call    far ptr PRESTOCHANGOSELECTOR;
    cCall   SetOwner,<wParam,-1>   ; Make this new guy the owner
    jmps    WOW16Done       ; Just return return value

Entry   WOW16GetDibSize
    push    wParam      ; selector for which size is being queryed
    call    far ptr GetSelectorLimit
    jmps    WOW16Done       ; Just return return value

Entry   WOW16GetDibFlags
    cCall   get_sel_flags,<wParam>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16SetDibSel
    cCall   set_sel_for_dib,<wParam,wMsg,lParam.lo,lParam.hi,hwnd>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16FreeDibSel
    cCall   RestoreDib,<wParam,wMsg,lParam.hi,lParam.lo>
    jmps    WOW16Done       ; Just return return value

Entry   WOW16Debug
    int 3               ;that's all folks
    ;fall into WOW16Done

Entry   WOW16Done
    mov     cbackAX, ax      ; set return value
    mov     cbackDX, dx

    mov     bp, word ptr vfSP    ; verify the saved ES is still valid 
.386p
    verr    [bp].vf_wES          ;    see bug #121760 
    jz      @f                   ; jump if still valid
    mov     [bp].vf_wES, es      ; if not, update saved ES with a known good one
@@:                              ;    - cmjones  11/12/97
    mov     bp, [bp].vf_wLocalBP

    ; fall  thru. the return values are set for a 'real' callback only
    ; don't use 'entry' macro for wow16doneboot as it 'align 16s' the label
    ; thus putting extra instructions between cbackDx, dx and mov bp,si.

    public  WOW16DoneBoot           ; tasking.asm needs this label
WOW16DoneBoot:                      ; tasking.asm needs this label
    push    bp                   ;rebuild the frame
    push    RET_RETURN           ;push default wRetID (do not move see tasking.asm)
    SetKernelDS ds
    push    [curTDB]        ;save current 16bit task handle (see tasking.asm)
    mov [wCurTaskSS],ss     ;save current task SS
    mov [wCurTaskBP],bp     ;save current task BP
    mov     TraceOff,1h             ; Don't allow debuggers to trace to 32 bit land

    test    [FastWOWCbRetCS], 0ffffh
    jz      WOW16SlowCBReturn

.386
    call    fword ptr [FastWOWCbRet]
.286

    ; don't put any code here!!!
    ; when fastbopping, after kernel has booted we return
    ; directly to WOW16CallContinue

    jmp     WOW16CallContinue


WOW16SlowCBReturn:

    IFE PMODE
    BOP BOP_UNSIMULATE          ;return from host_simulate
    ELSE
    FBOP BOP_UNSIMULATE,,FastBop
    ENDIF

    jmp     WOW16CallContinue

cEnd nogen ; WOW16Call



;
; Initialize address of fast Bop entry to monitor.
;
cProc WOWFastBopInit,<PUBLIC,FAR>
cBegin
IF PMODE
    push    ds
    push    es
    push    bx
    push    dx

    DPMIBOP GetFastBopAddress
    CheckKernelDS   ds              ; On debug, check that DS is really kernels
    ReSetKernelDS   ds              ; Assume it otherwise.
    ;
    ; Set up FastBop address (for DPMI, and WOW without WOW16FastVector)

    mov     word ptr [FastBop],bx
    mov     word ptr [FastBop + 2],dx
    mov     word ptr [FastBop + 4],es
    or      bx,dx
    jz      NoFastWow

    call    far ptr WOWGetFastAddress
    mov     word ptr [FastWOW],ax
    mov     word ptr [FastWOW+2],dx

    or      ax,dx
    jz      NoFastWow

    mov     word ptr [FastWOWCS],es
    mov word ptr [WOWFastBopping],1

    call    far ptr WOWGetFastCbRetAddress
    mov     word ptr [FastWOWCbRet],ax
    mov     word ptr [FastWOWCbRet+2],dx

    or      ax,dx
    jz      NoFastCb

    mov     word ptr [FastWOWCbRetCS],es

if PMODE32
    call    far ptr WowGetFlatAddressArray
    mov     word ptr [FlatAddressArray],ax
    mov     word ptr [FlatAddressArray + 2],dx
endif
NoFastCb:
NoFastWow:

    pop     dx
    pop     bx
    pop     es
    pop     ds
    UnSetKernelDS ds
ENDIF
cEnd    WOWFastBopInit

cProc WOWNotifyTHHOOK,<PUBLIC,FAR>
cBegin
    CheckKernelDS ds
    ReSetKernelDS ds

    mov     DebugWOW,0

if PMODE32
    push    1
else
    push    0
endif
    push    seg THHOOK
    push    offset THHOOK
    push    DBG_TOOLHELP
    FBOP BOP_DEBUGGER,,FastBop
    add     sp,+8

    push    seg cur_drive_owner
    push    offset cur_drive_owner

    push    topPDB
    push    0

    push    seg LockTDB
    push    offset LockTDB

    push    seg DebugWOW
    push    offset DebugWOW

    push    seg curTDB
    push    offset curTDB

    push    seg num_tasks
    push    offset num_tasks

    push    codeBase
    push    codeOffset Int21Handler

    call    WOWNotifyWOW32

    UnSetKernelDS ds
cEnd    WOWNotifyTHHOOK

cProc WOWQueryDebug,<PUBLIC,FAR>
cBegin
    push    ds

    SetKernelDS

    mov     ax,DebugWOW

    pop     ds
    UnSetKernelDS

cEnd WOWQueryDebug


;*--------------------------------------------------------------------------*
;*
;*  WOW16GetCurrentDirectory() -
;*
;*      - Drive =0 implies 'current' drive.
;*--------------------------------------------------------------------------*
cProc WOW16GetCurrentDirectory, <NEAR, PUBLIC>, <SI, DI>

ParmD lpDest
ParmW Drive

cBegin
        push    ds          ; Preserve DS
        les     di,lpDest       ; ES:DI = lpDest
        push    es
        pop     ds          ; DS:DI = lpDest
        cld
        mov     ax,Drive        ; AX = Drive
        or      al,al       ; Zero?
        jnz     CDGotDrive      ; Yup, skip
        mov     ah,19h      ; Get Current Disk
        DOSCALL
        inc     al          ; Convert to logical drive number
CDGotDrive:
        mov     dl,al       ; DL = Logical Drive Number
        add     al, 040h    ; drive letter
        mov     ah, 03Ah    ; ':'
        stosw
        mov     al,'\'      ; Start string with a backslash
        stosb
        mov     byte ptr es:[di],0  ; Null terminate in case of error
        mov     si,di       ; DS:SI = lpDest[1]
        mov     ah,47h      ; Get Current Directory
        DOSCALL
        jc      CDExit      ; Skip if error
        xor     ax,ax       ; Return FALSE if no error
CDExit:
        pop     ds          ; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  WOW16SetCurrentDirectory() -                                            *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc WOW16SetCurrentDirectory, <NEAR, PUBLIC>,<si,di>

ParmD lpDirName

cBegin
        push    ds          ; Preserve DS
        lds     dx,lpDirName    ; DS:DX = lpDirName
    mov ah,3Bh      ; Change Current Directory
    DOSCALL
        jc      SCDExit     ; Skip on error
        xor     ax,ax       ; Return FALSE if successful
SCDExit:
        pop     ds          ; Restore DS
cEnd


;*--------------------------------------------------------------------------*
;*                                      *
;*  SetCurrentDrive() -                             *
;*                                      *
;*--------------------------------------------------------------------------*

; Returns the number of drives in AX.

cProc SetCurrentDrive, <NEAR, PUBLIC>,<si,di>

ParmW Drive

cBegin
        mov     dx,Drive
    mov ah,0Eh      ; Set Current Drive
    DOSCALL
        sub     ah,ah       ; Zero out AH
cEnd


; --- GetTaskHandle0 ---
; ripped out piece of GetTaskHandle, taken from CONTEXT.ASM which was not
; part of WOW's kernel, so we copied this little piece out.
;

GetTaskHandle0:
        or      ax,ax
        jnz     gt1
        SetKernelDS     es
        mov     ax,curTDB
gt1:    mov     es,ax
        assumes es, nothing
;       cmp     es:[TDB_sig],TDB_SIGNATURE
;       jne     gt2
        ret
;gt2:   kerror  ERR_TASKID,<GetTaskHandle: Invalid task handle>
;       ret


;*--------------------------------------------------------------------------*
;*                                                                          *
;*  WowSetExitOnLastApp(WORD fExitOnLastApp)                                *
;*     Sets fExitOnLastApp variable which causes kernel to exit when the    *
;*     last app except WowExec exits.  Called by WowExec for seperate       *
;*     WOW VDMs, which need to exit after the last app closes.              *
;*                                                                          *
;*--------------------------------------------------------------------------*

cProc  WowSetExitOnLastApp, <PUBLIC, FAR>

ParmW fExit

cBegin
    SetKernelDS

    mov     ax, fExit
    mov     fExitOnLastApp, al
cEnd

;-----------------------------------------------------------------------;
; WowFixWin32CurDir
;
; Called by thunks for PrivateProfile APIs which need Win32 current
; directory to reflect Win16 current directory (imagine that!)
;
; Trashes AX, DX which shouldn't matter
;
; History:
;  Mon Dec 20, 1993  -by-  Dave Hart [DaveHart]
;   Don't ask me about current directories and WOW!  I'll deny it all!
;-----------------------------------------------------------------------;

Entry WowFixWin32CurDir
        push    ds
        SetKernelDS
        mov     ax,[CurTDB]
        or      ax,ax
        jz      WFW32CD_Exit
        mov     ds,ax                       ; DS points to TDB
        UnSetKernelDS
        cmp     ds:[TDB_sig],TDB_SIGNATURE
        jne     WFW32CD_Exit
        mov     dl,ds:[TDB_Drive]
        and     dl,7fh
        mov     ah,0Eh                      ; change drive
        DOSCALL
        mov     dx,TDB_LFNDirectory         ; DS:DX points to TDB curdir
        mov     ah,3Bh                      ; change directory
        DOSCALL
if KDEBUG
        jnc     WFW32CD_Exit
        krDebugOut DEB_WARN, "WowFixWin32CurDir: DOS fn 3B fails error #AX"
endif
WFW32CD_Exit:
        pop     ds
        ret

; sudeepb 11-May-1994
;
; This hackcheck is for simcity. Simcity does a GlobalSize on GDI.EXE and
; USER.EXE to figure out how much free resources are available. WOW's USER
; GDI have pretty small DGROUP, hence the size returns fails the check of
; this app. So we need to fake a bigger size.
;

cProc HackCheck,<PUBLIC,NEAR>
    parmW   handle
cBegin]
    push    es
    SetKernelDS es
    ; first check in the TDB that the currently running app is SCW.
    mov     ax,curtdb
    mov     es,ax
    xor     ax,ax
    cmp     word ptr es:[0f2h],4353h    ; SC (mod name in TDB at f2 offset)
    jne     hc5
    cmp     word ptr es:[0f4h],0057h    ; W
    jne     hc5

    ; Its SCW. Now get the module table for the given handle and check if its
    ; for USER.EXE and GDI.EXE
    cCall   GetExePtr,<handle>
    or      ax,ax
    jz      hc5
    mov     ds,ax
    mov     si,ds:[ne_pfileinfo]
    lea     dx,[si].opFile          ; DS:DX -> path
    cCall   WowCheckUserGdi,<ds,dx> ; Much easier to check this in 32bit land.
hc5:
    pop     es
cEnd

;-----------------------------------------------------------------------;
; WowSetCompatHandle
;
; This routine takes a single parameter and saves it in the TDB. It is
; used to take care of a bug in dBase where it confuses handle values.
; This is a private API called by USER.EXE.
;
; All registers must be saved. DS is saved automatically by cmacros.
; History:
;-----------------------------------------------------------------------;

cProc  WowSetCompatHandle, <PUBLIC, FAR>
ParmW handle
cBegin
        push    bx
        SetKernelDS
        mov     bx,[CurTDB]
        or      bx,bx
        jz      @f                              ;check for zero just in case
        mov     ds,bx                           ; DS points to TDB
        UnSetKernelDS
        mov     bx, handle
        mov     ds:[TDB_CompatHandle],bx        ;save it here
@@:
        pop     bx
cEnd

sEND    CODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\up.c ===
/*
 * UP.C
 *
 * User Profile routines
 *
 * These are the routines which read and write INI files.
 *
 * Exported routines:
 *
 *	GetProfileString
 *	GetPrivateProfileString
 *	GetProfileInt
 *	GetPrivateProfileInt
 *	WriteProfileString
 *	WritePrivateProfileString
 *
 * Note the parameter "lpSection" used to be known as "lpApplicationName".
 * The code always referred to sections, so the parameter has been changed.
 *
 * Rewritten 6/90 for C 6.0.
 */

#include	"kernel.h"

		/*
		 * Required definitions for exported routines:
		 */

#define API	_far _pascal _loadds

HANDLE API IGlobalAlloc(WORD, DWORD);
HANDLE API IGlobalFree(HANDLE);
LPSTR  API IGlobalLock(HANDLE);
HANDLE API IGlobalReAlloc(HANDLE, DWORD, WORD);
BOOL   API IGlobalUnlock(HANDLE);

/* #pragma optimize("t", off) */

	/* This ensures that only one selector is required in PMODE */
#define	MAXBUFLEN	0xFFE0L

#define	SPACE		' '
#define	TAB		'\t'
#define	LINEFEED	'\n'
#define	CR		'\r'
#define	SECT_LEFT	'['
#define	SECT_RIGHT	']'
#define	CTRLZ		('Z'-'@')

	/* Constants for WriteProfileString - DON'T CHANGE THESE */
#define	NOSECTION	0
#define	NOKEY		1
#define	NEWRESULT	2
#define	REMOVESECTION	3
#define	REMOVEKEY	4

	/* Flags about a file kept in ProInfo
         * If the PROUNCLEAN label is changed, its value must also be
         *      changed in I21ENTRY.ASM, where it is assumed to be 2.
         */
#define	PROCOMMENTS	1		/* contains comments */
#define	PROUNCLEAN	2		/* has not been written */
#define PROMATCHES	4		/* buffer matches disk copy */
#define PROREADONLY	8		/* Read only file */
#define PRO_CREATED     16		/* File was just created */

	/* Sharing violation. */
#define	SHARINGVIOLATION        0x0020

	/* For forcing variables into the current code segment */
#define	CODESEG		_based(_segname("_CODE"))
	/* Hide disgusting _based syntax */
#define BASED_ON_LP(x)	_based((_segment)x)
#define BASED_ON_SEG(x)	_based(x)
#define	SEGMENT		_segment

	/* Externals assumed to be in DGROUP */
extern PROINFO	WinIniInfo;
extern PROINFO	PrivateProInfo;
extern LPSTR	lpWindowsDir;
extern int	cBytesWinDir;
extern int	WinFlags;
extern char	fBooting;
extern char	fProfileDirty;
extern char fProfileMaybeStale;
extern char	fAnnoyEarle;
extern char     fBooting;
extern LPSTR    curDTA;
extern BYTE fWriteOutProfilesReenter;

	/* Forward definitions to keep compiler happy */
	/* _fastcall may save some space on internal routines */
LPSTR _fastcall	BufferInit(PROINFO *, int);
LPSTR _fastcall LockBuffer(PROINFO *);
void  _fastcall	UnlockBuffer(PROINFO *);
LPSTR _fastcall	FreeBuffer(PROINFO *);
LPSTR _fastcall	PackBuffer(PROINFO *, int, int);
void  _fastcall FlushDirtyFile(PROINFO *);
int		GetInt(PROINFO *, LPSTR, LPSTR, int);
int		GetString(PROINFO *, LPSTR, LPSTR, LPSTR, LPSTR, int);
LPSTR		FindString(PROINFO *, LPSTR, LPSTR);
LPSTR		FindSection(LPSTR, LPSTR);
LPSTR		FindKey(LPSTR, LPSTR);
int		WriteString(PROINFO *, LPSTR, LPSTR, LPSTR);
void		strcmpi(void);
int		MyStrlen(void);
void API WriteOutProfiles(void);
PROINFO	* 	SetPrivateProInfo(LPSTR,LPSTR);
int GetSection(PROINFO*, LPSTR, LPSTR, int);
int IsItTheSame(LPSTR, LPSTR);
int Cstrlen(LPSTR);
int MakeRoom(LPSTR, int, int*);
int InsertSection(LPSTR, LPSTR, short);
int InsertKey(LPSTR, LPSTR, short);
int InsertResult(LPSTR, LPSTR, short);
int DeleteSection(LPSTR, PROINFO*);
int DeleteKey(LPSTR, PROINFO*);

	/* External KERNEL routines */
void _far _pascal FarMyLower();

int  API lstrOriginal(LPSTR,LPSTR);	/* lstrcmp in disguise */

#ifdef FE_SB
// Delacred in kernel.h already
// void _far _pascal AnsiPrev(LPSTR,LPSTR);
void _far _pascal FarMyIsDBCSLeadByte();
#endif

char CODESEG WinIniStr[] = "WIN.INI";

/* DOS FindFirst/FindNext structure (43h, 44h) */
typedef struct tagFILEINFO
{
        BYTE fiReserved[21];
        BYTE fiAttribute;
        WORD fiFileTime;
        WORD fiFileDate;
        DWORD fiSize;
        BYTE fiFileName[13];
} FILEINFO;

/*
 * Get[Private]ProfileInt
 *
 * Parameters:
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	nDefault		Default value to return if not found
 *	[lpFile			File to use for Private INI]
 *
 * Returns:
 *	nDefault		section/keyname not found
 *	number found in file if section/keyname found
 */
int API
IGetProfileInt(lpSection, lpKeyName, nDefault)
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = GetInt(&WinIniInfo, lpSection, lpKeyName, nDefault);

        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IGetPrivateProfileInt(lpSection, lpKeyName, nDefault, lpFile)
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
LPSTR	lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = GetInt(pProInfo, lpSection, lpKeyName, nDefault);
        --fWriteOutProfilesReenter;

        return nReturn;
}


/*
 * Get[Private]ProfileString
 *
 * Parameters:
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	lpDefault		Default string to return if not found
 *	lpResult		String to fill in
 *	nSize			Max number of characters to copy
 *	[lpFile]		File to use for Private INI
 *
 * Returns:
 *	string from file or lpDefault copied to lpResult
 *	< nSize - 2		Number of characters copied to lpResult
 *	nSize - 2		lpResult was not big enough
 */
int API
IGetProfileString(lpSection, lpKeyName, lpDefault, lpResult, nSize)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpDefault;
LPSTR lpResult;
int	 nSize;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = GetString(&WinIniInfo, lpSection, lpKeyName, lpDefault,
                lpResult, nSize);
        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IGetPrivateProfileString(lpSection, lpKeyName, lpDefault, lpResult, nSize, lpFile)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpDefault;
LPSTR lpResult;
int	nSize;
LPSTR lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = GetString(pProInfo, lpSection, lpKeyName, lpDefault,
                lpResult, nSize);

        --fWriteOutProfilesReenter;

        return nReturn;
}


/*
 * Write[Private]ProfileString
 *
 * Parameters:
 *	lpSection		Pointer to section to match/add to INI file
 *	lpKeyName		Pointer to key string to match/add to file
 *	lpString		String to add to file
 *	[lpFile]		File to use for Private INI
 *
 * Returns:
 *	0			Failed
 *	1			Success
 */
int API
IWriteProfileString(lpSection, lpKeyName, lpString)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpString;
{
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

        /* Reread INI file first if necessary */
        FlushDirtyFile(&WinIniInfo);

	nReturn = WriteString(&WinIniInfo, lpSection, lpKeyName, lpString);

        --fWriteOutProfilesReenter;

        return nReturn;
}


int API
IWritePrivateProfileString(lpSection, lpKeyName, lpString, lpFile)
LPSTR lpSection;
LPSTR lpKeyName;
LPSTR lpString;
LPSTR lpFile;
{
	PROINFO	*pProInfo;
	char	Buffer[128];
        int nReturn;

        /* Make sure we don't try to flush INI files on DOS calls */
        ++fWriteOutProfilesReenter;

	pProInfo = SetPrivateProInfo(lpFile, (LPSTR)Buffer);

        /* Reread INI file first if necessary */
        FlushDirtyFile(pProInfo);

	nReturn = WriteString(pProInfo, lpSection, lpKeyName, lpString);

        --fWriteOutProfilesReenter;

        return nReturn;
}


/*  FlushDirtyFile
 *      Rereads a file if it has been "dirtied" by another task.  To
 *      see if the file has been dirtied, we check the time/date
 *      stamp.
 */

void _fastcall FlushDirtyFile(PROINFO *pProInfo)
{
        FILEINFO FileInfo;
        DWORD dwSaveDTA;

        /* We only have to do this if the file COULD have changed and
         *      that we already have something cached.  Also, there's
         *      no need to do this at boot time because this is a
         *      safeguard against the USER doing something bad!
         */
        if (fBooting || !fProfileMaybeStale || !pProInfo->lpBuffer)
                return;

        /* The OFSTRUCT in the PROINFO buffer should have the most recent
         *  date and time when the file was opened.  We just compare the
         *  current date and time to this.
         */
        _asm
        {
        ;** Save old DTA and point to our structure
        mov     ah,2fh                  ;Get DTA.  Int21 code calls DOS only
        int     21h                     ;  if necessary.  DTA in ES:BX
        jc      RDF_FlushIt             ;Problem, so better flush it
        mov     WORD PTR dwSaveDTA[2],es ;Save for later
        mov     WORD PTR dwSaveDTA[0],bx
        mov     ah,1ah                  ;Set DTA
        push    ds                      ;Can't do a SetKernelDS so push/pop
        push    ss                      ;Get SS=DS
        pop     ds
        lea     dx,FileInfo             ;Point DTA to our structure
        int     21h                     ;Set the DTA
        pop     ds
        jc      RDF_FlushIt             ;Problem, so just flush it

        ;** Do a FindFirst on the file to get date and time reliably
        xor     cx,cx                   ;Normal file
        mov     si,pProInfo             ;Point to pathname with DS:DX
        lea     dx,[si].ProBuf
        add     dx,8                    ;(offset of szPathName)
        mov     ah,4eh                  ;Find first
        int     21h                     ;Call DOS
        jc      RDF_FlushIt             ;Can't find, so better flush it

        ;** Put DTA back
        push    ds
        lds     dx,dwSaveDTA            ;DS:DX points to old DTA
        mov     ah,1ah
        int     21h
        pop     ds

        ;** Compare the date and time
        lea     bx,FileInfo             ;Point to FILEINFO
        mov     dx,ss:[bx + 24]         ;Date in FILEINFO structure
        mov     cx,ss:[bx + 22]         ;Tile in FILEINFO structure
        mov     si,pProInfo             ;Point to OFSTRUCT with DS:SI
        lea     si,[si].ProBuf
    	cmp	[si + 4],dx		;Same date as original?
	jne	RDF_FlushIt             ;No
    	cmp	[si + 6],cx		;Same time as original?
	je	RDF_NoFlush             ;No
        }

        /* Force a file reread */
RDF_FlushIt:
        FreeBuffer(pProInfo);
RDF_NoFlush:

        /* Clear the dirty flag */
        fProfileMaybeStale = 0;
}


/*
 * SetPrivateProInfo
 *
 * Force a private profile into the windows directory if necessary.
 * Check if it is the same file as is currently cached.
 * If not, discard the cached file.
 * Sets up the PrivateProInfo data structure.
 *
 * Parameters:
 *	lpFile		Pointer to filename to be used as a profile
 *	Buffer		Buffer to parse filename into
 *
 * Returns:
 *	PROINFO *	Pointer to information about ini file
 */
PROINFO *
SetPrivateProInfo(lpFile, Buffer)
LPSTR lpFile;
LPSTR Buffer;
{
	OFSTRUCT NewFileBuf;
	char	c;
	char	fQualified = 0;
	char	BASED_ON_LP(lpFile) *psrc;
	int	Count = 0;

        /* Get rid of annoying warnings with this ugly cast */
        psrc = (char BASED_ON_LP(lpFile)*)(WORD)(DWORD)lpFile;

		/* For those who insist on using private routines for WIN.INI */
	if ( lstrOriginal(lpFile, (LPSTR)WinIniStr) == 0
	     || lstrOriginal(lpFile, WinIniInfo.ProBuf.szPathName) == 0 ) {
		return(&WinIniInfo);
	}

	/*
	 * Following code is from ForcePrivatePro
	 *
 	 * If the filename given is not qualified, we force
	 * it into the windows directory.
	 */
#ifdef FE_SB
_asm {
					;Apr.26,1990 by AkiraK
	cld
	push	ds			;save kernel DS
	xor	ax,ax
	mov	bx,'/' shl 8 + '\\'	; '/' or '\'
	xor	dx,dx
	lds	si,lpFile		; first get length of string
	mov	cx,si
	mov	al,ds:[si]
	call	FarMyIsDBCSLeadByte
	jnc	fpp_s1
	cmp	byte ptr ds:[si+1],':'	 ;
	jnz	fpp_s1
	inc	dx
fpp_s1:

fpp_l1:
	lodsb
	or	al,al
	jz	fpp_got_length
	cmp	al,bh
	jz	fpp_qualified
	cmp	al,bl
	jz	fpp_qualified
fpp_s2:
	call	FarMyIsDBCSLeadByte
	jc	fpp_l1
	inc	si
	jmp	fpp_l1

fpp_qualified:
	inc	dx
	jmp	fpp_s2
fpp_got_length:
;;	  mov	  fQualified, dx
	mov	fQualified, dl		    ; a byte variable
	sub	si, cx
	mov	Count, si
	pop	ds			    ;recover kernel DS
}
#else
			/* Drive specified? */
	if ( *(psrc+1) == ':' )
		fQualified++;
	while ( c = *psrc++ ) {
			/* Look for path separators */
		if ( c == '/' || c == '\\' )
			fQualified++;
		Count++;
	}
#endif

	/*
	 * Now copy filename to buffer.
	 * Prepend Windows directory if not qualified.
	 */
	_asm {
		cld
		push	ds
		les	di, Buffer		; Destination is Buffer
		cmp	fQualified, 0
		jnz	Qualified
		mov	cx, cBytesWinDir	; Pick up Windows directory
		lds	si, lpWindowsDir
		rep	movsb			; Copy it
		mov	al, '\\'
		cmp	es:[di-1], al		; BUG FIX: if in root, don't
		je	Qualified		;	   add separator
		stosb				; Add path separator
	Qualified:
		lds	si, lpFile		; Now add Filename we were given
		mov	cx, Count
		inc	cx			; Allow for NULL
		rep	movsb
		pop	ds
	}
#ifdef NOTNOW
	if ( !fBooting && fQualified ) {
			/*
			 * Use OpenFile to generate pathname for
			 * comparison with the cached pathname.
			 * OF_EXIST ensures we get a complete pathname
			 * We cannot use OF_PARSE, it does not search the path.
			 * We only do this if the pathname we were given was
			 * qualified since in other cases we force the file
			 * into the windows directory and therefore know
			 * that Buffer contains the complete pathname.
			 */
		NewFileBuf.szPathName[0] = 0;
		OpenFile(Buffer, &NewFileBuf, OF_EXIST);
	}
#endif
		/* Now see if the filename matches the cached filename */
	_asm {
		cld
		xor	cx, cx
		lea	si, word ptr [PrivateProInfo.ProBuf]	; Cached INI OFSTRUCT
		mov	cl, [si].cBytes
		lea	si, word ptr [si].szPathName	; Cached filename
		sub	cx, 8				; Get its length
	UseOriginal:				; Use the filename they gave us
		les	di, Buffer		; while booting
		xor	bl, bl
		call	strcmpi			; Ignore case while booting
		jmp	short DoWeDiscardIt
	JustCompare:
					; Not booting, compare OFSTRUCTS
					; Note OpenFile forced upper case
		push	ss
		pop	es		; NewFileBuf is on SS
		lea	di, word ptr NewFileBuf.szPathName[0];
		rep	cmpsb			; Compare filenames
	DoWeDiscardIt:
		jz	WeHaveItCached		; Don't discard if names match
	}
	/*
	 * The cached file is not the right one,
	 * so we discard the saved file.
	 */
	FreeBuffer(&PrivateProInfo);

WeHaveItCached:
		/* Save pointer to FileName - buffer may have been discarded */
	PrivateProInfo.lpProFile = Buffer;
	return(&PrivateProInfo);
}


/*
 * GetInt - search file and return an integer
 *
 * Parameters:
 *	pProInfo		Pointer to information on the INI file
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	nDefault		Default value to return if not found
 *
 * Returns:
 *	see GetProfileInt
 */
int
GetInt(pProInfo, lpSection, lpKeyName, nDefault)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
int	nDefault;
{
	LPSTR lpResult;

	lpResult = FindString(pProInfo, lpSection, lpKeyName);
	if (lpResult) {
			/* We found a string, convert to int */
		register int c;
		int radix = 10;
		BOOL fNeg = FALSE;

        // Skip spaces
        while (*lpResult == ' ' || *lpResult == '\t')
            ++lpResult;

		nDefault = 0;

		while ((c = *lpResult++) != 0) {

			// Watch for change in sign
			//
			if (c == '-') {
				fNeg = !fNeg;
				continue;
			}

			// Lower case the character if it's a letter.
			//
			if (c >= 'A' && c <= 'Z')
				c += ('a' - 'A');

			// deal with hex constants
			//
			if (c == 'x') {
				radix = 16;
				continue;
			}

			c -= '0';
			if (c > 9)
			    c += '0' - 'a' + 10;

			if (c < 0 || c >= radix)
			    break;

			nDefault = nDefault * radix + c;
		}
		if (fNeg)
		    nDefault = -nDefault;
	}
	UnlockBuffer(pProInfo);
	return(nDefault);
}


/*
 * GetString -  Search file for a specific Section and KeyName
 *
 * Parameters:
 *	pProInfo		Pointer to information on the INI file
 *	lpSection		Pointer to section to match in INI file
 *	lpKeyName		Pointer to key string to match in file
 *	lpDefault		Default string to return if not found
 *	lpResult		String to fill in
 *	nSize			Max number of characters to copy
 *
 * Returns:
 *	see GetProfileString
 */
GetString(pProInfo, lpSection, lpKeyName, lpDefault, lpResult, nSize)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
LPSTR	lpDefault;
LPSTR	lpResult;
int	nSize;
{
	int	nFound;
	LPSTR	lpFound;

	if ( !lpKeyName ) {
		nFound = GetSection(pProInfo, lpSection, lpResult, nSize);
		if ( nFound == -1 )
			goto	CopyDefault;	/* Yes, I know! */
	} else {
		lpFound = FindString(pProInfo, lpSection, lpKeyName);
		if ( lpFound )
			lpDefault = lpFound;
	CopyDefault:
	_asm	{
		xor	ax, ax				; Return value
		cmp	word ptr lpDefault[2], 0	; Check for null default
		je	SavedMe
		les	di, lpDefault
		call	MyStrlen		; Returns length in CX

                ; Fix for #10907  --  Used to GP fault on zero length str.
                or      cx,cx                   ; No characters in string?
                je      strdone

#ifdef	FE_SB
		; Get last character behind terminator
		push	si
		les	si, lpDefault		; SI = front of string
	gps_dbcs_l1:
		mov	al, es:[si]
		call	FarMyIsDBCSLeadByte
		cmc
		adc	si, 1
		cmp	si, di
		jb	gps_dbcs_l1
		pop	si
#else
		add	di, cx
		mov	al, es:[di-1]		; Final character in string
#endif
		les	di, lpDefault
		cmp	cx, 2		; strlen > 2
		jb	strdone
    					; Strip off single and double quotes
		mov	ah, es:[di]
		cmp	ah, al		; First character == last character?
		jne	strdone
		cmp	al, '\''
		je	strq
		cmp	al, '"'
		jne	strdone
	strq:
		sub	cx, 2		; Lose those quotes
		inc	di
	strdone:
					; CX has length of string
		mov	dx, nSize
		dec	dx		; Allow for null
		cmp	cx, dx		; See if enough room
		jbe	HaveRoom
		mov	cx, dx
	HaveRoom:
		cld
		push	ds
		push	es
		pop	ds
		mov	si, di		; DS:SI has string to return
		les	di, lpResult
		mov	ax, cx		; Save length of string
		rep	movsb		; Copy the string
		mov	byte ptr es:[di], 0	; Null terminate the string
		pop	ds
	SavedMe:
		mov	nFound, ax	; We will return this
		}
	}

	UnlockBuffer(pProInfo);
	return(nFound);
}


/*
 * GetSection - find a section and copy all KeyNames to lpResult
 *
 * Parameters:
 *	pProInfo		pointer to info on the file
 *	lpSection		pointer to the section name we want
 *	lpResult		where the KeyNames will go
 *	nSize			size of lpResult buffer
 *
 * Returns:
 *	int			Number of characters copied, -1 for failure
 */
int
GetSection(pProInfo, lpSection, lpResult, nSize)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpResult;
int	nSize;
{
	LPSTR	lp;

	lp = BufferInit(pProInfo, READ);
	if ( !lp )
		return(-1);	/* No buffer, (no file, no memory etc.) */

	nSize--;		/* Room for terminating NULL */

	lp = FindSection(lp, lpSection);
	if ( !lp )
		return(-1);

	_asm {
		push	ds
		lds	si, lpResult	; DS:SI is where we store the result
		les	di, lp		; ES:DI points to the section in buffer
		xor	dx, dx		; Count of characters in the result
	KeyNameLoop:
		mov	bx, di		; Save start of line
		cmp	es:[di], ';'	; Is this a comment line?
		jne	KeyNameNextCh	;   no, check this line out
		cld
		mov	cx, -1
		mov	al, LINEFEED
		repne	scasb		; Skip to end of the line
		jmp	KeyNameLoop
	KeyNameNextCh:
		mov	al, es:[di]	; Get next character
#ifdef FE_SB
		call	FarMyIsDBCSLeadByte
		cmc			; if the char is lead byte of DBCS,
		adc	di, 1		;  then di += 2, else di += 1
#else
		inc	di
#endif
		cmp	al, '='
		je	FoundEquals
		cmp	al, LINEFEED
		je	KeyNameLoop	; Ignore lines without an '='
		cmp	al, SECT_LEFT
		je	EndSection	; Done if end of section
		or	al, al		;  or if end of buffer (NULL)
		jne	KeyNameNextCh	; On to the next character
		jmp	EndSection
	FoundEquals:
		mov	di, bx		; Back to the start of the line
	CopyLoop:
		mov	al, es:[di]	; Pick up next character in line
		inc	di
		cmp	al, '='		; Is it the '='?
		jne	LeaveItAlone
		xor	al, al		;   yes, replace with NULL
	LeaveItAlone:
		mov	[si], al	; Put it in the result string
		inc	dx		; Number of characters in the result
		inc	si
		cmp	dx, nSize	; Overflowed?
		jb	NoProblem
		dec	dx		;   yes, ignore this character
		dec	si
	NoProblem:
#ifdef FE_SB
		call	FarMyIsDBCSLeadByte
		jc	NoProblem1
		mov	al, es:[di]
		inc	di
		mov	[si], al
		inc	dx
		inc	si
		cmp	dx, nSize
		jb	NoProblem1
		dec	si
		dec	dx
	NoProblem1:
#endif
		or	al, al		; Was this the '='
		jne	CopyLoop
	SkipLine:
		mov	al, es:[di]	; Skip the rest of the line
		inc	di
		cmp	al, LINEFEED
		jne	SkipLine
		jmp	KeyNameLoop

	EndSection:
		mov	byte ptr [si], 0	; Terminate with NULL
		or	dx, dx			; Did we copy anything?
		jz	NothingFound		;  no, no hack
#ifdef FE_SB
;AnsiPrev API has been moved to USER and it is not the
;right time to invoke any USER's APIs as we might be called
;while USER is still on the bed.
;		push	dx
;		push	word ptr lpResult[2]
;		push	word ptr lpResult[0]
;		push	ds
;		push	si
;		call	AnsiPrev
;		mov	si, ax
;		mov	byte ptr [si], 0
;		mov	byte ptr [si+1], 0
;		pop	dx
;-----------------------------------------------------------
		push	es
		push	di
		push	bx
		les	di,lpResult		;string head
ScanLoop:
		mov	bx,di			;"prev" char position
		mov	al,es:[di]
                call    FarMyIsDBCSLeadByte
                cmc
		adc	di, 1			;+2 if DBCS, +1 if not
		cmp	di,si			;have we hit the point yet?
		jb	ScanLoop		;nope,
;The output of this routine looks like:
;<name 1>,0,<name2>,0,.... <name n>,0,0
; the very last 0 tells the end of story.
		mov	es:[bx],0		;this is safe
		mov	es:[bx+1],0		;Hmmmmm
		pop	bx
		pop	di
		pop	es
#else
		mov	byte ptr [si-1], 0	; Hack - if we hit nSize, we
#endif
						; and extra NULL
	NothingFound:
		pop	ds
		mov	nSize, dx
		}
	return(nSize);
}


/*
 * FindString - look for section name and key name
 *
 * Parameters:
 *	pProInfo		Pointer to info on the file
 *	lp			Pointer to the buffer containing the file
 *	lpSection		Pointer to the section name we are looking for
 *	lpKeyName		Pointer the the KeyName we want
 *
 * Returns:
 *	LPSTR			Pointer to the start of the result string
 *				NULL for failure
 */
LPSTR
FindString(pProInfo, lpSection, lpKeyName)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
{
	LPSTR	lp;

	if ( lp = BufferInit(pProInfo, READ) )
		if ( lp = FindSection(lp, lpSection) )
			lp = FindKey(lp, lpKeyName);
	return(lp);
}


/*
 * FindSection - look for a section name enclosed in '[' and ']'
 *
 * Parameters:
 *	lp			Pointer to the buffer containing the file
 *	lpSection		Pointer to the section name we are looking for
 *
 * Returns:
 *	LPSTR			Pointer to the start of the section for success
 *				NULL for failure
 */
LPSTR
FindSection(lp, lpSection)
LPSTR	lp;
LPSTR	lpSection;
{
        WORD wCount;
        WORD wTrailCount;
        WORD fLead;
        LPSTR lpstr;
        WORD wSegLen;

        /* Remove leading whitespace from section names and compute
         *      a length count that doesn't include trailing whitespace.
         *      We use this below to force a TRUE compare even though
         *      the program put garbage on the end.
         */
        for (lpstr = lpSection, fLead = 1, wCount = wTrailCount = 0 ;
                *lpstr ; ++lpstr)
        {
                /* If we haven't passed leading space yet... */
                if (fLead)
                {
                        if (*lpstr == SPACE || *lpstr == TAB)
                                ++lpSection;
                        else
                        {
                                fLead = 0;
                                ++wCount;
                                ++wTrailCount;
                        }
                }

                /* Otherwise this might be trailing space... */
                else
                {
                        /* wCount always has correct count, wTrailCount
                         *      never counts whitespace until another
                         *      character is encountered.  This allows
                         *      a count of characters excluding trailing
                         *      whitespace.
                         */
                        ++wCount;
                        if (*lpstr != SPACE && *lpstr != TAB)
                                wTrailCount = wCount;
                }
        }
        wCount = wTrailCount;

	_asm {
                lsl     cx,WORD PTR lp[2] ; Get max possible search len
                mov     wSegLen,cx      ; Save for quick access later
		push	ds
		les	di, lp
	SectionLoop:
		cmp	byte ptr es:[di], SECT_LEFT	; ie '['
		jne	NotThisLine
		inc	di				; Skip the '['

                ;** Check the length of the string
                push    di              ; Save because we're going to trash
                mov     cx,wSegLen      ; Get segment length
                sub     cx,di           ; Subtract off the distance into seg
                mov     dx,cx           ; Save in DX
                mov     al,SECT_RIGHT   ; Stop when we encouter this
#ifdef	 FE_SB
;SECT_RIGHT is a legal DBCS second byte
;and we have to emulate DBCS "repne scasb" here.
        fsScanSectRight:
		dec	cx		;
                jz      fsScanFinish    ; reach to end of segment
		scasb			;
                je      fsScanFinish    ; find it!
                call    FarMyIsDBCSLeadByte
                jc      fsScanSectRight
                inc     di              ; skip DBCS 2nd byte
                dec     cx
                jnz     short fsScanSectRight
        fsScanFinish:

#else
                repne   scasb           ; Compare until we find it
#endif
                sub     dx,cx           ; Get true string len
                dec     dx
                pop     di
                cmp     dx,wCount       ; Same length?
                jne     NotThisLine

                ;** Now compare the strings.  Note that strcmpi returns a
                ;**     pointer just past the failed char
		lds	si, lpSection
                mov     bl, SECT_RIGHT                  ; Compare up to '['
		call	strcmpi
                je      HereItIs

                ;** Even if we failed, it might match less trailing whitespace
                sub     ax,di           ; Get length at first mismatch
                cmp     ax,wCount       ; Make sure we mismatched at end
                jne     NotThisLine     ; We didn't so get out
                add     di,ax           ; Bump pointers to end
                add     si,ax
                mov     al,es:[di - 1]  ; Compare last chars
                cmp     al,ds:[si - 1]  ; Do they match?
                jne     NotThisLine     ; Yes

        HereItIs:
		mov	al, LINEFEED	; Skip the rest of the line
		mov	cx, -1
		repne	scasb		; Scans ES:[DI]

		mov	ax, di
		mov	dx, es		; Return pointer to section
		jmp	FoundIt

	NotThisLine:
		mov	al, LINEFEED	; Skip the rest of the line
		mov	cx, -1		; Scans ES:[DI]
		repne	scasb

		cmp	byte ptr es:[di], 0		; End of the file?
		jne	SectionLoop			;  nope, continue
		xor	ax, ax
		xor	dx, dx				; Return 0
	FoundIt:
		pop	ds
		}
}


/*
 * FindKey - Find a KeyName given a pointer to the start of a section
 *
 * Parameters:
 *	lp			Pointer to start of a section
 *	lpKeyName		Pointer the the KeyName we want
 *
 * Returns:
 *	LPSTR			Pointer to the string following the KeyName
 *				NULL if KeyName not found
 */
LPSTR
FindKey(lp, lpKeyName)
LPSTR	lp;
LPSTR	lpKeyName;
{
        WORD wCount;
        WORD wTrailCount;
        WORD fLead;
        LPSTR lpstr;
        WORD wSegLen;

        /* Remove leading whitespace from key names and compute
         *      a length count that doesn't include trailing whitespace.
         *      We use this below to force a TRUE compare even though
         *      the program put garbage on the end.
         */
        for (lpstr = lpKeyName, fLead = 1, wCount = wTrailCount = 0 ;
                *lpstr ; ++lpstr)
        {
                /* If we haven't passed leading space yet... */
                if (fLead)
                {
                        if (*lpstr == SPACE || *lpstr == TAB)
                                ++lpKeyName;
                        else
                        {
                                fLead = 0;
                                ++wCount;
                                ++wTrailCount;
                        }
                }

                /* Otherwise this might be trailing space... */
                else
                {
                        /* wCount always has correct count, wTrailCount
                         *      never counts whitespace until another
                         *      character is encountered.  This allows
                         *      a count of characters excluding trailing
                         *      whitespace.
                         */
                        ++wCount;
                        if (*lpstr != SPACE && *lpstr != TAB)
                                wTrailCount = wCount;
                }
        }
        wCount = wTrailCount;

	_asm	{
		push	ds
		mov	ax, word ptr lpKeyName
		or	ax, word ptr lpKeyName[2]
		jz	NoMatch		; Return zero if lpKeyName is 0
                lsl     cx,WORD PTR lp[2] ; Get max possible search len
                mov     wSegLen,cx      ; Save for quick access later
		les	di, lp

                ;** See if we're at the end of the section
	FindKeyNext:
		mov	al,es:[di]	; Get next character
		or	al,al
		jz	NoMatch		; End of the file
		cmp	al,SECT_LEFT
		je	NoMatch		; End of the section
                cmp     al,CR           ; Blank line?
                je      NotThisKey      ; Yes, skip this one

                ;** Check the length of the string
                push    di              ; Save because we're going to trash
                mov     cx,wSegLen      ; Get segment length
                sub     cx,di           ; Subtract off the distance into seg
                mov     dx,cx           ; Save in DX
                mov     al,'='          ; Stop when we encouter this
                repne   scasb           ; Compare until we find it
                sub     dx,cx           ; Get true string len
                dec     dx
                pop     di
                cmp     dx,wCount       ; Same length?
                jne     NotThisKey

                ;** Now compare the strings.  Note that strcmpi returns a
                ;**     pointer just past the failed char.
                mov     bl,'='          ; Compare until we hit this
		lds	si,lpKeyName
		call	strcmpi
                mov     bx,di           ; Save DI value for below
                mov     di,ax
                je      FoundKey

                ;** Even if we failed, it might match less trailing whitespace
                sub     ax,bx           ; Get length at first mismatch
                cmp     ax,wCount       ; Make sure we mismatched at end
                jne     NotThisKey      ; Lengths at mismatch must match
                add     bx,ax           ; Bump pointers to end
                add     si,ax
                mov     al,es:[bx - 1]  ; Get last char that should match
                cmp     al,ds:[si - 1]  ; Does it match?
                je      FoundKey        ; Yes

        NotThisKey:
		mov	al, LINEFEED
		mov	cx, -1
		repne	scasb		; Scan to the end of the line
		jmp	FindKeyNext

	NoMatch:
		xor	ax, ax
		xor	dx, dx
		jmp	AndReturn
	FoundKey:
		inc	di		; Skip the '='
		mov	ax, di		; Return the pointer
		mov	dx, es
	AndReturn:
		pop	ds
		}
}


/*
 * MyStrlen - returns length of a string excluding trailing spaces and CR
 *
 * Paremeters:
 *	ES:DI			pointer to string
 *
 * Returns:
 *	CX			number of characters in string
 *
 */
int
MyStrlen()
{
_asm	{
; SPACE, CR, NULL never in DBCS lead byte, so we are safe here
	push	ax
	mov	cx, di		; CX = start of string
	dec	di
str1:
	inc	di
	mov	al, es:[di]	; Get next character
	cmp	al, CR
	ja	str1		; Not CR or NULL
str2:
	cmp	di, cx		; Back at the start?
	jbe	str3		;  yes
	dec	di		; Previous character
	cmp	byte ptr es:[di], SPACE
	je	str2		; skip spaces
	inc	di		; Back to CR or NULL
str3:
	cmp	es:[di], al
	je	maybe_in_code	; PMODE hack
	mov	es:[di], al	; Zap trailing spaces
maybe_in_code:
	neg	cx		; Calculate length
	add	cx, di
	pop	ax
	}
}


/*
 * Cstrlen - returns length of a string excluding trailing spaces and CR
 *	     This is a C callable interface to MyStrLen
 *
 * Paremeters:
 *	lp			pointer to string
 *
 * Returns:
 *	number of characters in string
 *
 */
int
Cstrlen(lp)
LPSTR	lp;
{
_asm	{
	xor	di, di		; Persuade compiler to save DI
	les	di, lp
	call	MyStrlen
	mov	ax, cx
	}
}


/*
 * strcmpi - internal case insensitive string compare
 *
 * Parameters:
 *	ES:DI & DS:SI		Strings to be compared
 *	BL			Character to terminate on
 *				DS:SI is null terminated
 *
 * Returns:
 *	ZF			indicates strings equal
 *	AX			pointer to next character in ES:DI string
 *                              or failed character in case of mismatch
 */
void
strcmpi()
{
_asm	{
#ifdef FE_SB
					;Apr.26,1990 by AkiraK
					; Copied directly from USERPRO.ASM
sti_l1:
	mov	al,es:[di]
	cmp	al,bl
	jz	sti_s1

	call	FarMyLower
	mov	cl,al

	mov	al,ds:[si]
	call	FarMyLower

	inc	si
	inc	di

	cmp	al,cl
	jnz	sti_exit

	call	FarMyIsDBCSLeadByte
	jc	sti_l1

	mov	al,es:[di]
	cmp	al,ds:[si]
	jnz	sti_exit

	inc	si
	inc	di
	jmp	short sti_l1

sti_s1:
	mov	al,ds:[si]
	or	al,al
sti_exit:
	mov	ax, di
#else
stci10:
	mov	al,es:[di]		; Get next character
	cmp	al,bl			; Character to terminate on?
	jnz	stci15			;  no, compare it
	mov	al,[si]			;  yes, strings equal if at end
	or	al,al
	jmp	stciex
stci15:
	call	FarMyLower		; Ensure both characters lower case
	mov	cl,[si]
	xchg	al,cl
	call	FarMyLower
	inc	si
	inc	di
	cmp	al,cl			; Still matching chars?
	jz	stci10			; Yes, go try the next char.
stciex:
	mov	ax,di			; Return pointer to next character
#endif
	}
}


/*
 * BufferInit
 *
 * Parameters:
 *	pProInfo		Pointer to structure describing an INI file
 *	OpenFlags		READ_WRITE if we are writing to the file
 *
 * Returns:
 *	Pointer to start of buffer on success
 *	(LPSTR)0		Failure
 *
 * Open or create the INI file as necessary
 * Get a buffer in memory for the file
 * Read the INI file into the buffer
 * Strip unwanted spaces comments and ^Zs from the buffer
 */
LPSTR _fastcall
BufferInit(pProInfo, OpenFlags)
PROINFO *pProInfo;
int	OpenFlags;
{
	LPSTR	BufAddr;
	long	llen;
	unsigned short	len;
	int	fh;
	int	hNew;
        BYTE byLastDrive;               /* Cache last drive read from */

		/* Ensure we have a handle for the buffer */
	if ( pProInfo->hBuffer == 0 )
		return(0L);
		/* If the buffer is already filled, return */
	if ( (BufAddr = LockBuffer(pProInfo)) != (LPSTR)NULL )
		return(BufAddr);

	pProInfo->ProFlags = 0;

        /* Remember the last drive read from to see if we have to reread
	 * the cluster size.
	 */
	byLastDrive = *pProInfo->ProBuf.szPathName;

	if ( pProInfo == &PrivateProInfo ) {
		/* Open a PRIVATE profile */
		fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ_WRITE+OF_SHARE_DENY_WRITE);
		if ( fh == -1 ) {
			/* Attempt to open for read. */
			if ( !OpenFlags ){
				pProInfo->ProFlags |= PROREADONLY;
				fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ+OF_SHARE_DENY_WRITE);
				/* If this fails, try compatibility mode. */
				if ( (fh == -1) && (pProInfo->ProBuf.nErrCode == SHARINGVIOLATION) ){
					fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, READ);
				}
			}else{
			/* If the open failed and we are writing, silently create the file.
			 * If the open failed because of sharing violation, try compatibility mode instead.
			 */
				if ( pProInfo->ProBuf.nErrCode != SHARINGVIOLATION ){
					OpenFlags |= OF_CREATE;
				}
				fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags);
			}
		}
	} else {
		/* Open WIN.INI */
		if ( OpenFlags )
			OpenFlags |= OF_CREATE;
		if ( pProInfo->ProBuf.cBytes ) {
				/* If previously found, reopen, don't create */
			OpenFlags |= OF_REOPEN+OF_PROMPT|OF_CANCEL|OF_SHARE_DENY_WRITE;
			OpenFlags &= ~OF_CREATE;
		}
		fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags|READ_WRITE);
		if ( (fh == -1) && !(OpenFlags & (READ_WRITE|OF_CREATE)) ) {
			pProInfo->ProFlags |= PROREADONLY;
			fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags+OF_SHARE_DENY_WRITE);
		}
		/* Sharing violation.  Let's try compatibility mode. */
		if ( (fh == -1) && ( pProInfo->ProBuf.nErrCode == SHARINGVIOLATION ) ){
			OpenFlags &= ~OF_SHARE_DENY_WRITE;
			fh = OpenFile(pProInfo->lpProFile, &pProInfo->ProBuf, OpenFlags);
		}
	}
	pProInfo->FileHandle = fh;

	/* If we are using a different drive than the last call or this is
	 *      the first time, clear cluster size so we reread it on next
	 *      call to WriteString.
	 */
	if (byLastDrive != *pProInfo->ProBuf.szPathName)
		pProInfo->wClusterSize = 0;

	if ( fh == -1 )
		goto ReturnNull;

		/* Seek to end of file, allow for CR, LF and NULL */
	llen = _llseek(fh, 0L, 2);
	if (!llen)
		pProInfo->ProFlags |= PRO_CREATED;
	llen += 3;
	if ( llen > MAXBUFLEN )
		llen = MAXBUFLEN;	/* Limit to plenty less than 64k */

			/* Now get a buffer */
	hNew = IGlobalReAlloc(pProInfo->hBuffer, llen, GMEM_ZEROINIT);
	if ( !hNew ) {
	ReturnNull:
		return( pProInfo->lpBuffer = (LPSTR)0 );
	}

		/* And now read in the file */
	pProInfo->hBuffer = hNew;
	LockBuffer(pProInfo);
	_llseek(fh, 0L, 0);			/* Seek to beginning of file */
	*(int _far *)pProInfo->lpBuffer = 0x2020;	/* Bogus spaces */

	len = _lread(fh, pProInfo->lpBuffer, (short)llen-3);
	if ( len == -1 ) {
		UnlockBuffer(pProInfo);
		return( FreeBuffer(pProInfo) );
	}
	if ( len < 2 )
		len = 2;		/* Prevent faults in PackBuffer */
	return( PackBuffer(pProInfo, len, OpenFlags & READ_WRITE) );
}


/*
 * LockBuffer - Lock the buffer containing the file.  Make it
 *		moveable and non-discardable.
 *      Instead of locking the buffer, we're just going to make it
 *      non-discardable and moveable.  This is preferable to locking it
 *      because all we really care about is that it doesn't get discarded.
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	LPSTR			Pointer to buffer containing file
 */
LPSTR _fastcall
LockBuffer(pProInfo)
PROINFO *pProInfo;
{
    /* We only have to lock the block if it's marked dirty.  Otherwise
     *  it's already unlocked.
     */
    if (!(pProInfo->ProFlags & PROUNCLEAN))
    {
        /* Make the block non-discardable */
        IGlobalReAlloc(pProInfo->hBuffer, 0L,
            GMEM_MODIFY + GMEM_MOVEABLE);

        /* All we need here is to dereference the handle.  Since
         *  this block is now non-discardable, this is all that
         *  IGlobalLock() really does.
         */
        pProInfo->lpBuffer = IGlobalLock(pProInfo->hBuffer);
        IGlobalUnlock(pProInfo->hBuffer);
    }

    return pProInfo->lpBuffer;
}


/*
 * UnlockBuffer - unlock the buffer, make it discardable and close the file.
 *    We don't really have to unlock the buffer (we weren't before anyway
 *    even though the comment says so)
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	nothing
 */
void _fastcall
UnlockBuffer(pProInfo)
PROINFO *pProInfo;
{
    int fh;

    if (!(pProInfo->ProFlags & PROUNCLEAN))
        IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_DISCARDABLE+GMEM_MODIFY);
    fh = pProInfo->FileHandle;
    pProInfo->FileHandle = -1;
    if (fh != -1)
        _lclose(fh);
}


/*
 * FreeBuffer - discards the CONTENTS of a buffer containing an INI file
 *
 * Parameter:
 *	pProInfo		Pointer to info describing INI file
 *
 * Returns:
 *	(LPSTR)0
 */
LPSTR _fastcall
FreeBuffer(pProInfo)
PROINFO *pProInfo;
{
	if ( pProInfo->ProFlags & PROUNCLEAN )
		WriteOutProfiles();
		/* Make the buffer discardable */
	IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_DISCARDABLE+GMEM_MODIFY);

		/* Make it zero length, shared, moveable and below the line */
	IGlobalReAlloc(pProInfo->hBuffer, 0L, GMEM_MOVEABLE);

	pProInfo->ProFlags = 0;
	return( pProInfo->lpBuffer = (LPSTR)0 );
}


/*
 * PackBuffer - strip blanks comments and ^Zs from an INI file
 *
 * Parameters:
 *	pProInfo		Pointer to info describing INI file
 *	Count			Number of characters in the buffer
 *	writing			Flag indicating we are writing to the file
 *
 * Returns:
 *	LPSTR			Pointer to the packed buffer
 *
 * NOTE: The use of Count here is DUMB.  We should stick a NULL
 *	 at the end, check for it and toss all the checks on Count.
 */
LPSTR _fastcall
PackBuffer(pProInfo, Count, fKeepComments)
PROINFO	*pProInfo;
int	Count;
int	fKeepComments;
{
        LPSTR	Buffer;
	char	BASED_ON_LP(Buffer) *psrc;
	char	BASED_ON_LP(Buffer) *pdst;
	char	BASED_ON_LP(Buffer) *LastValid;
	char	nextc;

        Buffer = pProInfo->lpBuffer;
	psrc = pdst = (char BASED_ON_LP(Buffer)*)(WORD)(DWORD)Buffer;

	if ( WinFlags & WF_PMODE )
		fKeepComments = 1;

	if ( fKeepComments )
		pProInfo->ProFlags |= PROCOMMENTS;

	while ( Count ) {
			/* Strip leading spaces and tabs */
		nextc = *psrc;
		if ( nextc == SPACE || nextc == TAB ) {
/* TAB or SPACE never in lead byte of DBCS, so loop is safe */
			Count--;
			psrc++;
			continue;
		}

			/* Process non-blanks */
		LastValid = pdst;
		do {
			nextc = *psrc++;
			Count--;
				/* Strip comments if real mode and not writing */
			if ( nextc == ';' && !fKeepComments ) {
				while ( Count && nextc != LINEFEED ) {
/* LINEFEED never in lead byte of DBCS, so loop is safe */
					nextc = *psrc++;
					Count--;
				}
				break;
			}
				/* Copy this character */
			*pdst++ = nextc;
#ifdef	FE_SB
			if ( Count && CIsDBCSLeadByte(nextc) ) {
				*pdst++ = *psrc++;
				Count--;
			}
#endif
			if ( nextc ==  '=' ) {
					/* Skip preceeding spaces and tabs */
				pdst = LastValid;
					/* New home for the '=' */
				*pdst++ = nextc;
					/* Skip spaces and tabs again */
				while ( Count ) {
					nextc = *psrc;
					if ( nextc != SPACE && nextc != TAB )
						break;
					Count--;
					psrc++;
				}
					/* Copy remainder of line */
				while ( Count ) {
					Count--;
/* LINEFEED never in lead byte of DBCS, so loop is safe */
					if ( (*pdst++ = *psrc++) == LINEFEED )
						break;
				}
				break;
			}

				/* End of file or line? */
			if ( Count == 0 || nextc == LINEFEED )
				break;

				/* Strip trailing spaces */
			if ( nextc == SPACE || nextc == TAB )
				continue;

			LastValid = pdst;
		} while ( Count );
			/* Here if end of line or file */
	}
		/* Here if end of file; skip trailing ^Zs */
	for ( ; ; ) {
		if ( pdst == Buffer )
			break;
		if ( *--pdst != CTRLZ ) {
			pdst++;
			break;
		}
	}

	*pdst++ = CR;
	*pdst++ = LINEFEED;
	*pdst++ = 0;

	IGlobalUnlock(pProInfo->hBuffer);
	IGlobalReAlloc(pProInfo->hBuffer, (long)((LPSTR)pdst - Buffer), 0);
	Buffer = LockBuffer(pProInfo);
	pProInfo->BufferLen = (unsigned)pdst;
	return(Buffer);
}


#ifdef FE_SB
/*
 * C interface to FarMyIsDBCSLeadByte
 *
 * Parameter:
 *	c		character to be tested
 *
 * Returns:
 *	1		It is a lead byte
 *	0		It isn't a lead byte
 */
CIsDBCSLeadByte(c)
char c;
{
_asm {
	mov	al, c
	call	FarMyIsDBCSLeadByte
	cmc			; Set carry if lead byte
	mov	ax, 0		; Set return value to 0, preserve flags
	adc	al, 0		; Set to one if carry set
}
}
#endif


/*
 * WriteString
 *
 * Adds/deletes sections/lines in an INI file
 *
 * Parameters:
 *	pProInfo		pointer to info on the file
 *	lpSection		pointer to the section name we want
 *	lpKeyName		key name to change or add
 *				NULL means delete section
 *	lpString		string to add to file
 *				NULL means delete line
 *
 * Returns:
 *	bResult			Success/Fail
 */
WriteString(pProInfo, lpSection, lpKeyName, lpString)
PROINFO	*pProInfo;
LPSTR	lpSection;
LPSTR	lpKeyName;
LPSTR	lpString;
{
	LPSTR	ptrTmp;
	short	WhatIsMissing;
	short	nchars;
	short	fh;
	long	fp;
	short	SectLen = 0;
	short	KeyLen = 0;
	short	ResultLen = 0;
	SEGMENT BufferSeg;
	register char BASED_ON_SEG(BufferSeg) *bp;

	/* Debugging noise */
		/* Assert that we have something to do! */
	if ( (SEGMENT)lpSection == NULL && (SEGMENT)lpKeyName == NULL
	     && (SEGMENT)lpString == NULL ) {
		FreeBuffer(pProInfo);	/* FEATURE! */
		return(0);
	}

		/* If buffer does not already contain comments, free it */
	if ( !(pProInfo->ProFlags & PROCOMMENTS) )
		FreeBuffer(pProInfo);

		/* Read the file into a buffer, preserving comments */
	ptrTmp = BufferInit(pProInfo, READ_WRITE);
	if ( !ptrTmp )
		return(0);

		/* Abort now if read only file */
	if ( pProInfo->ProFlags & PROREADONLY )
                goto GrodyError;

		/* Set bp to point in buffer where we will add stuff */
	BufferSeg = (SEGMENT)ptrTmp;
	bp = pProInfo->BufferLen + (char BASED_ON_SEG(BufferSeg)*)
                (WORD)(DWORD)ptrTmp - 1;

	/*
	 * Now see what we have to do to the file by
	 * searching for section and keyname.
	 */
	nchars = 0;

		/* See if section exists */
	if ( !(ptrTmp = FindSection(ptrTmp, lpSection)) ) {
			/* No Section. If deleting anything, stop now */
		if ( !lpKeyName || !lpString )
			goto NothingToDo;
			/* Need to add section and keyname */
		WhatIsMissing = NOSECTION;
	} else {
			/* Found the section, save pointer to it */
		bp = (char BASED_ON_SEG(BufferSeg)*)(WORD)(DWORD)ptrTmp;
			/* If lpKeyName NULL, delete the section */
		if ( !lpKeyName ) {
			WhatIsMissing = REMOVESECTION;
		} else {
				/* Look for the keyname in the section */
			if ( !(ptrTmp = FindKey(bp, lpKeyName)) ) {
					/* No KeyName, stop if deleting it */
				if ( !lpString )
					goto NothingToDo;
				WhatIsMissing = NOKEY;
					/* Insert new keyname
					   at the end of the section */
				while ( *bp && (*bp != SECT_LEFT || *(bp-1) != LINEFEED) )
					bp++;
			} else {
					/* Found the keyname, save pointer */
				bp = (char BASED_ON_SEG(BufferSeg)*)
                                        (WORD)(DWORD)ptrTmp;
					/* NULL lpString means delete it */
				if ( !lpString )
					WhatIsMissing = REMOVEKEY;
				else {
					/*
					 * Compare the existing string with the
					 * string we are supposed to replace it
					 * with.  If they are the same, there
					 * is no need to rewrite the file, so
					 * we abort now.
					 */
					if ( !IsItTheSame((LPSTR)bp, lpString) )
						goto NothingToDo;

					/*
					 * Count characters in old result.
					 * The file will be shrinking by
					 * this many characters.
					 */
					while ( *bp++ != CR )
						nchars--;
					bp = (char BASED_ON_SEG(BufferSeg)*)
                                                (WORD)(DWORD)ptrTmp;
					WhatIsMissing = NEWRESULT;
				}
			}
		}
	}

	/*
	 * If we will be adding to the file, grow the buffer
	 * to the size we will need, then make an appropriate
	 * sized hole in the buffer.
	 */
	switch ( WhatIsMissing ) {

	case NOSECTION:
			/* Need to add section */
		SectLen = Cstrlen(lpSection);
		nchars = SectLen + 4;	/* for []<CR><LF> */
			/* Fall through for KeyName and result */

	case NOKEY:
			/* Need to add key name */
		KeyLen = Cstrlen(lpKeyName);
		nchars += KeyLen + 3;	/* for =<CR><LF> */

			/* For new key or section, skip back to previous line */
		while ( bp > pProInfo->lpBuffer ) {
			bp--;
			if ( *bp != CR && *bp != LINEFEED )
				break;
		}
		if ( bp != pProInfo->lpBuffer )
			bp += 3;
			/* Fall through for result */

                /* If not at start of buffer, add room for extra CR/LF */
                if ((WORD)bp && WhatIsMissing == NOSECTION)
                        nchars += 2;

	case NEWRESULT:
			/* Need to change/add result */
			/* nchars may be -<current length of result> */
		ResultLen = Cstrlen(lpString);
		nchars += ResultLen;

			/* Grow the buffer if necessary */
		if ( nchars > 0 ) {
			IGlobalUnlock(pProInfo->hBuffer);

			fp = nchars + (long)pProInfo->BufferLen;
				/* Ensure buffer will be plenty less than 64k */
				/* and grow to new size */
			if ( fp > MAXBUFLEN || !IGlobalReAlloc(pProInfo->hBuffer, fp, 0) ) {
				/* Undo above Unlock */
				IGlobalLock(pProInfo->hBuffer);
                                goto GrodyError;
			}
			pProInfo->lpBuffer = IGlobalLock(pProInfo->hBuffer);
			BufferSeg = (SEGMENT)pProInfo->lpBuffer;
		}

                /* In order to fix bug #4672 and other ugly things
                 *      that happen when we run out of disk space,
                 *      we want to see if there is room to write the
                 *      buffer.  We know that the file can actually only
                 *      grow on cluster boundaries, but rather than get
                 *      the cluster size.  If we don't have the cluster
                 *      size yet, we have to get it from DOS.
                 */
                if (!pProInfo->wClusterSize)
                {
                        WORD wTemp;

                        /* Get drive letter */
                        wTemp = *pProInfo->ProBuf.szPathName - 'A' + 1;
                        _asm
                        {
                                mov     ah,1ch  ;Drive parameters
                                mov     dl,BYTE PTR wTemp
                                push    ds
                                int     21h
                                pop     ds
                                cmp     al,0ffh ;Error?
                                jnz     DPOk    ;No
                                mov     al,1
                                mov     cx,512  ;Default
                        DPOk:   cbw             ;Secs per cluster WORD
                                mul     cx      ;AX = bytes/cluster
                                mov     wTemp,ax
                        }
                        if (!wTemp)
                                pProInfo->wClusterSize = 512;
                        else
                                pProInfo->wClusterSize = wTemp;
                }

                /* Now see if we're going past a cluster length */
                if ((pProInfo->ProFlags & PRO_CREATED) ||
                        (((pProInfo->BufferLen + nchars) ^ pProInfo->BufferLen)
                        & ~(pProInfo->wClusterSize - 1)))
                {
                        int fh;

                        /* Make sure that we only do this once for a newly-
			 *      created file because this will handle the
                         *      growing to one cluster case.
                         */
                        pProInfo->ProFlags &= ~PRO_CREATED;
                        fh = pProInfo->FileHandle;

                        /* Make sure the file is open and exists.  If not,
                         *      we have to open the file.  We are guaranteed
                         *      at least that the file exists in this case.
                         *      Note that UnlockBuffer closes the file
                         *      that we open here.
                         */
                        if (fh == -1)
                        {
				fh = OpenFile(pProInfo->lpProFile,&pProInfo->ProBuf,OF_REOPEN+READ_WRITE+OF_SHARE_DENY_WRITE);
                                /* Sharing violation.  Let's try compabitility mode. */
				if ( (fh == -1) && (pProInfo->ProBuf.nErrCode == SHARINGVIOLATION ) ){
					fh = OpenFile(pProInfo->lpProFile,&pProInfo->ProBuf,OF_REOPEN+READ_WRITE);
				}
				pProInfo->FileHandle = fh;
                        }

                        /* Try to grow the file to the right length */
                        if(_llseek(fh, pProInfo->BufferLen + nchars, 0) !=
                                pProInfo->BufferLen + nchars ||
                                _lwrite(fh, " ", 1) != 1)
                                goto GrodyError;
                }

                /* Now, make room in the buffer for this new stuff */
		if ( nchars )
			MakeRoom((LPSTR)bp, nchars, &pProInfo->BufferLen);

			/* Now copy in the new info */
		switch ( WhatIsMissing ) {
		case NOSECTION:
				/* Create the new section */
			(int)bp = InsertSection((LPSTR)bp, lpSection, SectLen);
			/* FALL THROUGH */

		case NOKEY:
			(int)bp = InsertKey((LPSTR)bp, lpKeyName, KeyLen);
			/* FALL THROUGH */

		case NEWRESULT:
			(int) bp = InsertResult((LPSTR)bp, lpString, ResultLen);
		}
		break;

		/* Handle deleting sections or KeyNames */
	case REMOVESECTION:
		DeleteSection((LPSTR)bp, pProInfo);
		break;

	case REMOVEKEY:
		DeleteKey((LPSTR)bp, pProInfo);
		break;
	}

	pProInfo->ProFlags |= PROUNCLEAN;
	fProfileDirty = 1;

NothingToDo:
	UnlockBuffer(pProInfo);
	return(1);

        /* I really hate the GOTO, but in order to clean up, this is much
         *      more efficient...
         */
GrodyError:
        UnlockBuffer(pProInfo);
        return 0;
}


/*
 * WriteOutProfiles
 *
 * Called on a task switch or at exit time
 *
 * If we have a dirty profile buffer, write it.
 */
void API
WriteOutProfiles(void)
{
	LPSTR	ptrTmp;
	int	fh;
	PROINFO	*pProInfo;
     	int	nwritten;

        /* Make sure that we don't get called through a DOS call.  This
         *      flag is tested in I21ENTRY.ASM in the Int 21h hook to see
         *      if the profiles should be flushed.
         */
        ++fWriteOutProfilesReenter;

	for ( pProInfo = &WinIniInfo; ; pProInfo = &PrivateProInfo ) {
		if ( !(pProInfo->ProFlags & PROUNCLEAN) )
			goto NoWrite;
		if (
/* Try read/write with sharing flags, then try compabitility mode, then try to create it. */
			( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | READ_WRITE | OF_SHARE_DENY_WRITE)) == -1)
			&& ( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | READ_WRITE)) == -1)
			&& ( (fh = OpenFile(NULL, &pProInfo->ProBuf, OF_REOPEN | OF_CREATE)) == -1) ){
				goto NoWrite;
			}
		pProInfo->FileHandle = fh;

			/* Finally write the file */
		ptrTmp = pProInfo->lpBuffer;
		nwritten = _lwrite(fh, ptrTmp, pProInfo->BufferLen-3);
		if ( nwritten == pProInfo->BufferLen-3 ) {
			_lwrite(fh, ptrTmp, 0);		/* Mark end of file */
			pProInfo->ProFlags &= ~(PROUNCLEAN | PRO_CREATED);
			UnlockBuffer(pProInfo);
		} else {
			_lclose(fh);
		}
	NoWrite:
		if ( pProInfo == &PrivateProInfo )
			break;
	}
	fProfileDirty = 0;

	--fWriteOutProfilesReenter;
}


/*
 * See if two character strings are the same.
 * Special routine since one is terminated with <CR>.
 * Returns zero if the strings match.
 */
IsItTheSame(CRstring, NullString)
LPSTR CRstring;
LPSTR NullString;
{
_asm {
	push	ds
	les	di, CRstring		; CR terminated string
	lds	si, NullString		; Null terminated string
	xor	ah, ah			; High byte of return value
stci10:
	mov	al,es:[di]		; Get next character
	cmp	al,0Dh			; CR?
	jnz	stci15			;  no, compare it
	mov	al,[si]			;  yes, strings equal if at end
	jmp	stciex
stci15:
	mov	cl,[si]
	inc	si
	inc	di
	cmp	al,cl			; Still matching chars?
	jz	stci10			; Yes, go try the next char.
	mov	al, 1			; Didn't match
stciex:
	pop	ds
}
}


/*
 * Create or close a hole in the buffer.
 * Used to create room for a new section,
 * keyname or result and to remove unwanted
 * sections, keynames or results.
 *
 * Parameters:
 *	lp		position in buffer to add/remove characters
 *	nchars		number of characters to add/remove
 *	pAdjust		pointer to variable containing current
 *			size of the buffer
 *
 * Side effects:
 *	*pAdjust is changed by nchars
 *
 * Returns:
 *	nothing
 */
MakeRoom(lp, nChars, pAdjust)
LPSTR	lp;
short	nChars;
int	*pAdjust;
{
	short	BufLen = *pAdjust;

	if ( nChars < 0 )
	_asm {
		push	ds
		les	di, lp			; Where characters will be taken
		push	es
		pop	ds
		mov	si, di			; End of area
		sub	si, nChars		; Remember nChars is negative
		mov	cx, BufLen
		sub	cx, si			; Calculate # characters to move
		cld
		rep	movsb			; Copy characters down
		pop	ds
	} else _asm {
		push	ds
		mov	es, word ptr lp[2]	; Get segment to copy in
		mov	ds, word ptr lp[2]
		mov	si, BufLen		; We will be moving backwards
		mov	cx, si
		dec	si			; Adjust pointer for move
		mov	di, si			; so start at end of the buffer
		sub	cx, word ptr lp		; Number of characters to move
		add	di, nChars
		std				; Backwards move
		rep	movsb			; Copy characters up
		cld
		pop	ds
	}
	*pAdjust += nChars;
}


/*
 * Delete a section from the buffer,
 * preserving comments since they may
 * relate to the next section
 *
 * Parameters:
 *	lp			pointer to section returned by FindSection
 *	pProInfo		pointer to INI file info
 *
 * Returns:
 *	nothing
 */
DeleteSection(lp, pProInfo)
LPSTR	lp;
PROINFO *pProInfo;
{
	int	nRemoved;
	char BASED_ON_LP(lp) *SectEnd;

	_asm {
		cld
		push	ds
		lds	si, lp
	BackToStart:
		dec	si		; Skip backwards to start of the section
		cmp	ds:[si], SECT_LEFT
		jne	BackToStart

		mov	di, si
		push	ds
		pop	es		; ES:DI points to start of section
		inc	si		; DS:SI points to the '[', skip it
	RemoveLoop:
		lodsb			; Get next character in section
		cmp	al, ';'		; Is it a comment
		jne	NotComment

	CopyComment:
		stosb			; Save this character
		cmp	al, LINEFEED	; Copy to end of the line
		je	RemoveLoop
		lodsb			; And get the next one
		jmp	CopyComment

	NotComment:
		cmp	al, SECT_LEFT	; So is it the next section?
		je	EndSection
		or	al, al		; or the end of the buffer?
		jne	SkipLine
		sub	si, 2		; Extra CR & LF at end of buffer
		jmp	short EndSection

	SkipLine:
		cmp	al, LINEFEED	; Nothing interesting, so skip line
		je	RemoveLoop
		lodsb
		jmp	SkipLine

	EndSection:
		dec	si		; Back to the character
		mov	SectEnd, si	; where the search stopped
		mov	word ptr lp, di	; End of copied comments (if any)
		sub	si, di
		mov	nRemoved, si	; Number of characters removed
		pop	ds
	}

	MakeRoom(lp, -nRemoved, &pProInfo->BufferLen);
}


/*
 * Delete a keyname from the buffer
 *
 * Parameters:
 *	lp			pointer to keyname returned by FindKey
 *	pProInfo		pointer to INI file info
 *
 * Returns:
 *	nothing
 */
DeleteKey(lp, pProInfo)
LPSTR	lp;
PROINFO *pProInfo;
{
	int	nRemoved;
	char BASED_ON_LP(lp) *KeyEnd;

	_asm {
		cld
		les	di, lp
	BackToStart:
		dec	di		; Skip backwards to start of the line
		cmp	es:[di], LINEFEED
		jne	BackToStart
		inc	di
		mov	word ptr lp, di	; Save start of the line

		mov	cx, -1
		mov	al, LINEFEED
		repne	scasb		; Scan to end of the line
		sub	di, word ptr lp
		mov	nRemoved, di	; Length of line
	}
	MakeRoom(lp, -nRemoved, &pProInfo->BufferLen);
}


/*
 * Insert a new section in the buffer.
 * A hole has already been created for it.
 * This merely copies the string, places
 * '[]'s around it and a CR, LF after it.
 * Returns a pointer to immediately
 * after the section header in the buffer.
 *
 * Parameters:
 *	lpDest			pointer to where to add the section
 *	lpSrc			pointer to the section name
 *	count			length of lpSrc
 */
InsertSection(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
        or      di,di                   ; If at start of buffer, no prefix
        jz      IS_SkipPrefix
	mov	ax, LINEFEED SHL 8 + CR	; Prefix with CR/LF
	stosw
IS_SkipPrefix:
	mov	al, SECT_LEFT		; '[' first
	stosb
	mov	cx, count		; Now the section name
	rep	movsb
	mov	al, SECT_RIGHT		; and the ']'
	stosb
	mov	ax, LINEFEED SHL 8 + CR	; finally, CR, LF
	stosw
	pop	ds
	mov	ax, di			; Return pointer to char after header
}
}


/*
 * Insert a new keyname in the buffer.
 * This copies the keyname and adds
 * an '='.  It is assumed that InsertResult()
 * will terminate the line.
 * A pointer to the buffer immediately after
 * the '=' is returned.
 *
 * Parameters:
 *	lpDest			pointer to where to add the keyname
 *	lpSrc			pointer to the keyname
 *	count			length of lpSrc
 */
InsertKey(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
	mov	cx, count		; Copy the KeyName
	rep	movsb
	mov	al, '='			; add the '='
	stosb
	mov	ax, di			; Pointer to char after the '='
	pop	ds
}
}


/*
 * Add a new result string to the buffer.
 * It assumes that the keyname and '=' are
 * already there.  This routine may be
 * overwriting an existing result.  The result
 * is terminated with a CR, LR.
 *
 * Parameters:
 *	lpDest			pointer to where to add the result
 *	lpSrc			pointer to the result
 *	count			length of lpSrc
 */
InsertResult(lpDest, lpSrc, count)
LPSTR	lpDest;
LPSTR	lpSrc;
short	count;
{
_asm {
	cld
	push	ds
	les	di, lpDest
	lds	si, lpSrc
	mov	cx, count		; Copy the result
	rep	movsb
	mov	ax, LINEFEED SHL 8 + CR	; finally, CR, LF
	stosw				; This may overwrite existing CR, LF
	mov	ax, di
	pop	ds
}
}

/*
 * GetFileAttr
 *
 * DOS call to Get file attributes
GetFileAttr(szFile)
LPSTR szFile;
{
_asm {
	int 3
	xor	cx, cx			; In case of failure
	lds	dx, szFile
	mov	ax, 4300h
	int	21h
	mov	ax, cx
}
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\winkern.inc ===
MASTER_OBJECT_SIZE  equ 512

LOCALHEAP_SIG   EQU 'HL'
GLOBALHEAP_SIG  EQU 'HG'

; Debug fill constants

DBGFILL_ALLOC   equ     0fdh
DBGFILL_FREE    equ     0fbh
DBGFILL_BUFFER  equ     0f9h
DBGFILL_STACK   equ     0f7h

ife PMODE32

; Data structure that describes an allocation arena.  Both the local
; and global allocators use this structure at the beginning of their
; information structures.
;
HeapInfo    STRUC
hi_check    DW  ?   ; arena check word (non-zero enables heap checking)
hi_freeze   DW  ?   ; arena frozen word (non-zero prevents compaction)
hi_count    DW  ?   ; #entries in arena
hi_first    DW  ?   ; first arena entry (sentinel, always busy)
hi_last     DW  ?   ; last arena entry (sentinel, always busy)
hi_ncompact DB  ?   ; #compactions done so far (max of 3)
hi_dislevel DB  ?   ; current discard level
hi_distotal DW  ?   ; total amount discarded so far
hi_htable   DW  ?   ; head of handle table list
hi_hfree    DW  ?   ; head of free handle table list
hi_hdelta   DW  ?   ; #handles to allocate each time
hi_hexpand  DW  ?   ; address of near procedure to expand handles for
            ; this arena
hi_pstats   DW  ?   ; address of statistics table or zero
HeapInfo    ENDS

else    ; PMODE32

; Data structure that describes an allocation arena.  Both the local
; and global allocators use this structure at the beginning of their
; information structures.
;
HeapInfo    STRUC
hi_check    DW  ?   ; arena check word (non-zero enables heap checking)
hi_freeze   DW  ?   ; arena frozen word (non-zero prevents compaction)
hi_count    DW  ?   ; #entries in arena
hi_first    DW  ?   ; first arena entry (sentinel, always busy)
        DW  ?
hi_last     DW  ?   ; last arena entry (sentinel, always busy)
        DW  ?
hi_ncompact DB  ?   ; #compactions done so far (max of 3)
hi_dislevel DB  ?   ; current discard level
hi_distotal DD  ?   ; total amount discarded so far
hi_htable   DW  ?   ; head of handle table list
hi_hfree    DW  ?   ; head of free handle table list
hi_hdelta   DW  ?   ; #handles to allocate each time
hi_hexpand  DW  ?   ; address of near procedure to expand handles for
            ; this arena
hi_pstats   DW  ?   ; address of statistics table or zero
HeapInfo    ENDS

phi_first   equ dword ptr hi_first
phi_last    equ dword ptr hi_last

endif   ; PMODE32

; Handle table entry.

HandleEntry STRUC
he_address  DW  ?   ; actual address of object
he_flags    DB  ?   ; flags and priority level
he_seg_no   DB  ?   ; 0-based segment number for discardable code
HandleEntry ENDS
he_EMSPID_no    equ byte ptr he_seg_no

FreeHandleEntry STRUC
he_link     DW  ?
he_free     DW  ?
FreeHandleEntry ENDS

LocalHandleEntry STRUC
lhe_address DW  ?   ; actual address of object
lhe_flags   DB  ?   ; flags and priority level
lhe_count   DB  ?   ; lock count
LocalHandleEntry ENDS

LocalFreeHandleEntry STRUC
lhe_link    DW  ?
lhe_free    DW  ?
LocalFreeHandleEntry ENDS

he_owner    EQU he_address  ; Discarded objects contain owner field
                ; here so we know when to free handle
                ; table entries of discarded objects.

HE_DISCARDABLE  EQU 00Fh    ; Discard level of this object
HE_DISCARDED    EQU 040h    ; Marks objects that have been discarded.

HE_FREEHANDLE   EQU 0FFFFh  ; Use -1 to mark free handle table entries


LHE_DISCARDABLE EQU 00Fh    ; Discard level of this object
LHE_DISCARDED   EQU 040h    ; Marks objects that have been discarded.
LHE_USERFLAGS   EQU 01Fh    ; Mask for user setable flags

LHE_FREEHANDLE  EQU 0FFFFh  ; Use -1 to mark free handle table entries


HE_ALIGN    = 4-1
HE_MASK     = NOT HE_ALIGN

; Handles are allocated in blocks of N, where N is the hi_hdelta field
; in the local heap information structure.  The last word of each block
; of handles is used to thread the blocks together, allowing all handles
; to be enumerated.  The first word of every block is the number of
; handle table entries in the block.  Not only does it save us code
; in henum, but it also has the convenient property of placing all
; handle entries on 2 byte boundaries (i.e. 2, 6, 10, 14), since the
; LA_MOVEABLE bit is 02h.  Thus the address of the he_address field of
; a handle table entry is also the address of the handle table entry
; itself.

HandleTable STRUC
ht_count    DW  ?       ; # handletable entries in this block
ht_entry    DB SIZE HandleEntry DUP (?)
HandleTable ENDS

LocalHandleTable STRUC
lht_count    DW  ?      ; # handletable entries in this block
lht_entry    DB  SIZE LocalHandleEntry DUP (?)
LocalHandleTable ENDS

; Local arena objects are kept in a doubly linked list.

LocalArena  STRUC
la_prev     DW  ?   ; previous arena entry (first entry points to self)
la_next     DW  ?   ; next arena entry  (last entry points to self)
la_handle   DW  ?   ; back link to handle table entry
LocalArena  ENDS
la_fixedsize    = la_handle    ; Fixed arena headers stop here

LA_MINBLOCKSIZE = la_fixedsize*4  ;*** This must be larger than LocalArenaFree

; free blocks have these extra items.
la_size     = la_handle ; size of block (includes header data)
LocalArenaFree  STRUC
        DB  SIZE LocalArena DUP (?)
la_free_prev    DW  ?   ; previous free entry
la_free_next    DW  ?   ; next free entry
LocalArenaFree  ENDS
la_freefixedsize = SIZE LocalArenaFree ; Free block header stops here

; Local arena objects are aligned on 4 byte boundaries, leaving the
; low order two bits always zero.

LA_ALIGN    = 4-1
LA_MASK     = NOT LA_ALIGN
LA_FREE     = 00h
LA_BUSY     = 01h       ; Saved in la_prev field of header
errnz   <LA_ALIGN - LA_MOVEABLE - LA_BUSY>


; Flags passed to LocalAlloc (zero is the default case)

LA_MOVEABLE EQU 02h     ; Saved in la_prev field of header
LA_NOCOMPACT    EQU 10h
LA_ZEROINIT EQU 40h
LA_MODIFY   EQU 80h


; Data structure that describes the local arena.  Allocated as the first
; object in each local heap.  _pLocalHeap is a reserved location each
; automatic data segment that contains the pointer to this structure.

LocalInfo   STRUC
        DB  SIZE HeapInfo DUP (?)
li_notify   DD  ?   ; Far proc to call whenever a local block is moved
li_lock     DW  ?   ; arena lock word
li_extra    DW  ?   ; minimum amount to grow DS by
li_minsize  DW  ?   ; minimum size of heap
li_sig      DW  ?   ; signature for local heap
LocalInfo   ENDS

; Notify procedure message codes

LN_OUTOFMEM = 0     ; Out of memory - arg1 = #bytes needed
LN_MOVE     = 1     ; Object moved - arg1 = handle arg2 = old location
LN_DISCARD  = 2     ; Object discard? - arg1 = handle, arg2 = discard flags
            ; Returns new discard flags in AX

LocalStats  STRUC
ls_ljoin    DW  ?   ; #calls to ljoin
ls_falloc   DW  ?   ; #calls to lalloc with forward search
ls_fexamine DW  ?   ;   #arena entries examined by ls_falloc calls
ls_fcompact DW  ?   ;   #calls to lcompact by ls_falloc calls
ls_ffound   DW  ?   ;   #ls_falloc calls that found a block
ls_ffoundne DW  ?   ;   #ls_falloc calls that failed to find a block
ls_malloc   DW  ?   ; #calls to lalloc with backward search
ls_mexamine DW  ?   ;   #arena entries examined by ls_malloc calls
ls_mcompact DW  ?   ;   #calls to lcompact by ls_malloc calls
ls_mfound   DW  ?   ;   #ls_malloc calls that found a block
ls_mfoundne DW  ?   ;   #ls_malloc calls that failed to find a block
ls_fail     DW  ?   ; #times lalloc failed because unable to grow DS
ls_lcompact DW  ?   ; #calls to lcompact
ls_cloop    DW  ?   ; #repeated compacts after discarding
ls_cexamine DW  ?   ; #entries examined in compaction loop
ls_cfree    DW  ?   ; #free entries examined in compaction loop
ls_cmove    DW  ?   ; #moveable entries moved by compaction
LocalStats  ENDS


IncLocalStat    MACRO   n
if KDEBUG
inc ds:&n[di+SIZE LocalInfo]
endif
ENDM

; Global arena objects are kept in a doubly linked list.
;
ifdef WOWJUNK
GlobalArena STRUC
ga_count    DB  ?   ; lock count for movable segments
ga_flags    DB  ?   ; 1 byte available for flags
ga_owner    DW  ?   ; DOS 2.x 3.x owner field (current task)
ga_size     DW  ?   ; DOS 2.x 3.x size, in paragraphs, not incl. header
ga_prev     DW  ?   ; previous arena entry (first points to self)
ga_next     DW  ?   ; next arena entry (last points to self)
ga_handle   DW  ?   ; back link to handle table entry
ga_lruprev  DW  ?   ; Previous handle in lru chain
ga_lrunext  DW  ?   ; Next handle in lru chain
GlobalArena ENDS
else
GlobalArena STRUC
ga_count    DB  ?   ; lock count for movable segments
ga_owner    DW  ?   ; DOS 2.x 3.x owner field (current task)
ga_size     DW  ?   ; DOS 2.x 3.x size, in paragraphs, not incl. header
ga_flags    DB  ?   ; 1 byte available for flags
ga_prev     DW  ?   ; previous arena entry (first points to self)
ga_next     DW  ?   ; next arena entry (last points to self)
ga_handle   DW  ?   ; back link to handle table entry
ga_lruprev  DW  ?   ; Previous handle in lru chain
ga_lrunext  DW  ?   ; Next handle in lru chain
GlobalArena ENDS
endif; WOW
ga_sig       = byte ptr ga_count ; DOS =< 3.x signature byte for fixed segs

ga_freeprev = word ptr ga_lruprev   ; links for free segs
ga_freenext = word ptr ga_lrunext   ; links for free segs

if PMODE32

DEFAULT_ARENA_SIZE  equ 8000h   ; Initial length of arena array
;
;   32 bit Protect Mode Arena
;
GlobalArena32 STRUC
pga_next    DD  ?   ; next arena entry (last points to self)
pga_prev    DD  ?   ; previous arena entry (first points to self)
pga_address DD  ?   ; 32 bit linear address of memory
pga_size    DD  ?   ; 32 bit size in bytes
pga_handle  DW  ?   ; back link to handle table entry
pga_owner   DW  ?   ; Owner field (current task)
pga_count   DB  ?   ; lock count for movable segments
pga_pglock  DB  ?   ; # times page locked
pga_flags   DB  ?   ; 1 word available for flags
pga_selcount    DB  ?   ; Number of selectors allocated
pga_lruprev DD  ?   ; Previous entry in lru chain
pga_lrunext DD  ?   ; Next entry in lru chain
GlobalArena32 ENDS

.ERRNZ  32-size GlobalArena32

pga_sig      = word ptr pga_count

pga_freeprev    = dword ptr pga_lruprev ; links for free segs
pga_freenext    = dword ptr pga_lrunext ; links for free segs

endif   ; PMODE32

GA_SIGNATURE    = 04Dh
GA_ENDSIG   = 05Ah

; there are many special kinds of blocks, marked in the owner word

GA_SENTINAL = -1        ; a sentinal block
GA_BOGUS_BLOCK  = -7        ; a block temporary marked allocated
GA_BURGERMASTER = -3        ; the master object
GA_NOT_THERE    = -4        ; used with EEMS to link out unallocatable
                ; memory such as the EGA etc.
GA_PHANTOM  = -5        ; A block that has no EMS banks banked in.
GA_WRAITH   = -6        ; A block used to hold up partition headers.

; Global arena objects are aligned on 2 para. boundaries, leaving the
; low order bit always zero.

GA_ALIGN    = 2-1
GA_MASK     = NOT GA_ALIGN
GA_FIXED    = 1

; It is specific to WOW only. This handle was generated by WIN32, ChandanC.

GA_WOWHANDLE = 3

errnz   <GA_FIXED-GA_ALIGN>

; Low byte of flags passed to GlobalAlloc (zero is the default case)

GA_ALLOCHIGH    EQU 01h     ; Flag to indicate allocate high
GA_MOVEABLE EQU 02h
GA_SEGTYPE  EQU 0Ch     ; These 2 bits stored in he_flags field
GA_DGROUP   EQU 04h
GA_DISCCODE EQU 08h
GA_NOCOMPACT    EQU 10h
GA_NODISCARD    EQU 20h
GA_ZEROINIT EQU 40h
GA_MODIFY   EQU 80h

GA_NEWEXPANDED  EQU 80h     ; Use new EMS allocation scheme

; These flags for use by KERNEL only (caller's CS must match)

GA_INTFLAGS = GA_ALLOCHIGH+GA_SEGTYPE or (GA_CODE_DATA+GA_ALLOC_DOS) shl 8

; High byte of flags remembered in handle table (he_flags field)

GA_DISCARDABLE  EQU 01h     ; Boolean flag for global object, not a level.
GA_CODE_DATA    EQU 02h     ; CODE or DATA seg that belongs to a task.
;GA_DGROUP  EQU 04h
;GA_DISCCODE    EQU 08h
GA_ALLOC_LOW    EQU 10h     ; Alloc in Lower land, overrides GA_ALLOC_EMS
GA_SHAREABLE    EQU 20h     ; Shareable object
GA_DDESHARE EQU 20h     ; A shared memory object used for DDE.
;HE_DISCARDED   EQU 40h     ; Marks objects that have been discarded.
;GAH_NOTIFY EQU 40h
GA_ALLOC_DOS    EQU 80h     ; Alloc in DOS land if protected mode

GA_USERFLAGS    = GA_SHAREABLE + GA_DISCARDABLE

; Flags stored in the global arena header

GAH_PHANTOM EQU 01h     ; This block is either a phantom or a wraith
GAH_DONT_GROW   EQU 02h     ; Don't grow this data segment.
GAH_DGROUP  EQU GA_DGROUP
GAH_DISCCODE    EQU GA_DISCCODE
GAH_NOTIFY  EQU 40h
GAH_FIXED   EQU 80h

GAH_CURSORICON EQU 10h     ; WOW uses this flag

;
; GAH_PHANTOM is unused in Win 3.0 and Win 3.1
; ChandanC
;
GAH_WOWDDEFREEHANDLE EQU GAH_PHANTOM ; This is used to mark the DDE handle

;
; Global Memory Stats definitions
; Offsets in array
;
cGLOBALALLOC    EQU 0
cGLOBALREALLOC  EQU 4
cGLOBALFREE EQU 8
cGLOBALFREEALL  EQU 12
cGLOBALLOCK EQU 16
cGLOBALUNLOCK   EQU 20
cGLOBALSIZE EQU 24
cGLOBALCOMPACT  EQU 28
cLOCKSEGMENT    EQU 32
cUNLOCKSEGMENT  EQU 36
cGLOBALFIX  EQU 40
cGLOBALUNFIX    EQU 44
cGLOBALHANDLE   EQU 48
cGLOBALFLAGS    EQU 52
NGLOBALSTATS    EQU (56/4)

; Data structure that describes the global arena.  Allocated at the end
; of the local heap information structure.  DO NOT CHANGE THE ORDER OF
; THE ENTRIES!  The alt sequence and normal sequence must match!

GlobalInfo  STRUC
        DB  SIZE HeapInfo DUP (?)
gi_lrulock  DW  ?   ; Lock out access to LRU chain from interrupt level
ife PMODE32
gi_lruchain DW  ?   ; First handle in lru chain (most recently used)
else
gi_lruchain DD  ?   ; First handle in lru chain (most recently used)
endif
gi_lrucount DW  ?   ; #entries in LRU chain
ife PMODE32
gi_reserve  DW  ?   ; #paras to reserve for disc code, 0 => not enabled
gi_disfence DW  ?   ; Fence for discardable code.
else
gi_reserve  DD  ?   ; #paras to reserve for disc code, 0 => not enabled
gi_disfence DD  ?   ; Fence for discardable code.
endif
gi_free_count   DW  ?   ; Count of all the free partitions.

gi_alt_first    DW  ?   ; first entry in alternate arena
gi_alt_last DW  ?   ; last entry in alternate arena
gi_alt_count    DW  ?   ; count of entries in alternate arena
gi_alt_lruchain DW  ?   ; First handle in lru chain (most recently used)
gi_alt_lrucount DW  ?   ; #entries in LRU chain
gi_alt_reserve  DW  ?   ; alternate reserve
gi_alt_disfence DW  ?   ; Fence for discardable code.
gi_alt_free_count   DW  ?   ; Count of all the free partitions.
gi_alt_pPhantom DW  ?   ; Pointer to the first pPhantom block.
gi_disfence_hi  DW  ?   ; High word of fence
gi_flags    DW  ?   ; some flags!   !!! should merge with freeze and check
gi_stats    DD NGLOBALSTATS dup(?)
GlobalInfo  ENDS
gi_cmpflags = byte ptr hi_dislevel  ; Flags to control gcompact
gi_disfence_lo = word ptr gi_disfence

GIF_INT2    EQU 01h

BOOT_COMPACT    EQU 80h
COMPACT_ALLOC   EQU 40h     ; Fast abort in gcompact for allocations

CMP_FLAGS   EQU GA_NODISCARD or GA_NOCOMPACT or GA_DISCCODE or COMPACT_ALLOC

; Notify procedure message codes

GN_MOVE     = 1 ; Object moved - arg1 = handle arg2 = old location
GN_DISCARD  = 2 ; Object discard? - arg1 = handle, arg2 = discard flags
        ; Returns new discard flags in AX

SASTRUC     STRUC
sa_size     dw  0   ; size, in bytes, of the alias list
sa_allocated    dw  0   ; number of allocated entries
SASTRUC     ENDS

SAENTRY     STRUC
sae_sel     dw  0   ; selector of the object
sae_alias   dw  0   ; alias of the object
SAENTRY     ENDS

MAXFHCACHELEN = 12          ; Max number of file handles cached
MINFHCACHELEN = 2           ; Min number of file handles cached

fhCacheStruc    struc
    Cachefh     dw  ?   ; File handle
    CacheExe    dw  ?   ; Exe handle
fhCacheStruc    ends

; NAMETBL is a structure defining a private resource called a name table.
; It is a resource that maps string resource types and names into unique
; ordinal ids - this way all resources identified by name or type with
; a string can actually be loaded by id. This is for OS/2 compatibility
; with named resources.
;
; typedef struct nametbl {   /* ntbl */
;    int cbEntry;            /* size of structure */
;    int idType;             /* type id or string replc if (idType & RSORDID) */
;    int idName;             /* name id or string replc if (idName & RSORDID) */
;    char achTypeName[1];    /* 0 term type followed by 0 term name */
; } NAMETBL;
ntbl    struc
    ntbl_cbEntry     dw ?
    ntbl_idType      dw ?
    ntbl_idName      dw ?
    ntbl_achTypeName db ?
ntbl    ends

RT_NAMETABLE equ 15

ifdef WOW
if PMODE32
PAGE_READWRITE	EQU 0004h
MEM_COMMIT	EQU 1000h
MEM_RESERVE	EQU 2000h
MEM_RELEASE	EQU 8000h
MEM_COMMIT_RESERVE EQU 3000h
endif
endif

ifdef WOW
ife PMODE32
DpmiBlock struc
    DBSize dw 0
    DBSel dw 0
    DBHandleLow dw 0
    DBHandleHigh dw 0
DpmiBlock ends
NUM_DPMI_BLOCKS equ 20
endif
endif

ifdef WOW_x86
FLAT_SEL equ 23H
endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\winexec.asm ===
;-----------------------------------------------------------------------;
;
;  WINEXEC.ASM -
;
;      Windows Exec Function
;
;-----------------------------------------------------------------------;

include kernel.inc
ifdef WOW
include wowcmpat.inc
;The following defines come from winerror.inc, which is new in the
;win95 source tree, but hasn't been merged into wow
ERROR_FILE_NOT_FOUND equ 2
ERROR_BAD_LENGTH     equ 24
endif


ifdef FE_SB
externFP FarMyIsDBCSLeadByte
endif

ifdef WOW
externFP MyGetAppWOWCompatFlagsEx
endif

	externW		WinFlags		; (kdata.asm)
	externD		WinAppHooks		; (kdata.asm)

sBegin NRESCODE

assumes cs,NRESCODE


;-----------------------------------------------------------------------;
;
;  WinExec() -
;
;-----------------------------------------------------------------------;

; HANDLE PASCAL WinExec(lpszFile,wShow)

cProc IWinExec, <FAR,PUBLIC>,<si,di>

	parmD lpszFile			; Pathname ptr
	parmW wShow			; Mode flag
;
; szCmdLine buffer must be big enough for passed in path & parms, plus
; .EXE, null terminator, and newline terminator.
; So we add a little room for good measure here.
;
        LocalV szCmdLine,260+256+8      ; Path and command line (to account for .exe)
        LocalW pszParm                  ; Ptr to start of parameters

	LocalB bDotFound		; Non-zero if a period is in the string
	LocalB bDblQFound		; Non-zero if the string starts with "

	LocalV loadparams, %(SIZE EXECBLOCK)
	LocalD FCB1
cBegin

; Copy first part of line into szCmdLine.

	lds	si,lpszFile
	smov	es,ss
        lea     di,szCmdLine
        mov     cx,260                  ; MAX_PATH

	xor	al,al
	mov	bDotFound,al
	mov	bDblQFound,al
	; The Dbl-quote is used as a delimiter for cmdname as in
	; winexec("\"c:\fldr with spaces\" cmd line", ..);
	mov	al, ds:[si]		; get Ist char
	cmp	al,'"'			; is it a "
	jne	WELoop1			; N:
	mov	bDblQFound,al		; Y: remember that
	lodsb				; skip the dblQ

; Loop until a blank or NULL is found.
WELoop1:
	lodsb
	cmp	bDblQFound, 0		; If str didn't start with dblQ
	je	WESpaceCheck		; then SPACE is a delimiter
					; otherwise " is the delimiter
	cmp	al,'"'			; look for second DblQ
	jne	WESkipSpaceCheck
	and	bDblQFound,0		; reset this, so space is the delimiter
	lodsb				; skip past the dbl Q
WESpaceCheck:
	cmp	al,' '			; Exit loop if blank or NULL
	je	WECont1
WESkipSpaceCheck:
	cmp	al,9
	je	WECont1
	or	al,al
	je	WECont1
	cmp	al,'.'
	jne	WELoopCont
	mov	bDotFound,al
WELoopCont:
        ;** We have to check to see if the dot we found was actually in
        ;**     a directory name, not in the filename itself.
        cmp     al, '\'                 ; Separator?
        je      WE_Separator
        cmp     al, '/'
        jne     WE_Not_Separator
WE_Separator:
        mov     bDotFound,0             ; No dots count yet
WE_Not_Separator:
	stosb
        dec     cx
        jz      WE_filename_too_long
ifdef FE_SB				;Apr.26,1990 by AkiraK
        push    cx
	call	FarMyIsDBCSLeadByte
        pop     cx
	jc	WELoop1
	movsb
        dec     cx
        jz      WE_filename_too_long
endif
	jmp	short WELoop1

WE_filename_too_long:
	krDebugOut DEB_TRACE, "WinExecEnv: filename too long, > 259"
	mov	ax,ERROR_FILE_NOT_FOUND
	jmp	WinExecEnvExit

WECont1:
	mov	dx,ax			; Store final char in DX

; Does the command have an extention?

	cmp	bDotFound,0
	jne	WEHasExt

	mov	ax,0452Eh		;'.E'
	stosw
	mov	ax,04558h		;'XE'
	stosw

WEHasExt:
	xor	ax,ax			; NULL terminate string
	stosb

        mov     pszParm,di              ; Store pointer to parm string
        stosb                           ; length = 0
        mov     al,0dh                  ; line feed terminator
        stosb
        dec     di                      ; back up

	or	dl,dl			; Exec if lpszFile was null terminated
	jz	WEExec

; Copy everything else into szParm.

        mov     cx,255                  ; Max length of cmd tail +1
WELoop2:
        lodsb
        or      al,al
ifdef WOW
        jz      WEDoneParm
else
        jz      WECont2
endif
        stosb
        dec     cx
        jnz     WELoop2

ifdef WOW
        jmps    @F

;
; On NT we have a compatibility flag, WOWCFEX_LONGWINEXECTAIL which is
; set for applications such as TSSETUP, the setup program for Intergraph's
; NT-only Transcend app.  This app uses a command tail on the order of
; 143 bytes for a Win32 worker app, and it worked on 3.5 and 3.51,
; so we need to continue to let at least this app cheat.
;

WEDoneParm:
        sub     cx, 128
        ja      WECont2

; tail was longer than 126 characters

        call    MyGetAppWOWCompatFlagsEx
        test    dx, word ptr cs:[WE_GACFEX_LONGWINEXECTAIL+2]
        jz      @F
        jmps    WECont2

WE_GACFEX_LONGWINEXECTAIL:
        DD WOWCFEX_LONGWINEXECTAIL

@@:
endif

; Cmd tail too long to fit in PSP !!!
; Fail the call.
; We _could_ alloc some memory to hold the cmd tail and make its
;   owner be the new hTask. However InitTask is documented to return 
;   es=PSP, es:bx=cmd_tail. So we're in trouble. Could truncate the cmd line.
;   Cleaner to fail the exec.
;   Could grow the PSP and tack the big cmd tail on at the end. Scary!
; Unfortunately, kernel32.ExecWin16Program maps ERROR_BAD_LENGTH to
; ERROR_GEN_FAILURE.
        krDebugOut DEB_TRACE, "WinExecEnv: command tail too long, > 126"
	mov	ax,ERROR_BAD_LENGTH
        jmps    WinExecEnvExit

WECont2:

; Terminate it with a carriage return.

	mov	al,0Dh
	stosb

; Prefix the parameter string with its length.

        mov     bx,pszParm              ; ax = length + 2
        mov     ax,di
        sub     ax,bx
        dec     ax                      ; don't include line feed char or length
        dec     ax
        mov     ss:[bx],al

; Set up the FCBs.

WEExec:
	mov	word ptr FCB1[0],2	    ; FCB1[0] = 2;
	mov	ax,wShow		    ; FCB1[1] = wShow;
	mov	word ptr FCB1[2],ax
	xor	ax,ax
	mov	loadparams.envseg,ax	    ; loadparms.segEnv = 0;
	mov	loadparams.lpfcb2.lo,ax     ; loadparms.lpFCB2 = (LPSTR)NULL;
	mov	loadparams.lpfcb2.hi,ax
        mov     ax,pszParm                  ; loadparms.lpCmdLine = (LPSTR)pszParm;
	mov	loadparams.lpCmdLine.lo,ax
	mov	loadparams.lpCmdLine.hi,ss
	lea	ax,FCB1 		    ; loadparms.lpFCB1 = (LPSTR)fcb1buf;
	mov	loadparams.lpfcb1.lo,ax
	mov	loadparams.lpfcb1.hi,ss

; Exec the progam.

	smov	ds,ss
        lea     dx,szCmdLine                ; ds:ax == ptr to file to exec
	lea	bx,loadparams		    ; es:bx == ptr to param block
	mov	ax,4B00h		    ; dos exec
	int	21h

WinExecEnvExit:
cEnd

;**************************************************************************
; RegisterWinoldapHook(Addr,Opcode):
; 
; Description:  (Opcode == 1) => hook, (Opcode == 0) => unhook.
;  Addr is a ptr to struct of the form WinoldapHookList
;  struct WinoldapHookList { struct WinoldapHookList *ptr; DWORD Hook;};
;**************************************************************************

cProc	RegisterWinoldapHook,<FAR,PUBLIC,PASCAL>,<ds,es,di,si,dx>
	parmD	Address
	parmB	Opcode
cBegin
	SetKernelDSNRes			; set kernel's DS
	mov	ax, WinFlags
	test	ax, WF_STANDARD
	mov	ax,0
	jz	RWH_Call
	lea	si,WinAppHooks
	les	di,Address
	cmp	Opcode,0		; unhook ?
	jz	RWH_Unhook
RWH_Exchange:
	mov	ax,ds:[si]		; old
	mov	es:[di],ax		; next of new
	mov	ax,ds:[si+2]
	mov	es:[di+2],ax		; next set
	mov	ds:[si],di
	mov	di,es
	mov	ds:[si+2],di		; new one becomes first
	mov	ax,1
	jmp	SHORT RWH_Call

RWH_Unhook:
	mov	dx,es
RWH_Compare:
	cmp	di,ds:[si]
	jnz	RWH_Nexthook
	cmp	dx,ds:[si+2]
	jnz	RWH_NextHook
	mov	ax,es:[di]
	mov	ds:[si],ax
	mov	ax,es:[di+2]
	mov	ds:[si+2],ax
	mov	ax,1
	jmp	SHORT RWH_Call
RWH_NextHook:
	lds	si,ds:[si]
	mov	ax,ds
	or	ax,si
	jnz	short RWH_Compare
RWH_Call:
	UnSetKernelDS			; unset it
cEnd

;**********************************************************************
;
; GetWinoldapHooks:
; Description: Called exclusively by winoldap to get a pointer to a list
;		of WinoldapHookList.
; Entry: None
; EXIT: DX:AX -> WinoldapHookList...
; USES: Flags.
;**********************************************************************
 
cProc	GetWinoldapHooks,<FAR,PUBLIC,PASCAL>,<ds,si>
cBegin
	SetKernelDSNRes			; set kernel DS
	lea	si,WinAppHooks
	mov	ax, word ptr ds:[si]
	mov	dx, word ptr ds:[si+2]
	UnSetKernelDS			; unset it
cEnd

sEnd NRESCODE

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\br\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\fi\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\hu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\es\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\cs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\el\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\it\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\da\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ger\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\fr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\chs\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\cs\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Vmna diskety',0
ELSE
szDiskCap       db  'Chyba souboru',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Nelze nalzt soubor ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Chyba pi natn souboru ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', vlote disk do jednotky '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "V aplikaci se vyskytla chyba.",10
	db      "Pokud zvolte Ignorovat, ulote vae data do novho souboru.",10
	db      "Pokud zvolte Ukonit, bude dan aplikace ukonena.",0
endif

public  szDosVer
szDosVer        DB      'Chybn verze systmu MS-DOS. Vyaduje se verze 3.1 nebo vy.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Chyba aplikace"
		db      0
szBlame         db      "START "
		db      0
szSnoozer       db      " zpsobil "
		db      0
szInModule      db      " v", 10, "modulu <neznm>"
		db      0
szAt            db      " na adrese "
		db      0
szNukeApp       db      ".", 10, 10, "Zvolte ukonen aplikace. "
		db      0
szWillClose     db      " bude ukonen."
		db      0
szGP            db      "veobecnou chybu ochrany"
		db      0
szD0            db      "dlen nulou"  ; not yet used
		db      0
szSF            db      "chybu zsobnku"               ; not spec'ed
		db      0
szII            db      "ilegln instrukci"    ; "Fault" ???
		db      0
szPF            db      "chybu strnky"
		db      0
szNP            db      "chybu neptomnosti"
		db      0
szAF            db      "chybu aplikace"        ; not yet used
		db      0
szLoad          db      "chybu naten segmentu"
		db      0
szOutofSelectors db     "nedostatek selektor"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Aplikace bude ukonena.",0

; Text for dialog box when trying to run a compressed file

public szBozo
szBozo          db      "Nelze nast komprimovan soubory",0

; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Chyba systmu",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disk chrnn proti zpisu v jednotce "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Nelze st z jednotky "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Nelze zapisovat na jednotku "
drvlet3                 db      "X.",0

msgShare                db      "Pestupek sdlen na jednotce "
drvlet4                 db      "X.",0

msgNetError             db      "Chyba st na jednotce "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Nelze st ze zazen "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Nelze zapisovat na zazen "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Chyba st na zazen "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Tiskrna nen pipravena",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'kd FatalExit = ',0
szExitStr2  DB  ' peteen zsobnku',13,10,0
public  szUndefDyn
szUndefDyn      db      "voln nedefinovanho Dynalinku",0
public  szFatalExit
szFatalExit     db      "aplikace si vydala abnormln ukonen",0
else
public szDebugStr
szDebugStr  DB  'JDRO: Selhalo naten - ',0                   ; 0
	    DB  'JDRO: Selhalo naten nov instance - ',0     ; 1
	    DB  'Chyba pi natn souboru zdroje - ',0        ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit, kd = ',0                   ; 4
	    DB  ' peteen zsobnku',0                        ; 5
	    DB  13,10,'Stav zsobnku:',13,10,0                 ; 6
	    DB  7,13,10,'Peruit, Ukonit, Nvrat nebo Ignorovat? ',0      ; 7
	    DB  'Neplatn etzec BP',7,13,10,0                 ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Nov vskyt chyby FatalExit',7,13,10,0         ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatln chyba jdra ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[start]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Kd selhn je ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Start diagnostickho reimu. Soubor protokolu:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Podsystm Win16 nemohl pejt do chrnnho reimu; DOSX.EXE mus bt uveden v souboru AUTOEXEC.NT a leet v cest (promnn PATH).",0
szMissingMod    db   "JDRO NTVDM: Nebyl nalezen 16bitov systmov modul",0
szPleaseDoIt    db   "Peinstalujte nsledujc modul do adrese system32:",13,10,9,9,0
szInadequate    db   "JDRO NTVDM: Neadekvtn server DPMI",0
szNoGlobalInit  db   "JDRO NTVDM: Nelze inicializovat haldu",0
NoOpenFile      db   "JDRO NTVDM: Nelze otevt spustiteln program JDRA",0
NoLoadHeader    db   "JDRO NTVDM: Nelze nast zhlav EXE JDRA",0
szGenBootFail   db   "JDRO NTVDM: Inicializace podsystmu Win16 se nezdaila",0
else
szInadequate    db   'JDRO: Neadekvtn server DPMI',13,10,'$'
szNoPMode       db   'JDRO: Nelze pejt do chrnnho reimu',13,10,'$'
szNoGlobalInit  db   "JDRO: Nelze inicializovat haldu",13,10,'$'
NoOpenFile      db   "JDRO: Nelze otevt spustiteln program JDRA"
		db   13, 10, '$'
NoLoadHeader    db   "JDRO: Nelze nast zhlav EXE JDRA"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Varovn - kompatibilita aplikac",0

msgRealModeApp1 db      "Aplikace, kter m bt sputna,  ",0
msgRealModeApp2 db      "byla navrena pro pedchoz verzi systmu Windows.",0Dh,0Dh
        db      "Opatete si aktualizovanou verzi aplikace, kter je kompatibiln "
        db      "se systmem Windows 3.0 nebo vym.",13,13
        db      "Pokud klepnete na tlatko OK a aplikaci spustte, me dojt k potm "
        db      "kompatibility ve form neoekvanho ukonen aplikace nebo systmu Windows. ",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\br\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Troque o disco',0
ELSE
szDiskCap	db  'Erro de arquivo',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No foi possvel encontrar ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Erro de carregamento ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', insira na unidade '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Ocorreu um erro no aplicativo.",10
        db      "Se escolher 'Ignorar', ter que salvar os dados em um novo arquivo.",10
        db      "Se escolher 'Fechar', o aplicativo ser finalizado.",0
endif

public	szDosVer
szDosVer	DB	'Verso incorreta do MS-DOS.  necessrio o MS-DOS 3.1 ou uma verso posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Erro de aplicativo"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" foi causado "
		db	0
szInModule	db	" em", 10, "mdulo <descon.>"
		db	0
szAt		db	" em "
		db	0
szNukeApp       db      ".", 10, 10, "Escolha fechar. "
		db	0
szWillClose	db	" ser fechado."
		db	0
szGP		db	"uma falha de proteo geral"
		db	0
szD0		db	"uma diviso por zero"	; not yet used
		db	0
szSF		db	"uma falha na pilha"		; not spec'ed
		db	0
szII		db	"uma instruo invlida"	; "Fault" ???
		db	0
szPF		db	"um erro de pgina"
		db	0
szNP		db	"uma falha de presena"
		db	0
szAF		db	"uma falha de aplicativo"	; not yet used
		db	0
szLoad		db	"falha no carregamento de segmento"
		db	0
szOutofSelectors db	"sem seletores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"O aplicativo est sendo fechado.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"No foi possvel carregar arquivos compactados",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Erro de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra gravao na unidade "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "No foi possvel ler a unidade "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "No foi possvel gravar na unidade "
drvlet3                 db      "X.",0

msgShare		db	"Violao de compartilhamento na unidade "
drvlet4                 db      "X.",0

msgNetError		db	"Ocorreu um erro de rede na unidade "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "No foi possvel ler o dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "No foi possvel gravar no dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Ocorreu um erro de rede no dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "A impressora no est pronta",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chamada a um vnculo dinmico indefinido",0
public  szFatalExit
szFatalExit	db	"O aplicativo foi encerrado de forma anormal",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Erro ao carregar - ',0                   	 ; 0
            DB  'KERNEL: Erro ao carregar uma nova cpia de - ',0 ; 1
            DB  'Erro ao carregar o arquivo de recursos - ',0        ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'Cdigo de sada fatal = ',0                   ; 4
            DB  ' estouro de pilha',0                             ; 5
            DB  13,10,'Segmento da pilha:',13,10,0                    ; 6
	    DB  7,13,10,'Anular, Interromper, Sair ou Ignorar? ',0      ; 7
            DB  'Cadeia BP invlida',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Sada fatal fornecida outra vez',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Erro fatal de ncleo ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'Incio de carregamento = ',0
szLoadSuccess   db      'Carregamento correto = ', 0
szLoadFail      db      'Carregamento incorreto = ', 0
szFailCode      db      ' O cdigo de erro  ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Inicializao do modo de diagnstico. O arquivo de log : ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "O Subsistema Win16 no conseguiu entrar no modo protegido. DOSX.EXE deve estar no arquivo AUTOEXEC.NT e em seu PATH.",0
szMissingMod    db   "NTVDM KERNEL: O mdulo do sistema de 16 bits est faltando",0
szPleaseDoIt    db   "Reinstale o seguinte mdulo na pasta system32:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Servidor DPMI inadequado",0
szNoGlobalInit	db   "NTVDM KERNEL: No foi possvel inicializar a pilha",0
NoOpenFile	db   "NTVDM KERNEL: No foi possvel abrir o executvel KERNEL",0
NoLoadHeader	db   "NTVDM KERNEL: No foi possvel carregar o cabealho do executvel KERNEL",0
szGenBootFail   db   "NTVDM KERNEL: Falha na inicializao do subsistema Win16",0
else
szInadequate	db   'KERNEL: O servidor DPMI no  adequado',13,10,'$'
szNoPMode	db   'KERNEL: No foi possvel entrar no modo protegido',13,10,'$'
szNoGlobalInit	db   "KERNEL: No foi possvel inicializar a pilha",13,10,'$'
NoOpenFile      db   "KERNEL: No foi possvel abrir o executvel KERNEL"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: No foi possvel carregar o cabealho do executvel KERNEL"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Aviso sobre a compatibilidade do aplicativo",0

msgRealModeApp1 db	"O aplicativo que voc vai executar foi ",0
msgRealModeApp2 db	"desenvolvido para uma verso anterior do Windows.",0Dh,0Dh
	db	"Obtenha uma verso atualizada do aplicativo que seja compatvel "
	db	"com o Windows 3.0 ou posterior.    ",13,13
	db	"Se for escolhido OK e o aplicativo for inicializado, problemas de compatibilidade "
	db	"podero fazer com que o aplicativo ou o Windows sejam encerrados inesperadamente.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\da\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Skift disk',0
ELSE
szDiskCap       db  'Filfejl',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Kan ikke finde ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Fejl ved indlsning af ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', Indst i drev '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Der er opstet en fejl i dit program.",10
	db      "Hvis du vlger Ignorer, skal du gemme dit arbejde i en ny fil.",10
	db      "Hvis du vlger Luk, afsluttes programmet.",0
endif

public  szDosVer
szDosVer        DB      'Forkert MS-DOS-version.  Der krves MS-DOS 3.1 eller senere.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Programfejl"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " forrsagede "
		db      0
szInModule      db      " i", 10, "modul <ukendt>"
		db      0
szAt            db      " ved "
		db      0
szNukeApp       db      ".", 10, 10, "Vlg luk. "
		db      0
szWillClose     db      " vil lukke."
		db      0
szGP            db      "en generel beskyttelsesfejl"
		db      0
szD0            db      "en division med nul"   ; not yet used
		db      0
szSF            db      "en stakfejl"           ; not spec'ed
		db      0
szII            db      "en ugyldig instruktion"        ; "Fejl" ???
		db      0
szPF            db      "en sidefejl"
		db      0
szNP            db      "en fejl pga. at noget mangler"
		db      0
szAF            db      "en programfejl"        ; not yet used
		db      0
szLoad          db      "segmentindlsningsfejl"
		db      0
szOutofSelectors db     "Der er ikke flere selektorer"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Lukker programmet.",0

; Text for dialog box when trying to run a compressed file
			
public szBozo
szBozo          db      "Der kan ikke indlses komprimerede filer",0
						
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Systemfejl",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Skrivebeskyttet diskette i drev "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Kan ikke lse drev "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Der kan ikke skrives til "
drvlet3                 db      "X.",0

msgShare                db      "Fildelingsfejl p drev "
drvlet4                 db      "X.",0

msgNetError             db      "Netvrksfejl p drev "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Der kan ikke lses fra enheden "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Der kan ikke skrives til enheden "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Netvrksfejl p enheden "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Printeren er ikke klar",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Kald til ikke-defineret Dynalink",0
public  szFatalExit
szFatalExit     db      "Programmet forespurgte unormal afslutning",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                    ; 0
	    DB  'KERNEL: Failed loading new instance of - ',0    ; 1
	    DB  'Error loading from resource file - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' stack overflow',0                             ; 5
	    DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
	    DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Reentered FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Win16-undersystemet kunne ikke g i beskyttet tilstand, DOSX.EXE skal vre i din AUTOEXEC.NT og i din PATH.",0
szMissingMod    db   "NTVDM KERNEL: Der mangler et 16-bit systemmodul",0
szPleaseDoIt    db   "Geninstaller flgende modul i system32-mappen:",13,10,9,9,0
szInadequate    db   "KERNEL: Mangelfuld DPMI-server",0
szNoGlobalInit  db   "KERNEL: Heapen kan ikke initialiseres",0
NoOpenFile      db   "KERNEL: Kernel.exe kan ikke bnes",0
NoLoadHeader    db   "KERNEL: Der kan ikke indlses header for Kernel.exe",0
szGenBootFail   db   "KERNEL: Initialiseringsfejl i Win16-undersystem",0
else
szInadequate    db   'KERNEL: Mangelfuld DPMI-server',13,10,'$'
szNoPMode       db   'KERNEL: Der kan ikke gs i beskyttet tilstand',13,10,'$'
szNoGlobalInit  db   "KERNEL: Heapen kan ikke initialiseres",13,10,'$'
NoOpenFile      db   "KERNEL: Kernel.exe kan ikke bnes"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Der kan ikke indlses header for Kernel.exe"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Kompatibilitetsadvarsel",0

msgRealModeApp1 db      "Det program, du vil kre, er udviklet ",0
msgRealModeApp2 db      "til en tidligere version af Windows.",0Dh,0Dh
	db      "Anskaf en opdateret version, som er kompatibel med "
	db      "Windows version 3.0 og senere.",13,13
	db      "Vlger du OK og starter programmet, kan kompatibilitetsproblemer "
	db      "medfre, at programmet eller Windows uventet lukker.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\cht\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\es\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Cambiar disco',0
ELSE
szDiskCap	db  'Error de archivo',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No se encuentra ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error al cargar ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', inserte en la unidad '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Error en la aplicacin.",10
        db      "Si escoge Omitir, tendr que guardar sus datos en un archivo nuevo.",10
        db      "Si escoge Cerrar, su aplicacin terminar.",0
endif

public	szDosVer
szDosVer	DB	'Versin incorrecta de MS-DOS.  Se precisa MS-DOS 3.1 o posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Error de aplicacin"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" ha causado "
		db	0
szInModule	db	" en", 10, "mdulo <indefi.>"
		db	0
szAt		db	" en "
		db	0
szNukeApp       db      ".", 10, 10, "Escoja Cerrar. "
		db	0
szWillClose	db	" se cerrar."
		db	0
szGP		db	"un error de proteccin general"
		db	0
szD0		db	"una divisin entre cero"	; not yet used
		db	0
szSF		db	"un error de pila"		; not spec'ed
		db	0
szII		db	"una instruccin ilegal"	; "Fault" ???
		db	0
szPF		db	"un error de pgina"
		db	0
szNP		db	"un error de presencia"
		db	0
szAF		db	"un error de aplicacin"	; not yet used
		db	0
szLoad		db	"error de carga de segmento"
		db	0
szOutofSelectors db	"no quedan selectores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"La aplicacin se est cerrando.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"No se puede cargar archivos comprimidos",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Error de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra escritura en la unidad "
drvlet1                 db      "X.",0
			
msgCannotReadDrv        db      "No se puede leer de la unidad "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "No se puede escribir en la unidad "
drvlet3                 db      "X.",0

msgShare		db	"Infraccin de recurso compartido en la unidad "
drvlet4                 db      "X.",0

msgNetError		db	"Error de red en la unidad "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "No se puede leer del dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "No se puede escribir en el dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Error de red en el dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "La impresora no est lista",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Llamada indefinida a vnculo dinmico",0
public  szFatalExit
szFatalExit	db	"La aplicacin ha solicitado terminar de forma anormal",0
else
public szDebugStr
szDebugStr  DB  'NCLEO: error al cargar - ',0                   	; 0
            DB  'NCLEO: error al cargar una nueva instancia de - ',0 	; 1
            DB  'Error al cargar del archivo de recursos - ',0        	; 2
            DB  13,10,0                                         	; 3
            DB  7,13,10,'Cdigo de salida crtica = ',0                 ; 4
            DB  ' desbordamiento de pila',0                             ; 5
            DB  13,10,'Seguimiento de la pila:',13,10,0                 ; 6
	    DB  7,13,10,'Anular, Interrumpir, Salir u Omitir? ',0      	; 7
            DB  'Cadena BP no vlida',7,13,10,0                    	; 8
	    DB	': ',0							; 9
	    DB	'Salida crtica reentrante',7,13,10,0 			; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'Inicio de carga = ',0
szLoadSuccess   db      'Carga correcta = ', 0
szLoadFail      db      'Carga errnea = ', 0
szFailCode      db      ' El cdigo de error es ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Inicio de modo diagnstico.  El archivo de registro es:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "El subsistema Win16 no ha podido entrar en modo Protegido. DOSX.EXE debe estar en AUTOEXEC.NT y presente en la ruta (PATH).",0
szMissingMod    db   "NCLEO NTVDM: falta el mdulo del sistema de 16 bits",0
szPleaseDoIt    db   "Reinstale el siguiente mdulo en el directorio system32:",13,10,9,9,0
szInadequate	db   "NCLEO NTVDM: el servidor DPMI no es el adecuado",0
szNoGlobalInit	db   "NCLEO NTVDM: no se puede inicializar la pila heap",0
NoOpenFile	db   "NCLEO NTVDM: no se puede abrir el ejecutable del NCLEO",0
NoLoadHeader	db   "NCLEO NTVDM: no se puede cargar el encabezado ejecutable del NCLEO",0
szGenBootFail   db   "NCLEO NTVDM: error de inicializacin del Subsistema Win16",0
else
szInadequate	db   'NCLEO: el servidor DPMI no es el adecuado',13,10,'$'
szNoPMode	db   'NCLEO: no se puede entrar en modo Protegido',13,10,'$'
szNoGlobalInit	db   "NCLEO: No se puede inicializar la pila heap",13,10,'$'
NoOpenFile      db   "NCLEO: No se puede abrir el ejecutable del NCLEO"
                db   13, 10, '$'
NoLoadHeader    db   "NUCLEO: no se puede cargar el encabezado ejecutable del NCLEO"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	" Aviso de compatibilidad de aplicaciones  ",0

msgRealModeApp1 db	" La aplicacin que va a ejecutar, fue ",0
msgRealModeApp2 db	"diseada para una versin anterior de Windows.   ",0Dh,0Dh
	db	"Consiga una versin actualizada de la misma que sea compatible "
	db	"con Windows 3.0 o posterior.    ",13,13
	db	"Si escoge Aceptar e inicia la aplicacin, problemas de compatibilidad "
	db	"pueden causar que la aplicacin o Windows se cierren inesperadamente.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\chp\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\kor\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\el\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  ' ',0
ELSE
szDiskCap	db  '  ',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"     ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"     ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ',      '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"    .",10
        db      "  '',        .",10
        db      "  '',     .",0
endif

public	szDosVer
szDosVer	DB	'   MS-DOS.  MS-DOS 3.1    .',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	" "
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	"  "
		db	0
szInModule	db	" ", 10, " <>"
		db	0
szAt		db	"  "
		db	0
szNukeApp       db      ".", 10, 10, " ''. "
		db	0
szWillClose	db	" ."
		db	0
szGP		db	"   "
		db	0
szD0		db	"    "	; not yet used
		db	0
szSF		db	"  "		; not spec'ed
		db	0
szII		db	"   "	; "" ???
		db	0
szPF		db	"  "
		db	0
szNP		db	"    "
		db	0
szAF		db	"  "	; not yet used
		db	0
szLoad		db	"  "
		db	0
szOutofSelectors db	"  "
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"   .",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"      ",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	" ",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "      "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "        "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "        "
drvlet3                 db      "X.",0

msgShare		db	"      "
drvlet4                 db      "X.",0

msgNetError		db	"      "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "        "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "       "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"     "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "    ",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'    = ',0
szExitStr2  DB  '  ',13,10,0
public  szUndefDyn
szUndefDyn      db      "   ",0
public  szFatalExit
szFatalExit	db	"       ",0
else
public szDebugStr
szDebugStr  DB  ':   - ',0                   ; 0
            DB  ':      - ',0   ; 1
            DB  '        - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'   = ',0    ; 4
            DB  '  ',0                        ; 5
            DB  13,10,' :',13,10,0          ; 6
	    DB  7,13,10,', ,   ; ',0;7
            DB  '  BP   ',7,13,10,0       ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '***    ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      '    ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      '    .     :  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "  Win16       ,  DOSX.EXE     AUTOEXEC.NT      PATH.",0
szMissingMod    db   " NTVDM:  16-bit   ",0
szPleaseDoIt    db   "        system32:",13,10,9,9,0
szInadequate	db   " NTVDM:   DPMI",0
szNoGlobalInit	db   " NTVDM:       heap",0
NoOpenFile	    db   " NTVDM:         ",0
NoLoadHeader	db   " NTVDM:         KERNEL EXE ",0
szGenBootFail   db   " NTVDM:     Win16",0
else
szInadequate	db   ':   DPMI',13,10,'$'
szNoPMode	db   ':       ',13,10,'$'
szNoGlobalInit	db   ":       heap",13,10,'$'
NoOpenFile      db   ":         "
                db   13, 10, '$'
NoLoadHeader    db   ":         KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"  ",0

msgRealModeApp1 db	"     , ",0
msgRealModeApp2 db	"      Windows.",0Dh,0Dh
	db	"          "
	db	"  Windows 3.0     .",13,13
	db	"  'OK'    ,    "
	db	"          Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\fr\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Changement de disque',0
ELSE
szDiskCap       db  'Erreur de fichier',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Impossible de trouver ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Erreur lors du chargement de ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', Veuillez insrer dans le lecteur '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Une erreur s'est produite dans votre application.",10
	db      "Si vous choisissez Ignorer, vous devriez sauvegarder votre travail.",10
	db      "Si vous choisissez Fermer, votre application va se terminer.",0
endif

public  szDosVer
szDosVer        DB      'Version de MS-DOS incorrecte.  MS-DOS version 3.1 ou ultrieure est requis.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Erreur d'application"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " a caus "
		db      0
szInModule      db      " dans le module <inconnu>"   ; Same French localization as in NT4 (, 10 missing)
		db      0
szAt            db      "  l'adresse "
		db      0
szNukeApp       db      ".", 10, 10, "Choisissez le bouton Fermer. "
		db      0
szWillClose     db      " va se fermer."
		db      0
szGP            db      "une faute de protection gnrale"
		db      0
szD0            db      "une division par zro" ; not yet used
		db      0
szSF            db      "une faute de pile"             ; not spec'ed
		db      0
szII            db      "une instruction illgale"      ; "Fault" ???
		db      0
szPF            db      "un dfaut de page"
		db      0
szNP            db      "une faute de non-prsence"
		db      0
szAF            db      "une faute d'une application"   ; not yet used
		db      0
szLoad          db      "Echec de chargement de segment"
		db      0
szOutofSelectors db     "Slecteurs puiss"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Fermeture de l'application en cours d'excution",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Impossible de charger les fichiers compresss",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Erreur systme",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disque protg en criture dans le lecteur "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossible de lire depuis le lecteur "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossible d'crire sur le lecteur "
drvlet3                 db      "X.",0

msgShare                db      "Violation de partage sur le lecteur "
drvlet4                 db      "X.",0

msgNetError             db      "Erreur rseau sur le lecteur "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Impossible de lire depuis le priphrique "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Impossible d'crire sur le priphrique "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Erreur rseau sur le priphrique "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Imprimante non prte",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Code FatalExit = ',0
szExitStr2  DB  ' dpassement de pile',13,10,0
public  szUndefDyn
szUndefDyn      db      "Appel  un Dynalink non dfini",0
public  szFatalExit
szFatalExit     db      "L'application a demand une fin anormale",0
else
public szDebugStr
szDebugStr  DB  'NOYAU : Echec de chargement - ',0                   ; 0
	    DB  "NOYAU : Echec du chargement d'une nouvelle instance de - ",0   ; 1
	    DB  'Erreur de chargement depuis le fichier de ressources - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'Code FatalExit = ',0                   ; 4
	    DB  ' dpassement de pile',0                             ; 5
	    DB  13,10,'Trace de la pile :',13,10,0                    ; 6
	    DB  7,13,10,'Abandonner, Interrompre, Quitter ou Ignorer ? ',0      ; 7
	    DB  'Chane BP non valide',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'FatalExit rentre',7,13,10,0          ; 10
	    DB  0
public szFKE
szFKE   DB '*** Erreur fatale du noyau ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      " Le code d'chec est " ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Dmarrage du mode diagnostic.  Le fichier journal est :  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Le sous-systme Win16 n'a pas pu entrer en mode protg, DOSX.EXE doit tre dans votre AUTOEXEC.NT et prsent dans votre chemin PATH.",0
szMissingMod    db   "NOYAU NTVDM : Module systme 16 bits manquant",0
szPleaseDoIt    db   "Veuillez rinstaller le module suivant dans votre rpertoire system32 :",13,10,9,9,0
szInadequate	db   "NOYAU NTVDM : Serveur DPMI inadquat",0
szNoGlobalInit	db   "NOYAU NTVDM : Impossible d'initialiser le tas",0
NoOpenFile	    db   "NOYAU NTVDM : Impossible d'ouvrir l'excutable NOYAU",0
NoLoadHeader	db   "NOYAU NTVDM : Impossible de charger l'en-tte EXE du NOYAU",0
szGenBootFail   db   "NOYAU NTVDM : Dysfonctionnement de l'initialisation du sous-systme Win16",0
else
szInadequate    db   'NOYAU : Serveur DPMI inadquat',13,10,'$'
szNoPMode       db   "NOYAU : Impossible d'entrer en mode protg",13,10,'$'
szNoGlobalInit  db   "NOYAU : Impossible d'initialiser le tas",13,10,'$'
NoOpenFile      db   "NOYAU : Impossible d'ouvrir l'excutable NOYAU"
		db   13, 10, '$'
NoLoadHeader    db   "NOYAU : Impossible de charger l'en-tte EXE du NOYAU"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Avertissement de compatibilit d'application",0

msgRealModeApp1 db      "L'application que vous tes sur le point d'excuter, ",0
msgRealModeApp2 db      ", a t conue pour une version prcdente de Windows.",0Dh,0Dh
	db      "Procurez-vous une version mise  jour de l'application qui soit compatible "
	db      "avec Windows version 3.0 ou ultrieure.",13,13
	db      "Si vous choisissez OK pour lancer l'application, des problmes de "
	db      "compatibilit pourraient fermer Windows ou l'application de faon inattendue.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\fi\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Vaihda levy',0
ELSE
szDiskCap       db  'Tiedostovirhe',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Tiedostoa ", 0
szCannotFind2   db      " ei lydy", 0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Virhe ladattaessa tiedostoa ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ' ei lydy, aseta tiedoston sisltv levy asemaan '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Sovelluksessa tapahtui virhe.",10
	db      "Jos valitset Ohita, tallenna tysi uuteen tiedostoon.",10
	db      "Jos valitset Sulje, sovellus lopetetaan.",0
endif

public  szDosVer
szDosVer        DB      'Vr MS-DOS-versio. MS-DOS 3.1 tai uudempi tarvitaan.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Sovellusvirhe"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " aiheutti "
		db      0
szInModule      db      " moduulissa", 10, " <tuntematon>"
		db      0
szAt            db      ": "
		db      0
szNukeApp       db      ".", 10, 10, "Valitse sulje. "
		db      0
szWillClose     db      " lopetetaan."
		db      0
szGP            db      "yleisen suojausvirheen"
		db      0
szD0            db      "jako nollalla -virheen"        ; not yet used
		db      0
szSF            db      "pinovirheen"           ; not spec'ed
		db      0
szII            db      "virheellinen komento -virheen" ; "Fault" ???
		db      0
szPF            db      "sivuvirheen"
		db      0
szNP            db      "ei kytettviss -virheen"
		db      0
szAF            db      "sovellusvirheen"       ; not yet used
		db      0
szLoad          db      "segmentin latausvirheen"
		db      0
szOutofSelectors db     "valitsimien loppumisvirheen"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Nykyinen sovellus lopetetaan.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Ei voi ladata pakattuja tiedostoja",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Jrjestelmvirhe",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Kirjoitussuojattu levyke asemassa "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Ei voi lukea asemasta "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Ei voi kirjoittaa asemaan "
drvlet3                 db      "X.",0

msgShare                db      "Tiedostonjakovirhe asemassa "
drvlet4                 db      "X.",0

msgNetError             db      "Verkkovirhe asemassa "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Ei voi lukea laitteelta "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Ei voi kirjoittaa laitteeseen "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Verkkovirhe laitteessa "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Kirjoitin ei valmiina",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit-koodi = ',0
szExitStr2  DB  ' pinon ylivuoto',13,10,0
public  szUndefDyn
szUndefDyn      db      "Kutsu mrittelemttmn dynaamiseen linkkiin",0
public  szFatalExit
szFatalExit     db      "Sovellus kutsui epnormaalia pysytyst",0
else
public szDebugStr
szDebugStr  DB  'YDIN: Eponnistunut lataus - ',0                   ; 0
	    DB  'YDIN: Eponnistunut yritys ladata uusi taso tiedostosta - ',0   ; 1
	    DB  'Virhe ladattaessa resurssitiedostosta - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit-koodi = ',0                   ; 4
	    DB  ' pinon ylivuoto',0                             ; 5
	    DB  13,10,'Pinon jlki:',13,10,0                    ; 6
	    DB  7,13,10,'Keskeyt, katkaise, lopeta vai jt huomiotta? ',0      ; 7
	    DB  'Virheellinen BP-ketju',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Uudelleenkutsuttu FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Peruuttamaton ydinvirhe ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Virhekoodi on ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostiikkatilan kynnistys. Lokitiedosto:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt


ifdef WOW
public szGenBootFail
szNoPMode db "Win16-alijrjestelm ei voinut siirty suojattuun tilaan. DOSX.EXE:n on oltava AUTOEXEC.NT-tiedostossasi ja polussa.",0
szMissingMod    db   "NTVDM:n YDIN: 16-bittinen jrjestelmmoduuli puuttuu",0
szPleaseDoIt    db   "Asenna seuraava moduuli uudelleen system32-hakemistoon:",13,10,9,9,0
szInadequate    db   "NTVDM:n YDIN: Riittmtn DPMI-palvelin",0
szNoGlobalInit  db   "NTVDM:n YDIN: Ei voi alustaa kekoa",0
NoOpenFile      db   "NTVDM:n YDIN: Ytimen kynnistystiedostoa ei voi avata",0
NoLoadHeader    db   "NTVDM:n YDIN: Ytimen kynnistystiedoston alustustietoja ei voi ladata",0
szGenBootFail   db   "NTVDM:n YDIN: Win16-alijrjestelmn alustusvirhe",0
else
szInadequate    db   'YDIN: Riittmtn DPMI-palvelin',13,10,'$'
szNoPMode       db   'YDIN: Ei voi kytt suojattua tilaa',13,10,'$'
szNoGlobalInit  db   "YDIN: Ei voi alustaa kekoa",13,10,'$'
NoOpenFile      db   "YDIN: Ytimen kynnistystiedostoa ei voi avata"
		db   13, 10, '$'
NoLoadHeader    db   "YDIN: Ei voi ladata ytimen kynnistystiedoston alustustietoja"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Varoitus sovellusten yhteensopimattomuudesta",0

msgRealModeApp1 db      "Sovellus, jonka aiot kynnist, ",0
msgRealModeApp2 db      ", on tehty edellist Windowsin versiota varten.",0Dh,0Dh
	db      "Hanki sovelluksesta pivitetty versio, joka on yhteensopiva "
	db      "Windowsin version 3.0 ja uudempien kanssa.",13,13
	db      "Jos valitset painikkeen OK ja kynnistt sovelluksen, yhteensopivuusongelmat "
	db      "voivat aiheuttaa sovelluksen tai Windowsin yllttvn pyshtymisen.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\ger\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Diskette wechseln',0
ELSE
szDiskCap	db  'Dateifehler',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Folgende Datei kann nicht gefunden werden: ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Fehler beim Laden der Datei: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Bitte legen Sie die Diskette ein in Laufwerk '
ENDIF
;public  drvlet
;drvlet		db  "X:. ",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"In Ihrer Anwendung ist ein Fehler aufgetreten.",10
	db	"Falls Sie 'Ignorieren' whlen, sollten Sie Ihre Arbeit",10
	db	"in einer neuen Datei sichern. Falls Sie 'Schlieen' ",10
	db	"whlen, wird Ihre Anwendung beendet. ",0

endif

public	szDosVer
szDosVer	DB	'Falsche MS-DOS-Version. MS-DOS, Version 3.1 oder hher erforderlich. ',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Anwendungsfehler"
		db	0
szBlame		db	"START "
		db	0
szSnoozer	db	" verursachte "
		db	0
szInModule	db	" in", 10, "Modul <NO_NAME>"
		db	0
szAt		db	" bei "
		db	0
szNukeApp	db	". ", 10, 10, "Whlen Sie 'Schlieen'. "
		db	0
szWillClose	db	" wird schlieen. "
		db	0
szGP		db	"eine allgemeine Schutzverletzung"
		db	0
szD0		db	"eine Division durch Null"	; not yet used
		db	0
szSF		db	"ein Stapelspeicherfehler"	; not spec'ed
		db	0
szII		db	"eine unzulssige Anweisung"	; "Fault" ???
		db	0
szPF		db	"ein Seitenfehler"
		db	0
szNP		db	"ein nicht vorhandener Fehler"
		db	0
szAF		db	"ein Anwendungsfehler"	; not yet used
		db	0
szLoad		db	"Segmentladefehler"
		db	0
szOutofSelectors db	"Nicht gengend Selektoren"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Schliet aktuelle Anwendung. ",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Komprimierte Dateien knnen nicht geladen werden. ",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Systemfehler",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Schreibgeschtzte Diskette in Laufwerk "
drvlet1                 db      "X:. ",0

msgCannotReadDrv        db      "Fehler beim Lesen von Laufwerk "
drvlet2                 db      "X:. ",0

msgCannotWriteDrv       db      "Fehler beim Schreiben auf Laufwerk "
drvlet3                 db      "X:. ",0

msgShare                db      "Fehler beim gleichzeitigen Zugriff auf Laufwerk "
drvlet4                 db      "X:. ",0

msgNetError             db      "Netzwerkfehler auf Laufwerk "
drvlet5                 db      "X:. ",0

msgCannotReadDev        db      "Fehler beim Lesen von Gert "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Fehler beim Schreiben auf Gert "
devenam2                db      8 dup (?)
                        db      0

msgNetErrorDev          db      "Netzwerkfehler bei Gert "
devenam3                db      8 dup (?)
                        db      0

msgNoPrinter            db      "Drucker ist nicht bereit. ",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit Code = ',0
szExitStr2  DB  ' Stapelberlauf',13,10,0
public  szUndefDyn
szUndefDyn      db      "Aufruf zu nicht definierten Dynalink. ",0
public  szFatalExit
szFatalExit	db	"Anwendung verlangte besondere Terminierung. ",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Fehlgeschlagenes Laden - ',0                ; 0
            DB  'KERNEL: Fehler beim Laden einer neuen Instanz von - ',0; 1
            DB  'Fehler beim Laden von der Quelldatei - ',0             ; 2
            DB  13,10,0                                                 ; 3
            DB  7,13,10,'FatalExit Code = ',0                           ; 4
            DB  ' Stapelspeicherberlauf',0                             ; 5
            DB  13,10,'Stapelablaufverfolgung:',13,10,0                 ; 6
            DB  7,13,10,'Abbrechen, unterbrechen, beenden oder ignorieren?',0 ; 7
            DB  'Unzulssige BP-Kette',7,13,10,0                        ; 8
            DB  ': ',0                                                  ; 9
            DB  'Zurckgegangen zu FatalExit',7,13,10,0                 ; 10
            DB  0
public szFKE
szFKE	DB '*** Schwerwiegender Kernel-Fehler ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Fehler-Code ist: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Starten im Diagnosemodus. Protokolldatei ist:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Das Win16-Teilsystem konnte nicht im Protected Mode gestartet werden. DOSX.EXE muss in AUTOEXEC.NT vorhanden und ber PATH aufrufbar sein.",0
szMissingMod    db   "NTVDM KERNEL: Fehlendes 16-Bit-Systemmodul",0
szPleaseDoIt    db   "Installieren Sie erneut folgendes Modul in das Verzeichnis 'System32':",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Unzulssiger DPMI-Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Heap konnte nicht initialisiert werden.",0
NoOpenFile	db   "NTVDM KERNEL: Ausfhrbare KERNEL-Datei konnte nicht geffnet werden.",0
NoLoadHeader	db   "NTVDM KERNEL: KERNEL EXE-Vorspann konnte nicht geladen werden.",0
szGenBootFail   db   "NTVDM KERNEL: Initialisierungsfehler des Win 16-Teilsystems.",0
else
szInadequate	db   'KERNEL: Unzulssiger DPMI-Server',13,10,'$'
szNoPMode	db   'KERNEL: Kein Starten im Protected Mode mglich. ',13,10,'$'
szNoGlobalInit	db   "KERNEL: Heap konnte nicht initialisiert werden.",13,10,'$'
NoOpenFile	db   "KERNEL: Ausfhrbare KERNEL-Datei konnte nicht geffnet werden."
			db   13, 10, '$'
NoLoadHeader	db   "KERNEL: KERNEL EXE-Vorspann konnte nicht geladen werden."
			db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Hinweis zur Kompatibilitt der Anwendung",0

msgRealModeApp1 db	"Die Anwendung, die Sie ausfhren mchten, ",0
msgRealModeApp2 db	"ist fr eine frhere Windows-Version entwickelt worden. ",0Dh,0Dh
	db	"Verwenden Sie eine aktualisierte Version der Anwendung, die mit"
	db	"Windows, Version 3.0 oder hher, kompatibel ist. ",13,13
	db	"Wenn Sie OK whlen und die Anwendung starten, knnen Kompatibilitts-"
	db	"probleme ein unerwartetes Beenden des Windows-Teilsystems verursachen. ",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\it\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Cambiare disco',0
ELSE
szDiskCap       db  'Errore nel file',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Impossibile trovare ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Errore nel caricamento di ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', inserire nell''unit '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Errore dell'applicazione.",10
	db      "Scegliendo Ignora, si deve salvare in un nuovo file.",10
	db      "Scegliendo Chiudi, l'applicazione verr terminata.",0
endif

public  szDosVer
szDosVer        DB      'Versione MS-DOS errata.  E'' richiesto MS-DOS 3.1 o una versione successiva.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Errore dell'applicazione"
		db      0
szBlame         db      "AVVIO "
		db      0
szSnoozer       db      " ha causato "
		db      0
szInModule      db      " in", 10, "modulo <sconosciuto>"
		db      0
szAt            db      " su "
		db      0
szNukeApp       db      ".", 10, 10, "Scegliere chiudi. "
		db      0
szWillClose     db      " verr terminata."
		db      0
szGP            db      "un errore di protezione generale"
		db      0
szD0            db      "una divisione per zero"        ; not yet used
		db      0
szSF            db      "uno Stack Fault"               ; not spec'ed
		db      0
szII            db      "un'istruzione non consentita"  ; "Fault" ???
		db      0
szPF            db      "un Page Fault"
		db      0
szNP            db      "un errore di non presenza"
		db      0
szAF            db      "un errore dell'applicazione"   ; not yet used
		db      0
szLoad          db      "fallimento di caricamento del segmento"
		db      0
szOutofSelectors db     "selettori esauriti"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Chiusura dell'applicazione corrente.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Impossibile caricare i file compressi",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Errore di sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protetto da scrittura nell'unit "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossibile leggere l'unit "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossibile scrivere sull'unit "
drvlet3                 db      "X.",0

msgShare                db      "Violazione di condivisione sull'unit "
drvlet4                 db      "X.",0

msgNetError             db      "Errore di rete sull'unit "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Impossibile leggere dalla periferica "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Impossibile scrivere sulla periferica "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Errore di rete sulla periferica "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Stampante non pronta",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Codice di FatalExit = ',0
szExitStr2  DB  ' overflow dello stack',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chiamata ad un collegamento dinamico indefinito",0
public  szFatalExit
szFatalExit     db      "L'applicazione ha richiesto una terminazione anormale",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Caricamento non riuscito - ',0                     ; 0
	    DB  'KERNEL: Caricamento non riuscito di una nuova istanza di - ',0      ; 1
	    DB  'Errore nel caricamento del file risorsa - ',0      ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'Codice di FatalExit = ',0                       ; 4
	    DB  ' overflow dello stack',0                                 ; 5
	    DB  13,10,'Traccia dello stack:',13,10,0                     ; 6
	    DB  7,13,10,'Termina, Interrompi, Esci o Ignora? ',0            ; 7
	    DB  'Catena BP non valida',7,13,10,0                         ; 8
	    DB  ': ',0                                          ; 9
	    DB  'FatalExit reimmesso',7,13,10,0         ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[avvio]'           ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Codice Failure: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Avvio modalit diagnostica. File registro:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Il sottosistema Win16 non ha potuto avviare la modalit protetta, DOSX.EXE deve essere in AUTOEXEC.NT e presente in PATH.",0
szMissingMod    db   "NTVDM KERNEL: modulo di sistema a 16 bit mancante",0
szPleaseDoIt    db   "Reinstallare il modulo seguente nella directory system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Server DPMI non adatto",0
szNoGlobalInit  db   "NTVDM KERNEL: Impossibile inizializzare la memoria",0
NoOpenFile          db   "NTVDM KERNEL: Impossibile aprire l'eseguibile KERNEL",0
NoLoadHeader    db   "NTVDM KERNEL: Impossibile caricare l'intestazione KERNEL EXE",0
szGenBootFail   db   "NTVDM KERNEL: Inizializzazione del sottosistema Win16 non riuscita",0
else
szInadequate    db   'KERNEL: Server DPMI non adatto',13,10,'$'
szNoPMode       db   'KERNEL: Impossibile operare in modalit protetta',13,10,'$'
szNoGlobalInit  db   "KERNEL: Impossibile inizializzare la memoria",13,10,'$'
NoOpenFile      db   "KERNEL: Impossibile aprire l'eseguibile KERNEL"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Impossibile caricare l'intestazione KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Avviso di compatibilit dell'applicazione",0

msgRealModeApp1 db      "L'applicazione che si sta per eseguire, ",0
msgRealModeApp2 db      ",  scritta per una versione precedente di Windows.",0Dh,0Dh
	db      "Ottenere una versione aggiornata dell'applicazione che sia compatibile "
	db      "con Windows versione 3.0 o successive.",13,13
	db      "Se si sceglie OK e si avvia l'applicazione, i problemi di compatibilit"
	db      "potrebbero causare la chiusura inattesa dell'applicazione o di Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\hu\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Lemezcsere',0
ELSE
szDiskCap       db  'Fjlhiba',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "A(z) ", 0
szCannotFind2   db      " nem tallhat.", 0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Hiba a kvetkez komponens betltse kzben: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ' nem tallhat. Helyezze be a kvetkez meghajtba: '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Hiba trtnt az alkalmazsban.",10
        db      "Ha a Tovbb gombra kattint, azonnal mentse el adatait egy j fjlba.",10
        db      "Ha a Bezrst vlasztja, az alkalmazs befejezdik.",0
endif

public  szDosVer
szDosVer        DB      'Nem megfelel MS-DOS verzi.  MS-DOS 3.1 vagy jabb szksges.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Alkalmazshiba"
                db      0
szBlame         db      "BOOT "
                db      0
szSnoozer       db      "  "
                db      0
szInModule      db      " -", 10, "modul: <unknown>"
                db      0
szAt            db      " - "
                db      0
szNukeApp       db      ".", 10, 10, "Vlassza a Bezrs gombot. "
                db      0
szWillClose     db      " be lesz zrva."
                db      0
szGP            db      "ltalnos vdelmi hiba (GPF)"
                db      0
szD0            db      "nullval val oszts " ; not yet used
                db      0
szSF            db      "veremhiba"             ; not spec'ed
                db      0
szII            db      "illeglis utasts"    ; "Fault" ???
                db      0
szPF            db      "laphiba "
                db      0
szNP            db      "'objektum nem tallhat' hiba"
                db      0
szAF            db      "alkalmazshiba "    ; not yet used
                db      0
szLoad          db      "szegmensbetltsi hiba"
                db      0
szOutofSelectors db     "a szelektorok elfogytak "
                db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Az aktulis alkalmazs bezrsa.",0

; Text for dialog box when trying to run a compressed file
                           
public szBozo
szBozo          db      "Tmrtett fjlokat nem lehet betlteni.",0
                                                     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Rendszerhiba",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "A kvetkez meghajtban lv lemez rsvdett: "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "A kvetkez meghajtrl nem lehet olvasni: "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "A kvetkez meghajtra nem lehet rni: "
drvlet3                 db      "X.",0

msgShare                db      "Megosztsmegsrtsi hiba a kvetkez meghajtn: "
drvlet4                 db      "X.",0

msgNetError             db      "Hlzati hiba a kvetkez meghajtn: "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "A kvetkez eszkzrl nem lehet olvasni: "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "A kvetkez eszkzre nem lehet rni: "
devenam2                db      8 dup (?)
                        db      0

msgNetErrorDev          db      "Hlzati hiba a kvetkez eszkzn: "
devenam3                db      8 dup (?)
                        db      0

msgNoPrinter            db      "A nyomtat nem zemksz.",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Nem definilt Dynalink-hvs.",0
public  szFatalExit
szFatalExit     db      "Az alkalmazs nem a szablyos mdon fejezdtt be",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: nem tlthet be - ',0                                     ; 0
            DB  'KERNEL: az objektum j pldnya nem tlthet be - ',0             ; 1
            DB  'Az objektum nem tlthet be az erforrsfjlbl  - ',0    ; 2
            DB  13,10,0                                                            ; 3
            DB  7,13,10,'FatalExit kd = ',0                                       ; 4
            DB  ' veremtr tlcsorduls',0                                         ; 5
            DB  13,10,'A verem tartalma:',13,10,0                                  ; 6
            DB  7,13,10,'Megszakts, Trspont, Kilps vagy Folytats? ',0         ; 7
            DB  'rvnytelen BP lnc.',7,13,10,0                                   ; 8
            DB  ': ',0                                          ; 9
            DB  'jra bert FatalExit',7,13,10,0                 ; 10
            DB  0
public szFKE
szFKE   DB '*** Slyos kernelhiba ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Hibakd: ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
        public szInitSpew
szInitSpew      DB      'Indts diagnosztikai zemmdban. Naplfjl:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "A Win16 alrendszer nem tudott vdett mdba kapcsolni. A DOSX.EXE programnak szerepelnie kell az AUTOEXEC.NT fjlban, vagy PATH vltozval megadott elrsi ton.",0
szMissingMod    db   "NTVDM KERNEL: Hinyz 16 bites rendszermodul.",0
szPleaseDoIt    db   "Teleptse jra a kvetkez modult a system32 knyvtrba:",13,10,9,9,0
szInadequate    db   "KERNEL: Nem megfelel DPMI-kiszolgl.",0
szNoGlobalInit  db   "KERNEL: A heap nem inicializlhat.",0
NoOpenFile      db   "KERNEL: A kernel futtathat fjljt nem sikerlt megnyitni.",0
NoLoadHeader    db   "KERNEL: A KERNEL EXE-fejlce nem tlthet be.",0
szGenBootFail   db   "KERNEL: Win16 alrendszer - inicializcis hiba.",0
else
szInadequate    db   'KERNEL: Nem megfelel DPMI-kiszolgl.',13,10,'$'
szNoPMode       db   'KERNEL: Nem sikerlt vdett mdba kapcsolni.',13,10,'$'
szNoGlobalInit  db   "KERNEL: Nem sikerlt inicializlni a heapet.",13,10,'$'
NoOpenFile      db   "KERNEL: A kernel futtathat fjljt nem sikerlt megnyitni."
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: a KERNEL EXE-fejlce nem tlthet be."
                db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Alkalmazs-kompatibilitsi zenet",0

msgRealModeApp1 db      "A futtatni kvnt alkalmazst a Windows korbbi ",0
msgRealModeApp2 db      ", verzijhoz terveztk.",0Dh,0Dh
        db      "Szerezze be az alkalmazs jabb, legalbb Windows 3.0-val kompatibilis "
        db      "vltozatt.",13,13
        db      "Ha az OK gombra kattint s elindtja az alkalmazst, akkor nem vrt "
        db      "problmk lphetnek fel, illetve a Windows bezrhatja az alkalmazst.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\jpn\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'fBXNX',0
ELSE
szDiskCap       db  't@C G[',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "t@C: ", 0
szCannotFind2   db      "  "0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "[h G[: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  'Bt@CfBXNhCu}: '
ENDIF
;public  drvlet
;drvlet         db  "X",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "AvP[VG[B",10
        db      "[] IAeVt@CB",10
        db      "[] IAAvP[VIB",0
endif

public  szDosVer
szDosVer        DB      'o[WMS-DOSWindowssBo[W3.1~MS-DOSKvB',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
public szRISC386
endif ; for JAPAN
endif ; not PM386
szAbortCaption  db      "AvP[V G["
                db      0
szBlame         db      "u[g"
                db      0
szSnoozer       db      "  "
                db      0
szInModule      db      " B", 10, "AW[ <s>"
                db      0
szAt            db      "  "
                db      0
szNukeApp       db      " nB", 10, 10, "[] IB"
                db      0
szWillClose     db      " IB"
                db      0
szGP            db      ""
                db      0
szD0            db      "0Z"        ; not yet used
                db      0
szSF            db      "X^bN"                ; not spec'ed
                db      0
szII            db      "s" ; "Fault" ???
                db      0
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
szRISC386       db      "RISC VXeT|[g x86 " ; "Fault" ???
                db      0
endif ; for JAPAN
endif ; not PM386
szPF            db      "y[W"
                db      0
szNP            db      "s"
                db      0
szAF            db      "AvP[V" ; not yet used
                db      0
szLoad          db      "ZOg[hs"
                db      0
szOutofSelectors db     "ZN^s"
                db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "sAvP[VIB",0

; Text for dialog box when trying to run a compressed file

public szBozo
szBozo          db      "kt@C[h",0

; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "VXe G[",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3
IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
public  SIZE_INT24_MESSAGES
;
;       ATTENTION: msgWriteProtect is must be first label of int24 messages.
;
ENDIF   ; was DB_FA DNT

msgWriteProtect         db      "~fBXN: hCu "
drvlet1                 db      "X",0

msgCannotReadDrv        db      "o: hCu "
drvlet2                 db      "X",0

msgCannotWriteDrv       db      ": hCu "
drvlet3                 db      "X",0

msgShare                db      "L: hCu "
drvlet4                 db      "X",0

msgNetError             db      "lbg[N G[: hCu "
drvlet5                 db      "X",0

msgCannotReadDev        db      "o: foCX "
devenam1                db      8 dup (0)
                        db      0

msgCannotWriteDev       db      ": foCX "
devenam2                db      8 dup (0)
                        db      0

msgNetErrorDev          db      "lbg[N G[: foCX "
devenam3                db      8 dup (0)
                        db      0

msgNoPrinter            db      "v^",0

IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
SIZE_INT24_MESSAGES     equ     $ - offset msgWriteProtect
ENDIF   ; was DB_FA - now JAPAN DNT

ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExitR[h = ',0
szExitStr2  DB  'X^bN I[o[t[',13,10,0
public  szUndefDyn
szUndefDyn      db      "`_Ci~bN No",0
public  szFatalExit
szFatalExit     db      "AvP[VIv",0
else
public szDebugStr
szDebugStr  DB  'J[l: [hs - ',0                   ; 0
            DB  'J[l: VCX^X[hs - ',0   ; 1
            DB  '\[X t@C[hs - ',0      ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExitR[h = ',0                  ; 4
            DB  'X^bN I[o[t[',0                     ; 5
            DB  13,10,'X^bN g[X:',13,10,0              ; 6
            DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'BP`F[',7,13,10,0                    ; 8
            DB  ': ',0                                          ; 9
            DB  'FatalExit',7,13,10,0               ; 10
            DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' G[ R[h ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
        public szInitSpew
szInitSpew      DB      'ff[hNBO t@C:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt
	
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate    db   'J[l: DPMIT[o[sK',13,10,'$'
szNoPMode       db   'J[l: veNg [h',13,10,'$'
szNoGlobalInit  db   "J[l: q[v",13,10,'$'

NoOpenFile      db   "J[l: KERNELs\t@CI[v"
                db   13, 10, '$'
NoLoadHeader    db   "J[l: KERNELEXEwb_[[h"
                db   13, 10, '$'

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "AvP[Vx",0

msgRealModeApp1 db      "sAvP[V ",0
msgRealModeApp2 db      " AOo[WWindowspJB",0Dh,0Dh
        db      "o[W3.0~WindowsAVAvP[V"
        db      "B",13,13
        db      " [OK] IAvP[VNA"
        db      "AvP[VWindowsRN[Y\B",0

_NRESTEXT ENDS

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\nec_98\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'fBXNX',0
ELSE
szDiskCap       db  't@C G[',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "t@C: ", 0
szCannotFind2   db      "  "0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "[h G[: ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  'Bt@CfBXNhCu}: '
ENDIF
;public  drvlet
;drvlet         db  "X",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "AvP[VG[B",10
        db      "[] IAeVt@CB",10
        db      "[] IAAvP[VIB",0
endif

public  szDosVer
szDosVer        DB      'o[WMS-DOSWindowssBo[W3.1~MS-DOSKvB',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
public szRISC386
endif ; for JAPAN
endif ; not PM386
szAbortCaption  db      "AvP[V G["
                db      0
szBlame         db      "u[g"
                db      0
szSnoozer       db      "  "
                db      0
szInModule      db      " B", 10, "AW[ <s>"
                db      0
szAt            db      "  "
                db      0
szNukeApp       db      " nB", 10, 10, "[] IB"
                db      0
szWillClose     db      " IB"
                db      0
szGP            db      ""
                db      0
szD0            db      "0Z"        ; not yet used
                db      0
szSF            db      "X^bN"                ; not spec'ed
                db      0
szII            db      "s" ; "Fault" ???
                db      0
ifndef PM386
ifdef JAPAN
; RISC x86 emulation for JAPAN 
szRISC386       db      "RISC VXeT|[g x86 " ; "Fault" ???
                db      0
endif ; for JAPAN
endif ; not PM386
szPF            db      "y[W"
                db      0
szNP            db      "s"
                db      0
szAF            db      "AvP[V" ; not yet used
                db      0
szLoad          db      "ZOg[hs"
                db      0
szOutofSelectors db     "ZN^s"
                db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "sAvP[VIB",0

; Text for dialog box when trying to run a compressed file

public szBozo
szBozo          db      "kt@C[h",0

; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "VXe G[",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3
IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
public  SIZE_INT24_MESSAGES
;
;       ATTENTION: msgWriteProtect is must be first label of int24 messages.
;
ENDIF   ; was DB_FA DNT

msgWriteProtect         db      "~fBXN: hCu "
drvlet1                 db      "X",0

msgCannotReadDrv        db      "o: hCu "
drvlet2                 db      "X",0

msgCannotWriteDrv       db      ": hCu "
drvlet3                 db      "X",0

msgShare                db      "L: hCu "
drvlet4                 db      "X",0

msgNetError             db      "lbg[N G[: hCu "
drvlet5                 db      "X",0

msgCannotReadDev        db      "o: foCX "
devenam1                db      8 dup (0)
                        db      0

msgCannotWriteDev       db      ": foCX "
devenam2                db      8 dup (0)
                        db      0

msgNetErrorDev          db      "lbg[N G[: foCX "
devenam3                db      8 dup (0)
                        db      0

msgNoPrinter            db      "v^",0

IFDEF   JAPAN                           ; For FontAssoc 92/09/29 yasuho
SIZE_INT24_MESSAGES     equ     $ - offset msgWriteProtect
ENDIF   ; was DB_FA - now JAPAN DNT

ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExitR[h = ',0
szExitStr2  DB  'X^bN I[o[t[',13,10,0
public  szUndefDyn
szUndefDyn      db      "`_Ci~bN No",0
public  szFatalExit
szFatalExit     db      "AvP[VIv",0
else
public szDebugStr
szDebugStr  DB  'J[l: [hs - ',0                   ; 0
            DB  'J[l: VCX^X[hs - ',0   ; 1
            DB  '\[X t@C[hs - ',0      ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExitR[h = ',0                  ; 4
            DB  'X^bN I[o[t[',0                     ; 5
            DB  13,10,'X^bN g[X:',13,10,0              ; 6
            DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'BP`F[',7,13,10,0                    ; 8
            DB  ': ',0                                          ; 9
            DB  'FatalExit',7,13,10,0               ; 10
            DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' G[ R[h ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
        public szInitSpew
szInitSpew      DB      'ff[hNBO t@C:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt
	
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate    db   'J[l: DPMIT[o[sK',13,10,'$'
szNoPMode       db   'J[l: veNg [h',13,10,'$'
szNoGlobalInit  db   "J[l: q[v",13,10,'$'

NoOpenFile      db   "J[l: KERNELs\t@CI[v"
                db   13, 10, '$'
NoLoadHeader    db   "J[l: KERNELEXEwb_[[h"
                db   13, 10, '$'

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "AvP[Vx",0

msgRealModeApp1 db      "sAvP[V ",0
msgRealModeApp2 db      " AOo[WWindowspJB",0Dh,0Dh
        db      "o[W3.0~WindowsAVAvP[V"
        db      "B",13,13
        db      " [OK] IAvP[VNA"
        db      "AvP[VWindowsRN[Y\B",0

_NRESTEXT ENDS

end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\usa\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Change Disk',0
ELSE
szDiskCap	db  'File Error',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Cannot find ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Error loading ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Please insert in drive '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"An error has occurred in your application.",10
        db      "If you choose Ignore, you should save your work in a new file.",10
        db      "If you choose Close, your application will terminate.",0
endif

public	szDosVer
szDosVer	DB	'Incorrect MS-DOS version.  MS-DOS 3.1 or greater required.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Application Error"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" caused "
		db	0
szInModule	db	" in", 10, "module <unknown>"
		db	0
szAt		db	" at "
		db	0
szNukeApp       db      ".", 10, 10, "Choose close. "
		db	0
szWillClose	db	" will close."
		db	0
szGP		db	"a General Protection Fault"
		db	0
szD0		db	"a Divide by Zero"	; not yet used
		db	0
szSF		db	"a Stack Fault"		; not spec'ed
		db	0
szII		db	"an Illegal Instruction"	; "Fault" ???
		db	0
szPF		db	"a Page Fault"
		db	0
szNP		db	"a Not Present Fault"
		db	0
szAF		db	"an Application Fault"	; not yet used
		db	0
szLoad		db	"Segment Load Failure"
		db	0
szOutofSelectors db	"Out of Selectors"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Closing current application.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Cannot load compressed files",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"System Error",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Write-protected disk in drive "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Cannot read from drive "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Cannot write to drive "
drvlet3                 db      "X.",0

msgShare		db	"Sharing violation on drive "
drvlet4                 db      "X.",0

msgNetError		db	"Network error on drive "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Cannot read from device "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Cannot write to device "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Network error on device "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Printer not ready",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit	db	"Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
            DB  'KERNEL: Failed loading new instance of - ',0   ; 1
            DB  'Error loading from resource file - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit code = ',0                   ; 4
            DB  ' stack overflow',0                             ; 5
            DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
            DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Reentered FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "The Win16 Subsystem was unable to enter Protected Mode, DOSX.EXE must be in your AUTOEXEC.NT and present in your PATH.",0
szMissingMod    db   "NTVDM KERNEL: Missing 16-bit system module",0
szPleaseDoIt    db   "Please re-install the following module to your system32 directory:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Inadequate DPMI Server",0
szNoGlobalInit	db   "NTVDM KERNEL: Unable to initialize heap",0
NoOpenFile	    db   "NTVDM KERNEL: Unable to open KERNEL executable",0
NoLoadHeader	db   "NTVDM KERNEL: Unable to load KERNEL EXE header",0
szGenBootFail   db   "NTVDM KERNEL: Win16 Subsystem Initialization Failure",0
else
szInadequate	db   'KERNEL: Inadequate DPMI Server',13,10,'$'
szNoPMode	db   'KERNEL: Unable to enter Protected Mode',13,10,'$'
szNoGlobalInit	db   "KERNEL: Unable to initialize heap",13,10,'$'
NoOpenFile      db   "KERNEL: Unable to open KERNEL executable"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Unable to load KERNEL EXE header"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Application Compatibility Warning",0

msgRealModeApp1 db	"The application you are about to run, ",0
msgRealModeApp2 db	", was designed for a previous version of Windows.",0Dh,0Dh
	db	"Obtain an updated version of the application that is compatible "
	db	"with Windows version 3.0 and later.",13,13
	db	"If you choose the OK button and start the application, compatibility "
	db	"problems could cause the application or Windows to close unexpectedly.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\nl\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Kies andere schijf',0
ELSE
szDiskCap       db  'Bestandsfout',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Kan ",0
szCannotFind2   db      " niet vinden",0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Fout tijdens laden van ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', plaats deze in station '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Er is een fout opgetreden in uw toepassing.",10
	db      "Als u Negeren kiest, kunt u uw werk het beste opslaan in een nieuw bestand.",10
	db      "Als u Sluiten kiest, zal uw toepassing beindigd worden.",0
endif

public  szDosVer
szDosVer        DB      'Onjuiste MS-DOS-versie.  MS-DOS 3.1 of hoger is benodigd.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Toepassingsfout"
		db      0
szBlame         db      "OPSTARTEN "
		db      0
szSnoozer       db      " veroorzaakte "
		db      0
szInModule      db      " in", 10, "module <onbekend>"
		db      0
szAt            db      " op "
		db      0
szNukeApp       db      ".", 10, 10, "Kies sluiten. "
		db      0
szWillClose     db      " zal sluiten."
		db      0
szGP            db      "een algemene beschermingsfout"
		db      0
szD0            db      "een deling door nul"   ; not yet used
		db      0
szSF            db      "een stapelfout"                ; not spec'ed
		db      0
szII            db      "een ongeldige opdracht"        ; "Fault" ???
		db      0
szPF            db      "een wisselfout"
		db      0
szNP            db      "een is-niet-aanwezig-fout"
		db      0
szAF            db      "een toepassingsfout"   ; not yet used
		db      0
szLoad          db      "Segment laden mislukt"
		db      0
szOutofSelectors db     "Geen selectors meer"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Huidige toepassing wordt gesloten.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Kan geen gecomprimeerde bestanden laden",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Systeemfout",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Schrijfbeveiligde diskette in station "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Kan niet lezen van station "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Kan niet schrijven naar station "
drvlet3                 db      "X.",0

msgShare                db      "Schending van gemeensch. gebruik op station "
drvlet4                 db      "X.",0

msgNetError             db      "Netwerkfout op station "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Kan niet lezen van apparaat "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Kan niet schrijven van apparaat "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Netwerkfout op apparaat "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Printer niet gereed",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Aanroep van een niet-gedefinieerde Dynalink",0
public  szFatalExit
szFatalExit     db      "De toepassing heeft gevraagd om uitzonderlijke beindiging",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
	    DB  'KERNEL: Failed loading new instance of - ',0   ; 1
	    DB  'Error loading from resource file - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' stack overflow',0                             ; 5
	    DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
	    DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Reentered FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Het Win16-subsysteem kan de 'protected' modus niet gebruiken, DOSX.EXE moet aanwezig zijn in uw AUTOEXEC.NT en in uw PAD.",0
szMissingMod    db   "NTVDM KERNEL: 16-bit systeemmodule ontbreekt",0
szPleaseDoIt    db   "Installeer de volgende module opnieuw in de map system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Inadequate DPMI-server",0
szNoGlobalInit  db   "NTVDM KERNEL: Kan opslag niet initialiseren",0
NoOpenFile          db   "NTVDM KERNEL: Kan KERNEL.EXE niet openen",0
NoLoadHeader    db   "NTVDM KERNEL: Kan het beginrecord van KERNEL.EXE niet laden",0
szGenBootFail   db   "NTVDM KERNEL: Fout bij initialisatie van het Win16-subsysteem",0
else
szInadequate    db   'KERNEL: Inadequate DPMI-server',13,10,'$'
szNoPMode       db   'KERNEL: Kan protected modus niet starten',13,10,'$'
szNoGlobalInit  db   "KERNEL: Kan opslag niet initialiseren",13,10,'$'
NoOpenFile      db   "KERNEL: Kan KERNEL.EXE niet openen"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Kan het beginrecord van KERNEL.EXE niet laden"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Waarschuwing: toepassing is niet compatibel",0

msgRealModeApp1 db      "De toepassing die u wilt gaan gebruiken, ",0
msgRealModeApp2 db      ", is bedoeld voor een oudere versie van Windows.",0Dh,0Dh
	db      "Gebruik een nieuwere versie van de toepassing die compatibel is "
	db      "met Windows-versie 3.0 en hoger.",13,13
	db      "Als u de knop OK kiest en de toepassing start, kunnen compatibiliteits-"
	db      "problemen de toepassing of Windows onverwacht beindigen.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\pl\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Zmie dyskietk',0
ELSE
szDiskCap       db  'Bd pliku',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Nie mona odnale ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Bd adowania ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', W do stacji '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "W aplikacji wystpi bd.",10
	db      "Jeli wybierzesz Ignoruj, moliwe bdzie zapisanie wynikw pracy w nowym pliku.",10
	db      "Jeli wybierzesz Zamknij, aplikacja zostanie zakoczona.",0
endif

public  szDosVer
szDosVer        DB      'Niepoprawna wersja MS-DOS. Wymagany jest system MS-DOS 3.1 lub nowszy.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Bd aplikacji"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " wywoaa "
		db      0
szInModule      db      " w", 10, "module <nieznany>"
		db      0
szAt            db      " pod adresem "
		db      0
szNukeApp       db      ".", 10, 10, "Wybierz zamknicie. "
		db      0
szWillClose     db      " ulegnie zamkniciu."
		db      0
szGP            db      "oglny bd ochrony"
		db      0
szD0            db      "dzielenie przez zero"  ; not yet used
		db      0
szSF            db      "bd stosu"            ; not spec'ed
		db      0
szII            db      "nieprawidow instrukcj"      ; "Fault" ???
		db      0
szPF            db      "bd strony"
		db      0
szNP            db      "bd braku"
		db      0
szAF            db      "bd aplikacji"        ; not yet used
		db      0
szLoad          db      "bd adowania segmentu "
		db      0
szOutofSelectors db     "za mao selektorw"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Zamykanie aplikacji.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Nie mona zaadowa plikw skompresowanych",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Bd systemu",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Dysk zabezpieczony przed zapisem w stacji "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Nie jest moliwy odczyt z dysku "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Nie jest moliwy zapis na dysk "
drvlet3                 db      "X.",0

msgShare                db      "Bd wspuytkowania dysku "
drvlet4                 db      "X.",0

msgNetError             db      "Bd sieciowy dysku "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Nie jest moliwy odczyt z urzdzenia "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Nie jest moliwy zapis do urzdzenia "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Bd sieci na urzdzeniu "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Drukarka nie jest gotowa",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' przepenienie stosu',13,10,0
public  szUndefDyn
szUndefDyn      db      "wywoanie niezdefiniowanego cza Dynalink",0
public  szFatalExit
szFatalExit     db      "Aplikacja zadaa nietypowego zakoczenia",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Nieudane adowanie - ',0                   ; 0
	    DB  'KERNEL: Nieudane adowanie nowego wystpienia - ',0   ; 1
	    DB  'Bd adowania z pliku zasobw - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' przepenienie stosu',0                             ; 5
	    DB  13,10,'ledzenie stosu:',13,10,0                    ; 6
	    DB  7,13,10,'Zakocz, Przerwij, Wyjd czy Ignoruj? ',0      ; 7
	    DB  'Nieprawidowy acuch BP',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Ponowne wejcie do funkcji FatalExit',7,13,10,0   ; 10
	    DB  0
public szFKE
szFKE   DB '*** Krytyczny bd jdra ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Kod bdu ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Rozpoczcie trybu diagnostycznego. Plik wynikw:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Podsystem Win16 nie mg uruchomi trybu chronionego, DOSX.EXE musi by w AUTOEXEC.NT oraz w ciece wyszukiwania.",0
szMissingMod    db   "NTVDM KERNEL: Brak 16-bitowego moduu systemowego",0
szPleaseDoIt    db   "Zainstaluj ponownie nastpujcy modu w katalogu system32:",13,10,9,9,0
szInadequate    db   "NTVDM KERNEL: Nieodpowiedni serwer DPMI",0
szNoGlobalInit  db   "NTVDM KERNEL: Nie mona zainicjowa sterty",0
NoOpenFile      db   "NTVDM KERNEL: Nie mona otworzy pliku wykonywalnego KERNEL",0
NoLoadHeader    db   "NTVDM KERNEL: Nie mona zaadowa nagwka KERNEL EXE",0
szGenBootFail   db   "NTVDM KERNEL: Bd inicjowania podsystemu Win16",0
else
szInadequate    db   'KERNEL: Nieodpowiedni serwer DPMI',13,10,'$'
szNoPMode       db   'KERNEL: Nie mona uruchomi trybu chronionego',13,10,'$'
szNoGlobalInit  db   "KERNEL: Nie mona zainicjowa sterty",13,10,'$'
NoOpenFile      db   "KERNEL: Nie mona otworzy pliku wykonywalnego KERNEL"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Nie mona zaadowa nagwka KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap        db	"Ostrzeenie o zgodnoci aplikacji",0

msgRealModeApp1 db      "Aplikacja ktr chcesz uruchomi, ",0
msgRealModeApp2 db      ", zostaa zaprojektowana dla poprzedniej wersji Windows.",0Dh,0Dh
	db      "Uzyskaj uaktualnion wersj tej aplikacji, zgodn "
	db      "z systemem Windows w wersji 3.0 lub nowszej.",13,13
	db      "Jeli wybierzesz OK i uruchomisz aplikacj, problemy ze zgodnoci "
	db      "mog spowodowa niespodziewane zamknicie aplikacji lub systemu.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\nl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\pt\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Trocar disco',0
ELSE
szDiskCap	db  'Erro de ficheiro',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"No  possvel encontrar ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Erro a carregar ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', Introduza na unidade  '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"Ocorreu um erro na aplicao.",10
        db      "Se escolher Ignorar, deve guardar o seu trabalho num novo ficheiro.",10
        db      "Se escolher Fechar, a aplicao terminar.",0
endif

public	szDosVer
szDosVer	DB	'Verso de MS-DOS incorrecta. Necessrio o MS-DOS 3.1 ou posterior.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Erro de aplicao"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" causou "
		db	0
szInModule	db	" no", 10, "mdulo <unknown>"
		db	0
szAt		db	" em "
		db	0
szNukeApp       db      ".", 10, 10, "Escolha fechar. "
		db	0
szWillClose	db	" ser fechada."
		db	0
szGP		db	"uma falha geral de proteco"
		db	0
szD0		db	"uma diviso por zero"	; not yet used
		db	0
szSF		db	"uma falha de pilha"		; not spec'ed
		db	0
szII		db	"uma instruo ilegal"	; "Fault" ???
		db	0
szPF		db	"uma falha de pgina"
		db	0
szNP		db	"uma falha de no presente"
		db	0
szAF		db	"uma falha de aplicao"	; not yet used
		db	0
szLoad		db	"Falha de carregamento de segmento"
		db	0
szOutofSelectors db	"Sem selectores"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"A encerrar a aplicao actual.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Impossvel carregar ficheiros comprimidos",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Erro de sistema",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Disco protegido contra escrita na unidade "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Impossivel ler da unidade "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Impossivel escrever na unidade "
drvlet3                 db      "X.",0

msgShare		db	"Violao de partilha na unidade "
drvlet4                 db      "X.",0

msgNetError		db	"Erro de rede na unidade "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Impossvel ler do dispositivo "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Impossvel escrever no dispositivo "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Erro de rede no dispositivo "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Impressora no preparada",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'Cd. FatalExit = ',0
szExitStr2  DB  ' excesso de pilha',13,10,0
public  szUndefDyn
szUndefDyn      db      "Chamada a dynalink no definida",0
public  szFatalExit
szFatalExit	db	"A aplicao requisitou concluso anormal.",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Falhou a carregar - ',0                   ; 0
            DB  'KERNEL: Falhou a carregar nova instncia de - ',0   ; 1
            DB  'Erro a carregar de ficheiro de recursos - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'Cd. FatalExit = ',0                   ; 4
            DB  ' excesso de pilha',0                             ; 5
            DB  13,10,'Rastreio da pilha:',13,10,0                    ; 6
	    DB  7,13,10,'Abortar, Suspender, Sair ou Ignorar? ',0      ; 7
            DB  'Cadeia BP invlida',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'FatalExit reentrou',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE	DB '*** Erro fatal de Kernel ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Cdigo de falha  ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Arranque em modo diagnstico. Ficheiro de registo :  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "O subsistema Win16 no conseguiu entrar em modo protegido. O DOSX.EXE tem de estar no AUTOEXEC.NT e presente em PATH.",0
szMissingMod    db   "NTVDM KERNEL: Falta mdulo de sistema a 16-bits",0
szPleaseDoIt    db   "Reinstale o mdulo seguinte no directrio system32:",13,10,9,9,0
szInadequate	db   "NTVDM KERNEL: Servidor DPMI inadequado",0
szNoGlobalInit	db   "NTVDM KERNEL: Impossvel inicializar a pilha local",0
NoOpenFile	    db   "NTVDM KERNEL: Impossvel abrir um executvel de KERNEL",0
NoLoadHeader	db   "NTVDM KERNEL: Impossvel carregar um cabealho de EXE de KERNEL",0
szGenBootFail   db   "NTVDM KERNEL: Falha na inicializao de subsistema Win16",0
else
szInadequate	db   'KERNEL: Servidor DPMI inadequado',13,10,'$'
szNoPMode	db   'KERNEL: Impossvel entrar em modo protegido',13,10,'$'
szNoGlobalInit	db   "KERNEL: Impossvel inicializar a pilha local",13,10,'$'
NoOpenFile      db   "KERNEL: Impossvel abrir um executvel de KERNEL"
                db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Impossvel carregar um cabealho de EXE de KERNEL"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Aviso de compatibilidade de aplicaes",0

msgRealModeApp1 db	"A aplicao que est prestes a executar, ",0
msgRealModeApp2 db	", foi concebida para uma verso anterior do Windows.",0Dh,0Dh
	db	"Obtenha uma verso actualizada da aplicao que seja compatvel "
	db	"com o Windows verso 3.0 e posteriores. ",13,13
	db	"Se escolher o boto OK e iniciar a aplicao, problemas de compatibilidade"
	db	"podero fechar inesperadamente a aplicao ou o Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\sv\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  'Byt diskett',0
ELSE
szDiskCap       db  'Filfel',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "Det gr inte att hitta ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "Fel vid inlsning av ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ', stt in i enhet '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "Det har uppsttt ett fel i programmet.",10
	db      "Om du vljer att Ignorera, br du frst spara arbetet i en ny fil.",10
	db      "Om du vljer Stng, kommer programmet att avslutas.",0
endif

public  szDosVer
szDosVer        DB      'Felaktig MS-DOS-version.  MS-DOS 3.1 eller nyare krvs.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Programfel"
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      " orsakade "
		db      0
szInModule      db      " i", 10, "modul <oknd>"
		db      0
szAt            db      " p "
		db      0
szNukeApp       db      ".", 10, 10, "Vlj Stng. "
		db      0
szWillClose     db      " kommer att stngas."
		db      0
szGP            db      "ett allmnt skyddsfel"
		db      0
szD0            db      "nolldivision"  ; not yet used
		db      0
szSF            db      "ett stackfel"          ; not spec'ed
		db      0
szII            db      "en ogiltig instruktion"        ; "Fel" ???
		db      0
szPF            db      "ett sidfel"
		db      0
szNP            db      "ett fel pga att ngot saknas"
		db      0
szAF            db      "ett programfel"        ; not yet used
		db      0
szLoad          db      "segmentinlsningsfel"
		db      0
szOutofSelectors db     "slut p selectors"
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Programmet avslutas.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Det gr inte att lsa in komprimerade filer",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr          db      "Systemfel",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "Skrivskyddad diskett i enhet "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Det gr inte att lsa frn enhet "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Det gr inte att skriva till enhet "
drvlet3                 db      "X.",0

msgShare                db      "Delningsfel p enhet "
drvlet4                 db      "X.",0

msgNetError             db      "Ntverksfel p enhet "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "Det gr inte att lsa frn enhet "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "Det gr inte att skriva till enhet "
devenam2                db      8 dup (?)
			db      0

msgNetErrorDev          db      "Ntverksfel p enhet "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "Skrivaren r inte klar",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Call to Undefined Dynalink",0
public  szFatalExit
szFatalExit     db      "Application requested abnormal termination",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Failed loading - ',0                   ; 0
	    DB  'KERNEL: Failed loading new instance of - ',0   ; 1
	    DB  'Error loading from resource file - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'FatalExit code = ',0                   ; 4
	    DB  ' stack overflow',0                             ; 5
	    DB  13,10,'Stack trace:',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit or Ignore? ',0      ; 7
	    DB  'Invalid BP chain',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  'Reentered FatalExit',7,13,10,0                 ; 10
	    DB  0
public szFKE
szFKE   DB '*** Fatal Kernel Error ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Failure code is ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Diagnostic mode startup.  Log file is:  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Undersystemet Win16 kunde inte verg i skyddat lge. DOSX.EXE mste",13,10,"finnas i  AUTOEXEC.NT och i skvgsinstllningen (PATH).",0
szMissingMod    db   "NTVDM KERNEL: 16-bitars systemmodul saknas",0
szPleaseDoIt    db   "Installera om fljande modul till system32-katalogen:",13,10,9,9,0
szInadequate    db   "KERNEL: Felaktig DPMI-server",0
szNoGlobalInit  db   "KERNEL: Det gr inte att initiera denna heap",0
NoOpenFile      db   "KERNEL: Det gr inte att ppna KERNEL.EXE",0
NoLoadHeader    db   "KERNEL: Det gr inte att lsa in huvudet (header) fr KERNEL EXE ",0
szGenBootFail   db   "KERNEL: Initieringsfel fr undersystemet Win16",0
else
szInadequate    db   'KERNEL: Felaktig DPMI-server',13,10,'$'
szNoPMode       db   'KERNEL: Det gr inte att verg i skyddat lge',13,10,'$'
szNoGlobalInit  db   "KERNEL: Det gr inte att initiera denna heap",13,10,'$'
NoOpenFile      db   "KERNEL: Det gr inte att ppna KERNEL.EXE"
		db   13, 10, '$'
NoLoadHeader    db   "KERNEL: Det gr inte att lsa in huvudet (header) fr KERNEL EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Kompatibilitetsvarning",0

msgRealModeApp1 db      "Programmet som skulle kras, ",0
msgRealModeApp2 db      ", r utvecklat fr en tidigare version av Windows.",0Dh,0Dh
	db      "Skaffa en uppdaterad version av programmet som r kompatibel "
	db      "med Windows version 3.0 och senare.",13,13
	db      "Om du trycker p OK och startar programmet, kan det leda till kompatibilitets-"
	db      "problem som kan orsaka att programmet eller Windows ovntat stngs.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\ru\strings.asm ===
TITLE   STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc              ; SHERLOCK

_DATA   SEGMENT PARA PUBLIC 'DATA'
_DATA   ENDS

DGROUP  GROUP   _DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME  DS:DGROUP


_DATA   SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public  szDiskCap
IF 0
szDiskCap       db  ' ',0
ELSE
szDiskCap       db  '    ',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public  szCannotFind1,szCannotFind2
szCannotFind1   db      "   ", 0
szCannotFind2   db      0

; This is the text for fatal errors at boot time
;       <szBootLoad>filename
public szBootLoad
szBootLoad      db      "   ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;       <szCannotFind1>filename<szInsert>

IF 0
public  szInsert
szInsert        db  ',    '
ENDIF
;public  drvlet
;drvlet         db  "X.",0

if SHERLOCK
public szGPCont         ; GP fault continuation message
szGPCont        db      "  .",10
	db      "  ,         .",10
	db      "  ,   .     .",0
endif

public  szDosVer
szDosVer        DB      '  MS-DOS.  MS-DOS 3.1    .',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "  "
		db      0
szBlame         db      "BOOT "
		db      0
szSnoozer       db      "  "
		db      0
szInModule      db      " ", 10, " <unknown>"
		db      0
szAt            db      "  "
		db      0
szNukeApp       db      ".", 10, 10, "  . "
		db      0
szWillClose     db      "  ."
		db      0
szGP            db      "  "
		db      0
szD0            db      "  "       ; not yet used
		db      0
szSF            db      "   "                ; not spec'ed
		db      0
szII            db      " "  ; "Fault" ???
		db      0
szPF            db      "  "
		db      0
szNP            db      " "
		db      0
szAF            db      " "     ; not yet used
		db      0
szLoad          db      "  "
		db      0
szOutofSelectors db     " "
		db      0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "  .",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "   ",0
						     
; This is the caption string for system error dialog boxes

public  syserr
syserr  db      " ",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public  msgWriteProtect,drvlet1
public  msgCannotReadDrv,drvlet2
public  msgCannotWriteDrv,drvlet3
public  msgShare,drvlet4
public  msgNetError,drvlet5
public  msgCannotReadDev,devenam1
public  msgCannotWriteDev,devenam2
public  msgNoPrinter
public  msgNetErrorDev,devenam3

msgWriteProtect         db      "     "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "      "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "      "
drvlet3                 db      "X.",0

msgShare                db      "     "
drvlet4                 db      "X.",0

msgNetError             db      "    "
drvlet5                 db      "X.",0

msgCannotReadDev        db      "      "
devenam1                db      8 dup (?)
			db      0

msgCannotWriteDev       db      "      "
devenam2                db      8 dup (?)
				db      0

msgNetErrorDev          db      "    "
devenam3                db      8 dup (?)
			db      0

msgNoPrinter            db      "  ",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'   = ',0
szExitStr2  DB  '  ',13,10,0
public  szUndefDyn
szUndefDyn              db      "    ",0
public  szFatalExit
szFatalExit             db      "   ",0
else
public szDebugStr
szDebugStr  DB  ':    - ',0                   ; 0
	    DB  ':      - ',0   ; 1
	    DB  '     - ',0         ; 2
	    DB  13,10,0                                         ; 3
	    DB  7,13,10,'   = ',0        ; 4
	    DB  '  ',0                         ; 5
	    DB  13,10,' :',13,10,0                    ; 6
	    DB  7,13,10,'Abort, Break, Exit  Ignore? ',0      ; 7
	    DB  '  BP',7,13,10,0                    ; 8
	    DB  ': ',0                                          ; 9
	    DB  '   ',7,13,10,0               ; 10
	    DB  0
public szFKE
szFKE   DB '***    ***',0
endif

;** Diagnostic mode messages
	public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
	public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      '   - ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      '  .   :  ', 0
endif

_DATA   ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode       db " Win16      , DOSX.EXE    AUTOEXEC.NT,     -  PATH.",0
szMissingMod    db   " NTVDM:  16-  ",0
szPleaseDoIt    db   "     SYSTEM32:",13,10,9,9,0
szInadequate    db   " NTVDM:    DPMI",0
szNoGlobalInit  db   " NTVDM:   heap-",0
NoOpenFile      db   " NTVDM:    KERNEL.EXE",0
NoLoadHeader    db   " NTVDM:    KERNEL.EXE",0
szGenBootFail   db   " NTVDM:    Win16",0
else
szInadequate    db   ':    DPMI',13,10,'$'
szNoPMode       db   ':     ',13,10,'$'
szNoGlobalInit  db   ":   heap-",13,10,'$'
NoOpenFile      db   ":    KERNEL.EXE"
		db   13, 10, '$'
NoLoadHeader    db   ":    KERNEL.EXE"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap    db      "   ",0

msgRealModeApp1 db      ",    , ",0
msgRealModeApp2 db      ",      Windows.",0Dh,0Dh
	db      "   ,  "
	db      " Windows  3.0   .",13,13
	db      "    OK   ,    "
	db      "       Windows.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\no\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\pl\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\tr\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap       db  'Diski Deitir',0
ELSE
szDiskCap       db  'Dosya Hatas',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1   db      "Bulunamyor ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad      db      "Ykleme hatas ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert        db  ', Srcye yerletirin '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont        db      "Uygulamanzda bir hata olutu.",10
        db      "Yoksay'' seerseniz almalarnz yeni bir dosyaya kaydetmelisiniz.",10
        db      "Kapat'' seerseniz uygulamanz sona erecek.",0
endif

public	szDosVer
szDosVer        DB      'Yanl MS-DOS srm.  MS-DOS 3.1 veya yukars gerekli.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption  db      "Uygulama Hatas"
		db	0
szBlame         db      "NYKLEME YAP "
		db	0
szSnoozer	db	" neden oldu "
		db	0
szInModule	db	" ", 10, "birim <bilinmiyor>"
		db	0
szAt		db	" konum "
		db	0
szNukeApp       db      ".", 10, 10, "Kapat'' sein. "
		db	0
szWillClose	db	" kapanacak."
		db	0
szGP            db      "Genel Koruma Hatas"
		db	0
szD0            db      "Sfra Blnme"        ; not yet used
		db	0
szSF            db      "Yn Hatas"          ; not spec'ed
		db	0
szII            db      "Geersiz Komut"        ; "Hatas" ???
		db	0
szPF            db      "Sayfa Hatas"
		db	0
szNP            db      "Yok Hatas"
		db	0
szAF            db      "Uygulama Hatas"       ; not yet used
		db	0
szLoad          db      "Blt Ykleme Hatas"
		db	0
szOutofSelectors db     "Seiciler Bitti"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort         db      "Geerli uygulama kapatlyor.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo          db      "Sktrlm dosyalar yklenemez",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr          db      "Sistem Hatas",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Srcde yazma korumal disk "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Srcden okunamyor "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Srcye yazlamIyor "
drvlet3                 db      "X.",0

msgShare                db      "Srcde paylam ihlali "
drvlet4                 db      "X.",0

msgNetError             db      "Srcde a hatas "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Aygttan okunamyor "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Aygta yazlamyor "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev          db      "Aygtta a hatas "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Yazc hazr deil",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Tanmsz Dynalink ars",0
public  szFatalExit
szFatalExit     db      "Uygulama anormal sonlandrma istedi",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Ykleme baarsz - ',0                   ; 0
            DB  'KERNEL: Yeni kopya ykleme baarsz - ',0   ; 1
            DB  'Kaynak dosyadan yklemede hata - ',0         ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit kodu = ',0                   ; 4
            DB  ' yn tamas',0                             ; 5
            DB  13,10,'Yn izleme:',13,10,0                    ; 6
            DB  7,13,10,'ptal et, Kes, Ik veya Yoksay? ',0      ; 7
            DB  'Geersiz BP zinciri',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Yeniden girildi FatalExit',7,13,10,0 		; 10
	    DB  0
public szFKE
szFKE   DB '*** nemli ekirdek Hatas ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Hata kodu ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Tan modu balangc.  Gnlk dosyas:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Win16 Alt sistemi KorumalI Kipe giremedi, DOSX.EXE "
          db "AUTOEXEC.NT''nizde ve YOL''unuzda olmal.",0
szMissingMod    db   "NTVDM EKRDEK: Eksik 16-bit sistem modl",0
szPleaseDoIt    db   "Aadaki modl system32 dizininize yeniden ykleyin:",13,10,9,9,0
szInadequate    db   "NTVDM EKRDEK: Yetersiz DPMI Sunucusu",0
szNoGlobalInit  db   "NTVDM EKRDEK: Kme alan hazrlanamad",0
NoOpenFile          db   "NTVDM EKRDEK: EKRDEK altrlabilir alamyor",0
NoLoadHeader    db   "NTVDM EKRDEK: EKRDEK EXE bal yklenemiyor",0
szGenBootFail   db   "NTVDM EKRDEK: Win16 Alt sistemi Balatma Hatas",0
else
szInadequate    db   'EKRDEK: Yetersiz DPMI Sunucusu',13,10,'$'
szNoPMode       db   'EKRDEK: Korumal Kipe girilemedi',13,10,'$'
szNoGlobalInit  db   "EKRDEK: Kme hazrlanamad",13,10,'$'
NoOpenFile      db   "EKRDEK: EKRDEK altrlabilir alamyor"
                db   13, 10, '$'
NoLoadHeader    db   "EKRDEK: EKRDEK EXE bal yklenemiyor"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap            db      "Uygulama Uyumluk Uyars",0

msgRealModeApp1 db      "altrmak zere olduunuz uygulama, ",0
msgRealModeApp2 db      ", Windows''un nceki bir srm iin tasarlanm.",0Dh,0Dh
        db      "Uygulamann gncelletirilmi, Windows srm 3.0 ve sonras ile "
        db      "uyumlu bir srmn edinin.",13,13
        db      "Tamam dmesini seip uygulamay balatrsanz uyumluluk sorunlar uygulamann "
        db      "veya Windows''un beklenmedik bir ekilde kapanmasna neden olabilir.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\psu\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\pt\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\messages\no\strings.asm ===
TITLE	STRINGS - OEM dependent strings used by KERNEL
include gpcont.inc		; SHERLOCK

_DATA	SEGMENT PARA PUBLIC 'DATA'
_DATA	ENDS

DGROUP	GROUP	_DATA

_INITTEXT SEGMENT WORD PUBLIC 'CODE'
_INITTEXT ENDS

_NRESTEXT SEGMENT WORD PUBLIC 'CODE'
_NRESTEXT ENDS

ASSUME	DS:DGROUP


_DATA	SEGMENT PARA PUBLIC 'DATA'

; This is the caption string for the dialog box.

public	szDiskCap
IF 0
szDiskCap	db  'Bytt diskett',0
ELSE
szDiskCap	db  'Filfeil',0
ENDIF


; This is the text for the "Cannot find xxxxxx" dialog box.
; It is printed:
;
;       <szCannotFind1>filename<szCannotFind2>

public	szCannotFind1,szCannotFind2
szCannotFind1	db	"Finner ikke ", 0
szCannotFind2	db	0

; This is the text for fatal errors at boot time
;	<szBootLoad>filename
public szBootLoad
szBootLoad	db	"Feil ved innlasting av ",0

; The following group of strings is used for the "Please insert disk with XXXX
;   in drive X:" dialog box.
;
; These two strings form the dialog message it is:
;
;	<szCannotFind1>filename<szInsert>

IF 0
public	szInsert
szInsert	db  ', sett inn i stasjon '
ENDIF
;public  drvlet
;drvlet		db  "X.",0

if SHERLOCK
public szGPCont		; GP fault continuation message
szGPCont	db	"En feil har oppsttt i programmet.",10
	db	"Hvis du velger Ignorer, br du lagre arbeidet i en ny fil.",10
	db	"Hvis du velger Lukk, vil programmet avsluttes",0
endif

public	szDosVer
szDosVer	DB	'Feil MS-DOS-versjon.  MS-DOS 3.1 eller nyere er pkrevd.',13,10,'$'
; Text for exceptions and faults lead to app termination.

public szAbortCaption,szInModule,szAt
public szNukeApp,szSnoozer,szGP,szSF,szII,szPF,szNP,szBlame,szLoad,szWillClose
public szOutofSelectors
szAbortCaption	db	"Programfeil"
		db	0
szBlame		db	"BOOT "
		db	0
szSnoozer	db	" forrsaket "
		db	0
szInModule	db	" i", 10, "modul <ukjent>"
		db	0
szAt		db	", adresse: "
		db	0
szNukeApp	db	".", 10, 10, "Velg Lukk. "
		db	0
szWillClose	db	" vil avsluttes."
		db	0
szGP		db	"en generell beskyttelsesfeil"
		db	0
szD0		db	"en divisjon med null"	; not yet used
		db	0
szSF		db	"en stakkfeil"		; not spec'ed
		db	0
szII		db	"en ugyldig instruksjon"	; "Fault" ???
		db	0
szPF		db	"en sidefeil"
		db	0
szNP		db	"en feil fordi ressursen ikke fantes"
		db	0
szAF		db	"en programfeil"	; not yet used
		db	0
szLoad		db	"Feil under innlasting av segment"
		db	0
szOutofSelectors db	"Ingen flere selektorer"
		db	0

; Text for dialog box when terminating an application

public szAbort
szAbort 	db	"Lukker gjeldende program.",0

; Text for dialog box when trying to run a compressed file
			   
public szBozo
szBozo  	db	"Kan ikke laste inn komprimerte filer",0
			 	     		     
; This is the caption string for system error dialog boxes

public	syserr
syserr		db	"Systemfeil",0

; The following group of messages forms all of the messages used
; in the INT 24 dialog box.
;
; There are 7 messages which can be translated individually. The
; location of drvlet? and devenam? can be moved to any location
; within the string.

public	msgWriteProtect,drvlet1
public	msgCannotReadDrv,drvlet2
public	msgCannotWriteDrv,drvlet3
public	msgShare,drvlet4
public	msgNetError,drvlet5
public	msgCannotReadDev,devenam1
public	msgCannotWriteDev,devenam2
public	msgNoPrinter
public	msgNetErrorDev,devenam3

msgWriteProtect         db      "Skrivebeskyttet disk i stasjon "
drvlet1                 db      "X.",0

msgCannotReadDrv        db      "Kan ikke lese fra stasjon "
drvlet2                 db      "X.",0

msgCannotWriteDrv       db      "Kan ikke skrive til stasjon "
drvlet3                 db      "X.",0

msgShare		db	"Brudd p deletillatelser p stasjon "
drvlet4                 db      "X.",0

msgNetError		db	"Nettverksfeil p stasjon "
drvlet5 		db	"X.",0

msgCannotReadDev        db      "Kan ikke lese fra enhet "
devenam1                db      8 dup (?)
                        db      0

msgCannotWriteDev       db      "Kan ikke skrive til enhet "
devenam2                db      8 dup (?)
			db	0

msgNetErrorDev		db	"Nettverksfeil p enhet "
devenam3		db	8 dup (?)
			db	0

msgNoPrinter            db      "Skriveren er ikke klar",0


ifndef WINDEBUG
public szExitStr1,szExitStr2
szExitStr1  DB  7,13,10,'FatalExit code = ',0
szExitStr2  DB  ' stack overflow',13,10,0
public  szUndefDyn
szUndefDyn      db      "Kall til udefinert Dynalink",0
public  szFatalExit
szFatalExit	db	"Programmet forespurte en unormal avslutning",0
else
public szDebugStr
szDebugStr  DB  'KERNEL: Feil under lasting - ',0               ; 0
            DB  'KERNEL: Feil under lasting av ny - ',0         ; 1
            DB  'Feil ved lasting fra ressursfil - ',0          ; 2
            DB  13,10,0                                         ; 3
            DB  7,13,10,'FatalExit kode = ',0                   ; 4
            DB  ' stakkoverflyt',0                              ; 5
            DB  13,10,'Stakksporing:',13,10,0                   ; 6
	    DB  7,13,10,'Avbryt, Stopp, Avslutt eller Ignorer? ',0; 7
            DB  'Ugyldig PB-kjede',7,13,10,0                    ; 8
	    DB	': ',0						; 9
	    DB	'Gikk inn i FatalExit p nytt',7,13,10,0	; 10
	    DB  0
public szFKE
szFKE	DB '*** Kritisk Kernel-feil ***',0
endif

;** Diagnostic mode messages
        public szDiagStart, szCRLF, szLoadStart, szLoadSuccess, szLoadFail
        public szFailCode, szCodeString
szDiagStart     db      '[boot]'      ;lpCRLF must follow
szCRLF          db      0dh, 0ah, 0
szLoadStart     db      'LoadStart = ',0
szLoadSuccess   db      'LoadSuccess = ', 0
szLoadFail      db      'LoadFail = ', 0
szFailCode      db      ' Feilkode er ' ;szCodeString must follow
szCodeString    db      '00', 0dh, 0ah, 0
ifdef WINDEBUG
	public szInitSpew
szInitSpew      DB      'Oppstart i diagnostisk modus. Loggfilen er:  ', 0
endif

_DATA	ENDS


_INITTEXT SEGMENT WORD PUBLIC 'CODE'
public szInadequate, szNoPMode, szNoGlobalInit
public NoOpenFile, NoLoadHeader, szMissingMod, szPleaseDoIt

ifdef WOW
public szGenBootFail
szNoPMode db "Win16-delsystemet kan ikke g inn i beskyttet modus, Dosx.exe m finnes i Autoexec.nt og finnes i PATH-setningen.",0
szMissingMod    db   "NTVDM-kjerne: Manglende 16-biters systemmodul",0
szPleaseDoIt    db   "Installer flgende modul p nytt i system32-katalogen:",13,10,9,9,0
szInadequate	db   "NTVDM-kjerne: Inadekvat DPMI-server",0
szNoGlobalInit	db   "NTVDM-kjerne: Kan ikke initialisere heap",0
NoOpenFile	db   "NTVDM-kjerne: Kan ikke pne den kjrbare filen KERNEL",0
NoLoadHeader	db   "NTVDM-kjerne: Kan ikke laste KERNEL EXE-filhodet",0
szGenBootFail	db   "NTVDM-kjerne: Feil under initialisering av Win16-delsystemet",0
else
szInadequate	db   'Kjerne: Inadekvat DPMI-server',13,10,'$'
szNoPMode	db   'Kjerne: Kan ikke starte beskyttet modus',13,10,'$'
szNoGlobalInit	db   "Kjerne: Kan ikke initialisere heap",13,10,'$'
NoOpenFile      db   "Kjerne: Kan ikke pne den kjrbare filen KERNEL"
                db   13, 10, '$'
NoLoadHeader    db   "Kjerne: Kan ikke laste inn KERNEL EXE-filhodet"
		db   13, 10, '$'
endif

_INITTEXT ENDS




_NRESTEXT SEGMENT WORD PUBLIC 'CODE'

; This is the caption string for the protect mode dialog box.
;
; DO NOT CHANGE THE LENGTH OF THIS MESSAGE
;

public szProtectCap,msgRealModeApp1,msgRealModeApp2

szProtectCap		db	"Advarsel om programkompatibilitet",0

msgRealModeApp1 db	"Programmet du vil kjre, ",0
msgRealModeApp2 db	", ble laget for en tidligere versjon av Windows.",0Dh,0Dh
	db	"Skaff en oppdatert versjon av programmet som er kompatibel "
	db	"med Windows versjon 3.0 eller nyere.",13,13
	db	"Hvis du velger OK og starter programmet, kan det oppst "
	db	"kompatibilitetsproblemer som forrsaker at Windows avslutter uventet.",0

_NRESTEXT ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\sv\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\ru\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\tr\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB -DDBCS -DJAPAN -DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\tst\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET)  \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\killwow\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\killwow\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\chp\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\cht\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DTAIWAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\chs\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd ..
    nmake  /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DPRC"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\kor\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DKOREA"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\jpn\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DDBCS -DJAPAN"       
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\lib\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DFE_SB" 
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\killwow\killwow.c ===
/****************************************************************************

	PROGRAM: KillWOW.c

	PURPOSE: KillWOW Close WOW

	COMMENTS:
		 This app will NUKE WOW if it is able to run


****************************************************************************/

#include <windows.h>		/* required for all Windows applications */

HANDLE hInst;	/* current instance */

/****************************************************************************

	FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

	PURPOSE: calls initialization function, processes message loop

	COMMENTS:


****************************************************************************/

int PASCAL WinMain(HANDLE hInstance, HANDLE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
        ExitKernelThunk(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\kernel31\swappro\swap.c ===
/* Chris Peters
 * CHANGED:	Fritz Knabe, 7/28/87
 *		mikedr, 8/8/88 - read offset bytes after 0xff seg no on swap
 *				 allow specification of data file location
 *    c-chrisc [Christine Comaford], 10/31/89 - added "-i" flag to 
 *            allow symbol file path spec on command line, added "-m" 
 *            flag to precede module spec, rewrote module parser,
 *            added usage display, misc other enhancements.
 *
 * Copyright Microsoft Corporation, 1985-1990
 */

#include <string.h>
#include <stdio.h>
#include <ctype.h>
#include <assert.h>
#include <memory.h>
#include <malloc.h>
#include <stdlib.h>

/* standard stuff */
typedef unsigned char BYTE;
typedef unsigned short	WORD;
typedef unsigned long  DWORD;
typedef int BOOL;
#define TRUE 1
#define FALSE 0

BOOL FModuleMatch(BYTE *, BYTE);
int GetSymbolString(BYTE *, BYTE *, WORD, WORD);
int GetSegNum(char *, char *);
BYTE *htoa(BYTE *, WORD);
char *ProcessArguments(int, char **);

/* Debug Symbol Table Structures
   -----------------------------
For each symbol table (map): (MAPDEF)
-------------------------------------------------------------------------------------------------
| map_ptr | lsa | pgm_ent | abs_cnt | abs_ptr | seg_cnt | seg_ptr | nam_max | nam_len | name... |
------------------------------------------------------------------------------------------------- */
struct  mapdef
{
	unsigned    map_ptr;    /* 16 bit ptr to next map (0 if end)    */
	unsigned    lsa    ;    /* 16 bit Load Segment address          */
	unsigned    pgm_ent;    /* 16 bit entry point segment value     */
	int         abs_cnt;    /* 16 bit count of constants in map     */
	unsigned    abs_ptr;    /* 16 bit ptr to   constant chain       */
	int         seg_cnt;    /* 16 bit count of segments in map      */
	unsigned    seg_ptr;    /* 16 bit ptr to   segment chain        */
	char        nam_max;    /*  8 bit Maximum Symbol name length    */
	char        nam_len;    /*  8 bit Symbol table name length      */
};

struct  mapend
{
	unsigned        chnend;         /* end of map chain (0) */
	char            rel;            /* release              */
	char            ver;            /* version              */
};

/* For each segment/group within a symbol table: (SEGDEF)
--------------------------------------------------------------
| nxt_seg | sym_cnt | sym_ptr | seg_lsa | name_len | name... |
-------------------------------------------------------------- */
struct  segdef
{
	unsigned    nxt_seg;    /* 16 bit ptr to next segment(0 if end) */
	int         sym_cnt;    /* 16 bit count of symbols in sym list  */
	unsigned    sym_ptr;    /* 16 bit ptr to symbol list            */
	unsigned    seg_lsa;    /* 16 bit Load Segment address          */
	unsigned    seg_in0;    /* 16 bit instance 0 physical address   */
	unsigned    seg_in1;    /* 16 bit instance 1 physical address   */
	unsigned    seg_in2;    /* 16 bit instance 2 physical address   */
	unsigned    seg_in3;    /* 16 bit instance 3 physical address   */
	unsigned    seg_lin;    /* 16 bit ptr to line number record     */
	char        seg_ldd;    /*  8 bit boolean 0 if seg not loaded   */
	char        seg_cin;    /*  8 bit current instance              */
	char        nam_len;    /*  8 bit Segment name length           */
};

/*  Followed by a list of SYMDEF's..
    for each symbol within a segment/group: (SYMDEF)
-------------------------------
| sym_val | nam_len | name... |
------------------------------- */
struct  symdef
{
	unsigned    sym_val;    /* 16 bit symbol addr or const          */
	char        nam_len;    /*  8 bit symbol name length            */
};

typedef struct tagMODSEG		/* Structure for saving information */
{					/* about cmd line arguments */
	int segno;	/* Special values:
			   -1	information about all segments in the module
				is supplied
			   -2	an invalid segment name was supplied, i.e.
				nothing matches this record/argument
			   >=0	valid segment number
			*/
	char szModule[32];	/* Name of module */
} MODSEG, *PMODSEG;


/*----------------------------------------------------------------------------
|	Global Variables
|
----------------------------------------------------------------------------*/

#define MAX_ARGS  34		      /* arbitrary (but reasonable) values */
#define MAX_PATHS	16

char curpath_buffer[65];      /* buffer holding current sym file path */
char path_buffer[132];        /* buffer holding cmd line sym path string */
char *path_table[MAX_PATHS];  /* table of sym file buffers */

int  num_paths = 0;           /* index into path_table[] */
int nNumArgs;		            /* Number of command line arguments */

char *ModSegTab[MAX_ARGS];	   /* Table of MODSEG records */

BOOL bModule = FALSE;   /* is module specified on command line? */
BOOL bSymPath = FALSE;  /* is symbol file path specified on command line? */

int  num_mods = 0;      /* index into module table */


char usage[] = "\nUSAGE: SWAP [-Ipath1;path2;...] [-Fswapfile] [-Mmod1[:seg];mod2[:seg];...]\n\n"
	       "      -Ipath1;path2;...           -- Path list for .SYM files.\n\n"
	       "      -Fswapfile                  -- Name and path of swap file,\n"
          "                                     default: swappro.dat.\n\n"
	       "      -Mmod1[:seg];mod2[:seg];... -- Name of module or module:segment\n"
          "                                     pairs to return swap data for.\n";


/*----------------------------------------------------------------------------
|	Main Program
|
|
----------------------------------------------------------------------------*/

/* Structure of swappro.dat records:
	BYTE type;	0 = Call, 1 = Swap, 2 = Discard, 3 = Return
	WORD time;
	BYTE nam_len;	Length of following name (not null terminated)
	BYTE name[];
	BYTE segno;	This is the end of the record for DISCARD records
			or resources (segno == 0xFF)
	WORD offset;	This is the end of the record for types 2 and 3
	BYTE nam2_len;	If 0, the next field missing, and the name is the
			same as the previous one
	BYTE name2[];
	BYTE segno2;
	BYTE offset2;
*/


main(argc, argv)
int argc;
char *argv[];
{
	register FILE *pfIn;
	BYTE rgch1[256];
	BYTE rgch2[256];
	register BYTE stModule[32], stModule2[32];
	BYTE rt;
	BYTE cch;
	WORD t;
	WORD segno = 0, segno2 = 0;
	WORD offset, offset2;
	BOOL fFirst = TRUE;
	long time, timePrev, timeBase;
	char *filepath;


   /* sign on */

   printf("Microsoft (R) Swap File Analyzer  Version 3.00\n");
   printf("Copyright (C) Microsoft Corp 1990.  All rights reserved.\n\n");

	filepath = ProcessArguments(argc, argv);
	if (filepath == NULL)
		filepath = "swappro.dat";

	pfIn = fopen(filepath,"rb");
	if (pfIn == NULL)
	{
		printf("\nFile %s not found.\n",filepath);
		exit(2);
	}

	printf("\nType\tTime\tSegment\tOffset\tSegment\tOffset");
	printf("\n----\t----\t-------\t------\t-------\t------");

	while(!feof(pfIn))
	{
		fread(&rt, 1, 1, pfIn); 	/* Get the record type */

		timePrev = time;
		fread(&t, 2, 1, pfIn);		/* Get the time */
		time = t;
		if (fFirst)
		{
			timePrev = 0;
			timeBase = time;
			fFirst = FALSE;
		}
		time -= timeBase;
		if (time < timePrev)
		{
			time += 65536;
			timeBase -= 65536;
		}

		switch (rt)
		{
		default:
			printf("\n **** Invalid swap record ****");
			break;

		case 0:			/* Call */
		case 1:			/* Swap */
			fread(stModule, 1, 1, pfIn);
			fread(stModule+1, 1, stModule[0], pfIn);
			fread(&segno, 1, 1, pfIn);
			if (segno != 0xFF)
				fread(&offset, 2, 1, pfIn);

			else	/* We have a RESOURCE, so we don't fread */
				offset = 0xFFFF;

			fread(stModule2, 1, 1, pfIn);
				/* Check if this module name is the same as
				   stModule */
			if (stModule2[0])
				fread(stModule2+1, 1, stModule2[0], pfIn);
			else
				memcpy(stModule2, stModule, 1 + stModule[0]);

			/* read segment and offset */
			fread(&segno2, 1, 1, pfIn);
			fread(&offset2, 2, 1, pfIn);
			if (segno2 == 0xFF)
				offset2 = 0xFFFF;

         if (bModule)
         {

   			if (!FModuleMatch(stModule, segno) &&
	   			!FModuleMatch(stModule2, segno2))
		   			break;
         }

			GetSymbolString(rgch1, stModule, segno, offset);
			GetSymbolString(rgch2, stModule2, segno2, offset2);

			if (rt == 1)
				printf("\nSwap");
			else
				printf("\nCall");
			printf("\t%ld\t%s\t%s",time, rgch1, rgch2);
			break;

		case 2:			/* Discard */
		case 3:			/* Return */
			fread(stModule, 1, 1, pfIn);
			fread(stModule+1, 1, stModule[0], pfIn);
			fread(&segno, 1, 1, pfIn);
			if (rt == 2 || segno == 0xFF)
				offset = 0xFFFF;
			else
					/* Only read offset if not a DISCARD
					   record or a resource */
				fread(&offset, 2, 1, pfIn);


         if (bModule)
         {

   			if (!FModuleMatch(stModule, segno))
	   			break;

         }

			GetSymbolString(rgch1, stModule, segno, offset);
			if (rt == 2)
				printf("\nDiscard");
			else
				printf("\nReturn");
			printf("\t%ld\t%s",time,rgch1);
			break;
		}
	}
}


/* returns pointer to swap data file name, NULL if none given */
char *ProcessArguments(argc, argv)
int argc;
char *argv[];
{
	PMODSEG pms;
	int i,j;
	int nArgSep = 0;
	int n = 0;
	char *filepath = NULL;
	char *curpath;
	char ch;
	char *opt;
   char module_buffer[132];
   char *curmodule;
   
   #define MAX_MODULES 20
   char *module_table[MAX_MODULES];


	nNumArgs = (int) min(argc,MAX_ARGS);

	if (nNumArgs < 2)	/* No arguments */
		return(filepath);

	for (i = 1; i < argc; i++)
	{
		if ((*argv[i] == '-' || *argv[i] == '/')) 
		{
			ch = tolower(argv[i][1]);

			switch (ch) {

				case 'f':
					/* create swap data file spec */
					filepath = &argv[i][2];  /* first char past flag */
					if (!*filepath) 	 /* skip white space */
					{
						i++;	      /* adjust command line variables */
						nNumArgs--;
						filepath = argv[i]; /* get file name from next arg */
					}

					nNumArgs--;
					break;
	
				case 'i':
               bSymPath = TRUE;

               /* place the current directory at the head of the symbol 
                  table path */
               getcwd(curpath_buffer, 132);
               path_table[num_paths++] = curpath_buffer;

					/* create symbol file spec */
					strcpy(path_buffer, &argv[i][2]); 

					if (!*path_buffer)
					{
						/* space after flag, so increment index */
						i++;	      

						/* adjust command line arg count */
						nNumArgs--;

						/* get all symbol file path names from next arg */
						strcpy (path_buffer, argv[i]);  
					}

	   		   strcat(path_buffer, ";");

	      		curpath = strtok(path_buffer, ";");

	       		do {
	         		 path_table[num_paths++] = curpath;
	      	 		 } while (curpath = strtok(NULL, ";"));

	       		break;
		      

            case 'm':

               /* create module and/or module:_segment file spec */

               bModule = TRUE;
                     
               strcpy(module_buffer, &argv[i][2]);
                     
               if (!*module_buffer)
               {
                  i++;
                  nNumArgs--;
                  strcpy(module_buffer, argv[i]);
                     
               }
                  
	   		   strcat(module_buffer, ";");

               /* fill module table with mod names */
	      		curmodule = strtok(module_buffer, ";");

	       		do {
	         		 module_table[num_mods++] = curmodule;
	      	 		 } while (curmodule = strtok(NULL, ";"));


               /* for each module, assign segno if applicable */
               for (j = 0; j < num_mods; j++)
               {
            		if (!(pms = (PMODSEG) malloc(sizeof(MODSEG))))
                  {
                     printf ("MEMORY ALLOCATION FAILED!!!!");
                     exit (1);
                  }
               
                  /* determine whether a segment has been specified
                     (i.e., GDI:_FONTRES), look for a ':' */

              		nArgSep = strcspn(module_table[j], ":");
                  strncpy(pms->szModule, module_table[j], nArgSep);

   		         pms->szModule[nArgSep] = '\0';

		            /* Get segment number */

   	   		   /* First case: no segment specified; e.g. format of
   			         arg would be "user" */
            		if (nArgSep == strlen(module_table[j]) || 
                           module_table[j][nArgSep+1] == '\0')
            			pms->segno = -1;

      	   		/* Second case: decimal segment number supplied; e.g.
   			         "user:10" */
         		   else if (isdigit(module_table[j][nArgSep+1]))
         			   pms->segno = atoi(module_table[j]+nArgSep+1);

         			/* Third case: the segment name is "resource" */
            		else if (strcmpi(module_table[j]+nArgSep+1, "RESOURCE") == 0)
            			pms->segno = 0xFF;

            		/* Fourth case: a segment name is supplied; get
                     it's number */
         	   	else
                  {
         		   	pms->segno = GetSegNum(pms->szModule, 
                                          module_table[j]+nArgSep+1);
   
                  }

            		ModSegTab[n++] = (char *) pms;

               }
               break;

            default:

               /* Display cmd line args and quit */
            	fprintf(stderr, usage);
               exit(1);
			}			

		}

	}

	return(filepath);
}



/* Determines whether module specified on command line is equal to
current module read in.  No called if no mod, mod/seg is specified on
command line.  If false is returned, record won't be displayed. */

BOOL FModuleMatch(stModule, segno)
register BYTE stModule[];
BYTE segno;
{
	register int i;
	PMODSEG pms;


	if (nNumArgs < 2)
		return TRUE;

	stModule[stModule[0]+1] = '\0';

	for (i = 0; i < num_mods; i++)
	{
		pms = (PMODSEG) ModSegTab[i];

		if (strcmpi(stModule+1, pms->szModule) == 0 &&
			(pms->segno == -1 || pms->segno == segno))
				return(TRUE);
	}
	return(FALSE);
}


int GetSegNum(szModule, szSegment)
char *szModule;
char *szSegment;
{
/* Gets the number of the named segment in the named module, if it exists.
   This is a "stripped" version of GetSymbolString. */

	char buf[50];
	FILE *pfSym;
	struct mapdef MAPDEF;
	struct mapend MAPEND;
	struct segdef SEGDEF;
	WORD seg_ptr, fstseg_ptr;
	int i;
   register int pathcnt;
   char symfile[65];


	strcpy(symfile, szModule);
	strcat(symfile, ".SYM");


   if (bSymPath)
   {
      /* Loop through all symbol file paths until file is found */

      for (pathcnt=0; pathcnt <num_paths; pathcnt++) 
      {
         strcpy(buf, path_table[pathcnt]);
         strcat(buf, "\\");
         strcat(buf, symfile);

         if (pfSym = fopen(buf, "rb"))
            break;
      }
   }
   else
      pfSym = fopen(symfile, "rb");

	if (!pfSym)
		return -1;

	fread(&MAPDEF, 1, sizeof(MAPDEF), pfSym);
	fstseg_ptr = seg_ptr = (WORD)MAPDEF.seg_ptr;
	fseek(pfSym, (long)-sizeof(MAPEND), 2);
	fread(&MAPEND, 1, sizeof(MAPEND), pfSym);
	if (MAPEND.ver != 3)
	{
		fclose(pfSym);
		return -1;
	}
	i = 0;
	do
	{
		if (MAPEND.rel >= 10)
			fseek(pfSym, (long)(seg_ptr * 16), 0);
		else
			fseek(pfSym, (long)seg_ptr, 0);
		fread(&SEGDEF, 1, sizeof(SEGDEF), pfSym);
		seg_ptr = (WORD)SEGDEF.nxt_seg;
		fread(buf, 1, SEGDEF.nam_len, pfSym);
		buf[SEGDEF.nam_len] = '\0';
		if (strcmpi(buf, szSegment) == 0)
		{
			fclose(pfSym);
			return i;
		}
		i++;
	}
	while (seg_ptr && seg_ptr != fstseg_ptr);
	fclose(pfSym);
	return -2;
}


int GetSymbolString(pchOut, stModule, segno, offset)
BYTE *pchOut;			/* output buffer       */
BYTE stModule[];		/* module name	       */
WORD segno;			/* segment number      */
WORD offset;			/* offset into segment */
{
	int cch;
	register int i;
	register BYTE *pch;
	FILE *pfSym;
	WORD seg_ptr;
	long symPos1, symPos2;
	struct mapdef MAPDEF;
	struct mapend MAPEND;
	struct segdef SEGDEF;
	struct symdef SYMDEF;
	BYTE *htoa();
   register int pathcnt;
   char symfile[65];
   int len;


	pch = stModule;
   
	cch = *pch++;
	pch = (BYTE *) memcpy(pchOut, pch, cch) + cch;

   if((len = strlen(pchOut)) < 2)
      return (-1);


	pch[0] = '.';
	pch[1] = 'S';
	pch[2] = 'Y';
	pch[3] = 'M';
	pch[4] = 0;

   if (bSymPath) 
   {
      for (pathcnt=0; pathcnt <num_paths; pathcnt++) 
      {
         strcpy(symfile, path_table[pathcnt]);
         strcat(symfile, "\\");
         strcat(symfile, pchOut);

         if (pfSym = fopen(symfile, "rb"))
            break;
      }
   }
   else
      	pfSym = fopen(pchOut, "rb");


	/* If symbol file not found, insert/append () around name */
	if (pfSym == NULL)
	{
		pch = stModule;
		cch = *pch++;
		pch = (BYTE *) memcpy(pchOut+1, pch, cch) + cch;
		*pchOut = '(';
		*pch++ = ')';
		if (offset != 0xFFFF)
			*pch++ = '\t';
		*pch = 0;
		return(-1);
	}

	fread(&MAPDEF, 1, sizeof(MAPDEF), pfSym);

	*pch++ = '!';
	if (segno == 0xFF)
	{
		*pch++ = 'R';
		*pch++ = 'E';
		*pch++ = 'S';
		*pch++ = 'O';
		*pch++ = 'U';
		*pch++ = 'R';
		*pch++ = 'C';
		*pch++ = 'E';
		*pch = 0;
		fclose(pfSym);
		return(1);
	}

	if (segno >= MAPDEF.seg_cnt)
		goto lbNoSeg;

	seg_ptr = (WORD)MAPDEF.seg_ptr;
	fseek(pfSym, (long)-sizeof(MAPEND), 2);
	fread(&MAPEND, 1, sizeof(MAPEND), pfSym);
	if (MAPEND.ver != 3)
	{

lbNoSeg:
		pch = htoa(pch, segno);
		*pch = 0;
		if (offset != 0xFFFF)
		{
			*pch++ = '\t';
			pch = htoa(pch, offset);
			*pch = 0;
		}
		fclose(pfSym);
		return(-2);
	}
	i = segno+1;
	while (i--)
	{
		if (MAPEND.rel >= 10)
			fseek(pfSym, (long)(seg_ptr * 16), 0);
		else
			fseek(pfSym, (long)seg_ptr, 0);
		fread(&SEGDEF, 1, sizeof(SEGDEF), pfSym);
		seg_ptr = (WORD)SEGDEF.nxt_seg;
	}
	fread(pch, 1, (int)((BYTE)SEGDEF.nam_len), pfSym);

	pch += SEGDEF.nam_len;
	*pch = 0;
	if (offset == 0xFFFF)
	{
		fclose(pfSym);
		return(1);
	}
	*pch++ = '\t';

	i = (WORD)SEGDEF.sym_cnt;
	if (i == 0)
		goto lbNoSym;
	symPos1 = 0;
	while (i--)
	{
		symPos2 = symPos1;
		symPos1 = ftell(pfSym);
		fread(&SYMDEF, 1, sizeof(SYMDEF), pfSym);
		if (i == 0 || (WORD)SYMDEF.sym_val > offset)
		{
			if ((WORD)SYMDEF.sym_val > offset)
			{
				if (symPos2 == 0)
					goto lbNoSym;
				fseek(pfSym, (long)symPos2, 0);
				fread(&SYMDEF, 1, sizeof(SYMDEF), pfSym);
			}
			fread(pch, 1, (int)((BYTE)SYMDEF.nam_len), pfSym);
			pch += SYMDEF.nam_len;
			if ((WORD)SYMDEF.sym_val < offset)
			{
				*pch++ = '+';
				pch = htoa(pch, offset - SYMDEF.sym_val);
			}
			*pch = 0;
			fclose(pfSym);
			return(1);
		}
		fseek(pfSym, (long)((BYTE)SYMDEF.nam_len), 1);
	}
lbNoSym:
	pch = htoa(pch, offset);
	*pch = 0;
	fclose(pfSym);
	return(0);
}

BYTE *htoa( s, w )		/* Hexadecimal to ASCII */
register BYTE *s;
WORD w;
{
	register int i;
	char c;

	i = 4;
	s += i;
	while (i--)
	{
		c = (char)(w & (WORD)0xF);
		w >>= 4;
		if (c > 9)
			c += 'A' - 10;
		else
			c += '0';
		*--s = c;
	}

	return s+4;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\ole.h ===
/*****************************************************************************\
*                                                                             *
* ole.h -       Object Linking and Embedding functions, types, and definitions*
*                                                                             *
*               Version 1.0                                                   *
*                                                                             *
*               NOTE: windows.h must be #included first                       *
*                                                                             *
*               Copyright (c) 1990-1992, Microsoft Corp.  All rights reserved.*
*                                                                             *
\*****************************************************************************/

#ifndef _INC_OLE
#define _INC_OLE

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#ifndef WINAPI          /* If not included with 3.1 headers... */
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL
#define LPCSTR      LPSTR
#define UINT        WORD
#define LPARAM      LONG
#define WPARAM      WORD
#define LRESULT     LONG
#define HMODULE     HANDLE
#define HINSTANCE   HANDLE
#define HLOCAL      HANDLE
#define HGLOBAL     HANDLE
#endif  /* _INC_WINDOWS */

#ifdef STRICT
#define OLE_LPCSTR  LPCSTR
#define OLE_CONST   const
#else   /* STRICT */
#define OLE_LPCSTR  LPSTR
#define OLE_CONST
#endif /* !STRICT */


/* Object types */
#define OT_LINK             1L
#define OT_EMBEDDED         2L
#define OT_STATIC           3L

/* activate verbs */
#define OLEVERB_PRIMARY     0

/* target device info structure */
typedef struct _OLETARGETDEVICE
{
    UINT otdDeviceNameOffset;
    UINT otdDriverNameOffset;
    UINT otdPortNameOffset;
    UINT otdExtDevmodeOffset;
    UINT otdExtDevmodeSize;
    UINT otdEnvironmentOffset;
    UINT otdEnvironmentSize;
    BYTE otdData[1];
} OLETARGETDEVICE;
typedef OLETARGETDEVICE FAR* LPOLETARGETDEVICE;

/* flags used in some methods */
#define OF_SET              0x0001
#define OF_GET              0x0002
#define OF_HANDLER          0x0004

/* return codes for OLE functions */
typedef enum
{
    OLE_OK,                     /* 0   Function operated correctly             */

    OLE_WAIT_FOR_RELEASE,       /* 1   Command has been initiated, client      */
                                /*     must wait for release. keep dispatching */
                                /*     messages till OLE_RELESE in callback    */

    OLE_BUSY,                   /* 2   Tried to execute a method while another */
                                /*     method is in progress.                  */

    OLE_ERROR_PROTECT_ONLY,     /* 3   Ole APIs are called in real mode        */
    OLE_ERROR_MEMORY,           /* 4   Could not alloc or lock memory          */
    OLE_ERROR_STREAM,           /* 5  (OLESTREAM) stream error                 */
    OLE_ERROR_STATIC,           /* 6   Non static object expected              */
    OLE_ERROR_BLANK,            /* 7   Critical data missing                   */
    OLE_ERROR_DRAW,             /* 8   Error while drawing                     */
    OLE_ERROR_METAFILE,         /* 9   Invalid metafile                        */
    OLE_ERROR_ABORT,            /* 10  Client chose to abort metafile drawing  */
    OLE_ERROR_CLIPBOARD,        /* 11  Failed to get/set clipboard data        */
    OLE_ERROR_FORMAT,           /* 12  Requested format is not available       */
    OLE_ERROR_OBJECT,           /* 13  Not a valid object                      */
    OLE_ERROR_OPTION,           /* 14  Invalid option(link update / render)    */
    OLE_ERROR_PROTOCOL,         /* 15  Invalid protocol                        */
    OLE_ERROR_ADDRESS,          /* 16  One of the pointers is invalid          */
    OLE_ERROR_NOT_EQUAL,        /* 17  Objects are not equal                   */
    OLE_ERROR_HANDLE,           /* 18  Invalid handle encountered              */
    OLE_ERROR_GENERIC,          /* 19  Some general error                      */
    OLE_ERROR_CLASS,            /* 20  Invalid class                           */
    OLE_ERROR_SYNTAX,           /* 21  Command syntax is invalid               */
    OLE_ERROR_DATATYPE,         /* 22  Data format is not supported            */
    OLE_ERROR_PALETTE,          /* 23  Invalid color palette                   */
    OLE_ERROR_NOT_LINK,         /* 24  Not a linked object                     */
    OLE_ERROR_NOT_EMPTY,        /* 25  Client doc contains objects.            */
    OLE_ERROR_SIZE,             /* 26  Incorrect buffer size passed to the api */
                                /*     that places some string in caller's     */
                                /*     buffer                                  */

    OLE_ERROR_DRIVE,            /* 27  Drive letter in doc name is invalid     */
    OLE_ERROR_NETWORK,          /* 28  Failed to establish connection to a     */
                                /*     network share on which the document     */
                                /*     is located                              */

    OLE_ERROR_NAME,             /* 29  Invalid name(doc name, object name),    */
                                /*     etc.. passed to the APIs                */

    OLE_ERROR_TEMPLATE,         /* 30  Server failed to load template          */
    OLE_ERROR_NEW,              /* 31  Server failed to create new doc         */
    OLE_ERROR_EDIT,             /* 32  Server failed to create embedded        */
                                /*     instance                                */
    OLE_ERROR_OPEN,             /* 33  Server failed to open document,         */
                                /*     possible invalid link                   */

    OLE_ERROR_NOT_OPEN,         /* 34  Object is not open for editing          */
    OLE_ERROR_LAUNCH,           /* 35  Failed to launch server                 */
    OLE_ERROR_COMM,             /* 36  Failed to communicate with server       */
    OLE_ERROR_TERMINATE,        /* 37  Error in termination                    */
    OLE_ERROR_COMMAND,          /* 38  Error in execute                        */
    OLE_ERROR_SHOW,             /* 39  Error in show                           */
    OLE_ERROR_DOVERB,           /* 40  Error in sending do verb, or invalid    */
                                /*     verb                                    */
    OLE_ERROR_ADVISE_NATIVE,    /* 41  Item could be missing                   */
    OLE_ERROR_ADVISE_PICT,      /* 42  Item could be missing or server doesn't */
                                /*     this format.                            */

    OLE_ERROR_ADVISE_RENAME,    /* 43  Server doesn't support rename           */
    OLE_ERROR_POKE_NATIVE,      /* 44  Failure of poking native data to server */
    OLE_ERROR_REQUEST_NATIVE,   /* 45  Server failed to render native data     */
    OLE_ERROR_REQUEST_PICT,     /* 46  Server failed to render presentation    */
                                /*     data                                    */
    OLE_ERROR_SERVER_BLOCKED,   /* 47  Trying to block a blocked server or     */
                                /*     trying to revoke a blocked server       */
                                /*     or document                             */

    OLE_ERROR_REGISTRATION,     /* 48  Server is not registered in regestation */
                                /*     data base                               */
    OLE_ERROR_ALREADY_REGISTERED,/*49  Trying to register same doc multiple    */
                                 /*    times                                   */
    OLE_ERROR_TASK,             /* 50  Server or client task is invalid        */
    OLE_ERROR_OUTOFDATE,        /* 51  Object is out of date                   */
    OLE_ERROR_CANT_UPDATE_CLIENT,/* 52 Embed doc's client doesn't accept       */
                                /*     updates                                 */
    OLE_ERROR_UPDATE,           /* 53  erorr while trying to update            */
    OLE_ERROR_SETDATA_FORMAT,   /* 54  Server app doesn't understand the       */
                                /*     format given to its SetData method      */
    OLE_ERROR_STATIC_FROM_OTHER_OS,/* 55 trying to load a static object created */
                                   /*    on another Operating System           */

    /*  Following are warnings */
    OLE_WARN_DELETE_DATA = 1000 /*     Caller must delete the data when he is  */
                                /*     done with it.                           */
} OLESTATUS;



/* Codes for CallBack events */
typedef enum
{
    OLE_CHANGED,            /* 0                                             */
    OLE_SAVED,              /* 1                                             */
    OLE_CLOSED,             /* 2                                             */
    OLE_RENAMED,            /* 3                                             */
    OLE_QUERY_PAINT,        /* 4  Interruptible paint support                */
    OLE_RELEASE,            /* 5  Object is released(asynchronous operation  */
                            /*    is completed)                              */
    OLE_QUERY_RETRY         /* 6  Query for retry when server sends busy ACK */
} OLE_NOTIFICATION;

typedef enum
{
    OLE_NONE,               /* 0  no method active                           */
    OLE_DELETE,             /* 1  object delete                              */
    OLE_LNKPASTE,           /* 2  PasteLink(auto reconnect)                  */
    OLE_EMBPASTE,           /* 3  paste(and update)                          */
    OLE_SHOW,               /* 4  Show                                       */
    OLE_RUN,                /* 5  Run                                        */
    OLE_ACTIVATE,           /* 6  Activate                                   */
    OLE_UPDATE,             /* 7  Update                                     */
    OLE_CLOSE,              /* 8  Close                                      */
    OLE_RECONNECT,          /* 9  Reconnect                                  */
    OLE_SETUPDATEOPTIONS,   /* 10 setting update options                     */
    OLE_SERVERUNLAUNCH,     /* 11 server is being unlaunched                 */
    OLE_LOADFROMSTREAM,     /* 12 LoadFromStream(auto reconnect)             */
    OLE_SETDATA,            /* 13 OleSetData                                 */
    OLE_REQUESTDATA,        /* 14 OleRequestData                             */
    OLE_OTHER,              /* 15 other misc async operations                */
    OLE_CREATE,             /* 16 create                                     */
    OLE_CREATEFROMTEMPLATE, /* 17 CreatefromTemplate                         */
    OLE_CREATELINKFROMFILE, /* 18 CreateLinkFromFile                         */
    OLE_COPYFROMLNK,        /* 19 CopyFromLink(auto reconnect)               */
    OLE_CREATEFROMFILE,     /* 20 CreateFromFile                             */
    OLE_CREATEINVISIBLE     /* 21 CreateInvisible                            */
} OLE_RELEASE_METHOD;

/* rendering options */
typedef enum
{
    olerender_none, 
    olerender_draw, 
    olerender_format 
} OLEOPT_RENDER;

/* standard clipboard format type */
typedef WORD OLECLIPFORMAT;

/* Link update options */
typedef enum
{
    oleupdate_always,
    oleupdate_onsave,
#ifndef OLE_INTERNAL
    oleupdate_oncall
#else
    oleupdate_oncall,
    oleupdate_onclose
#endif  /* OLE_INTERNAL */
} OLEOPT_UPDATE;

typedef HANDLE  HOBJECT;
typedef LONG    LHSERVER;
typedef LONG    LHCLIENTDOC;
typedef LONG    LHSERVERDOC;

typedef struct _OLEOBJECT FAR*  LPOLEOBJECT;
typedef struct _OLESTREAM FAR*  LPOLESTREAM;
typedef struct _OLECLIENT FAR*  LPOLECLIENT;


#ifndef OLE_INTERNAL
/* object method table definitions. */
typedef struct _OLEOBJECTVTBL
{
    void FAR*      (CALLBACK* QueryProtocol)        (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* Release)              (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Show)                 (LPOLEOBJECT, BOOL);
    OLESTATUS      (CALLBACK* DoVerb)               (LPOLEOBJECT, UINT, BOOL, BOOL);
    OLESTATUS      (CALLBACK* GetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
    OLESTATUS      (CALLBACK* SetData)              (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
    OLESTATUS      (CALLBACK* SetTargetDevice)      (LPOLEOBJECT, HGLOBAL);
    OLESTATUS      (CALLBACK* SetBounds)            (LPOLEOBJECT, OLE_CONST RECT FAR*);
    OLECLIPFORMAT  (CALLBACK* EnumFormats)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* SetColorScheme)       (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
    /* Server has to implement only the above methods. */

#ifndef SERVERONLY
    /* Extra methods required for client. */
    OLESTATUS      (CALLBACK* Delete)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* SetHostNames)         (LPOLEOBJECT, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* SaveToStream)         (LPOLEOBJECT, LPOLESTREAM);
    OLESTATUS      (CALLBACK* Clone)                (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* CopyFromLink)         (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* Equal)                (LPOLEOBJECT, LPOLEOBJECT);
    OLESTATUS      (CALLBACK* CopyToClipboard)      (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Draw)                 (LPOLEOBJECT, HDC, OLE_CONST RECT FAR*, OLE_CONST RECT FAR*, HDC);
    OLESTATUS      (CALLBACK* Activate)             (LPOLEOBJECT, UINT, BOOL, BOOL, HWND, OLE_CONST RECT FAR*);
    OLESTATUS      (CALLBACK* Execute)              (LPOLEOBJECT, HGLOBAL, UINT);
    OLESTATUS      (CALLBACK* Close)                (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Update)               (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* Reconnect)            (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* ObjectConvert)        (LPOLEOBJECT, OLE_LPCSTR, LPOLECLIENT, LHCLIENTDOC, OLE_LPCSTR, LPOLEOBJECT FAR*);
    OLESTATUS      (CALLBACK* GetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE FAR*);
    OLESTATUS      (CALLBACK* SetLinkUpdateOptions) (LPOLEOBJECT, OLEOPT_UPDATE);
    
    OLESTATUS      (CALLBACK* Rename)               (LPOLEOBJECT, OLE_LPCSTR);
    OLESTATUS      (CALLBACK* QueryName)            (LPOLEOBJECT, LPSTR, UINT FAR*);

    OLESTATUS      (CALLBACK* QueryType)            (LPOLEOBJECT, LONG FAR*);
    OLESTATUS      (CALLBACK* QueryBounds)          (LPOLEOBJECT, RECT FAR*);
    OLESTATUS      (CALLBACK* QuerySize)            (LPOLEOBJECT, DWORD FAR*);
    OLESTATUS      (CALLBACK* QueryOpen)            (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryOutOfDate)       (LPOLEOBJECT);

    OLESTATUS      (CALLBACK* QueryReleaseStatus)   (LPOLEOBJECT);
    OLESTATUS      (CALLBACK* QueryReleaseError)    (LPOLEOBJECT);
    OLE_RELEASE_METHOD (CALLBACK* QueryReleaseMethod)(LPOLEOBJECT);

    OLESTATUS      (CALLBACK* RequestData)          (LPOLEOBJECT, OLECLIPFORMAT);
    OLESTATUS      (CALLBACK* ObjectLong)           (LPOLEOBJECT, UINT, LONG FAR*);
    
/* This method is internal only */
    OLESTATUS      (CALLBACK* ChangeData)           (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);
#endif  /* !SERVERONLY */
} OLEOBJECTVTBL;
typedef  OLEOBJECTVTBL FAR* LPOLEOBJECTVTBL;

typedef struct _OLEOBJECT
{
    LPOLEOBJECTVTBL    lpvtbl;
} OLEOBJECT;
#endif  /* !OLE_NTERNAL */

/* ole client definitions */
typedef struct _OLECLIENTVTBL
{
    int (CALLBACK* CallBack)(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);
} OLECLIENTVTBL;

typedef  OLECLIENTVTBL FAR*  LPOLECLIENTVTBL;

typedef struct _OLECLIENT
{
    LPOLECLIENTVTBL   lpvtbl;
} OLECLIENT;

/* Stream definitions */
typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, OLE_CONST void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL      lpstbl;
} OLESTREAM;

/* Public Function Prototypes */
OLESTATUS   WINAPI  OleDelete(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRelease(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSaveToStream(LPOLEOBJECT, LPOLESTREAM);
OLESTATUS   WINAPI  OleEqual(LPOLEOBJECT, LPOLEOBJECT );
OLESTATUS   WINAPI  OleCopyToClipboard(LPOLEOBJECT);
OLESTATUS   WINAPI  OleSetHostNames(LPOLEOBJECT, LPCSTR, LPCSTR);
OLESTATUS   WINAPI  OleSetTargetDevice(LPOLEOBJECT, HGLOBAL);
OLESTATUS   WINAPI  OleSetBounds(LPOLEOBJECT, const RECT FAR*);
OLESTATUS   WINAPI  OleSetColorScheme(LPOLEOBJECT, const LOGPALETTE FAR*);
OLESTATUS   WINAPI  OleQueryBounds(LPOLEOBJECT, RECT FAR*);
OLESTATUS   WINAPI  OleQuerySize(LPOLEOBJECT, DWORD FAR*);
OLESTATUS   WINAPI  OleDraw(LPOLEOBJECT, HDC, const RECT FAR*, const RECT FAR*, HDC);
OLESTATUS   WINAPI  OleQueryOpen(LPOLEOBJECT);
OLESTATUS   WINAPI  OleActivate(LPOLEOBJECT, UINT, BOOL, BOOL, HWND, const RECT FAR*);
OLESTATUS   WINAPI  OleExecute(LPOLEOBJECT, HGLOBAL, UINT);
OLESTATUS   WINAPI  OleClose(LPOLEOBJECT);
OLESTATUS   WINAPI  OleUpdate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleReconnect(LPOLEOBJECT);
OLESTATUS   WINAPI  OleGetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE FAR*);
OLESTATUS   WINAPI  OleSetLinkUpdateOptions(LPOLEOBJECT, OLEOPT_UPDATE);
void FAR*   WINAPI  OleQueryProtocol(LPOLEOBJECT, LPCSTR);

/* Routines related to asynchronous operations. */
OLESTATUS   WINAPI  OleQueryReleaseStatus(LPOLEOBJECT);
OLESTATUS   WINAPI  OleQueryReleaseError(LPOLEOBJECT);
OLE_RELEASE_METHOD WINAPI OleQueryReleaseMethod(LPOLEOBJECT);

OLESTATUS   WINAPI  OleQueryType(LPOLEOBJECT, LONG FAR*);

/* LOWORD is major version, HIWORD is minor version */
DWORD       WINAPI  OleQueryClientVersion(void);
DWORD       WINAPI  OleQueryServerVersion(void);

/* Converting to format (as in clipboard): */
OLECLIPFORMAT  WINAPI  OleEnumFormats(LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleGetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE FAR*);
OLESTATUS   WINAPI  OleSetData(LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS   WINAPI  OleQueryOutOfDate(LPOLEOBJECT);
OLESTATUS   WINAPI  OleRequestData(LPOLEOBJECT, OLECLIPFORMAT);

/* Query apis for creation from clipboard */
OLESTATUS   WINAPI  OleQueryLinkFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleQueryCreateFromClip(LPCSTR, OLEOPT_RENDER, OLECLIPFORMAT);

/* Object creation functions */
OLESTATUS   WINAPI  OleCreateFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR,  LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromClip(LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateLinkFromFile(LPCSTR, LPOLECLIENT, LPCSTR, LPCSTR, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleLoadFromStream(LPOLESTREAM, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCreate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleCreateInvisible(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);
OLESTATUS   WINAPI  OleCreateFromTemplate(LPCSTR, LPOLECLIENT, LPCSTR, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*, OLEOPT_RENDER, OLECLIPFORMAT);
OLESTATUS   WINAPI  OleClone(LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleCopyFromLink(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleObjectConvert(LPOLEOBJECT, LPCSTR, LPOLECLIENT, LHCLIENTDOC, LPCSTR, LPOLEOBJECT FAR*);
OLESTATUS   WINAPI  OleRename(LPOLEOBJECT, LPCSTR);
OLESTATUS   WINAPI  OleQueryName(LPOLEOBJECT, LPSTR, UINT FAR*);
OLESTATUS   WINAPI  OleRevokeObject(LPOLECLIENT);
BOOL        WINAPI  OleIsDcMeta(HDC);

/* client document API */
OLESTATUS   WINAPI  OleRegisterClientDoc(LPCSTR, LPCSTR, LONG, LHCLIENTDOC FAR*);
OLESTATUS   WINAPI  OleRevokeClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleRenameClientDoc(LHCLIENTDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleSavedClientDoc(LHCLIENTDOC);
OLESTATUS   WINAPI  OleEnumObjects(LHCLIENTDOC, LPOLEOBJECT FAR*);

/* server usage definitions */
typedef enum {
    OLE_SERVER_MULTI,           /* multiple instances */
    OLE_SERVER_SINGLE           /* single instance(multiple document) */
} OLE_SERVER_USE;

/* Server API */
typedef struct _OLESERVER FAR*  LPOLESERVER;

OLESTATUS   WINAPI  OleRegisterServer(LPCSTR, LPOLESERVER, LHSERVER FAR*, HINSTANCE, OLE_SERVER_USE);
OLESTATUS   WINAPI  OleRevokeServer(LHSERVER);
OLESTATUS   WINAPI  OleBlockServer(LHSERVER);
OLESTATUS   WINAPI  OleUnblockServer(LHSERVER, BOOL FAR*);

/* APIs to keep server open */
OLESTATUS   WINAPI  OleLockServer(LPOLEOBJECT, LHSERVER FAR*);
OLESTATUS   WINAPI  OleUnlockServer(LHSERVER);

/* Server document API */

typedef struct _OLESERVERDOC FAR*  LPOLESERVERDOC;

OLESTATUS   WINAPI  OleRegisterServerDoc(LHSERVER, LPCSTR, LPOLESERVERDOC, LHSERVERDOC FAR*);
OLESTATUS   WINAPI  OleRevokeServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleRenameServerDoc(LHSERVERDOC, LPCSTR);
OLESTATUS   WINAPI  OleRevertServerDoc(LHSERVERDOC);
OLESTATUS   WINAPI  OleSavedServerDoc(LHSERVERDOC);

typedef struct _OLESERVERVTBL
{
    OLESTATUS (CALLBACK* Open)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* document name                        */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Create)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* CreateFromTemplate)(LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* lp template name                     */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Edit)  (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR*);
                                    /* long handle to doc(privtate to DLL)  */
                                    /* lp to OLESERVER                      */
                                    /* lp class name                        */
                                    /* lp doc name                          */
                                    /* place holder for returning oledoc.   */

    OLESTATUS (CALLBACK* Exit)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Release)  (LPOLESERVER);
                                    /* lp OLESERVER                         */

    OLESTATUS (CALLBACK* Execute)(LPOLESERVER, HGLOBAL);
                                    /* lp OLESERVER                         */
                                    /* handle to command strings            */
} OLESERVERVTBL;
typedef  OLESERVERVTBL FAR*  LPOLESERVERVTBL;

typedef struct _OLESERVER
{
    LPOLESERVERVTBL    lpvtbl;
} OLESERVER;

typedef struct _OLESERVERDOCVTBL
{
    OLESTATUS (CALLBACK* Save)      (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* Close)     (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetHostNames)(LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);
    OLESTATUS (CALLBACK* SetDocDimensions)(LPOLESERVERDOC, OLE_CONST RECT FAR*);
    OLESTATUS (CALLBACK* GetObject) (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR*, LPOLECLIENT);
    OLESTATUS (CALLBACK* Release)   (LPOLESERVERDOC);
    OLESTATUS (CALLBACK* SetColorScheme)(LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
    OLESTATUS (CALLBACK* Execute)  (LPOLESERVERDOC, HGLOBAL);
} OLESERVERDOCVTBL;
typedef  OLESERVERDOCVTBL FAR*  LPOLESERVERDOCVTBL;

typedef struct _OLESERVERDOC
{
    LPOLESERVERDOCVTBL lpvtbl;
} OLESERVERDOC;

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_OLE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\libinit.asm ===
page	,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  LIBINIT.ASM
;
; library stub to do local init for a Dynamic linked library
;
; Created: 06-27-89
; Author:  Todd Laney [ToddLa]
;
; Exported Functions:   none
;
; Public Functions:     none
;
; Public Data:		none
;
; General Description:
;
; Restrictions:
;
;   This must be the first object file in the LINK line, this assures
;   that the reserved parameter block is at the *base* of DGROUP
;
;-----------------------------------------------------------------------;

?PLM=1      ; PASCAL Calling convention is DEFAULT
?WIN=1	    ; Windows calling convention

        .286p
	.xlist
	include cmacros.inc
;       include windows.inc
        .list

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;   external functions
;
        externFP    LocalInit           ; in KERNEL
        externP     LibMain             ; C code to do DLL init

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
%out link me first!!
sBegin  Data
assumes DS,Data
            org 0               ; base of DATA segment!

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

;-----------------------------------------------------------------------;

sBegin  CodeSeg
        assumes cs,CodeSeg

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        cCall   LocalInit,<0,0,cx>

no_heap:
        cCall   LibMain, <di>
cEnd

if 0
;--------------------------Exported-Routine-----------------------------;
;
;   WEP()
;
;   called when the DLL is unloaded, it is passed 1 WORD parameter that
;   is TRUE if the system is going down, or zero if the app is
;
;   WARNING:
;
;       This function is basicly useless, you cant can any kernel function
;       that may cause the LoadModule() code to be reentered..
;
;-----------------------------------------------------------------------;

cProc   WEP,<FAR,PUBLIC,NODATA>,<>
;       ParmW   fSystemExit
cBegin  nogen
        mov     ax,1
        retf    2
cEnd    nogen
endif

sEnd    CodeSeg

        end     LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\auxout.c ===
#include <windows.h>
#define MMNOMCI
#include "mmsystem.h"
#define NOMCIDEV
#include "mmddk.h"
#include "mmsysi.h"

/* -------------------------------------------------------------------------
** External globals
** -------------------------------------------------------------------------
*/
extern DWORD               mmwow32Lib;
extern LPSOUNDDEVMSGPROC   aux32Message;



/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetNumDevs | This function retrieves the number of auxiliary
 *   output devices present in the system.
 *
 * @rdesc Returns the number of auxiliary output devices present in the system.
 *
 * @xref auxGetDevCaps
 ****************************************************************************/
UINT WINAPI auxGetNumDevs(void)
{
    return (UINT)auxOutMessage( 0, AUXDM_GETNUMDEVS, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetDevCaps | This function queries a specified
 *   auxiliary output device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the auxiliary output device to be
 *   queried. Specify a valid device ID (see the following comments
 *   section), or use the following constant:
 *   @flag AUX_MAPPER | Auxiliary audio mapper. The function will
 *     return an error if no auxiliary audio mapper is installed.
 *
 * @parm LPAUXCAPS | lpCaps | Specifies a far pointer to an AUXCAPS
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the AUXCAPS structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm The device ID specified by <p wDeviceID> varies from zero
 *   to one less than the number of devices present. AUX_MAPPER may
 *   also be used. Use <f auxGetNumDevs> to determine the number of
 *   auxiliary devices present in the system.
 *
 * @xref auxGetNumDevs
 ****************************************************************************/
UINT WINAPI auxGetDevCaps(UINT wDeviceID, LPAUXCAPS lpCaps, UINT wSize)
{
    if (!wSize)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);
    return (UINT)auxOutMessage(wDeviceID, AUXDM_GETDEVCAPS, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxGetVolume | This function returns the current volume
 *   setting of an auxiliary output device.
 *
 * @parm UINT | wDeviceID | Identifies the auxiliary output device to be
 *   queried.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   word contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f auxSetVolume> are returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 * @comm  Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @xref auxSetVolume
 ****************************************************************************/
UINT WINAPI auxGetVolume(UINT wDeviceID, LPDWORD lpdwVolume)
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);
    return (UINT)auxOutMessage(wDeviceID, AUXDM_GETVOLUME, (DWORD)lpdwVolume, 0);
}

/*****************************************************************************
 * @doc EXTERNAL AUX
 *
 * @api UINT | auxSetVolume | This function sets the volume in an
 *   auxiliary output device.
 *
 * @parm UINT | wDeviceID |  Identifies the auxiliary output device to be
 *   queried.  Device IDs are determined implicitly from the number of
 *   devices present in the system.  Device ID values range from zero
 *   to one less than the number of devices present.  Use <f auxGetNumDevs>
 *   to determine the number of auxiliary devices in the system.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word specifies the left channel volume setting, and the
 *   high-order word specifies the right channel setting.
 *   A value of 0xFFFF represents full volume, and a value of 0x0000
 *   is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver failed to install.
 *
 * @comm Not all devices support volume control.
 *   To determine whether the device supports volume control, use the
 *   AUXCAPS_VOLUME flag to test the <e AUXCAPS.dwSupport> field of the
 *   <t AUXCAPS> structure (filled by <f auxGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the AUXCAPS_LRVOLUME flag to test the
 *   <e AUXCAPS.dwSupport> field of the <t AUXCAPS> structure (filled
 *   by <f auxGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f auxGetVolume> function will return the full 16-bit setting set
 *   with <f auxSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived volume increase is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref auxGetVolume
 ****************************************************************************/
UINT WINAPI auxSetVolume(UINT wDeviceID, DWORD dwVolume)
{
    return (UINT)auxOutMessage(wDeviceID, AUXDM_SETVOLUME, dwVolume, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\mciole.h ===
///////////////////////////////////////////////////////////////////////////////
//
//  these are the default OLE functions (exported from OLECLI.DLL)
//
///////////////////////////////////////////////////////////////////////////////
extern OLESTATUS FAR PASCAL DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);
extern OLESTATUS FAR PASCAL DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
extern OLESTATUS FAR PASCAL DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

///////////////////////////////////////////////////////////////////////////////
//
//  these are our OLE handlers (defined in this file)
//
///////////////////////////////////////////////////////////////////////////////

// Server has to implement only the following methods.
LPVOID          FAR PASCAL _loadds DllQueryProtocol         (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllRelease               (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllShow                  (LPOLEOBJECT, BOOL);
OLESTATUS       FAR PASCAL _loadds DllDoVerb                (LPOLEOBJECT, WORD, BOOL, BOOL);
OLESTATUS       FAR PASCAL _loadds DllGetData               (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetData               (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetTargetDevice       (LPOLEOBJECT, HANDLE);
OLESTATUS       FAR PASCAL _loadds DllSetBounds             (LPOLEOBJECT, LPRECT);
OLECLIPFORMAT   FAR PASCAL _loadds DllEnumFormats           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _loadds DllSetColorScheme        (LPOLEOBJECT, LPLOGPALETTE);

// Extra methods required for client.
OLESTATUS       FAR PASCAL _loadds DllDelete                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllSetHostNames          (LPOLEOBJECT, LPSTR, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllSaveToStream          (LPOLEOBJECT, LPOLESTREAM);
OLESTATUS       FAR PASCAL _loadds DllClone                 (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllCopyFromLink          (LPOLEOBJECT, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllEqual                 (LPOLEOBJECT, LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllCopyToClipboard       (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllDraw                  (LPOLEOBJECT, HDC, LPRECT, LPRECT, HDC);
OLESTATUS       FAR PASCAL _loadds DllActivate              (LPOLEOBJECT, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS       FAR PASCAL _loadds DllExecute               (LPOLEOBJECT, HANDLE, WORD);
OLESTATUS       FAR PASCAL _loadds DllClose                 (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllUpdate                (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllReconnect             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllObjectConvert         (LPOLEOBJECT, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);
OLESTATUS       FAR PASCAL _loadds DllGetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE FAR *);
OLESTATUS       FAR PASCAL _loadds DllSetLinkUpdateOptions  (LPOLEOBJECT, OLEOPT_UPDATE);
OLESTATUS       FAR PASCAL _loadds DllRename                (LPOLEOBJECT, LPSTR);
OLESTATUS       FAR PASCAL _loadds DllQueryName             (LPOLEOBJECT, LPSTR, WORD FAR *);
OLESTATUS       FAR PASCAL _loadds DllQueryType             (LPOLEOBJECT, LPLONG);
OLESTATUS       FAR PASCAL _loadds DllQueryBounds           (LPOLEOBJECT, LPRECT);
OLESTATUS       FAR PASCAL _loadds DllQuerySize             (LPOLEOBJECT, DWORD FAR *);
OLESTATUS       FAR PASCAL _loadds DllQueryOpen             (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryOutOfDate        (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryReleaseStatus    (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllQueryReleaseError     (LPOLEOBJECT);
OLESTATUS       FAR PASCAL _loadds DllRequestData           (LPOLEOBJECT, OLECLIPFORMAT);
OLESTATUS       FAR PASCAL _loadds DllObjectLong            (LPOLEOBJECT, WORD, LPLONG);
OLE_RELEASE_METHOD  FAR PASCAL _loadds DllQueryReleaseMethod(LPOLEOBJECT);

// This method is internal only 
OLESTATUS       FAR PASCAL _loadds DllChangeData            (LPOLEOBJECT, HANDLE, LPOLECLIENT, BOOL);

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG
    extern void FAR cdecl dprintf(LPSTR, ...);

    #define DPRINTF(x) dprintf x
#else
    #define DPRINTF(x)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\bwinexec.asm ===
PAGE 58,132
;******************************************************************************
TITLE bwinexec.asm - WinExec with binary command line
;******************************************************************************
;
;   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.
;
;   Title:      bwinexec.asm - Exec. an app. with a block of binary data.
;
;   Version:    1.00
;
;   Date:       14-Mar-1990 (from winexec)
;
;   Author:     ROBWI
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV            DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   14-Mar-1990 RJW Modified Toddla's WinExec code to take a binary command
;                   block instead of an ascii command line
;
;==============================================================================

?PLM=1
?WIN=0
PMODE=1

.xlist
include cmacros.inc
include windows.inc
.list

                externFP        LoadModule

EXECBLOCK struc
envseg          dw      ?    ; seg addr of environment
lpcmdline       dd      ?    ; pointer to command block (normally ascii str)
lpfcb1          dd      ?    ; default fcb at 5C
lpfcb2          dd      ?    ; default fcb at 6C
EXECBLOCK ends

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes es,nothing
        assumes ds,nothing

;****************************************************************************
;
;   @doc    INTERNAL    MMSYSTEMS
;
;   @api    HANDLE | BWinExec | This function executes the Windows
;           or non-Windows application identified by the <p lpCmdLine>
;           parameter. The <p nCmdShow> parameter specifies the initial
;           state of the applications main window when it is created.
;   
;     @parm   LPSTR | lpModuleName |  Far pointer to a null-terminated 
;             character string that contains the filename of the 
;             application to run. See <f LoadModule> for more info.
;
;     @parm   WORD | nCmdShow |  Specifies how the application is shown.
;             See <f ShowWindow> for valid values.
;
;     @parm   LPVOID | lpParameters | Specifies a far pointer to a block
;             of data which will be passed to the application as a cmd 
;             tail. The first byte of the block must be the length of the
;             data and must be less than or equal to 120. 
;
;   @rdesc  The return value identifies the instance of the loaded module if
;           the function was successful. Otherwise, it is a value less than
;           32 that specifies the error. See <f LoadModule> for valid
;           error values.
;
;   @xref   LoadModule WinExec
;
;============================================================================

cProc BWinExec, <FAR,PUBLIC,NODATA>,<si,di>

    parmD lpszFile              ; Pathname ptr
    parmW wShow                 ; Mode flag
    parmD lpParameters          ; Cmd Line Data

    LocalV szCommand, 128       ; ASCIIZ Name of program to exec

    LocalV szParm, 128          ; DOS version of parameters
    LocalB szParmLen            ; DOS parm length
    LocalB bDotFound            ; Non-zero if a period is in the string

    LocalV loadparams, %(SIZE EXECBLOCK)
    LocalV rOF, %(SIZE OPENSTRUC)
    LocalD FCB1

cBegin
    mov     byte ptr szParm,0Dh
    mov     szParmLen,0         ; Init to zero length, Line feed

; Copy first part of line into szCommand.

    lds     si,lpszFile
    mov     ax,ss
    mov     es,ax
    lea     di,szCommand

    xor     al,al
    mov     bDotFound,al

; Loop until a blank or NULL is found.

WELoop1:
    lodsb
    cmp     al,' '              ; Exit loop if blank or NULL
    je      WECont1
    or      al,al
    je      WECont1
    cmp     al,'.'
    jne     WELoopCont
    mov     bDotFound,al
WELoopCont:
    stosb
    jmp     short WELoop1

WECont1:

; Does the command have an extension?

    cmp     bDotFound,0
    jne     WEHasExt

    mov     ax,0452Eh           ;'.E'
    stosw                       
    mov     ax,04558h           ;'XE'
    stosw

WEHasExt:
    xor     ax,ax               ; NULL terminate string
    stosb                   

    lds     si,lpParameters     
    mov     ax, ds
    or      ax, si              ; NULL Parameter block?
    jz      WEExec              ;  Y: exec 

; Copy Parameter Block into szParm.

    lea    di, szParmLen
    lodsb
    xor    cx,cx
    mov    cl, al   
    push   dx                           ; truncate to legal length!
    mov    ax, 78h 
    sub    ax, cx
    cwd    
    and    ax, dx
    add    cx, ax                       ; length + 1 in cx
    pop    dx
    mov    al, cl
    stosb
    dec    cx
    cld
    rep    movsb

; Terminate it with a linefeed.

    mov    al,0Dh
    stosb

; Set up the FCBs.

WEExec:
    mov    word ptr FCB1[0],2   ; FCB1[0] = 2;
    mov    ax,wShow             ; FCB1[1] = wShow;
    mov    word ptr FCB1[2],ax
    xor    ax,ax
    mov    loadparams.envseg,ax         ; loadparms.segEnv = 0;
    mov    loadparams.lpfcb2.lo,ax      ; loadparms.lpFCB2 = (LPSTR)NULL;
    mov    loadparams.lpfcb2.hi,ax
    lea    ax,szParmLen            ; loadparms.lpCmdLine = (LPSTR)ach;
    mov    loadparams.lpCmdLine.lo,ax
    mov    loadparams.lpCmdLine.hi,ss
    lea    ax,FCB1              ; loadparms.lpFCB1 = (LPSTR)fcb1buf;
    mov    loadparams.lpfcb1.lo,ax
    mov    loadparams.lpfcb1.hi,ss

; Exec the progam.

    lea     dx,szCommand        ; ds:ax == ptr to file to exec
    lea     bx,loadparams       ; es:bx == ptr to param block
if 1
    cCall   LoadModule, <ss,dx, ss,bx>      ; return ax=hInstance, dx=hTask
    cmp     ax,32
    jb      @f
    mov     ax,dx                           ; return hTask
@@:
else
    mov     ax,ss
    mov     ds,ax
    mov     ax,4B00h            ; dos exec
    int     21h
endif

cEnd

sEnd CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\mciole.c ===
//
//  MCIOLE  - OLE handler DLL for MCI objects
//
//
//  NOTES:
//      The whole reason for this handler DLL is to supply the function
//
//      OleQueryObjPos()
//
//      this function gives information to the server application on the
//      location (in the client document) of the activated OLE object.
//      the server can use this information to play the object in place
//      or position the server window correctly
//
//  IMPLEMENTION:
//
//      in theory all this DLL (handler) has to do is save the information
//      passed to OleActivate().  But in reality no app correctly calls
//      OleActivate().  They either pass no information or the wrong
//      information.
//
//      this DLL is a OLE handler, because of global data (vtblDef!) it
//      can only be a handler for one class at a time.
//
//      the handler intercepts the OleDraw, OleActivate, and all the
//      creation/destuction OLE APIs.  for each OLE object a info
//      structure is maintained (a OBJINFO structure) when ever the
//      client draws (using OleDraw...) the drawing position, and the
//      window drawn to is remembered.
//
//      when the client calls OleActivate, the saved draw location is
//      recalled, or if the app never called OleDraw() (plays
//      the meta-file itself) then the rectangle passed to OleActivate()
//      is used. (if one is supplied)
//
//      there are many classes of apps:
//
//          calls OleActivate() with correct info
//          calls OleActivate() with incorrect info
//          calls OleActivate() with no info
//
//          calls OleDraw()
//          does not call OleDraw()
//
//      here is a table of known OLE Clients....
//
//                      OleDraw     OleActivate()
//      App             Y or N      Y, N, X
//                                  (X = wrong info)
//      -------------   ----------  ------------
//      Write           Y           N
//      CardFile        Y           N
//      Packager        Y           N
//
//      Excel           N           N               (uses DDE)
//      Excel 4.0       N           N               (uses DDE)
//      PowerPnt 2.0    N           N               (uses DDE)
//
//      WinWord         N           N
//      WinWorks        Y           X
//      PowerPnt 3.0    N           Y
//      MsPublisher     N           X
//      ClTest          Y           N
//      Cirus           Y           X
//      WinProj         ?           ?
//
//      AmiPro          Y           ?
//
#include <windows.h>
#include "ole.h"
#include "shellapi.h"
#include "mciole.h"

HANDLE  ghInstance;

OLEOBJECTVTBL   vtblDll;        // these are our functions.
OLEOBJECTVTBL   vtblDef;        // these are the default functions.
HBITMAP         hbmStock;

#ifdef DEBUG
RECT rcNull = {0,0,0,0};
#define PUSHRC(prc) *((prc) ? (prc) : &rcNull)
#define CARETPOS()  // {POINT pt; GetCaretPos(&pt); DPRINTF(("CaretPos: [%d, %d]", pt.x, pt.y));}
#endif

/****************************************************************************
****************************************************************************/

void    ReplaceFunctions(LPOLEOBJECT);
BOOL    CanReplace(LPOLEOBJECT);

/****************************************************************************

    FUNCTION: LibMain(HANDLE hInstance)

****************************************************************************/

BOOL NEAR PASCAL LibMain (HANDLE hInstance)
{
    HDC hdc;
    HBITMAP hbm;

    ghInstance = hInstance;

    //
    // get the stock 1x1 mono bitmap.
    //
    hbm = CreateBitmap(1,1,1,1,NULL);
    hdc = CreateCompatibleDC(NULL);
    hbmStock = SelectObject(hdc, hbm);
    SelectObject(hdc, hbmStock);
    DeleteDC(hdc);
    DeleteObject(hbm);

//  // register clipboard formats.
//  cfObjectLink    = RegisterClipboardFormat("ObjectLink");
//  cfOwnerLink     = RegisterClipboardFormat("OwnerLink");
//  cfNative        = RegisterClipboardFormat("Native");

    return TRUE;
}

/****************************************************************************

    FUNCTION: WEP(int)

    PURPOSE: Standard exit routine for the DLL

****************************************************************************/

int FAR PASCAL _loadds WEP(nParameter)
int nParameter;
{
    return 1;
}

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsApp(LPSTR szApp)
{
    char ach[80];
    int  i;
    WORD wStack;

    _asm mov wStack,ss

    GetModuleFileName((HINSTANCE)wStack, ach, sizeof(ach));

    for (i = lstrlen(ach);
        i > 0 && ach[i-1] != '\\' && ach[i-1] != '/' && ach[i] != ':';
        i--)
        ;

    return lstrcmpi(ach + i, szApp) == 0;
}

/****************************************************************************
****************************************************************************/

BOOL NEAR PASCAL IsDcMemory(HDC hdc)
{
    HBITMAP hbmT;

    if (hbmT = SelectObject(hdc, hbmStock))
        SelectObject(hdc, hbmT);

    return hbmT != NULL;
}

/****************************************************************************
****************************************************************************/

typedef struct _OBJINFO {

    struct _OBJINFO*poiNext;

    LPOLEOBJECT     lpobj;          // client side LPOLEOBJECT

    HWND            hwnd;           // client window (passed to OleActivate)
    RECT            rcActivate;     // activation rectangle (passed to OleActivate)

    HWND            hwndDraw;       // active window at time of OleDraw
    RECT            rcDraw;         // rectangle of draw
}   OBJINFO;

#ifdef DEBUG
int nObjects = 0;
#endif
OBJINFO *poiFirst = NULL;

LPOLEOBJECT lpobjActive;
BOOL RegSetGetData(OBJINFO *poi, BOOL Write);

OBJINFO *FindObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    for (poi=poiFirst; poi; poi=poi->poiNext)
        if (poi->lpobj == lpobj)
            return poi;

    DPRINTF(("FindObj: Unable to find object %lx", lpobj));

    return NULL;
}

void DelObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;
    OBJINFO *poiT;

    for (poiT=NULL,poi=poiFirst; poi; poiT=poi,poi=poi->poiNext)
    {
        if (poi->lpobj == lpobj)
        {
            if (poiT)
                poiT->poiNext = poi->poiNext;
            else
                poiFirst = poi->poiNext;

            poi->lpobj = NULL;
            LocalFree((HLOCAL)poi);

            DPRINTF(("DelObj(%lx): %d objects", lpobj, --nObjects));
            return;
        }
    }

    DPRINTF(("DelObj(%lx): Cant find object to delete.", lpobj));
}

BOOL RegSetGetData(OBJINFO *poi, BOOL Write)
{

    static char szKey[] = "PlayData";
    static char szFormat[] = "%ld %ld %d %d %d %d %d %d %d %d";


    if (Write) {
        LONG Rc;

        char Data[100];

        //
        // Store hwnd, hwnddraw, rcDraw, rcActivate
        //

#ifdef WIN32
        wsprintf(Data, szFormat,
                 (LONG)poi->hwnd,
                 (LONG)poi->hwndDraw,
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);

#else
        wsprintf(Data, szFormat,
                 (LONG)(poi->hwnd == NULL ? (LONG)0 : MAKELONG(poi->hwnd, 0xFFFF)),
                 (LONG)(poi->hwndDraw == NULL ? (LONG)0 : MAKELONG(poi->hwndDraw, 0xFFFF)),
                 poi->rcDraw.left,
                 poi->rcDraw.right,
                 poi->rcDraw.top,
                 poi->rcDraw.bottom,
                 poi->rcActivate.left,
                 poi->rcActivate.right,
                 poi->rcActivate.top,
                 poi->rcActivate.bottom);
#endif

        Rc = RegSetValue(HKEY_CLASSES_ROOT,
                         szKey,
                         REG_SZ,
                         Data,
                         lstrlen(Data));

        return Rc == ERROR_SUCCESS;
    } else {

#ifdef WIN32
        LONG Rc;
        CHAR Data[100];
        DWORD hwnd, hwndDraw;
        LONG Length;

        Length = sizeof(Data);

        Rc = RegQueryValue(HKEY_CLASSES_ROOT, szKey,
                           Data, &Length);

        RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, "", 0);

        //
        // Extract our data - sscanf doesn't work yet!!!
        //

        if (Rc == ERROR_SUCCESS) {
            LONG OurData[10];
            int i;
            LPTSTR lpData;

            for (i = 0, lpData = Data; i < 10; i++) {
                OurData[i] = atol(lpData);
                while (*lpData != ' ' && *lpData != '\0') {
                    lpData++;
                }

                if (*lpData == ' ') {
                    lpData++;
                }
            }

            poi->hwnd = (HWND)OurData[0];
            poi->hwndDraw = (HWND)OurData[1];
            poi->rcDraw.left = OurData[2];
            poi->rcDraw.right = OurData[3];
            poi->rcDraw.top = OurData[4];
            poi->rcDraw.bottom = OurData[5];
            poi->rcActivate.left = OurData[6];
            poi->rcActivate.right = OurData[7];
            poi->rcActivate.top = OurData[8];
            poi->rcActivate.bottom = OurData[9];
        }

        return Rc == ERROR_SUCCESS && Length != 0;
#else
        return FALSE;
#endif
    }
}

//
// for some reason we dont get all the OleDelete() calls that we should
// so lets try to "weed out the bad apples" so we dont choke.
//
void CleanObjects()
{
    OBJINFO *poi;

again:
    for (poi=poiFirst; poi; poi=poi->poiNext)
    {
        if (IsBadReadPtr(poi->lpobj, 0))
        {
            DPRINTF(("Freeing bad object %lx", poi->lpobj));
            DelObj(poi->lpobj);
            goto again;
        }
    }
}

OBJINFO *NewObj(LPOLEOBJECT lpobj)
{
    OBJINFO *poi;

    CleanObjects();

    if (poi = FindObj(lpobj))
    {
        DPRINTF(("NewObj(%lx): Trying to add object twice!", lpobj));
        return poi;
    }

    if (poi = (OBJINFO*)LocalAlloc(LPTR, sizeof(OBJINFO)))
    {
        poi->lpobj = lpobj;
        poi->hwnd  = NULL;
        poi->hwndDraw = NULL;
        SetRectEmpty(&poi->rcDraw);
        SetRectEmpty(&poi->rcActivate);

        poi->poiNext = poiFirst;
        poiFirst = poi;

        DPRINTF(("NewObj(%lx): %d objects", lpobj, ++nObjects));
    }
    else
    {
        DPRINTF(("NewObj(%lx): Out of room in the object table", lpobj));
    }

    return poi;
}

/****************************************************************************
****************************************************************************/

HWND LookForDC(HWND hwndP, HDC hdc)
{
    RECT    rc;
    DWORD   dw;
    HWND    hwnd;

    if (hwndP == NULL)
        return NULL;

    dw = GetDCOrg(hdc);

    for (hwnd = hwndP; hwnd; hwnd = GetWindow(hwnd, GW_HWNDNEXT))
    {
        GetClientRect(hwnd, &rc);
        ClientToScreen(hwnd, (LPPOINT)&rc);
        ClientToScreen(hwnd, (LPPOINT)&rc+1);

        if ((int)LOWORD(dw) == rc.left && (int)HIWORD(dw) == rc.top)
            return hwnd;

        if (PtInRect(&rc, MAKEPOINT(dw)) && (hwndP = GetWindow(hwnd, GW_CHILD)))
            if (hwndP = LookForDC(hwndP,hdc))
                return hwndP;
    }

    return NULL;
}

HWND WindowFromDC(HDC hdc)
{
    return LookForDC(GetDesktopWindow(), hdc);
}

/****************************************************************************
****************************************************************************/

BOOL RectSameSize(LPRECT lprc1, LPRECT lprc2)
{
    return lprc1->right  - lprc1->left == lprc2->right  - lprc2->left &&
           lprc1->bottom - lprc1->top  == lprc2->bottom - lprc2->top;
}

/****************************************************************************

    OleQueryObjPos - this function retuns the last drawn or activated
                     position of a object

****************************************************************************/

OLESTATUS FAR PASCAL _loadds OleQueryObjPos(
LPOLEOBJECT lpobj,      /* object to query */
HWND FAR *  lphwnd,     /* window of the document containing the object */
LPRECT      lprc,       /* rect (client cords) of object. */
LPRECT      lprcWBounds)/* rect (client cords) of bounding rect. */
{
    OBJINFO *poi;

    //
    // we dont do this any more
    //
    if (lprcWBounds)
        SetRectEmpty(lprcWBounds);

    //
    // because the server side calls this API the passed lpobj is
    // a server side LPOLEOBJECT, we can't search our table for this
    // object.
    //
    // this API is only callable by the server during the DoVerb
    // server callback
    //
    //!!! this only works for the last active object!!!!

    DPRINTF(("OleQueryObjPos(%lx)", lpobj));

    if (lpobjActive != NULL && (poi = FindObj(lpobjActive)))
    {
        //
        //  set lpobjActive to NULL so we will never retrive the
        //  wrong info again.
        //
        lpobjActive = NULL;

        *lphwnd = poi->hwnd;

//      if (IsRectEmpty(&poi->rcActivate))
        if (!IsRectEmpty(&poi->rcDraw))
        {
            DPRINTF(("Using the OleDraw() rectange...."));

            //
            // use the draw rectangle
            //
            *lprc = poi->rcDraw;

            if (poi->hwndDraw)
            {
                ClientToScreen(poi->hwndDraw, (LPPOINT)lprc);
                ClientToScreen(poi->hwndDraw, (LPPOINT)lprc+1);
            }

            ScreenToClient(poi->hwnd, (LPPOINT)lprc);
            ScreenToClient(poi->hwnd, (LPPOINT)lprc+1);
        }
        else
        {
            //
            // use the activate rectangle
            //
            *lprc = poi->rcActivate;
        }

        if (poi->hwnd && !IsRectEmpty(lprc))
            return OLE_OK;
        else
            return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
    else
    {
        *lphwnd = NULL;
        SetRectEmpty(lprc);

        return OLE_ERROR_BLANK;     // return a error, we dont know about this OBJ
    }
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleLoadFromStream(%s,%s)", lpprotocol, lpobjname));

    retVal = DefLoadFromStream (lpstream, lpprotocol, lpclient,
                    lhclientdoc, lpobjname, lplpobj,
                    objType, aClass, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateFromClip (lpprotocol, lpclient,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat, objType);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS       retVal;
    BOOL            bReplace = FALSE;

    DPRINTF(("OleCreateLinkFromClip(%s,%s)", lpprotocol, lpobjname));

    retVal =  DefCreateLinkFromClip (lpprotocol, lpclient,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromTemplate(%s,%s,%s)", lpprotocol, lptemplate, lpobjname));

    retVal = DefCreateFromTemplate (lpprotocol, lpclient, lptemplate,
                            lhclientdoc, lpobjname, lplpobj,
                            optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreate(%s,%s,%s)", lpprotocol, lpclass, lpobjname));

    retVal = DefCreate (lpprotocol, lpclient, lpclass,
                    lhclientdoc, lpobjname, lplpobj,
                    optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}

/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateFromFile(%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpobjname));

    retVal = DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

OLESTATUS FAR PASCAL _loadds DllCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;

    DPRINTF(("OleCreateLinkFromFile(%s,%s,%s,%s,%s)", lpprotocol, lpclass, lpfile, lpitem, lpobjname));

    retVal = DefCreateLinkFromFile (lpprotocol, lpclient,
                        lpclass, lpfile, lpitem,
                        lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat);

    if (retVal <= OLE_WAIT_FOR_RELEASE)
        ReplaceFunctions(*lplpobj);

    return retVal;
}


/****************************************************************************
****************************************************************************/

void ReplaceFunctions(LPOLEOBJECT lpobj)
{
//  OBJINFO *poi;

    if (!CanReplace(lpobj))
        return;

    NewObj(lpobj);

    //
    // get the default handlers
    //
    if (vtblDef.Draw == NULL)           // only get the handlers once!
        vtblDef = *lpobj->lpvtbl;       // save default handlers

    //
    //  make the OLE object use our handlers
    //
    lpobj->lpvtbl = (LPOLEOBJECTVTBL)&vtblDll;

    //
    //  init our VTBL, ie replace any handlers we want to override.
    //  any handlers we dont replace we set the the default ones.
    //
    vtblDll = vtblDef;

////(FARPROC)vtblDll.QueryProtocol           = (FARPROC)DllQueryProtocol;
////(FARPROC)vtblDll.Release                 = (FARPROC)DllRelease;
////(FARPROC)vtblDll.Show                    = (FARPROC)DllShow;
////(FARPROC)vtblDll.DoVerb                  = (FARPROC)DllDoVerb;
////(FARPROC)vtblDll.GetData                 = (FARPROC)DllGetData;
////(FARPROC)vtblDll.SetData                 = (FARPROC)DllSetData;
////(FARPROC)vtblDll.SetTargetDevice         = (FARPROC)DllSetTargetDevice;
////(FARPROC)vtblDll.SetBounds               = (FARPROC)DllSetBounds;
////(FARPROC)vtblDll.EnumFormats             = (FARPROC)DllEnumFormats;
////(FARPROC)vtblDll.SetColorScheme          = (FARPROC)DllSetColorScheme;

    (FARPROC)vtblDll.Delete                  = (FARPROC)DllDelete;
////(FARPROC)vtblDll.SetHostNames            = (FARPROC)DllSetHostNames;
////(FARPROC)vtblDll.SaveToStream            = (FARPROC)DllSaveToStream;
    (FARPROC)vtblDll.Clone                   = (FARPROC)DllClone;
    (FARPROC)vtblDll.CopyFromLink            = (FARPROC)DllCopyFromLink;
////(FARPROC)vtblDll.Equal                   = (FARPROC)DllEqual;
////(FARPROC)vtblDll.CopyToClipboard         = (FARPROC)DllCopyToClipboard;
    (FARPROC)vtblDll.Draw                    = (FARPROC)DllDraw;
    (FARPROC)vtblDll.Activate                = (FARPROC)DllActivate;
////(FARPROC)vtblDll.Execute                 = (FARPROC)DllExecute;
////(FARPROC)vtblDll.Close                   = (FARPROC)DllClose;
////(FARPROC)vtblDll.Update                  = (FARPROC)DllUpdate;
////(FARPROC)vtblDll.Reconnect               = (FARPROC)DllReconnect;
    (FARPROC)vtblDll.ObjectConvert           = (FARPROC)DllObjectConvert;
////(FARPROC)vtblDll.GetLinkUpdateOptions    = (FARPROC)DllGetLinkUpdateOptions;
////(FARPROC)vtblDll.SetLinkUpdateOptions    = (FARPROC)DllSetLinkUpdateOptions;
////(FARPROC)vtblDll.Rename                  = (FARPROC)DllRename;
////(FARPROC)vtblDll.QueryName               = (FARPROC)DllQueryName;
////(FARPROC)vtblDll.QueryType               = (FARPROC)DllQueryType;
////(FARPROC)vtblDll.QueryBounds             = (FARPROC)DllQueryBounds;
////(FARPROC)vtblDll.QuerySize               = (FARPROC)DllQuerySize;
////(FARPROC)vtblDll.QueryOpen               = (FARPROC)DllQueryOpen;
////(FARPROC)vtblDll.QueryOutOfDate          = (FARPROC)DllQueryOutOfDate;
////(FARPROC)vtblDll.QueryReleaseStatus      = (FARPROC)DllQueryReleaseStatus;
////(FARPROC)vtblDll.QueryReleaseError       = (FARPROC)DllQueryReleaseError;
////(FARPROC)vtblDll.QueryReleaseMethod      = (FARPROC)DllQueryReleaseMethod;
////(FARPROC)vtblDll.RequestData             = (FARPROC)DllRequestData;
////(FARPROC)vtblDll.ObjectLong              = (FARPROC)DllObjectLong;
////(FARPROC)vtblDll.ChangeData              = (FARPROC)DllChangeData;
}

/****************************************************************************
****************************************************************************/

BOOL CanReplace(LPOLEOBJECT lpobj)
{
#if 0   // did not work anyway.
    //
    // we dont work on the wierd OLE shipped with PenWindows so don't load
    //
#pragma message("Disabling handler because we are on PenWindows...")
    if (GetSystemMetrics(SM_PENWINDOWS))
        return FALSE;
#endif

    return TRUE;
}

/****************************************************************************
****************************************************************************/

LPVOID GetData(LPOLEOBJECT lpobj, WORD cf)
{
    HANDLE h;

    if ( (*vtblDef.GetData)(lpobj, cf, &h) != OLE_OK || h == NULL)
        return NULL;

    return GlobalLock(h);
}

/****************************************************************************

these are the actual handlers.....

****************************************************************************/

/****************************************************************************
****************************************************************************/

LPVOID          FAR PASCAL _loadds DllQueryProtocol (
LPOLEOBJECT     lpobj,
LPSTR           lpsz)
{
    DPRINTF(("OleQueryProtocol(%ls)", lpsz));

    return vtblDef.QueryProtocol(lpobj, lpsz);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRelease (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleRelease()"));

    return vtblDef.Release(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllShow (
LPOLEOBJECT     lpobj,
BOOL            fShow)
{
    DPRINTF(("OleShow(%d)", fShow));

    return vtblDef.Show(lpobj, fShow);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDoVerb (
LPOLEOBJECT     lpobj,
WORD            verb,
BOOL            fShow,
BOOL            fActivate)
{
    DPRINTF(("OleDoVerb(%d, %d, %d)", verb, fShow, fActivate));

    return vtblDef.DoVerb(lpobj, verb, fShow, fActivate);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllGetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
LPHANDLE        lph)
{
    DPRINTF(("OleGetData(%d)", cf));

    return vtblDef.GetData(lpobj, cf, lph);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf,
HANDLE          h)
{
    DPRINTF(("OleSetData(%d, %d)", cf, h));

    return vtblDef.SetData(lpobj, cf, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetTargetDevice (
LPOLEOBJECT     lpobj,
HANDLE          h)
{
    DPRINTF(("OleSetTargetDevice()"));

    return vtblDef.SetTargetDevice(lpobj, h);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleSetBounds([%d,%d,%d,%d])", PUSHRC(lprc)));

    return vtblDef.SetBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLECLIPFORMAT   FAR PASCAL _loadds DllEnumFormats (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleEnumFormats(%d)", cf));

    return vtblDef.EnumFormats(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetColorScheme (
LPOLEOBJECT     lpobj,
LPLOGPALETTE    lppal)
{
    DPRINTF(("OleSetColorScheme()"));

    return vtblDef.SetColorScheme(lpobj, lppal);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDelete (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleDelete(%lx)", lpobj));

    DelObj(lpobj);
    CleanObjects();

    return vtblDef.Delete(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetHostNames (
LPOLEOBJECT     lpobj,
LPSTR           szClientName,
LPSTR           szDocName)
{
    DPRINTF(("OleSetHostNames(%ls,%ls)", szClientName, szDocName));

    return vtblDef.SetHostNames(lpobj, szClientName, szDocName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSaveToStream (
LPOLEOBJECT     lpobj,
LPOLESTREAM     lpstream)
{
    DPRINTF(("OleSaveToStream()"));

    return vtblDef.SaveToStream(lpobj, lpstream);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllClone (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleClone(%ls)", szObjName));

    err = vtblDef.Clone(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    //
    // if the object cloned correctly then clone our object information
    //
    if (err <= OLE_WAIT_FOR_RELEASE)
    {
        OBJINFO *poi, *poiT;

        if ((poiT = FindObj(lpobj)) && (poi = NewObj(NULL)))
        {
            poi->lpobj      = *lplpobj;
            poi->hwnd       = poiT->hwnd;
            poi->rcActivate = poiT->rcActivate;
            poi->hwndDraw   = poiT->hwndDraw;
            poi->rcDraw     = poiT->rcDraw;
        }
    }

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllCopyFromLink (
LPOLEOBJECT     lpobj,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleCopyFromLink(%ls)", szObjName));

    err = vtblDef.CopyFromLink(lpobj, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllEqual (
LPOLEOBJECT     lpobj1,
LPOLEOBJECT     lpobj2)
{
    DPRINTF(("OleEqual()"));

    return vtblDef.Equal(lpobj1, lpobj2);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllCopyToClipboard (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleCopyToClipboard()"));

    return vtblDef.CopyToClipboard(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllDraw (
LPOLEOBJECT     lpobj,
HDC             hdc,
LPRECT          lprcBounds,
LPRECT          lprcWBounds,
HDC             hdcFormat)
{
    OBJINFO *poi;
    RECT rc;
    DWORD   dw;

    DPRINTF(("OleDraw(%lx,[%d,%d,%d,%d], [%d,%d,%d,%d])", lpobj, PUSHRC(lprcBounds), PUSHRC(lprcWBounds)));

#ifdef DEBUG
    if (OleIsDcMeta(hdc))
        DPRINTF(("OleDraw: drawing to a meta-file"));
    else if (IsDcMemory(hdc))
        DPRINTF(("OleDraw: drawing to a bitmap"));
#endif

    if ((poi = FindObj(lpobj)) && !OleIsDcMeta(hdc) && !IsDcMemory(hdc))
    {
        //!!!get the window from the HDC!!!

        poi->hwndDraw = WindowFromDC(hdc);
        DPRINTF(("OleDraw: hwndDraw = %04X", poi->hwndDraw));

        if (lprcBounds && !IsRectEmpty(lprcBounds))
        {
            poi->rcDraw = *lprcBounds;

            //
            // convert the bound rectange into coordinates.
            // relative to hwndDraw
            //
            LPtoDP(hdc, (LPPOINT)&poi->rcDraw, 2);

            if (poi->hwndDraw == NULL)
            {
                dw = GetDCOrg(hdc);
                OffsetRect(&poi->rcDraw, LOWORD(dw), HIWORD(dw));
            }
        }

        if (GetClipBox(hdc, &rc) == NULLREGION)
            return OLE_OK;
    }

    return vtblDef.Draw(lpobj, hdc, lprcBounds, lprcWBounds, hdcFormat);
}

/****************************************************************************

    scan WinWords stack and "extract" the info it should have passed to
    OleActivate() this has been tested with WinWord 2.0 and 2.0a.

    we expect future verisons of WinWord to pass the correct info to
    OleActivate() so we will never get here.

****************************************************************************/

BOOL NEAR PASCAL GetOpusRect(LPRECT lprcBound)
{
    LPRECT lprc;
    LPVOID lp;
//  int i,dx,dy;

    //
    //  see if the current app is WinWord
    //
    if (!IsApp("WINWORD.EXE"))
        return FALSE;

    //
    //  lets scan the stack looking for a RECT, this is a total
    //  hack to get MSWORD to work.
    //
    _asm
    {
        mov     bx,ss:[bp]      ; get saved BP              DllActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved BP        OleActivate()
        and     bx, not 1
        mov     bx,ss:[bx]      ; get saved saved saved BP  "winword"
        and     bx, not 1

        mov     word ptr lp[0], bx
        mov     word ptr lp[2], ss
    }

#ifdef DEBUG
    DPRINTF(("****** SCANING WINWORDs STACK ********"));
    lprc = lp;

    for (i=0; i<1000; i++)
    {
        dx = lprc->right  - lprc->left;
        dy = lprc->bottom - lprc->top;

        if (dx >= 158 && dx <= 162 &&
            dy >= 118 && dy <= 122)
        {
            DPRINTF(("found a RECT at offset %d, [%d, %d, %d, %d]",
                (LPBYTE)lprc - (LPBYTE)lp, PUSHRC(lprc)));
        }

        ((LPBYTE)lprc)++;
    }
    DPRINTF(("**************************************"));
#endif

    lprc = (LPRECT)((LPBYTE)lp + 6);

    if (lprc->right - lprc->left > 0 && lprc->bottom - lprc->top > 0)
    {
        DPRINTF(("*** HACK FOR WINWORD, [%d, %d, %d, %d]", PUSHRC(lprc)));
        *lprcBound = *lprc;
        return TRUE;
    }

    return FALSE;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllActivate (
LPOLEOBJECT     lpobj,
WORD            verb,
BOOL            fShow,
BOOL            fActivate,
HWND            hwnd,
LPRECT          lprcBound)
{
    OBJINFO *poi;
    RECT    rc;

    DPRINTF(("OleActivate(%lx, %d, %d, %d, %04X, [%d,%d,%d,%d])", lpobj, verb, fShow, fActivate, hwnd, PUSHRC(lprcBound)));

    //
    //  hack for Write
    //
    if (IsWindow(fActivate))
    {
        DPRINTF(("OleActivate: Write pre-realase work around"));
        hwnd = fActivate;
        fActivate = TRUE;
    }

    if (poi = FindObj(lpobj))
    {
        lpobjActive = lpobj;

        poi->hwnd = hwnd;

        if (poi->hwnd == NULL)
        {
            if (GetFocus())
            {
                DPRINTF(("OleActivate: no window specifed, using the focus window"));
                poi->hwnd = GetFocus();
            }
            else
            {
                DPRINTF(("OleActivate: no window specifed, using the active window"));
                poi->hwnd = GetActiveWindow();
            }
        }

        if (lprcBound && !IsRectEmpty(lprcBound))
        {
            poi->rcActivate = *lprcBound;
        }
        else
        {
            GetOpusRect(&poi->rcActivate);
        }

        //
        //  MS-Publisher gives use the *wrong* rectangle in the OleActivate call
        //  and never calls OleDraw() we are hosed!
        //
        //  so we check if the rect is off in space, and dont use it if so.
        //
        if (poi->hwnd)
        {
            GetClientRect(poi->hwnd, &rc);

            IntersectRect(&rc,&rc,&poi->rcActivate);

            if (IsRectEmpty(&rc))
            {
                DPRINTF(("OleActivate: rectangle specifed is not valid"));
                SetRectEmpty(&poi->rcActivate);
            }
        }

        if (IsRectEmpty(&poi->rcActivate))
        {
            DPRINTF(("OleActivate: stupid ole app!!!"));
        }

        //
        // Shove it in the registry
        //

        {
            RegSetGetData(poi, TRUE);
        }
    }

    return vtblDef.Activate(lpobj, verb, fShow, fActivate, hwnd, lprcBound);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllExecute (
LPOLEOBJECT     lpobj,
HANDLE          hCmds,
WORD            reserved)
{
    DPRINTF(("OleExecute(%ls)", GlobalLock(hCmds)));

    return vtblDef.Execute(lpobj, hCmds, reserved);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllClose (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleClose(%lx)", lpobj));

////DelObj(lpobj);

    return vtblDef.Close(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllUpdate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleUpdate()"));

    return vtblDef.Update(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllReconnect (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleReconnect()"));

    return vtblDef.Reconnect(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllObjectConvert (
LPOLEOBJECT     lpobj,
LPSTR           szProtocol,
LPOLECLIENT     lpClient,
LHCLIENTDOC     lhClientDoc,
LPSTR           szObjName,
LPOLEOBJECT FAR*lplpobj)
{
    OLESTATUS err;

    DPRINTF(("OleObjectConvert(%ls,%ls)", szProtocol, szObjName));

    err = vtblDef.ObjectConvert(lpobj, szProtocol, lpClient, lhClientDoc, szObjName, lplpobj);

    if (err <= OLE_WAIT_FOR_RELEASE)
        NewObj(*lplpobj);

    return err;
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllGetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE FAR *lpoleopt)
{
    DPRINTF(("OleGetLinkUpdateOptions()"));

    return vtblDef.GetLinkUpdateOptions(lpobj, lpoleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllSetLinkUpdateOptions (
LPOLEOBJECT     lpobj,
OLEOPT_UPDATE   oleopt)
{
    DPRINTF(("OleSetLinkUpdateOptions()"));

    return vtblDef.SetLinkUpdateOptions(lpobj, oleopt);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRename (
LPOLEOBJECT     lpobj,
LPSTR           szName)
{
    DPRINTF(("OleRename(%ls)", szName));

    return vtblDef.Rename(lpobj, szName);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryName (
LPOLEOBJECT     lpobj,
LPSTR           szObjName,
WORD FAR *      lpwSize)
{
    DPRINTF(("OleQueryName(%ls)", szObjName));

    return vtblDef.QueryName(lpobj, szObjName, lpwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryType (
LPOLEOBJECT     lpobj,
LPLONG          lpType)
{
    DPRINTF(("OleQueryType()"));

    return vtblDef.QueryType(lpobj, lpType);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryBounds (
LPOLEOBJECT     lpobj,
LPRECT          lprc)
{
    DPRINTF(("OleQueryBounds()"));

    return vtblDef.QueryBounds(lpobj, lprc);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQuerySize (
LPOLEOBJECT     lpobj,
DWORD FAR *     lpdwSize)
{
    DPRINTF(("OleQuerySize()"));

    return vtblDef.QuerySize(lpobj, lpdwSize);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryOpen (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOpen()"));

    return vtblDef.QueryOpen(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryOutOfDate (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryOutOfDate()"));

    return vtblDef.QueryOutOfDate(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryReleaseStatus (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseStatus()"));

    return vtblDef.QueryReleaseStatus(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllQueryReleaseError (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseError()"));

    return vtblDef.QueryReleaseError(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllRequestData (
LPOLEOBJECT     lpobj,
OLECLIPFORMAT   cf)
{
    DPRINTF(("OleRequestData(%d)", cf));

    return vtblDef.RequestData(lpobj, cf);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllObjectLong (
LPOLEOBJECT     lpobj,
WORD            w,
LPLONG          lpl)
{
    DPRINTF(("OleObjectLong()"));

    return vtblDef.ObjectLong(lpobj, w, lpl);
}

/****************************************************************************
****************************************************************************/

OLE_RELEASE_METHOD  FAR PASCAL _loadds DllQueryReleaseMethod (
LPOLEOBJECT     lpobj)
{
    DPRINTF(("OleQueryReleaseMethod()"));

    return vtblDef.QueryReleaseMethod(lpobj);
}

/****************************************************************************
****************************************************************************/

OLESTATUS       FAR PASCAL _loadds DllChangeData (
LPOLEOBJECT     lpobj,
HANDLE          h,
LPOLECLIENT     lpClient,
BOOL            f)
{
    DPRINTF(("OleChangeData()"));

    return vtblDef.ChangeData(lpobj, h, lpClient, f);
}

///////////////////////////////////////////////////////////////////////////////
//
//  DEBUG STUFF
//
///////////////////////////////////////////////////////////////////////////////

#ifdef DEBUG

void FAR cdecl dprintf(LPSTR szFormat, ...)
{
    char ach[128];

    extern FAR PASCAL OutputDebugStr(LPSTR);

    lstrcpy(ach, "MCIOLE: ");
    wvsprintf(ach + 8,szFormat,(LPSTR)(&szFormat+1));
    lstrcat(ach,"\r\n");

    OutputDebugString(ach);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mciole\shellapi.h ===
/*****************************************************************************\
*                                                                             *
* shellapi.h -  SHELL.DLL functions, types, and definitions                   *
*                                                                             *
*               Copyright (c) 1992, Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef _INC_SHELLAPI
#define _INC_SHELLAPI

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/* If included with Windows 3.0 windows.h: define 3.1-compatible types */

#ifndef _INC_WINDOWS

#define HDROP   HANDLE
#define WINAPI  FAR PASCAL
#define LPCSTR  LPSTR
#define UINT    WORD

#else

DECLARE_HANDLE(HDROP);

#endif

/* return codes from Registration functions */
#define ERROR_SUCCESS           0L
#define ERROR_BADDB             1L
#define ERROR_BADKEY            2L
#define ERROR_CANTOPEN          3L
#define ERROR_CANTREAD          4L
#define ERROR_CANTWRITE         5L
#define ERROR_OUTOFMEMORY       6L
#define ERROR_INVALID_PARAMETER 7L
#define ERROR_ACCESS_DENIED     8L

#define REG_SZ			1	    /* string type */

#define HKEY_CLASSES_ROOT	1

typedef DWORD HKEY;
typedef HKEY FAR* PHKEY;

LONG WINAPI RegOpenKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCreateKey(HKEY, LPCSTR, HKEY FAR*);
LONG WINAPI RegCloseKey(HKEY);
LONG WINAPI RegDeleteKey(HKEY, LPCSTR);
LONG WINAPI RegSetValue(HKEY, LPCSTR, DWORD, LPCSTR, DWORD);
LONG WINAPI RegQueryValue(HKEY, LPCSTR, LPSTR, LONG FAR*);
LONG WINAPI RegEnumKey(HKEY, DWORD, LPSTR, DWORD);

UINT WINAPI DragQueryFile(HDROP, UINT, LPSTR, UINT);
BOOL WINAPI DragQueryPoint(HDROP, POINT FAR*);
void WINAPI DragFinish(HDROP);
void WINAPI DragAcceptFiles(HWND, BOOL);

HICON WINAPI ExtractIcon(HINSTANCE hInst, LPCSTR lpszExeFileName, UINT nIconIndex);

/* error values for ShellExecute() beyond the regular WinExec() codes */
#define SE_ERR_SHARE            26
#define SE_ERR_ASSOCINCOMPLETE  27
#define SE_ERR_DDETIMEOUT       28
#define SE_ERR_DDEFAIL          29
#define SE_ERR_DDEBUSY          30
#define SE_ERR_NOASSOC          31

HINSTANCE WINAPI ShellExecute(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, int iShowCmd);
HINSTANCE WINAPI FindExecutable(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);
				 

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* RC_INVOKED */

#endif  /* _INC_SHELLAPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\comm.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   COMM.ASM
;
;   Copyright (c) Microsoft Corporation 1990. All rights reserved.
;
;   This module contains code to write a string to the COM port
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

        .286
        .xlist
        include cmacros.inc
;       include windows.inc
        .list

        WF_CPU286       equ 0002h

        ifdef DEBUG
            DEBUG_RETAIL equ 1
        endif

;       externA     __0040h                 ; in KERNEL
;       externA     __B000h                 ; in KERNEL

        externFP    OutputDebugString       ; in KERNEL

        externFP    wvsprintf               ; in USER

        SCREENWIDTH  equ 80
        SCREENHEIGHT equ 25
        SCREENBYTES  equ (SCREENWIDTH*2)
        DEFATTR      equ 07

        LASTLINE     equ ((SCREENHEIGHT-1)*SCREENBYTES)

BUFFER_SIZE = 256

;******************************************************************************
;
;   SEGMENTS
;
;******************************************************************************

createSeg _TEXT,    CodeRes, word, public, CODE
createSeg FIX,      CodeFix, word, public, CODE
createSeg INTDS,    DataFix, byte, public, DATA

;******************************************************************************
;
;   FIXED DATA
;
;******************************************************************************
ifdef DEBUG_RETAIL
sBegin  DataFix
        globalW fDebugOutput, 0
sEnd    DataFix
endif

;******************************************************************************
;
;   NON FIXED DATA
;
;******************************************************************************
ifdef DEBUG
sBegin  Data
        globalW _fDebug, 0
sEnd    Data
endif

ifdef DEBUG

sBegin  CodeRes
        assumes cs,CodeRes
        assumes ds,nothing
        assumes es,nothing

;******************************************************************************
;
;   dprintf    - output a MMSYSTEM debug string with formatting
;
;   if the mmsystem global fDebug==0, no ouput will be sent
;
;==============================================================================
        assumes ds,Data
        assumes es,nothing

?PLM=0
cProc   dprintf, <FAR, C, PUBLIC>, <>
        ParmD   szFormat
        ParmW   Args
        LocalV  szBuffer, BUFFER_SIZE
cBegin
        cmp     [_fDebug],0
        jz      dprintf_exit

        lea     ax,szBuffer
        lea     bx,Args
        cCall   wvsprintf, <ss,ax, szFormat, ss,bx>

        lea     ax,szBuffer
        push    ss
        push    ax
        call    far ptr OutputDebugStr

dprintf_exit:

cEnd
?PLM=1

sEnd

endif

;******************************************************************************
;
;******************************************************************************
sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,nothing
        assumes es,nothing

        externW CodeFixDS                       ; in STACK.ASM
        externW CodeFixWinFlags

ifdef DEBUG

;******************************************************************************
;
;   dout       - output a MMSYSTEM debug string
;
;   if the mmsystem global fDebug==0, no ouput will be sent
;
;==============================================================================
        assumes ds,Data
        assumes es,nothing

public  dout
dout   proc far

        cmp     [_fDebug],0
        jnz     OutputDebugStr
        retf 4

dout  endp

endif; DEBUG


;
;   in the retail version stub out the OutputDebugStr function
;
cProc   OutputDebugStr, <FAR, PASCAL, PUBLIC>, <>
        ParmD   szString
cBegin

        cCall   OutputDebugString, <szString>
cEnd

sEnd
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\debug.h ===
//==========================================================================;
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (c) 1992, 1993  Microsoft Corporation.  All Rights Reserved.
//
//--------------------------------------------------------------------------;
//
//  debug.h
//
//  Description:
//
//
//
//==========================================================================;

#ifndef _INC_DEBUG
#define _INC_DEBUG
#ifdef __cplusplus
extern "C"
{
#endif


//
//
//
//
#define DEBUG_MODULE_NAME       "MSMIXMGR"  // key name and prefix for output

#ifdef DEBUG
    #define DEBUG_SECTION       "Debug"     // section name for
    #define DEBUG_MAX_LINE_LEN  255         // max line length (bytes!)
#endif


//
//  based code makes since only in win 16 (to try and keep stuff out of
//  [fixed] data segments, etc)...
//
#ifndef BCODE
#ifdef WIN32
    #define BCODE
#else
    #define BCODE           _based(_segname("_CODE"))
#endif
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//  #pragma message(REMIND("this is a reminder"))
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef DEBUG

    #define D(x)        {x;}
    #define DPF(_x_)
    #define DPI(sz)     {static char BCODE ach[] = sz; OutputDebugStr(ach);}

#else

    #define D(x)
    #define DPF(_x_)
    #define DPI(sz)

#endif

#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\debug.asm ===
;--------------------------------------------------------------------------

ifdef	DEBUG
	DEBUG_RETAIL equ 1
endif	; ifdef DEBUG

;--------------------------------------------------------------------------
	?PLM = 1
	?WIN = 0
	PMODE = 1

        .xlist
        include cmacros.inc
        include windows.inc
	include mmsystem.inc
;       include logerror.inc
	include mmddk.inc
        .list

;--------------------------------------------------------------------------

;/* Error modifier bits */

ERR_WARNING             equ 08000h
ERR_PARAM               equ 04000h

;/* Generic parameter values */
ERR_BAD_VALUE           equ 06001h
ERR_BAD_FLAGS           equ 06002h
ERR_BAD_INDEX           equ 06003h
ERR_BAD_DVALUE          equ 07004h
ERR_BAD_DFLAGS          equ 07005h
ERR_BAD_DINDEX          equ 07006h
ERR_BAD_PTR             equ 07007h
ERR_BAD_FUNC_PTR        equ 07008h
ERR_BAD_SELECTOR        equ 06009h
ERR_BAD_STRING_PTR      equ 0700ah
ERR_BAD_HANDLE          equ 0600bh

;/* KERNEL parameter errors */
ERR_BAD_HINSTANCE       equ 06020h
ERR_BAD_HMODULE         equ 06021h
ERR_BAD_GLOBAL_HANDLE   equ 06022h
ERR_BAD_LOCAL_HANDLE    equ 06023h
ERR_BAD_ATOM            equ 06024h
ERR_BAD_HFILE           equ 06025h

;/* USER parameter errors */
ERR_BAD_HWND            equ 06040h
ERR_BAD_HMENU           equ 06041h
ERR_BAD_HCURSOR         equ 06042h
ERR_BAD_HICON           equ 06043h
ERR_BAD_HDWP            equ 06044h
ERR_BAD_CID             equ 06045h
ERR_BAD_HDRVR           equ 06046h

DBF_TRACE           equ 00000h
DBF_WARNING         equ 04000h
DBF_ERROR           equ 08000h
DBF_FATAL           equ 0c000h

; [Windows] DebugFilter and flags values

DBF_INTERNAL        equ 02000h
DBF_KERNEL          equ 01000h
DBF_USER            equ 00800h
DBF_GDI             equ 00400h
DBF_COMPAT          equ 00200h
DBF_LOGERROR        equ 00100h
DBF_PARAMERROR      equ 00080h
DBF_MMSYSTEM        equ 00040h
DBF_PENWIN          equ 00020h

;--------------------------------------------------------------------------

AssertF macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jnz     assert_ok
        int     3
assert_ok:
endif
        endm

AssertT macro reg
        local   assert_ok
ifdef DEBUG
        or      reg,reg
        jz      assert_ok
        int     3
assert_ok:
endif
        endm

;--------------------------------------------------------------------------
;
; DebugErr() macro
;
ifdef DEBUG_RETAIL

externFP    _DebugOutput

DebugErr    macro   flags,msg
        local   a,b

        push    cs
        push    offset a
        push    flags or DBF_MMSYSTEM
        call    _DebugOutput
        add     sp,6
        jmp     short b
a:
        db      "MMSYSTEM: "
        db      msg
        db      13,10,0
b:
endm

else    ; DEBUG

DebugErr    macro   flags,msg
endm

endif   ; DEBUG

;--------------------------------------------------------------------------

; Define the return address as a type using the DefD macro in order to
; be able to pass it as a parameter to the LogParamError function.
ReturnAddr equ (dword ptr [bp+2])
DefD ReturnAddr

;--------------------------------------------------------------------------

NSTYPE			equ 00007h	; Segment type mask
NSCODE			equ 00000h	; Code segment
NSDATA			equ 00001h	; Data segment
NSITER			equ 00008h	; Iterated segment flag
NSMOVE			equ 00010h	; Movable segment flag
NSPURE			equ 00020h	; Pure segment flag
NSPRELOAD		equ 00040h	; Preload segment flag
NSRELOC			equ 00100h	; Segment has relocations
NSDEBUG			equ 00200h	; Segment has debug info
NSDPL			equ 00C00h	; 286 DPL bits
NSDISCARD		equ 01000h	; Discard bit for segment

CODEINFO	struc
	ns_sector	dw	?	; File sector of start of segment
	ns_cbseg	dw	?	; Number of bytes in file
	ns_flags	dw	?	; Attribute flags
	ns_minalloc	dw	?	; Minimum allocation in bytes
	ns_handle	dw	?	; handle to object
	ns_align	dw	?	; file alignment
CODEINFO	ends

DSC_CODE_BIT	equ	08h

;--------------------------------------------------------------------------

;**************************************************************************;
;   IF YOU CHANGE THESE TYPES YOU MUST ALSO CHANGE THE ONES IN MMSYSI.H
;**************************************************************************;
TYPE_WAVEOUT		equ	1
TYPE_WAVEIN		equ	2
TYPE_MIDIOUT		equ	3
TYPE_MIDIIN		equ	4
TYPE_MMIO               equ     5
TYPE_IOPROC             equ     6
TYPE_MCI                equ     7
TYPE_DRVR               equ     8
TYPE_MIXER              equ     9
;**************************************************************************;

;--------------------------------------------------------------------------

;**************************************************************************;
;   IF YOU CHANGE THIS STRUCTURE YOU MUST ALSO CHANGE THE ONE IN MMSYSI.H
;**************************************************************************;
HNDL	struc
	hndlNext	dw	?	; link to next handle
	hndlType	dw	?	; type of handle wave, midi, mmio, ...
	hndlTask	dw	?	; task that owns it
HNDL	ends
;**************************************************************************;

;--------------------------------------------------------------------------

externW		_pHandleList
externA		__AHINCR
externA		__WINFLAGS
externFP	LogParamError		;(WORD wError, FARPROC lpfn, DWORD dValue);
externFP	LocalAlloc		;(WORD fwFlags, WORD wSize);
externFP	LocalFree		;(LOCALHANDLE h);
externFP	IsWindow		;(HWND hwnd);
externFP	GetCodeInfo		;(FARPROC lpfnProc, LPVOID lpSegInfo);
externFP	GetCurrentTask		;(void);
externFP	IsTask			;(HANDLE hTask);

; Windows internal pointer validation tools.
externFP	IsBadReadPtr		;(LPVOID lp, WORD cb);
externFP	IsBadWritePtr		;(LPVOID lp, WORD cb);
externFP	IsBadHugeReadPtr	;(LPVOID lp, DWORD cb);
externFP	IsBadHugeWritePtr	;(LPVOID lp, DWORD cb);
externFP	IsBadCodePtr		;(FARPROC lp);
externFP	IsBadStringPtr		;(LPSTR lpsz, WORD wMaxLen);
externFP	IsSharedSelector	;(WORD wSelector);

;--------------------------------------------------------------------------
sBegin Data

sEnd Data

;--------------------------------------------------------------------------

createSeg _TEXT, CodeRes, word, public, CODE
createSeg FIX,   CodeFix, word, public, CODE

sBegin  CodeRes
        assumes cs, CodeRes
	assumes ds, Data

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func HANDLE | NewHandle | allocate a fixed handle in MMSYSTEM's local heap
;
; @parm  WORD | wType | unique id describing handle type
; @parm  WORD | wSize | size in bytes to be allocated
;
; @rdesc Returns pointer/handle to memory object
;
; @comm a standard handle header (HNDL) will be added to the object,
;       and it will be linked into the list of MMSYSTEM handles.
;
cProc	NewHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	wType
	parmW	wSize
cBegin
	mov	ax, wSize		; Attempt to allocate local memory
	add	ax, SIZE HNDL		; Add header to requested size first
        cCall   LocalAlloc, <LPTR, ax>
        AssertF ax
	or	ax, ax
	jz	NewHandle_Exit		; Return NULL
	mov	bx, ax
        mov     ax, [_pHandleList]      ; Put the head of the list as the
	mov	[bx].hndlNext, ax	; next pointer
	cCall	GetCurrentTask, <>
	mov	[bx].hndlTask, ax	; Set task for new handle
	mov	ax, wType		; Set type for new handle
	mov	[bx].hndlType, ax
        mov     [_pHandleList], bx      ; Make new handle head of list
	lea	ax, [bx + SIZE HNDL]	; Return data portion of handle
NewHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func HANDLE | FreeHandle | free handle allocated with NewHandle
;
; @parm HANDLE | hLocal | handle returned from NewHandle
;
; @comm handle will be unlinked from list, and memory will be freed with
;       LocalFree
;
cProc   FreeHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	hLocal
cBegin
        mov     ax, hLocal
        AssertF ax
        or      ax, ax
        jz      FreeHandle_Exit         ; NULL handle returns NULL
        sub     ax, SIZE HNDL           ; Get real handle from data portion
        lea     bx, [_pHandleList]      ; Pointer to first pointer
        errnz   hndlNext		; Assume this is the first element

FreeHandle_Search:
        mov     dx, [bx].hndlNext       ; get pointer to next handle
        cmp     dx, ax                  ; If this is the handle
        je      FreeHandle_Free         ; Free it

	mov	bx, dx			; advance to next handle.
        or      bx, bx                  ; Check for end of list
        jnz     FreeHandle_Search
	AssertF bx			; bx == 0 force a fail
	jmp	FreeHandle_Exit 	; Handle not found, so return handle

FreeHandle_Free:
        xchg    ax, bx                  ; BX --> handle
	xor	dx, dx			; Zero out entries for better debugging
        mov     [bx].hndlType, dx
        mov     [bx].hndlTask, dx
        xchg    [bx].hndlNext, dx       ; Get next handle in list
        xchg    ax, bx                  ; BX --> prev handle
	mov	[bx].hndlNext, dx	; update link
        cCall   LocalFree, <ax>         ; Free handle found, returning error
	AssertT ax

FreeHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL WAVE MIDI
;
; @func BOOL | ValidateHeader | validates a wave or midi date header
;
; @parm LPVOID | lpHeader| pointer to wave/midi header
; @parm  WORD  | wSize  | size of header passed by app
; @parm  WORD  | wType  | unique id describing header/handle type
;
; @rdesc Returns TRUE  if <p> is non NULL and <wSize> is the correct size
;        Returns FALSE otherwise
;
; @comm  if the header is invalid an error will be generated.
;

cProc   ValidateHeader, <FAR, PUBLIC, PASCAL> <>
        parmD   lpHeader
	parmW	wSize
	parmW	wType
cBegin
        cCall   IsBadWritePtr, <lpHeader, wSize>
	or	ax, ax			; If fail,
        jnz     vValidateHeader_Fail_Header_Ptr

        mov     ax, wType
        mov     dx, SIZE WAVEHDR        ; assume WAVEHDR
        mov     cx, not WHDR_VALID

        cmp     ax, TYPE_WAVEIN         ; If wave out
        jbe     ValidateHeader_Size
        errnz   TYPE_WAVEOUT-1
        errnz   TYPE_WAVEIN-2

        mov     dx, SIZE MIDIHDR        ; Set MIDIHDR
        mov     cx, not MHDR_VALID

ValidateHeader_Size:
	cmp	dx, wSize		; Compare against given size
        jne     ValidateHeader_Fail_Size; Fail if wrong size, LogParamError

        les     bx, lpHeader            ; Load lpData pointer

        mov     ax,es:[bx].dwWaveFlags.lo
        test    ax,cx
        jnz     ValidateHeader_Fail_Flags

	push	es:[bx].lpWaveData.hi	; Validate data pointer
	push	es:[bx].lpWaveData.lo
	push	es:[bx].dwWaveBufferLength.hi
	push	es:[bx].dwWaveBufferLength.lo
        cCall   IsBadHugeWritePtr, <>
        or      ax,ax
        jnz     vValidateHeader_Fail_Buffer_Ptr
        errn$   ValidateHeader_Exit

ValidateHeader_Exit:
        not     ax
cEnd

ValidateHeader_Fail_Exit:
        mov     ax, -1                  ; Return FALSE
        jmp     short ValidateHeader_Exit

vValidateHeader_Fail_Header_Ptr:
        jmp     ValidateHeader_Fail_Header_Ptr

vValidateHeader_Fail_Buffer_Ptr:
        jmp     ValidateHeader_Fail_Buffer_Ptr

ValidateHeader_Fail_Size:
        DebugErr DBF_ERROR, "Invalid header size."
        cCall   LogParamError, <ERR_BAD_VALUE, ReturnAddr, 0, wSize>
        jmp     short ValidateHeader_Fail_Exit

ValidateHeader_Fail_Flags:
        cCall   LogParamError, <ERR_BAD_FLAGS, ReturnAddr, 0, ax>
        jmp     short ValidateHeader_Fail_Exit

ValidateHeader_Fail_Header_Ptr:
        DebugErr DBF_ERROR, "Invalid header pointer."
        cCall   LogParamError, <ERR_BAD_PTR, ReturnAddr, lpHeader>
        jmp     ValidateHeader_Fail_Exit

ValidateHeader_Fail_Buffer_Ptr:
        DebugErr DBF_ERROR, "Invalid buffer pointer."
        push    ERR_BAD_PTR
        push    ReturnAddr.hi
        push    ReturnAddr.lo
        les     bx,lpHeader
        push    es:[bx].lpWaveData.hi
        push    es:[bx].lpWaveData.lo
        cCall   LogParamError
        jmp     ValidateHeader_Fail_Exit

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateReadPointer | validates that a pointer is valid to
;	read from.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateReadPointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
        cCall   IsBadHugeReadPtr, <lpPoint, dLen>
        or      ax,ax
        jz      ValidateReadPointer_Exit        ; Return TRUE

	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE

ValidateReadPointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateWritePointer | validates that a pointer is valid to
;	write to.
;
; @parm LPVOID | lpPoint| pointer to validate
; @parm DWORD  | dLen   | supposed length of said pointer
;
; @rdesc Returns TRUE  if <p> is a valid pointer
;        Returns FALSE if <p> is not a valid pointer
;
; @comm will generate error if the pointer is invalid
;
cProc	ValidateWritePointer, <FAR, PUBLIC, PASCAL> <>
	parmD	lpPoint
	parmD	dLen
cBegin
	cCall	IsBadHugeWritePtr, <lpPoint, dLen>
        or      ax,ax                           ; If not fail,
        jz      ValidateWritePointer_Exit       ; Return TRUE
	cCall	LogParamError, <ERR_BAD_PTR, ReturnAddr, lpPoint>
        mov     ax,-1                           ; Return FALSE
ValidateWritePointer_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func WORD | ValidDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns 0  if <dwCallback> is a valid callback
;        Returns error condition if <dwCallback> is not a valid callback
;
cProc	ValidDriverCallback, <NEAR, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
	localV	ci, %(SIZE CODEINFO)
cBegin
	mov	ax, wFlags			; switch on callback type
	and	ax, DCB_TYPEMASK
	errnz	<DCB_NULL>
	jnz	ValidDriverCallback_Window	; case DCB_NULL
        jmp     ValidDriverCallback_Exit        ; return zero for success

ValidDriverCallback_Window:
	dec	ax
	errnz	<DCB_WINDOW - 1>
	jnz	ValidDriverCallback_Task	; case DCB_WINDOW
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadWindow	; Set error
	push	dCallback.lo			; Check for valid HWND
	cCall	IsWindow, <>
	or	ax, ax				; If HWND,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadWindow:                  ; Else set error return
	mov	ax, ERR_BAD_HWND
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Task:
	dec	ax
	errnz	<DCB_TASK - 2>
	jnz	ValidDriverCallback_Function	; case DCB_TASK
	cmp	dCallback.hi, 0			; HIWORD must be NULL
	jnz	ValidDriverCallback_BadTask	; Set error
	push	dCallback.lo			; Check for valid Task
	cCall	IsTask, <>
	or	ax, ax				; If Task,
        jnz     ValidDriverCallback_Success     ; Set successful return

ValidDriverCallback_BadTask:			; Else set error return
	mov	ax, ERR_BAD_HANDLE
        jmp     ValidDriverCallback_Exit        ; Return error

ValidDriverCallback_Function:
	dec	ax
        errnz   <DCB_FUNCTION - 3>              ; case DCB_FUNCTION
        jnz     ValidDriverCallback_Default
	lea	ax, ci
	cCall	GetCodeInfo, <dCallback, ss, ax>
	or	ax, ax
	jz	ValidDriverCallback_BadFunction	; Set error return
	mov	ax, ci.ns_flags			; Check for valid flags
	and	ax, NSDATA or NSMOVE or NSDISCARD
        jz      ValidDriverCallback_Exit        ; Return zero for success
        jnz     ValidDriverCallback_BadFunction

ValidDriverCallback_Default:
	mov	ax, ERR_BAD_FLAGS		; default to error condition
        jmp     ValidDriverCallback_Exit

ValidDriverCallback_Success:
        xor     ax, ax

ValidDriverCallback_Exit:
cEnd

ValidDriverCallback_BadFunction:                ; Else set error return
        DebugErr DBF_ERROR, "Driver callbacks MUST be in a FIXED segment of a DLL."
	mov	ax, ERR_BAD_FUNC_PTR
        jmp     ValidDriverCallback_Exit        ; Return error

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateDriverCallback |
;
;  validates that a driver callback is valid, to be valid a driver
;  callback must be a valid window, task, or a function in a FIXED DLL
;  code segment.
;
; @parm DWORD  | dwCallback | callback to validate
; @parm  WORD  | wFlags     | driver callback flags
;
; @rdesc Returns TRUE  if <dwCallback> is a valid callback
;        Returns FALSE if <dwCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateDriverCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
	parmW	wFlags
cBegin
	cCall	ValidDriverCallback, <dCallback, wFlags>
	or	ax, ax				; If no error return
	jz	ValidateDriverCallback_Exit	; Return TRUE
	cCall	LogParamError, <ax, ReturnAddr, dCallback>
	mov	ax, -1				; Return FALSE
ValidateDriverCallback_Exit:
	not	ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateCallback |
;
;  validates that a callback is valid.
;
; @parm FARPROC  | dCallback | callback to validate
;
; @rdesc Returns TRUE  if <lpfnCallback> is a valid callback
;        Returns FALSE if <lpfnCallback> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
cProc	ValidateCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	dCallback
cBegin
	cCall	IsBadCodePtr, <dCallback>
        or      ax,ax                           ; If not fail,
        jz      ValidateCallback_Exit           ; Return TRUE
	cCall	LogParamError, <ERR_BAD_FUNC_PTR, ReturnAddr, dCallback>
        mov     ax, -1                          ; Return FALSE
ValidateCallback_Exit:
        not     ax
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateString |
;
cProc	ValidateString, <FAR, PUBLIC, PASCAL> <>
        parmD   lsz
        parmW   max_len
cBegin
        cCall   IsBadStringPtr, <lsz, max_len>  ; Maximum length
        or      ax,ax                           ; If not fail,
        jz      ValidateString_Exit             ; Return TRUE
	cCall	LogParamError, <ERR_BAD_STRING_PTR, ReturnAddr, lsz>
        mov     ax, -1                          ; Return FALSE
ValidateString_Exit:
        not     ax
cEnd

sEnd

;--------------------------------------------------------------------------

sBegin  CodeFix
        assumes cs, CodeFix
        assumes ds, nothing

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateHandle | validates a handle created with NewHandle
;
; @parm HANDLE | hLocal | handle returned from NewHandle
; @parm WORD   | wType  | unique id describing handle type
;
; @rdesc Returns TRUE  if <h> is a valid handle of type <wType>
;        Returns FALSE if <h> is not a valid handle
;
; @comm  if the handle is invalid an error will be generated.
;
;--------------------------------------------------------------------------
        assumes ds, Data
        assumes es, nothing

cProc	ValidateHandle, <FAR, PUBLIC, PASCAL> <>
	parmW	hLocal
	parmW	wType
cBegin
        mov     bx, hLocal
        sub     bx, SIZE HNDL           ; Get actual handle
        jc      ValidateHandle_Bad

	mov	ax, ds
        lsl     ax, ax                  ; Get DS limit
        cmp     bx, ax                  ; Check for out of limit
        jae     ValidateHandle_Bad

        mov     ax,[bx].hndlType
        cmp     ax, wType               ; Compare handle type
        je      ValidateHandle_Exit     ; Types are the same, return TRUE

ValidateHandle_Bad:
        add     bx, SIZE HNDL
        cCall   LogParamError, <ERR_BAD_HANDLE, ReturnAddr, 0, bx>
        xor     ax, ax                  ; Return FALSE

ValidateHandle_Exit:
cEnd

;--------------------------------------------------------------------------
; @doc INTERNAL
;
; @func BOOL | ValidateTimerCallback |
;
;  validates that a timer callback is valid, to be valid a driver
;  callback must be a valid function in a FIXED DLL code segment.
;
; @parm LPTIMECALLBACK  | lpfn | callback to validate
;
; @rdesc Returns TRUE  if <lpfn> is a valid callback
;        Returns FALSE if <lpfn> is not a valid callback
;
; @comm will generate error if the callback is invalid
;
;--------------------------------------------------------------------------
        assumes ds, nothing
        assumes es, nothing

cProc	ValidateTimerCallback, <FAR, PUBLIC, PASCAL> <>
	parmD	lpfn
cBegin
	mov	ax, lpfn.hi
	lar	bx, ax
	jnz	ValidateTimerCallback_Fail	; Invalid segment
	test	bh, DSC_CODE_BIT
	jz	ValidateTimerCallback_Fail	; Not executable segment
	lsl	cx, ax				; Get segment limit
	mov	bx, lpfn.lo
	cmp	bx, cx
	jae	ValidateTimerCallback_Fail	; Invalid offset
	mov	es, ax
	mov	bx, es:[bx]+2
	cmp	bx, 0581eH			; push ds, pop ax
	je	ValidateTimerCallback_Fail	; Invalid entry point
	cmp	bx, 0d88cH			; mov ax, ds
	jne	ValidateTimerCallback_Exit	; Return TRUE
ValidateTimerCallback_Fail:
	cCall	LogParamError, <ERR_BAD_FUNC_PTR, ReturnAddr, lpfn>
	xor	ax, ax				; Return FALSE
ValidateTimerCallback_Exit:
cEnd

sEnd    CodeFix

;--------------------------------------------------------------------------

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\dosa.asm ===
title	dosa.asm
;
; ASM routines lifted from WINCOM
;
; ToddLa & RussellW
;
; DavidLe removed all but current drive/directory functions
;
?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention
PMODE=1     ; Enable enter/leave

        .xlist
        include cmacros.inc
        .list

; -------------------------------------------------------
;               DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes CS,CodeSeg
        assumes DS,Data
        assumes ES,nothing

; ----------------------------------------------------------------
;
; @doc	INTERNAL
; @api  int | DosChangeDir | This function changes the current drive
; and directory.
;
; @parm LPSTR | lpszPath | Points to the desired drive and directory path.
; The optional drive identifier must be the first character, followed by
; a colon.  The drive identifier is followed by an optional path
; specification, which may be relative or absolute.
;
; @rdesc Returns one of the following values:
;
; @flag	1	The drive and directory were successfully changed.
; @flag	0	The specified pathname is invalid.  The drive and
;		current directory is restored
;		to the default values when the function was called.
; @flag	-1	The specified drive is invalid.  The drive and directory
;		current directory is restored to the default values when the
;		function was called.
;
; @xref	DosGetCurrentDir, DosGetCurrentPath, DosGetCurrentDrive
;
szCurDir:
        db '.',0

cProc	DosChangeDir,<PUBLIC, FAR, PASCAL>, <ds>
	parmD	lpszPath

	LocalW	fDriveChange
	LocalW	wLastDrive
	LocalW	wReturn
	LocalV	szPoint, 2
cBegin
	mov	fDriveChange, 0

	lds	dx, lpszPath
	mov	bx, dx

	; Check if a drive was specified.  If not, then go direct to ChDir
	cmp	BYTE PTR ds:[bx+1],':'	; no drive allowed
	jnz	chdnodrive

	;  get the current drive to save it in case the drive change/
	;  dir change fails, so we can restore it.
	mov	ah, 19h
	int	21h
	mov	wLastDrive, ax

	mov	fDriveChange, 1		; flag the drive change

	;  Now, change the drive to that specified in the input
	;  string.
	mov	dl, ds:[bx]		; Get the drive letter
	or	dl, 20h			; lower case it
	sub	dl, 'a'			; and adjust so 0 = a:, 1 = b:, etc

	mov	ah, 0eh			; set current drive
	int	21h

	mov	ah, 19h			; get current drive
	int	21h

	cmp	al, dl			; check that chDrive succeeded
	jne	chdDriveError

	;  as a further test of whether the drive change took, attempt
	;  to change to the current directory on the new drive.
        mov     ax, cs
	mov	ds, ax
        mov     dx, CodeSegOFFSET szCurDir
	mov	ah, 3bh
	int	21h
	jc	chdDriveError

	lds	dx, lpszPath
	add	dx, 2			; skip over the drive identifier
	mov	bx, dx
	;; if they passed only drive: without dir path, then end now
	cmp	BYTE PTR ds:[bx], 0	; if path name is "", we are there
	jz	chdok

chdnodrive:
	mov	ah, 3bh
	int	21h
	jc	chdPathError
chdok:
	mov	ax, 1
chdexit:
cEnd

chdPathError:
	mov	wReturn, 0
	jmp	short chderror

chdDriveError:
	mov	wReturn, -1

chderror:
	;  if a drive change occurred, but the CD failed, change
	;  the drive back to that which was the original drive
	;  when entered.
	mov	ax, fDriveChange
	or	ax, ax
	jz	chdNoCD
	
	mov	dx, wLastDrive
	mov	ah, 0eh
	int	21h
	mov	ax, wReturn
	jmp	short chdexit
chdNoCD:
	xor	ax, ax			; return zero on error
	jmp	short chdexit




; ----------------------------------------------------------------
;
; @doc	INTERNAL
; @api  WORD | DosGetCurrentDrive | This function returns the drive identifier
;	of the current drive.
; @rdesc        Returns the drive code of the current drive: 0 is drive
;		A:, 1 is drive B:, etc.
;
; @comm This function assumes that drive A: is zero. Some
;	other DOS functions assume drive A: is one.
;
; @xref	DosSetCurrentDrive
;

cProc	DosGetCurrentDrive,<PUBLIC, FAR, PASCAL>
cBegin
	mov	ah, 19h		; Get Current Drive
	int	21h
	sub	ah, ah		; Zero out AH
cEnd


; ----------------------------------------------------------------
;
; @doc	INTERNAL WINCOM
; @api	WORD | DosSetCurrentDrive | This function sets the current DOS
;		drive to be the specified drive.
;
; @parm	WORD | wDrive | Specifies the drive to be set as the current drive.
;               0 indicates drive A:, 1 is B:, etc.
;
; @rdesc	Returns TRUE if the drive change was successful, or FALSE
;               if the current drive was not changed.
;
; @comm         This is the same range returned by <f DosGetCurrentDrive>.
;               Other functions assume drive A: is 1.
;
;
; @xref	DosGetCurrentDrive
;

cProc	DosSetCurrentDrive,<FAR, PUBLIC, PASCAL>
ParmW Drive
cBegin
	mov     dx, Drive
	mov     ah, 0Eh		; Set Current Drive
	int     21h

	; Check if successful
	mov	ah, 19h		; get current drive
	int	21h

	cmp	al, dl		; check that chDrive succeeded
	jne	SetDriveError
	mov	ax, 1h		; return true on success
SetDriveExit:
cEnd
SetDriveError:
	xor	ax, ax		; return false on error
	jmp	short SetDriveExit



; ----------------------------------------------------------------
;
; @doc	INTERNAL WINCOM
;
; @api	WORD | DosGetCurrentDir | This function copies the current
; directory of the specified drive into a caller-supplied buffer.  This
; function differs from the <f DosGetCurrentPath> function in that it
; copies only the current directory of the specified drive, whereas
; <f DosGetCurrentPath> copies the current drive and its current directory
; into the caller's buffer.
;
; @parm	WORD | wCurdrive | Specifies the drive.  0 is the default drive,
;		1 is drive A, 2 is drive B, etc.
;
; @parm	LPSTR | lpszBuf | Points to the buffer in which to place the
; current directory.  This buffer must be 66 bytes in length.
; The returned directory name will always have a leading '\' character.
;
; @rdesc Returns NULL if the function succeeded.  Otherwise, it returns
; the DOS error code.
;
; @comm The drive identifier value specified by <p wCurdrive>
;	assumes that drive A: is one, whereas the <f DosGetCurrentDrive>
;	function assumes that drive A: is zero.
;
; @xref	DosGetCurrentDrive, DosChangeDir, DosGetCurrentPath
;

cProc	DosGetCurrentDir,<PUBLIC,FAR,PASCAL>,<si,di,ds>
	parmW	wCurdrive
	parmD	lpDest
cBegin
	cld
	les	di, lpDest	; es:di = lpDest
	mov	al, '\'
	stosb
	push	es
	pop	ds		; ds = es
	mov	si, di		; ds:si = lpDest + 1
	; Add NULL char for case of error
	xor	al, al
	stosb			; null terminate in case of error
	
	mov	ah, 47h		; GetCurrentDirectory
	mov	dx, wCurdrive	; of this drive
	int	21h
	jc	CWDexit		; return error code for failure
	xor	ax, ax		; return NULL on success
CWDexit:
cEnd

sEnd	CodeSeg

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvr.h ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   drvr.h - Installable driver code internal header file.

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI Based on windows 3.1 installable driver code by davidds

*****************************************************************************/

typedef LRESULT (CALLBACK *DRIVERPROC)
        (DWORD dwDriverID, HDRVR hDriver, UINT wMessage, LPARAM lParam1, LPARAM lParam2);

typedef struct tagDRIVERTABLE
{
  WORD    fFirstEntry:1;
  WORD    fBusy:1;
  DWORD   dwDriverIdentifier;
  WORD    hModule;
  DRIVERPROC lpDriverEntryPoint;
} DRIVERTABLE;
typedef DRIVERTABLE FAR *LPDRIVERTABLE;

LONG FAR PASCAL InternalBroadcastDriverMessage(WORD, WORD, LONG, LONG, WORD);
LONG FAR PASCAL InternalCloseDriver(WORD, LONG, LONG, BOOL);
LONG FAR PASCAL InternalOpenDriver(LPSTR, LPSTR, LONG, BOOL);
LONG FAR PASCAL InternalLoadDriver(LPSTR, LPSTR, LPSTR, WORD, BOOL);
WORD FAR PASCAL InternalFreeDriver(WORD, BOOL);
void FAR PASCAL InternalInstallDriverChain (void);
void FAR PASCAL InternalDriverDisable (void);
void FAR PASCAL InternalDriverEnable (void);
int  FAR PASCAL GetDrvrUsage(HANDLE);
HANDLE FAR PASCAL LoadAliasedLibrary (LPSTR, LPSTR, LPSTR, LPSTR, WORD);
void NEAR PASCAL DrvInit(void);

/* Defines for internalbroadcastdrivermessage flags */
#define IBDM_SENDMESSAGE       0x0001
#define IBDM_REVERSE           0x0002
#define IBDM_ONEINSTANCEONLY   0x0004
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvproc.c ===
/*
    drvproc.c

    contains MMSYSTEMs DriverProc

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/

#include <windows.h>
#include <mmsysver.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "drvr.h"
#include "mmioi.h"

extern IOProcMapEntry NEAR * gIOProcMapHead;   // in MMIO.C

/****************************************************************************

    internal prototypes

****************************************************************************/

static void FAR PASCAL SetPrivateProfileInt(LPSTR szSection, LPSTR szKey, int i, LPSTR szIniFile);

static BYTE    fFirstTime=TRUE;         // First enable

extern BOOL FAR PASCAL DrvLoad(void);   // in init.c
extern BOOL FAR PASCAL DrvFree(void);
extern char far szStartupSound[];       // in mmwnd.c

static  SZCODE  szExitSound[]   = "SystemExit";

#ifdef DEBUG_RETAIL
        extern  char far szMMSystem[];
        extern  char far szSystemIni[];
        extern  char far szDebugOutput[];
        extern  char far szMci[];

//      extern  WORD    fDebugOutput;
        extern  int     DebugmciSendCommand;        // in MCI.C
#ifdef DEBUG
        extern  char far szDebug[];
        extern  WORD    fDebug;
#endif
#endif

void NEAR PASCAL AppExit(HTASK hTask, BOOL fNormalExit);

/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   LRESULT | DriverProc | This is the standard DLL entry point. It is
 *        called from user (3.1) or mmsound.drv (3.0) when MMSYSTEM.DLL is
 *        loaded, enabled, or disabled.
 *
 ****************************************************************************/
LRESULT CALLBACK
DriverProc(
    DWORD dwDriver,
    HDRVR hDriver,
    UINT wMessage,
    LPARAM lParam1,
    LPARAM lParam2
    )
{
    switch (wMessage)
        {
        case DRV_LOAD:
            //
            //  first load message, initialize mmsystem.
            //  sent from USER when loading drivers from drivers= line
            //
            if (fFirstTime)
                return (LRESULT)(LONG)DrvLoad();

            //
            //  a normal load message, a app is trying to open us
            //  with OpenDriver()
            //
            break; // return success all other times (1L)

        case DRV_FREE:
            //
            //  a free message, this is send just before the DLL is unloaded
            //  by the driver interface.
            //
            //  sent by user just before system exit, after sending
            //  the DRV_DISABLE message.
            //
            DrvFree();
            break;         // return success (1L)

        case DRV_OPEN:     // FALL-THROUGH
        case DRV_CLOSE:
            break;         // return success (1L)

        case DRV_ENABLE:
            DOUT("MMSYSTEM: Enable\r\n");
            fFirstTime = FALSE;
            break;         // return success (1L)

        case DRV_DISABLE:
            DOUT("MMSYSTEM: Disable\r\n");
            break;         // return success (1L)

        //
        //  sent when a application is terminating
        //
        //  lParam1:
        //      DRVEA_ABNORMALEXIT
        //      DRVEA_NORMALEXIT
        //
        case DRV_EXITAPPLICATION:
            AppExit(GetCurrentTask(), (BOOL)lParam1 == DRVEA_NORMALEXIT);
            break;

        case DRV_EXITSESSION:
            sndPlaySound(szExitSound, SND_SYNC | SND_NODEFAULT);
            break;

#ifdef  DEBUG_RETAIL
        case MM_GET_DEBUG:
            break;

        case MM_GET_DEBUGOUT:
            return (LRESULT)(LONG)fDebugOutput;

        case MM_SET_DEBUGOUT:
            fDebugOutput = (BYTE)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szDebugOutput,fDebugOutput,szSystemIni);
            break;

        case MM_GET_MCI_DEBUG:
            return (LRESULT)(LONG)DebugmciSendCommand;

        case MM_SET_MCI_DEBUG:
            DebugmciSendCommand = (WORD)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szMci,DebugmciSendCommand,szSystemIni);
            break;

#ifdef DEBUG
        case MM_GET_MM_DEBUG:
            return (LRESULT)(LONG)fDebug;

        case MM_SET_MM_DEBUG:
            fDebug = (BYTE)(LONG)lParam1;
            SetPrivateProfileInt(szMMSystem,szDebug,fDebug,szSystemIni);
            break;

#ifdef DEBUG
        case MM_DRV_RESTART:
            break;
#endif


        case MM_HINFO_MCI:
            if ((HLOCAL)(LONG)lParam2 == (HLOCAL)NULL)
                return (LRESULT)(LONG)MCI_wNextDeviceID;
            if (MCI_VALID_DEVICE_ID((UINT)(LONG)lParam1))
            {
                *(LPMCI_DEVICE_NODE)lParam2 = *MCI_lpDeviceList[(UINT)(LONG)lParam1];
                break;
            }
            return (LRESULT)FALSE;

        case MM_HINFO_NEXT:
            if ((HLOCAL)(LONG)lParam1 == (HLOCAL)NULL)
                return (LRESULT)(LONG)(UINT)GetHandleFirst();
            else
                return (LRESULT)(LONG)(UINT)GetHandleNext((HLOCAL)(LONG)lParam1);

        case MM_HINFO_TASK:
            return (LRESULT)(LONG)(UINT)GetHandleOwner((HLOCAL)(LONG)lParam1);

        case MM_HINFO_TYPE:
            return GetHandleType((HLOCAL)(LONG)lParam1);

#endif   // ifdef DEBUG
#endif   // ifdef DEBUG_RETAIL

        default:
            return DefDriverProc(dwDriver, hDriver, wMessage, lParam1, lParam2);
        }
    return (LRESULT)1L;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | AppExit |
 *      a application is exiting, free any MMSYS resources it may own
 *
 ****************************************************************************/

void NEAR PASCAL AppExit(HTASK hTask, BOOL fNormalExit)
{
    HLOCAL h;
    HLOCAL hNext;
    WORD   wDebugFlags;
    UINT   wDeviceID;
    UINT   cFree;
    UINT   cHeap;
    UINT   err;

    if (hdrvDestroy != (HLOCAL)-1)
    {
        DOUT("MMSYSTEM: Hey! AppExit has been re-entered!\r\n");
    }

#ifdef DEBUG
    if (!fNormalExit)
        ROUT("MMSYSTEM: Abnormal app termination");
#endif

    //
    // either log a error or a warning depending on wether it was
    // a normal exit or not.
    //
    if (fNormalExit)
        wDebugFlags = DBF_MMSYSTEM | DBF_ERROR;
    else
        wDebugFlags = DBF_MMSYSTEM | DBF_WARNING; // DBF_TRACE?

    //
    // now free MCI devices.
    //
    for (wDeviceID=1; wDeviceID<MCI_wNextDeviceID; wDeviceID++)
    {
        if (MCI_VALID_DEVICE_ID(wDeviceID) && MCI_lpDeviceList[wDeviceID]->hCreatorTask == hTask)
        {
            DebugErr2(wDebugFlags, "MCI device %ls (%d) not released.", MCI_lpDeviceList[wDeviceID]->lpstrInstallName, wDeviceID);

            //
            // clear these to force MCI to close the device
            //
            MCI_lpDeviceList[wDeviceID]->dwMCIFlags &= ~MCINODE_ISCLOSING;
            MCI_lpDeviceList[wDeviceID]->dwMCIFlags &= ~MCINODE_ISAUTOCLOSING;

            err = (UINT)mciSendCommand(wDeviceID, MCI_CLOSE, NULL, NULL);

#ifdef DEBUG
            if (err != 0)
                DebugErr1(DBF_WARNING, "Unable to close MCI device (err = %04X).", err);
#endif
        }
    }

    //
    // free all WAVE/MIDI/MMIO handles
    //
start_over:
    for (h=GetHandleFirst(); h; h=hNext)
    {
        hNext = GetHandleNext(h);

        if (GetHandleOwner(h) == hTask)
        {
            //
            //  hack for the wave/midi mapper, always free handle's backward.
            //
            if (hNext && GetHandleOwner(hNext) == hTask)
                continue;

            //
            // do this so even if the close fails we will not
            // find it again.
            //
            SetHandleOwner(h, NULL);

            //
            // set the hdrvDestroy global so DriverCallback will not
            // do anything for this device
            //
            hdrvDestroy = h;

            switch(GetHandleType(h))
            {
                case TYPE_WAVEOUT:
                    DebugErr1(wDebugFlags, "WaveOut handle (%04X) was not released.", h);
                    waveOutReset((HWAVEOUT)h);
                    err = waveOutClose((HWAVEOUT)h);
                    break;

                case TYPE_WAVEIN:
                    DebugErr1(wDebugFlags, "WaveIn handle (%04X) was not released.", h);
                    waveInStop((HWAVEIN)h);
                    waveInReset((HWAVEIN)h);
                    err = waveInClose((HWAVEIN)h);
                    break;

                case TYPE_MIDIOUT:
                    DebugErr1(wDebugFlags, "MidiOut handle (%04X) was not released.", h);
                    midiOutReset((HMIDIOUT)h);
                    err = midiOutClose((HMIDIOUT)h);
                    break;

                case TYPE_MIDIIN:
                    DebugErr1(wDebugFlags, "MidiIn handle (%04X) was not released.", h);
                    midiInStop((HMIDIIN)h);
                    midiInReset((HMIDIIN)h);
                    err = midiInClose((HMIDIIN)h);
                    break;

                case TYPE_MMIO:
                    DebugErr1(wDebugFlags, "MMIO handle (%04X) was not released.", h);
                    err = mmioClose((HMMIO)h, 0);
                    break;

                case TYPE_IOPROC:
                    DebugErr1(wDebugFlags, "MMIO handler '%4.4ls' not removed.", (LPSTR)&((IOProcMapEntry*)h)->fccIOProc);
                    err = !mmioInstallIOProc(((IOProcMapEntry*)h)->fccIOProc, NULL, MMIO_REMOVEPROC);
                    break;

            }

#ifdef DEBUG
            if (err != 0)
                DebugErr1(DBF_WARNING, "Unable to close handle (err = %04X).", err);
#endif

            //
            // unset hdrvDestroy so DriverCallback will work.
            // some hosebag drivers (like the TIMER driver)
            // may pass NULL as their driver handle.
            // so dont set it to NULL.
            //
            hdrvDestroy = (HLOCAL)-1;

            //
            // the reason we start over is because a single free may cause
            // multiple free's (ie MIDIMAPPER has another HMIDI open, ...)
            //
            goto start_over;
        }
    }

    //
    //  what about timeSetEvent()!!!???
    //
    //  any outstanding timer events till be killed by the timer driver
    //  it self.
    //
    mciAppExit( hTask );


    // shrink our heap, down to minimal size.

    if ((cFree = LocalCountFree()) > 1024)
    {
        cHeap = LocalHeapSize() - (cFree - 512);
        LocalShrink(NULL, cHeap);
        DPRINTF(("MMSYSTEM: Shrinking the heap (%d)\r\n", cHeap));
    }
}

#ifdef  DEBUG_RETAIL
/*****************************************************************************
 * @doc INTERNAL
 *
 * @func void | SetPrivateProfileInt | windows should have this function
 *
 * @comm  used by DriverProc to set debug state in SYSTEM.INI
 *
 ****************************************************************************/

static  void FAR PASCAL SetPrivateProfileInt(LPSTR szSection, LPSTR szKey, int i, LPSTR szIniFile)
{
    char    ach[32] ;

    if (i != (int)GetPrivateProfileInt(szSection, szKey, ~i, szIniFile))
    {
        wsprintf(ach, "%d", i);
        WritePrivateProfileString(szSection, szKey, ach, szIniFile);
    }
}
#endif   //ifdef DEBUG_RETAIL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\dpmipage.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  PAGELOCK
;
;   This module contains functions for page locking memory using DPMI
;
; Created:  03-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     DpmiPageLock
;                       DpmiPageUnlock
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM = 1
        ?WIN = 0
        ?NODATA = 1

        .286
        .xlist
        include cmacros.inc
        include int31.inc
        .list

        externA         __AHINCR                    ; KERNEL
        externFP        GlobalHandle                ; KERNEL
        externFP        GlobalHandleNoRip           ; KERNEL
        externFP        GlobalFix                   ; KERNEL
        externFP        GlobalUnFix                 ; KERNEL

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

Int31_SelMgt_Get_Base     EQU ((Int31_Sel_Mgt shl 8) + SelMgt_Get_Base )
Int31_Lock_Region         EQU ((Int31_Page_Lock shl 8) + Lock_Region )
Int31_Unlock_Region       EQU ((Int31_Page_Lock shl 8) + Unlock_Region )

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; DpmiPageLock
;
;   page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageLock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Lock_Region
        jmp     short DpmiPageLockUnLock
cEnd    nogen

;---------------------------Public-Routine------------------------------;
; DpmiPageUnlock
;
;   un-page lock a region using DPMI
;
; Entry:
;       lpBase      Selector:offset of base of region to unlock
;       dwSize      size in bytes of region to unlock
;
; Returns:
;       NZ
;       AX = TRUE if successful
;
; Error Returns:
;       Z
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   DpmiPageUnlock, <NEAR>, <>
;       parmD   lpBase
;       parmD   dwSize
cBegin  nogen
        mov     cx,Int31_Unlock_Region
        errn$   DpmiPageLockUnLock
cEnd    nogen

cProc   DpmiPageLockUnLock, <NEAR>, <si,di>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     si,cx                       ; save lock/unlock flag

        mov     ax,Int31_SelMgt_Get_Base
        mov     bx,lpBase.sel
        int     31h                         ; returns CX:DX selector base
        jc      dpl_exit

        mov     bx,cx                       ; BX:CX is base
        mov     cx,dx

        add     cx,lpBase.off               ; add offset into selector base
        adc     bx,0

        mov     ax,si                       ; get lock/unlock flag
        mov     si,dwSize.hi                ; SI:DI length
        mov     di,dwSize.lo

        int     31h                         ; lock or unlock it
dpl_exit:
        cmc                                 ; set carry iff success
        sbb     ax,ax                       ; return TRUE/FALSE
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageLock
;
;   page lock a range of windows allocated memory
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       AX = TRUE if successful
;
; Error Returns:
;       AX = FALSE if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageLock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        mov     ax,lpBase.sel               ; NULL pointer, invalid
        or      ax,ax
        jz      GPageLock_Exit

        call    HugeGlobalFix               ; fix the memory, then page lock
        cCall   DpmiPageLock,<lpBase, dwSize>
        jnz     GPageLock_Exit

        mov     ax,lpBase.sel               ; page lock failed, un-fix
        call    HugeGlobalUnFix             ; and return failure
        xor     ax,ax

GPageLock_Exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HugePageUnlock
;
;   un-page lock a range of windows alocated memory, (locked with HugePageLock)
;
; Entry:
;       lpBase      Selector:offset of base of region to lock
;       dwSize      size in bytes of region to lock
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       INT 31h
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HugePageUnlock, <FAR, PUBLIC>, <>
        parmD   lpBase
        parmD   dwSize
cBegin
        cCall   DpmiPageUnlock,<lpBase, dwSize>

        mov     ax,lpBase.sel
        call    HugeGlobalUnFix
cEnd

;---------------------------Public-Routine------------------------------;
; HugeGlobalFix
;
;   fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalFix
;       HugeGlobalHandle
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalFixExit

        cCall   GlobalFix,<ax>

HugeGlobalFixExit:
        ret

HugeGlobalFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalUnFix
;
;   un-fix the global object that represents the passed selector
;
; Entry:
;       AX = SELECTOR
;
; Returns:
;       none
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       HugeGlobalHandle
;       GlobalUnFix
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalUnFix proc near

        call    HugeGlobalHandle
        jz      HugeGlobalUnFixExit

        cCall   GlobalUnFix,<ax>

HugeGlobalUnFixExit:
        ret

HugeGlobalUnFix endp

;---------------------------Public-Routine------------------------------;
; HugeGlobalHandle
;
; Entry:
;       AX = SELECTOR to global object
;
; Returns:
;       NZ
;       AX = HANDLE of global object
;
; Error Returns:
;       Z
;       AX = 0 if error
;
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalHandleNoRip
; History:
;
;       Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

HugeGlobalHandle proc near

        push    si
        mov     si,ax

        or      ax,ax                   ; test for NULL pointer!
        jz      HugeGlobalHandleExit

HugeGlobalHandleAgain:
        cCall   GlobalHandleNoRip,<si>
        sub     si,__AHINCR
        or      ax,ax
        jz      HugeGlobalHandleAgain

HugeGlobalHandleExit:
        pop     si
        ret

HugeGlobalHandle endp

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvr31.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  DRVR31.ASM - Installable driver code.
;
; all this code does is pass any installable driver API on to
; win 3.1 USER.
;
; Created:  28-08-91
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1991 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE	= 1

	.xlist
	include cmacros.inc
        include windows.inc
        .list

;
; these are the USER driver interface functions
;
        externFP    OpenDriver                  ; USER
        externFP    CloseDriver                 ; USER
        externFP    GetDriverModuleHandle       ; USER
        externFP    SendDriverMessage           ; USER
	externFP    DefDriverProc		; USER

ifdef DEBUG
        externFP    GetModuleFileName           ; KERNEL
        externFP    _dprintf                    ; COMM.ASM
endif

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

ifndef SEGNAME
        SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

ifdef DEBUG

szSuccess:
        db "MMSYSTEM: DrvOpen(%ls) (%ls)", 13,10,0

szFailed:
        db "MMSYSTEM: DrvOpen(%ls) *failed*", 13,10,0

cProc DrvOpen, <FAR, PUBLIC, PASCAL, LOADDS>, <>
        ParmD   szDriverName
        ParmD   szSectionName
        ParmD   dw2
        LocalV  ach,128
cBegin
	cCall   OpenDriver, <szDriverName, szSectionName, dw2>
        push    ax

        lea     bx,szFailed
        or      ax,ax
        jz      DrvOpenFailed

        cCall   GetDriverModuleHandle, <ax>

        lea     bx,ach
        cCall   GetModuleFileName,<ax, ss,bx, 128>

        lea     bx,szSuccess

DrvOpenFailed:
        lea     ax,ach
        push    ss                      ; ach
        push    ax

        push    szDriverName.sel        ; szDriverName
        push    szDriverName.off

        push    cs                      ; szFormat
        push    bx

        call    _dprintf                ; dprintf(szFormat, szDriverName, ach)
        add     sp,6*2

DrvOpenExit:
	pop	ax			; return hdrv to caller

DrvOpenExitNow:
cEnd

else ; DEBUG

cProc DrvOpen, <FAR, PUBLIC, PASCAL>, <>
;       ParmD   szDriverName
;       ParmD   szSectionName
;       ParmD   dw2
cBegin nogen

        jmp     OpenDriver

cEnd nogen




endif ; DEBUG

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvClose, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     CloseDriver

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvGetModuleHandle, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
cBegin nogen

        jmp     GetDriverModuleHandle

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvSendMessage, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   hDriver
;       ParmW   message
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     SendDriverMessage

cEnd nogen

;-----------------------------------------------------------------------;
;-----------------------------------------------------------------------;
    assumes ds,nothing
    assumes es,nothing

cProc DrvDefDriverProc, <FAR, PUBLIC, PASCAL>, <>
;       ParmD   dwDriver
;       ParmW   hDriver
;       ParmW   message
;       ParmD   dw1
;       ParmD   dw2
cBegin nogen

        jmp     DefDriverProc

cEnd nogen

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvr.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   drvr.c - Installable driver code. Common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI From windows 3.1 installable driver code by davidds

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "drvr.h"

int     cInstalledDrivers = 0;      // Count of installed drivers
HANDLE  hInstalledDriverList = 0;   // List of installed drivers

typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, WORD, LONG, LONG);
typedef LONG   (FAR PASCAL *DEFDRIVERPROC31)(DWORD, HANDLE, WORD, LONG, LONG);

extern SENDDRIVERMESSAGE31      lpSendDriverMessage;
extern DEFDRIVERPROC31          lpDefDriverProc;
extern BOOL                     fUseWinAPI;

/***************************************************************************
 *
 * @doc INTERNAL 
 *
 * @api LONG | InternalBroadcastDriverMessage |  Send a message to a
 *      range of drivers.
 *
 * @parm WORD | hDriverStart | index of first driver to send message to
 *
 * @parm WORD | message | Message to broadcast.
 *
 * @parm LONG | lParam1 | First message parameter.
 *
 * @parm LONG | lParam2 | Second message parameter.
 *
 * @parm WORD | flags | defines range of drivers as follows:
 *
 * @flag IBDM_SENDMESSAGE | Only send message to hDriverStart.
 *
 * @flag IBDM_ONEINSTANCEONLY | This flag is ignored if IBDM_SENDMESSAGE is
 *       set. Only send message to single instance of each driver.
 *
 * @flag IBDM_REVERSE | This flag is ignored if IBDM_SENDMESSAGE is set.
 *       Send message to drivers with indices between
 *       hDriverStart and 1 instead of hDriverStart and cInstalledDrivers.
 *       If IBDM_REVERSE is set and hDriverStart is 0 then send messages
 *       to drivers with indices between cInstalledDrivers and 1.
 *
 * @rdesc returns non-zero if message was broadcast. If the IBDM_SENDMESSAGE
 *        flag is set, returns the return result from the driver proc.
 *
 ***************************************************************************/

LONG FAR PASCAL InternalBroadcastDriverMessage(WORD hDriverStart,
                                               WORD message,
                                               LONG lParam1,
                                               LONG lParam2,
                                               WORD flags)
{
    LPDRIVERTABLE lpdt;
    LONG          result=0;
    int           id;
    int           idEnd;


    if (!hInstalledDriverList || hDriverStart > cInstalledDrivers)
        return(FALSE);

    if (flags & IBDM_SENDMESSAGE)
        {
        if (!hDriverStart)
            return (FALSE);
        flags &= ~(IBDM_REVERSE | IBDM_ONEINSTANCEONLY);
        idEnd = hDriverStart;
        }

    else
        {
        if (flags & IBDM_REVERSE)
            {
            if (!hDriverStart)
                hDriverStart = cInstalledDrivers;
            idEnd = -1;
            }            
        else
            {
            if (!hDriverStart)
                return (FALSE);
            idEnd = cInstalledDrivers;
            }            
        }
    
    hDriverStart--;

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    for (id = hDriverStart; id != idEnd; ((flags & IBDM_REVERSE) ? id-- : id++))
        {
        if (lpdt[id].hModule)
            {
            if ((flags & IBDM_ONEINSTANCEONLY) && 
                !lpdt[id].fFirstEntry)
                continue;

            result = 
                (*lpdt[id].lpDriverEntryPoint)(lpdt[id].dwDriverIdentifier,
                                               id+1,
                                               message,
                                               lParam1,
                                               lParam2);
            }
        }

    GlobalUnlock(hInstalledDriverList);

    return(result);
}


/***************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DrvSendMessage |  This function sends a message 
 *      to a specified driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the destination driver.
 *
 * @parm WORD | wMessage | Specifies a driver message.
 *
 * @parm LONG | lParam1 | Specifies the first message parameter.
 *
 * @parm LONG | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns the results returned from the driver.
 *
 ***************************************************************************/

LONG API DrvSendMessage(HANDLE hDriver, WORD message, LONG lParam1, LONG lParam2)
{
    if (fUseWinAPI)
        return (*lpSendDriverMessage)(hDriver, message, lParam1,lParam2);

    return(InternalBroadcastDriverMessage(hDriver,
                                          message,
                                          lParam1, 
                                          lParam2, 
                                          IBDM_SENDMESSAGE));
}

/**************************************************************************
 *
 * @doc DDK
 *
 * @api LONG | DefDriverProc |  This function provides default 
 * handling of system messages. 
 * 
 * @parm DWORD | dwDriverIdentifier | Specifies the identifier of 
 * the device driver.
 *
 * @parm HANDLE | hDriver | Specifies the handle of the device driver.
 *
 * @parm WORD | wMessage | Specifies a driver message.
 *
 * @parm LONG | lParam1 | Specifies the first message parameter.
 *
 * @parm LONG | lParam2 | Specifies the second message parameter.
 *
 * @rdesc Returns 1L for DRV_LOAD, DRV_FREE, DRV_ENABLE, and DRV_DISABLE. 
 * It returns 0L for all other messages.
 *
***************************************************************************/



LONG API DefDriverProc(DWORD  dwDriverIdentifier,
                              HANDLE hDriver,
                              WORD   message,
                              LONG   lParam1,
                              LONG   lParam2)
{

    switch (message)
        {
        case DRV_LOAD:
        case DRV_ENABLE:
        case DRV_DISABLE:
        case DRV_FREE:
            return(1L);
            break;
        case DRV_INSTALL:
            return(DRV_OK);
            break;
       }

    return(0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvrstr.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   drvrstr.c - Installable driver code strings

   Version: 1.00

   Date:    10-Jun-1990

   Author:  ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   10-JUN-1990   ROBWI Based on windows 3.1 installable driver code by davidds

*****************************************************************************/

#include "windows.h"

LPSTR szDriverProc              = "DriverProc";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\gmem.h ===
/*
 * GMEM.H - Macros for windows 3.0 memory management in protected mode
 *
 * because windows 3.0 runs in pmode GlobalLock and GlobalUnlock are
 * unnessary.  The "Selector" to a memory object will always be the
 * same for the life of the memory object.
 *
 * these macros take advantage of the following win3 memory "facts"
 *
 *      a SELECTOR (to a global object) is a HANDLE
 *      a HANDLE is *not* a SELECTOR!!!!!!!!
 *
 *      GlobalLock() and GlobalUnlock() do *not* keep lock counts
 *
 *      GlobalLock() is the only way to convert a HANDLE to a SELECTOR
 *
 * functions:
 *
 *      GHandle(sel)                convert a SELECTOR to a HANDLE
 *      GSelector(h)                convert a HANDLE to a SELECTOR
 *
 *      GAllocSel(ulBytes)          allocate a SELECTOR ulBytes in size
 *      GAllocPtr(ulBytes)          allocate a POINTER ulBytes in size
 *
 *      GReAllocSel(sel,ulBytes)    re-alloc a SELECTOR
 *      GReAllocPtr(lp,ulBytes)     re-alloc a POINTER
 *
 *      GSizeSel(sel)               return the size in bytes of a SELECTOR
 *
 *      GLockSel(sel)               convert a SELECTOR into a POINTER
 *      GUnlockSel(sel)             does nothing
 *
 *      GFreeSel(sel)               free a SELECTOR
 *      GFreePtr(lp)                free a POINTER
 *
 * 5/31/90 ToddLa
 *
 */

HGLOBAL __H;

#define MAKEP(sel,off)      ((LPVOID)MAKELONG(off,sel))

#define GHandle(sel)        ((HGLOBAL)(sel))  /* GlobalHandle? */
#define GSelector(h)        (HIWORD((DWORD)GlobalLock(h)))

#define GAllocSelF(f,ulBytes) ((__H=GlobalAlloc(f,(LONG)(ulBytes))) ? GSelector(__H) : NULL )
#define GAllocPtrF(f,ulBytes) MAKEP(GAllocSelF(f,ulBytes),0)
#define GAllocF(f,ulBytes)    GAllocSelF(f,ulBytes)

#define GAllocSel(ulBytes)    GAllocSelF(GMEM_MOVEABLE,ulBytes)
#define GAllocPtr(ulBytes)    GAllocPtrF(GMEM_MOVEABLE,ulBytes)
#define GAlloc(ulBytes)       GAllocSelF(GMEM_MOVEABLE,ulBytes)

#define GReAllocSel(sel,ulBytes)   ((__H=GlobalReAlloc((HGLOBAL)(sel),(LONG)(ulBytes), GMEM_MOVEABLE | GMEM_ZEROINIT)) ? GSelector(__H) : NULL )
#define GReAllocPtr(lp,ulBytes)    MAKEP(GReAllocSel(HIWORD((DWORD)(lp)),ulBytes),0)
#define GReAlloc(sel,ulBytes)      GReAllocSel(sel,ulBytes)

#define GSizeSel(sel)       GlobalSize((HGLOBAL)(sel))
#define GSize(sel)          GSizeSel(sel)

#define GLockSel(sel)       MAKEP(sel,0)
#define GUnlockSel(sel)     /* nothing */
#define GLock(sel)          GLockSel(sel)
#define GUnlock(sel)        GUnlockSel(sel)

#define GFreeSel(sel)       (GlobalUnlock(GHandle(sel)),GlobalFree(GHandle(sel)))
#define GFreePtr(lp)        GFreeSel(HIWORD((DWORD)(lp)))
#define GFree(sel)          GFreeSel(sel)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\drvrrare.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   drvrrare.c - Installable driver code. Less common code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  DAVIDDS ROBWI

*****************************************************************************/

#include <windows.h>
#include "drvr.h"
#define MMNOSOUND     
#define MMNOWAVE      
#define MMNOMIDI      
#define MMNOSEQ       
#define MMNOTIMER     
#define MMNOJOY       
#define MMNOMCI       
#include "mmsystem.h"
#define NOTIMERDEV
#define NOJOYDEV
#define NOMCIDEV
#define NOSEQDEV
#define NOWAVEDEV
#define NOMIDIDEV
#define NOTASKDEV
#include "mmddk.h"
#include "mmsysi.h"

extern HANDLE  hInstalledDriverList;  // List of installed driver instances 
extern int     cInstalledDrivers;     // High water count of installed driver instances

extern DWORD FAR PASCAL DriverProc(DWORD dwID, HANDLE hdrv, WORD msg, DWORD dw1, DWORD dw2);

/* Support for using 3.1 APIs if available */

typedef HANDLE (FAR PASCAL *OPENDRIVER31)(LPSTR, LPSTR, LONG);
typedef LONG   (FAR PASCAL *CLOSEDRIVER31)(HANDLE, LONG, LONG);
typedef HANDLE (FAR PASCAL *GETDRIVERMODULEHANDLE31)(HANDLE);
typedef LONG   (FAR PASCAL *SENDDRIVERMESSAGE31)(HANDLE, WORD, LONG, LONG);
typedef LONG   (FAR PASCAL *DEFDRIVERPROC31)(DWORD, HANDLE, WORD, LONG, LONG);

OPENDRIVER31            lpOpenDriver;
CLOSEDRIVER31           lpCloseDriver;
GETDRIVERMODULEHANDLE31 lpGetDriverModuleHandle;
SENDDRIVERMESSAGE31     lpSendDriverMessage;
DEFDRIVERPROC31         lpDefDriverProc;
BOOL                    fUseWinAPI;

#pragma alloc_text( INIT, DrvInit )

/***************************************************************************

   strings

****************************************************************************/

extern char far szSystemIni[];          // INIT.C
extern char far szDrivers[];
extern char far szBoot[];
extern char far szNull[];
extern char far szUser[];
extern char far szOpenDriver[];
extern char far szCloseDriver[];
extern char far szDrvModuleHandle[];
extern char far szSendDriverMessage[];
extern char far szDefDriverProc[];
extern char far szDriverProc[];

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvClose | This function closes an open driver 
 *        instance and decrements
 *        the driver's open count. Once the driver's open count becomes zero,
 *        the driver is unloaded. 
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable 
 *        driver to close.
 *
 * @parm  LONG | lParam1 | Specifies the first message parameter for 
 *        the DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @parm  LONG | lParam2 | Specifies the second message parameter 
 *        for DRV_CLOSE message. This data is passed directly to the driver.
 *
 * @rdesc Returns zero if the driver aborted the close;
 *        otherwise, returns the return result from the driver.

 * @xref DrvOpen
 *
 ***************************************************************************/

   
LONG API DrvClose(HANDLE hDriver, LONG lParam1, LONG lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      DRV_CLOSE 
     *      if DRV_CLOSE returns non-zero
     *          if driver usage count = 1
     *              DRV_DISABLE
     *              DRV_FREE
     */

    if (fUseWinAPI)
       return ((*lpCloseDriver)(hDriver, lParam1, lParam2));
    else
       return InternalCloseDriver(hDriver, lParam1, lParam2, TRUE);
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   LONG | DrvOpen | This function opens an installable driver. 
 *        The first time a driver is opened it is loaded
 *        and enabled. A driver must be opened before messages are sent
 *        to it. 
 *
 * @parm  LPSTR | szDriverName | Specifies a far pointer to a 
 *        null-terminated character string
 *        containing a driver filename or a keyname from a
 *        section of the SYSTEM.INI file.
 *
 * @parm  LPSTR | szSectionName | Specifies a far pointer to a 
 *        null-terminated character string containing the name of 
 *        the driver section to search. If <p szSectionName> is
 *        not null, the specified section of the SYSTEM.INI file is 
 *        searched instead of the [Drivers] section. If 
 *        <p szSectionName> is null, the default [Drivers] section is used.
 *
 * @parm  LONG | lParam | Specifies a message parameter to 
 *        pass to the driver procedure with the <m DRV_OPEN> message.
 *
 * @rdesc Returns a handle to the driver.
 *
 * @comm Installable drivers must export a <f DriverProc> routine of
 *        the form:
 * 
 * @cb   LONG FAR PASCAL | DriverProc | This entry point receives the 
 * messages sent to an installable driver. This entry will always 
 * handle the system messages as a minimum set of messages.
 * 
 * @parm DWORD | dwDriverIdentifier | Specifies the device driver 
 *       identifier. 
 * 
 * @parm HANDLE | hDriver | Specifies the device driver handle. 
 * 
 * @parm WORD | wMessage | Specifies the message for the device 
 *       driver. 
 * 
 * @parm LONG | lParm1 | Specifies message dependent data.
 * 
 * @parm LONG | lParm2 | Specifies message dependent data.
 * 
 * @xref DrvClose
 *
****************************************************************************/

HANDLE API DrvOpen(LPSTR szDriverName,
                          LPSTR szSectionName,
                          LONG lParam2)
{
    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero
     *              DRV_ENABLE
     *      if driver loaded correctly
     *          DRV_OPEN
     */

    HANDLE hdrv;

    if (fUseWinAPI)
        hdrv = ((*lpOpenDriver)(szDriverName, szSectionName, lParam2));
    else
        hdrv = (HANDLE)InternalOpenDriver(szDriverName, szSectionName, lParam2, TRUE);

#ifdef DEBUG
    if (hdrv) {
        char ach[80];
        static SZCODE szFormat[] = "MMSYSTEM: Opened %ls (%ls)\r\n";

        GetModuleFileName(DrvGetModuleHandle(hdrv), ach, sizeof(ach));
        DPRINTF((szFormat, (LPSTR)szDriverName, (LPSTR)ach));
    }
#endif

    return hdrv;
}

/***************************************************************************
 *
 * @doc   DDK
 *
 * @api   HANDLE | DrvGetModuleHandle | This function returns the library
 *        module handle of the specified installable driver.
 *
 * @parm  HANDLE | hDriver | Specifies the handle of the installable driver.
 *       
 * @rdesc Returns the module handle of the driver specified by the 
 *        driver handle <p hDriver>.
 *
 * @comm  A module handle is not the same as an installable driver handle.
 *        
 ***************************************************************************/

HANDLE API DrvGetModuleHandle(HANDLE hDriver)
{
    LPDRIVERTABLE lpdt;
    HANDLE        h = 0;

    if (fUseWinAPI)
        return ((*lpGetDriverModuleHandle)(hDriver));
 
    if (hDriver && ((WORD)hDriver <= cInstalledDrivers))
        {
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        h = lpdt[hDriver-1].hModule;
        GlobalUnlock(hInstalledDriverList);
        }

    return(h);
}

 
LONG FAR PASCAL InternalCloseDriver(WORD hDriver,
                                    LONG lParam1,
                                    LONG lParam2,
                                    BOOL fSendDisable)
{
    LPDRIVERTABLE lpdt;
    LONG          result;
    HANDLE        h;
    int           index;
    BOOL          f;

    // check handle in valid range.

    if (hDriver > cInstalledDrivers)
        return(FALSE);

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    result = DrvSendMessage(hDriver, DRV_CLOSE, lParam1, lParam2);

    if (result)
        {
    
        // Driver didn't abort close
        
        f = lpdt[hDriver-1].fFirstEntry;

        if (InternalFreeDriver(hDriver, fSendDisable) && f)
            {
      
            /* Only one entry for the driver in the driver list has the first
             * instance flag set. This is to make it easier to handle system
             * messages that only need to be sent to a driver once.
             *
             * To maintain the flag, we must set the flag in one of the other
             * entries if we remove the driver entry with the flag set.
             *
             * Note that InternalFreeDriver returns the new usage count of
             * the driver so if it is zero, we know that there are no other
             * entries for the driver in the list and so we don't have to
             * do this loop.
             */
         
            for (index=0;index<cInstalledDrivers;index++)
                if (lpdt[index].hModule == lpdt[hDriver-1].hModule && !lpdt[index].fFirstEntry)
                    {
                    lpdt[index].fFirstEntry = 1;
                    break;
                    }        
            }
        
        }

    GlobalUnlock(hInstalledDriverList);
  
    return(result);
}


LONG FAR PASCAL InternalOpenDriver(LPSTR szDriverName,
                                   LPSTR szSectionName,
                                   LONG  lParam2,
                                   BOOL  fSendEnable)
{
    int           hDriver;
    LPDRIVERTABLE lpdt;
    LONG          result;  
    HANDLE        h;
    char          sz[128];

    if (hDriver = LOWORD(InternalLoadDriver(szDriverName,
                                            szSectionName,
                                            sz,
                                            sizeof(sz),
                                            fSendEnable)))
        {

  
        /*
           Set the driver identifier to the DRV_OPEN call to the
           driver handle. This will let people build helper functions
           that the driver can call with a unique identifier if they
           want to.
        */
         
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
        lpdt[hDriver-1].dwDriverIdentifier = hDriver;
        GlobalUnlock(hInstalledDriverList);

        result = DrvSendMessage(hDriver,
                                DRV_OPEN,
                                (LONG)(LPSTR)sz,
                                lParam2);
        if (!result)
            InternalFreeDriver(hDriver, fSendEnable);

        else
            {
            lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
            lpdt[hDriver-1].dwDriverIdentifier = result;
            GlobalUnlock(hInstalledDriverList);
            result = hDriver;
            }
        }
    else
        result = 0L;

    return(result);
}

/***************************************************************************
 *
 * @doc   INTERNAL 
 *
 * @api   LONG | InternalLoadDriver | Loads an installable driver. If this is
 *        the first time that the driver is opened, the driver will be loaded
 *        and enabled.
 *
 * @parm  LPSTR | szDriverName | A null-terminated character string
 *        containing a driver filename or a keyname from the [Drivers]
 *        section of system.ini.
 *
 * @parm  LPSTR | szSectionName | A null-terminated character string
 *        that specifies a driver section to search. If szSectionName is
 *        not null, the specified section of system.ini is searched instead
 *        of the [Drivers] section. If szSectionName is null, the
 *        default [Drivers] section is used.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 * 
 * @parm  WORD | cbTail | size of supplied buffer.
 *
 * @parm  BOOL | fSendEnable | TRUE if driver should be enabled
 *
 * @rdesc Returns a long whose loword is the handle to the driver and whose
 *        high word is an error code or the module handle
 *
 * @xref  InternalOpenDriver
 *
 ****************************************************************************/

LONG FAR PASCAL InternalLoadDriver(LPSTR szDriverName,
                                   LPSTR szSectionName,
                                   LPSTR lpstrTail,
                                   WORD  cbTail,
                                   BOOL  fSendEnable)
{
    int           index;
    LPDRIVERTABLE lpdt;
    LONG          result;
    HANDLE        h;


    /*  The driver will receive the following message sequence:
     *
     *      if driver not loaded and can be found
     *          DRV_LOAD
     *          if DRV_LOAD returns non-zero and fSendEnable
     *              DRV_ENABLE
     */

    /* Allocate a table entry */

    if (!hInstalledDriverList)
        h = GlobalAlloc(GHND | GMEM_SHARE, (DWORD)((WORD)sizeof(DRIVERTABLE)));

    else

        /* Alloc space for the next driver we will install. We may not really
         * install the driver in the last entry but rather in an intermediate
         * entry which was freed. 
         */
        
        h = GlobalReAlloc(hInstalledDriverList, 
            (DWORD)((WORD)sizeof(DRIVERTABLE)*(cInstalledDrivers+1)),
            GHND | GMEM_SHARE);

    if (!h)
        return(0L);

    cInstalledDrivers++;        
    hInstalledDriverList = h;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

    /* find an unused entry in the table */

    for (index=0;index<cInstalledDrivers;index++)
        {
        if (lpdt->hModule || lpdt->fBusy) 
            lpdt++;
        else
            break;
        }

    if (index+1 < cInstalledDrivers)

        /* The driver went into an unused entry in the middle somewhere so
         * restore table size. 
         */

        cInstalledDrivers--;

    /* Protect the entry we just allocated so that OpenDriver 
     * can be called at any point from now on without overriding
     * the entry
     */

    lpdt->fBusy = 1;

    h = LoadAliasedLibrary(szDriverName,
                           szSectionName ? szSectionName : szDrivers,
                           szSystemIni,
                           lpstrTail,
                           cbTail);

    if (h < 32)
        {
        result = MAKELONG(0,h);
        goto LoadCleanUp;
        }

    lpdt->lpDriverEntryPoint = (DRIVERPROC)GetProcAddress(h, szDriverProc);
    if (!lpdt->lpDriverEntryPoint)
        {
        // Driver does not have correct entry point 
        FreeLibrary(h);
        result = 0L;
        goto LoadCleanUp;
        }

    // Set hModule here so that GetDrvrUsage() and DrvSendMessage() work

    lpdt->hModule = h;

    if (GetDrvrUsage(h) == 1)
        {
        
        // First instance of the driver.

        if (!DrvSendMessage(index+1, DRV_LOAD, 0L, 0L))
            {
            // Driver failed load call.
            lpdt->lpDriverEntryPoint = NULL;
            lpdt->hModule = NULL;
            FreeLibrary(h);
            result = 0L;
            goto LoadCleanUp;
            }
        lpdt->fFirstEntry = 1;
        if (fSendEnable)
            DrvSendMessage(index+1, DRV_ENABLE, 0L, 0L);                             
        }
   
    result = MAKELONG(index+1,h);

LoadCleanUp:
    lpdt->fBusy = 0;
    GlobalUnlock(hInstalledDriverList);
    return(result);
}        

/***************************************************************************
 *
 * @doc   INTERNAL  
 *
 * @api   WORD | InternalFreeDriver | This function decrements the usage
 *        count of the specified driver. When the driver usage count reaches
 *        0, the driver is sent a DRV_FREE message and then freed.
 *
 * @parm  HANDLE | hDriver | Driver handle of the installable driver to be
 *        freed. 
 *       
 * @parm  BOOL | fSendDisable | TRUE if a DRV_DISABLE message should be sent 
 *        before the DRV_FREE message if the usage count reaches zero.
 *
 * @rdesc Returns current driver usage count.
 *
 * @comm  Using LoadLibrary or FreeLibrary directly on a library installed
 *        with OpenDriver will break this function. A module handle is not
 *        the same as an installable driver handle.
 *        
 * @xref  CloseDriver
 *
 ***************************************************************************/

WORD FAR PASCAL InternalFreeDriver(WORD hDriver, BOOL fSendDisable)
{
    LPDRIVERTABLE lpdt;
    HANDLE        h;
    WORD          w;

    /*  The driver will receive the following message sequence:
     *
     *      if usage count of driver is 1 
     *          DRV_DISABLE (normally)
     *          DRV_FREE
     */

    if (hDriver > cInstalledDrivers || !hDriver)
        return(0);

    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    
    /*
     * If the driver usage count is 1, then send 
     * free and disable messages.
     */
 
    /*
       Clear dwDriverIdentifier so that the sendmessage for
       DRV_OPEN and DRV_ENABLE have dwDriverIdentifier = 0
       if an entry gets reused and so that the DRV_DISABLE and DRV_FREE
       messages below also get dwDriverIdentifier = 0.
    */

    lpdt[hDriver-1].dwDriverIdentifier = 0; 
    
    w = GetDrvrUsage(lpdt[hDriver-1].hModule);
    if (w == 1)
        {
        if (fSendDisable)
            DrvSendMessage(hDriver, DRV_DISABLE, 0L, 0L);
        DrvSendMessage(hDriver, DRV_FREE, 0L, 0L);
        }        
    FreeLibrary(lpdt[hDriver-1].hModule);
 
    // Clear the rest of the table entry

    lpdt[hDriver-1].hModule = 0;        // this indicates free entry
    lpdt[hDriver-1].fFirstEntry = 0;    // this is also just to be tidy
    lpdt[hDriver-1].lpDriverEntryPoint = 0; // this is also just to be tidy
 
    GlobalUnlock(hInstalledDriverList);
    return(w-1);
}
    
#ifdef DEBUG

WORD GetWinVer()
{
    WORD w = GetVersion();

    return (w>>8) | (w<<8);
}

#endif

void NEAR PASCAL DrvInit(void)
{
HANDLE  hlibUser;
LPDRIVERTABLE lpdt;

    /* If the window's driver interface is present then use it.
     */

    DOUT("MMSYSTEM: DrvInit");

    hlibUser = GetModuleHandle(szUser);

    if(lpOpenDriver = (OPENDRIVER31)GetProcAddress(hlibUser,szOpenDriver))
        fUseWinAPI = TRUE;
    else
        {
        fUseWinAPI = FALSE;
        DOUT(" - No Windows Driver I/F detected. Using MMSYSTEM\r\n");

        //
        // force MMSYSTEM into the driver table, without enableing it.
        //
        cInstalledDrivers = 1;
        hInstalledDriverList = GlobalAlloc(GHND|GMEM_SHARE, (DWORD)((WORD)sizeof(DRIVERTABLE)));

#ifdef DEBUG
        if (hInstalledDriverList == NULL)
            {
            DOUT("no memory for driver table\r\n");
            FatalExit(-1);
            return;
            }
#endif
        lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);

        //
        //  NOTE! we are not setting fFirstEntry==TRUE
        //
        //  because under windows 3.0 MMSOUND will enable/disable us
        //  we *dont* wan't the driver interface doing it!
        //
        lpdt->lpDriverEntryPoint = (DRIVERPROC)DriverProc;
        lpdt->hModule = ghInst;
        lpdt->fFirstEntry = 0;

        GlobalUnlock(hInstalledDriverList);
        }
    
    if (fUseWinAPI)
        {
        DOUT(" - Windows Driver I/F detected\r\n");

#ifdef DEBUG
        if (GetWinVer() < 0x30A)
            DOUT("MMSYSTEM: WARNING !!! WINDOWS DRIVER I/F BUT VERSION LESS THAN 3.1\r\n");
#endif

        // link to the relevant user APIs.

        lpCloseDriver = (CLOSEDRIVER31)GetProcAddress(hlibUser, szCloseDriver);
        lpGetDriverModuleHandle = (GETDRIVERMODULEHANDLE31)GetProcAddress(hlibUser, szDrvModuleHandle);
        lpSendDriverMessage = (SENDDRIVERMESSAGE31)GetProcAddress(hlibUser, szSendDriverMessage);
        lpDefDriverProc = (DEFDRIVERPROC31)GetProcAddress(hlibUser, szDefDriverProc);
        }
}
    
/***************************************************************************
 *
 * @doc   INTERNAL 
 *
 * @api   void | InternalInstallDriverChain | This function loads the
 *        drivers specified on the Drivers= line of the [Boot] section
 *        of system.ini. The Drivers are loaded but not opened. 
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalInstallDriverChain(void)
{
    char    szBuffer[150];
    BOOL    bFinished;
    int     iStart;
    int     iEnd;

    if (!fUseWinAPI)
        {
        /* Load DLL's from DRIVERS section in system.ini
        */
        GetPrivateProfileString(szBoot,      /* [Boot] section */
                                szDrivers,   /* Drivers= */
                                szNull,      /* Default if no match */
                                szBuffer,    /* Return buffer */
                                sizeof(szBuffer),
                                szSystemIni);

        if (!*szBuffer)
            return;

        bFinished = FALSE;
        iStart    = 0;
        while (!bFinished)
            {
            iEnd = iStart;
            while (szBuffer[iEnd] && (szBuffer[iEnd] != ' ') && 
                (szBuffer[iEnd] != ','))
	        iEnd++;

            if (szBuffer[iEnd] == NULL)
	        bFinished = TRUE;
            else
	        szBuffer[iEnd] = NULL;

            /* Load and enable the driver. 
            */
            InternalLoadDriver(&(szBuffer[iStart]), NULL, NULL, 0, TRUE);

            iStart = iEnd+1;
            }
        }
}

/***************************************************************************
 *
 * @doc   INTERNAL  
 *
 * @api   void | InternalDriverEnable | This function enables all the
 *        currently loaded installable drivers. If the user driver i/f
 *        has been detected, this function will do nothing.
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverEnable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(1, DRV_ENABLE, 0L, 0L, IBDM_ONEINSTANCEONLY);
}

/***************************************************************************
 *
 * @doc   INTERNAL  
 *
 * @api   void | InternalDriverDisable | This function disables all the
 *        currently loaded installable drivers. If the user driver I/F
 *        has been detected, this function will do nothing.
 *      
 *
 * @rdesc None
 *
 ***************************************************************************/

void FAR PASCAL InternalDriverDisable(void)
{

    if (!fUseWinAPI)
        InternalBroadcastDriverMessage(0, DRV_DISABLE, 0L, 0L,
            IBDM_ONEINSTANCEONLY | IBDM_REVERSE);
}

/***************************************************************************
 *
 * @doc   INTERNAL 
 *
 * @api   HANDLE | LoadAliasedLibrary | This function loads the library module
 *        contained in the specified file and returns its module handle
 *        unless the specified  name matches a keyname in the
 *        specified section section of the specified ini file in which case
 *        the library module in the file specified on the ini line is loaded.
 *      
 * @parm  LPSTR | szLibFileName | points to a null-terminated character
 *        string containing the filename or system.ini keyname.
 *
 * @parm  LPSTR | szSection | points to a null-terminated character
 *        string containing the section name.
 *
 * @parm  LPSTR | szIniFile | points to a null-terminated character
 *        string containing the ini filename.
 *
 * @parm  LPSTR | lpstrTail | caller supplied buffer to return the "tail"
 *        of the system.ini line in. The tail is any characters that follow
 *        the filename.
 * 
 * @parm  WORD | cbTail | size of supplied buffer.
 *
 * @rdesc Returns the library's module handle. 
 *
 * @xref  LoadLibrary
 *
 ***************************************************************************/

HANDLE FAR PASCAL LoadAliasedLibrary(LPSTR szLibFileName,
                                     LPSTR szSection,
                                     LPSTR szIniFile,
                                     LPSTR lpstrTail,
                                     WORD  cbTail)
{
    HANDLE        h;
    char          sz[128];
    LPSTR         pch;
    OFSTRUCT      of;

    if (!szLibFileName || !*szLibFileName)
        return(2); // File not found

    // read the filename and additional info. into sz

    GetPrivateProfileString(szSection,          // ini section
                            szLibFileName,      // key name
                            szLibFileName,      // default if no match
                            sz,                 // return buffer
                            sizeof(sz),         // return buffer size
                            szIniFile);         // ini. file

    sz[sizeof(sz)-1] = 0;

    // strip off the additional info.

    pch = (LPSTR)sz;

    while (*pch)
        {
        if (*pch == ' ')
            {
            *pch++ = '\0';
            break;
            }            
        pch++;
        }

    // pch pts to ch after first space or null ch

    if (!GetModuleHandle(sz) &&
        OpenFile(sz, &of, OF_EXIST|OF_READ|OF_SHARE_DENY_NONE) == -1)
        return(2);

    // copy additional info. to lpstrTail

    if (lpstrTail && cbTail)
        {
        while (cbTail-- && (*lpstrTail++ = *pch++))
            ;
        *(lpstrTail-1) = 0;
        }

    return (LoadLibrary(sz));
}


/***************************************************************************
 *
 * @doc   INTERNAL 
 *
 * @api   int | GetDrvrUsage | Runs through the driver list and figures
 *        out how many instances of this driver module handle we have.
 *        We use this instead of GetModuleUsage so that we can have drivers
 *        loaded as normal DLLs and as installable drivers.
 *      
 * @parm  HANDLE | h | Driver's module handle
 *
 * @rdesc Returns the library's driver usage count.
 *
 ***************************************************************************/

int FAR PASCAL GetDrvrUsage(HANDLE h)
{
    LPDRIVERTABLE lpdt;
    int           index;
    int           count;

    if (!hInstalledDriverList || !cInstalledDrivers)
        return(0);

    count = 0;
    lpdt = (LPDRIVERTABLE)GlobalLock(hInstalledDriverList);
    for (index=0;index<cInstalledDrivers;index++)
        {
        if (lpdt->hModule==h)
            {
            count++;
            }
        lpdt++;
        }
    GlobalUnlock(hInstalledDriverList);

    return(count);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\heap.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  HEAP.ASM
;
;   This module contains functions for dealing with external local heaps
;
; Created:  09-20-90
; Author:   Todd Laney [ToddLa]
;
; Copyright (c) 1984-1990 Microsoft Corporation
;
; Exported Functions:	none
;
; Public Functions:     HeapCreate
;                       HeapDestroy
;                       HeapAlloc
;                       HeapFree
;
; Public Data:          none
;
; General Description:
;
; Restrictions:
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        ?NODATA = 1
        .286p

	.xlist
	include cmacros.inc
        include windows.inc
        .list

        MIN_HEAPSIZE    = 128
        GMEM_SHARE      = GMEM_DDESHARE

        externFP        LocalInit           ; in KERNEL
        externFP        LocalAlloc          ; in KERNEL
        externFP        LocalReAlloc        ; in KERNEL
        externFP        LocalFree           ; in KERNEL
        externFP        LocalCompact        ; in KERNEL
        externFP        GlobalAlloc         ; in KERNEL
        externFP        GlobalLock          ; in KERNEL
        externFP        GlobalUnlock        ; in KERNEL
        externFP        GlobalFree          ; in KERNEL


; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends

createSeg INIT, InitSeg, word, public, CODE

sBegin InitSeg
        assumes cs,InitSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; HeapCreate
;
;   Create a external heap
;
; Entry:
;       cbSize is the initial size of the heap
;
; Returns:
;       AX = handle to heap
; Error Returns:
;       AX = 0
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalAlloc, LocalInit
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapCreate, <FAR,PUBLIC>, <>
        ParmW   cbSize
cBegin
        mov     ax,cbSize
        cmp     ax,MIN_HEAPSIZE
        jg      hc_alloc
        mov     ax,MIN_HEAPSIZE
        mov     cbSize,ax

hc_alloc:
        cCall   GlobalAlloc, <GHND+GMEM_SHARE,0,ax>
        or      ax,ax
        jz      hc_exit

        cCall   GlobalLock, <ax>
        push    dx
        mov     ax,cbSize
        dec     ax
        cCall   LocalInit,<dx,0,ax>
        pop     ax
hc_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapDestroy
;
;   Destroys a external heap
;
; Entry:
;       hHeap contains heap handle (ie the selector)
;
; Returns:
;       none
; Error Returns:
;       none
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       GlobalUnlock, GlobalFree
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapDestroy, <FAR,PUBLIC>, <>
        ParmW   hHeap
cBegin
        cCall   GlobalUnlock, <hHeap>       ; !!! only need in REAL mode
        cCall   GlobalFree, <hHeap>
cEnd

sEnd

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
        assumes cs,CodeSeg
        assumes ds,nothing
        assumes es,nothing

;---------------------------Public-Routine------------------------------;
; HeapAlloc
;
;       allocate memory from a external heap
;
; Entry:
;       hHeap contains heap handle (ie the selector)
;       cbSize contains the requested size of the allocation
;
; Returns:
;       DX:AX = pointer to allocated object
; Error Returns:
;       DX:AX = NULL
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalAlloc
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapAlloc, <FAR,PUBLIC>, <ds>
        ParmW   hHeap
        ParmW   cbSize
cBegin
        mov     ds,hHeap
        cCall   LocalAlloc, <LPTR, cbSize>
        xor     dx,dx
        or      ax,ax
        jz      hal_exit
        mov     dx,ds
hal_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapReAlloc
;
;       reallocate memory from a external heap
;
; Entry:
;       lpObject contains the pointer to the object to be reallocated
;       cbSize contains the requested size of the reallocation
;
; Returns:
;       DX:AX = pointer to allocated object
; Error Returns:
;       DX:AX = NULL
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalAlloc
; History:
;       Wed  8-Jan-1991  1: 2: 3 -by-  David Levine [DavidLe]
;	Created based on HeapAlloc.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapReAlloc, <FAR,PUBLIC>, <ds>
        ParmD   lpObject
        ParmW   cbSize
cBegin
        lds     ax,lpObject

AllocFlags EQU LMEM_MOVEABLE OR LMEM_ZEROINIT

        cCall   LocalReAlloc, <ax, cbSize, AllocFlags>
        xor     dx,dx
        or      ax,ax
        jz      hral_exit
        mov     dx,ds
hral_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; HeapFree
;
;       free memory from a external heap
;
; Entry:
;       hObject contains the object to free
;
; Returns:
;       none
; Error Returns:
;       none
; Registers Preserved:
;       BP,DS,SI,DI
; Registers Destroyed:
;       AX,BX,CX,DX,FLAGS
; Calls:
;       LocalFree
; History:
;       Fri 21-Sep-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   HeapFree, <FAR,PUBLIC>, <ds>
        ParmD   lpObject
cBegin
        lds     ax,lpObject
        cCall   LocalFree, <ax>
cEnd

sEnd    CodeSeg
	end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\hmemcpy.asm ===
; mem.asm:
;
; masm -Mx -Zi -DSEGNAME=????? asm.asm
;
	TITLE MEM.ASM

;****************************************************************
;* MEM.ASM - Assembly mem-copy routines				*
;*		for 80286 and 80386				*
;****************************************************************
;

?PLM=1	    ; PASCAL Calling convention is DEFAULT
?WIN=0      ; Windows calling convention

.xlist
include cmacros.inc
include windows.inc
.list

	externA	    __WinFlags	    ; in KERNEL
	externA	    __AHINCR	    ; in KERNEL
	externA	    __AHSHIFT	    ; in KERNEL

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG	struc
lo	dw	?
hi	dw	?
LONG	ends

FARPOINTER	struc
off	dw	?
sel	dw	?
FARPOINTER	ends

; -------------------------------------------------------
;		DATA SEGMENT DECLARATIONS
; -------------------------------------------------------

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin Data
sEnd Data

sBegin CodeSeg
        assumes cs,CodeSeg
        assumes ds,DATA

cProc fstrrchr,<NEAR,PASCAL,PUBLIC,NODATA>,<di>
	ParmD	lsz
	ParmB	c
cBegin
	les	di, lsz
	xor	al, al			; Search for terminating NULL
	mov	cx, -1			; Search forever
	cld				; Moving forward
	repne	scasb			; Look for the NULL
	not	cx			; Negative value minus 1 gives length
	dec	cx			; CX is always incremented
	jcxz	fstrrchr_fail		; Zero length string fails
	dec	di			; DI is one past character found
	dec	di			; Back up to last character in string
	mov	al, c			; Get character to search for
	std				; Moving backwards
	repne	scasb			; Look for the character
	cld				; Reset direction
	jne	fstrrchr_fail		; Fail if not found
	inc	di			; Back up to actual character found
	mov	ax, di			; Return pointer to that character
	mov	dx, es
	jmp	fstrrchr_exit
fstrrchr_fail:
	xor	ax, ax			; Return NULL on failure
	cwd
fstrrchr_exit:
cEnd

;---------------------------Public-Routine------------------------------;
; MemCopy
;
;   copy memory, dons *not* handle overlaped copies.
;
; Entry:
;	lpSrc	HPSTR to copy from
;	lpDst	HPSTR to copy to
;	cbMem	DWORD count of bytes to move
;
; Returns:
;	destination pointer
; Error Returns:
;	None
; Registers Preserved:
;	BP,DS,SI,DI
; Registers Destroyed:
;	AX,BX,CX,DX,FLAGS
; Calls:
;	nothing
; History:
;
;	Wed 04-Jan-1990 13:45:58 -by-  Todd Laney [ToddLa]
;	Created.
;	Tue 16-Oct-1990 16:41:00 -by-  David Maymudes [DavidMay]
;	Modified 286 case to work correctly with cbMem >= 64K.
;	Changed name to hmemcpy.
;	Changed 386 case to copy by longwords
;-----------------------------------------------------------------------;

cProc MemCopy,<NEAR,PASCAL,PUBLIC,NODATA>,<>
;	 ParmD	 lpDst
;	 ParmD	 lpSrc
;	 ParmD	 cbMem
cBegin	<nogen>
	mov	ax,__WinFlags
	test	ax,WF_CPU286
        jz      MemCopy386
        jmp     NEAR PTR MemCopy286
cEnd <nogen>

cProc MemCopy386,<NEAR,PASCAL,PUBLIC,NODATA>,<ds>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	.386
	push	edi
	push	esi
	cld

	mov	ecx,cbMem
	jecxz	mc386_exit

	movzx	edi,di
	movzx	esi,si
	lds	si,lpSrc
	les	di,lpDst

	push	ecx
	shr	ecx,2		; get count in DWORDs
	rep	movs dword ptr es:[edi], dword ptr ds:[esi]
	db	67H
	pop	ecx
	and	ecx,3
	rep	movs byte ptr es:[edi], byte ptr ds:[esi]
	db	67H
	nop
mc386_exit:
	cld
	pop	esi
	pop	edi
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
	.286
cEnd

cProc MemCopy286,<NEAR,PASCAL,PUBLIC,NODATA>,<ds,si,di>
	ParmD	lpDst
	ParmD	lpSrc
	ParmD	cbMem
cBegin
	mov	cx,cbMem.lo	; CX holds count
	or	cx,cbMem.hi	; or with high word
	jnz	@f
	jmp	empty_copy
@@:
	lds	si,lpSrc	  ; DS:SI = src
	les	di,lpDst	  ; ES:DI = dst

next:
	mov	ax,cx
	dec	ax

	mov	ax,di
	not	ax		; AX = 65535-DI

	mov	dx,si
	not	dx		; DX = 65535-SI

	sub	ax,dx
	sbb	bx,bx
	and	ax,bx
	add	ax,dx		; AX = MIN(AX,DX) = MIN(65535-SI,65535-DI)

	; problem: ax might have wrapped to zero

	test	cbMem.hi,-1
	jnz	plentytogo	; at least 64k still to copy
	
	dec	cx		; this is ok, since high word is zero
	sub	ax,cx
	sbb	bx,bx
	and	ax,bx
	add	ax,cx		; AX = MIN(AX,CX)
	inc	cx

plentytogo:
	xor	bx,bx
	add	ax,1		; AX = Num = MIN(count,65536-SI,65536-DI)
				; we must check the carry here!
	adc	bx,0		; BX could be 1 here, if CX==0 indicating
				; exactly 64k to copy
	xchg	ax,cx
	sub	ax,cx		; Count -= Num
	sbb	cbMem.hi,bx

	shr	bx,1
	rcr	cx,1		; if bx==1, then cx ends up 0x8000
	rep	movsw
	jnc	@f
	movsb			; move last byte, if necessary
@@:
	mov	cx,ax		; put low word of count back in cx
	or	ax,cbMem.hi

	jz	done		; If Count == 0 Then BREAK

	or	si,si		; if SI wraps, update DS
	jnz	@f
;
	mov	ax,ds
	add	ax,__AHINCR
	mov	ds,ax		; update DS if appropriate
@@:
	or	di,di		; if DI wraps, update ES
	jnz	next
;
	mov	ax,es
	add	ax,__AHINCR
	mov	es,ax		; update ES if appropriate
	jmp	next
;
; Restore registers and return
;
done:
empty_copy:
	mov	dx,lpDst.sel	; return destination address
	mov	ax,lpDst.off
cEnd

sEnd

sEnd CodeSeg
end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\int31.inc ===
;******************************************************************************
;
;   (C) Copyright MICROSOFT Corp., 1989-1990
;
;   Title:	INT31.INC - Equates and Structures for Int 31h Interface
;
;   Version:	3.00
;
;   Date:	22-May-1989
;
;   Author:	RAL
;
;------------------------------------------------------------------------------
;
;   Change log:
;
;      DATE	REV		    DESCRIPTION
;   ----------- --- -----------------------------------------------------------
;   22-May-1989 RAL Original
;
;==============================================================================



Int31_Sel_Mgt		EQU	00h
    SelMgt_Alloc_Sel	EQU	00h
    SelMgt_Free_Sel	EQU	01h
    SelMgt_Seg_To_Sel	EQU	02h
    SelMgt_Get_LDT_Base EQU	03h
    SelMgt_Lock_Sel	EQU	04h
    SelMgt_Unlock_Sel	EQU	05h
    SelMgt_Get_Base	EQU	06h
    SelMgt_Set_Base	EQU	07h
    SelMgt_Set_Limit	EQU	08h
    SelMgt_Set_Acc_Bits EQU	09h
    SelMgt_Alias_Sel	EQU	0Ah
    SelMgt_Get_Desc	EQU	0Bh
    SelMgt_Set_Desc	EQU	0Ch
    SelMgt_Get_Spec_Sel EQU	0Dh

Int31_DOS_Mem_Mgt	EQU	01h
    DOSMem_Allocate	EQU	00h
    DOSMem_Free 	EQU	01h
    DOSMem_Resize	EQU	02h

Int31_Int_Serv		EQU	02h
    Int_Get_Real_Vec	EQU	00h
    Int_Set_Real_Vec	EQU	01h
    Int_Get_Excep_Vec	EQU	02h
    Int_Set_Excep_Vec	EQU	03h
    Int_Get_PMode_Vec	EQU	04h
    Int_Set_PMode_Vec	EQU	05h

Int31_Trans_Serv	EQU	03h
    Trans_Sim_Int	EQU	00h
    Trans_Far_Call	EQU	01h
    Trans_Call_Int_Proc EQU	02h
    Trans_Call_Back	EQU	03h
    Trans_Free_CB	EQU	04h
    Trans_Get_Save_Addr EQU	05h
    Trans_Get_Sw_Addr	EQU	06h

Int31_Get_Version	EQU	04h

Int31_Mem_Mgt		EQU	05h
    MemMgt_Get_Info	EQU	00h
    MemMgt_Allocate	EQU	01h
    MemMgt_Free 	EQU	02h
    MemMgt_Resize	EQU	03h

Int31_Page_Lock 	EQU	06h
    Lock_Region 	EQU	00h
    Unlock_Region	EQU	01h
    Mark_Pageable	EQU	02h
    Mark_Not_Pageable	EQU	03h
    Get_Page_Size	EQU	04h

Int31_Demand_Page_Tune	EQU	07h
    Page_Candidate	EQU	00h
    Page_Discard	EQU	01h
    DPMI_Candidate	EQU	02h
    DPMI_Discard	EQU	03h

Int31_Map_Phys_Addr	EQU	08h

Int31_Virt_Int_State	EQU	09h
    Get_Clear_Int_State EQU	00h
    Get_Set_Int_State	EQU	01h
    Get_Int_State	EQU	02h


Real_Mode_Call_Struc	STRUC
RealMode_EDI	dd	?
RealMode_ESI	dd	?
RealMode_EBP	dd	?
		dd	?
RealMode_EBX	dd	?
RealMode_EDX	dd	?
RealMode_ECX	dd	?
RealMode_EAX	dd	?
RealMode_Flags	dw	?
RealMode_ES	dw	?
RealMode_DS	dw	?
RealMode_FS	dw	?
RealMode_GS	dw	?
RealMode_IP	dw	?
RealMode_CS	dw	?
RealMode_SP	dw	?
RealMode_SS	dw	?
Real_Mode_Call_Struc	ENDS


Real_Mode_Word_Regs	STRUC
RealMode_DI	dw	?
		dw	?
RealMode_SI	dw	?
		dw	?
RealMode_BP	dw	?
		dw	?
		dd	?
RealMode_BX	dw	?
		dw	?
RealMode_DX	dw	?
		dw	?
RealMode_CX	dw	?
		dw	?
RealMode_AX	dw	?
Real_Mode_Word_Regs	ENDS


Real_Mode_Byte_Regs	STRUC
		dd	4 dup (?)
RealMode_BL	db	?
RealMode_BH	db	?
		dw	?
RealMode_DL	db	?
RealMode_DH	db	?
		dw	?
RealMode_CL	db	?
RealMode_CH	db	?
		dw	?
RealMode_AL	db	?
RealMode_AH	db	?
Real_Mode_Byte_Regs	ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\idrv.h ===
//==========================================================================;
//
//  idrv.h
//
//  Description:
//      This header file defines common information needed for compiling
//      the installable driver.
//
//  History:
//      11/ 8/92    cjp     [curtisp]
//
//==========================================================================;

#ifndef _INC_IDRV
#define _INC_IDRV                   // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 32
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifdef WIN32
    #ifndef FNLOCAL
        #define FNLOCAL
        #define FNCLOCAL
        #define FNGLOBAL
        #define FNCGLOBAL
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK
    #endif

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)    \
        ((DWORD)SendMessage((hwndCtl), EM_GETSEL, (WPARAM)pnS, (LPARAM)pnE))

    //
    //  for compiling Unicode
    //
    #ifdef UNICODE
        #define SIZEOF(x)   (sizeof(x)/sizeof(WCHAR))
    #else
        #define SIZEOF(x)   sizeof(x)
    #endif

    //
    //  win32 apps [usually] don't have to worry about 'huge' data
    //
    #define hmemcpy     memcpy
#endif // #ifdef WIN32


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Win 16
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef WIN32
    #ifndef FNLOCAL
        #ifdef CALLBACK
            #undef CALLBACK
        #endif
        #ifdef _WINDLL
            #define CALLBACK    _far _pascal _loadds
        #else
            #define CALLBACK    _far _pascal
        #endif

    #ifdef DEBUG
        #define FNLOCAL     NEAR PASCAL
        #define FNCLOCAL    NEAR _cdecl
    #else
        #define FNLOCAL     static NEAR PASCAL
        #define FNCLOCAL    static NEAR _cdecl
    #endif
        #define FNGLOBAL    FAR PASCAL
        #define FNCGLOBAL   FAR _cdecl
        #define FNWCALLBACK CALLBACK
        #define FNEXPORT    CALLBACK _export
    #endif

    //
    //  stuff for Unicode in Win 32--make it a noop in Win 16
    //
    #ifndef _TCHAR_DEFINED
        #define _TCHAR_DEFINED
        typedef char            TCHAR, *PTCHAR;
        typedef unsigned char   TBYTE, *PTUCHAR;

        typedef PSTR            PTSTR, PTCH;
        typedef LPSTR           LPTSTR, LPTCH;
        typedef LPCSTR          LPCTSTR;
    #endif

    #define TEXT(a)         a
    #define SIZEOF(x)       sizeof(x)

    //
    //
    //
    #define CharNext        AnsiNext
    #define CharPrev        AnsiPrev

    //
    //
    //
    #define Edit_GetSelEx(hwndCtl, pnS, pnE)                        \
    {                                                               \
        DWORD   dw;                                                 \
        dw = (DWORD)SendMessage((hwndCtl), EM_GETSEL, 0, 0L);       \
        *pnE = (int)HIWORD(dw);                                     \
        *pnS = (int)LOWORD(dw);                                     \
    }

    //
    //  common message cracker macros available in windowx.h on NT--these
    //  should be added to the Win 16 windowsx.h and probably will be
    //  in the future.
    //
    //  there is a windowsx.h16 that ships with the NT PDK that defines
    //  these macros. so if that version is being used, don't redefine
    //  message crackers.
    //

#ifndef WM_CTLCOLORMSGBOX
    #define WM_CTLCOLORMSGBOX           0x0132
    #define WM_CTLCOLOREDIT             0x0133
    #define WM_CTLCOLORLISTBOX          0x0134
    #define WM_CTLCOLORBTN              0x0135
    #define WM_CTLCOLORDLG              0x0136
    #define WM_CTLCOLORSCROLLBAR        0x0137
    #define WM_CTLCOLORSTATIC           0x0138
#endif

#ifndef GET_WM_ACTIVATE_STATE
    #define GET_WM_ACTIVATE_STATE(wp, lp)           (wp)
    #define GET_WM_ACTIVATE_FMINIMIZED(wp, lp)      (BOOL)HIWORD(lp)
    #define GET_WM_ACTIVATE_HWND(wp, lp)            (HWND)LOWORD(lp)
    #define GET_WM_ACTIVATE_MPS(s, fmin, hwnd)      (WPARAM)(s), MAKELONG(hwnd, fmin)

    #define GET_WM_CHARTOITEM_CHAR(wp, lp)          (CHAR)(wp)
    #define GET_WM_CHARTOITEM_POS(wp, lp)           HIWORD(lp)
    #define GET_WM_CHARTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_CHARTOITEM_MPS(ch, pos, hwnd)    (WPARAM)(ch), MAKELONG(hwnd, pos)

    #define GET_WM_COMMAND_ID(wp, lp)               (wp)
    #define GET_WM_COMMAND_HWND(wp, lp)             (HWND)LOWORD(lp)
    #define GET_WM_COMMAND_CMD(wp, lp)              HIWORD(lp)
    #define GET_WM_COMMAND_MPS(id, hwnd, cmd)       (WPARAM)(id), MAKELONG(hwnd, cmd)

    #define GET_WM_CTLCOLOR_HDC(wp, lp, msg)        (HDC)(wp)
    #define GET_WM_CTLCOLOR_HWND(wp, lp, msg)       (HWND)LOWORD(lp)
    #define GET_WM_CTLCOLOR_TYPE(wp, lp, msg)       HIWORD(lp)
    #define GET_WM_CTLCOLOR_MPS(hdc, hwnd, type)    (WPARAM)(hdc), MAKELONG(hwnd, type)

    #define GET_WM_MENUSELECT_CMD(wp, lp)           (wp)
    #define GET_WM_MENUSELECT_FLAGS(wp, lp)         LOWORD(lp)
    #define GET_WM_MENUSELECT_HMENU(wp, lp)         (HMENU)HIWORD(lp)
    #define GET_WM_MENUSELECT_MPS(cmd, f, hmenu)    (WPARAM)(cmd), MAKELONG(f, hmenu)

    // Note: the following are for interpreting MDIclient to MDI child messages.
    #define GET_WM_MDIACTIVATE_FACTIVATE(hwnd, wp, lp)  (BOOL)(wp)
    #define GET_WM_MDIACTIVATE_HWNDDEACT(wp, lp)        (HWND)HIWORD(lp)
    #define GET_WM_MDIACTIVATE_HWNDACTIVATE(wp, lp)     (HWND)LOWORD(lp)

    // Note: the following is for sending to the MDI client window.
    #define GET_WM_MDIACTIVATE_MPS(f, hwndD, hwndA) (WPARAM)(hwndA), 0

    #define GET_WM_MDISETMENU_MPS(hmenuF, hmenuW)   0, MAKELONG(hmenuF, hmenuW)

    #define GET_WM_MENUCHAR_CHAR(wp, lp)            (CHAR)(wp)
    #define GET_WM_MENUCHAR_HMENU(wp, lp)           (HMENU)LOWORD(lp)
    #define GET_WM_MENUCHAR_FMENU(wp, lp)           (BOOL)HIWORD(lp)
    #define GET_WM_MENUCHAR_MPS(ch, hmenu, f)       (WPARAM)(ch), MAKELONG(hmenu, f)

    #define GET_WM_PARENTNOTIFY_MSG(wp, lp)         (wp)
    #define GET_WM_PARENTNOTIFY_ID(wp, lp)          HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_HWNDCHILD(wp, lp)   (HWND)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_X(wp, lp)           (INT)LOWORD(lp)
    #define GET_WM_PARENTNOTIFY_Y(wp, lp)           (INT)HIWORD(lp)
    #define GET_WM_PARENTNOTIFY_MPS(msg, id, hwnd)  (WPARAM)(msg), MAKELONG(hwnd, id)
    #define GET_WM_PARENTNOTIFY2_MPS(msg, x, y)     (WPARAM)(msg), MAKELONG(x, y)

    #define GET_WM_VKEYTOITEM_CODE(wp, lp)          (wp)
    #define GET_WM_VKEYTOITEM_ITEM(wp, lp)          (INT)HIWORD(lp)
    #define GET_WM_VKEYTOITEM_HWND(wp, lp)          (HWND)LOWORD(lp)
    #define GET_WM_VKEYTOITEM_MPS(code, item, hwnd) (WPARAM)(code), MAKELONG(hwnd, item)

    #define GET_EM_SETSEL_START(wp, lp)             LOWORD(lp)
    #define GET_EM_SETSEL_END(wp, lp)               HIWORD(lp)
    #define GET_EM_SETSEL_MPS(iStart, iEnd)         0, MAKELONG(iStart, iEnd)

    #define GET_EM_LINESCROLL_MPS(vert, horz)       0, MAKELONG(vert, horz)

    #define GET_WM_CHANGECBCHAIN_HWNDNEXT(wp, lp)   (HWND)LOWORD(lp)

    #define GET_WM_HSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_HSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_HSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_HSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)

    #define GET_WM_VSCROLL_CODE(wp, lp)             (wp)
    #define GET_WM_VSCROLL_POS(wp, lp)              LOWORD(lp)
    #define GET_WM_VSCROLL_HWND(wp, lp)             (HWND)HIWORD(lp)
    #define GET_WM_VSCROLL_MPS(code, pos, hwnd)     (WPARAM)(code), MAKELONG(pos, hwnd)
#endif

#endif // #ifndef WIN32






//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  Installable Driver Version Information:
//
//
//
//  NOTE! all string resources that will be used in app.rcv for the
//  version resource information *MUST* have an explicit \0 terminator!
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#define IDRV_VERSION_MAJOR          3
#define IDRV_VERSION_MINOR          11
#define IDRV_VERSION_BUILD          43
#ifdef UNICODE
#define IDRV_VERSION_STRING_RC      "Version 3.11 (Unicode Enabled)\0"
#else
#define IDRV_VERSION_STRING_RC      "Version 3.11\0"
#endif

#define IDRV_VERSION_NAME_RC        "msmixmgr.dll\0"
#define IDRV_VERSION_COMPANYNAME_RC "Microsoft Corporation\0"
#define IDRV_VERSION_COPYRIGHT_RC   "Copyright \251 Microsoft Corp. 1993\0"

#define IDRV_VERSION_PRODUCTNAME_RC "Microsoft Audio Mixer Manager\0"

#ifdef DEBUG
#define IDRV_VERSION_DESCRIPTION_RC "Microsoft Audio Mixer Manager (debug)\0"
#else
#define IDRV_VERSION_DESCRIPTION_RC "Microsoft Audio Mixer Manager\0"
#endif


//
//  Unicode versions (if UNICODE is defined)... the resource compiler
//  cannot deal with the TEXT() macro.
//
#define IDRV_VERSION_STRING         TEXT(IDRV_VERSION_STRING_RC)
#define IDRV_VERSION_NAME           TEXT(IDRV_VERSION_NAME_RC)
#define IDRV_VERSION_COMPANYNAME    TEXT(IDRV_VERSION_COMPANYNAME_RC)
#define IDRV_VERSION_COPYRIGHT      TEXT(IDRV_VERSION_COPYRIGHT_RC)
#define IDRV_VERSION_PRODUCTNAME    TEXT(IDRV_VERSION_PRODUCTNAME_RC)
#define IDRV_VERSION_DESCRIPTION    TEXT(IDRV_VERSION_DESCRIPTION_RC)




//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  misc defines for misc sizes and things...
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  bilingual. this allows the same identifier to be used in resource files
//  and code without having to decorate the id in your code.
//
#ifdef RC_INVOKED
    #define RCID(id)                id
#else
    #define RCID(id)                MAKEINTRESOURCE(id)
#endif


//
//
//
#ifdef WIN32
    #define BSTACK
    #define BCODE
    #define BDATA
#else
    #define BSTACK  _based(_segname("_STACK"))
    #define BCODE   _based(_segname("_CODE"))
    #define BDATA   _based(_segname("_DATA"))
#endif


//
//
//
//
#define IDRV_MAX_STRING_RC_CHARS    512
#define IDRV_MAX_STRING_RC_BYTES    (IDRV_MAX_STRING_RC_CHARS * sizeof(TCHAR))
#define IDRV_MAX_STRING_ERROR_CHARS 512
#define IDRV_MAX_STRING_ERROR_BYTES (IDRV_MAX_STRING_ERROR_CHARS * sizeof(TCHAR))


//
//  resource defines...
//
#define ICON_IDRV                   RCID(10)


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

BOOL FNGLOBAL ProfileWriteUInt
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    UINT            uValue
);

UINT FNGLOBAL ProfileReadUInt
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    UINT            uDefault
);

BOOL FNGLOBAL ProfileWriteString
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPCTSTR         pszValue
);

UINT FNGLOBAL ProfileReadString
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPCTSTR         pszDefault,
    LPTSTR          pszBuffer,
    UINT            cbBuffer
);

BOOL FNGLOBAL ProfileWriteBytes
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
);

BOOL FNGLOBAL ProfileReadBytes
(
    LPCTSTR         pszSection,
    LPCTSTR         pszKey,
    LPBYTE          pbStruct,
    UINT            cbStruct
);


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//
//
#define BOGUS_DRIVER_ID     1L


//
//
//
//
typedef struct tIDRVINST
{
    HDRVR           hdrvr;          // driver handle we were opened with

} IDRVINST, *PIDRVINST, FAR *LPIDRVINST;



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

LRESULT FNGLOBAL IDrvLoad
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvFree
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvEnable
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvDisable
(
    HDRVR               hdrvr
);

LRESULT FNGLOBAL IDrvExitSession
(
    PIDRVINST           pidi
);

LRESULT FNGLOBAL IDrvConfigure
(
    PIDRVINST           pidi,
    HWND                hwnd,
    LPDRVCONFIGINFO     pdci
);


LRESULT FNGLOBAL IDrvInstall
(
    PIDRVINST           pidi,
    LPDRVCONFIGINFO     pdci
);

LRESULT FNGLOBAL IDrvRemove
(
    PIDRVINST           pidi
);



//
//  defines for gfuIDrvFlags
//
//
#define IDRVF_FIRSTLOAD             0x0001
#define IDRVF_ENABLED               0x0002


//
//  defines for gfuIDrvOptions
//
//
#define IDRV_OPTF_ZYZSMAG           0x0001



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  global variables
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

extern HINSTANCE    ghinstIDrv;

extern UINT         gfuIDrvFlags;
extern UINT         gfuIDrvOptions;

extern TCHAR        gszIDrvSecConfig[];
extern TCHAR        gszNull[];


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_IDRV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\init.c ===
/*
    init.c

    Level 1 kitchen sink DLL initialisation

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/
#ifdef DEBUG
#ifndef DEBUG_RETAIL
#define DEBUG_RETAIL
#endif
#endif

#include <windows.h>
#include <mmsysver.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "drvr.h"
#include "thunks.h"


/****************************************************************************

    global data

****************************************************************************/

HINSTANCE ghInst;                     // our module handle


/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
LPCB32             PASCAL cb32;
LPSOUNDDEVMSGPROC  PASCAL wod32Message;
LPSOUNDDEVMSGPROC  PASCAL wid32Message;
LPSOUNDDEVMSGPROC  PASCAL mod32Message;
LPSOUNDDEVMSGPROC  PASCAL mid32Message;
LPSOUNDDEVMSGPROC  PASCAL aux32Message;
JOYMESSAGEPROC     PASCAL joy32Message;


UINT FAR PASCAL _loadds ThunkInit(void);
static BOOL NEAR PASCAL ThunkTerm( void );

LPSOUNDDEVMSGPROC  PASCAL wodMapper;
LPSOUNDDEVMSGPROC  PASCAL widMapper;


#ifdef DEBUG_RETAIL
BYTE    fIdReverse;                   // reverse wave/midi id's
#endif

PHNDL pHandleList;

#ifdef   DEBUG_RETAIL
extern  int         DebugmciSendCommand;    // in MCI.C
#endif

#ifdef DEBUG
extern  WORD        fDebug;
#endif

/****************************************************************************

    strings

****************************************************************************/

static  SZCODE  szMMWow32[]             = "winmm.dll";
static  SZCODE  szNotifyCB[]             = "NotifyCallbackData";
static  SZCODE  szWodMessage[]          = "wod32Message";
static  SZCODE  szWidMessage[]          = "wid32Message";
static  SZCODE  szModMessage[]          = "mod32Message";
static  SZCODE  szMidMessage[]          = "mid32Message";
static  SZCODE  szAuxMessage[]          = "aux32Message";
static  SZCODE  szTidMessage[]          = "tid32Message";
static  SZCODE  szJoyMessage[]          = "joy32Message";
static  SZCODE  szWaveMapper[]          = "wavemapper";
static  SZCODE  szWodMapper[]           = "wodMessage";
static  SZCODE  szWidMapper[]           = "widMessage";

        SZCODE  szNull[]                = "";
        SZCODE  szSystemIni[]           = "system.ini";
        SZCODE  szDrivers[]             = "Drivers";
        SZCODE  szBoot[]                = "boot";
        SZCODE  szDriverProc[]          = "DriverProc";
        SZCODE  szJoystick[]            = "joystick";
        SZCODE  szJoystickDrv[]         = "joystick.drv";
        SZCODE  szTimerDrv[]            = "timer";

#ifdef DEBUG_RETAIL
        SZCODE  szLibMain[]     = "MMSYSTEM: Win%dp %ls Version"
                                  "%d.%02d MMSystem Version %d.%02d.%03d\r\n";
        SZCODE  szWinDebug[]    = "(Debug)";
        SZCODE  szWinRetail[]   = "(Retail)";
#endif

        SZCODE  szMMSystem[]            = "mmsystem";
        SZCODE  szStackFrames[]         = "StackFrames";
        SZCODE  szStackSize[]           = "StackSize";

#ifdef DEBUG_RETAIL
        SZCODE  szDebugOutput[]         = "DebugOutput";
        SZCODE  szMci[]                 = "mci";
#endif
#ifdef DEBUG
        SZCODE  szDebug[]               = "Debug";
#endif

#ifdef   DEBUG_RETAIL
/*****************************************************************************
 *
 * DebugInit()  - called from init.c!LibMain() to handle any DLL load time
 *                initialization in the DEBUG version
 *
 ****************************************************************************/

#pragma warning(4:4704)

static  void NEAR PASCAL
DebugInit(
    void
    )
{
        fDebugOutput = GetPrivateProfileInt(szMMSystem,szDebugOutput,0,szSystemIni);
        DebugmciSendCommand = GetPrivateProfileInt(szMMSystem,szMci,0,szSystemIni);

#ifdef DEBUG
        fDebug = GetPrivateProfileInt(szMMSystem,szDebug,fDebugOutput,szSystemIni);

        if (fDebug && !fDebugOutput)
                fDebug = FALSE;

        if (fDebug) {
            OutputDebugString( "Breaking for debugging\r\n" );
            _asm int 3
        }
#endif
}
#endif   // ifdef DEBUG_RETAIL



/****************************************************************************

    Library initialization code

    libentry took care of calling LibMain() and other things....

****************************************************************************/
int NEAR PASCAL
LibMain(
    HINSTANCE hInstance,
    UINT cbHeap,
    LPSTR lpCmdLine
    )
{

#ifdef DEBUG_RETAIL
    WORD    w;
#endif

    ghInst = hInstance;

    /*
    ** Here we do a global alloc of the Callback data array.  We then
    ** Lock and Page Lock the allocated storage and initialize the storage
    ** to all zeros.  We then call WOW32 passing to it the address of the
    ** Callback data array, which is saved by WOW32.
    */
    hGlobal = GlobalAlloc( GHND, sizeof(CALLBACK_DATA) );
    if ( hGlobal == (HGLOBAL)NULL ) {
        return FALSE;
    }

    vpCallbackData = (VPCALLBACK_DATA)GlobalLock( hGlobal );
    if ( vpCallbackData == NULL ) {
        return FALSE;
    }

    if ( !HugePageLock( vpCallbackData, (DWORD)sizeof(CALLBACK_DATA) ) ) {
        return FALSE;
    }

    /*
    ** Now we create our interrupt callback stacks.
    */
    if ( StackInit() == FALSE ) {
        return FALSE;
    }

    /*
    ** Now we install our interrupt service routine.  InstallInterruptHandler
    ** return FALSE if it couldn't set the interrupt vector.  If this is the
    ** case we have to terminate the load of the dll.
    */
    if ( InstallInterruptHandler() == FALSE ) {
        return FALSE;
    }


#ifdef DEBUG_RETAIL
    DebugInit();
    w = (WORD)GetVersion();
#endif

    DPRINTF(( szLibMain, WinFlags & WF_WIN386 ? 386 : 286,
        (LPSTR)(GetSystemMetrics(SM_DEBUG) ? szWinDebug : szWinRetail),
        LOBYTE(w), HIBYTE(w),
        HIBYTE(mmsystemGetVersion()), LOBYTE(mmsystemGetVersion()),
        MMSYSRELEASE ));

#ifdef DEBUG
    DPRINTF(("MMSYSTEM: NumTasks: %d\r\n", GetNumTasks()));
    //
    // 3.0 - MMSYSTEM must be loaded by MMSOUND (ie at boot time)
    // check for this and fail to load otherwise.
    //
    // the real reason we need loaded at boot time is so we can get
    // in the enable/disable chain.
    //
    if (GetNumTasks() > 1)
    {
        DOUT("MMSYSTEM: ***!!! Not correctly installed !!!***\r\n");
////////return FALSE;   -Dont fail loading, just don't Enable()
    }
#endif

#ifdef DEBUG_RETAIL
    //
    // fIdReverse being TRUE causes mmsystem to reverse all wave/midi
    // logical device id's.
    //
    // this prevents apps/drivers assuming a driver load order.
    //
    // see wave.c!MapWaveId() and midi.c!MapId()
    //

    fIdReverse = LOBYTE(LOWORD(GetCurrentTime())) & (BYTE)0x01;

    if (fIdReverse)
        ROUT("MMSYSTEM: wave/midi driver id's will be inverted");
#endif

    //
    // do a LoadLibrary() on ourself
    //
    LoadLibrary(szMMSystem);

    return TRUE;
}

/****************************************************************************

    DrvFree - Handler for a DRV_FREE driver message

****************************************************************************/
void FAR PASCAL
DrvFree(
    void
    )
{
    MCITerminate();     // mci.c    free heap
    WndTerminate();     // mmwnd.c  destroy window, unregister class
    if ( mmwow32Lib != 0L ) {
        ThunkTerm();
    }
}


/****************************************************************************

    DrvLoad - handler for a DRV_LOAD driver message

****************************************************************************/
BOOL FAR PASCAL DrvLoad(void)
{

/*
**  The VFW1.1 wave mapper was GP faulting in Daytona when running dangerous
**  creatures videos.  Since it was trying to load an invalid selector in
**  its callback routine it's doubtful we can ever enable them.
**
*/
#if 0 // The wave mappers were GP faulting in Daytona so NOOP for now

    HDRVR   h;


    /* The wave mapper.
     *
     * MMSYSTEM allows the user to install a special wave driver which is
     * not visible to the application as a physical device (it is not
     * included in the number returned from getnumdevs).
     *
     * An application opens the wave mapper when it does not care which
     * physical device is used to input or output waveform data. Thus
     * it is the wave mapper's task to select a physical device that can
     * render the application-specified waveform format or to convert the
     * data into a format that is renderable by an available physical
     * device.
     */

    if (h = mmDrvOpen(szWaveMapper))
    {
        mmDrvInstall(h, &wodMapper, MMDRVI_MAPPER|MMDRVI_WAVEOUT|MMDRVI_HDRV);
        /* open again to get usage count in DLL correct */
        h = mmDrvOpen(szWaveMapper);
        mmDrvInstall(h, &widMapper, MMDRVI_MAPPER|MMDRVI_WAVEIN |MMDRVI_HDRV);
    }
#endif // NOOP wave mapper


    if ( TimeInit() && WndInit() ) {
        return TRUE;
    }

    //
    // something failed, backout the changes
    //
    DrvFree();
    return FALSE;
}

/******************************Public*Routine******************************\
* StackInit
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL FAR PASCAL
StackInit(
    void
    )
{
#   define GMEM_STACK_FLAGS        (GMEM_FIXED | GMEM_SHARE)
#   define DEF_STACK_SIZE          0x600           // 1.5k
#   define DEF_STACK_FRAMES        3
#   define MIN_STACK_SIZE          64
#   define MIN_STACK_FRAMES        1

    DWORD   dwStackBytes;
    WORD    wStackFrames;

    //
    //  The original Window 3.1 code didn't create stack frames for the
    //  Windows Enchanced mode.  However, WOW only emulates standard mode so
    //  I won't bother with this distinction.
    //
    //  if (WinFlags & WF_ENHANCED)
    //      return TRUE;
    //

    /* read stackframes and stacksize from system.ini */
    gwStackSize = GetPrivateProfileInt( szMMSystem, szStackSize,
                                        DEF_STACK_SIZE, szSystemIni );

    /* make sure value isn't something bad */
    if ( gwStackSize < DEF_STACK_SIZE ) {
        gwStackSize = DEF_STACK_SIZE;
    }

    wStackFrames = GetPrivateProfileInt( szMMSystem, szStackFrames,
                                         DEF_STACK_FRAMES, szSystemIni );

    //
    // Always create at least DEF_STACK_FRAMES stack frames.
    //
    if ( wStackFrames < DEF_STACK_FRAMES ) {
        wStackFrames = DEF_STACK_FRAMES;
    }

    gwStackFrames = wStackFrames;

    /* round to nearest number of WORDs */
    gwStackSize = (gwStackSize + 1) & ~1;

    dwStackBytes = (DWORD)gwStackSize * (DWORD)gwStackFrames;

    /* try to alloc memory */
    if ( dwStackBytes >= 0x10000 ||
       !(gwStackSelector = GlobalAlloc(GMEM_STACK_FLAGS, dwStackBytes)) )
    {
        gwStackFrames = DEF_STACK_FRAMES;
        gwStackSize   = DEF_STACK_SIZE;

        /* do as little at runtime as possible.. */
        dwStackBytes = (DWORD)(DEF_STACK_FRAMES * DEF_STACK_SIZE);

        /* try allocating defaults--if this fails, we are HOSED! */
        gwStackSelector = GlobalAlloc( GMEM_STACK_FLAGS, dwStackBytes );
    }

    /*
    ** set to first available stack
    */
    gwStackUse = (WORD)dwStackBytes;


    /*
    ** did we get memory for stacks??
    */
    if ( !gwStackSelector ) {

        /*
        ** no stacks available... as if we have a chance of survival!
        */

        gwStackUse = 0;
        return FALSE;
    }

    /* looks good... */
    return TRUE;
}


/*****************************Private*Routine******************************\
* StackInit
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL NEAR PASCAL
StackTerminate(
    void
    )
{
    if ( gwStackSelector )
    {
        DOUT("MMSTACKS: Freeing stacks\r\n");

        gwStackSelector = GlobalFree( gwStackSelector );

        if ( gwStackSelector )
            DOUT("MMSTACKS: GlobalFree failed!\r\n");
    }

    /* return the outcome... non-zero is bad */
    return ( (BOOL)gwStackSelector );
} /* StackTerminate() */


/*****************************************************************************
 * @doc EXTERNAL MMSYSTEM
 *
 * @api WORD | mmsystemGetVersion | This function returns the current
 * version number of the Multimedia extensions system software.
 *
 * @rdesc The return value specifies the major and minor version numbers of
 * the Multimedia extensions.  The high-order byte specifies the major
 * version number.  The low-order byte specifies the minor version number.
 *
 ****************************************************************************/
WORD WINAPI mmsystemGetVersion(void)
{
    return(MMSYSTEM_VERSION);
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   BOOL | DrvTerminate | This function cleans up the installable
 *        driver interface.
 *
 ****************************************************************************/
static void NEAR PASCAL DrvTerminate(void)
{
// don't know about system exit dll order - so do nothing.
}


/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | mmDrvInstall | This function installs a WAVE driver
 *
 * @parm HANDLE | hDriver | Module handle or driver handle containing driver
 *
 * @parm DRIVERMSGPROC | drvMessage | driver message procedure, if NULL
 *      the standard name will be used (looked for with GetProcAddress)
 *
 * @parm UINT | wFlags | flags
 *
 *      @flag MMDRVI_TYPE      | driver type mask
 *      @flag MMDRVI_WAVEIN    | install driver as a wave input  driver
 *      @flag MMDRVI_WAVEOUT   | install driver as a wave ouput  driver
 *
 *      @flag MMDRVI_MAPPER    | install this driver as the mapper
 *      @flag MMDRVI_HDRV      | hDriver is a installable driver
 *
 *  @rdesc  returns NULL if unable to install driver
 *
 ****************************************************************************/
BOOL WINAPI
mmDrvInstall(
    HANDLE hDriver,
    DRIVERMSGPROC *drvMessage,
    UINT wFlags
    )
{
    DWORD       dw;
    HINSTANCE   hModule;
    UINT        msg_num_devs;
    SZCODE      *szMessage;

    hModule = GetDriverModuleHandle((HDRVR)hDriver);

    switch (wFlags & MMDRVI_TYPE)
    {
        case MMDRVI_WAVEOUT:
            msg_num_devs = WODM_GETNUMDEVS;
            szMessage    = szWodMapper;
            break;

        case MMDRVI_WAVEIN:
            msg_num_devs = WIDM_GETNUMDEVS;
            szMessage    = szWidMapper;
            break;

        default:
            goto error_exit;
    }

    if (hModule != NULL)
        *drvMessage = (DRIVERMSGPROC)GetProcAddress(hModule, szMessage);

    if (*drvMessage == NULL)
        goto error_exit;

    //
    // send the init message, if the driver returns a error, should we
    // unload them???
    //
    dw = (*(*drvMessage))(0,DRVM_INIT,0L,0L,0L);

    //
    // call driver to get num-devices it supports
    //
    dw = (*(*drvMessage))(0,msg_num_devs,0L,0L,0L);

    //
    //  the device returned a error, or has no devices
    //
    if (HIWORD(dw) != 0)
        goto error_exit;

    return TRUE;

error_exit:
    if (hDriver)
        CloseDriver(hDriver, 0, 0);

    return FALSE;
}


/*****************************************************************************
 *
 * @doc   INTERNAL
 *
 * @api   HDRVR | mmDrvOpen | This function load's an installable driver, but
 *                 first checks weather it exists in the [Drivers] section.
 *
 * @parm LPSTR | szAlias | driver alias to load
 *
 * @rdesc The return value is return value from OpenDriver or NULL if the alias
 *        was not found in the [Drivers] section.
 *
 ****************************************************************************/
HDRVR NEAR PASCAL
mmDrvOpen(
    LPSTR szAlias
    )
{
    char buf[3];

    if (GetPrivateProfileString( szDrivers,szAlias,szNull,buf,
                                 sizeof(buf),szSystemIni )) {

        return OpenDriver(szAlias, NULL, 0L);
    }
    else {
        return NULL;
    }
}

/*****************************Private*Routine******************************\
* ThunkInit
*
* Tries to setup the thunking system.  If this can not be performed
* it returns an error code of MMSYSERR_NODRIVER.  Otherwise it returns
* MMSYSERR_NOERROR to indicate sucess.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL _loadds
ThunkInit(
    void
    )
{
    mmwow32Lib = LoadLibraryEx32W( szMMWow32, NULL, 0L );
    if ( mmwow32Lib == 0L ) {
        return MMSYSERR_NODRIVER;
    }
    cb32 = (LPCB32)GetProcAddress32W(mmwow32Lib, szNotifyCB );

    /*
    ** Now we notify WOW32 that all is OK by passing the 16:16 bit pointer
    ** to the CALLBACK_DATA to it.
    */
    Notify_Callback_Data( vpCallbackData );

    /*
    ** Now initialize the rest of the thuynking system
    */
    wod32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szWodMessage );
    wid32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szWidMessage );
    mod32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szModMessage );
    mid32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szMidMessage );
    aux32Message = (LPSOUNDDEVMSGPROC)GetProcAddress32W( mmwow32Lib, szAuxMessage );
    mci32Message = (LPMCIMESSAGE)GetProcAddress32W( mmwow32Lib, "mci32Message" );
    tid32Message = (TIDMESSAGEPROC)GetProcAddress32W( mmwow32Lib, szTidMessage );
    joy32Message = (JOYMESSAGEPROC)GetProcAddress32W( mmwow32Lib, szJoyMessage );

    return MMSYSERR_NOERROR;
}

/*****************************Private*Routine******************************\
* ThunkTerm
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
static BOOL NEAR PASCAL
ThunkTerm(
    void
    )
{
    /*
    ** Free the interrupt stack frames and  uninstall the interrupt handler.
    */
    StackTerminate();
    DeInstallInterruptHandler();

    /*
    ** Next we notify WOW32 that we are going away by passing NULL to
    ** Notify_Callback_Data, then free the storage.
    */
    Notify_Callback_Data( NULL );
    HugePageUnlock( vpCallbackData, (DWORD)sizeof(CALLBACK_DATA) );
    GlobalUnlock( hGlobal );
    GlobalFree( hGlobal );

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\isr.asm ===
TITLE   ISR.ASM -- Windows DLL HARDWARE ISR
;****************************************************************************
;
;   PROGRAM: isr.asm
;
;   PURPOSE:
;       Installs an interrupt handler under Windows 3.x
;       This ISR (Interrupt service routine) will then service a requested
;       multi-media callback routine.
;
;   FUNCTIONS:
;       DoInterrupt:                    Performs interrupt processing
;       InstallInterruptHandler:        Installs the interrupt handler
;       DeInstallInterruptHandler:      Removes the interrupt handler
;
;****************************************************************************

        .286
memS    EQU 1                   ;Small memory model

.xlist
        include cmacros.inc
        include windows.inc
        include wowmmcb.inc
	include vint.inc
.list


;-------------------------------------------------------------------------;
;
;   debug support
;
;-------------------------------------------------------------------------;


externFP        OutputDebugString
externFP        DoInterrupt

;-------------------------------------------------------------------------;
;
;   callback support
;
;-------------------------------------------------------------------------;
externW         CodeFixWinFlags



;--------------------------Private-Macro----------------------------------;
; DOUT String - send a debug message to the debugger
;
; Entry:
;       String      String to send to the COM port, does not need a CR,LF
;
; Registers Destroyed:
;       none
;
; NOTE no code is generated unless the DEBUG symbol is defined
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;        Wrote it.
;-------------------------------------------------------------------------;

DOUT    macro   text
        local string_buffer
ifdef MYDEBUG
        push    cs
        push    offset string_buffer
        call    OutputDebugString
        jmp     @F
string_buffer label byte
        db      "MMSYSTEM: "
        db      "&text&",13,10,0
@@:
endif
        endm


;****************************************************************************
;
; Create a fixed code segment
;
;****************************************************************************

createSeg FIX,          CodeFix, word, public, CODE
createSeg INTDS,        DataFix, byte, public, DATA



DOS_SetVector           EQU 2500h
DOS_GetVector           EQU 3500h
ifdef   NEC_98
Pic1                    EQU 00h
Pic2                    EQU 08h
else    ; NEC_98
Pic1                    EQU 20h
Pic2                    EQU 0a0h
endif   ; NEC_98

sBegin  Data
staticD dOldVector,0
sEnd

sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,Data



;****************************************************************************
;   FUNCTION:  InstallInterruptHandler()
;
;   PURPOSE:
;       This routine saves the interrupt vector "MultiMediaVector" in
;       the global variable "dOldVector". Then, it installs a small
;       ISR at that vector which calls the routine "DoInt()" when
;       the interrupt occurs.
;
;
;****************************************************************************
cProc InstallInterruptHandler, <FAR,PUBLIC>, <si,di>
cBegin  InstallInterruptHandler

        push    bx                      ;Save previous vector
        push    es
        mov     ax,DOS_GetVector + MULTIMEDIA_INTERRUPT
        int     21h
        mov     WORD PTR dOldVector,bx
        mov     WORD PTR dOldVector+2,es
        pop     es
        pop     bx


        push    ds                      ;Install handler
        push    dx                      ;
        push    cs
        pop     ds
        mov     dx,OFFSET MULTI_MEDIA_ISR286
        test    cs:[CodeFixWinFlags],WF_WIN286
        jnz     @F
        mov     dx,OFFSET MULTI_MEDIA_ISR386
@@:
        mov     ax,DOS_SetVector + MULTIMEDIA_INTERRUPT
        int     21h
        pop     dx
        pop     ds

        jmp     set_exit

        ; ****  Entry point of ISR  ****
MULTI_MEDIA_ISR286:                     ;Our Multi-Media ISR (286)
        pusha
        push    ds
        push    es

        cCall   DoInterrupt             ;Do Interrupt Handling

        mov     al,20h
        out     Pic2,al                 ;EOI on Pic2
        out     Pic1,al                 ;EOI on Pic1
        pop     es
        pop     ds
        popa
	; FSTI
        ; iret                            ;exit MULTI_MEDIA_ISR
        FIRET

MULTI_MEDIA_ISR386:                     ;Our Multi-Media ISR (286)
.386
        pushad
        push    ds
        push    es
        push    fs
        push    gs

        cCall   DoInterrupt             ;Do Interrupt Handling

        mov     al,20h
        out     Pic2,al                 ;EOI on Pic2
        out     Pic1,al                 ;EOI on Pic1
        pop     gs
        pop     fs
        pop     es
        pop     ds
        popad
	; FSTI
        ; iret                            ;exit MULTI_MEDIA_ISR
        FIRET
.286

set_exit:                               ;exit InstallHandler

;       DOUT    <Interupt installed>
        mov     ax,1                    ;return TRUE

cEnd    InstallInteruptHandler


;****************************************************************************
;   FUNCTION:  DeInstallInterruptHandler()
;
;   PURPOSE:
;       Restores the interrupt vector "MultiMediaVector" with the address
;       at "dOldVector".
;
;****************************************************************************
cProc DeInstallInterruptHandler, <FAR,PUBLIC>, <si,di>
cBegin  DeInstallInterruptHandler

        push    ds                      ;
        push    dx                      ;
        mov     dx,WORD PTR dOldVector
        mov     ax,WORD PTR dOldVector+2
        cmp     dx,0                    ;were we installed?
        jnz     dih_go
        cmp     ax,0
        jz      dih_skip
dih_go:
        mov     ds,ax
        mov     ax,DOS_SetVector + MULTIMEDIA_INTERRUPT
        int     21h

dih_skip:
        pop     dx                      ;
        pop     ds                      ;

cEnd    DeInstallHandler

sEnd
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\libentry.asm ===
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   LIBENTRY.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains the entry point for MMsystem.dll
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        PMODE = 1

        include cmacros.inc                   

?PLM=1  ; pascal call convention
?WIN=0  ; Windows prolog/epilog code

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   extrns
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

        externNP LibMain
        externFP LocalInit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;   Code segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

ifndef SEGNAME
    SEGNAME equ <_TEXT>
endif

createSeg %SEGNAME, CodeSeg, word, public, CODE

;-----------------------------------------------------------------------;
;
; Stuff needed to avoid the C runtime coming in, and init the windows
; reserved parameter block at the base of DGROUP
;
sBegin  Data
assumes DS,Data

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

sEnd        Data

sBegin  CodeSeg
	assumes cs,CodeSeg
        assumes ds,Data
        assumes es,nothing

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;       Library entry point
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;--------------------------Private-Routine-----------------------------;
;
; LibEntry - called when DLL is loaded
;
; Entry:
;       CX    = size of heap
;       DI    = module handle
;       DS    = automatic data segment
;       ES:SI = address of command line (not used)
;
; Returns:
;       AX = TRUE if success
; Error Returns:
;       AX = FALSE if error (ie fail load process)
; Registers Preserved:
;	SI,DI,DS,BP
; Registers Destroyed:
;       AX,BX,CX,DX,ES,FLAGS
; Calls:
;	None
; History:
;
;       06-27-89 -by-  Todd Laney [ToddLa]
;	Created.
;-----------------------------------------------------------------------;

cProc   LibEntry,<FAR,PUBLIC,NODATA>,<>
cBegin
	;
        ; Push frame for LibMain (hModule,cbHeap,lpszCmdLine)
	;
	push	di
	push	cx
	push	es
	push	si

        ;
        ; Init the local heap (if one is declared in the .def file)
        ;
        jcxz no_heap

        xor     ax,ax
        cCall   LocalInit,<ax,ax,cx>

no_heap:
        cCall   LibMain
cEnd

	assumes ds,nothing
	assumes es,nothing

cProc   WEP, <FAR, PUBLIC, PASCAL>, <>
;	ParmW  fSystemExit
cBegin nogen
	mov	ax, 1
	retf	2
cEnd   nogen

        sEnd CodeSeg

        end LibEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mci.c ===
/******************************************************************************
* Module Name: mci.c
*
* Media Control Architecture Driver Interface
*
* Contents:  MCI external message API's mciSendString and mciSendCommand
* Author:  DLL (DavidLe)
* Created: 2/13/90
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/
#ifdef DEBUG
#ifndef DEBUG_RETAIL
#define DEBUG_RETAIL
#endif
#endif

#include <windows.h>
#include <string.h>

#define MMNOSEQ
#define MMNOJOY
#define MMNOWAVE
#define MMNOMIDI
#include "mmsystem.h"

#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"

#include "mmsysi.h"
#include "thunks.h"

#ifndef STATICFN
#define STATICFN
#endif


/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
LPMCIMESSAGE PASCAL mci32Message;
DWORD WINAPI mciSendCommand16(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    );


//
//  Define the init code for this file.
//
#pragma alloc_text( INIT, MCITerminate )

#ifdef DEBUG_RETAIL
int DebugmciSendCommand;
#endif

#ifdef DEBUG
void PASCAL NEAR mciCheckLocks(void);
#endif

STATICFN UINT PASCAL NEAR
mciConvertReturnValue(
    UINT wType,
    UINT wErr,
    UINT wDeviceID,
    LPDWORD dwParams,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    );

STATICFN DWORD NEAR PASCAL
mciSendStringInternal(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage
    );

STATICFN DWORD NEAR PASCAL
mciSendSystemString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    );

extern int FAR PASCAL
mciBreakKeyYieldProc(
    UINT wDeviceID,
    DWORD dwYieldData
    );


// From dosa.asm
extern int FAR PASCAL DosChangeDir(LPCSTR lpszPath);
extern WORD FAR PASCAL DosGetCurrentDrive(void);
extern BOOL FAR PASCAL DosSetCurrentDrive(WORD wDrive);
extern WORD FAR PASCAL DosGetCurrentDir(WORD wCurdrive, LPSTR lpszBuf);

#define MAX_PATHNAME 144

// This macro defines the list of messages for which mciSendString
// will not try to auto-open
#define MCI_CANNOT_AUTO_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SYSINFO \
        || wMessage == MCI_SOUND || wMessage == MCI_CLOSE \
        || wMessage == MCI_BREAK)

// This macro devices the list of message which do not require an open
// device.  It is a subset of MCI_CANNOT_AUTO_OPEN
#define MCI_DO_NOT_NEED_OPEN(wMessage) \
    (wMessage == MCI_OPEN || wMessage == MCI_SOUND || wMessage == MCI_SYSINFO)

// Strings used in mciAutoOpenDevice
          SZCODE szOpen[] = "open";
static    SZCODE szClose[] = "close";
static    SZCODE szNotify[] = "notify";
static    SZCODE szWait[] = "wait";
static    SZCODE szCmdFormat[] = "%ls %ls";
static    SZCODE szLongFormat[] = "%ld";
static    SZCODE szRectFormat[] = "%d %d %d %d";
extern char far szSystemDefault[];

// Special device name
static    SZCODE szNew[] = "new";

/******************************Public*Routine******************************\
* mciAppExit
*
* Notify the 32 bit code that a 16 bit app has died.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD
mciAppExit(
    HTASK hTask
    )
{
    return mciMessage( THUNK_APP_EXIT, (DWORD)hTask,
                       0L, 0L, 0L );
}



/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | MciNotify  | called by mmWndProc when it recives a
 *                          MM_MCINOTIFY message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL
MciNotify(
    WPARAM wParam,
    LPARAM lParam
    )
{
    //
    //  wParam is the notify status
    //  lParam is the MCI device id
    //
    if (MCI_VALID_DEVICE_ID(LOWORD(lParam)) &&
        !(MCI_lpDeviceList[LOWORD(lParam)]->dwMCIFlags & MCINODE_ISCLOSING)) {
        MCI_lpDeviceList[LOWORD(lParam)]->dwMCIFlags |= MCINODE_ISAUTOCLOSING;
        mciCloseDevice (LOWORD(lParam), 0L, NULL, TRUE);
    }
}



STATICFN void NEAR PASCAL
HandleNotify(
    UINT wErr,
    UINT wDeviceID,
    DWORD dwFlags,
    DWORD dwParam2
    )
{
    LPMCI_GENERIC_PARMS lpGeneric = (LPMCI_GENERIC_PARMS)dwParam2;
    HWND hwndCallback;
    if (wErr == 0 && dwFlags & MCI_NOTIFY && lpGeneric != NULL &&
        (hwndCallback = (HWND)(UINT)lpGeneric->dwCallback) != NULL)

        mciDriverNotify (hwndCallback, wDeviceID, MCI_NOTIFY_SUCCESSFUL);
}

#ifdef DEBUG_RETAIL
//
// Dump the string form of an MCI command
//
UINT PASCAL NEAR
mciDebugOut(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwFlags,
    DWORD dwParam2,
    LPMCI_DEVICE_NODE nodeWorking
    )
{
    LPSTR lpCommand, lpFirstParameter, lpPrevious, lszDebugOut;
    char strTemp[256];
    UINT wID, wOffset, wOffsetFirstParameter, wReturnType;
    DWORD dwValue;
    DWORD dwMask;
    UINT wTable;

// Find the command table for the given command message ID
    lpCommand = FindCommandItem( wDeviceID, NULL,
                                 (LPSTR)MAKELONG (wMessage, 0),
                                 NULL, &wTable);

    if (lpCommand == NULL)
    {
        if (wMessage != MCI_OPEN_DRIVER && wMessage != MCI_CLOSE_DRIVER)
            ROUT ("MMSYSTEM: mciDebugOut:  Command table not found");
        return 0;
    }

    lszDebugOut = mciAlloc(512);
    if (!lszDebugOut) {
        ROUT("MMSYSTEM: Not enough memory to display command");
	return 0;
    }

//  Dump the command name
    wsprintf(lszDebugOut, "MMSYSTEM: MCI command: \"%ls", lpCommand);

// Dump the device name
    if (wDeviceID == MCI_ALL_DEVICE_ID)
    {
        lstrcat(lszDebugOut, " all");
    }
    else if (nodeWorking != NULL)
    {
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
        {
            wsprintf(lszDebugOut + lstrlen(lszDebugOut), " Element ID:0x%lx", nodeWorking->dwElementID);
        } else if (nodeWorking->lpstrName != NULL)
        {
            wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", nodeWorking->lpstrName);
        }
    }

// Skip past command entry
    lpCommand += mciEatCommandEntry (lpCommand, NULL, NULL);

// Get the next entry
    lpFirstParameter = lpCommand;

// Skip past the DWORD return value
    wOffsetFirstParameter = 4;

    lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);

// If it is a return value, skip it
    if (wID == MCI_RETURN)
    {
        wReturnType = (UINT)dwValue;
        lpFirstParameter = lpCommand;
        wOffsetFirstParameter += mciGetParamSize (dwValue, wID);
        lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);
    }
    else {
        wReturnType = (UINT)0;
    }

// Dump device name parameter to OPEN
    if (wMessage == MCI_OPEN)
    {
        LPCSTR lpstrDeviceType =
            ((LPMCI_OPEN_PARMS)dwParam2)->lpstrDeviceType;
        LPCSTR lpstrElementName =
            ((LPMCI_OPEN_PARMS)dwParam2)->lpstrElementName;

// Tack on device type
        if (dwFlags & MCI_OPEN_TYPE_ID)
        {
            LPMCI_OPEN_PARMS lpOpen = (LPMCI_OPEN_PARMS)dwParam2;
            DWORD dwOld = (DWORD)lpOpen->lpstrDeviceType;
            if (mciExtractTypeFromID ((LPMCI_OPEN_PARMS)dwParam2) != 0)
                strTemp[0] = '\0';
            lstrcpy (strTemp, lpOpen->lpstrDeviceType);
            mciFree ((LPSTR)lpOpen->lpstrDeviceType);
            lpOpen->lpstrDeviceType = (LPSTR)dwOld;
        } else if (lpstrDeviceType != NULL)
            lstrcpy (strTemp, lpstrDeviceType);
        else
            strTemp[0] = '\0';

        if (dwFlags & MCI_OPEN_ELEMENT_ID)
        {
// Tack on element ID
            lstrcat (strTemp, " Element ID:");
            wsprintf (strTemp + lstrlen (strTemp), szLongFormat,
                      LOWORD ((DWORD)lpstrDeviceType));
        } else
        {
// Add separator if both type name and element name are present
            if (lpstrDeviceType != 0 && lpstrElementName != 0)
                lstrcat (strTemp, "!");
            if (lpstrElementName != 0 && dwFlags & MCI_OPEN_ELEMENT)
                lstrcat (strTemp, lpstrElementName);
        }
        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", (LPSTR)strTemp);
    }


// Walk through each flag
    for (dwMask = 1; dwMask;)
    {
// Is this bit set?
        if ((dwFlags & dwMask) != 0 && !
// The MCI_OPEN_TYPE and MCI_OPEN_ELEMENT flags are taken care of
// above
            (wMessage == MCI_OPEN && (dwMask == MCI_OPEN_TYPE
                                      || dwMask == MCI_OPEN_ELEMENT)))
        {
            lpPrevious = lpCommand = lpFirstParameter;
            wOffset = 0;
            lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);

// What parameter uses this bit?
            while (wID != MCI_END_COMMAND && dwValue != dwMask)
            {
                wOffset += mciGetParamSize (dwValue, wID);

                if (wID == MCI_CONSTANT)
                    while (wID != MCI_END_CONSTANT)
                        lpCommand += mciEatCommandEntry (lpCommand,
                                                         NULL, &wID);

                lpPrevious = lpCommand;
                lpCommand += mciEatCommandEntry (lpCommand, &dwValue, &wID);
            }

            if (wID != MCI_END_COMMAND)
            {
// Found the parameter which matches this flag bit
// Print the parameter name
                if (*lpPrevious)
                    wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", lpPrevious);

// Print any argument
                switch (wID)
                {
                    case MCI_STRING:
                        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", *(LPSTR FAR *)((LPSTR)dwParam2 + wOffset + wOffsetFirstParameter));
                        break;
                    case MCI_CONSTANT:
                    {
                        DWORD dwConst = *(LPDWORD)((LPSTR)dwParam2 + wOffset +
                                             wOffsetFirstParameter);
                        UINT wLen;
                        BOOL bFound;

                        for (bFound = FALSE; wID != MCI_END_CONSTANT;)
                        {
                            wLen = mciEatCommandEntry (lpCommand,
                                                       &dwValue, &wID);

                            if (dwValue == dwConst)
                            {
                                bFound = TRUE;
                                wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", lpCommand);
                            }

                            lpCommand += wLen;
                        }
                        if (bFound)
                            break;
// FALL THROUGH
                    }
                    case MCI_INTEGER:
                        wsprintf ((LPSTR)strTemp, szLongFormat,
                                  *(LPDWORD)((LPSTR)dwParam2 + wOffset +
                                             wOffsetFirstParameter));
                        wsprintf(lszDebugOut + lstrlen(lszDebugOut), " %ls", (LPSTR)strTemp);
                        break;
                }
            }
        }
// Go the the next flag
        dwMask <<= 1;
    }
    mciUnlockCommandTable (wTable);
    lstrcat(lszDebugOut, "\"");
    ROUTS(lszDebugOut);
    mciFree(lszDebugOut);
    return wReturnType;
}
#endif

STATICFN DWORD PASCAL NEAR
mciBreak(
    UINT wDeviceID,
    DWORD dwFlags,
    LPMCI_BREAK_PARMS lpBreakon
    )
{
    HWND hwnd;

    if (dwFlags & MCI_BREAK_KEY)
    {
        if (dwFlags & MCI_BREAK_OFF)
            return MCIERR_FLAGS_NOT_COMPATIBLE;

        if (dwFlags & MCI_BREAK_HWND)
            hwnd = lpBreakon->hwndBreak;
        else
            hwnd = 0;

        return  mciSetBreakKey (wDeviceID, lpBreakon->nVirtKey,
                                hwnd)
                    ? 0 : MMSYSERR_INVALPARAM;

    } else if (dwFlags & MCI_BREAK_OFF) {

        mciSetYieldProc(wDeviceID, NULL, 0);
        return 0;

    } else
        return MCIERR_MISSING_PARAMETER;
}

// Close the indicated device by sending a message inter-task
STATICFN DWORD PASCAL NEAR
mciAutoCloseDevice(
    LPCSTR lpstrDevice
    )
{
    LPSTR lpstrCommand;
    DWORD dwRet;

    if ((lpstrCommand =
            mciAlloc (sizeof (szClose) + 1 +
                    lstrlen (lpstrDevice))) == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintf(lpstrCommand, szCmdFormat, (LPCSTR)szClose, lpstrDevice);

    dwRet = mciSendSystemString (lpstrCommand, NULL, 0);

    mciFree (lpstrCommand);

    return dwRet;
}

//
// Process a single MCI command
//
// Called by mciSendCommandInternal
//
STATICFN DWORD PASCAL NEAR
mciSendSingleCommand(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2,
    LPMCI_DEVICE_NODE nodeWorking,
    BOOL bTaskSwitch,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo
    )
{
    DWORD dwRet;
#ifdef	DEBUG_RETAIL
    UINT wReturnType;
    DWORD dwTime;
#endif

#ifdef  DEBUG_RETAIL
    if (DebugmciSendCommand)
        wReturnType =
            mciDebugOut (wDeviceID, wMessage, dwParam1, dwParam2,
                         nodeWorking);
#endif

    switch (wMessage)
    {
        case MCI_OPEN:
            dwRet = mciOpenDevice (dwParam1,
                                   (LPMCI_OPEN_PARMS)dwParam2, lpOpenInfo);
            break;

        case MCI_CLOSE:
// If this device was auto opened send the command via a task switch
            if (bTaskSwitch)
            {
                if (dwParam1 & MCI_NOTIFY)
                    return MCIERR_NOTIFY_ON_AUTO_OPEN;

                dwRet = mciAutoCloseDevice (nodeWorking->lpstrName);
            } else
                dwRet =
                    mciCloseDevice (wDeviceID,
                                    dwParam1,
                                    (LPMCI_GENERIC_PARMS)dwParam2, TRUE);
            break;

        case MCI_SYSINFO:
            dwRet = mciSysinfo (wDeviceID, dwParam1,
                               (LPMCI_SYSINFO_PARMS)dwParam2);
            HandleNotify ((UINT)dwRet, 0, dwParam1, dwParam2);
            break;

        case MCI_BREAK:
            dwRet = mciBreak (wDeviceID, dwParam1,
                              (LPMCI_BREAK_PARMS)dwParam2);
            HandleNotify ((UINT)dwRet, wDeviceID, dwParam1, dwParam2);
            break;

        case MCI_SOUND:
        {
            dwRet =
                sndPlaySound (MCI_SOUND_NAME & dwParam1 ?
                              ((LPMCI_SOUND_PARMS)dwParam2)->lpstrSoundName : szSystemDefault,
                              dwParam1 & MCI_WAIT ?
                                    SND_SYNC : SND_ASYNC)
                    ? 0 : MCIERR_HARDWARE;
            HandleNotify ((UINT)dwRet, wDeviceID, dwParam1, dwParam2);
            break;
        }
        default:
#ifdef DEBUG_RETAIL
            if (DebugmciSendCommand)
            {
                dwTime = timeGetTime();
            }
#endif
// Initialize GetAsyncKeyState for break key
            if (dwParam1 & MCI_WAIT &&
                nodeWorking->fpYieldProc == mciBreakKeyYieldProc)
                GetAsyncKeyState (LOWORD(nodeWorking->dwYieldData));

            dwRet = (DWORD)SendDriverMessage(nodeWorking->hDrvDriver, wMessage,
                                   (LPARAM)dwParam1, (LPARAM)dwParam2);
#ifdef DEBUG_RETAIL
            if (DebugmciSendCommand)
            {
		dwTime = timeGetTime() - dwTime;
            }
#endif
            break;
    } // switch

#ifdef DEBUG_RETAIL
    if (DebugmciSendCommand)
    {
        if (dwRet & MCI_INTEGER_RETURNED) {
            wReturnType = MCI_INTEGER;
        }


        switch (wReturnType)
        {
            case MCI_INTEGER:
            {
                char strTemp[50];

                if (wMessage == MCI_OPEN) {

                    mciConvertReturnValue( wReturnType, HIWORD(dwRet),
                                           wDeviceID, (LPDWORD)dwParam2,
                                           strTemp, sizeof(strTemp));
                }
                else {
                    mciConvertReturnValue( wReturnType, HIWORD(dwRet),
                                           wDeviceID, (LPDWORD)dwParam2,
                                           strTemp, sizeof(strTemp));
                }

                RPRINTF2( "MMSYSTEM: time: %lums returns: \"%ls\"",
                          dwTime, (LPSTR)strTemp);
                break;
            }
            case MCI_STRING:
                RPRINTF2( "MMSYSTEM: time: %lums returns: \"%ls\"",
                          dwTime, (LPSTR)*(((LPDWORD)dwParam2) + 1));
                break;
        }
    }
#endif

    return dwRet;
}

// Internal version of mciSendCommand.  Differs ONLY in that the return
// value is a DWORD where the high word has meaning only for mciSendString

STATICFN DWORD NEAR PASCAL
mciSendCommandInternal(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo
    )
{
    DWORD dwRetVal;
    LPMCI_DEVICE_NODE nodeWorking = NULL;
    BOOL bWalkAll;
    BOOL bTaskSwitch;
    DWORD dwAllError = 0;
    HTASK hCurrentTask;

    hCurrentTask = GetCurrentTask();

// If the device is "all" and the message is *not*
// "sysinfo" then we must walk all devices
    if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO && wMessage != MCI_SOUND)
    {
        if (wMessage == MCI_OPEN)
        {
            dwRetVal = MCIERR_CANNOT_USE_ALL;
            goto exitfn;
        }

        bWalkAll = TRUE;

// Start at device #1
        wDeviceID = 1;
    } else
        bWalkAll = FALSE;

// Walk through all devices if bWalkAll or just one device if !bWalkAll
    do
    {
// Initialize
        dwRetVal = 0;
        bTaskSwitch = FALSE;

// Validate the device ID if single device
        if (!bWalkAll)
        {
            if (!MCI_DO_NOT_NEED_OPEN(wMessage))
            {
                if (!MCI_VALID_DEVICE_ID(wDeviceID))
                {
                    dwRetVal = MCIERR_INVALID_DEVICE_ID;
                    goto exitfn;
                }
                nodeWorking = MCI_lpDeviceList[wDeviceID];
            }
        } else if (wMessage != MCI_SYSINFO)
            nodeWorking = MCI_lpDeviceList[wDeviceID];

// Skip if walking the device list and the
// device is not part of the current task

        if (bWalkAll)
        {
            if (nodeWorking == NULL ||
                nodeWorking->hOpeningTask != hCurrentTask)
                    goto no_send;
        }
// If the device is in the process of closing and the message
// is not MCI_CLOSE_DRIVER then return an error
        if (nodeWorking != NULL &&
            (nodeWorking->dwMCIFlags & MCINODE_ISCLOSING) &&
            wMessage != MCI_CLOSE_DRIVER)
        {
            dwRetVal = MCIERR_DEVICE_LOCKED;
            goto exitfn;
        }

// If this message is being sent from the wrong task (the device was auto-
// opened) fail all but the MCI_CLOSE message which gets sent inter-task
        if (nodeWorking != NULL &&
            nodeWorking->hCreatorTask != hCurrentTask)
            if (wMessage != MCI_CLOSE)
                return MCIERR_ILLEGAL_FOR_AUTO_OPEN;
            else
            {
// Don't even allow close from mciSendCommand if auto-open device has a
// pending close
                if (nodeWorking->dwMCIFlags & MCINODE_ISAUTOCLOSING)
                {
// But at least give the close a chance to take place
//!!                    Yield();
                    return MCIERR_DEVICE_LOCKED;
                } else
                    bTaskSwitch = TRUE;
            }

        dwRetVal = mciSendSingleCommand (wDeviceID, wMessage, dwParam1,
                                         dwParam2, nodeWorking, bTaskSwitch,
                                         lpOpenInfo);
no_send:

// If we are processing multiple devices
        if (bWalkAll)
        {
// If there was an error for this device
            if (dwRetVal != 0)
// If this is not the first error
                if (dwAllError != 0)
                    dwAllError = MCIERR_MULTIPLE;
// Just one error so far
                else
                    dwAllError = dwRetVal;
        }
    } while (bWalkAll && ++wDeviceID < MCI_wNextDeviceID);

exitfn:
// Return the accumulated error if multiple devices or just the single error
    return bWalkAll ? dwAllError : dwRetVal;
}


/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendCommand | This function sends a command message to
 * the specified MCI device.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * receive the command. This parameter is
 *  not used with the <m MCI_OPEN> command.
 *
 * @parm UINT | wMessage | Specifies the command message.
 *
 * @parm DWORD | dwParam1 | Specifies flags for the command.
 *
 * @parm DWORD | dwParam2 | Specifies a pointer to a parameter block
 *  for the command.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD is the error return value. If the error is
 *  device-specific, the high-order word contains the driver ID; otherwise
 *  the high-order word is zero.
 *
 *  To get a textual description of <f mciSendCommand> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  Error values that are returned when a device is being opened
 *  are listed with the MCI_OPEN message. In addition to the
 *  MCI_OPEN error returns, this function can
 *  return the following values:
 *
 *  @flag MCIERR_BAD_TIME_FORMAT | Illegal value for time format.
 *
 *  @flag MCIERR_CANNOT_USE_ALL | The device name "all" is not allowed
 *  for this command.
 *
 *  @flag MCIERR_CREATEWINDOW | Could not create or use window.
 *
 *  @flag MCIERR_DEVICE_LOCKED | The device is locked until it is
 *  closed automatically.
 *
 *  @flag MCIERR_DEVICE_NOT_READY | Device not ready.
 *
 *  @flag MCIERR_DEVICE_TYPE_REQUIRED | The device name must be a valid
 *  device type.
 *
 *  @flag MCIERR_DRIVER | Unspecified device error.
 *
 *  @flag MCIERR_DRIVER_INTERNAL | Internal driver error.
 *
 *  @flag MCIERR_FILE_NOT_FOUND | Requested file not found.
 *
 *  @flag MCIERR_FILE_NOT_SAVED | The file was not saved.
 *
 *  @flag MCIERR_FILE_READ | A read from the file failed.
 *
 *  @flag MCIERR_FILE_WRITE | A write to the file failed.
 *
 *  @flag MCIERR_FLAGS_NOT_COMPATIBLE | Incompatible parameters
 *  were specified.
 *
 *  @flag MCIERR_HARDWARE | Hardware error on media device.
 *
 *  @flag MCIERR_INTERNAL | mmsystem startup error.
 *
 *  @flag MCIERR_INVALID_DEVICE_ID | Invalid device ID.
 *
 *  @flag MCIERR_INVALID_DEVICE_NAME | The device is not open
 *  or is not known.
 *
 *  @flag MCIERR_INVALID_FILE | Invalid file format.
 *
 *  @flag MCIERR_MULTIPLE | Errors occurred in more than one device.
 *
 *  @flag MCIERR_NO_WINDOW | There is no display window.
 *
 *  @flag MCIERR_NULL_PARAMETER_BLOCK | Parameter block pointer was NULL.
 *
 *  @flag MCIERR_OUT_OF_MEMORY | Not enough memory for requested operation.
 *
 *  @flag MCIERR_OUTOFRANGE | Parameter value out of range.
 *
 *  @flag MCIERR_UNNAMED_RESOURCE | Attempt to save unnamed file.
 *
 *  @flag MCIERR_UNRECOGNIZED_COMMAND | Unknown command.
 *
 *  @flag MCIERR_UNSUPPORTED_FUNCTION | Action not available for this
 *  device.
 *
 *  The following additional return values are defined for MCI sequencers:
 *
 *  @flag MCIERR_SEQ_DIV_INCOMPATIBLE | Set Song Pointer incompatible
 *  with SMPTE files.
 *
 *  @flag MCIERR_SEQ_PORT_INUSE | Specified port is in use.
 *
 *  @flag MCIERR_SEQ_PORT_MAPNODEVICE | Current map uses non-existent
 *  device.
 *
 *  @flag MCIERR_SEQ_PORT_MISCERROR | Miscellaneous error with
 *  specified port.
 *
 *  @flag MCIERR_SEQ_PORT_NONEXISTENT | Specified port does not exist.
 *
 *  @flag MCIERR_SEQ_PORTUNSPECIFIED | No current MIDI port.
 *
 *  @flag MCIERR_SEQ_NOMIDIPRESENT | No MIDI ports present.
 *
 *  @flag MCIERR_SEQ_TIMER | Timer error.
 *
 *  The following additional return values are defined for MCI waveform
 *  audio devices:
 *
 *  @flag MCIERR_WAVE_INPUTSINUSE | No compatible waveform recording
 *   device is free.
 *
 *  @flag MCIERR_WAVE_INPUTSUNSUITABLE | No compatible waveform
 *  recording devices.
 *
 *  @flag MCIERR_WAVE_INPUTUNSPECIFIED | Any compatible waveform
 *  recording device may be used.
 *
 *  @flag MCIERR_WAVE_OUTPUTSINUSE | No compatible waveform playback
 *  device is free.
 *
 *  @flag MCIERR_WAVE_OUTPUTSUNSUITABLE | No compatible waveform
 *  playback devices.
 *
 *  @flag MCIERR_WAVE_OUTPUTUNSPECIFIED | Any compatible waveform
 *  playback device may be used.
 *
 *  @flag MCIERR_WAVE_SETINPUTINUSE | Set waveform recording device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETINPUTUNSUITABLE | Set waveform recording
 *  device is incompatible with set format.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTINUSE | Set waveform playback device
 *  is in use.
 *
 *  @flag MCIERR_WAVE_SETOUTPUTUNSUITABLE | Set waveform playback
 *  device is incompatible with set format.
 *
 * @comm Use the <m MCI_OPEN> command to obtain the device ID
 *  specified by <p wDeviceID>.
 *
 * @xref mciGetErrorString mciSendString
 */

 /*
 * @doc internal
 *
 * @api DWORD | mciDriverEntry | Actually a callback.  The entry point for MCI drivers.
 *
 * @parm UINT | wMessage | Identifies the requested action to be performed.
 *
 * @parm DWORD | dwParam1 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @parm DWORD | dwParam2 | Specifies data for this message.  Defined separately
 * for each message.
 *
 * @rdesc The return value is defined separately for each message.
 */
DWORD WINAPI
mciSendCommand(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    // Initialize the 16-bit device list if needed.
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

    // MCI_OPEN_DRIVER & MCI_CLOSE_DRIVER only supported on 16-bit drivers
    if ( (wMessage == MCI_OPEN_DRIVER) || (wMessage == MCI_CLOSE_DRIVER) ) {
        return mciSendCommand16( wDeviceID, wMessage, dwParam1, dwParam2 );
    }

    /*
    ** If we are opening the device try the 32 bit side first.  If this
    ** worked (hopefully this is the usual case) we return the given
    ** device ID.  Otherwise, we try for a 16 bit device.
    */
    if ( wMessage == MCI_OPEN ) {

        DWORD dwErr;

        DPRINTF(("mciSendCommand: Got an MCI_OPEN command... "
                 "trying 32 bits\r\n" ));

        dwErr = mciMessage( THUNK_MCI_SENDCOMMAND, (DWORD)wDeviceID,
                            (DWORD)wMessage, dwParam1, dwParam2 );

        if ( dwErr == MMSYSERR_NOERROR ) {

            LPMCI_OPEN_PARMS lpOpenParms = (LPMCI_OPEN_PARMS)dwParam2;

            DPRINTF(("mciSendCommand: We have a 32 bit driver,"
                     " devID = 0x%X\r\n", lpOpenParms->wDeviceID ));

            return dwErr;

        }
        else {

            /*
            ** We could open the device on the 32 bit side so let
            ** the 16 bit code have a go (ie. just fall thru to the code below).
            */
            DPRINTF(("mciSendCommand: Could not find a 32 bit driver, "
                     "trying for a 16 bit driver\r\n" ));

            dwErr = mciSendCommand16( wDeviceID, wMessage, dwParam1, dwParam2 );

            if ( dwErr == MMSYSERR_NOERROR ) {

                LPMCI_OPEN_PARMS lpOpenParms = (LPMCI_OPEN_PARMS)dwParam2;

                DPRINTF(("mciSendCommand: We have a 16 bit driver,"
                         " devID = 0x%X\r\n", lpOpenParms->wDeviceID ));
            }

            return dwErr;
        }
    }
    else {

        DWORD dwErr16;
        DWORD dwErr32;

        /*
        ** If we have been given the MCI_ALL_DEVICE_ID then we have to
        ** send the command to both the 32 and 16 bit side.
        **
        ** Special care needs to be taken with the MCI_ALL_DEVICE_ID.
        ** The message must be passed on to both 32 and 16 bit devices.
        */

        if (CouldBe16bitDrv(wDeviceID)) {
            dwErr16 = mciSendCommand16( wDeviceID, wMessage,
                                        dwParam1, dwParam2 );

            if ( wDeviceID != MCI_ALL_DEVICE_ID ) {
                return dwErr16;
            }
        }

        dwErr32 = mciMessage( THUNK_MCI_SENDCOMMAND, (DWORD)wDeviceID,
                              (DWORD)wMessage, dwParam1, dwParam2 );

        /*
        ** If we have the MCI_ALL_DEVICE_ID device ID we only return
        ** an error if both the 16 and 32 bit calls failed.  In which
        ** case we return the 32 bit error code.
        */
        if ( wDeviceID == MCI_ALL_DEVICE_ID ) {

            if ( (dwErr16 != MMSYSERR_NOERROR)
              && (dwErr32 != MMSYSERR_NOERROR) ) {

                return dwErr32;
            }
            else {
                return MMSYSERR_NOERROR;
            }
        }

        return dwErr32;
    }
}


/*****************************Private*Routine******************************\
* mciSendCommand16
*
* Here is where we execute the real 16 bit mciSendCommand.  Hoefully this
* will not get called to often.
*
* History:
* dd-mm-94 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
mciSendCommand16(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    DWORD dwErr;
    MCI_INTERNAL_OPEN_INFO OpenInfo;


    //
    // Send the command.  This shell is responsible for adding the device ID
    // to the error code if necessary
    //
    OpenInfo.hCallingTask = GetCurrentTask();
    OpenInfo.lpstrParams = NULL;
    OpenInfo.lpstrPointerList = NULL;
    OpenInfo.wParsingError = 0;
    dwErr = mciSendCommandInternal (wDeviceID, wMessage,
                                    dwParam1, dwParam2, &OpenInfo);
    //
    // If the return value contains a resource ID then clear
    // it from clear the high word
    //
    if (dwErr & MCI_RESOURCE_RETURNED)
        ((LPDWORD)dwParam2)[1] &= 0xFFFF;
    dwErr &= 0xFFFF;

    //
    // If the error message is in a driver, store the driver ID in the high
    // word of the error code
    //
    if ((UINT)dwErr >= MCIERR_CUSTOM_DRIVER_BASE)
        dwErr |= ((DWORD)wDeviceID << 16);

#ifdef DEBUG
    // Dump the error text if any to the debug terminal
    if (dwErr != 0)
    {
        char strTemp[MAXERRORLENGTH];

        if (!mciGetErrorString (dwErr, strTemp, sizeof(strTemp)))
            LoadString(ghInst, STR_MCISCERRTXT, strTemp, sizeof(strTemp));
        else
            DPRINTF(("mciSendCommand: %ls\r\n",(LPSTR)strTemp));
    }
#endif
    return dwErr;
}



// Grab colonized digit
// Return is number of bytes written to output (NOT including NULL)
// or 0 if out of room in output buffer (but is terminated anyway)
// If there is room then at least two digits are written, padded with '0'
// if necessary.  The function assumes that the buffer size is non-zero length,
// as this is checked in the calling function.
STATICFN UINT PASCAL NEAR
mciColonizeDigit(
    LPSTR lpstrOutput,
    unsigned char cDigit,
    UINT wSize
    )
{
    UINT wCount;

    wCount = 2;

// If there is room for at least two digits
    if (wSize >= 3)
    {
        if (cDigit >= 100)
        {
            wCount = 3;
            if (wSize < 4)
                goto terminate;
            *lpstrOutput++ = (char)((cDigit / 100) % 10 + '0');
            cDigit = (char)(cDigit % 100);
        }
        *lpstrOutput++ = (char)(cDigit / 10 + '0');
        *lpstrOutput++ = (char)(cDigit % 10 + '0');
    }

terminate:
    *lpstrOutput++ = '\0';

// If we ran out of room then return an error
    return (wCount >= wSize) ? 0 : wCount;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciColonize | Convert a colonized dword into a string
 * representation
 *
 * @parm LPSTR | lpstrOutput | Output buffer
 *
 * @parm UINT | wLength | Size of output buffer
 *
 * @parm DWORD | dwData | Value to convert
 *
 * @parm UINT | wType | Either MCI_COLONIZED3_RETURN or
 * MCI_COLONIZED4_RETURN is set (HIWORD portion only!)
 *
 * @comm Example:  For C4, 0x01020304 is converted to "04:03:02:01"
 *                 For C3, 0x01020304 is converted to "04:03:02"
 *
 * @rdesc FALSE if there is not enough room in the output buffer
 *
 */
STATICFN BOOL PASCAL NEAR mciColonize(
    LPSTR lpstrOutput,
    UINT wLength,
    DWORD dwData,
    UINT wType
    )
{
    LPSTR lpstrInput = (LPSTR)&dwData;
    UINT wSize;
    int i;

    for (i = 1; i <= (wType & HIWORD(MCI_COLONIZED3_RETURN) ? 3 : 4); ++i)
    {
        wSize = mciColonizeDigit (lpstrOutput,
                                  *lpstrInput++,
                                  wLength);
        if (wSize == 0)
            return FALSE;
        lpstrOutput += wSize;
        wLength -= wSize;
        if (i < 3 || i < 4 && wType & HIWORD(MCI_COLONIZED4_RETURN))
        {
            --wLength;
            if (wLength == 0)
                return FALSE;
            else
                *lpstrOutput++ = ':';
        }
    }
    return TRUE;
}

//
// Convert the return value to a return string
//
STATICFN UINT PASCAL NEAR
mciConvertReturnValue(
    UINT wType,
    UINT wErrCode,
    UINT wDeviceID,
    LPDWORD   dwParams,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    UINT    wExternalTable;

    if (lpstrReturnString == NULL || wReturnLength == 0)
        return 0;

    switch (wType)
    {
        case MCI_INTEGER:
// Convert integer or resource return value to string
            if (wErrCode & HIWORD(MCI_RESOURCE_RETURNED))
            {
                int nResId = HIWORD(dwParams[1]);
                LPMCI_DEVICE_NODE nodeWorking;
                HINSTANCE hInstance;

                if ((nodeWorking = MCI_lpDeviceList[wDeviceID])
                    == NULL)
                {
// Return blank string on memory error
                    DOUT ("mciConvertReturnValue Warning:NULL device node\r\n");
                    break;
                }

// Return value is a resource
                if (wErrCode & HIWORD(MCI_RESOURCE_DRIVER))
                {
// Return string ID belongs to driver
                    hInstance = nodeWorking->hDriver;

                    wExternalTable = nodeWorking->wCustomCommandTable;
                } else
                {
                    wExternalTable = nodeWorking->wCommandTable;
                    hInstance = ghInst;
                }

// Try to get string from custom or device specific external table
                if (wExternalTable == -1 ||
                    command_tables[wExternalTable].hModule == NULL ||
                    LoadString (command_tables[wExternalTable].hModule,
                                nResId, lpstrReturnString, wReturnLength)
                    == 0)
                {
// Try to get string from CORE.MCI if it's not from the driver
                    if (hInstance != ghInst ||
                        command_tables[0].hModule == NULL ||
                        LoadString (command_tables[0].hModule,
                                    nResId, lpstrReturnString, wReturnLength)
                        == 0)
// Get string from custom module or MMSYSTEM.DLL
                        LoadString (hInstance, nResId, lpstrReturnString,
                                    wReturnLength);
                }

            } else if (wErrCode & HIWORD(MCI_COLONIZED3_RETURN) ||
                        wErrCode & HIWORD(MCI_COLONIZED4_RETURN))
            {
                if (!mciColonize (lpstrReturnString,
                                wReturnLength, dwParams[1], wErrCode))
                    return MCIERR_PARAM_OVERFLOW;
            } else
// Convert integer return value to string
            {
                DWORD dwTemp;

// Need room for a sign, up to ten digits and a NULL
                if (wReturnLength < 12)
                    return MCIERR_PARAM_OVERFLOW;

                if (wType == MCI_STRING ||
                    wErrCode == HIWORD(MCI_INTEGER_RETURNED))
                    dwTemp = *(LPDWORD)dwParams[1];
                else
                    dwTemp = dwParams[1];
                wsprintf(lpstrReturnString, szLongFormat, dwTemp);
            }
            break;
        case MCI_RECT:
// Need from for 4 times (a sign plus 5 digits) plus three spaces and a NULL
            if (wReturnLength < 4 * 6 + 4)
                return MCIERR_PARAM_OVERFLOW;

            wsprintf (lpstrReturnString, szRectFormat,
                        ((LPWORD)dwParams)[2], ((LPWORD)dwParams)[3],
                        ((LPWORD)dwParams)[4], ((LPWORD)dwParams)[5]);
            break;
        default:
// Only support INTEGERs & MIXED
            DOUT ("mciConvertReturnValue Warning:  Unknown return type\r\n");
            return MCIERR_PARSER_INTERNAL;
    }
    return 0;
}


//
// Pull off the command name and device name from the command string,
// leaving *lplpstrCommand pointing past the device name
//
// Returns 0 or an error code on failure.  If successful, the caller must
// free the pstrCommandName and pstrDeviceName
//
// If bCompound then check for a '!' separator in the extracted device name
// and return only the element part.  This is done so that inter-task
// commands to auto-opened devices will include the correct device name
//
STATICFN DWORD PASCAL NEAR
mciSeparateCommandParts(
    LPSTR FAR *lplpstrCommand,
    BOOL bCompound,
    LPSTR FAR *lplpstrCommandName,
    LPSTR FAR *lplpstrDeviceName
    )
{
    LPSTR lpstrCommand;
    UINT wErr;

// Localize the input
    lpstrCommand = *lplpstrCommand;

// Remove leading spaces

    while (*lpstrCommand == ' ')
        ++lpstrCommand;

    if (*lpstrCommand == '\0')
        return MCIERR_MISSING_COMMAND_STRING;

// Pull the command name off of the command string
   if ((wErr = mciEatToken (&lpstrCommand, ' ', lplpstrCommandName, FALSE))
       != 0)
       return wErr;

// Skip past spaces
    while (*lpstrCommand == ' ')
        ++lpstrCommand;

// If we're looking for compound elements then yank off any leading
// device type if it is not the open command
    if (bCompound && lstrcmpi (szOpen, *lplpstrCommandName) != 0)
    {
        LPSTR lpstrTemp = lpstrCommand;
        while (*lpstrTemp != '\0')
        {
            if (*lpstrTemp == '!')
            {
// A ! was found so skip past it
                lpstrCommand = lpstrTemp + 1;
                break;
            } else
                ++lpstrTemp;
        }
    }

// Pull the device name off of the command string
    if ((wErr = mciEatToken (&lpstrCommand, ' ', lplpstrDeviceName, FALSE))
        != 0)
    {
        mciFree (*lplpstrCommandName);
        return wErr;

    }

// Fix up the results
    *lplpstrCommand = lpstrCommand;

    return 0;
}

STATICFN DWORD NEAR PASCAL
mciSendSystemString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    DWORD    dwRet;
    LPMCI_SYSTEM_MESSAGE    lpMessage;

    if (!hwndNotify)
        return MCIERR_INTERNAL;
    if (lpMessage = mciAlloc (sizeof (MCI_SYSTEM_MESSAGE))) {
        LPSTR    lpstrPath;

        if (lpstrPath = mciAlloc(MAX_PATHNAME)) {
            if (!(DosGetCurrentDir(0, lpstrPath))) {
                lpMessage->lpstrCommand = (LPSTR)lpstrCommand;
                lpMessage->lpstrReturnString = lpstrReturnString;
                lpMessage->wReturnLength = wReturnLength;
                lpMessage->hCallingTask = GetCurrentTask();
                lpMessage->lpstrNewDirectory = lpstrPath;
                lpMessage->nNewDrive = DosGetCurrentDrive();
                dwRet = (DWORD)SendMessage(hwndNotify, MM_MCISYSTEM_STRING, (WPARAM)0, (LPARAM)lpMessage);
            } else {
                DOUT("mciSendSystemString: cannot get current directory\r\n");
                dwRet = MCIERR_GET_CD;
            }
            mciFree(lpstrPath);
        } else {
            DOUT("mciSendSystemString: cannot allocate new path\r\n");
            dwRet = MCIERR_OUT_OF_MEMORY;
        }
        mciFree(lpMessage);
    } else {
        DOUT("mciSendSystemString: cannot allocate message block\r\n");
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

DWORD FAR PASCAL
mciRelaySystemString(
    LPMCI_SYSTEM_MESSAGE lpMessage
    )
{
    DWORD    dwRet;
    LPSTR    lpstrOldPath;

    if (lpstrOldPath = mciAlloc(MAX_PATHNAME)) {
        if (!(DosGetCurrentDir(0, lpstrOldPath))) {
            int    nOldDrive;

            nOldDrive = DosGetCurrentDrive();
            if (DosSetCurrentDrive(lpMessage->nNewDrive)) {
                if (DosChangeDir(lpMessage->lpstrNewDirectory) == 1) {
                    dwRet = mciSendStringInternal (NULL, NULL, 0, 0, lpMessage);
                    if (!DosSetCurrentDrive(nOldDrive))
                        DOUT("mciRelaySystemString: WARNING, cannot restore drive\r\n");
                    if (DosChangeDir(lpstrOldPath) != 1)
                        DOUT("mciRelaySystemString: WARNING, cannot restore directory\r\n");
                } else {
                    DosSetCurrentDrive(nOldDrive);
                    DOUT("mciRelaySystemString: cannot change to new directory\r\n");
                    dwRet = MCIERR_SET_CD;
                }
            } else {
                DOUT("mciRelaySystemString: cannot change to new drive\r\n");
                dwRet = MCIERR_SET_DRIVE;
            }
        } else {
            DOUT("mciRelaySystemString: cannot get old directory\r\n");
            dwRet = MCIERR_GET_CD;
        }
        mciFree(lpstrOldPath);
    } else {
        DOUT("mciRelaySystemString: cannot allocate old path\r\n");
        dwRet = MCIERR_OUT_OF_MEMORY;
    }
    return dwRet;
}

// Returns TRUE if "notify" is contained in string with leading blank
// and trailing blank or '\0'
STATICFN BOOL PASCAL NEAR
mciFindNotify(
    LPSTR lpString
    )
{
    while (*lpString != '\0')
    {
// "notify" must be preceded by a blank
        if (*lpString++ == ' ')
        {
            LPSTR lpTemp;

            lpTemp = szNotify;
            while (*lpTemp != '\0' && *lpString != '\0' &&
                   *lpTemp == MCI_TOLOWER(*lpString))
            {
                ++lpTemp;
                ++lpString;
            }
// "notify" must be followed by a blank or a null
            if (*lpTemp == '\0' &&
                (*lpString == '\0' || *lpString == ' '))
                return TRUE;
        }
    }
    return FALSE;
}

/*
 * @doc INTERNAL MCI
 *
 * @func UINT | mciAutoOpenDevice | Try to auto-open the given device and
 * then send the given command with notification sent to the system task
 * window proc which sends a close command to the device on receipt
 *
 * @parm LPSTR | lpstrDeviceName | The device name to open
 *
 * @parm LPSTR | lpstrCommand | The full command to send including the
 * device name which must be the same as lpstrDeviceName
 *
 * @parm LPSTR | lpstrReturnString | The caller's return string buffer
 *
 * @parm UINT | wReturnLength | Size of the caller's return string buffer
 *
 * @rdesc The errorcode to return to the user
 */
STATICFN UINT PASCAL NEAR
mciAutoOpenDevice(
    LPSTR lpstrDeviceName,
    LPSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength
    )
{
    LPSTR lpstrTempCommand, lpstrTempReturn = NULL;
    UINT wErr;

// "notify" not allowed.  This will be found by the parser but the wrong
// error message will be returned.
    if (mciFindNotify (lpstrCommand))
        return MCIERR_NOTIFY_ON_AUTO_OPEN;

// Build the command string "open <device name>"

// Must be GMEM_SHARE for system task
// device name + blank + "open"
    if ((lpstrTempCommand = mciAlloc (lstrlen (lpstrDeviceName) + 1 +
                                        sizeof (szOpen)))
        == NULL)
        return MCIERR_OUT_OF_MEMORY;

    wsprintf(lpstrTempCommand, szCmdFormat, (LPSTR)szOpen, lpstrDeviceName);
// Get the open string into the system task via a SendMessage() to mmWndProc
    wErr = (UINT)mciSendSystemString (lpstrTempCommand, NULL, NULL);

    mciFree (lpstrTempCommand);

    if (wErr != 0)
        return wErr;

    lpstrTempCommand = NULL;
// Must make a GMEM_SHARE copy of the return string for system task
    if (lpstrReturnString == NULL ||
        (lpstrTempReturn = mciAlloc (wReturnLength + 1)) != NULL)
    {
// Build a GMEM_SHARE command string "<user command> <notify>
// command + blank + "notify"
        if ((lpstrTempCommand = mciAlloc (lstrlen (lpstrCommand) + 1 + sizeof(szNotify))) == NULL)
            mciFree (lpstrTempReturn);
    }

    if (lpstrTempCommand == NULL)
    {
// Close the device
        mciDriverNotify (hwndNotify, mciGetDeviceID (lpstrDeviceName), 0);
        return MCIERR_OUT_OF_MEMORY;
    }

    wsprintf(lpstrTempCommand, szCmdFormat, lpstrCommand, (LPSTR)szNotify);

// Get the user command string into the system task via a SendMessage()
// to mmWndProc
// The notification handle is also mmWndProc
    wErr = (UINT)mciSendSystemString (lpstrTempCommand, lpstrTempReturn,
                                    wReturnLength);

// Copy the return string into the user's buffer
    if (lpstrReturnString != NULL)
    {
        lstrcpy (lpstrReturnString, lpstrTempReturn);
        mciFree (lpstrTempReturn);
    }

    mciFree (lpstrTempCommand);

// If there was an error we must close the device
    if (wErr != 0)
        mciAutoCloseDevice (lpstrDeviceName);

    return wErr;
}

//
// Identical to mciSendString() but the lpMessage parameter is tacked on
//
// lpMessage comes from inter-task mciSendString and includes an
// hCallingTask item which is sent down the the OPEN command
//
STATICFN DWORD NEAR PASCAL
mciSendStringInternal(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback,
    LPMCI_SYSTEM_MESSAGE lpMessage
    )
{
    UINT    wID, wConvertReturnValue, wErr, wMessage;
    UINT    wLen;
    UINT    wDeviceID;
    LPDWORD lpdwParams = NULL;
    DWORD   dwReturn, dwFlags = 0;
    LPSTR   lpCommandItem;
    DWORD   dwErr, dwRetType;
    UINT    wTable = (UINT)-1;
    LPSTR    lpstrDeviceName = NULL, lpstrCommandName = NULL;
    LPSTR   FAR *lpstrPointerList = NULL;
    LPSTR   lpstrCommandStart;
    HTASK hCallingTask;
    UINT    wParsingError;
    BOOL    bNewDevice;
    LPSTR   lpstrInputCopy;

    // Did this call come in from another task
    if (lpMessage != NULL)
    {
        // Yes so restore info
        lpstrCommand = lpMessage->lpstrCommand;
        lpstrReturnString = lpMessage->lpstrReturnString;
        wReturnLength = lpMessage->wReturnLength;
        hwndCallback = hwndNotify;
        hCallingTask = lpMessage->hCallingTask;
        lpstrInputCopy = NULL;

    } else
    {
        BOOL bInQuotes = FALSE;

        // No so set hCallingTask to current
        hCallingTask = GetCurrentTask();

        if (lpstrCommand == NULL)
            return MCIERR_MISSING_COMMAND_STRING;

        // Make a copy of the input string and convert tabs to
        // spaces except those inside quotes
        //
        if ((lpstrInputCopy = mciAlloc (lstrlen (lpstrCommand) + 1)) == NULL)
            return MCIERR_OUT_OF_MEMORY;
        lstrcpy (lpstrInputCopy, lpstrCommand);
        lpstrCommand = lpstrInputCopy;
        lpstrCommandStart = (LPSTR)lpstrCommand;
        while (*lpstrCommandStart != '\0')
        {
            if (*lpstrCommandStart == '"')
                bInQuotes = !bInQuotes;
            else if (!bInQuotes && *lpstrCommandStart == '\t')
                *lpstrCommandStart = ' ';
            ++lpstrCommandStart;
        }
    }
    lpstrCommandStart = (LPSTR)lpstrCommand;

    if (lpstrReturnString == NULL) {
        //
        // As an additional safeguard against the driver writing into the
        // output buffer when the return string pointer is NULL, set its
        // length to 0
        //
        wReturnLength = 0;
    }
    else {
        //
        // Set return to empty string so that it won't print out garbage if not
        // touched again
        //
        *lpstrReturnString = '\0';
    }

    // Pull the command name and device name off the command string
    if ((dwReturn = mciSeparateCommandParts (&lpstrCommand, lpMessage != NULL,
                                   &lpstrCommandName, &lpstrDeviceName)) != 0)
        goto exitfn;

    // Get the device id (if any) of the given device name
    wDeviceID = mciGetDeviceIDInternal(lpstrDeviceName, hCallingTask);

    // Allow "new" for an empty device name
    if (wDeviceID == 0 && lstrcmpi (lpstrDeviceName, szNew) == 0)
    {
        bNewDevice = TRUE;
        *lpstrDeviceName = '\0';
    } else {
        bNewDevice = FALSE;
    }


    // Look up the command name
    wMessage = mciParseCommand (wDeviceID, lpstrCommandName, lpstrDeviceName,
                                &lpCommandItem, &wTable);

    // If the device has a pending auto-close
    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE nodeWorking = MCI_lpDeviceList[wDeviceID];

        // Is there a pending auto-close message?
        if (nodeWorking->dwMCIFlags & MCINODE_ISAUTOCLOSING)
        {
            // Let the device close
            //!!            Yield();
            // Did the device close?
            //!!            wDeviceID = mciGetDeviceIDInternal (lpstrDeviceName, hCallingTask);
            // If not then fail this command
            //!!            if (wDeviceID == 0)
            //!!            {

            wErr = MCIERR_DEVICE_LOCKED;
            goto cleanup;

            //!!            }

            // If the call does not come from another task and is not owned by this task
            // and is not the SYSINFO command
            //

        } else if (lpMessage == NULL &&
            nodeWorking->hOpeningTask != nodeWorking->hCreatorTask &&
            wMessage != MCI_SYSINFO)
        // Send the string inter-task
        {
            if (mciFindNotify (lpstrCommandStart))
            {
                wErr = MCIERR_NOTIFY_ON_AUTO_OPEN;
                goto cleanup;
            } else
            {
                LPSTR    lpstrReturnStringCopy;

                mciFree(lpstrCommandName);
                mciFree(lpstrDeviceName);
                mciUnlockCommandTable (wTable);

                if ((lpstrReturnStringCopy = mciAlloc (wReturnLength + 1)) != NULL)
                {
                    dwReturn = mciSendSystemString (lpstrCommandStart,
                                                    lpstrReturnStringCopy,
                                                    wReturnLength);
                    lstrcpy (lpstrReturnString, lpstrReturnStringCopy);
                    mciFree (lpstrReturnStringCopy);
                } else
                    dwReturn = MCIERR_OUT_OF_MEMORY;
                goto exitfn;
            }
        }
    }

    // There must be a device name (except for the MCI_SOUND message)
    if (*lpstrDeviceName == '\0' && wMessage != MCI_SOUND && !bNewDevice)
    {
        wErr = MCIERR_MISSING_DEVICE_NAME;
        goto cleanup;
    }

    // The command must appear in the parser tables
    if (wMessage == 0)
    {
        wErr = MCIERR_UNRECOGNIZED_COMMAND;
        goto cleanup;
    }

    // The "new" device name is only legal for the open message
    if (bNewDevice)
    {
        if (wMessage != MCI_OPEN)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto cleanup;
        }
    }

    // If there was no device ID
    if (wDeviceID == 0)
        // If auto open is not legal (usually internal commands)
        if (MCI_CANNOT_AUTO_OPEN (wMessage))
        {
            // If the command needs an open device
            if (!MCI_DO_NOT_NEED_OPEN (wMessage))
            {
                wErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
        } else

        // If auto open is legal try to open the device automatically
        {
            wErr = mciAutoOpenDevice (lpstrDeviceName, lpstrCommandStart,
                                      lpstrReturnString, wReturnLength);
            goto cleanup;
        }

    //
    //   Parse the command parameters
    //
    // Allocate command parameter block
    if ((lpdwParams = (LPDWORD)mciAlloc (sizeof(DWORD) * MCI_MAX_PARAM_SLOTS))
        == NULL)
    {
        wErr = MCIERR_OUT_OF_MEMORY;
        goto cleanup;
    }

    wErr = mciParseParams (lpstrCommand, lpCommandItem,
                            &dwFlags,
                            (LPSTR)lpdwParams,
                            MCI_MAX_PARAM_SLOTS * sizeof(DWORD),
                            &lpstrPointerList, &wParsingError);
    if (wErr != 0)
        goto cleanup;

    // The 'new' device keyword requires an alias
    if (bNewDevice && !(dwFlags & MCI_OPEN_ALIAS))
    {
        wErr = MCIERR_NEW_REQUIRES_ALIAS;
        goto cleanup;
    }

    // Parsed OK so execute command

    // Special processing for the MCI_OPEN message's parameters
    if (wMessage == MCI_OPEN)
    {
        // Manually reference the device type and device element
        if (dwFlags & MCI_OPEN_TYPE)
        {
            // The type name was specified explicitly as a parameter
            // so the given device name is the element name
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName
                = (LPSTR)lpstrDeviceName;
            dwFlags |= MCI_OPEN_ELEMENT;
        } else
        {
            // A type must be explicitly specified when "new" is used
            if (bNewDevice)
            {
                wErr = MCIERR_INVALID_DEVICE_NAME;
                goto cleanup;
            }
            // The device type is the given device name.
            // There is no element name
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrDeviceType
                = (LPSTR)lpstrDeviceName;
            ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName = NULL;
            dwFlags |= MCI_OPEN_TYPE;
        }
    }

    else if (wMessage == MCI_SOUND && *lpstrDeviceName != '\0')
    {
        // Kludge the sound name for SOUND
        //!!        mciToLower (lpstrDeviceName);
        if (lstrcmpi (lpstrDeviceName, szNotify) == 0)
            dwFlags |= MCI_NOTIFY;
        else if (lstrcmpi (lpstrDeviceName, szWait) == 0)
            dwFlags |= MCI_WAIT;
        else
        {
            ((LPMCI_SOUND_PARMS)lpdwParams)->lpstrSoundName = lpstrDeviceName;
            dwFlags |= MCI_SOUND_NAME;
        }
    }

    // Figure out what kind of return value to expect

    // Initialize flag
    wConvertReturnValue = 0;

    // Skip past header
    wLen = mciEatCommandEntry (lpCommandItem, NULL, NULL);

    // Get return value (if any)
    mciEatCommandEntry (lpCommandItem + wLen, &dwRetType, &wID);
    if (wID == MCI_RETURN)
    {
        // There is a return value
        if (wDeviceID == MCI_ALL_DEVICE_ID && wMessage != MCI_SYSINFO)
        {
            wErr = MCIERR_CANNOT_USE_ALL;
            goto cleanup;
        }
        switch ((UINT)dwRetType)
        {
            case MCI_STRING:
                // The return value is a string, point output
                // buffer to user's buffer
                lpdwParams[1] = (DWORD)lpstrReturnString;
                lpdwParams[2] = (DWORD)wReturnLength;
                break;

            case MCI_INTEGER:
                // The return value is an integer, flag to convert it
                // to a string later
                wConvertReturnValue = MCI_INTEGER;
                break;

            case MCI_RECT:
                // The return value is an rect, flag to
                // convert it to a string later
                wConvertReturnValue = MCI_RECT;
                break;
#ifdef DEBUG
            default:
                DOUT ("mciSendStringInternal:  Unknown return type\r\n");
                break;
#endif
        }
    }

    // We don't need this around anymore
    mciUnlockCommandTable (wTable);
    wTable = (UINT)-1;

    /* Fill the callback entry */
    lpdwParams[0] = (DWORD)(UINT)hwndCallback;

    // Kludge the type number for SYSINFO
    if (wMessage == MCI_SYSINFO)
        ((LPMCI_SYSINFO_PARMS)lpdwParams)->wDeviceType = mciLookUpType(lpstrDeviceName);

    // Now we actually send the command further into the bowels of MCI!

    // The INTERNAL version of mciSendCommand is used in order to get
    // special return description information encoded in the high word
    // of the return value and to get back the list of pointers allocated
    // by any parsing done in the open command
    {
        MCI_INTERNAL_OPEN_INFO OpenInfo;
        OpenInfo.lpstrParams = (LPSTR)lpstrCommand;
        OpenInfo.lpstrPointerList = lpstrPointerList;
        OpenInfo.hCallingTask = hCallingTask;
        OpenInfo.wParsingError = wParsingError;
        dwErr = mciSendCommandInternal (wDeviceID, wMessage, dwFlags,
                                        (DWORD)(LPDWORD)lpdwParams,
                                        &OpenInfo);
        // If the command was reparsed there may be a new pointer list
        // and the old one was free'd
        lpstrPointerList = OpenInfo.lpstrPointerList;
    }

    wErr = (UINT)dwErr;

    if (wErr != 0)
        // If command execution error
        goto cleanup;

    // Command executed OK
    // See if a string return came back with an integer instead
    if (dwErr & MCI_INTEGER_RETURNED)
        wConvertReturnValue = MCI_INTEGER;

    // If the return value must be converted
    if (wConvertReturnValue != 0 && wReturnLength != 0)
        wErr = mciConvertReturnValue (wConvertReturnValue, HIWORD(dwErr),
                                      wDeviceID, lpdwParams,
                                      lpstrReturnString, wReturnLength);

cleanup:
    if (wTable != -1)
        mciUnlockCommandTable (wTable);

    mciFree(lpstrCommandName);
    mciFree(lpstrDeviceName);
    if (lpdwParams != NULL)
        mciFree (lpdwParams);

    // Free any memory used by string parameters
    mciParserFree (lpstrPointerList);

    dwReturn =  (wErr >= MCIERR_CUSTOM_DRIVER_BASE ?
                (DWORD)wErr | (DWORD)wDeviceID << 16 :
                (DWORD)wErr);

#ifdef DEBUG
    if (dwReturn != 0)
    {
        char strTemp[MAXERRORLENGTH];

        if (!mciGetErrorString (dwReturn, strTemp, sizeof(strTemp)))
            LoadString(ghInst, STR_MCISSERRTXT, strTemp, sizeof(strTemp));
        else
            DPRINTF(("mciSendString: %ls\r\n",(LPSTR)strTemp));
    }
#endif

exitfn:
    if (lpstrInputCopy != NULL)
        mciFree (lpstrInputCopy);

#ifdef DEBUG
    mciCheckLocks();
#endif

    return dwReturn;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api DWORD | mciSendString | This function sends a command string to an
 *  MCI device.  The device that the command is sent to is specified in the
 *  command string.
 *
 * @parm LPCSTR | lpstrCommand | Specifies an MCI command string.
 *
 * @parm LPSTR | lpstrReturnString | Specifies a buffer for return
 *  information. If no return information is needed, you can specify
 *  NUL for this parameter.
 *
 * @parm UINT | wReturnLength | Specifies the size of the return buffer
 *  specified by <p lpstrReturnString>.
 *
 * @parm HWND | hwndCallback | Specifies a handle to a window to call back
 *  if "notify" was specified in the command string.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *  error information. The low-order word
 *  of the returned DWORD contains the error return value.
 *
 *  To get a textual description of <f mciSendString> return values,
 *  pass the return value to <f mciGetErrorString>.
 *
 *  The error returns listed for <f mciSendCommand> also apply to
 *  <f mciSendString>. The following error returns are unique to
 *  <f mciSendString>:
 *
 *  @flag MCIERR_BAD_CONSTANT | Unknown value for parameter.
 *
 *  @flag MCIERR_BAD_INTEGER | Invalid or missing integer in command.
 *
 *  @flag MCIERR_DUPLICATE_FLAGS | A flag or value was specified twice.
 *
 *  @flag MCIERR_MISSING_COMMAND_STRING | No command was specified.
 *
 *  @flag MCIERR_MISSING_DEVICE_NAME | No device name was specified.
 *
 *  @flag MCIERR_MISSING_STRING_ARGUMENT | A string value was
 *  missing from the command.
 *
 *  @flag MCIERR_NEW_REQUIRES_ALIAS | An alias must be used
 *  with the "new" device name.
 *
 *  @flag MCIERR_NO_CLOSING_QUOTE | A closing quotation mark is missing.
 *
 *  @flag MCIERR_NOTIFY_ON_AUTO_OPEN | The "notify" flag is illegal
 *  with auto-open.
 *
 *  @flag MCIERR_PARAM_OVERFLOW | The output string was not long enough.
 *
 *  @flag MCIERR_PARSER_INTERNAL | Internal parser error.
 *
 *  @flag MCIERR_UNRECOGNIZED_KEYWORD | Unknown command parameter.
 *
 * @xref mciGetErrorString mciSendCommand
 */
DWORD WINAPI
mciSendString(
    LPCSTR lpstrCommand,
    LPSTR lpstrReturnString,
    UINT wReturnLength,
    HWND hwndCallback
    )
{
    DWORD   dwErr32;
    DWORD   dwErr16 = MMSYSERR_NOERROR;
    LPSTR   lpstr;
    BOOL    fHaveAll = FALSE;

    // Initialize the 16-bit device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList()) {
        return MCIERR_OUT_OF_MEMORY;
    }

    dwErr32 = mciMessage( THUNK_MCI_SENDSTRING, (DWORD)lpstrCommand,
                          (DWORD)lpstrReturnString, (DWORD)wReturnLength,
                          (DWORD)hwndCallback );

    /*
    ** Even if the string was processed correctly by the 32 bit side
    ** we might still have to pass it through to the 16 bit side if it
    ** contains the string " all\0" or " all ".
    */
    lpstr = _fstrstr( lpstrCommand, " all" );
    if ( lpstr ) {

        lpstr += 4;

        if ( *lpstr == ' ' || *lpstr == '\0' ) {
            fHaveAll = TRUE;
        }
    }


    /*
    ** If we have the all device or an error from the 32 bit side
    ** we have to try the 16 bit side.
    */

    if ( !fHaveAll && dwErr32 == MMSYSERR_NOERROR ) {
        return dwErr32;
    }
    else {

        dwErr16 = mciSendStringInternal( lpstrCommand, lpstrReturnString,
                                         wReturnLength, hwndCallback, NULL );
    }


    /*
    ** Special processing of the return code is required if the
    ** MCI_ALL_DEVICE_ID was specified.
    */
    if ( fHaveAll ) {
        if ( (dwErr16 != MMSYSERR_NOERROR)
          && (dwErr32 != MMSYSERR_NOERROR) ) {

            return dwErr32;
        }
        else {
            return MMSYSERR_NOERROR;
        }
    }

    if ( dwErr32 != MCIERR_INVALID_DEVICE_NAME
      && dwErr16 != MMSYSERR_NOERROR ) {

         return dwErr32;
    }

    return dwErr16;
}


/*
 * @doc INTERNAL MCI
 *
 * @api BOOL | mciExecute | This function is a simplified version of the
 *  <f mciSendString> function. It does not take a buffer for
 *  return information, and it displays a message box when errors occur.
 *
 * @parm LPCSTR | lpstrCommand | Specifies an MCI command string.
 *
 * @rdesc TRUE if successful, FALSE if unsuccessful.
 *
 * @comm This function provides a simple interface to MCI from scripting
 *  languages.
 *
 * @xref mciSendString
 */
BOOL WINAPI
mciExecute(
    LPCSTR lpstrCommand
    )
{
    char aszError[MAXERRORLENGTH];
    DWORD dwErr;
    LPSTR lpstrName;

    if (LOWORD(dwErr = mciSendString (lpstrCommand, NULL, 0, NULL)) == 0)
        return TRUE;

    if (!mciGetErrorString (dwErr, aszError, sizeof(aszError)))
        LoadString(ghInst, STR_MCIUNKNOWN, aszError, sizeof(aszError));
    else

    if (lpstrCommand != NULL)
    {
// Skip initial blanks
        while (*lpstrCommand == ' ')
            ++lpstrCommand;
// Then skip the command
        while (*lpstrCommand != ' ' && *lpstrCommand != '\0')
            ++lpstrCommand;
// Then blanks before the device name
        while (*lpstrCommand == ' ')
            ++lpstrCommand;

// Now, get the device name
        if (lpstrCommand != '\0' &&
            mciEatToken (&lpstrCommand, ' ', &lpstrName, FALSE) != 0)
            DOUT ("Could not allocate device name text for error box\r\n");
    } else
        lpstrName = NULL;

    MessageBox (NULL, aszError, lpstrName, MB_ICONHAND | MB_OK);

    if (lpstrName != NULL)
        mciFree(lpstrName);

    return FALSE;
}

/*
 * @doc EXTERNAL MCI
 *
 * @api BOOL | mciGetErrorString | This function returns a
 * textual description of the specified MCI error.
 *
 * @parm DWORD | dwError | Specifies the error code returned by
 *  <f mciSendCommand> or <f mciSendString>.
 *
 * @parm LPSTR | lpstrBuffer | Specifies a pointer to a buffer that is
 *  filled with a textual description of the specified error.
 *
 * @parm UINT | wLength | Specifies the length of the buffer pointed to by
 *  <p lpstrBuffer>.
 *
 * @rdesc Returns TRUE if successful.  Otherwise, the given error code
 *  was not known.
 */
BOOL WINAPI
mciGetErrorString (
    DWORD dwError,
    LPSTR lpstrBuffer,
    UINT wLength
    )
{
    HINSTANCE hInst;


    if (lpstrBuffer == NULL)
        return FALSE;

    if ( mciMessage( THUNK_MCI_GETERRORSTRING, (DWORD)dwError,
                     (DWORD)lpstrBuffer, (DWORD)wLength, 0L ) ) {
        return TRUE;
    }

// If the high bit is set then get the error string from the driver
// else get it from mmsystem.dll
    if (HIWORD(dwError) != 0)
    {
        if (!MCI_VALID_DEVICE_ID (HIWORD (dwError)) || !(hInst = MCI_lpDeviceList[HIWORD (dwError)]->hDriver))
        {
            hInst = ghInst;
            dwError = MCIERR_DRIVER;
        }
    } else
        hInst = ghInst;

    if (LoadString (hInst, LOWORD(dwError), lpstrBuffer, wLength) == 0)
    {
// If the string load failed then at least terminate the string
        if (wLength > 0)
            *lpstrBuffer = '\0';
        return FALSE;
    }
    else
        return TRUE;
}

#if 0
/* Return non-zero if load successful */
BOOL NEAR PASCAL MCIInit(void)
{
    mci32Message = (LPMCIMESSAGE)GetProcAddress32W( mmwow32Lib,
                                                    "mci32Message" );
    return TRUE;
}
#endif


void NEAR PASCAL
MCITerminate(
    void
    )
{
/*
    We would like to close all open devices here but cannot because of
 	   unknown WEP order
*/
    if (hMciHeap != NULL)
        HeapDestroy(hMciHeap);

    hMciHeap = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\joy.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   joy.c - MMSYSTEM Joystick interface code

   Version: 1.00

   Date:    10-Jun-1990

   Author:  GLENNS ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
  --------   ----- -----------------------------------------------------------
    2/7/90             Changes to avoid a bug in Windows which won't allow
                       FreeLibrary to be called during WEP.

    10/11/90      .61  Use windows timer + general cleanup

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

//  Put init and terminate code in correct segment.

static void NEAR PASCAL joyGetCalibration(void);

#pragma alloc_text( INIT, JoyInit )
#pragma alloc_text( INIT, joyGetCalibration)

/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
extern JOYMESSAGEPROC PASCAL joy32Message;



/****************************************************************************

    strings

****************************************************************************/

extern char far szNull[];                   // in INIT.C
extern char far szSystemIni[];
extern char far szJoystick[];
extern char far szJoystickDrv[];
extern char far szDrivers[];

char szJoyKey[] = "JoyCal ";

/****************************************************************************

    Joystick Capture Internal Structure

****************************************************************************/

typedef struct joycapture_tag {
    HWND    hWnd;
    UINT    wPeriod;
    BOOL    bChanged;
    UINT    wThreshold;
    UINT    wIDEvent;
} JOYCAPTURE;

#define iJoyMax 2
#define JOY_UNINITIALIZED 0xFFFF

// !!! Code assumes these constants equal 0 and 1

#if JOYSTICKID1	!= 0
ERROR IN ASSUMMED CONSTANT
#endif
#if JOYSTICKID2	!= 1
ERROR IN ASSUMMED CONSTANT
#endif


/****************************************************************************

    Local data

****************************************************************************/

static JOYCAPTURE  JoyCapture[iJoyMax];
static HDRVR       hDrvJoy[iJoyMax];
static UINT        wNumDevs = JOY_UNINITIALIZED;

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT wIDEvent, DWORD dwTime);

/****************************************************************************

    @doc INTERNAL

    @api void | joyGetCalibration | Retrieve and set calibration from
    [joystick.drv] section of system.ini file.

****************************************************************************/

// !!! need to do clean up of strings in all of mmsystem

static void NEAR PASCAL joyGetCalibration(void)
{
    char szKeyName[sizeof(szJoyKey)];

    #define hexval(h)   (int)(h>='a'?h-'a'+10:h-'0')

    UINT     val[6];
    UINT     wDev,wVal;
    int      hv;
    char     c,sz[80],far *psz;

    lstrcpy(szKeyName, szJoyKey);
    for (wDev=0; wDev < wNumDevs; wDev++)
    {
        szKeyName[sizeof(szKeyName)-2] = (char)(wDev + '0');

        if (GetPrivateProfileString(szJoystickDrv,
                szKeyName,szNull,sz,sizeof(sz),szSystemIni))
        {
            AnsiLower(sz);
            for (psz=sz,wVal=0; c = *psz, wVal < 6; psz++)
            {
                if (c != ' ')
                {
                    hv=0;

                    do {
                        hv = (hv << 4) + hexval(c);
                    } while ((c=*++psz) && (c!=' '));

                    val[wVal++] = hv;
                }
            }
            joySetCalibration (wDev,val+0,val+1,val+2,val+3,val+4,val+5);
        }
    }
}

/****************************************************************************

    @doc INTERNAL

    @api BOOL | JoyInit | This function initializes the joystick services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
	   if an error occurs

****************************************************************************/

BOOL FAR PASCAL JoyInit(void)
{
    // Only attempt initialization once.
    if (wNumDevs != JOY_UNINITIALIZED) {
        return FALSE;
    }
    else {
        wNumDevs = 0;
    }

    wNumDevs = joyMessage( (HDRVR)1, JDD_GETNUMDEVS, 0L, 0L );

    // Make sure driver was installed.
    if (joy32Message == NULL) {
        return FALSE;
    }

    switch ( wNumDevs ) {

    case 2:
        hDrvJoy[1] = (HDRVR)2;
        /* fall thru */

    case 1:
        hDrvJoy[0] = (HDRVR)1;
        break;

    default:
        return FALSE;
    }

    // Initialize joycapture...

    // Code relies on hWnd being NULL or an invalid window handle
    // if joystick is not captured.

    JoyCapture[0].hWnd = NULL;
    JoyCapture[1].hWnd = NULL;

    // Code relies on joystick threshold being initialized to a rational
    // value. 0 essentially turns threshold off - any change in joystick
    // position will be reported.

    JoyCapture[0].wThreshold= 0;
    JoyCapture[1].wThreshold= 0;

    JoyCapture[0].wIDEvent= 0;
    JoyCapture[1].wIDEvent= 0;

    // bChanged, and wPeriod do not need initializing.

    joyGetCalibration ();

    return TRUE;

}


/****************************************************************************
*
*   MMSYSTEM JOYSTICK API'S
*
****************************************************************************/

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetDevCaps | This function queries a joystick device to
    determine its capabilities.

    @parm UINT | wId | Identifies the device to be queried. This value
    is either JOYSTICKID1 or JOYSTICKID2.

    @parm LPJOYCAPS | lpCaps | Specifies a far pointer to a <t JOYCAPS>
    data structure.  This structure is filled with information about the
    capabilities of the joystick device.

    @parm UINT | wSize | Specifies the size of the <t JOYCAPS> structure.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm Use <f joyGetNumDevs> to determine the number of
    joystick devices supported by the driver.

    @xref joyGetNumDevs
****************************************************************************/

UINT WINAPI joyGetDevCaps(UINT wId, LPJOYCAPS lpCaps, UINT wSize)
{
    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if ((!hDrvJoy[0] && !JoyInit()) || (wId >= iJoyMax))
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
        return JOYERR_PARMS;

    return joyMessage( hDrvJoy[wId], JDD_GETDEVCAPS,
                       (DWORD)lpCaps, (DWORD)wSize );
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetNumDevs | This function returns the number of joystick
    devices supported by the system.

    @rdesc Returns the number of joystick devices supported by the joystick
    driver. If no driver is present, the function returns zero.

    @comm Use <f joyGetPos> to determine whether a given
    joystick is actually attached to the system. The <f joyGetPos> function returns
    a JOYERR_UNPLUGGED error code if the specified joystick is not connected.

    @xref joyGetDevCaps joyGetPos

****************************************************************************/

UINT WINAPI joyGetNumDevs(void)
{
    // Return 0 on error (Can't return JOYERR_NODRIVER
    // since no way to distinguish error code from valid count.)

    if (!hDrvJoy[0] && !JoyInit())
        return 0;

    return wNumDevs;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetPos | This function queries for the position and button
    activity of a joystick device.

    @parm UINT | wId | Identifies the joystick device to be queried.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm LPJOYINFO | lpInfo | Specifies a far pointer to a <t JOYINFO>
    data structure.  This structure is filled with information about the
    position and button activity of the joystick device.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

****************************************************************************/

UINT WINAPI joyGetPos(UINT wId, LPJOYINFO lpInfo)
{
    V_WPOINTER(lpInfo, sizeof(JOYINFO), MMSYSERR_INVALPARAM);

    if ((!hDrvJoy[0] && !JoyInit()) || (wId >= iJoyMax))
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    return joyMessage( hDrvJoy[wId], JDD_GETPOS, (DWORD)lpInfo, 0L );
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyGetThreshold | This function queries the current
    movement threshold of a joystick device.

    @parm UINT | wId | Identifies the joystick device to be queried.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm UINT FAR* | lpwThreshold | Specifies a far pointer to a UINT variable
    that is filled with the movement threshold value.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm The movement threshold is the distance the joystick must be
	  moved before a WM_JOYMOVE message is sent to a window that has
	  captured the device. The threshold is initially zero.

    @xref joySetThreshold

****************************************************************************/

UINT WINAPI joyGetThreshold(UINT wId, UINT FAR* lpwThreshold)
{
    V_WPOINTER(lpwThreshold, sizeof(UINT), MMSYSERR_INVALPARAM);

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    *lpwThreshold = (JoyCapture[wId].wThreshold);

    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joyReleaseCapture | This function releases the capture
    set by <f joySetCapture> on the specified joystick device.

    @parm UINT | wId | Identifies the joystick device to be released.
    This value is either JOYSTICKID1 or JOYSTICK2.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @xref joySetCapture
****************************************************************************/

UINT WINAPI joyReleaseCapture(UINT wId)
{
    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    if (JoyCapture[wId].hWnd == NULL)
        return JOYERR_NOERROR;

    KillTimer (NULL, JoyCapture[wId].wIDEvent);
    JoyCapture[wId].wIDEvent = 0;
    JoyCapture[wId].hWnd = NULL;

    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joySetCapture | This function causes joystick messages to
    be sent to the specified window.

    @parm HWND | hWnd | Specifies a handle to the window to which messages
    are to be sent.

    @parm UINT | wId | Identifies the joystick device to be captured.
    This value is either JOYSTICKID1 or JOYSTICKID2.

    @parm UINT | wPeriod | Specifies the polling rate, in milliseconds.

    @parm BOOL | bChanged | If this parameter is set to TRUE, then messages
    are sent only when the position changes by a value greater than the
    joystick movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified window handle <p hWnd>
    or joystick device ID <p wId> is invalid.

    @flag JOYERR_NOCANDO | Cannot capture joystick input because some
    required service (for example, a Windows timer) is unavailable.

    @flag JOYERR_UNPLUGGED | The specified joystick is not connected to the
    system.

    @comm     This function fails if the specified joystick device is
    currently captured.  You should call the <f joyReleaseCapture> function when
    the joystick capture is no longer needed.  If the window is destroyed,
    the joystick will be released automatically.

    @xref  joyReleaseCapture joySetThreshold joyGetThreshold

****************************************************************************/

UINT WINAPI joySetCapture(HWND hwnd, UINT wId, UINT wPeriod, BOOL bChanged )
{
    JOYINFO     joyinfo;
    LPJOYINFO   lpinfo = &joyinfo;
    UINT        w;
    JOYCAPS     JoyCaps;

    if (!hwnd || !IsWindow(hwnd))
        return JOYERR_PARMS;

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    if (JoyCapture[wId].hWnd)
        if (IsWindow(JoyCapture[wId].hWnd))
            return JOYERR_NOCANDO;
        else
            joyReleaseCapture(wId);

    if (joyGetDevCaps (wId, &JoyCaps, sizeof(JOYCAPS)) == 0)
	wPeriod = min(JoyCaps.wPeriodMax,max(JoyCaps.wPeriodMin,wPeriod));
    else
        return JOYERR_NOCANDO;

    // ensure that position info. is ok.

    if (w = joyGetPos(wId, lpinfo))
        return (w);

    JoyCapture[wId].wPeriod = wPeriod;
    JoyCapture[wId].bChanged = bChanged;

    if (!(JoyCapture[wId].wIDEvent = SetTimer(NULL, 0, wPeriod, (TIMERPROC)joyPollCallback)))
    {
        DOUT("MMSYSTEM: Couldn't allocate timer in joy.c\r\n");
        return JOYERR_NOCANDO;
    }

    JoyCapture[wId].hWnd = hwnd;
    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc EXTERNAL

    @api UINT | joySetThreshold | This function sets the movement threshold
	 of a joystick device.

    @parm UINT | wId | Identifies the joystick device.  This value is either
    JOYSTICKID1 or JOYSTICKID2.

    @parm UINT | wThreshold | Specifies the new movement threshold.

    @rdesc Returns JOYERR_NOERROR if successful.  Otherwise, returns one of the
    following error codes:

    @flag MMSYSERR_NODRIVER | The joystick driver is not present.

    @flag JOYERR_PARMS | The specified joystick device ID <p wId> is invalid.

    @comm The movement threshold is the distance the joystick must be
	  moved before a MM_JOYMOVE message is sent to a window that has
	  captured the device.

    @xref joyGetThreshold joySetCapture

****************************************************************************/

UINT WINAPI joySetThreshold(UINT wId, UINT wThreshold)
{
    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= iJoyMax)
        return MMSYSERR_INVALPARAM;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    JoyCapture[wId].wThreshold = wThreshold;
    return JOYERR_NOERROR;
}

/****************************************************************************

    @doc INTERNAL

    @api UINT | joySetCalibration | This function sets the values used to
	 convert the values returned by the joystick drivers GetPos function
	 to the range specified in GetDevCaps.

    @parm UINT | wId | Identifies the joystick device

    @parm UINT FAR* | pwXbase | Specifies the base value for the X pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwXdelta | Specifies the delta value for the X pot.	The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwYbase | Specifies the base value for the Y pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwYdelta | Specifies the delta value for the Y pot.	The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwZbase | Specifies the base value for the Z pot.  The
	  previous value will be copied back to the variable pointed to here.

    @parm UINT FAR* | pwZdelta | Specifies the delta value for the Z pot.	The
	  previous value will be copied back to the variable pointed to here.

    @rdesc The return value is zero if the function was successful, otherwise
	   it is an error number.

    @comm The base represents the lowest value the joystick driver returns,
	  whereas the delta represents the multiplier to use to convert
	  the actual value returned by the driver to the valid range
	  for the joystick API's.
	  i.e.	If the driver returns a range of 43-345 for the X pot, and
	  the valid mmsystem API range is 0-65535, the base value will be
	  43, and the delta will be 65535/(345-43)=217.  Thus the base,
	  and delta convert 43-345 to a range of 0-65535 with the formula:
	  ((wXvalue-43)*217) , where wXvalue was given by the joystick driver.

****************************************************************************/

UINT WINAPI joySetCalibration( UINT wId,
                               UINT FAR* pwXbase,
                               UINT FAR* pwXdelta,
                               UINT FAR* pwYbase,
                               UINT FAR* pwYdelta,
                               UINT FAR* pwZbase,
                               UINT FAR* pwZdelta )
{
    JOYCALIBRATE    oldCal,newCal;
    UINT w;

    if (!hDrvJoy[0] && !JoyInit())
        return MMSYSERR_NODRIVER;

    if (wId >= wNumDevs)
       return JOYERR_PARMS;

    newCal.wXbase  = *pwXbase;
    newCal.wXdelta = *pwXdelta;

    newCal.wYbase  = *pwYbase;
    newCal.wYdelta = *pwYdelta;

    newCal.wZbase  = *pwZbase;
    newCal.wZdelta = *pwZdelta;

    w = joyMessage( hDrvJoy[wId], JDD_SETCALIBRATION, (DWORD)(LPSTR)&newCal,
                    (DWORD)(LPSTR)&oldCal );

    *pwXbase  = oldCal.wXbase;
    *pwXdelta = oldCal.wXdelta;

    *pwYbase  = oldCal.wYbase;
    *pwYdelta = oldCal.wYdelta;

    *pwZbase  = oldCal.wZbase;
    *pwZdelta = oldCal.wZdelta;

    return w;
}

/****************************************************************************

    @doc INTERNAL

    @api void | joyPollCallback | Function called for joystick
	 timer polling scheme initiated from SetCapture call.
	
    @parm HWND | hWnd | Identifies the window associated with the timer
    event.

    @parm UINT | wMsg | Specifies the WM_TIMER message.

    @parm UINT | wIDEvent | Specifies the timer's ID.

    @parm DWORD | dwTime | Specifies the current system time.


****************************************************************************/

void CALLBACK joyPollCallback(HWND hWnd, UINT wMsg, UINT wIDEvent, DWORD dwTime)
{
    #define	diff(w1,w2) (UINT)(w1 > w2 ? w1-w2 : w2-w1)

    static  JOYINFO  oldInfo[2] = {{ 0, 0, 0, 0 },{ 0, 0, 0, 0 }};
    JOYINFO Info;

    UINT    w ,fBtnMask;

    if (wIDEvent == JoyCapture[0].wIDEvent)
        wIDEvent = 0;
    else if (wIDEvent == JoyCapture[1].wIDEvent)
        wIDEvent = 1;

#ifdef DEBUG
    else
    {
        DOUT("MMSYSTEM: Invalid timer handle in joy.c\r\n");
        KillTimer (NULL, wIDEvent);
    }
#endif


    if (!JoyCapture[wIDEvent].hWnd || !IsWindow(JoyCapture[wIDEvent].hWnd))
        joyReleaseCapture(wIDEvent);

    if (!joyMessage( hDrvJoy[wIDEvent], JDD_GETPOS,
                     (DWORD)(LPJOYINFO)&Info, 0L ))
    {

	for (w=0,fBtnMask=1; w < 4; w++,fBtnMask <<=1)
        {
	    if ((Info.wButtons ^ oldInfo[wIDEvent].wButtons) & fBtnMask)
            {
		PostMessage(
		      JoyCapture[wIDEvent].hWnd,
		      wIDEvent + ((Info.wButtons & fBtnMask) ?
		      MM_JOY1BUTTONDOWN : MM_JOY1BUTTONUP ),
		      (WPARAM)(Info.wButtons | fBtnMask << 8),
		      MAKELPARAM(Info.wXpos,Info.wYpos));
	    }
	}

	if (!JoyCapture[wIDEvent].bChanged ||
	    diff(Info.wXpos,oldInfo[wIDEvent].wXpos)>JoyCapture[wIDEvent].wThreshold ||
	    diff(Info.wYpos,oldInfo[wIDEvent].wYpos)>JoyCapture[wIDEvent].wThreshold)
        {
	    PostMessage(
	        JoyCapture[wIDEvent].hWnd,
	        MM_JOY1MOVE+wIDEvent,
	        (WPARAM)(Info.wButtons),
	        MAKELPARAM(Info.wXpos,Info.wYpos));

	}

        else if (!JoyCapture[wIDEvent].bChanged ||
	    diff(Info.wZpos,oldInfo[wIDEvent].wZpos)>JoyCapture[wIDEvent].wThreshold)
        {
	    PostMessage(
	        JoyCapture[wIDEvent].hWnd,
		MM_JOY1ZMOVE+wIDEvent,
		(WPARAM)Info.wButtons,
		MAKELPARAM(Info.wZpos,0));
        }
	
        oldInfo[wIDEvent] = Info;
    }
    #undef  diff
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mciparse.c ===
/*******************************Module*Header*********************************\
* Module Name: mciparse.c
*
* Media Control Architecture Command Parser
*
* Created: 3/2/90
* Author:  DLL (DavidLe)
*
* History:
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/

#include <windows.h>
#define MMNOMIDI
#define MMNOWAVE
#define MMNOSOUND
#define MMNOTIMER
#define MMNOJOY
#define MMNOSEQ
#include "mmsystem.h"
#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"
#include "mmsysi.h"

#ifndef STATICFN
#define STATICFN
#endif

#define	WCODE	UINT _based(_segname("_CODE"))

extern char far szOpen[];       // in MCI.C

#ifdef DEBUG_RETAIL
extern int DebugmciSendCommand;
#endif

// Number of command tables registered, including "holes"
static UINT number_of_command_tables;

// Command table list
command_table_type command_tables[MAX_COMMAND_TABLES];

static SZCODE szTypeTableExtension[] = ".mci";
static SZCODE szCoreTable[] = "core";

// Core table is loaded when the first MCI command table is requested
static BOOL bCoreTableLoaded;

// One element for each device type.  Value is the table type to use
// or 0 if there is no device type specific table.
static WCODE table_types[] =
{
    MCI_DEVTYPE_VCR,                // vcr
    MCI_DEVTYPE_VIDEODISC,          // videodisc
    MCI_DEVTYPE_OVERLAY,            // overlay
    MCI_DEVTYPE_CD_AUDIO,           // cdaudio
    MCI_DEVTYPE_DAT,                // dat
    MCI_DEVTYPE_SCANNER,            // scanner
    MCI_DEVTYPE_ANIMATION,          // animation
    MCI_DEVTYPE_DIGITAL_VIDEO,      // digitalvideo
    MCI_DEVTYPE_OTHER,              // other
    MCI_DEVTYPE_WAVEFORM_AUDIO,     // waveaudio
    MCI_DEVTYPE_SEQUENCER           // sequencer
};
/*!!
void PASCAL NEAR mciToLower (LPSTR lpstrString)
{
    while (*lpstrString != '\0')
    {
        if (*lpstrString >= 'A' && *lpstrString <= 'Z')
            *lpstrString += 0x20;

        ++lpstrString;
    }
}
*/
/*
 * @doc INTERNAL MCI
 * @func UINT | mciEatCommandEntry | Read a command resource entry and
 * return its length and its value and identifier
 *
 * @parm LPCSTR | lpEntry | The start of the command resource entry
 *
 * @parm LPDWORD | lpValue | The value of the entry, returned to caller
 * May be NULL
 *
 * @parm UINT FAR* | lpID | The identifier of the entry, returned to caller
 * May be NULL
 *
 * @rdesc The total number of bytes in the entry
 *
 */
UINT PASCAL NEAR mciEatCommandEntry (
LPCSTR lpEntry,
LPDWORD lpValue,
UINT FAR* lpID)
{
    LPCSTR lpScan = lpEntry;

    while (*lpScan++ != '\0')
        ;
    if (lpValue != NULL)
        *lpValue = *(LPDWORD)lpScan;
    lpScan += sizeof(DWORD);
    if (lpID != NULL)
        *lpID = *(LPWORD)lpScan;
    lpScan += sizeof(UINT);

    return lpScan - lpEntry;
}

// Return the size used by this token in the parameter list
UINT PASCAL NEAR mciGetParamSize (DWORD dwValue, UINT wID)
{
    switch (wID)
    {
        case MCI_CONSTANT:
        case MCI_INTEGER:
        case MCI_STRING:
            return sizeof(DWORD);
        case MCI_RECT:
            return sizeof(RECT);
        case MCI_RETURN:
            switch ((UINT)dwValue)
            {
                case MCI_INTEGER:
                    return sizeof(DWORD);
                case MCI_STRING:
                case MCI_RECT:
                    return sizeof(RECT);
                default:
                    DOUT ("mciGetParamSize:  Unknown return type\r\n");
                    return 0;
            }
            break;
    }
    return 0;
}


/*
 * @doc INTERNAL MCI
 * @func UINT | mciRegisterCommandTable | This function adds a new
 * table for the MCI parser.
 *
 * @parm HGLOBAL | hResource | Handle to the RCDATA resource
 *
 * @parm UINT FAR* | lpwIndex | Pointer to command table index
 *
 * @parm UINT   | wType | Specifies the device type for this command table.
 * Driver tables and the core table are type 0.
 *
 * @parm HINSTANCE | hModule | Module instance registering table.
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 *
 */
STATICFN UINT PASCAL NEAR
mciRegisterCommandTable(
    HGLOBAL hResource,
    UINT FAR* lpwIndex,
    UINT wType,
    HINSTANCE hModule
    )
{
    UINT wID;

/* First check for free slots */
    for (wID = 0; wID < number_of_command_tables; ++wID)
        if (command_tables[wID].hResource == NULL)
            break;

/* If no empty slots then allocate another one */
    if (wID >= number_of_command_tables)
    {
        if (number_of_command_tables == MAX_COMMAND_TABLES)
        {
            DOUT ("mciRegisterCommandTable: No more tables\r\n");
            return (UINT)-1;
        }
        else
           wID = number_of_command_tables++;
    }

/* Fill in the slot */
    command_tables[wID].wType = wType;
    command_tables[wID].hResource = hResource;
    command_tables[wID].lpwIndex = lpwIndex;
    command_tables[wID].hModule = hModule;
#ifdef DEBUG
    command_tables[wID].wLockCount = 0;
#endif
#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciRegisterCommandTable INFO: assigned slot %u\r\n", wID));
        DPRINTF(("mciRegisterCommandTable INFO: #tables is %u\r\n",
                 number_of_command_tables));
    }
#endif
    return wID;
}

/*
 * @doc DDK MCI
 * @api UINT | mciLoadCommandResource | Registers the indicated
 * resource as an MCI command table and builds a command table
 * index.  If a file with the resource name and the extension '.mci' is
 * found in the path then the resource is taken from that file.
 *
 * @parm HINSTANCE | hInstance | The instance of the module whose executable
 * file contains the resource.  This parameter is ignored if an external file
 * is found.
 *
 * @parm LPCSTR | lpResName | The name of the resource
 *
 * @parm UINT | wType | The table type.  Custom device specific tables MUST
 * give a table type of 0.
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 *
 */
UINT WINAPI mciLoadCommandResource (
HINSTANCE hInstance,
LPCSTR lpResName,
UINT wType)
{
    UINT FAR*           lpwIndex, FAR* lpwScan;
    HINSTANCE           hExternal;
    HRSRC               hResInfo;
    HGLOBAL             hResource;
    LPSTR               lpResource, lpScan;
    int                 nCommands = 0;
    UINT                wID;
    UINT                wLen;
                        // Name + '.' + Extension + '\0'
    char                strFile[8 + 1 + 3 + 1];
    LPSTR               lpstrFile = strFile;
    LPCSTR              lpstrType = lpResName;
    OFSTRUCT            ofs;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
        DPRINTF(("mciLoadCommandResource INFO:  %s loading\r\n", (LPSTR)lpResName));
#endif

// Initialize the device list
    if (!MCI_bDeviceListInitialized && !mciInitDeviceList())
        return MCIERR_OUT_OF_MEMORY;

// Load the core table if its not already there
    if (!bCoreTableLoaded)
    {
        bCoreTableLoaded = TRUE;
// If its not the core table being loaded
        if (lstrcmpi (szCoreTable, lpResName) != 0)
            if (mciLoadCommandResource (ghInst, szCoreTable, 0) == -1)
            {
                DOUT ("mciLoadCommandResource:  Cannot load core table\r\n");
            }
    }

// Check for a file with the extension ".mci"
// Copy up to the first eight characters of device type
    while (lpstrType < lpResName + 8 && *lpstrType != '\0')
        *lpstrFile++ = *lpstrType++;

// Tack extension onto end
    lstrcpy (lpstrFile, szTypeTableExtension);

// If the file exists and can be loaded then set flag
// otherwise load resource from MMSYSTEM.DLL
    if (OpenFile (strFile, &ofs, OF_EXIST) == HFILE_ERROR ||
        (hExternal = LoadLibrary(strFile)) < HINSTANCE_ERROR)

        hExternal = NULL;

// Load the given table from the file or from the module if not found
    if (hExternal != NULL &&
        (hResInfo = FindResource (hExternal, lpResName, RT_RCDATA)) != NULL)

        hInstance = hExternal;
    else
        hResInfo = FindResource (hInstance, lpResName, RT_RCDATA);

    if (hResInfo == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot find command resource\r\n");
        return (UINT)-1;
    }
    if ((hResource = LoadResource (hInstance, hResInfo)) == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot load command resource\r\n");
        return (UINT)-1;
    }
    if ((lpResource = LockResource (hResource)) == NULL)
    {
        DOUT ("mciLoadCommandResource:  Cannot lock resource\r\n");
        FreeResource (hResource);
        return (UINT)-1;
    }

/* Count the number of commands  */
    lpScan = lpResource;
    while (TRUE)
    {
        lpScan += mciEatCommandEntry(lpScan, NULL, &wID);

// End of command?
        if (wID == MCI_COMMAND_HEAD)
            ++nCommands;
// End of command list?
        else if (wID == MCI_END_COMMAND_LIST)
            break;
    }

// There must be at least on command in the table
    if (nCommands == 0)
    {
        DOUT ("mciLoadCommandResource:  No commands in the specified table\r\n");
        UnlockResource (hResource);
        FreeResource (hResource);
        return (UINT)-1;
    }

// Allocate storage for the command table index
// Leave room for a -1 entry to terminate it
    if ((lpwIndex = (UINT FAR*)
                        mciAlloc ((UINT)sizeof (UINT) * (nCommands + 1)))
                        == NULL)
    {
        DOUT ("mciLoadCommandResource:  cannot allocate command table index\r\n");
        UnlockResource (hResource);
        FreeResource (hResource);
        return (UINT)-1;
    }

/* Build Command Table */
    lpwScan = lpwIndex;
    lpScan = lpResource;

    while (TRUE)
    {
// Get next command entry
        wLen = mciEatCommandEntry (lpScan, NULL, &wID);

        if (wID == MCI_COMMAND_HEAD)
// Add an index to this command
            *lpwScan++ = lpScan - lpResource;

        else if (wID == MCI_END_COMMAND_LIST)
        {
// Mark the end of the table
            *lpwScan = (UINT)-1;
            break;
        }
        lpScan += wLen;
    }
    UnlockResource (hResource);
    return mciRegisterCommandTable (hResource, lpwIndex, wType, hExternal);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLoadTableType | If the table of the given type
 * has not been loaded, register it
 *
 * @parm UINT | wType | The table type to load
 *
 * @rdesc Returns the command table index number that was assigned or -1
 * on error.
 */
UINT PASCAL NEAR mciLoadTableType (
UINT wType)
{
    UINT wID;
    char buf[MCI_MAX_DEVICE_TYPE_LENGTH];
    int nTypeLen;

// Check to see if this table type is already loaded
    for (wID = 0; wID < number_of_command_tables; ++wID)
        if (command_tables[wID].wType == wType)
            return wID;

// Must load table
// First look up what device type specific table to load for this type
    if (wType < MCI_DEVTYPE_FIRST || wType > MCI_DEVTYPE_LAST)
        return (UINT)-1;

// Load string that corresponds to table type
    LoadString (ghInst, table_types[wType - MCI_DEVTYPE_FIRST],
                buf, sizeof(buf));

//Must be at least one character in type name
    if ((nTypeLen = lstrlen (buf)) < 1)
        return (UINT)-1;

// Register the table with MCI
    return mciLoadCommandResource (ghInst, buf, wType);
}

/*
 * @doc DDK MCI
 *
 * @api BOOL | mciFreeCommandResource | Frees the memory used
 * by the specified command table.
 *
 * @parm UINT | wTable | The table index returned from a previous call to
 * mciLoadCommandResource.
 *
 * @rdesc FALSE if the table index is not valid, TRUE otherwise.
 *
 */
BOOL WINAPI mciFreeCommandResource (
UINT wTable)
{
    UINT wID;
    HGLOBAL hResource;
    UINT FAR* lpwIndex;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciFreeCommandResource INFO:  Free table %d\r\n", wTable));
        DPRINTF(("mciFreeCommandResource INFO:  Lockcount is %d\r\n",
                  command_tables[wTable].wLockCount));
    }
#endif

/* Validate input -- do not let the core table be free'd */
    if (wTable <= 0 || wTable >= number_of_command_tables)
    {
#ifdef DEBUG
// wTable == -1 is OK
        if (wTable != -1)
            DOUT ("mciFreeCommandResource: Bad table number\r\n");
#endif
        return FALSE;
    }

// If this table is being used elsewhere then keep it around
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        if (MCI_lpDeviceList[wID] != NULL)
            if (MCI_lpDeviceList[wID]->wCustomCommandTable == wTable ||
                MCI_lpDeviceList[wID]->wCommandTable == wTable)
            {
#ifdef DEBUG
                if (DebugmciSendCommand > 2)
                    DOUT ("mciFreeCommandResource INFO:  table in use\r\n");
#endif
                return FALSE;
            }

#if 0
/* Search the list of tables */
    for (wID = 0; wID < number_of_command_tables; ++wID)

/* If this resource is still in use, keep it around */
        if (command_tables[wID].hResource == hResource)
        {
#ifdef DEBUG
            if (DebugmciSendCommand > 2)
                DOUT ("mciFreeCommandResource INFO:  resource in use\r\n");
#endif
            return FALSE;
        }
#endif

    hResource = command_tables[wTable].hResource;
    command_tables[wTable].hResource = NULL;

    lpwIndex = command_tables[wTable].lpwIndex;
    command_tables[wTable].lpwIndex = NULL;
    command_tables[wTable].wType = 0;


    FreeResource (hResource);
    mciFree (lpwIndex);

    if (command_tables[wTable].hModule != NULL)
        FreeLibrary (command_tables[wTable].hModule);

// Make space at top of list
    if (wTable == number_of_command_tables - 1)
        --number_of_command_tables;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
        DPRINTF(("mciFreeCommandResource INFO:  number_of_command_tables: %u\r\n",
                                             number_of_command_tables));
#endif

    return TRUE;
}

#ifdef DEBUG
void PASCAL NEAR mciCheckLocks (void)
{
    UINT wTable;

    if (DebugmciSendCommand <= 2)
        return;

    for (wTable = 0; wTable < number_of_command_tables; ++wTable)
    {
        if (command_tables[wTable].hResource == NULL)
            continue;
        DPRINTF(("mciCheckLocks INFO: table %u ", wTable));
        DPRINTF(("user: %x ",
                 GlobalFlags (command_tables[wTable].hResource) & GMEM_LOCKCOUNT));
        DPRINTF(("mci: %u ", command_tables[wTable].wLockCount));
        if (GlobalFlags (command_tables[wTable].hResource) & GMEM_DISCARDABLE)
            DPRINTF(("discardable\r\n"));
        else
            DPRINTF(("NOT discardable\r\n"));
    }
}
#endif

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciUnlockCommandTable | Unlocks the command table given by
 * a table index
 *
 * @parm UINT | wCommandTable | Table to unlock
 *
 * @rdesc TRUE if success, FALSE otherwise
 *
 * @comm Used external to this module by mci.c
 *
 */
BOOL PASCAL NEAR mciUnlockCommandTable (
UINT wCommandTable)
{
    UnlockResource(command_tables[wCommandTable].hResource);
#ifdef DEBUG
    --command_tables[wCommandTable].wLockCount;
    if (DebugmciSendCommand > 2)
    {
        DPRINTF(("mciUnlockCommandTable INFO:  table %d\r\n", wCommandTable));
        DOUT ("mciUnlockCommandTable INFO:  check locks...\r\n");
        mciCheckLocks();
    }
#endif
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | FindCommandInTable | Look up the given
 * command string in the GIVEN parser command table
 *
 * @parm UINT  | wTable | Command table to use
 *
 * @parm LPCSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.
 *
 * @parm UINT FAR * | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown or on error, otherwise a pointer to
 * the command list for the input command string.
 *
 * @comm If the command is found, the command resource will be locked on exit.
 *
 */
LPSTR PASCAL NEAR FindCommandInTable (
UINT wTable,
LPCSTR lpstrCommand,
UINT FAR * lpwMessage)
{
    UINT FAR* lpwIndex;
    LPSTR lpResource, lpstrThisCommand;
    UINT  wMessage;

/* Validate table */

    if (wTable >= number_of_command_tables)
    {
// Check the core table but its not yet loaded
        if (wTable == 0)
        {
// Try to load it
            if (mciLoadCommandResource (ghInst, szCoreTable, 0) == -1)
            {
                DOUT ("FindCommandInTable:  cannot load core table\r\n");
                return NULL;
            }
        } else
        {
            DOUT ("MCI FindCommandInTable:  invalid table ID\r\n");
            return NULL;
        }

    }

    if ((lpResource = LockResource (command_tables[wTable].hResource)) == NULL)
    {
        DOUT ("MCI FindCommandInTable:  Cannot lock table resource\r\n");
        return NULL;
    }
#ifdef DEBUG
    ++command_tables[wTable].wLockCount;
#endif

// Look at each command in the table
    lpwIndex = command_tables[wTable].lpwIndex;
    if (lpwIndex == NULL)
    {
        DOUT ("MCI FindCommandInTable:  null command table index\r\n");
        return NULL;
    }

    while (*lpwIndex != -1)
    {
        DWORD dwMessage;

        lpstrThisCommand = *lpwIndex++ + lpResource;

// Get message number from the table
        mciEatCommandEntry (lpstrThisCommand, &dwMessage, NULL);
        wMessage = (UINT)dwMessage;

// Does this command match the input?

// String case
        if  (HIWORD  (lpstrCommand) != 0 &&
             lstrcmpi (lpstrThisCommand, lpstrCommand) == 0  ||

// Message case
             HIWORD (lpstrCommand) == 0 &&
             wMessage == LOWORD ((DWORD)lpstrCommand))
        {
// Retain the locked resource pointer
                command_tables[wTable].lpResource = lpResource;

// Address the message ID which comes after the command name
                if (lpwMessage != NULL)
                    *lpwMessage = wMessage;
// Leave table locked on exit
                return lpstrThisCommand;
        }

// Strings don't match, go to the next command in the table
    }

    UnlockResource (command_tables[wTable].hResource);
#ifdef DEBUG
    --command_tables[wTable].wLockCount;
#endif

    return NULL;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | FindCommandItem | Look up the given
 * command string in the parser command tables
 *
 * @parm UINT | wDeviceID | The device ID used for this command.
 * If 0 then only the system core command table is searched.
 *
 * @parm LPCSTR | lpstrType | The type name of the device
 *
 * @parm LPCSTR | lpstrCommand | The command to look up.  It must
 * be in lower case with no leading or trailing blanks and with at
 * least one character.  If the HIWORD is 0 then the LOWORD contains
 * the command message ID instead of a command name and the function is
 * merely to find the command list pointer.
 *
 * If the high word is 0 then the low word is an command ID value instead
 * of a command name
 *
 * @parm UINT FAR* | lpwMessage | The message corresponding to the command
 * Returned to caller.
 *
 * @parm UINT FAR* | lpwTable | The table index in which the command was found
 * Returned to caller.
 *
 * @rdesc NULL if the command is unknown, otherwise a pointer to
 * the command list for the input command string.
 */
LPSTR PASCAL NEAR FindCommandItem (
UINT wDeviceID,
LPCSTR lpstrType,
LPCSTR lpstrCommand,
UINT FAR* lpwMessage,
UINT FAR* lpwTable)
{
    LPSTR lpCommand;
    UINT wTable;
    LPMCI_DEVICE_NODE nodeWorking;

// Only check hiword per comments above
    if (HIWORD (lpstrCommand) != NULL && *lpstrCommand == '\0')
    {
        DOUT ("MCI FindCommandItem:  lpstrCommand is NULL or empty string\r\n");
        return NULL;
    }

// If a specific device ID was specified then look in any custom table
// or type table
    if (wDeviceID != 0 && wDeviceID != MCI_ALL_DEVICE_ID)
    {
// If the device ID is valid
        if (!MCI_VALID_DEVICE_ID(wDeviceID))
        {
            DOUT ("MCI FindCommandItem:  Invalid device ID\r\n");
            return NULL;
        }
        nodeWorking = MCI_lpDeviceList[wDeviceID];

// If there is a custom command table then use it
        if ((wTable = nodeWorking->wCustomCommandTable) != -1)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL)
                goto exit;
        }
// Get the device type table from the existing device
// Relies on mciReparseCommand in mciLoadDevice to catch all device type
// tables when device is not yet open.
        if ((wTable = nodeWorking->wCommandTable) != -1)
        {
            lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
            if (lpCommand != NULL)
                goto exit;
        }
    }

// If no match was found in the device or type specific tables
// Look in the core table
    wTable = 0;
    lpCommand = FindCommandInTable (wTable, lpstrCommand, lpwMessage);
    if (lpCommand == NULL)
        wTable = (UINT)-1;

exit:
    if (lpwTable != NULL)
        *lpwTable = wTable;

#ifdef DEBUG
    if (DebugmciSendCommand > 2)
    {
        DOUT ("FindCommandItem INFO:  check locks...\r\n");
        mciCheckLocks();
    }
#endif

    return lpCommand;
}

/*
 * @doc INTERNAL MCI
 * @func LPSTR | mciCheckToken | Check to see if the command item matches
 * the given string, allowing multiple blanks in the input parameter to
 * match a corresponding single blank in the command token and ignoring
 * case.
 *
 * @parm LPCSTR | lpstrToken | The command token to check
 *
 * @parm LPCSTR | lpstrParam | The input parameter
 *
 * @rdesc NULL if no match, otherwise points to the first character
 * after the parameter
 *
 */
STATICFN LPSTR PASCAL NEAR
mciCheckToken(
    LPCSTR lpstrToken,
    LPCSTR lpstrParam
    )
{
/* Check for legal input */
    if (lpstrToken == NULL || lpstrParam == NULL)
        return NULL;

    while (*lpstrToken != '\0' && MCI_TOLOWER(*lpstrParam) == *lpstrToken)
    {
// If the token contains a blank, allow more than one blank in the
// parameter
        if (*lpstrToken == ' ')
            while (*lpstrParam == ' ')
                ++lpstrParam;
        else
            *lpstrParam++;
        *lpstrToken++;
    }
    if (*lpstrToken != '\0'|| (*lpstrParam != '\0' && *lpstrParam != ' '))
        return NULL;
    else
        return (LPSTR)lpstrParam;
}

/*
 * @doc INTERNAL MCI
 * @api BOOL | mciParseInteger | Parse the given integer
 *
 * @parm LPSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @rdesc Returns TRUE if not error
 *
 * @comm If there are colons in the input (':') the result is "colonized".
 * This means that each time a colon is read, the current result is written
 * and any subsequent digits are shifted left one byte.  No one "segment"
 * can be more than 0xFF.  For example, "0:1:2:3" is parsed to 0x03020100.
 *
 */

#pragma warning(4:4146)

STATICFN BOOL PASCAL NEAR
mciParseInteger(
    LPSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument
    )
{
    LPSTR lpstrInput = *lplpstrInput;
    BOOL fDigitFound;
    DWORD dwResult;
    LPSTR lpstrResult = (LPSTR)lpdwArgument;
    int   nDigitPosition = 0;
    BOOL  bSigned = FALSE;

// Leading blanks have been removed by mciParseParams

    if (*lpstrInput == '-')
    {
        ++lpstrInput;
        bSigned = TRUE;
    }

// Read digits
    *lpdwArgument = 0;                      /* Initialize */
    dwResult = 0;
    fDigitFound = FALSE;                    /* Initialize */
    while (*lpstrInput >= '0' && *lpstrInput <= '9' || *lpstrInput == ':')
    {
// ':' indicates colonized data
        if (*lpstrInput == ':')
        {
// Cannot mix colonized and signed forms
            if (bSigned)
            {
                DOUT ("Bad integer: mixing signed and colonized forms\r\n");
                return FALSE;
            }
// Check for overflow in accumulated colonized byte
            if (dwResult > 0xFF)
                return FALSE;

// Copy and move to next byte converted in output
            *lpstrResult++ = (char)dwResult;
            ++lpstrInput;
// Initialize next colonized byte
            dwResult = 0;
            ++nDigitPosition;
// Only allow four colonized components
            if (nDigitPosition > 3)
            {
                DOUT ("Bad integer:  Too many colonized components\r\n");
                return FALSE;
            }
        } else
        {
            char cDigit = (char)(*lpstrInput++ - '0');
// Satisfies condition that at least one digit must be read
            fDigitFound = TRUE;

            if (dwResult > 0xFFFFFFFF / 10)
// Overflow if multiply was to occur
                return FALSE;
            else
// Multiply for next digit
                dwResult *= 10;

// Add new digit
            dwResult += cDigit;
        }
    }
    if (nDigitPosition == 0)
    {
// No colonized components
        if (bSigned)
        {
// Check for overflow from negation
            if (dwResult > 0x7FFFFFFF)
                return FALSE;
// Negate result because a '-' sign was parsed
            dwResult = -dwResult;
        }

        *lpdwArgument = dwResult;
    }
    else
// Store last colonized component
    {
// Check for overflow
        if (dwResult > 0xFF)
            return FALSE;
// Store component
        *lpstrResult = (char)dwResult;
    }

    *lplpstrInput = lpstrInput;

/*
If there were no digits or if the digits were followed by a character
other than a blank or a '\0', then return a syntax error.
*/
    return fDigitFound && (!*lpstrInput || *lpstrInput == ' ');
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciParseConstant | Parse the given integer
 *
 * @parm LPSTR FAR * | lplpstrInput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwArgument | The place to put the output
 *
 * @parm LPSTR | lpItem | Pointer into command table.
 *
 * @rdesc Returns TRUE if not error
 *
 */
STATICFN BOOL PASCAL NEAR
mciParseConstant(
    LPSTR FAR * lplpstrInput,
    LPDWORD lpdwArgument,
    LPSTR lpItem
    )
{
    LPSTR lpPrev;
    DWORD dwValue;
    UINT wID;

// Skip past constant header
    lpItem += mciEatCommandEntry (lpItem, &dwValue, &wID);

    while (TRUE)
    {
        LPSTR lpstrAfter;

        lpPrev = lpItem;

        lpItem += mciEatCommandEntry (lpItem, &dwValue, &wID);

        if (wID == MCI_END_CONSTANT)
            break;

        if ((lpstrAfter = mciCheckToken (lpPrev, *lplpstrInput)) != NULL)
        {
            *lpdwArgument = dwValue;
            *lplpstrInput = lpstrAfter;
            return TRUE;
        }

    }

    return mciParseInteger (lplpstrInput, lpdwArgument);
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciParseArgument | Parse the given argument
 *
 * @parm DWORD | dwValue | The argument value
 *
 * @parm UINT | wID | The argument ID
 *
 * @parm LPSTR FAR * | lplpstrOutput | The string containing the argument.
 * It is updated and returned to the caller pointing to the first character
 * after the argument or to the first character that is in error.
 *
 * @parm LPDWORD | lpdwFlags | The output flags
 *
 * @parm LPDWORD | lpArgument | The place to put the output
 *
 * @rdesc Returns 0 if no error or
 * @flag MCIERR_BAD_INTEGER | An integer argument could not be parsed
 * @flag MCIERR_MISSING_STRING_ARGUMENT | An expected string argument
 * @flag MCIERR_PARM_OVERFLOW | The output buffer was a NULL pointer
 * was missing
 *
 */
STATICFN UINT PASCAL NEAR
mciParseArgument(
    DWORD dwValue,
    UINT wID,
    LPSTR FAR * lplpstrOutput,
    LPDWORD lpdwFlags,
    LPSTR lpArgument,
    LPSTR lpCurrentCommandItem
    )
{
LPSTR lpstrInput =  *lplpstrOutput;
UINT wRetval = 0;

/* Switch on the argument type */
    switch (wID)
    {

// The parameter is a flag
        case MCI_FLAG:
            break; /* switch */

        case MCI_CONSTANT:
            if (*lpstrInput == '\0')
                wRetval = MCIERR_NO_INTEGER;
            else if (!mciParseConstant (&lpstrInput, (LPDWORD)lpArgument,
                                        lpCurrentCommandItem))
                wRetval = MCIERR_BAD_CONSTANT;
            break;

/* The parameter has an integer argument, try to parse it */
        case MCI_INTEGER:
            if (!mciParseInteger (&lpstrInput, (LPDWORD)lpArgument))
                wRetval = MCIERR_BAD_INTEGER;

            break; /* switch */
        case MCI_RECT:
        {
// Read in four RECT components.  Resulting structure is the
// same as a Windows RECT
            long lTemp;
            int n;
            for (n = 0; n < 4; ++n)
            {
                if (!mciParseInteger (&lpstrInput, &lTemp))
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }
// Each component is a signed 16 bit number
                if (lTemp > 32768 || lTemp < -32767)
                {
                    wRetval = MCIERR_BAD_INTEGER;
                    break;
                }
                ((int FAR *)lpArgument)[n] = (int)lTemp;
// Remove leading blanks before next digit
                while (*lpstrInput == ' ') ++lpstrInput;
            }
            break;
        }

        case MCI_STRING:
        {
            LPSTR lpstrOutput;

/* The parameter has an string argument, read it */

// Leading blanks have been removed by mciParseParams

/* Are there any non-blank characters left in the input? */
            if (*lpstrInput == '\0')
            {
/* Return an error */
                wRetval = MCIERR_MISSING_STRING_ARGUMENT;
                break; /* switch */
            }

            if ((wRetval = mciEatToken (&lpstrInput, ' ', &lpstrOutput, FALSE))
                != 0)
            {
                DOUT ("mciParseArgument:  error parsing string\r\n");
                return wRetval;
            }

            *(LPDWORD)lpArgument = (DWORD)lpstrOutput;

// NOTE:  mciSendString frees the output string after command execution
// by calling mciParserFree

            break; /* switch */
        } /* case */
    } /* switch */

/* Update the output flags if there was no error */
    if (wRetval == 0)
    {
        if (*lpdwFlags & dwValue)
        {
            if (wID == MCI_CONSTANT)
                wRetval = MCIERR_FLAGS_NOT_COMPATIBLE;
            else
                wRetval = MCIERR_DUPLICATE_FLAGS;
        } else
            *lpdwFlags |= dwValue;
    }
/*
   Return the input pointer pointing at the first character after
   the argument or to the first character that is in error
*/
    *lplpstrOutput = lpstrInput;
    return wRetval;
}

/*
 * @doc MCI INTERNAL
 * @func UINT | mciParseParams | Parse the command parameters
 *
 * @parm LPCSTR | lpstrParams | The parameter string
 *
 * @parm LPCSTR | lpCommandList | The command table description
 * of the command tokens
 *
 * @parm LPDWORD | lpdwFlags | Return the parsed flags here
 *
 * @parm LPDWORD | lpdwOutputParams | Return the list of parameters here
 *
 * @parm UINT | wParamsSize | The size allocated for the parameter list
 *
 * @parm LPSTR FAR * FAR * | lpPointerList | A NULL terminated list of
 * pointers allocated by this function that should be free'd when
 * no longer needed.   The list itself should be free'd also.  In both
 * cases, use mciFree().
 *
 * @parm UINT FAR* | lpwParsingError | If not NULL then if the command is
 * 'open', unrecognized keywords return an error here, and the
 * function return value is 0 (unless other errors occur).  This
 * is used to allow reparsing of the command by mciLoadDevice
 *
 * @rdesc Returns zero if successful or one of the following error codes:
 * @flag MCIERR_PARM_OVERFLOW | Not enough space for parameters
 * @flag MCIERR_UNRECOGNIZED_KEYWORD | Unrecognized keyword
 *
 * @comm Any syntax error, including missing arguments, will result in
 * a non-zero error return and invalid output data.
 *
 */
UINT PASCAL NEAR
mciParseParams(
    LPCSTR lpstrParams,
    LPCSTR lpCommandList,
    LPDWORD lpdwFlags,
    LPSTR lpOutputParams,
    UINT wParamsSize,
    LPSTR FAR * FAR *lpPointerList,
    UINT FAR* lpwOpenError
    )
{
    LPSTR lpFirstCommandItem, lpCurrentCommandItem;
    UINT wArgumentPosition, wErr, wLen, wID, wDefaultID;
    DWORD dwValue, dwDefaultValue;
    BOOL bOpenCommand;
    LPSTR FAR *lpstrPointerList;
    UINT wPointers = 0;
    UINT wHeaderSize = 0;
    LPSTR lpDefaultCommandItem = NULL;
    UINT wDefaultArgumentPosition;

    if (lpwOpenError != NULL)
        *lpwOpenError = 0;

// If the parameter pointer is NULL, return
    if (lpstrParams == NULL)
    {
        DOUT ("Warning:  lpstrParams is null in mciParseParams()\r\n");
        return 0;
    }

    if ((lpstrPointerList =
         mciAlloc ((MCI_MAX_PARAM_SLOTS + 1) * sizeof (LPSTR)))
        == NULL)
    {
        *lpPointerList = NULL;
        return MCIERR_OUT_OF_MEMORY;
    }

// If this is the "open" command then allow parameter errors
    bOpenCommand = lstrcmpi (lpCommandList, szOpen) == 0;

/* Clear all the flags */
    *lpdwFlags = 0;

/* Initialize the entry for the callback message window handle */
    wHeaderSize += sizeof (DWORD);
    if (wHeaderSize > wParamsSize)
    {
        wErr = MCIERR_PARAM_OVERFLOW;
        goto error_exit;
    }

/* Skip past the header */
    lpFirstCommandItem = (LPSTR)lpCommandList +
        mciEatCommandEntry (lpCommandList, NULL, NULL);

    wLen = mciEatCommandEntry (lpFirstCommandItem, &dwValue, &wID);
/* Make room in lpdwOutputParams for the return arguments if any */
    if (wID == MCI_RETURN)
    {
        lpFirstCommandItem += wLen;
        wHeaderSize += mciGetParamSize (dwValue, wID);
        if (wHeaderSize > wParamsSize)
        {
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }
    }

    lpOutputParams += wHeaderSize;

// Scan the parameter string looking up each parameter in the given command
// list

    while (TRUE)
    {
        LPCSTR lpstrArgument = NULL;

/* Remove leading blanks */
        while (*lpstrParams == ' ') ++lpstrParams;

/* Break at end of parameter string */
        if (*lpstrParams == '\0') break;

/* Scan for this parameter in the command list */
        lpCurrentCommandItem = lpFirstCommandItem;

        wLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);

        wArgumentPosition = 0;

/* While there are more tokens in the Command List */
        while (wID != MCI_END_COMMAND)
        {
/* Check for a default argument if not already read */
            if (lpDefaultCommandItem == NULL &&
                *lpCurrentCommandItem == '\0')
            {
// Remember default argument
                lpDefaultCommandItem = lpCurrentCommandItem;
                dwDefaultValue = dwValue;
                wDefaultID = wID;
                wDefaultArgumentPosition = wArgumentPosition;
//              break;
            }
/* Check to see if this token matches */
            else if ((lpstrArgument =
                mciCheckToken (lpCurrentCommandItem, lpstrParams)) != NULL)
                break;

/* This token did not match the input but advance the argument position */
            wArgumentPosition += mciGetParamSize (dwValue, wID);

/* Go to next token */
            lpCurrentCommandItem += wLen;

// Is this command parameter a constant?
            if (wID == MCI_CONSTANT)
// Skip constant list
                do
                    lpCurrentCommandItem +=
                        mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
                while (wID != MCI_END_CONSTANT);

            wLen = mciEatCommandEntry (lpCurrentCommandItem, &dwValue, &wID);
        } /* while */

/* If there were no matches */
        if (lpstrArgument == NULL)
        {
// If a default argument exists then try it
            if (lpDefaultCommandItem != NULL)
            {
                lpstrArgument = lpstrParams;
                dwValue = dwDefaultValue;
                wID = wDefaultID;
                lpCurrentCommandItem = lpDefaultCommandItem;
                wArgumentPosition = wDefaultArgumentPosition;
            } else
            {
// Allow missing paramters on OPEN command if indicated by a non-null
// lpwOpenError address
                if (!bOpenCommand || lpwOpenError == NULL)
                {
                    wErr = MCIERR_UNRECOGNIZED_KEYWORD;
                    goto error_exit;
                } else
                {
// Skip the parameter if OPEN command
                    while (*lpstrParams != ' ' && *lpstrParams != '\0')
                        ++lpstrParams;
                    if (lpwOpenError != NULL)
                        *lpwOpenError = MCIERR_UNRECOGNIZED_KEYWORD;
                    continue;
                }
            }
        }

/* Is there room in the output buffer for this argument? */
        if (wArgumentPosition + wHeaderSize + mciGetParamSize (dwValue, wID)
            > wParamsSize)
        {
            DOUT ("mciParseParams:  parameter space overflow\r\n");
            wErr = MCIERR_PARAM_OVERFLOW;
            goto error_exit;
        }

// Remove leading blanks
        while (*lpstrArgument == ' ') ++lpstrArgument;

/* Process this parameter, filling in any flags or arguments */
        if ((wErr = mciParseArgument (dwValue, wID,
                                      &lpstrArgument, lpdwFlags,
                                      &lpOutputParams[wArgumentPosition],
                                      lpCurrentCommandItem))
            != 0)
            goto error_exit;

        lpstrParams = lpstrArgument;

        if (wID == MCI_STRING)
        {
            if (wPointers >= MCI_MAX_PARAM_SLOTS)
            {
                DOUT ("Warning: Out of pointer list slots in mciParseParams\r\n");
                break;
            }

            (DWORD)lpstrPointerList[wPointers++] =
                *(LPDWORD)&lpOutputParams[wArgumentPosition];
        }

/* Continue reading the parameter string */
    } /* while */

// Terminate list
    lpstrPointerList[wPointers] = NULL;
// Copy reference for caller
    *lpPointerList = lpstrPointerList;
// Return Success
    return 0;

error_exit:
    *lpPointerList = NULL;
// Terminate list
    lpstrPointerList[wPointers] = NULL;
    mciParserFree (lpstrPointerList);
    return wErr;
}

/*
 * @doc INTERNAL  MCI
 * @func UINT | mciParseCommand | This function converts an MCI
 * control string to an MCI control message suitable for sending to
 * <f mciSendCommand>.  The input string usually comes from <f mciSendString>
 * and always has the device name stripped off the front.
 *
 * @parm UINT | wDeviceID | Identifies the device. First searches the parsing
 * table belonging to the driver.
 * Then searches the command tables matching the type
 * of the given device.  Then searches the core command table.
 *
 * @parm LPSTR | lpstrCommand | An MCI control command without
 * a device name prefix.  There must be no leading or trailing
 * blanks.
 *
 * @parm LPCSTR | lpstrDeviceName | The device name (second token on the
 * command line).  It is used to identify the device type.
 *
 * @parm LPSTR FAR * | lpCommandList | If not NULL then the address of
 * the command list for the parsed command (if successful) is copied here.
 * It is used later by mciSendString when parsing arguments
 *
 * @parm UINT FAR* | lpwTable | The table resource ID to be unlocked
 * after parsing.  Returned to caller.
 *
 * @rdesc Returns the command ID or 0 if not found.
 *
 */
UINT PASCAL NEAR
mciParseCommand(
    UINT wDeviceID,
    LPSTR lpstrCommand,
    LPCSTR lpstrDeviceName,
    LPSTR FAR * lpCommandList,
    UINT FAR* lpwTable)
{
    LPSTR lpCommandItem;
    UINT wMessage;

// Put the command in lower case
//!!    mciToLower (lpstrCommand);

// Look up lpstrCommand in the parser's command tables.
    if ((lpCommandItem = FindCommandItem (wDeviceID, lpstrDeviceName,
                                          lpstrCommand,
                                          &wMessage, lpwTable))
        == NULL)
        return 0;

/* Return the command list to the caller */
    if (lpCommandList != NULL)
        *lpCommandList = lpCommandItem;
    else
       DOUT ("Warning: NULL lpCommandList in mciParseCommanad\r\n");

    return wMessage;
}

/*
 * @doc INTERNAL MCI
 * @func void | mciParserFree | Free any buffers allocated to
 * receive string arguments.
 *
 * @parm LPSTR FAR * | lpstrPointerList | A NULL terminated list of far
 * pointers to strings to be free'd
 *
 */
void PASCAL NEAR
mciParserFree(
    LPSTR FAR *lpstrPointerList
    )
{
    LPSTR FAR *lpstrOriginal = lpstrPointerList;

    if (lpstrPointerList == NULL)
        return;

    while (*lpstrPointerList != NULL)
        mciFree (*lpstrPointerList++);

    mciFree (lpstrOriginal);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mixmgri.h ===
//==========================================================================;
//
//  mixmgri.h
//
//  Copyright (C) 1992-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//      This header file contains INTERNAL Mixer Manager defines and stuff.
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;

#ifndef _INC_MIXMGRI
#define _INC_MIXMGRI                // #defined if file has been included

#ifndef RC_INVOKED
#pragma pack(1)                     // assume byte packing throughout
#endif

#ifndef EXTERN_C
#ifdef __cplusplus
    #define EXTERN_C extern "C"
#else
    #define EXTERN_C extern
#endif
#endif

#ifdef __cplusplus
extern "C"                          // assume C declarations for C++
{
#endif

#ifdef DEBUG
    #define RDEBUG
#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;


//
//
//
//
#ifndef FIELD_OFFSET
    #define FIELD_OFFSET(type, field)    ((LONG)&(((type *)0)->field))
#endif



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
//
//  if you change the order of the following defines, you must also fix
//  gapszMxMgrFunctions[] in idrvinit.c!
//
//  WARNING DANGER WARNING DANGER WARNING DANGER WARNING DANGER WARNING
//

enum {
        MXMGRTHUNK_GETNUMDEVS      =    0,
#ifdef WIN32
        MXMGRTHUNK_GETDEVCAPSA           ,
        MXMGRTHUNK_GETDEVCAPS            ,
#else
        MXMGRTHUNK_GETDEVCAPS            ,
#endif // WIN32
        MXMGRTHUNK_GETID                 ,
        MXMGRTHUNK_OPEN                  ,
        MXMGRTHUNK_CLOSE                 ,
        MXMGRTHUNK_MESSAGE               ,
#ifdef WIN32
        MXMGRTHUNK_GETLINEINFOA          ,
        MXMGRTHUNK_GETLINEINFO           ,
        MXMGRTHUNK_GETLINECONTROLSA      ,
        MXMGRTHUNK_GETLINECONTROLS       ,
        MXMGRTHUNK_GETCONTROLDETAILSA    ,
        MXMGRTHUNK_GETCONTROLDETAILS     ,
#else
        MXMGRTHUNK_GETLINEINFO           ,
        MXMGRTHUNK_GETLINECONTROLS       ,
        MXMGRTHUNK_GETCONTROLDETAILS     ,
#endif // WIN32
        MXMGRTHUNK_SETCONTROLDETAILS     ,
        MXMGRTHUNK_MAX_FUNCTIONS
};


extern FARPROC  gafnMxMgrFunctions[];


//
//
//
//
UINT FNGLOBAL IMixerGetNumDevs
(
    void
);

MMRESULT FNGLOBAL IMixerGetDevCaps
(
    UINT                    uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
);

#ifdef WIN32
MMRESULT FNGLOBAL IMixerGetDevCapsA
(
    UINT                    uMxId,
    LPMIXERCAPSA            pmxcaps,
    UINT                    cbmxcaps
);
#endif // WIN32

MMRESULT FNGLOBAL IMixerGetID
(
    HMIXEROBJ               hmxobj,
    UINT               FAR *puMxId,
    LPMIXERLINE             pmxl,
    DWORD                   fdwId
);

MMRESULT FNGLOBAL IMixerOpen
(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
);

MMRESULT FNGLOBAL IMixerClose
(
    HMIXER                  hmx
);

DWORD FNGLOBAL IMixerMessage
(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD                   dwParam1,
    DWORD                   dwParam2
);

MMRESULT FNGLOBAL IMixerGetLineInfo
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
);

MMRESULT FNGLOBAL IMixerGetLineControls
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
);

MMRESULT FNGLOBAL IMixerGetControlDetails
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);

#ifdef WIN32
MMRESULT FNGLOBAL IMixerGetLineInfoA
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINEA            pmxl,
    DWORD                   fdwInfo
);

MMRESULT FNGLOBAL IMixerGetLineControlsA
(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLSA    pmxlc,
    DWORD                   fdwControls
);

MMRESULT FNGLOBAL IMixerGetControlDetailsA
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);
#endif // WIN32

MMRESULT FNGLOBAL IMixerSetControlDetails
(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
);



//
//
//
//
//
BOOL FNGLOBAL IMixerUnloadDrivers
(
    HDRVR           hdrvr
);

BOOL FNGLOBAL IMixerLoadDrivers
(
    HDRVR           hdrvr
);

//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  -= Handles =-
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  No multi-thread synchronization for 16-bit
//

#define ENTER_MM_HANDLE(x) TRUE
#define LEAVE_MM_HANDLE(x)

#define MIXMGR_ENTER
#define MIXMGR_LEAVE


//
//  typedef for mxdMessage
//
typedef DWORD (CALLBACK *DRIVERMSGPROC)
(
    UINT            uId,
    UINT            uMsg,
    DWORD           dwInstance,
    DWORD           dwParam1,
    DWORD           dwParam2
);


EXTERN_C DWORD FNWCALLBACK mxdMessageHack
(
    UINT                    uDevId,
    UINT                    uMsg,
    DWORD                   dwUser,
    DWORD                   dwParam1,
    DWORD                   dwParam2
);



//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//  -= Parameter Validation =-
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

//
//  No error logging for Win32
//

#ifdef WIN32
#define LogParamError(a, b, c)
#endif // WIN32
//
//
//
BOOL FNGLOBAL ValidateReadPointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateWritePointer(const void FAR* p, DWORD len);
BOOL FNGLOBAL ValidateDriverCallback(DWORD dwCallback, UINT uFlags);
BOOL FNGLOBAL ValidateCallback(FARPROC lpfnCallback);
BOOL FNGLOBAL ValidateString(LPCSTR lsz, UINT cbMaxLen);

//
//  unless we decide differently, ALWAYS do parameter validation--even
//  in retail. this is the 'safest' thing we can do. note that we still
//  LOG parameter errors in retail (see prmvalXX).
//
#if 1

#define V_HANDLE(h, t, r)       { if (!ValidateHandle(h, t)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!ValidateReadPointer((p), (l))) return (r); }
#define V_WPOINTER(p, l, r)     { if (!ValidateWritePointer((p), (l))) return (r); }
#define V_DCALLBACK(d, w, r)    { if (!ValidateDriverCallback((d), (w))) return (r); }
#define V_CALLBACK(f, r)        { if (!ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b)) {LogParamError(ERR_BAD_DFLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) {LogParamError(ERR_BAD_FLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}

#else

#define V_HANDLE(h, t, r)       { if (!(h)) return (r); }
#define V_RPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_WPOINTER(p, l, r)     { if (!(p)) return (r); }
#define V_DCALLBACK(d, w, r)    0
#define V_CALLBACK(f, r)        { if (!(f)) return (r); }
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define V_DFLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b))  return (r); }

#endif


//
//  the DV_xxxx macros are for INTERNAL DEBUG builds--aid to debugging.
//  we do 'loose' parameter validation in retail and retail debug builds.
//
#ifdef DEBUG

#define DV_HANDLE(h, t, r)      V_HANDLE(h, t, r)
#define DV_RPOINTER(p, l, r)    V_RPOINTER(p, l, r)
#define DV_WPOINTER(p, l, r)    V_WPOINTER(p, l, r)
#define DV_DCALLBACK(d, w, r)   V_DCALLBACK(d, w, r)
#define DV_CALLBACK(f, r)       V_CALLBACK(f, r)
#define DV_STRING(s, l, r)      V_STRING(s, l, r)
#define DV_DFLAGS(t, b, f, r)   V_DFLAGS(t, b, f, r)
#define DV_FLAGS(t, b, f, r)    V_FLAGS(t, b, f, r)

#else

#define DV_HANDLE(h, t, r)      { if (!(h)) return (r); }
#define DV_RPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_WPOINTER(p, l, r)    { if (!(p)) return (r); }
#define DV_DCALLBACK(d, w, r)   0
#define DV_CALLBACK(f, r)       { if (!(f)) return (r); }
#define DV_STRING(s, l, r)      { if (!(s)) return (r); }
#define DV_DFLAGS(t, b, f, r)   { if ((t) & ~(b))  return (r); }
#define DV_FLAGS(t, b, f, r)    { if ((t) & ~(b))  return (r); }

#endif


//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;
//
//
//
//- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;

#ifndef RC_INVOKED
#pragma pack()                      // revert to default packing
#endif

#ifdef __cplusplus
}                                   // end of extern "C" {
#endif

#endif // _INC_MIXMGRI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\midi.c ===
/*****************************************************************************
    midi.c

    Level 1 kitchen sink DLL midi support module

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*****************************************************************************/
#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

/* -------------------------------------------------------------------------
** Local functions
** -------------------------------------------------------------------------
*/
static UINT NEAR PASCAL
midiGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    );

/* -------------------------------------------------------------------------
** Local structures
** -------------------------------------------------------------------------
*/
typedef struct mididev_tag {
    PMIDIDRV    mididrv;
    UINT        wDevice;
    DWORD       dwDrvUser;
    UINT        wDeviceID;
} MIDIDEV;
typedef MIDIDEV *PMIDIDEV;


/* -------------------------------------------------------------------------
** Segmentation
**
**  Define the fixed code for this file.
** -------------------------------------------------------------------------
*/
#pragma alloc_text( FIX, midiIMessage)
#pragma alloc_text( FIX, midiOMessage)
#pragma alloc_text( FIX, midiOutMessage)
#pragma alloc_text( FIX, midiOutShortMsg)
#pragma alloc_text( FIX, midiOutLongMsg)
#pragma alloc_text( FIX, midiOutReset)

/* -------------------------------------------------------------------------
** Global data
** -------------------------------------------------------------------------
*/
static  int     iMidiLockCount = 0;


/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiLockData |
 *
 *      This function is called every time a new MIDI handle is created, it
 *      makes sure MMSYSTEM's data segment is page-locked.  MIDI handles
 *      are useable at interupt time so we must page-lock the data seg.
 *
 *      in the future we should re-do the MIDI system.
 *
 ****************************************************************************/
BOOL NEAR PASCAL
midiLockData(
    void
    )
{
    if (iMidiLockCount == 0) {

        DOUT("MMSYSTEM: Locking data segment\r\n");

        if ( !GlobalPageLock((HGLOBAL)HIWORD((DWORD)(LPVOID)&iMidiLockCount))
          && (WinFlags & WF_ENHANCED)) {

            return 0;
        }
    }

    return ++iMidiLockCount;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api void | midiUnlockData |
 *
 *      This function is called every time a MIDI handle is closed, it
 *      makes sure MMSYSTEM's data segment is un-page-locked.  MIDI handles
 *      are useable at interupt time so we must page-lock the data seg.
 *
 *      in the future we should re-do the MIDI system.
 *
 ****************************************************************************/
void NEAR PASCAL
midiUnlockData(
    void
    )
{

#ifdef DEBUG
    if (iMidiLockCount == 0)
        DOUT("MMSYSTEM: midiUnlockData() underflow!!!!\r\n");
#endif

    if (--iMidiLockCount == 0) {

        DOUT("MMSYSTEM: Unlocking data segment\r\n");
        GlobalPageUnlock((HGLOBAL)HIWORD((DWORD)(LPVOID)&iMidiLockCount));
    }
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api UINT | midiPrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
midiPrepareHeader(
    LPMIDIHDR lpMidiHdr,
    UINT wSize
    )
{
    if (!HugePageLock(lpMidiHdr, (DWORD)sizeof(MIDIHDR)))
        return MMSYSERR_NOMEM;

    if (!HugePageLock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength)) {
        HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));
        return MMSYSERR_NOMEM;
    }

//  lpMidiHdr->dwFlags |= MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  MIDI
 *
 * @api UINT | midiUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
midiUnprepareHeader(
    LPMIDIHDR lpMidiHdr,
    UINT wSize
    )
{
    HugePageUnlock(lpMidiHdr->lpData, lpMidiHdr->dwBufferLength);
    HugePageUnlock(lpMidiHdr, (DWORD)sizeof(MIDIHDR));

//  lpMidiHdr->dwFlags &= ~MHDR_PREPARED;

    return MMSYSERR_NOERROR;
}



/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetNumDevs | This function retrieves the number of MIDI
 *   output devices present in the system.
 *
 * @rdesc Returns the number of MIDI output devices present in the system.
 *
 * @xref midiOutGetDevCaps
 ****************************************************************************/
UINT WINAPI midiOutGetNumDevs(void)
{
    return midiOIDMessage( 0, MODM_GETNUMDEVS, 0L, 0L, 0L );
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api DWORD | midiOutMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIOUT | hMidiOut | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
DWORD WINAPI midiOutMessage(HMIDIOUT hMidiOut, UINT msg, DWORD dw1, DWORD dw2)
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, 0L);

    return midiOMessage( (HMIDI)hMidiOut, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetDevCaps | This function queries a specified
 *   MIDI output device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm LPMIDIOUTCAPS | lpCaps | Specifies a far pointer to a <t MIDIOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *   @flag MMSYSERR_NOMEM | Unable load mapper string description.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiOutGetNumDevs
 ****************************************************************************/
UINT WINAPI
midiOutGetDevCaps(
    UINT wDeviceID,
    LPMIDIOUTCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return midiOIDMessage( wDeviceID,
                          MODM_GETDEVCAPS, 0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutGetVolume | This function returns the current volume
 *   setting of a MIDI output device.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location
 *   to be filled with the current volume setting. The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   WORD contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f midiOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume control. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 * @xref midiOutSetVolume
 ****************************************************************************/
UINT WINAPI
midiOutGetVolume(
    UINT wDeviceID,
    LPDWORD lpdwVolume
    )
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_GETVOLUME,
                                 (DWORD)lpdwVolume,
                                 0));
    }

    return midiOIDMessage( wDeviceID, MODM_GETVOLUME, 0L, (DWORD)lpdwVolume, 0 );
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutSetVolume | This function sets the volume of a
 *      MIDI output device.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.
 *   The low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of <p dwVolume> specifies the volume
 *   level, and the high-order word is ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the MIDICAPS_VOLUME
 *   flag to test the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the MIDICAPS_LRVOLUME flag to test
 *   the <e MIDIOUTCAPS.dwSupport> field of the <t MIDIOUTCAPS>
 *   structure (filled by <f midiOutGetDevCaps>).
 *
 *   Most devices do not support the full 16 bits of volume level control
 *   and will use only the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be will
 *   all produce the same physical volume setting, 0x4000. The
 *   <f midiOutGetVolume> function will return the full 16-bit setting set
 *   with <f midiOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref midiOutGetVolume
 ****************************************************************************/
UINT WINAPI
midiOutSetVolume(
    UINT wDeviceID,
    DWORD dwVolume
    )
{
    if (ValidateHandle((HMIDIOUT)wDeviceID, TYPE_MIDIOUT)) {
       return((UINT)midiOMessage((HMIDI)wDeviceID,
                                 MODM_SETVOLUME,
                                 dwVolume,
                                 0));
    }

    return midiOIDMessage( wDeviceID, MODM_SETVOLUME, 0L, dwVolume, 0);
}

/*****************************************************************************
 * @doc INTERNAL MIDI
 *
 * @func UINT | midiGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.
 ****************************************************************************/
static UINT NEAR PASCAL
midiGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if ( ((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR))
      && ((wError < MIDIERR_BASE) || (wError > MIDIERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#else
    if ((wError > MMSYSERR_LASTERROR) && ((wError < MIDIERR_BASE)
     || (wError > MIDIERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#endif

    if (wSize > 1) {

        if (!LoadString(ghInst, wError, lpText, wSize)) {
            return MMSYSERR_BADERRNUM;
        }
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the
 *   function returns MMSYSERR_NOERROR.  All error descriptions are
 *   less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
midiOutGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if(wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutOpen | This function opens a specified MIDI
 *   output device for playback.
 *
 * @parm LPHMIDIOUT | lphMidiOut | Specifies a far pointer to an HMIDIOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   MIDI output device.  Use the handle to identify the device when calling
 *   other MIDI output functions.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI output device that is
 *   to be opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or
 *   a handle to a window called during MIDI playback to process
 *   messages related to the progress of the playback.  Specify NULL
 *   for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are as follows:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag MIDIERR_NOMAP | There is no current MIDI map. This occurs only
 *   when opening the mapper.
 *   @flag MIDIERR_NODEVICE | A port in the current MIDI map doesn't exist.
 *   This occurs only when opening the mapper.
 *
 * @comm Use <f midiOutGetNumDevs> to determine the number of MIDI output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   You may also specify MIDI_MAPPER as the device ID to open the MIDI mapper.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI output:  <m MM_MOM_OPEN>, <m MM_MOM_CLOSE>,
 *   <m MM_MOM_DONE>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   output: <m MOM_OPEN>, <m MOM_CLOSE>, <m MOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to
 *   get a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiOutFunc | <f MidiOutFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's
 *   module-definition file.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a MIDI output message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data
 *   supplied with <f midiOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiOutClose
 ****************************************************************************/
UINT WINAPI
midiOutOpen(
    LPHMIDIOUT lphMidiOut,
    UINT wDeviceID,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    UINT         wRet;

    V_WPOINTER(lphMidiOut, sizeof(HMIDIOUT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), 0, midiOutOpen, MMSYSERR_INVALFLAG);

    /*
    ** Check for no devices
    */
//  if (wTotalMidiOutDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != MIDI_MAPPER ) {
//      if ( wDeviceID >= wTotalMidiOutDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    *lphMidiOut = NULL;

    if (!midiLockData()) {
        return MMSYSERR_NOMEM;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIOUT, sizeof(MIDIDEV));
    if( pdev == NULL) {
        return MMSYSERR_NOMEM;
    }

    pdev->wDevice = wDeviceID;
    pdev->wDeviceID = wDeviceID;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;

    wRet = midiOIDMessage( wDeviceID, MODM_OPEN,
                          (DWORD)(LPDWORD)&pdev->dwDrvUser,
                          (DWORD)(LPMIDIOPENDESC)&mo, dwFlags );

    if (wRet) {
        FreeHandle((HMIDIOUT)pdev);
        midiUnlockData();
    } else {
        *lphMidiOut = (HMIDIOUT)pdev;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutClose | This function closes the specified MIDI
 *   output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are output buffers that have been sent with
 *   <f midiOutLongMsg> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiOutReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiOutOpen midiOutReset
 ****************************************************************************/
UINT WINAPI
midiOutClose(
    HMIDIOUT hMidiOut
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

    wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_CLOSE, 0L,0L);
    if (!wRet) {
        FreeHandle(hMidiOut);
        midiUnlockData();
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutPrepareHeader | This function prepares a MIDI
 *   system-exclusive data block for output.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref midiOutUnprepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutPrepareHeader(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (lpMidiOutHdr->dwFlags & MHDR_PREPARED) {
        return MMSYSERR_NOERROR;
    }

    lpMidiOutHdr->dwFlags = 0;

    wRet = midiPrepareHeader(lpMidiOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_PREPARE,
                                  (DWORD)lpMidiOutHdr, (DWORD)wSize );
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutUnprepareHeader | This function cleans up the
 * preparation performed by <f midiOutPrepareHeader>. The
 * <f midiOutUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f midiOutPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiOutLongMsg>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiOutUnprepareHeader>.
 *
 * Unpreparing a buffer that has not been
 * prepared has no effect, and the function returns zero.
 *
 * @xref midiOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutUnprepareHeader(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED)) {
        return MMSYSERR_NOERROR;
    }

    if(lpMidiOutHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr( DBF_WARNING,
                  "midiOutUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }

    wRet = midiUnprepareHeader(lpMidiOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_UNPREPARE,
                                  (DWORD)lpMidiOutHdr, (DWORD)wSize );
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutShortMsg | This function sends a short MIDI message to
 *   the specified MIDI output device.  Use this function to send any MIDI
 *   message except for system-exclusive messages.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm DWORD | dwMsg | Specifies the MIDI message.  The message is packed
 *   into a DWORD with the first byte of the message in the low-order byte.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm This function may not return until the message has been sent to the
 *   output device.
 *
 * @xref midiOutLongMsg
 ****************************************************************************/
UINT WINAPI
midiOutShortMsg(
    HMIDIOUT hMidiOut,
    DWORD dwMsg
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_DATA, dwMsg, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutLongMsg | This function sends a system-exclusive
 *   MIDI message to the specified MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiOutHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the MIDI data buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiOutHdr> hasn't been prepared.
 *   @flag MIDIERR_NOTREADY | The hardware is busy with other data.
 *
 * @comm The data buffer must be prepared with <f midiOutPrepareHeader>
 *   before it is passed to <f midiOutLongMsg>.  The <t MIDIHDR> data
 *   structure and the data buffer pointed to by its <e MIDIHDR.lpData>
 *   field must be allocated with <f GlobalAlloc> using the GMEM_MOVEABLE
 *   and GMEM_SHARE flags, and locked with <f GlobalLock>. The MIDI output
 *   device driver determines whether the data is sent synchronously or
 *   asynchronously.
 *
 * @xref midiOutShortMsg midiOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiOutLongMsg(
    HMIDIOUT hMidiOut,
    LPMIDIHDR lpMidiOutHdr,
    UINT wSize
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);

//
// we can't call these at interupt time.
//
#pragma message("header not validated for midiOutLongMessage")
////V_HEADER(lpMidiOutHdr, wSize, TYPE_MIDIOUT, MMSYSERR_INVALPARAM);

    if ( HIWORD(lpMidiOutHdr) == 0 ) {
        return MMSYSERR_INVALPARAM;
    }

    if ( wSize != sizeof(MIDIHDR) ) {
        return MMSYSERR_INVALPARAM;
    }

    if (LOWORD(lpMidiOutHdr->dwFlags) & ~MHDR_VALID) {
        return MMSYSERR_INVALFLAG;
    }

    if (!(lpMidiOutHdr->dwFlags & MHDR_PREPARED)) {
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiOutHdr->dwFlags & MHDR_INQUEUE) {
        return MIDIERR_STILLPLAYING;
    }

    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_LONGDATA,
                              (DWORD)lpMidiOutHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutReset | This function turns off all notes on all MIDI
 *   channels for the specified MIDI output device. Any pending
 *   system-exclusive output buffers are marked as done and
 *   returned to the application.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the MIDI output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm To turn off all notes, a note-off message for each note for each
 *   channel is sent. In addition, the sustain controller is turned off for
 *   each channel.
 *
 * @xref midiOutLongMsg midiOutClose
 ****************************************************************************/
UINT WINAPI
midiOutReset(
    HMIDIOUT hMidiOut
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    return (UINT)midiOMessage( (HMIDI)hMidiOut, MODM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutCachePatches | This function requests that an internal
 *   MIDI synthesizer device preload a specified set of patches. Some
 *   synthesizers are not capable of keeping all patches loaded simultaneously
 *   and must load data from disk when they receive MIDI program change
 *   messages. Caching patches ensures specified patches are immediately
 *   available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device must be an internal MIDI synthesizer.
 *
 * @parm UINT | wBank | Specifies which bank of patches should be used.
 *   This parameter should be set to zero to cache the default patch bank.
 *
 * @parm WORD FAR* | lpPatchArray | Specifies a pointer to a <t PATCHARRAY>
 *   array indicating the patches to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t PATCHARRAY> array,
 *         and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t PATCHARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t PATCHARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *         <t PATCHARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t PATCHARRAY> data type is defined as:
 *
 *   typedef WORD PATCHARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 patches and
 *   has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15 (0x0F). For
 *   example, if patch 0 is used by physical channels 0 and 8, element 0
 *   would be set to 0x0101.
 *
 *   This function only applies to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCacheDrumPatches
 ****************************************************************************/
UINT WINAPI
midiOutCachePatches(
    HMIDIOUT hMidiOut,
    UINT wBank,
    WORD FAR* lpPatchArray,
    UINT wFlags
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpPatchArray, sizeof(PATCHARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCachePatches, MMSYSERR_INVALFLAG);

    return (UINT)midiOMessage( (HMIDI)hMidiOut,
                              MODM_CACHEPATCHES, (DWORD)lpPatchArray,
                              MAKELONG(wFlags, wBank) );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiOutCacheDrumPatches | This function requests that an
 *   internal MIDI synthesizer device preload a specified set of key-based
 *   percussion patches. Some synthesizers are not capable of keeping all
 *   percussion patches loaded simultaneously. Caching patches ensures
 *   specified patches are available.
 *
 * @parm HMIDIOUT | hMidiOut | Specifies a handle to the opened MIDI output
 *   device. This device should be an internal MIDI synthesizer.
 *
 * @parm UINT | wPatch | Specifies which drum patch number should be used.
 *   This parameter should be set to zero to cache the default drum patch.
 *
 * @parm WORD FAR* | lpKeyArray | Specifies a pointer to a <t KEYARRAY>
 *   array indicating the key numbers of the specified percussion patches
 *  to be cached or uncached.
 *
 * @parm UINT | wFlags | Specifies options for the cache operation. Only one
 *   of the following flags can be specified:
 *      @flag MIDI_CACHE_ALL | Cache all of the specified patches. If they
 *         can't all be cached, cache none, clear the <t KEYARRAY> array,
 *       and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_BESTFIT | Cache all of the specified patches.
 *         If all patches can't be cached, cache as many patches as
 *         possible, change the <t KEYARRAY> array to reflect which
 *         patches were cached, and return MMSYSERR_NOMEM.
 *      @flag MIDI_CACHE_QUERY | Change the <t KEYARRAY> array to indicate
 *         which patches are currently cached.
 *      @flag MIDI_UNCACHE | Uncache the specified patches and clear the
 *       <t KEYARRAY> array.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   one of the following error codes:
 *      @flag MMSYSERR_INVALHANDLE | The specified device handle is invalid.
 *      @flag MMSYSERR_NOTSUPPORTED | The specified device does not support
 *          patch caching.
 *      @flag MMSYSERR_NOMEM | The device does not have enough memory to cache
 *          all of the requested patches.
 *
 * @comm The <t KEYARRAY> data type is defined as:
 *
 *   typedef WORD KEYARRAY[MIDIPATCHSIZE];
 *
 *   Each element of the array represents one of the 128 key-based percussion
 *   patches and has bits set for
 *   each of the 16 MIDI channels that use that particular patch. The
 *   least-significant bit represents physical channel 0; the
 *   most-significant bit represents physical channel 15. For
 *   example, if the patch on key number 60 is used by physical channels 9
 *       and 15, element 60 would be set to 0x8200.
 *
 *       This function applies only to internal MIDI synthesizer devices.
 *   Not all internal synthesizers support patch caching. Use the
 *   MIDICAPS_CACHE flag to test the <e MIDIOUTCAPS.dwSupport> field of the
 *   <t MIDIOUTCAPS> structure filled by <f midiOutGetDevCaps> to see if the
 *   device supports patch caching.
 *
 * @xref midiOutCachePatches
 ****************************************************************************/
UINT WINAPI
midiOutCacheDrumPatches(
    HMIDIOUT hMidiOut,
    UINT wPatch,
    WORD FAR* lpKeyArray,
    UINT wFlags
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpKeyArray, sizeof(KEYARRAY), MMSYSERR_INVALPARAM);
    V_FLAGS(wFlags, MIDI_CACHE_VALID, midiOutCacheDrumPatches, MMSYSERR_INVALFLAG);

    return (UINT)midiOMessage( (HMIDI)hMidiOut,
                               MODM_CACHEDRUMPATCHES, (DWORD)lpKeyArray,
                               MAKELONG(wFlags, wPatch) );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetNumDevs | This function retrieves the number of MIDI
 *   input devices in the system.
 *
 * @rdesc Returns the number of MIDI input devices present in the system.
 *
 * @xref midiInGetDevCaps
 ****************************************************************************/
UINT WINAPI
midiInGetNumDevs(
    void
    )
{
    return midiIIDMessage( 0, MIDM_GETNUMDEVS, 0L, 0L, 0L );
}

/****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api DWORD | midiInMessage | This function sends messages to the MIDI device
 *   drivers.
 *
 * @parm HMIDIIN | hMidiIn | The handle to the MIDI device.
 *
 * @parm UINT  | msg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value of the message sent.
 ***************************************************************************/
DWORD WINAPI
midiInMessage(
    HMIDIIN hMidiIn,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, 0L);

    return midiIMessage( (HMIDI)hMidiIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetDevCaps | This function queries a specified MIDI input
 *    device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI input device.
 *
 * @parm LPMIDIINCAPS | lpCaps | Specifies a far pointer to a <t MIDIINCAPS>
 *   data structure.  This structure is filled with information about
 *   the capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied,
 *   and the function returns zero.
 *
 * @xref midiInGetNumDevs
 ****************************************************************************/
UINT WINAPI
midiInGetDevCaps(
    UINT wDeviceID,
    LPMIDIINCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
         return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HMIDIIN)wDeviceID, TYPE_MIDIIN)) {
       return((UINT)midiIMessage((HMIDIIN)wDeviceID,
                                 MIDM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return midiIIDMessage( wDeviceID,
                          MIDM_GETDEVCAPS, 0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 * the description is truncated.  The returned error string is always
 * null-terminated. If <p wSize> is zero, nothing is copied, and
 * the function returns zero. All error descriptions are
 * less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
midiInGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if(wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return midiGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInOpen | This function opens a specified MIDI input device.
 *
 * @parm LPHMIDIIN | lphMidiIn | Specifies a far pointer to an HMIDIIN handle.
 *   This location is filled with a handle identifying the opened MIDI
 *   input device.  Use the handle to identify the device when calling
 *   other MIDI input functions.
 *
 * @parm UINT | wDeviceID | Identifies the MIDI input device to be
 *   opened.
 *
 * @parm DWORD | dwCallback | Specifies the address of a fixed callback
 *   function or a handle to a window called with information
 *   about incoming MIDI messages.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback function.  This parameter is not
 *   used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies a callback flag for opening the device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm Use <f midiInGetNumDevs> to determine the number of MIDI input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The MIDI_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of MIDI input:  <m MM_MIM_OPEN>, <m MM_MIM_CLOSE>,
 *   <m MM_MIM_DATA>, <m MM_MIM_LONGDATA>, <m MM_MIM_ERROR>,
 *   <m MM_MIM_LONGERROR>.
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of MIDI
 *   input:  <m MIM_OPEN>, <m MIM_CLOSE>, <m MIM_DATA>, <m MIM_LONGDATA>,
 *   <m MIM_ERROR>, <m MIM_LONGERROR>.  The callback function must reside in
 *   a DLL.  You do not have to use <f MakeProcInstance> to get a
 *   procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | MidiInFunc | <f MidiInFunc> is a placeholder for
 *   the application-supplied function name.  The actual name must be
 *   exported by including it in an EXPORTS statement in the DLL's module
 *   definition file.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm UINT | wMsg | Specifies a MIDI input message.
 *
 * @parm DWORD | dwInstance | Specifies the instance data supplied
 *      with <f midiInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL, and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref midiInClose
 ****************************************************************************/
UINT WINAPI
midiInOpen(
    LPHMIDIIN lphMidiIn,
    UINT wDeviceID,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    MIDIOPENDESC mo;
    PMIDIDEV     pdev;
    UINT         wRet;

    V_WPOINTER(lphMidiIn, sizeof(HMIDIIN), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), 0, midiInOpen, MMSYSERR_INVALFLAG);

    /*
    ** Check for no devices
    */
//  if (wTotalMidiInDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != MIDI_MAPPER ) {
//      if ( wDeviceID >= wTotalMidiInDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    *lphMidiIn = NULL;

    if (!midiLockData()) {
        return MMSYSERR_NOMEM;
    }

    pdev = (PMIDIDEV)NewHandle(TYPE_MIDIIN, sizeof(MIDIDEV));
    if( pdev == NULL) {
        return MMSYSERR_NOMEM;
    }

    pdev->wDevice = wDeviceID;
    pdev->wDeviceID = wDeviceID;

    mo.hMidi      = (HMIDI)pdev;
    mo.dwCallback = dwCallback;
    mo.dwInstance = dwInstance;

    wRet = midiIIDMessage( wDeviceID, MIDM_OPEN,
                          (DWORD)(LPDWORD)&pdev->dwDrvUser,
                          (DWORD)(LPMIDIOPENDESC)&mo, dwFlags );

    if (wRet) {
        FreeHandle((HMIDIIN)pdev);
        midiUnlockData();
    } else {
        *lphMidiIn = (HMIDIIN)pdev;
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInClose | This function closes the specified MIDI input
 *   device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f midiInAddBuffer> and haven't been returned to the application,
 *   the close operation will fail.  Call <f midiInReset> to mark all
 *   pending buffers as being done.
 *
 * @xref midiInOpen midiInReset
 ****************************************************************************/
UINT WINAPI
midiInClose(
    HMIDIIN hMidiIn
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_CLOSE, 0L, 0L);

    if (!wRet) {
        FreeHandle(hMidiIn);
        midiUnlockData();
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInPrepareHeader | This function prepares a buffer for
 *   MIDI input.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a pointer to a <t MIDIHDR>
 *   structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t MIDIHDR> data structure and the data block pointed to by its
 *   <e MIDIHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect,
 *   and the function returns zero.
 *
 * @xref midiInUnprepareHeader
 ****************************************************************************/
UINT WINAPI
midiInPrepareHeader(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (lpMidiInHdr->dwFlags & MHDR_PREPARED) {
        return MMSYSERR_NOERROR;
    }

    lpMidiInHdr->dwFlags = 0;

    wRet = midiPrepareHeader(lpMidiInHdr, wSize);
    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_PREPARE,
                                  (DWORD)lpMidiInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInUnprepareHeader | This function cleans up the
 * preparation performed by <f midiInPrepareHeader>. The
 * <f midiInUnprepareHeader> function must be called
 * after the device driver fills a data buffer and returns it to the
 * application. You must call this function before freeing the data
 * buffer.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input
 *   device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr |  Specifies a pointer to a <t MIDIHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_STILLPLAYING | <p lpMidiInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f midiInPrepareHeader>.
 * You must call this function before freeing the data buffer with
 * <f GlobalFree>.
 * After passing a buffer to the device driver with <f midiInAddBuffer>, you
 * must wait until the driver is finished with the buffer before calling
 * <f midiInUnprepareHeader>.  Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref midiInPrepareHeader
 ****************************************************************************/
UINT WINAPI
midiInUnprepareHeader(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED)) {
        return MMSYSERR_NOERROR;
    }

    if(lpMidiInHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr( DBF_WARNING,
                  "midiInUnprepareHeader: header still in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }


    wRet = midiUnprepareHeader(lpMidiInHdr, wSize);
    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_UNPREPARE,
                                   (DWORD)lpMidiInHdr, (DWORD)wSize);
    }
    return wRet;
}

/******************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInAddBuffer | This function sends an input buffer
 *   to a specified opened MIDI input device.  When the buffer is filled,
 *   it is sent back to the application.  Input buffers are
 *   used only for system-exclusive messages.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @parm LPMIDIHDR | lpMidiInHdr | Specifies a far pointer to a <t MIDIHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t MIDIHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MIDIERR_UNPREPARED | <p lpMidiInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f midiInPrepareHeader> before
 *   it is passed to <f midiInAddBuffer>.  The <t MIDIHDR> data structure
 *   and the data buffer pointed to by its <e MIDIHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref midiInPrepareHeader
 *****************************************************************************/
UINT WINAPI
midiInAddBuffer(
    HMIDIIN hMidiIn,
    LPMIDIHDR lpMidiInHdr,
    UINT wSize
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpMidiInHdr, wSize, TYPE_MIDIIN, MMSYSERR_INVALPARAM);

    if (!(lpMidiInHdr->dwFlags & MHDR_PREPARED)) {
        DebugErr(DBF_WARNING, "midiInAddBuffer: buffer not prepared\r\n");
        return MIDIERR_UNPREPARED;
    }

    if (lpMidiInHdr->dwFlags & MHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "midiInAddBuffer: buffer already in queue\r\n");
        return MIDIERR_STILLPLAYING;
    }

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_ADDBUFFER,
                              (DWORD)lpMidiInHdr, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInStart | This function starts MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm This function resets the timestamps to zero; timestamp values for
 *   subsequently received messages are relative to the time this
 *   function was called.
 *
 *   All messages other than system-exclusive messages are sent
 *   directly to the client when received. System-exclusive
 *   messages are placed in the buffers supplied by <f midiInAddBuffer>;
 *   if there are no buffers in the queue,
 *   the data is thrown away without notification to the client, and input
 *   continues.
 *
 *   Buffers are returned to the client when full, when a
 *   complete system-exclusive message has been received,
 *   or when <f midiInReset> is
 *   called. The <e MIDIHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data received.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref midiInStop midiInReset
 ****************************************************************************/
UINT WINAPI
midiInStart(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInStop | This function terminates MIDI input on the
 *   specified MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Current status (running status, parsing state, etc.) is maintained
 *   across calls to <f midiInStop> and <f midiInStart>.
 *   If there are any system-exclusive message buffers in the queue,
 *   the current buffer
 *   is marked as done (the <e MIDIHDR.dwBytesRecorded> field in the header will
 *   contain the actual length of data), but any empty buffers in the queue
 *   remain there.  Calling this function when input is not started has no
 *   no effect, and the function returns zero.
 *
 * @xref midiInStart midiInReset
 ****************************************************************************/
UINT WINAPI
midiInStop(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_STOP, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  MIDI
 *
 * @api UINT | midiInReset | This function stops input on a given MIDI
 *  input device and marks all pending input buffers as done.
 *
 * @parm HMIDIIN | hMidiIn | Specifies a handle to the MIDI input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref midiInStart midiInStop midiInAddBuffer midiInClose
 ****************************************************************************/
UINT WINAPI
midiInReset(
    HMIDIIN hMidiIn
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);

    return (UINT)midiIMessage( (HMIDI)hMidiIn, MIDM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiInGetID | This function gets the device ID for a
 * MIDI input device.
 *
 * @parm HMIDIIN | hMidiIn     | Specifies the handle to the MIDI input
 * device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
midiInGetID(
    HMIDIIN hMidiIn,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hMidiIn, TYPE_MIDIIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PMIDIDEV)hMidiIn)->wDeviceID;
    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL MIDI
 *
 * @api UINT | midiOutGetID | This function gets the device ID for a
 * MIDI output device.
 *
 * @parm HMIDIOUT | hMidiOut    | Specifies the handle to the MIDI output
 * device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized
 * memory location to be filled with the device ID.
 *
 * @rdesc Returns MMSYSERR_NOERROR if successful. Otherwise, returns
 * an error number. Possible error returns are:
 *
 * @flag MMSYSERR_INVALHANDLE | The <p hMidiOut> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
midiOutGetID(
    HMIDIOUT hMidiOut,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hMidiOut, TYPE_MIDIOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PMIDIDEV)hMidiOut)->wDeviceID;
    return MMSYSERR_NOERROR;
}

#if 0
/*****************************Private*Routine******************************\
* midiIDMessage
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT FAR PASCAL
midiIDMessage(
    LPSOUNDDEVMSGPROC lpProc,
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    return CallProc32W( (DWORD)wDeviceID, (DWORD)wMessage,
                        dwUser, dwParam1, dwParam2, lpProc, 0L, 5L );
}
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mixer.c ===
//==========================================================================;
//
//  mixapi.c
//
//  Copyright (C) 1992-1993 Microsoft Corporation.  All Rights Reserved.
//
//  Description:
//
//
//  History:
//       6/27/93    cjp     [curtisp]
//
//==========================================================================;
#define _WINDLL
#include <windows.h>
#include <windowsx.h>
#include <string.h>

#include <mmsystem.h>
#include <mmddk.h>

#include "mmreg.h"
#include "mmsysi.h"

//
//  fix a conflict will a bad define in MMREG.H that shipped with NT
//  the define is bad for some Media Vision things...
//
//  why not just build MSMIXMGR with a NEW mmreg.h??
//
#ifdef MIXERR_BASE
#undef MIXERR_BASE
#endif // MIXERR_BASE


#define _INC_MMDDK
#include "msmixmgr.y"


#define WODM_MAPPER_STATUS                  (0x2000)
#define WAVEOUT_MAPPER_STATUS_DEVICE        0
#define WIDM_MAPPER_STATUS                  (0x2000)
#define WAVEIN_MAPPER_STATUS_DEVICE         0

#include "idrv.h"
#include "mixmgri.h"
#include "debug.h"

UINT FAR PASCAL
mmCallProc32(
    DWORD uId,
    DWORD uMsg,
    DWORD dwInst,
    DWORD dwP1,
    DWORD dwP2,
    DRIVERMSGPROC fp,
    DWORD dwDirChange );

/* -------------------------------------------------------------------------
**  thunking global variables
** -------------------------------------------------------------------------
*/
DWORD   mix32Lib;

BOOL FAR PASCAL
InitMixerThunks(
    void
    );

DWORD CALLBACK
mxdMessage(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    );

#define CHECK_AND_INIT_THUNKS( _x_ )            \
    if ( (_x_) == 0L ) {            \
        if ( InitMixerThunks() == FALSE ) {     \
            return MMSYSERR_NODRIVER;           \
        }                                       \
    }

UINT guTotalMixerDevs;              // total mixer devices
DRIVERMSGPROC mix32Message;
typedef MMDRV MIXERDRV, *PMIXERDRV;


//
//
//
typedef struct tMIXERDEV {
    UINT                uHandleType;    // for parameter validation

    struct tMIXERDEV   *pmxdevNext;     /* How quaint, a linked list... */
    PMIXERDRV           pmxdrv;
    UINT                wDevice;
    DWORD               dwDrvUser;
    UINT                uDeviceID;

    DWORD               fdwSupport;     // from the driver's mixercaps
    DWORD               cDestinations;  // from the driver's mixercaps

    DWORD               dwCallback;     // client's callback and inst data
    DWORD               dwInstance;

    DWORD               fdwOpen;        /* The open flags the caller used */
} MIXERDEV, *PMIXERDEV;

PMIXERDEV gpMixerDevHeader = NULL;      /* A LL of open devices */

//
//  mixer device driver list--add one to accomodate the MIXER_MAPPER. note
//  that even if we are not compiling with mapper support we need to add
//  one because other code relies on it (for other device mappers).
//
MIXERDRV        mixerdrv[1];




//==========================================================================;
//
//  Mixer API's
//
//
//==========================================================================;

//--------------------------------------------------------------------------;
//
//  DWORD IMixerMapId
//
//  Description:
//      This function maps a logical id to a device driver table index and
//      physical id.
//
//  Arguments:
//      PMIXERDRV pmxdrv: The array of mixer drivers.
//
//      UINT uTotalNumDevs: The total number of mixer devices.
//
//      UINT uId: The logical id to be mapped.
//
//  Return (DWORD):
//      The return value contains the dev[] array element id in the high word
//      and the driver physical device number in the low word.
//
//      Out of range values map to FFFF:FFFF
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMapId(
    PMIXERDRV       pmxdrv,
    UINT            uTotalNumDevs,
    UINT            uId
)
{
    UINT    u;

#ifdef MIXER_MAPPER
    //
    //  the mapper is always the last element of the MIXERDEV array.
    //
    if (uId == MIXER_MAPPER)
        return (MAKELONG(0, MAXMIXERDRIVERS));
#endif

    if (uId >= uTotalNumDevs)
        return ((DWORD)-1);

#ifdef DEBUG_RETAIL
    if (fIdReverse)
        uId = uTotalNumDevs - 1 - uId;
#endif

    for (u = 0; u < MAXMIXERDRIVERS; u++)
    {
        if (pmxdrv[u].bNumDevs > (BYTE)uId)
            return (MAKELONG(uId, u));

        uId -= pmxdrv[u].bNumDevs;
    }

    return ((DWORD)-1);
} // IMixerMapId()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageHandle
//
//  Description:
//
//
//  Arguments:
//      HMIXER hmx:
//
//      UINT uMsg:
//
//      DWORD dwP1:
//
//      DWORD dwP2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageHandle(
    HMIXER          hmx,
    UINT            uMsg,
    DWORD           dwP1,
    DWORD           dwP2
)
{
    PMIXERDEV   pmxd;
    DWORD       dwRc;

    pmxd = (PMIXERDEV)hmx;

    dwRc = ((*(pmxd->pmxdrv->drvMessage))
             (pmxd->wDevice, uMsg, pmxd->dwDrvUser, dwP1, dwP2));

    return dwRc;
} // IMixerMessageHandle()


//--------------------------------------------------------------------------;
//
//  DWORD IMixerMessageId
//
//  Description:
//
//
//  Arguments:
//      PMIXERDRV pmxdrv:
//
//      UINT uTotalNumDevs:
//
//      UINT uDeviceID:
//
//      UINT uMsg:
//
//      DWORD dwParam1:
//
//      DWORD dwParam2:
//
//  Return (DWORD):
//
//  History:
//      03/17/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

DWORD NEAR PASCAL IMixerMessageId(
    PMIXERDRV       pmxdrv,
    UINT            uTotalNumDevs,
    UINT            uDeviceID,
    UINT            uMsg,
    DWORD           dwParam1,
    DWORD           dwParam2
)
{
    DWORD   dwMap;
    DWORD   dwRc;

    dwMap = IMixerMapId(pmxdrv, uTotalNumDevs, uDeviceID);

    if (dwMap == (DWORD)-1)
        return (MMSYSERR_BADDEVICEID);

    pmxdrv = (PMIXERDRV)&pmxdrv[HIWORD(dwMap)];
    if (!pmxdrv->drvMessage)
        return (MMSYSERR_NODRIVER);

    dwRc = ((*(pmxdrv->drvMessage))
            ((UINT)dwMap, uMsg, 0L, dwParam1, dwParam2));

    return dwRc;

} // IMixerMessageId()

/******************************Public*Routine******************************\
* mixerGetNumDevs
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT MIXAPI mixerGetNumDevs(
    void
)
{

    CHECK_AND_INIT_THUNKS(mix32Lib);

    return guTotalMixerDevs;
}



/******************************Public*Routine******************************\
* mixerGetDevCaps
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetDevCaps(
    UINT                    uMxId,
    LPMIXERCAPS             pmxcaps,
    UINT                    cbmxcaps
)
{

    MMRESULT mmr;
    CHECK_AND_INIT_THUNKS(mix32Lib);

    if (0 == cbmxcaps)
        return (MMSYSERR_NOERROR);

    V_WPOINTER(pmxcaps, cbmxcaps, MMSYSERR_INVALPARAM);

    if (uMxId >= MAXMIXERDRIVERS)
    {
        V_HANDLE((HMIXER)uMxId, TYPE_MIXER, MMSYSERR_INVALHANDLE);

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)uMxId,
                                           MXDM_GETDEVCAPS,
                                           (DWORD)pmxcaps,
                                           (DWORD)cbmxcaps);
    }
    else
    {
        if (uMxId >= guTotalMixerDevs)
        {
            DebugErr1(DBF_ERROR, "mixerGetDevCaps: mixer device id is out of range (%u).", uMxId);
            return (MMSYSERR_BADDEVICEID);
        }

        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                       guTotalMixerDevs,
                                       uMxId,
                                       MXDM_GETDEVCAPS,
                                       (DWORD)pmxcaps,
                                       (DWORD)cbmxcaps);
    }
    return mmr;
}



/******************************Public*Routine******************************\
* mixerGetID
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetID(
    HMIXEROBJ               hmxobj,
    UINT               FAR *puMxId,
    DWORD                   fdwId
)
{
    CHECK_AND_INIT_THUNKS(mix32Lib);
    return IMixerGetID( hmxobj, puMxId, NULL, fdwId );
}


/*****************************Private*Routine******************************\
* IMixerGetID
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT FNGLOBAL IMixerGetID(
    HMIXEROBJ           hmxobj,
    UINT           FAR *puMxId,
    LPMIXERLINE         pmxl,
    DWORD               fdwId
)
{
    MMRESULT        mmr;
    MIXERLINE       mxl;
    UINT            u;

    V_DFLAGS(fdwId, MIXER_GETIDF_VALID, IMixerGetID, MMSYSERR_INVALFLAG);
    V_WPOINTER(puMxId, sizeof(UINT), MMSYSERR_INVALPARAM);


    //
    //  set to '-1' which would be the mixer mapper (if there was one)
    //  this way we will definitely fail any calls made on this id if
    //  this function fails and the caller doesn't check his return value.
    //
    *puMxId = (UINT)-1;


    //
    //
    //
    switch (MIXER_OBJECTF_TYPEMASK & fdwId)
    {
        case MIXER_OBJECTF_MIXER:
        case MIXER_OBJECTF_HMIXER:
            if ((UINT)hmxobj > MAXMIXERDRIVERS)
            {
                V_HANDLE(hmxobj, TYPE_MIXER, MMSYSERR_INVALHANDLE);

                *puMxId = ((PMIXERDEV)hmxobj)->uDeviceID;
                return (MMSYSERR_NOERROR);
            }

            if ((UINT)hmxobj >= guTotalMixerDevs)
            {
                DebugErr1(DBF_ERROR, "mixerGetID: mixer device id is out of range (%u).", hmxobj);
                return (MMSYSERR_BADDEVICEID);
            }

            *puMxId = (UINT)hmxobj;
            return (MMSYSERR_NOERROR);


        case MIXER_OBJECTF_HWAVEOUT:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveOutGetID((HWAVEOUT)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveOutMessage((HWAVEOUT)hmxobj,
                                               WODM_MAPPER_STATUS,
                                               WAVEOUT_MAPPER_STATUS_DEVICE,
                                               (DWORD)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)uId;
        }

        case MIXER_OBJECTF_WAVEOUT:
        {
            WAVEOUTCAPS     woc;

            mmr = waveOutGetDevCaps((UINT)hmxobj, &woc, sizeof(woc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEOUT;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = woc.wMid;
            mxl.Target.wPid           = woc.wPid;
            mxl.Target.vDriverVersion = woc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, woc.szPname);
            break;
        }


        case MIXER_OBJECTF_HWAVEIN:
        {
            UINT        uId;
            DWORD       dwId;

            mmr = waveInGetID((HWAVEIN)hmxobj, &uId);
            if (MMSYSERR_NOERROR != mmr)
            {
                return (MMSYSERR_INVALHANDLE);
            }

            if (WAVE_MAPPER == uId)
            {
                mmr = (MMRESULT)waveInMessage((HWAVEIN)hmxobj,
                                              WIDM_MAPPER_STATUS,
                                              WAVEIN_MAPPER_STATUS_DEVICE,
                                              (DWORD)(LPVOID)&dwId);

                if (MMSYSERR_NOERROR == mmr)
                {
                    uId = (UINT)dwId;
                }
            }

            hmxobj = (HMIXEROBJ)uId;
        }

        case MIXER_OBJECTF_WAVEIN:
        {
            WAVEINCAPS      wic;

            mmr = waveInGetDevCaps((UINT)hmxobj, &wic, sizeof(wic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_WAVEIN;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = wic.wMid;
            mxl.Target.wPid           = wic.wPid;
            mxl.Target.vDriverVersion = wic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, wic.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIOUT:
            mmr = midiOutGetID((HMIDIOUT)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIOUT:
        {
            MIDIOUTCAPS     moc;

            mmr = midiOutGetDevCaps((UINT)hmxobj, &moc, sizeof(moc));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIOUT;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = moc.wMid;
            mxl.Target.wPid           = moc.wPid;
            mxl.Target.vDriverVersion = moc.vDriverVersion;
            lstrcpy(mxl.Target.szPname, moc.szPname);
            break;
        }


        case MIXER_OBJECTF_HMIDIIN:
            mmr = midiInGetID((HMIDIIN)hmxobj, (UINT FAR *)&hmxobj);
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_INVALHANDLE);

        case MIXER_OBJECTF_MIDIIN:
        {
            MIDIINCAPS      mic;

            mmr = midiInGetDevCaps((UINT)hmxobj, &mic, sizeof(mic));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_MIDIIN;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = mic.wMid;
            mxl.Target.wPid           = mic.wPid;
            mxl.Target.vDriverVersion = mic.vDriverVersion;
            lstrcpy(mxl.Target.szPname, mic.szPname);
            break;
        }


        case MIXER_OBJECTF_AUX:
        {
            AUXCAPS         ac;

            mmr = auxGetDevCaps((UINT)hmxobj, &ac, sizeof(ac));
            if (MMSYSERR_NOERROR != mmr)
                return (MMSYSERR_BADDEVICEID);

            ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

            mxl.Target.dwType         = MIXERLINE_TARGETTYPE_AUX;
            mxl.Target.dwDeviceID     = (UINT)hmxobj;
            mxl.Target.wMid           = ac.wMid;
            mxl.Target.wPid           = ac.wPid;
            mxl.Target.vDriverVersion = ac.vDriverVersion;
            lstrcpy(mxl.Target.szPname, ac.szPname);
            break;
        }

        default:
            DebugErr1(DBF_ERROR, "mixerGetID: unknown mixer object flag (%.08lXh).",
                        MIXER_OBJECTF_TYPEMASK & fdwId);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    //
    mxl.cbStruct        = sizeof(mxl);
    mxl.dwDestination   = (DWORD)-1L;
    mxl.dwSource        = (DWORD)-1L;
    mxl.dwLineID        = (DWORD)-1L;
    mxl.fdwLine         = 0;
    mxl.dwUser          = 0;
    mxl.dwComponentType = (DWORD)-1L;
    mxl.cChannels       = 0;
    mxl.cConnections    = 0;
    mxl.cControls       = 0;
    mxl.szShortName[0]  = '\0';
    mxl.szName[0]       = '\0';


    for (u = 0; u < guTotalMixerDevs; u++)
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        u,
                                        MXDM_GETLINEINFO,
                                        (DWORD)(LPVOID)&mxl,
                                        M_GLINFOF_TARGETTYPE);

        if (MMSYSERR_NOERROR == mmr)
        {
            *puMxId = u;

            if (NULL != pmxl)
            {
                DWORD       cbStruct;

                cbStruct = pmxl->cbStruct;

                _fmemcpy(pmxl, &mxl, (UINT)cbStruct);

                pmxl->cbStruct = cbStruct;
            }

            return (mmr);
        }
    }

    return (MMSYSERR_NODRIVER);
} // IMixerGetID()


/******************************Public*Routine******************************\
* mixerOpen
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerOpen(
    LPHMIXER                phmx,
    UINT                    uMxId,
    DWORD                   dwCallback,
    DWORD                   dwInstance,
    DWORD                   fdwOpen
)
{
    MMRESULT        mmr;
    DWORD           dwMap;
    PMIXERDRV       pmxdrv;
    PMIXERDEV       pmxdev;
    MIXEROPENDESC   mxod;
    DWORD           dwDrvUser;
    MIXERCAPS       mxcaps;


    CHECK_AND_INIT_THUNKS(mix32Lib);

    //
    //
    //
    V_WPOINTER(phmx, sizeof(HMIXER), MMSYSERR_INVALPARAM);

    *phmx = NULL;

    //
    //  Don't allow callback functions - they're not useful and they
    //  cause headaches.   Specifically for Windows NT the only way
    //  to cause an asynchronous callback to 16-bit land from a 32-bit DLL
    //  is to cause an interrupt but we don't want to require mixer stuff
    //  to be locked down to allow for this.
    //

    if ((fdwOpen & CALLBACK_TYPEMASK) == CALLBACK_FUNCTION)
    {
        DebugErr(DBF_ERROR, "mixerOpen: CALLBACK_FUNCTION is not supported");
        return MMSYSERR_INVALFLAG;
    }

    V_DCALLBACK(dwCallback, HIWORD(fdwOpen & CALLBACK_TYPEMASK), MMSYSERR_INVALPARAM);
    V_DFLAGS(fdwOpen, MIXER_OPENF_VALID, mixerOpen, MMSYSERR_INVALFLAG);

    mmr = IMixerGetID((HMIXEROBJ)uMxId, &uMxId, NULL, (MIXER_OBJECTF_TYPEMASK & fdwOpen));
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //
    //
    //
    dwMap = IMixerMapId(mixerdrv, guTotalMixerDevs, uMxId);
    if ((DWORD)-1 == dwMap)
        return (MMSYSERR_BADDEVICEID);

    pmxdrv = &mixerdrv[HIWORD(dwMap)];

#ifdef MIXER_MAPPER
    //
    //  Default Mixer Mapper:
    //
    //  If a mixer mapper is installed as a separate DLL then all mixer
    //  mapper messages are routed to it. If no mixer mapper is installed,
    //  simply loop through the mixer devices looking for a match.
    //
    if ((MIXER_MAPPER == uMxId) && (NULL == pmxdrv->drvMessage))
    {
        for (uMxId = 0; uMxId < guTotalMixerDevs; uMxId++)
        {
            // try to open it
            if (MMSYSERR_NOERROR == mmr)
                break;

        }

        return (mmr);
    }
#endif


    //
    // Get some memory for the dev structure
    //
    pmxdev = (PMIXERDEV)NewHandle(TYPE_MIXER, sizeof(MIXERDEV));
    if (NULL == pmxdev)
    {
       return (MMSYSERR_NOMEM);
    }

    //
    //  initialize our open instance struct for the client
    //
    pmxdev->uHandleType = TYPE_MIXER;
    pmxdev->pmxdrv      = pmxdrv;
    pmxdev->wDevice     = LOWORD(dwMap);
    pmxdev->uDeviceID   = uMxId;

    //
    //  save the client's callback info
    //
    pmxdev->dwCallback  = dwCallback;
    pmxdev->dwInstance  = dwInstance;
    pmxdev->fdwOpen     = fdwOpen;


    //
    //  this should probably be done when the driver is booted.. can change
    //  this later..
    //
    mmr = mixerGetDevCaps(uMxId, &mxcaps, sizeof(mxcaps));
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF((0, "!mixerOpen() failing because mixerGetDevCaps() failed!"));

        FreeHandle((HMIXER)pmxdev);
        return (mmr);
    }

    //
    //  cache some stuff for parameter validation
    //
    pmxdev->fdwSupport    = mxcaps.fdwSupport;
    pmxdev->cDestinations = mxcaps.cDestinations;


    //
    // If we get here, no one has the device currently open.  Let's
    // go open it, then.
    //

    //
    // Load up our local MIXEROPENDESC struct
    //

    mxod.hmx         = (HMIXER)pmxdev;
    mxod.pReserved0  = (LPVOID)(fdwOpen & ~MIXER_OBJECTF_TYPEMASK);
    mxod.dwCallback  = dwCallback;
    mxod.dwInstance  = dwInstance;
    mmr = (MMRESULT)((*(pmxdrv->drvMessage))(LOWORD(dwMap),
                                             MXDM_OPEN,
                                             (DWORD)(LPDWORD)&dwDrvUser,
                                             (DWORD)(LPVOID)&mxod,
                                             (DWORD)uMxId ));


    if (MMSYSERR_NOERROR != mmr)
    {
        FreeHandle((HMIXER)pmxdev);
    }
    else
    {
        pmxdrv->bUsage++;
        pmxdev->dwDrvUser = dwDrvUser;
        *phmx = (HMIXER)pmxdev;

        //
        // Put this new device into the devlist chain.
        //

        MIXMGR_ENTER;

        pmxdev->pmxdevNext = gpMixerDevHeader;
        gpMixerDevHeader = pmxdev;

        MIXMGR_LEAVE;
    }
    return mmr;
}


/******************************Public*Routine******************************\
* mixerClose
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerClose(
    HMIXER                  hmx
)
{
    MMRESULT    mmr;
    PMIXERDEV   pmxdev;
    PMIXERDEV   pmxdevT;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_HANDLE(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);


    //
    //  if last open instance, then close it
    //
    mmr = (MMRESULT)IMixerMessageHandle(hmx, MXDM_CLOSE, 0L, 0L);

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);


    //
    //  remove the mixer handle from the linked list
    //

    MIXMGR_ENTER;

    pmxdev = (PMIXERDEV)hmx;
    if (pmxdev == gpMixerDevHeader)
    {
        gpMixerDevHeader = pmxdev->pmxdevNext;
    }
    else
    {
        for (pmxdevT = gpMixerDevHeader;
             pmxdevT && (pmxdevT->pmxdevNext != pmxdev);
             pmxdevT = pmxdevT->pmxdevNext)
            ;

        if (NULL == pmxdevT)
        {
            DebugErr1(DBF_ERROR, "mixerClose: invalid mixer handle (%.04Xh).", hmx);
            return (MMSYSERR_INVALHANDLE);
        }

        pmxdevT->pmxdevNext = pmxdev->pmxdevNext;
    }

    MIXMGR_LEAVE;

    //
    //  dec usage count
    //
    pmxdev->pmxdrv->bUsage--;


    //
    //  we're done with the memory block. now free the memory and return.
    //
    FreeHandle(hmx);
    return mmr;
}


/******************************Public*Routine******************************\
* mixerMessage
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD MIXAPI mixerMessage(
    HMIXER                  hmx,
    UINT                    uMsg,
    DWORD                   dwParam1,
    DWORD                   dwParam2
)
{
    DWORD       dw;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_HANDLE(hmx, TYPE_MIXER, MMSYSERR_INVALHANDLE);

    //
    //  don't allow any non-user range messages through this API
    //
    if (MXDM_USER > uMsg)
    {
        DebugErr1(DBF_ERROR, "mixerMessage: message must be in MXDM_USER range--what's this (%u)?", uMsg);
        return (MMSYSERR_INVALPARAM);
    }


    dw = IMixerMessageHandle(hmx, uMsg, dwParam1, dwParam2);
    return dw;
}


//--------------------------------------------------------------------------;
//
//  BOOL IMixerIsValidComponentType
//
//  Description:
//
//
//  Arguments:
//      DWORD dwComponentType:
//
//      UINT uSrcDst:
//
//  Return (BOOL):
//
//  History:
//      10/06/93    cjp     [curtisp]
//
//--------------------------------------------------------------------------;

BOOL FNLOCAL IMixerIsValidComponentType(
    DWORD           dwComponentType,
    DWORD           fdwLine
)
{

    if (0L == (MIXERLINE_LINEF_SOURCE & fdwLine))
    {
        if (dwComponentType > MLCT_DST_LAST)
            return (FALSE);

        return (TRUE);
    }
    else
    {
        if (dwComponentType < MLCT_SRC_FIRST)
            return (FALSE);

        if (dwComponentType > MLCT_SRC_LAST)
            return (FALSE);

        return (TRUE);
    }

    return (FALSE);
} // IMixerIsValidComponentType()



/******************************Public*Routine******************************\
* mixerGetLineInfo
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetLineInfo(
    HMIXEROBJ               hmxobj,
    LPMIXERLINE             pmxl,
    DWORD                   fdwInfo
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    PMIXERDEV           pmxdev;
    UINT                uMxId;
    BOOL                fSourceLine;

    CHECK_AND_INIT_THUNKS(mix32Lib);

    V_DFLAGS(fdwInfo, M_GLINFOF_VALID, mixerGetLineInfo, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxl, sizeof(DWORD), MMSYSERR_INVALPARAM);
    if (sizeof(MIXERLINE) > (UINT)pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: structure size too small or cbStruct not initialized (%lu).", pmxl->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxl, pmxl->cbStruct, MMSYSERR_INVALPARAM);


    //
    //
    //
    fSourceLine = FALSE;
    switch (fdwInfo & M_GLINFOF_QUERYMASK)
    {
        case M_GLINFOF_DESTINATION:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_SOURCE:
            fSourceLine = TRUE;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_LINEID:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;
            break;

        case M_GLINFOF_COMPONENTTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;

            if (!IMixerIsValidComponentType(pmxl->dwComponentType, 0) &&
                !IMixerIsValidComponentType(pmxl->dwComponentType, MIXERLINE_LINEF_SOURCE))
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid dwComponentType (%lu).", pmxl->dwComponentType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        case M_GLINFOF_TARGETTYPE:
            pmxl->dwSource        = (DWORD)-1L;
            pmxl->dwDestination   = (DWORD)-1L;
            pmxl->dwLineID        = (DWORD)-1L;
            pmxl->dwComponentType = (DWORD)-1L;

            if ((DWORD)MIXERLINE_TARGETTYPE_AUX < pmxl->Target.dwType)
            {
                DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid Target.dwType (%lu).", pmxl->Target.dwType);
                return (MMSYSERR_INVALPARAM);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid query flag (%.08lXh).",
                        fdwInfo & M_GLINFOF_QUERYMASK);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwInfo);

    mmr = IMixerGetID(hmxobj, &uMxId, pmxl, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
    {
        DPF((0, "!IMixerGetLineInfo: IMixerGetID() failed!"));
        return (mmr);
    }

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        return (MMSYSERR_NOERROR);
    }


    //
    //  clear all fields before calling driver
    //
    if (NULL != hmxobj)
    {
        //
        //
        //
        pmxdev = (PMIXERDEV)hmxobj;
#if 0
        if (pmxdev->cDestinations <= pmxl->dwDestination)
        {
            DebugErr1(DBF_ERROR, "mixerGetLineInfo: invalid destination index (%lu).", pmxl->dwDestination);
            return (MMSYSERR_INVALPARAM);
        }
#endif

        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINEINFO,
                                            (DWORD)(LPVOID)pmxl,
                                            fdwInfo);
    }
    else
    {
#pragma message("----IMixerGetLineInfo: dwDestination not validated for ID's!!")
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETLINEINFO,
                                        (DWORD)(LPVOID)pmxl,
                                        fdwInfo);
    }

    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

#pragma message("----IMixerGetLineInfo: should validate mixer driver didn't hose us!")


    //
    //  validate the driver's returned stuff...
    //
    //
    if (sizeof(MIXERLINE) != (UINT)pmxl->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid cbStruct (%lu).", pmxl->cbStruct);
        pmxl->cbStruct = sizeof(MIXERLINE);
    }

    if ((DWORD)-1L == pmxl->dwDestination)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwDestination member.");
    }
    if (fSourceLine)
    {
        if (0L == (MIXERLINE_LINEF_SOURCE & pmxl->fdwLine))
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to set MIXERLINE_LINEF_SOURCE.");
            pmxl->fdwLine |= MIXERLINE_LINEF_SOURCE;
        }

        if ((DWORD)-1L == pmxl->dwSource)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwSource member.");
        }
    }
    if ((DWORD)-1L == pmxl->dwLineID)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver failed to init dwLineID member.");
    }
    if (pmxl->fdwLine & ~0x80008001L)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver set reserved line flags (%.08lXh)!", pmxl->fdwLine);
        pmxl->fdwLine &= 0x80008001L;
    }
    if (!IMixerIsValidComponentType(pmxl->dwComponentType, pmxl->fdwLine))
    {
        DebugErr1(DBF_ERROR, "mixerGetLineInfo: buggy driver returned invalid dwComponentType (%.08lXh).", pmxl->dwComponentType);
        pmxl->dwComponentType = MIXERLINE_TARGETTYPE_UNDEFINED;
    }
    if (0L == pmxl->cChannels)
    {
        DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned zero channels?!?");
        pmxl->cChannels = 1;
    }
    if (fSourceLine)
    {
        if (0L != pmxl->cConnections)
        {
            DebugErr(DBF_ERROR, "mixerGetLineInfo: buggy driver returned non-zero connections on source?!?");
            pmxl->cConnections = 0;
        }
    }

    pmxl->szShortName[SIZEOF(pmxl->szShortName) - 1] = '\0';
    pmxl->szName[SIZEOF(pmxl->szName) - 1] = '\0';


    //
    // Does this really need to be done if TARGETTYPE was requested?
    //


    //
    //
    //
    if ((DWORD)MIXERLINE_TARGETTYPE_UNDEFINED != pmxl->Target.dwType)
    {
        UINT        u;

        pmxl->Target.dwDeviceID = (DWORD)-1L;


        //
        //  we have a wMid, wPid and szPname (supposedly) of type dwType
        //  so let's go find it...
        //
        switch (pmxl->Target.dwType)
        {
            case MIXERLINE_TARGETTYPE_WAVEOUT:
                u = waveOutGetNumDevs();
                while (u--)
                {
                    WAVEOUTCAPS     woc;

                    mmr = waveOutGetDevCaps(u, &woc, sizeof(woc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    woc.szPname[SIZEOF(woc.szPname) - 1] = '\0';

                    if (woc.wMid != pmxl->Target.wMid)
                        continue;

                    if (woc.wPid != pmxl->Target.wPid)
                        continue;

                    if (woc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(woc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_WAVEIN:
                u = waveInGetNumDevs();
                while (u--)
                {
                    WAVEINCAPS      wic;

                    mmr = waveInGetDevCaps(u, &wic, sizeof(wic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    wic.szPname[SIZEOF(wic.szPname) - 1] = '\0';

                    if (wic.wMid != pmxl->Target.wMid)
                        continue;

                    if (wic.wPid != pmxl->Target.wPid)
                        continue;

                    if (wic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(wic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIOUT:
                u = midiOutGetNumDevs();
                while (u--)
                {
                    MIDIOUTCAPS     moc;

                    mmr = midiOutGetDevCaps(u, &moc, sizeof(moc));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    moc.szPname[SIZEOF(moc.szPname) - 1] = '\0';

                    if (moc.wMid != pmxl->Target.wMid)
                        continue;

                    if (moc.wPid != pmxl->Target.wPid)
                        continue;

                    if (moc.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(moc.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_MIDIIN:
                u = midiInGetNumDevs();
                while (u--)
                {
                    MIDIINCAPS      mic;

                    mmr = midiInGetDevCaps(u, &mic, sizeof(mic));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    mic.szPname[SIZEOF(mic.szPname) - 1] = '\0';

                    if (mic.wMid != pmxl->Target.wMid)
                        continue;

                    if (mic.wPid != pmxl->Target.wPid)
                        continue;

                    if (mic.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(mic.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            case MIXERLINE_TARGETTYPE_AUX:
                u = auxGetNumDevs();
                while (u--)
                {
                    AUXCAPS     ac;

                    mmr = auxGetDevCaps(u, &ac, sizeof(ac));
                    if (MMSYSERR_NOERROR != mmr)
                        continue;

                    ac.szPname[SIZEOF(ac.szPname) - 1] = '\0';

                    if (ac.wMid != pmxl->Target.wMid)
                        continue;

                    if (ac.wPid != pmxl->Target.wPid)
                        continue;

                    if (ac.vDriverVersion != pmxl->Target.vDriverVersion)
                        continue;

                    if (lstrcmp(ac.szPname, pmxl->Target.szPname))
                        continue;

                    pmxl->Target.dwDeviceID = u;
                    break;
                }
                break;

            default:
                pmxl->Target.dwType = MIXERLINE_TARGETTYPE_UNDEFINED;
                break;
        }
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerGetLineControls
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetLineControls(
    HMIXEROBJ               hmxobj,
    LPMIXERLINECONTROLS     pmxlc,
    DWORD                   fdwControls
)
{
    DWORD               fdwMxObjType;
    UINT                uMxId;
    MMRESULT            mmr;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwControls, M_GLCONTROLSF_VALID, mixerGetLineControls, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxlc, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERLINECONTROLS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERLINECONTROLS) > (UINT)pmxlc->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbStruct not initialized (%lu).", pmxlc->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxlc, pmxlc->cbStruct, MMSYSERR_INVALPARAM);

    if (sizeof(MIXERCONTROL) > (UINT)pmxlc->cbmxctrl)
    {
        DebugErr1(DBF_ERROR, "mixerGetLineControls: structure size too small or cbmxctrl not initialized (%lu).", pmxlc->cbmxctrl);
        return (MMSYSERR_INVALPARAM);
    }


    //
    //
    //
    switch (M_GLCONTROLSF_QUERYMASK & fdwControls)
    {
        case M_GLCONTROLSF_ALL:
            if (0L == pmxlc->cControls)
            {
                DebugErr(DBF_ERROR, "mixerGetLineControls: cControls cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }


            pmxlc->dwControlID  = (DWORD)-1L;
            break;

        case M_GLCONTROLSF_ONEBYID:
            pmxlc->dwLineID     = (DWORD)-1L;

            // -- fall through --

        case M_GLCONTROLSF_ONEBYTYPE:
            pmxlc->cControls    = (DWORD)1;
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetLineControls: invalid query flags (%.08lXh).",
                        M_GLCONTROLSF_QUERYMASK & fdwControls);
            return (MMSYSERR_INVALFLAG);
    }

    V_WPOINTER(pmxlc->pamxctrl, pmxlc->cControls * pmxlc->cbmxctrl, MMSYSERR_INVALPARAM);


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwControls);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
        fdwControls &= ~MIXER_OBJECTF_TYPEMASK;
        fdwControls |= MIXER_OBJECTF_MIXER;
    }



    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETLINECONTROLS,
                                            (DWORD)pmxlc,
                                            fdwControls);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETLINECONTROLS,
                                        (DWORD)pmxlc,
                                        fdwControls);
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerGetControlDetails
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerGetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwDetails, M_GCDSF_VALID, mixerGetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > (UINT)pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);


    switch (M_GCDSF_QUERYMASK & fdwDetails)
    {
        case M_GCDSF_VALUE:
            //
            //  if both cChannels and cMultipleItems are zero, it is a
            //  custom control
            //
            if ((0L == pmxcd->cChannels) && (0L == pmxcd->cMultipleItems))
            {
                if (0L == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            }
            else
            {
                if (0L == pmxcd->cChannels)
                {
                    DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _VALUE cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }


                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                //
                //
                //
                cDetails = (UINT)pmxcd->cChannels;
                if (0L != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)pmxcd->cMultipleItems;
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case M_GCDSF_LISTTEXT:
            if (0L == pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cChannels for _LISTTEXT cannot be zero.");
                return (MMSYSERR_INVALPARAM);
            }

            if (2L > pmxcd->cMultipleItems)
            {
                DebugErr(DBF_ERROR, "mixerGetControlDetails: cMultipleItems for _LISTTEXT must be 2 or greater.");
                return (MMSYSERR_INVALPARAM);
            }

            if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_LISTTEXT))
            {
                DebugErr1(DBF_ERROR, "mixerGetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                return (MMSYSERR_INVALPARAM);
            }

            cDetails = (UINT)pmxcd->cChannels * (UINT)pmxcd->cMultipleItems;
            V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerGetControlDetails: invalid query flags (%.08lXh).",
                        M_GCDSF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }



    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        hmxobj = NULL;
        fdwDetails &= ~MIXER_OBJECTF_TYPEMASK;
        fdwDetails |= MIXER_OBJECTF_MIXER;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_GETCONTROLDETAILS,
                                            (DWORD)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_GETCONTROLDETAILS,
                                        (DWORD)pmxcd,
                                        fdwDetails);
    }

    return mmr;
}


/******************************Public*Routine******************************\
* mixerSetControlDetails
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
MMRESULT MIXAPI mixerSetControlDetails(
    HMIXEROBJ               hmxobj,
    LPMIXERCONTROLDETAILS   pmxcd,
    DWORD                   fdwDetails
)
{
    DWORD               fdwMxObjType;
    MMRESULT            mmr;
    UINT                uMxId;
    UINT                cDetails;

    CHECK_AND_INIT_THUNKS(mix32Lib);
    V_DFLAGS(fdwDetails, M_SCDF_VALID, mixerSetControlDetails, MMSYSERR_INVALFLAG);
    V_WPOINTER(pmxcd, sizeof(DWORD), MMSYSERR_INVALPARAM);

    //
    //  the structure header for MIXERCONTROLDETAILS must be at least the
    //  minimum size
    //
    if (sizeof(MIXERCONTROLDETAILS) > (UINT)pmxcd->cbStruct)
    {
        DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbStruct not initialized (%lu).", pmxcd->cbStruct);
        return (MMSYSERR_INVALPARAM);
    }
    V_WPOINTER(pmxcd, pmxcd->cbStruct, MMSYSERR_INVALPARAM);



    switch (M_SCDF_QUERYMASK & fdwDetails)
    {
        case M_SCDF_VALUE:
            //
            //  cChannels is zero for custom controls
            //
            if (0L == pmxcd->cChannels)
            {
                if (0L == pmxcd->cbDetails)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero.");
                    return (MMSYSERR_INVALPARAM);
                }

                V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

                //
                //
                //
                if (0L != pmxcd->cMultipleItems)
                {
                    DebugErr(DBF_ERROR, "mixerSetControlDetails: cMultipleItems must be zero for custom controls.");
                    return (MMSYSERR_INVALPARAM);
                }
            }
            else
            {
                if (pmxcd->cbDetails < sizeof(MIXERCONTROLDETAILS_SIGNED))
                {
                    DebugErr1(DBF_ERROR, "mixerSetControlDetails: structure size too small or cbDetails not initialized (%lu).", pmxcd->cbDetails);
                    return (MMSYSERR_INVALPARAM);
                }

                cDetails = (UINT)pmxcd->cChannels;

                //
                //
                //
                if (0L != pmxcd->cMultipleItems)
                {
                    cDetails *= (UINT)(pmxcd->cMultipleItems);
                }

                V_WPOINTER(pmxcd->paDetails, cDetails * pmxcd->cbDetails, MMSYSERR_INVALPARAM);
            }
            break;

        case M_SCDF_CUSTOM:
            if (0L == pmxcd->cbDetails)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cbDetails cannot be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            if (0L != pmxcd->cChannels)
            {
                DebugErr(DBF_ERROR, "mixerSetControlDetails: cChannels must be zero for custom controls.");
                return (MMSYSERR_INVALPARAM);
            }

            V_WPOINTER(pmxcd->paDetails, pmxcd->cbDetails, MMSYSERR_INVALPARAM);

            //
            //
            //
            if ((NULL != pmxcd->hwndOwner) && !IsWindow(pmxcd->hwndOwner))
            {
                DebugErr1(DBF_ERROR, "mixerSetControlDetails: hwndOwner must be a valid window handle (%.04Xh).", pmxcd->hwndOwner);
                return (MMSYSERR_INVALHANDLE);
            }
            break;

        default:
            DebugErr1(DBF_ERROR, "mixerSetControlDetails: invalid query flags (%.08lXh).",
                        M_SCDF_QUERYMASK & fdwDetails);
            return (MMSYSERR_INVALFLAG);
    }


    //
    //
    //
    fdwMxObjType = (MIXER_OBJECTF_TYPEMASK & fdwDetails);

    mmr = IMixerGetID(hmxobj, &uMxId, NULL, fdwMxObjType);
    if (MMSYSERR_NOERROR != mmr)
        return (mmr);

    if ((MIXER_OBJECTF_MIXER  == fdwMxObjType) ||
        (MIXER_OBJECTF_HMIXER == fdwMxObjType))
    {
        //
        //  if a mixer device id was passed, then null hmx so we use the
        //  correct message sender below
        //
        if ((UINT)hmxobj == uMxId)
            hmxobj = NULL;
    }
    else
    {
        fdwDetails &= ~MIXER_OBJECTF_TYPEMASK;
        fdwDetails |= MIXER_OBJECTF_MIXER;
        hmxobj = NULL;
    }

    //
    //
    //
    //
    if (NULL != hmxobj)
    {
        mmr = (MMRESULT)IMixerMessageHandle((HMIXER)hmxobj,
                                            MXDM_SETCONTROLDETAILS,
                                            (DWORD)pmxcd,
                                            fdwDetails);
    }
    else
    {
        mmr = (MMRESULT)IMixerMessageId(mixerdrv,
                                        guTotalMixerDevs,
                                        uMxId,
                                        MXDM_SETCONTROLDETAILS,
                                        (DWORD)pmxcd,
                                        fdwDetails);
    }

    return mmr;
}

/*****************************Private*Routine******************************\
* InitMixerThunks
*
* Initializes the thunking system.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
BOOL FAR PASCAL
InitMixerThunks(
    void
    )
{

    /*
    ** For WOW we have a fake device driver (that actually lives inside
    ** this library).  When an applications makes an api call to this
    ** library we check to see is the WOW thunks are loaded.  If they are
    ** not loaded "InitWOWThunks" is called.  This function loads the 32
    ** bit library and determines the total number of mixer devices
    ** present in the system.  It then sets mixerdrv[0].bUsage
    ** and guTotalMixerDevs to this value.  This appears to the 16 bit code
    ** that we have one 16 bit device driver that supports all the
    ** 32 bit devices !!.  The entry point to this fake driver is
    ** mxdMessage, which just passes the message through to the 32 bit
    ** side.
    */

    mixerdrv[0].hDriver     = NULL;
    mixerdrv[0].bNumDevs    = (BYTE)0;
    mixerdrv[0].bUsage      = 0;
    mixerdrv[0].drvMessage  = mxdMessage;
    guTotalMixerDevs = 0;


    /*
    ** First try winmm.dll
    */
    mix32Lib = LoadLibraryEx32W( "winmm.dll", NULL, 0L );
    if ( mix32Lib ) {
        mix32Message = (DRIVERMSGPROC)GetProcAddress32W( mix32Lib,
                                                         "mxd32Message" );
        if ( mix32Message ) {

            mxdMessage( 0, MXDM_INIT, 0L, 0L, 0L );
            guTotalMixerDevs = (UINT)mxdMessage( 0, MXDM_GETNUMDEVS,
                                                 0L, 0L, 0L );

            mixerdrv[0].bNumDevs = (BYTE)guTotalMixerDevs;
            return TRUE;
        }
    }

    /*
    ** Then try msmix32.dll
    */
    mix32Lib = LoadLibraryEx32W( "msmix32.dll", NULL, 0L );
    if ( mix32Lib ) {

        mix32Message = (DRIVERMSGPROC)GetProcAddress32W( mix32Lib,
                                                         "mxd32Message" );
        if ( mix32Message ) {

            mxdMessage( 0, MXDM_INIT, 0L, 0L, 0L );
            guTotalMixerDevs = (UINT)mxdMessage( 0, MXDM_GETNUMDEVS,
                                                 0L, 0L, 0L );

            mixerdrv[0].bNumDevs = (BYTE)guTotalMixerDevs;
            return TRUE;
        }
    }

    /*
    ** Give up !!
    */
    return FALSE;

}


/*****************************Private*Routine******************************\
* mxdMessage
*
* Entry point for the fake WOW device driver.
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD CALLBACK
mxdMessage(
    UINT uId,
    UINT uMsg,
    DWORD dwInstance,
    DWORD dwParam1,
    DWORD dwParam2
    )
{
    return mmCallProc32( (DWORD)uId, (DWORD)uMsg, dwInstance,
                         dwParam1, dwParam2, mix32Message, 0L );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mcisys.c ===
/*******************************Module*Header*********************************\
* Module Name: mcisys.c
*
* Media Control Architecture System Functions
*
* Created: 2/28/90
* Author:  DLL (DavidLe)
*
* History:
*
* Copyright (c) 1990 Microsoft Corporation
*
\******************************************************************************/

#include <windows.h>

#define MMNOMIDI
#define MMNOWAVE
#define MMNOSOUND
#define MMNOTIMER
#define MMNOJOY
#define MMNOSEQ
#include "mmsystem.h"
#define NOMIDIDEV
#define NOWAVEDEV
#define NOTIMERDEV
#define NOJOYDEV
#define NOSEQDEV
#define NOTASKDEV
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

#ifndef STATICFN
#define STATICFN
#endif

extern char far szOpen[];          // in MCI.C

static SZCODE szNull[] = "";
static SZCODE szMciExtensions[] = "mci extensions";

#define MCI_EXTENSIONS szMciExtensions
#define MCI_PROFILE_STRING_LENGTH 255

//!!#define TOLOWER(c) ((c) >= 'A' && (c) <= 'Z' ? (c) + 'a' - 'A' : c)

// The device list is initialized on the first call to mciSendCommand or
// to mciSendString
BOOL MCI_bDeviceListInitialized;

// The next device ID to use for a new device
UINT MCI_wNextDeviceID = 1;

// The list of MCI devices. This list grows and shrinks as needed.
// The first offset MCI_lpDeviceList[0] is a placeholder and is unused
// because device 0 is defined as no device.
LPMCI_DEVICE_NODE FAR * MCI_lpDeviceList;

// The current size of the list of MCI devices
UINT MCI_wDeviceListSize;

// The internal mci heap used by mciAlloc and mciFree
HGLOBAL hMciHeap;

// File containing MCI device profile strings
extern char far szSystemIni[];			// in INIT.C

// Name of the section contining MCI device profile strings
static SZCODE szMCISectionName[] = "mci";

static SZCODE szAllDeviceName[] = "all";

static SZCODE szUnsignedFormat[] = "%u";

static void PASCAL NEAR mciFreeDevice(LPMCI_DEVICE_NODE nodeWorking);

BOOL NEAR PASCAL CouldBe16bitDrv(UINT wDeviceID)
{
    if (wDeviceID == MCI_ALL_DEVICE_ID) return TRUE;

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        if (MCI_lpDeviceList[wDeviceID]->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL NEAR PASCAL Is16bitDrv(UINT wDeviceID)
{
    if (wDeviceID == MCI_ALL_DEVICE_ID) return FALSE;

    if (MCI_VALID_DEVICE_ID(wDeviceID)) {
        if (MCI_lpDeviceList[wDeviceID]->dwMCIFlags & MCINODE_16BIT_DRIVER) {
            return TRUE;
        }
    }
    return FALSE;
}

//
// Initialize device list
// Called once by mciSendString or mciSendCommand
// Returns TRUE on success
BOOL NEAR PASCAL mciInitDeviceList(void)
{

    if ((hMciHeap = HeapCreate(0)) == 0)
    {
        DOUT("Mci heap create failed!\r\n");
        return FALSE;
    }
    if ((MCI_lpDeviceList = mciAlloc (sizeof (LPMCI_DEVICE_NODE) *
                                  (MCI_INIT_DEVICE_LIST_SIZE + 1))) != NULL)
    {
        MCI_wDeviceListSize = MCI_INIT_DEVICE_LIST_SIZE;
        MCI_bDeviceListInitialized = TRUE;
        return TRUE;
    } else
    {
        DOUT ("MCIInit: could not allocate master MCI device list\r\n");
        return FALSE;
    }
}

/*
 * @doc EXTERNAL MCI
 * @api UINT | mciGetDeviceIDFromElementID | This function
 * retrieves the MCI device ID corresponding to and element ID
 *
 * @parm DWORD | dwElementID | The element ID
 *
 * @parm LPCSTR | lpstrType | The type name this element ID belongs to
 *
 * @rdesc Returns the device ID assigned when it was opened and used in the
 * <f mciSendCommand> function.  Returns zero if the device name was not known,
 * if the device was not open, or if there was not enough memory to complete
 * the operation or if lpstrType is NULL.
 *
 */
UINT WINAPI mciGetDeviceIDFromElementID (
DWORD dwElementID,
LPCSTR lpstrType)
{
    UINT wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;
    char strTemp[MCI_MAX_DEVICE_TYPE_LENGTH];

    if (lpstrType == NULL)
        return 0;

    wID = (UINT)mciMessage( THUNK_MCI_GETDEVIDFROMELEMID, dwElementID,
                            (DWORD)lpstrType, 0L, 0L );
    if ( wID == 0 ) {

        nodeCounter = &MCI_lpDeviceList[1];

        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            nodeWorking = *nodeCounter++;

            if (nodeWorking == NULL)
                continue;

            if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID &&
                nodeWorking->dwElementID == dwElementID)

                if (LoadString (ghInst, nodeWorking->wDeviceType, strTemp,
                                sizeof(strTemp)) != 0
                    && lstrcmpi ((LPSTR)strTemp, lpstrType) == 0) {

                    return (wID);
                }
        }
        return 0;
    }
    return wID;
}

// Retrieves the device ID corresponding to the name of an opened device
// matching the given task
// This fn only looks for 16-bit devices
// See mciGetDeviceIDInternalEx that looks for all of them
UINT NEAR PASCAL mciGetDeviceIDInternal (
LPCSTR lpstrName,
HTASK hTask)
{
    UINT wID;
    LPMCI_DEVICE_NODE nodeWorking, FAR *nodeCounter;

    if (lstrcmpi (lpstrName, szAllDeviceName) == 0)
        return MCI_ALL_DEVICE_ID;

    if (MCI_lpDeviceList == NULL)
        return 0;

// Loop through the MCI device list
    nodeCounter = &MCI_lpDeviceList[1];
    for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
    {
        nodeWorking = *nodeCounter++;

        if (nodeWorking == NULL)
            continue;

// If this device does not have a name then skip it
        if (nodeWorking->dwMCIOpenFlags & MCI_OPEN_ELEMENT_ID)
            continue;

// If the names match
        if (lstrcmpi(nodeWorking->lpstrName, lpstrName) == 0)

// If the device belongs to the indicated task
            if (nodeWorking->hOpeningTask == hTask)
// Return this device ID
                return wID;
    }

    return 0;
}

/*
 * @doc EXTERNAL MCI
 * @api UINT | mciGetDeviceID | This function retrieves the device
 * ID corresponding to the name of an open MCI device.
 *
 * @parm LPCSTR | lpstrName | Specifies the device name used to open the
 * MCI device.
 *
 * @rdesc Returns the device ID assigned when the device was opened.
 * Returns zero if the device name isn't known,
 * if the device isn't open, or if there was insufficient memory to complete
 * the operation.  Each compound device element has a unique device ID.
 * The ID of the "all" device is MCI_ALL_DEVICE_ID.
 *
 * @xref MCI_OPEN
 *
 */
UINT WINAPI mciGetDeviceID (
LPCSTR lpstrName)
{
    UINT    wDevID;

    /*
    ** Try the 32 bit side first
    */
    wDevID = (UINT)mciMessage( THUNK_MCI_GETDEVICEID, (DWORD)lpstrName,
                               0L, 0L, 0L );
    if ( wDevID == 0 ) {

        /*
        ** The 32 bit call failed so let the 16 bit side have a go.
        */
        wDevID = mciGetDeviceIDInternal (lpstrName, GetCurrentTask());

    }

    return wDevID;
}

//
//  This function is same as mciGetDeviceID but it won't call GetCurrentTask
//  Used when mci needs to verify the dev alias had not been allocated yet
//
//

UINT NEAR PASCAL mciGetDeviceIDInternalEx(
LPCSTR lpstrName,
HTASK hTask)
{
    UINT uiDevID;

    uiDevID = (UINT)mciMessage( THUNK_MCI_GETDEVICEID, (DWORD)lpstrName,
                                0L, 0L, 0L );
    if (0 == uiDevID) {

        uiDevID = mciGetDeviceIDInternal(lpstrName, hTask);
    }

    return uiDevID;
}


/*
 * @doc EXTERNAL MCI
 * @api HTASK | mciGetCreatorTask | This function retrieves the creator task
 * corresponding with the device ID passed.
 *
 * @parm UINT | wDeviceID | Specifies the device ID whose creator task is to
 * be returned.
 *
 * @rdesc Returns the creator task responsible for opening the device, else
 * NULL if the device ID passed is invalid.
 *
 */
HTASK WINAPI mciGetCreatorTask (
UINT wDeviceID)
{
    /*
    ** Is this a 16 bit device ID
    */
    if (Is16bitDrv(wDeviceID)) {

        return MCI_lpDeviceList[wDeviceID]->hCreatorTask;
    }

    /*
    ** No, so pass it on to the 32 bit code.
    */

    return (HTASK)mciMessage( THUNK_MCI_GETCREATORTASK, (DWORD)wDeviceID,
                              0L, 0L, 0L );
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciDeviceMatch | Match the first string with the second.
 * Any single trailing digit on the first string is ignored.  Each string
 * must have at least one character
 *
 * @parm LPCSTR | lpstrDeviceName | The device name, possibly
 * with trailing digits but no blanks.
 *
 * @parm LPCSTR | lpstrDeviceType | The device type with no trailing digits
 * or blanks
 *
 * @rdesc TRUE if the strings match the above test, FALSE otherwise
 *
 */
STATICFN BOOL PASCAL NEAR
mciDeviceMatch(
    LPCSTR lpstrDeviceName,
    LPCSTR lpstrDeviceType
    )
{
    BOOL bAtLeastOne;

    for (bAtLeastOne = FALSE;;)
        if (!*lpstrDeviceType)
            break;
        else if (!*lpstrDeviceName || ((BYTE)(WORD)(DWORD)AnsiLower((LPSTR)(DWORD)(WORD)(*lpstrDeviceName++)) != (BYTE)(WORD)(DWORD)AnsiLower((LPSTR)(DWORD)(WORD)(*lpstrDeviceType++))))
            return FALSE;
        else
            bAtLeastOne = TRUE;
    if (!bAtLeastOne)
        return FALSE;
    for (; *lpstrDeviceName; lpstrDeviceName++)
        if ((*lpstrDeviceName < '0') || (*lpstrDeviceName > '9'))
            return FALSE;
    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciLookUpType | Look up the type given a type name
 *
 * @parm LPCSTR | lpstrTypeName | The type name to look up.  Trailing
 * digits are ignored.
 *
 * @rdesc The MCI type number (MCI_DEVTYPE_<x>) or 0 if not found
 *
!! * @comm Converts the input string to lower case as a side effect
 *
 */
UINT PASCAL NEAR mciLookUpType (
LPCSTR lpstrTypeName)
{
    UINT wType;
    char strType[MCI_MAX_DEVICE_TYPE_LENGTH];

//!!    mciToLower (lpstrTypeName);

    for (wType = MCI_DEVTYPE_FIRST; wType <= MCI_DEVTYPE_LAST; ++wType)
    {
        if (LoadString (ghInst, wType, strType, sizeof(strType)) == 0)
        {
            DOUT ("mciLookUpType:  could not load string for type\r\n");
            continue;
        }

        if (mciDeviceMatch (lpstrTypeName, strType))
            return wType;
    }
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func DWORD | mciSysinfo | Get system information about a device
 *
 * @parm UINT | wDeviceID | Device ID, may be 0
 *
 * @parm DWORD | dwFlags | SYSINFO flags
 *
 * @parm LPMCI_SYSINFO_PARMS | lpSysinfo | SYSINFO parameters
 *
 * @rdesc 0 if successful, otherwise error code
 *
 */
DWORD PASCAL NEAR mciSysinfo (
UINT wDeviceID,
DWORD dwFlags,
LPMCI_SYSINFO_PARMS lpSysinfo)
{
    UINT wCounted;
    char              strBuffer[MCI_PROFILE_STRING_LENGTH];
    LPSTR             lpstrBuffer = (LPSTR)strBuffer, lpstrStart;

    if (dwFlags & MCI_SYSINFO_NAME && lpSysinfo->dwNumber == 0)
        return MCIERR_OUTOFRANGE;

    if (lpSysinfo->lpstrReturn == NULL || lpSysinfo->dwRetSize == 0)
        return MCIERR_PARAM_OVERFLOW;

    if (dwFlags & MCI_SYSINFO_NAME && dwFlags & MCI_SYSINFO_QUANTITY)
        return MCIERR_FLAGS_NOT_COMPATIBLE;

    if (dwFlags & MCI_SYSINFO_INSTALLNAME)
    {
        LPMCI_DEVICE_NODE nodeWorking;

        if (wDeviceID == MCI_ALL_DEVICE_ID)
            return MCIERR_CANNOT_USE_ALL;
        if (!MCI_VALID_DEVICE_ID(wDeviceID))
            return MCIERR_INVALID_DEVICE_NAME;

        nodeWorking = MCI_lpDeviceList[wDeviceID];
        if ((DWORD)lstrlen (nodeWorking->lpstrInstallName) >= lpSysinfo->dwRetSize)
            return MCIERR_PARAM_OVERFLOW;
        lstrcpy (lpSysinfo->lpstrReturn, nodeWorking->lpstrInstallName);
        return 0;
    } else if (!(dwFlags & MCI_SYSINFO_OPEN))
    {
        if (wDeviceID != MCI_ALL_DEVICE_ID && lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;
        GetPrivateProfileString (szMCISectionName, NULL, szNull,
                                 lpstrBuffer, MCI_PROFILE_STRING_LENGTH,
                                 szSystemIni);
        wCounted = 0;
        while (TRUE)
        {
            if (dwFlags & MCI_SYSINFO_QUANTITY)
            {
                if (*lpstrBuffer == '\0')
                {
                    *(LPDWORD)lpSysinfo->lpstrReturn = (DWORD)wCounted;
                    return MCI_INTEGER_RETURNED;
                }
                if (wDeviceID == MCI_ALL_DEVICE_ID ||
                    mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                    ++wCounted;
// Skip past the terminating '\0'
                while (*lpstrBuffer != '\0')
                    *lpstrBuffer++;
                lpstrBuffer++;
            } else if (dwFlags & MCI_SYSINFO_NAME)
            {
                if (wCounted == (UINT)lpSysinfo->dwNumber)
                {
                    lstrcpy (lpSysinfo->lpstrReturn, lpstrStart);
                    return 0L;
                } else if (*lpstrBuffer == '\0')
                    return MCIERR_OUTOFRANGE;
                else
                {
                    lpstrStart = lpstrBuffer;
                    if (wDeviceID == MCI_ALL_DEVICE_ID ||
                        mciLookUpType (lpstrBuffer) == lpSysinfo->wDeviceType)
                        ++wCounted;
// Skip past the terminating '\0'
                    while (*lpstrBuffer != '\0')
                        *lpstrBuffer++;
                    lpstrBuffer++;
                }
            }
        }
    } else
// Process MCI_SYSINFO_OPEN cases
    {
        UINT wID;
        HTASK hCurrentTask = GetCurrentTask();
        LPMCI_DEVICE_NODE Node;

        if (wDeviceID != MCI_ALL_DEVICE_ID &&
            lpSysinfo->wDeviceType == 0)
            return MCIERR_DEVICE_TYPE_REQUIRED;

        if ((dwFlags & (MCI_SYSINFO_QUANTITY | MCI_SYSINFO_NAME)) == 0)
            return MCIERR_MISSING_PARAMETER;

        wCounted = 0;
        for (wID = 1; wID < MCI_wNextDeviceID; ++wID)
        {
            if ((Node = MCI_lpDeviceList[wID]) == 0)
                continue;

            if (wDeviceID == MCI_ALL_DEVICE_ID &&
                Node->hOpeningTask == hCurrentTask)
                ++wCounted;
            else
            {
                if (Node->wDeviceType == lpSysinfo->wDeviceType &&
                    Node->hOpeningTask == hCurrentTask)
                    ++wCounted;
            }
            if (dwFlags & MCI_SYSINFO_NAME &&
                wCounted == (UINT)lpSysinfo->dwNumber)
            {
                lstrcpy (lpSysinfo->lpstrReturn, Node->lpstrName);
                return 0L;
            }
        }
        if (dwFlags & MCI_SYSINFO_NAME)
        {
            if (lpSysinfo->lpstrReturn != NULL)
                lpSysinfo->lpstrReturn = '\0';
            return MCIERR_OUTOFRANGE;

        } else if (dwFlags & MCI_SYSINFO_QUANTITY &&
                   lpSysinfo->lpstrReturn != NULL &&
                   lpSysinfo->dwRetSize >= 4)

            *(LPDWORD)lpSysinfo->lpstrReturn = wCounted;
    }
    return MCI_INTEGER_RETURNED;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | wAddDeviceNodeToList | Add the given global handle into the
 * MCI device table and return that entry's ID#
 *
 * @parm LPMCI_DEVICE_NODE | node | device description
 *
 * @rdesc The ID value for this device or 0 if there is no memory to expand
 * the device list
 *
 */
STATICFN UINT PASCAL NEAR
wAddDeviceNodeToList(
    LPMCI_DEVICE_NODE node
    )
{
    UINT wDeviceID = node->wDeviceID;
    LPMCI_DEVICE_NODE FAR *lpTempList;
    UINT iReallocSize;

    while (wDeviceID >= MCI_wDeviceListSize)
    {
        // The list is full so try to grow it
        iReallocSize = MCI_wDeviceListSize + 1 + MCI_DEVICE_LIST_GROW_SIZE;
        iReallocSize *= sizeof(LPMCI_DEVICE_NODE);
        if ((lpTempList = mciReAlloc(MCI_lpDeviceList, iReallocSize)) == NULL)
        {
            DOUT ("wReserveDeviceID:  cannot grow device list\r\n");
            return 0;
        }
        MCI_lpDeviceList = lpTempList;
        MCI_wDeviceListSize += MCI_DEVICE_LIST_GROW_SIZE;
    }

    if (wDeviceID >= MCI_wNextDeviceID) {
        MCI_wNextDeviceID = wDeviceID + 1;
    }

    MCI_lpDeviceList[wDeviceID] = node;

    return wDeviceID;
}

//
// Allocate space for the given string and assign the name to the given
// device.
// Return FALSE if could not allocate memory
//
STATICFN BOOL PASCAL NEAR
mciAddDeviceName(
    LPMCI_DEVICE_NODE nodeWorking,
    LPCSTR lpDeviceName
    )
{
    nodeWorking->lpstrName = mciAlloc(lstrlen(lpDeviceName)+1);

    if (nodeWorking->lpstrName == NULL)
    {
        DOUT ("mciAddDeviceName:  Out of memory allocating device name\r\n");
        return FALSE;
    }

    // copy device name to mci node and lowercase it

    lstrcpy(nodeWorking->lpstrName, lpDeviceName);
//!!    mciToLower(nodeWorking->lpstrName);

    return TRUE;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciAllocateNode | Allocate a new driver entry
 *
 * @parm DWORD | dwFlags | As sent with MCI_OPEN message
 * @parm LPCSTR | lpDeviceName | The device name
 * @parm LPMCI_DEVICE_NODE FAR * | lpnodeNew | new node allocated
 *
 * @rdesc The device ID to the new node.  0 on error.
 *
 */
STATICFN UINT PASCAL NEAR mciAllocateNode(
    DWORD dwFlags,
    LPCSTR lpDeviceName,
    LPMCI_DEVICE_NODE FAR *lpnodeNew
    )
{
    LPMCI_DEVICE_NODE   nodeWorking;
    UINT wDeviceID;

    if ((nodeWorking = mciAlloc(sizeof(MCI_DEVICE_NODE))) == NULL)
    {
        DOUT("Out of memory in mciAllocateNode\r\n");
        return 0;
    }

    // The device ID is a global resource so we fetch it from 32-bit MCI.
    // A node is also allocated on the 32-bit side, and marked as 16-bit. The
    // node will be freed during mciFreeDevice, and acts as a place holder for
    // the device ID.

    wDeviceID = (UINT) mciMessage(THUNK_MCI_ALLOCATE_NODE,
                                  dwFlags,
                                  (DWORD)lpDeviceName,
                                  0L, 0L);

    // Copy the working node to the device list
    nodeWorking->wDeviceID = wDeviceID;
    if (wAddDeviceNodeToList(nodeWorking) == 0)
    {
        DOUT ("mciAllocateNode:  Cannot allocate new node\r\n");
        mciFree(nodeWorking);
        return 0;
    }

    // Initialize node
    nodeWorking->hCreatorTask = GetCurrentTask ();
    nodeWorking->dwMCIFlags |= MCINODE_16BIT_DRIVER;

    if (dwFlags & MCI_OPEN_ELEMENT_ID) {
        // No device name, just an element ID
        nodeWorking->dwElementID = (DWORD)lpDeviceName;
    }
    else {
        if (!mciAddDeviceName (nodeWorking, lpDeviceName))
        {
            mciFree (nodeWorking);
            return 0;
        }
    }
    *lpnodeNew = nodeWorking;

    return nodeWorking->wDeviceID;
}

//
// Reparse the original command parameters
// Returns MCIERR code.  If the reparse fails the original error code
// from the first parsing is returned.
//
STATICFN UINT PASCAL NEAR
mciReparseOpen(
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    UINT wCustomTable,
    UINT wTypeTable,
    LPDWORD lpdwFlags,
    LPMCI_OPEN_PARMS FAR *lplpOpen,
    UINT wDeviceID
    )
{
    LPSTR               lpCommand;
    LPDWORD             lpdwParams;
    UINT                wErr;
    DWORD               dwOldFlags = *lpdwFlags;

// If the custom table contains no open command
    if (wCustomTable == -1 ||
        (lpCommand = FindCommandInTable (wCustomTable, szOpen, NULL)) == NULL)
    {
// Try the type specific table
        lpCommand = FindCommandInTable (wTypeTable, szOpen, NULL);
// If it still cannot be parsed
        if (lpCommand == NULL)
            return lpOpenInfo->wParsingError;
        wCustomTable = wTypeTable;
    }
// A new version of 'open' was found
// Free previous set of parameters
    mciParserFree (lpOpenInfo->lpstrPointerList);
    *lpdwFlags = 0;

    if ((lpdwParams =
            (LPDWORD)mciAlloc (sizeof(DWORD) * MCI_MAX_PARAM_SLOTS))
        == NULL)
            return MCIERR_OUT_OF_MEMORY;

    wErr = mciParseParams (lpOpenInfo->lpstrParams, lpCommand,
                            lpdwFlags,
                            (LPSTR)lpdwParams,
                            sizeof(DWORD) * MCI_MAX_PARAM_SLOTS,
                            &lpOpenInfo->lpstrPointerList, NULL);
// We don't need this around anymore
    mciUnlockCommandTable (wCustomTable);

// If there was a parsing error
    if (wErr != 0)
    {
// Make sure this does not get free'd by mciSendString
        lpOpenInfo->lpstrPointerList = NULL;

        mciFree (lpdwParams);
        return wErr;
    }
    if (dwOldFlags & MCI_OPEN_TYPE)
    {
// Device type was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrDeviceType
            = (*lplpOpen)->lpstrDeviceType;
        *lpdwFlags |= MCI_OPEN_TYPE;
    }
    if (dwOldFlags & MCI_OPEN_ELEMENT)
    {
// Element name was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrElementName
            = (*lplpOpen)->lpstrElementName;
        *lpdwFlags |= MCI_OPEN_ELEMENT;
    }
    if (dwOldFlags & MCI_OPEN_ALIAS)
    {
// Alias name was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->lpstrAlias
            = (*lplpOpen)->lpstrAlias;
        *lpdwFlags |= MCI_OPEN_ALIAS;
    }
    if (dwOldFlags & MCI_NOTIFY)
// Notify was already extracted so add it manually
        ((LPMCI_OPEN_PARMS)lpdwParams)->dwCallback
            = (*lplpOpen)->dwCallback;

    // Replace old parameter list with new list
    *lplpOpen = (LPMCI_OPEN_PARMS)lpdwParams;

    return 0;
}

// See if lpstrDriverName exists in the profile strings of the [mci]
// section and return the keyname in lpstrDevice and the
// profile string in lpstrProfString
// Returns 0 on success or an error code
STATICFN UINT PASCAL NEAR
mciFindDriverName(
    LPCSTR lpstrDriverName,
    LPSTR lpstrDevice,
    LPSTR lpstrProfString,
    UINT wProfLength
    )
{
    LPSTR lpstrEnum, lpstrEnumStart;
    UINT wEnumLen = 100;
    UINT wErr;
    LPSTR lpstrDriverTemp, lpstrProfTemp;

// Enumerate values, trying until they fit into the buffer
    while (TRUE) {
        if ((lpstrEnum = mciAlloc (wEnumLen)) == NULL)
            return MCIERR_OUT_OF_MEMORY;

        wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                    NULL, szNull, lpstrEnum, wEnumLen,
                                    szSystemIni);

        if (*lpstrEnum == '\0')
        {
            mciFree (lpstrEnum);
            return MCIERR_DEVICE_NOT_INSTALLED;
        }

        if (wErr == wEnumLen - 2)
        {
            wEnumLen *= 2;
            mciFree (lpstrEnum);
        } else
            break;
    }

    lpstrEnumStart = lpstrEnum;
    if (lstrlen(lpstrDriverName) >= MCI_MAX_DEVICE_TYPE_LENGTH) {
        wErr = MCIERR_DEVICE_LENGTH;
        goto exit_fn;
    }
    lstrcpy(lpstrDevice, lpstrDriverName);
//!!    mciToLower (lpstrDevice);

// Walk through each string
    while (TRUE) {
        wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                    lpstrEnum, szNull, lpstrProfString,
                                    wProfLength,
                                    szSystemIni);
        if (*lpstrProfString == '\0')
        {
            DOUT ("mciFindDriverName: cannot load valid keyname\r\n");
            wErr = MCIERR_CANNOT_LOAD_DRIVER;
            goto exit_fn;
        }
// See if driver pathname matches input
//!!        mciToLower (lpstrProfString);
        lpstrDriverTemp = lpstrDevice;
        lpstrProfTemp = lpstrProfString;
// Find end of file name
        while (*lpstrProfTemp != '\0' && *lpstrProfTemp != ' ')
            ++lpstrProfTemp;
// Find begining of simple file name
        --lpstrProfTemp;
        while (*lpstrProfTemp != '\\' && *lpstrProfTemp != '/' &&
               *lpstrProfTemp != ':')
            if (--lpstrProfTemp < lpstrProfString)
                break;
        ++lpstrProfTemp;
// Compare to input
        while (*lpstrDriverTemp != '\0')
            if (*lpstrDriverTemp++ != *lpstrProfTemp++ ||
                (UINT)(lpstrProfTemp - lpstrProfString) >= wProfLength)
            {
                --lpstrProfTemp;
                break;
            }
// If the input was contained in the profile string and followed by
// a space or a '.' the we've got it!
        if (*lpstrDriverTemp == '\0' &&
            (*lpstrProfTemp == ' ' || *lpstrProfTemp == '.'))
        {
            if (lstrlen (lpstrEnum) >= MCI_MAX_DEVICE_TYPE_LENGTH)
            {
                DOUT ("mciFindDriverName: device name too long\r\n");
                wErr = MCIERR_DEVICE_LENGTH;
                goto exit_fn;
            }
            lstrcpy (lpstrDevice, lpstrEnum);
            wErr = 0;
            goto exit_fn;
        }
// Skip to next keyname
        while (*lpstrEnum++ != '\0') {}
// Error if no more left
        if (*lpstrEnum == 0)
        {
            wErr = MCIERR_INVALID_DEVICE_NAME;
            goto exit_fn;
        }
    }

exit_fn:
    mciFree (lpstrEnumStart);
    return wErr;
}

//
// Identifies the driver name to load
// Loads the driver
// Reparses open command if necessary
// Sets a default break key
//
// lpOpenInfo contains various info for reparsing
//
// bDefaultAlias indicates that the alias need not be verified because
// it was internally assigned
//
STATICFN UINT PASCAL NEAR
mciLoadDevice(
    DWORD dwFlags,
    LPMCI_OPEN_PARMS lpOpen,
    LPMCI_INTERNAL_OPEN_INFO lpOpenInfo,
    BOOL bDefaultAlias
    )
{
    LPMCI_DEVICE_NODE   nodeWorking;
    HINSTANCE           hDriver;
    UINT                wID, wErr;
    char                strProfileString[MCI_PROFILE_STRING_LENGTH];
    MCI_OPEN_DRIVER_PARMS DriverOpen;
    HDRVR               hDrvDriver;
    LPSTR               lpstrParams;
    LPCSTR              lpstrInstallName, lpstrDeviceName;
    LPSTR               lpstrCopy = NULL;
    LPMCI_OPEN_PARMS    lpOriginalOpenParms = lpOpen;

/* Check for the device name in SYSTEM.INI */
    lpstrInstallName = lpOpen->lpstrDeviceType;
    wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                lpstrInstallName,
                                szNull, (LPSTR)strProfileString,
                                MCI_PROFILE_STRING_LENGTH,
                                szSystemIni);

// If device name not found
    if (wErr == 0)
    {
        int nLen = lstrlen (lpstrInstallName);
        int index;

// Try for the device name with a '1' thru a '9' appended to it

        if ((lpstrCopy = (LPSTR)mciAlloc (nLen + 2)) // space for digit too
            == NULL)
        {
            DOUT ("mciLoadDevice:  cannot allocate device name copy\r\n");
            return MCIERR_OUT_OF_MEMORY;
        }
        lstrcpy (lpstrCopy, lpstrInstallName);

        lpstrCopy[nLen + 1] = '\0';

        for (index = 1; index <= 9; ++index)
        {
            lpstrCopy[nLen] = (char)('0' + index);
            wErr = GetPrivateProfileString ((LPSTR)szMCISectionName,
                                        lpstrCopy,
                                        szNull, (LPSTR)strProfileString,
                                        MCI_PROFILE_STRING_LENGTH,
                                        szSystemIni);
            if (wErr != 0)
                break;
        }
        if (wErr == 0)
        {
            mciFree (lpstrCopy);
            if ((lpstrCopy = (LPSTR)mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH))
                == NULL)
            {
                DOUT ("mciLoadDevice:  cannot allocate device name copy\r\n");
                return MCIERR_OUT_OF_MEMORY;
            }
            if ((wErr = mciFindDriverName (lpstrInstallName, lpstrCopy,
                                           (LPSTR)strProfileString,
                                           MCI_PROFILE_STRING_LENGTH)) != 0)
                goto exit_fn;
        }
        lpstrInstallName = lpstrCopy;
    }

// Break out the device driver pathname and the parameter list

    lpstrParams = strProfileString;

// Eat blanks
    while (*lpstrParams != ' ' && *lpstrParams != '\0')
        ++lpstrParams;

// Terminate driver file name
    if (*lpstrParams == ' ') *lpstrParams++ = '\0';

//Now "strProfileString" is the device driver and "lpstrParams" is
//the parameter string
    if (dwFlags & (MCI_OPEN_ELEMENT | MCI_OPEN_ELEMENT_ID))
        lpstrDeviceName = lpOpen->lpstrElementName;
    else
        lpstrDeviceName = lpOpen->lpstrDeviceType;

    if (dwFlags & MCI_OPEN_ALIAS)
    {
// If the alias is default then we've already checked its uniqueness
        if (!bDefaultAlias &&
            mciGetDeviceIDInternalEx (lpOpen->lpstrAlias,
                                      lpOpenInfo->hCallingTask) != 0)
        {
            wErr = MCIERR_DUPLICATE_ALIAS;
            goto exit_fn;
        }
        lpstrDeviceName = lpOpen->lpstrAlias;
    }

    wID = mciAllocateNode (dwFlags, lpstrDeviceName, &nodeWorking);

    if (wID == 0)
    {
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

// Identify the task which initiated the open command
    nodeWorking->hOpeningTask = lpOpenInfo->hCallingTask;

// Initialize the driver
    DriverOpen.lpstrParams = lpstrParams;
    DriverOpen.wCustomCommandTable = (UINT)-1;
    DriverOpen.wType = 0;
    DriverOpen.wDeviceID = wID;

// Load the driver
    hDrvDriver = OpenDriver ((LPSTR)strProfileString, szMCISectionName,
                          (LPARAM)(DWORD)(LPMCI_OPEN_DRIVER_PARMS)&DriverOpen);
    if (hDrvDriver == NULL)
    {
        DOUT ("mciLoadDevice:  OpenDriver failed\r\n");
// Assume driver has free'd any custom command table when it failed the open
        mciFreeDevice (nodeWorking);
        wErr = MCIERR_CANNOT_LOAD_DRIVER;
        goto exit_fn;
    }

    lpOpen->wDeviceID = wID;
    lpOpen->wReserved0 = 0;

    hDriver = GetDriverModuleHandle (hDrvDriver);

    nodeWorking->hDrvDriver = hDrvDriver;
    nodeWorking->hDriver = hDriver;

// Driver provides custom device table and type
    nodeWorking->wCustomCommandTable = DriverOpen.wCustomCommandTable;
    nodeWorking->wDeviceType = DriverOpen.wType;

// Load driver's type table
    if ((nodeWorking->wCommandTable = mciLoadTableType (DriverOpen.wType))
        == -1)
// Load from a file if necessary
        nodeWorking->wCommandTable =
            mciLoadCommandResource (ghInst, lpOpen->lpstrDeviceType,
                                    DriverOpen.wType);

// Record this for 'sysinfo installname'
    if ((nodeWorking->lpstrInstallName =
                    mciAlloc (lstrlen (lpstrInstallName) + 1))
        == NULL)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = MCIERR_OUT_OF_MEMORY;
        goto exit_fn;
    } else
        lstrcpy (nodeWorking->lpstrInstallName, lpstrInstallName);

// Reparse the input command if no type was known the first time or if
// there was a custom command table
// and there were any open command parameters
    if (lpOpenInfo->lpstrParams != NULL)
    {
        if ((wErr = mciReparseOpen (lpOpenInfo,
                                    nodeWorking->wCustomCommandTable,
                                    nodeWorking->wCommandTable,
                                    &dwFlags, &lpOpen, wID)) != 0)
        {
            mciCloseDevice (wID, 0L, NULL, FALSE);
            goto exit_fn;
        }
// If there is no custom command table but mciSendString had a parsing
// error then close the device and report the error now
    } else if (lpOpenInfo->wParsingError != 0)
    {
        mciCloseDevice (wID, 0L, NULL, FALSE);
        wErr = lpOpenInfo->wParsingError;
        goto exit_fn;
    }

/* Send MCI_OPEN_DRIVER command to device */
    wErr = LOWORD(mciSendCommand (wID, MCI_OPEN_DRIVER,
                                 dwFlags, (DWORD)lpOpen));

// If the OPEN failed then close the device (don't send a CLOSE though)
    if (wErr != 0)
        mciCloseDevice (wID, 0L, NULL, FALSE);
    else
// Set default break key
        mciSetBreakKey (nodeWorking->wDeviceID, VK_CANCEL, NULL);

// If we replaced the open parms here then free them
    if (lpOriginalOpenParms != lpOpen && lpOpen != NULL)
        mciFree (lpOpen);

exit_fn:
    if (lpstrCopy != NULL)
        mciFree (lpstrCopy);

    return wErr;
}

/*
 * @doc INTERNAL MCI
 * @func BOOL | mciExtractDeviceType | If the given device name ends with
 * a file extension (.???) then try to get a typename from the
 * [mci extensions] section of WIN.INI
 *
 * @parm LPCSTR | lpstrDeviceName | The name to get the type from
 *
 * @parm LPSTR | lpstrDeviceType | The device type, returned to caller.
 *
 * @parm UINT | wBufLen | The length of the output buffer
 *
 * @rdesc TRUE if the type was found, FALSE otherwise
 *
 */
BOOL PASCAL NEAR mciExtractDeviceType (
LPCSTR lpstrDeviceName,
LPSTR lpstrDeviceType,
UINT wBufLen)
{
    LPCSTR lpstrExt = lpstrDeviceName;
    int i;

// Goto end of string
    while (*lpstrExt != '\0')
    {
// '!' case is handled elsewhere
        if (*lpstrExt == '!')
            return FALSE;
        ++lpstrExt;
    }

// Must be at least 2 characters in string
    if (lpstrExt - lpstrDeviceName < 2)
        return FALSE;

    lpstrExt -= 1;

// Does not count if last character is '.'
    if (*lpstrExt == '.')
        return FALSE;

    lpstrExt -= 1;
// Now looking at second to the last character.  Check this and the two
// previous characters for a '.'

    for (i=1; i<=3; ++i)
    {
// Cannot have path separator here
        if (*lpstrExt == '/' || *lpstrExt == '\\')
            return FALSE;

        if (*lpstrExt == '.')
        {
            ++lpstrExt;
            if (GetProfileString (MCI_EXTENSIONS, lpstrExt, szNull,
                                            lpstrDeviceType, wBufLen) != 0)
                return TRUE;
        }
        if (lpstrExt == lpstrDeviceName)
            return FALSE;
        --lpstrExt;
    }
    return FALSE;
}

// Copy characters up to cSeparater into output which is allocated
// by this function using mciAlloc.  Return the input pointer pointing
// to the character after cSeparator
// unless the separator is '\0' in which case it points to the end.
//
// Return the allocated pointer
//
// If bMustFind then the output string is created only if the token
// is found and is otherwise NULL.  Else the output string is always created.
//
// cSeparator is ignored inside matching quotes ("abd"), the quotes
// are not coppied and doubled
// quotes inside are compressed to one.  There must be a terminating quote.
// Quotes are treated normally unless the first character is a quote
//
// Function return value is 0 or an MCIERR code.  A missing separator does
// not cause an error return.
UINT PASCAL NEAR mciEatToken (LPCSTR FAR *lplpstrInput, char cSeparater,
                  LPSTR FAR *lplpstrOutput, BOOL bMustFind)
{
    LPCSTR lpstrEnd = *lplpstrInput, lpstrCounter;
    LPSTR  lpstrOutput;
    UINT wLen;
    BOOL bInQuotes = FALSE, bParseQuotes = TRUE, bQuoted = FALSE;

// Clear output
   *lplpstrOutput = NULL;

// Scan for token or end of string
    while ((*lpstrEnd != cSeparater || bInQuotes) && *lpstrEnd != '\0')
    {
// If quote
        if (*lpstrEnd == '"' && bParseQuotes)
        {
// If inside quotes
            if (bInQuotes)
            {
// If next character is a quote also
                if (*(lpstrEnd + 1) == '"')
// Skip it
                    ++lpstrEnd;
                else
                    bInQuotes = FALSE;
            } else
            {
                bInQuotes = TRUE;
                bQuoted = TRUE;
            }
        } else if (!bInQuotes)
        {
            if (bQuoted)
                return MCIERR_EXTRA_CHARACTERS;
// A non-quote was read first so treat any quotes as normal characters
            bParseQuotes = FALSE;
        }
        ++lpstrEnd;
    }

    if (bInQuotes)
        return MCIERR_NO_CLOSING_QUOTE;

// Fail if the token was not found and bMustFind is TRUE
    if (*lpstrEnd != cSeparater && bMustFind)
        return 0;

// Length of new string (INCLUDES QUOTES NOT COPIED)
    wLen = lpstrEnd - *lplpstrInput + 1;

    if ((*lplpstrOutput = mciAlloc (wLen)) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Copy into allocated space
    lpstrCounter = *lplpstrInput;
    lpstrOutput = *lplpstrOutput;
    bInQuotes = FALSE;

    while (lpstrCounter != lpstrEnd)
    {
        if (*lpstrCounter == '"' && bParseQuotes)
        {
            if (bInQuotes)
            {
// If this is a doubled quote
                if (*(lpstrCounter + 1) == '"')
// Copy it
                    *lpstrOutput++ = *lpstrCounter++;
                else
                    bInQuotes = FALSE;
            } else
                bInQuotes = TRUE;
// Skip the quote
            ++lpstrCounter;
        } else
            *lpstrOutput++ = *lpstrCounter++;
    }

    *lpstrOutput = '\0';
    if (*lpstrEnd == '\0')
        *lplpstrInput = lpstrEnd;
    else
        *lplpstrInput = lpstrEnd + 1;

    return 0;
}

// Take the type number from the open parameters and return
// it as a string in lplpstrType which must be free'd with mciFree
// Returns 0 or an MCI error code
UINT PASCAL NEAR mciExtractTypeFromID (
LPMCI_OPEN_PARMS lpOpen)
{
    int nSize;
    LPSTR lpstrType;

    if ((lpstrType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH)) == NULL)
        return MCIERR_OUT_OF_MEMORY;

// Load the type string corresponding to the ID
    if ((nSize = LoadString (ghInst,
                                LOWORD ((DWORD)lpOpen->lpstrDeviceType),
                                lpstrType, MCI_MAX_DEVICE_TYPE_LENGTH)) == 0)
        return MCIERR_EXTENSION_NOT_FOUND;

// Add ordinal (if any) onto the end of the device type name
    if (HIWORD (lpOpen->lpstrDeviceType) != 0)
    {
        if (nSize > MCI_MAX_DEVICE_TYPE_LENGTH - 11)
        {
            DOUT ("mciExtractTypeFromID:  type + ordinal too long\r\n");
            return MCIERR_DEVICE_ORD_LENGTH;
        }

        wsprintf (lpstrType + nSize, szUnsignedFormat,
                    HIWORD ((DWORD)lpOpen->lpstrDeviceType));
    }
    lpOpen->lpstrDeviceType = lpstrType;
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciOpenDevice | Open an MCI device for access.
 * Used in processing the MCI_OPEN message.
 *
 * @parm DWORD | dwFlags | Open Flags
 * @parm LPMCI_OPEN_PARMS | lpOpen | Description of device
 *
 * @rdesc 0 if successful or an error code
 * @flag MCIERR_INVALID_DEVICE_NAME | Name not known
 * @flag MCIERR_DEVICE_OPEN | Device is already open and is not sharable
 *
 * @comm This function does the following:
 * 1) Check to see if device is already open.  If so, return an error
 *
 * 2) Locate the device name in the SYSTEM.INI file and load
 *    the corresponding device driver DLL
 *
 * 3) Allocate and initialize a new device description block
 *
 */
UINT NEAR PASCAL mciOpenDevice (
DWORD dwStartingFlags,
LPMCI_OPEN_PARMS lpOpen,
LPMCI_INTERNAL_OPEN_INFO lpOpenInfo)
{
    LPSTR               lpstrNewType = NULL;
    UINT                wID, wReturn;
    LPCSTR              lpstrDeviceName;
    LPSTR               lpstrNewElement = NULL;
    BOOL                bFromTypeID = FALSE;
    LPCSTR               lpstrOriginalType;
    LPCSTR               lpstrOriginalElement;
    LPCSTR               lpstrOriginalAlias;
    DWORD               dwFlags = dwStartingFlags;
    BOOL                bDefaultAlias = FALSE;

// Initialize
    if (lpOpen == NULL)
        return MCIERR_NULL_PARAMETER_BLOCK;
    lpstrOriginalType = lpOpen->lpstrDeviceType;
    lpstrOriginalElement = lpOpen->lpstrElementName;
    lpstrOriginalAlias = lpOpen->lpstrAlias;

// The type number is given explicitly, convert it to a type name
    if (dwFlags & MCI_OPEN_TYPE_ID)
        if ((wReturn = mciExtractTypeFromID (lpOpen)) != 0)
            return wReturn;
        else
            bFromTypeID = TRUE;

// The device name is the device type of a simple device or the device
// element of a compound device

    if (dwFlags & MCI_OPEN_ELEMENT)
        lpstrDeviceName = lpstrOriginalElement;
    else if (dwFlags & MCI_OPEN_TYPE)
        lpstrDeviceName = lpOpen->lpstrDeviceType;
    else
        return MCIERR_MISSING_PARAMETER;

    if (lpstrDeviceName == NULL)
    {
        DOUT ("mciOpenDevice:  Device name is NULL\r\n");
        return MCIERR_INVALID_DEVICE_NAME;
    }

// Is the device already open?
    if (dwFlags & MCI_OPEN_ELEMENT_ID)
        wID = mciGetDeviceIDFromElementID ((DWORD)lpstrDeviceName,
                                           lpOpen->lpstrDeviceType);
    else
        wID = mciGetDeviceIDInternalEx ((dwFlags & MCI_OPEN_ALIAS ?
                                       lpOpen->lpstrAlias : lpstrDeviceName),
                                       lpOpenInfo->hCallingTask);

// If the device is open already then return an error
    if (wID != 0)
        return dwFlags & MCI_OPEN_ALIAS ? MCIERR_DUPLICATE_ALIAS :
                                          MCIERR_DEVICE_OPEN;

// The device is not already open in that task by the name

// If the type was derived then skip all this crap
    if (bFromTypeID)
        goto load_device;

// If an element name is given but no type name (only via mciSendCommand)
    if (dwFlags & MCI_OPEN_ELEMENT && !(dwFlags & MCI_OPEN_TYPE))
    {
        lpstrNewType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH);
        if (lpstrNewType == NULL)
            return MCIERR_OUT_OF_MEMORY;

// Try to get the device type from the element name via a file extension
        if (mciExtractDeviceType (lpstrOriginalElement,
                                    lpstrNewType, MCI_MAX_DEVICE_TYPE_LENGTH))
        {
            lpOpen->lpstrDeviceType = lpstrNewType;
            dwFlags |= MCI_OPEN_TYPE;
        } else
        {
            mciFree (lpstrNewType);
            return MCIERR_EXTENSION_NOT_FOUND;
        }
    } else if (dwFlags & MCI_OPEN_TYPE && !(dwFlags & MCI_OPEN_ELEMENT))
// A type name is given but no element
    {
// Try to extract a device type from the given device name via a file extension
        lpstrNewType = mciAlloc (MCI_MAX_DEVICE_TYPE_LENGTH);
        if (lpstrNewType == NULL)
            return MCIERR_OUT_OF_MEMORY;
        if (mciExtractDeviceType (lpOpen->lpstrDeviceType, lpstrNewType,
                                    MCI_MAX_DEVICE_TYPE_LENGTH))
        {
// Fix up the type and element names
            dwFlags |= MCI_OPEN_ELEMENT;
            lpOpen->lpstrElementName = lpOpen->lpstrDeviceType;
            lpOpen->lpstrDeviceType = lpstrNewType;
        } else
// Failed to extract type so...
// Try to get a compound element name ('!' separator)
        {
            LPCSTR lpstrTemp = lpOpen->lpstrDeviceType;

            mciFree (lpstrNewType);
            lpstrNewType = NULL;

            if ((wReturn = mciEatToken (&lpstrTemp, '!', &lpstrNewType, TRUE))
                != 0)
                goto cleanup;
            else if (lpstrNewType != NULL)
            {
                if ((wReturn = mciEatToken (&lpstrTemp, '\0',
                                            &lpstrNewElement, TRUE))
                    != 0)
                    goto cleanup;
                else if (lpstrNewElement != NULL &&
                           *lpstrNewElement != '\0')
                {
// See if this element name is in use
                    if (!(dwFlags & MCI_OPEN_ALIAS))
                        if (mciGetDeviceIDInternalEx (lpstrNewElement,
                                                      lpOpenInfo->hCallingTask))
                        {
                            wReturn = MCIERR_DEVICE_OPEN;
                            goto cleanup;
                        }
// Swap type and element for new ones
                    lpOpen->lpstrElementName = lpstrNewElement;
                    lpOpen->lpstrDeviceType = lpstrNewType;
                    dwFlags |= MCI_OPEN_ELEMENT;
                }
            }
        }
    } else
        lpstrNewType = NULL;

// Tack on a default alias if none is given
    if (! (dwFlags & MCI_OPEN_ALIAS))
    {
        LPCSTR lpstrAlias;

// If an element name exists then the alias is the element name
        if (dwFlags & MCI_OPEN_ELEMENT)
        {
// If a device ID was specified then there is no alias
            if (dwFlags & MCI_OPEN_ELEMENT_ID)
                lpstrAlias = NULL;
            else
                lpstrAlias = lpOpen->lpstrElementName;
// Otherwise the alias is the device type
        } else
            lpstrAlias = lpOpen->lpstrDeviceType;

        if (lpstrAlias != NULL)
        {
            lpOpen->lpstrAlias = lpstrAlias;
            dwFlags |= MCI_OPEN_ALIAS;
            bDefaultAlias = TRUE;
        }
    }

load_device:;
    wReturn = mciLoadDevice (dwFlags, lpOpen, lpOpenInfo, bDefaultAlias);

cleanup:
    if (lpstrNewElement != NULL)
        mciFree (lpstrNewElement);
    if (lpstrNewType != NULL)
        mciFree (lpstrNewType);
    if (bFromTypeID)
        mciFree ((LPSTR)lpOpen->lpstrDeviceType);

// Replace original items
    lpOpen->lpstrDeviceType = lpstrOriginalType;
    lpOpen->lpstrElementName = lpstrOriginalElement;
    lpOpen->lpstrAlias = lpstrOriginalAlias;

    return wReturn;
}

STATICFN void PASCAL NEAR
mciFreeDevice(
    LPMCI_DEVICE_NODE nodeWorking
    )
{
    UINT wID = nodeWorking->wDeviceID;

    mciMessage(THUNK_MCI_FREE_NODE, (DWORD) nodeWorking->wDeviceID, 0L, 0L, 0L);

    if (nodeWorking->lpstrName != NULL)
        mciFree (nodeWorking->lpstrName);

    if (nodeWorking->lpstrInstallName != NULL)
        mciFree (nodeWorking->lpstrInstallName);

    mciFree(MCI_lpDeviceList[wID]);
    MCI_lpDeviceList[wID] = NULL;

/* If this was the last device in the list, decrement next ID value */
    if (wID + 1 == MCI_wNextDeviceID) {
        --MCI_wNextDeviceID;
    }
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciCloseDevice | Close an MCI device.  Used in
 * processing the MCI_CLOSE message.
 *
 * @parm UINT | wID | The ID of the device to close
 * @parm DWORD | dwFlags | Close Flags
 * @parm LPMCI_GENERIC_PARMS | lpClose | Generic parameters
 * @parm BOOL | bCloseDriver | TRUE if the CLOSE command should be sent
 * on to the driver.
 *
 * @rdesc 0 if successful or an error code
 *
 * @comm This function sends an MCI_CLOSE_DRIVER message to the corresponding
 * driver if the use count is zero and then unloads the driver DLL
 *
 */
UINT NEAR PASCAL mciCloseDevice (
UINT wID,
DWORD dwFlags,
LPMCI_GENERIC_PARMS lpGeneric,
BOOL bCloseDriver)
{
    LPMCI_DEVICE_NODE nodeWorking;
    UINT wErr, wTable;

    nodeWorking = MCI_lpDeviceList[wID];

    if (nodeWorking == NULL)
    {
        DOUT ("mciCloseDevice:  NULL node from device ID--error if not auto-close\r\n");
        return 0;
    }

// If a close is in progress (usually this message comes from a Yield
// after a mciDriverNotify actuated by the active close) then exit
    if (nodeWorking->dwMCIFlags & MCINODE_ISCLOSING)
        return 0;

    nodeWorking->dwMCIFlags |= MCINODE_ISCLOSING;
    if (bCloseDriver)
    {
        MCI_GENERIC_PARMS   GenericParms;
// Make fake generic params if close came internally
        if (lpGeneric == NULL)
            lpGeneric = &GenericParms;

        wErr = LOWORD(mciSendCommand (wID, MCI_CLOSE_DRIVER, dwFlags,
                                            (DWORD)lpGeneric));
    }
    else
        wErr = 0;

// Must zero this to allow the table to be freed by the driver
    nodeWorking->wCustomCommandTable = 0;

    wTable = nodeWorking->wCommandTable;
// Must zero this to allow the table to be freed
    nodeWorking->wCommandTable = 0;
    mciFreeCommandResource (wTable);

    CloseDriver (nodeWorking->hDrvDriver, 0L, 0L);

    mciFreeDevice (nodeWorking);

    return wErr;
}

/*
 * @doc INTERNAL MCI DDK
 * @api DWORD | mciGetDriverData | Returns a pointer to the instance
 * data associated with an MCI device
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @rdesc The driver instance data.  On error, returns 0 but since
 * the driver data might be zero, this cannot be verified by the caller
 * unless the instance data is known to be non-zero (e.g. a pointer)
 *
 */
DWORD WINAPI mciGetDriverData (
UINT wDeviceID)
{
    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        DOUT ("mciGetDriverData:  invalid device ID\r\n");
        return 0;
    }
    return MCI_lpDeviceList[wDeviceID]->lpDriverData;
}

/*
 * @doc INTERNAL MCI DDK
 * @func BOOL | mciSetDriverData | Sets the instance
 * data associated with an MCI device
 *
 * @parm UINT | wDeviceID | The MCI device ID
 *
 * @parm DWORD | dwData | Driver data to set
 *
 * @rdesc FALSE if the device ID is not known or there is insufficient
 * memory to load the device description, else TRUE.
 *
 */
BOOL WINAPI mciSetDriverData (
UINT wDeviceID,
DWORD dwData)
{
    if (!MCI_VALID_DEVICE_ID(wDeviceID))
    {
        DOUT ("mciSetDriverData:  invalid device ID\r\n");
        return FALSE;
    }
    MCI_lpDeviceList[wDeviceID]->lpDriverData = dwData;
    return TRUE;
}

/*
 * @doc INTERNAL MCI DDK
 * @api UINT | mciDriverYield | Used in a driver's idle loop
 * to yield to Windows
 *
 * @parm UINT | wDeviceID | Device ID that is yielding.
 *
 * @rdesc Non-zero if the driver should abort the operation.
 *
 */
UINT WINAPI mciDriverYield (
UINT wDeviceID)
{
    if (MCI_VALID_DEVICE_ID(wDeviceID))
    {
        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        if (node->fpYieldProc != NULL)
            return (node->fpYieldProc)(wDeviceID, node->dwYieldData);
    }

    Yield();
    return 0;
}

/*
 * @doc EXTERNAL MCI
 * @api BOOL | mciSetYieldProc | This function sets the address
 * of a callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be assigned.
 *
 * @parm YIELDPROC | fpYieldProc | Specifies the callback procedure
 * to be called when the given device is yielding. Specify a NULL value
 * to disable any existing yield procedure.
 *
 * @parm DWORD | dwYieldData | Specifies the data sent to the yield procedure
 * when it is called for the given device.
 *
 * @rdesc Returns TRUE if successful. Returns FALSE for an invalid device ID.
 *
 * @cb int CALLBACK | YieldProc | <f YieldProc> is a placeholder for
 * the application-supplied function name. Export the actual name
 * by including it in the EXPORTS statement in your module-definition
 * file.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device.
 *
 * @parm DWORD | dwData | Specifies the application-supplied yield data
 * originally supplied in the <p dwYieldData> parameter.
 *
 * @rdesc Return zero to continue the operation. To cancel the operation,
 * return a nonzero value.
 *
 * @comm This call overrides any previous yield procedure for this device.
 *
 */
BOOL WINAPI mciSetYieldProc (
UINT wDeviceID,
YIELDPROC fpYieldProc,
DWORD dwYieldData)
{
    V_CALLBACK((FARPROC)fpYieldProc, FALSE);

    if (Is16bitDrv(wDeviceID)) {

        LPMCI_DEVICE_NODE node = MCI_lpDeviceList[wDeviceID];

        node->fpYieldProc = fpYieldProc;
        node->dwYieldData = dwYieldData;
        return TRUE;
    }

    return (BOOL)mciMessage( THUNK_MCI_SETYIELDPROC, (DWORD)wDeviceID,
                             (DWORD)fpYieldProc, dwYieldData, 0L );

}

/*
 * @doc EXTERNAL MCI
 * @api YIELDPROC | mciGetYieldProc | This function gets the address
 * of the callback procedure to be called periodically when an MCI device
 * is completing a command specified with the WAIT flag.
 *
 * @parm UINT | wDeviceID | Specifies the device ID of the MCI device to
 * which the yield procedure is to be retrieved from.
 *
 * @parm LPDWORD | lpdwYieldData | Optionally specifies a buffer to place
 * the yield data passed to the function in.  If the parameter is NULL, it
 * is ignored.
 *
 * @rdesc Returns the current yield proc if any, else returns NULL for an
 * invalid device ID.
 *
 */
YIELDPROC WINAPI mciGetYieldProc (
UINT wDeviceID,
LPDWORD lpdwYieldData)
{
    /*
    ** Is this a 16 bit device ID ?
    */
    if (Is16bitDrv(wDeviceID)) {

        if (lpdwYieldData != NULL) {
            V_WPOINTER(lpdwYieldData, sizeof(DWORD), NULL);
            *lpdwYieldData = MCI_lpDeviceList[wDeviceID]->dwYieldData;
        }
        return MCI_lpDeviceList[wDeviceID]->fpYieldProc;
    }

    /*
    ** No, so pass it on to the 32 bit code.
    */
    return (YIELDPROC)mciMessage( THUNK_MCI_GETYIELDPROC, (DWORD)wDeviceID,
                                  (DWORD)lpdwYieldData, 0L, 0L );
}

/*
 * @doc INTERNAL MCI
 * @api int | mciBreakKeyYieldProc | Procedure called to check a
 * key state for the given device
 *
 * @parm UINT | wDeviceID | Device ID which is yielding
 *
 * @parm DWORD | dwYieldData | Data for this device's yield proc
 *
 * @rdesc Non-zero if the driver should abort the operation. Currently
 * always returns 0.
 *
 */
int CALLBACK mciBreakKeyYieldProc (
UINT wDeviceID,
DWORD dwYieldData)
{
    HWND hwndCheck;
    int nState;

    hwndCheck = (HWND)HIWORD (dwYieldData);
    if (hwndCheck == NULL || hwndCheck == GetActiveWindow())
    {
        nState = GetAsyncKeyState (LOWORD(dwYieldData));

// Break if key is down or has been down
        if (nState & 1)
        {
            MSG msg;

            while (PeekMessage (&msg, hwndCheck, WM_KEYFIRST, WM_KEYLAST,
                   PM_REMOVE));
            return -1;
        }
    }
    Yield();
    return 0;
}

/*
 * @doc INTERNAL MCI
 * @func UINT | mciSetBreakKey | Set a key which will break a wait loop
 * for a given driver
 *
 * @parm UINT | wDeviceID | The device ID to assign a break key to
 *
 * @parm int | nVirtKey | Virtual key code to trap
 *
 * @parm HWND | hwndTrap | The handle to a window that must be active
 * for the key to be trapped.  If NULL then all windows will be checked
 *
 * @rdesc TRUE if successful, FALSE if invalid device ID
 *
 */
UINT PASCAL NEAR mciSetBreakKey (
UINT wDeviceID,
int nVirtKey,
HWND hwndTrap)
{
    return mciSetYieldProc (wDeviceID, mciBreakKeyYieldProc,
                         MAKELONG (nVirtKey, hwndTrap));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmiocf.h ===
/* mmiocf.h
 *
 * Multimedia File I/O Library.
 *
 * This include file contains declarations required for compound file support.
 */

#define	PC(hmmcf)	((PMMCF)(hmmcf))
#define	CP(pmmcf)	((HMMCF)(pmmcf))

typedef HLOCAL HMMCF;		// a handle to an open RIFF compound file

typedef struct _MMCFINFO	// structure for representing CTOC header info.
{
	DWORD		dwHeaderSize;	// size of CTOC header (w/o entries)
	DWORD		dwEntriesTotal;	// no. of entries in table of contents
	DWORD		dwEntriesDeleted; // no. of entries ref. to. del. ent.
	DWORD		dwEntriesUnused; // no. of entries that are not used
	DWORD		dwBytesTotal;	// total bytes of CGRP contents
	DWORD		dwBytesDeleted;	// total bytes of deleted CGRP elements
	DWORD		dwHeaderFlags;	// flags
	WORD		wEntrySize;	// size of each <CTOC-table-entry>
	WORD		wNameSize;	// size of each <achName> field
	WORD		wExHdrFields;	// number of "extra header fields"
	WORD		wExEntFields;	// number of "extra entry fields"
} MMCFINFO, FAR *LPMMCFINFO;

typedef struct _MMCTOCENTRY	// structure for representing CTOC entry info.
{
	DWORD		dwOffset;	// offset of element inside CGRP chunk
	DWORD		dwSize;		// size of element inside CGRP chunk
	DWORD		dwMedType;	// media element type of CF element
	DWORD		dwMedUsage;	// media element usage information
	DWORD		dwCompressTech;	// media element compression technique
	DWORD		dwUncompressBytes; // size after decompression
	DWORD		adwExEntField[1]; // extra CTOC table entry fields
} MMCTOCENTRY, FAR *LPMMCTOCENTRY;

/* <dwFlags> field of MMIOINFO structure -- many same as OpenFile() flags */
#define MMIO_CTOCFIRST	0x00020000	// mmioCFOpen(): put CTOC before CGRP

/* flags for other functions */
#define MMIO_FINDFIRST		0x0010	// mmioCFFindEntry(): find first entry
#define MMIO_FINDNEXT		0x0020	// mmioCFFindEntry(): find next entry
#define MMIO_FINDUNUSED 	0x0040	// mmioCFFindEntry(): find unused entry
#define MMIO_FINDDELETED	0x0080	// mmioCFFindEntry(): find deleted entry

/* message numbers for MMIOPROC */
#define MMIOM_GETCF		10	// get HMMCF of CF element
#define MMIOM_GETCFENTRY	11	// get ptr. to CTOC table entry

/* four character codes used to identify standard built-in I/O procedures */
#define FOURCC_BND	mmioFOURCC('B', 'N', 'D', ' ')

/* <dwHeaderFlags> field of MMCFINFO structure */
#define CTOC_HF_SEQUENTIAL	0x00000001 // CF elements in same order as CTOC
#define CTOC_HF_MEDSUBTYPE	0x00000002 // <dwMedUsage> is a med. el. subtype

/* CTOC table entry flags */
#define CTOC_EF_DELETED		0x01	// CF element is deleted
#define CTOC_EF_UNUSED		0x02	// CTOC entry is unused

/* CF I/O prototypes */
HMMCF API mmioCFOpen(LPSTR szFileName, DWORD dwFlags);
HMMCF API mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo,
	DWORD dwFlags);
WORD API mmioCFClose(HMMCF hmmcf, WORD wFlags);
DWORD API mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
DWORD API mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb);
LPMMCTOCENTRY API mmioCFFindEntry(HMMCF hmmcf, LPSTR szName,
	WORD wFlags, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmio.c ===
/* mmio.c
 *
 * Basic MMIO functions.
 *
 * Implementation notes:
 *
 * The "current disk offset" is the disk offset (i.e. the location
 * in the disk file) that the next MMIOM_READ or MMIOM_WRITE will
 * read from or write to.  The I/O procedure maintains the
 * <lDiskOffset> field of the file's MMIO structure so that
 * <lDiskOffset> is equal to the current disk offset.
 *
 * The "current buffered offset" is the disk offset that the next
 * mmioRead() or mmioWrite() call would read from or write to.
 * The current buffered offset is defined as
 *
 *	<lBufOffset> + (<pchNext> - <pchBuffer>)
 *
 * since <lBufOffset> is the disk offset of the start of the buffer
 * and <pchNext> corresponds to the current buffered offset.
 *
 * If the file is unbuffered, then <pchBuffer>, <pchNext>,
 * <pchEndRead> and <pchEndWrite> will always be NULL, and
 * <lBufOffset> will always be considered the "current buffered
 * offset", i.e. mmioRead() and mmioWrite() will read/write
 * at this offset.
 *
 *
 * Except right at the beginning of mmioOpen(), the MMIO_ALLOCBUF
 * flag is set if and only if the pchBuffer field points to a block
 * of global memory that MMIO has allocated.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmioi.h"
#include "mmsysi.h"

/* The I/O procedure map is a linked list of IOProcMPEntry structures.
 * The head of the list, <gIOProcMapHead> is a pointer node to the last
 * entry registered.  The first few elements of the list are the predefined
 * global IO procedures below -- these all have <hTask> equal to NULL so
 * that no task can unregister them.
 */
static LRESULT CALLBACK mmioDOSIOProc(LPSTR, UINT, LPARAM, LPARAM);
static LRESULT CALLBACK mmioMEMIOProc(LPSTR, UINT, LPARAM, LPARAM);

static IOProcMapEntry gIOProcMaps[] = {
	FOURCC_DOS, mmioDOSIOProc, NULL, STATICIOPROC, &gIOProcMaps[1],
	FOURCC_MEM, mmioMEMIOProc, NULL, STATICIOPROC, NULL,
};
IOProcMapEntry NEAR * gIOProcMapHead = gIOProcMaps;

/* private prototypes */
static LONG NEAR PASCAL mmioDiskIO(PMMIO pmmio, UINT wMsg, HPSTR pch, LONG cch);
static UINT NEAR PASCAL mmioExpandMemFile(PMMIO pmmio, LONG lExpand);

/* @doc INTERNAL

@func	LPMMIOPROC | FindIOProc | This function locates previously installed
	IO procedure.
*/
static LPMMIOPROC PASCAL NEAR
FindIOProc(FOURCC fccIOProc, HTASK htask)
{
	IOProcMapEntry *pEnt;		// an entry in linked list

	/* walk through the linked list, first looking for an entry with
	 * identifier <fccIOProc> that was added by the current task, then
	 * looking for global entries.
	 */

	for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
		if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask))
			return pEnt->pIOProc;

	for (pEnt = gIOProcMapHead; pEnt; pEnt = pEnt->pNext)
		if (!pEnt->hTask && (pEnt->fccIOProc == fccIOProc))
			return pEnt->pIOProc;

	return NULL;
}

/* @doc INTERNAL

@func	LPMMIOPROC | RemoveIOProc | This function removes previously installed
	IO procedure.
*/
static LPMMIOPROC PASCAL NEAR
RemoveIOProc(FOURCC fccIOProc, HTASK htask)
{
	IOProcMapEntry *pEnt;		// an entry in linked list
	IOProcMapEntry *pEntPrev;	// the entry before <pEnt>

	/* walk through the linked list, looking for an entry with
	 * identifier <fccIOProc> that was added by the current task
	 */
	for (pEntPrev = NULL, pEnt = gIOProcMapHead; pEnt; pEntPrev = pEnt, pEnt = pEnt->pNext)
		if ((pEnt->fccIOProc == fccIOProc) && (pEnt->hTask == htask)) {
			LPMMIOPROC	pIOProc;

			if (pEnt->wFlags & STATICIOPROC)
				return NULL;
			pIOProc = pEnt->pIOProc;
			if (pEntPrev)
				pEntPrev->pNext = pEnt->pNext;
			else
				gIOProcMapHead = pEnt->pNext;
			FreeHandle((HMMIO) pEnt);
			return pIOProc;
		}
	return NULL;
}

/* @doc INTERNAL

@func	void | SetIOProc | This function sets the physical IO procedure
	based on either the file name or the parameters within the
	<p lpmmioinfo> structure passed.

@parm	LPCSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to open. If no I/O procedure is

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f SetIOProc> in determining the IO procedure to use.  The
	<e MMIOINFO.pIOProc> element is set to the procedure found.

@rdesc	Nothing.
*/

static void NEAR PASCAL
SetIOProc(LPCSTR szFileName, LPMMIOINFO lpmmio)
{
	/* If the IOProc is not given, see if the file name implies that
	 * <szFileName> is either a RIFF compound file or some kind of
	 * other registered storage system -- look for the last CFSEPCHAR in
	 * the name, e.g. '+' in "foo.bnd+bar.hlp+blorg.dib", and figure
	 * that the IOProc ID is the extension of the compound file name,
	 * e.g. the extension of "foo.bnd+bar.hlp", i.e. 'HLP '.
	 *
	 * Alternatively, if <szFileName> is NULL, then assume that
	 * <lpmmio->adwInfo[0]> is a DOS file handle.
	*/
	if (lpmmio->pIOProc == NULL)
	{
		if (lpmmio->fccIOProc == NULL)
		{
			if (szFileName != NULL)
			{
				LPSTR	pch;

				/* see if <szFileName> contains CFSEPCHAR */
				if ((pch = fstrrchr(szFileName, CFSEPCHAR)) != NULL)
				{
					/* find the extension that precedes CFSEPCHAR,
					 * e.g. "hlp" in "foo.bnd+bar.hlp+blorg.dib"
					*/
					while ((pch > szFileName) && (*pch != '.') && (*pch != ':') && (*pch != '\\'))
						pch--;
					if (*pch == '.')
					{
						char	aszFour[sizeof(FOURCC)+1];
						int	i;

						for (i = 0, pch++; i < sizeof(FOURCC); i++)
							if (*pch == CFSEPCHAR)
								aszFour[i] = (char)0;
							else
								aszFour[i] = *pch++;
						aszFour[sizeof(FOURCC)] = (char)0;
						lpmmio->fccIOProc = mmioStringToFOURCC(aszFour, MMIO_TOUPPER);
					}
				}
			}
			/* if the caller didn't specify an IOProc, and the code above
			 * didn't determine an IOProc ID, then the default is the DOS
			 * IOProc.
			*/
			if (lpmmio->fccIOProc == NULL)
				lpmmio->fccIOProc = FOURCC_DOS;
		}

		/* unless an IOProc address is specified explicitly, look up the
		 * IOProc in the global IOProc ID-to-address table -- the default
		 * is 'DOS' since we'll assume that custom storage system I/O
		 * procedures would have been installed
		*/
		lpmmio->pIOProc = FindIOProc(lpmmio->fccIOProc, lpmmio->htask ? lpmmio->htask : GetCurrentTask());

		if (lpmmio->pIOProc == NULL)
			lpmmio->pIOProc = mmioDOSIOProc;
	}
}

/* @doc EXTERNAL

@api	UINT | mmioRename | This function renames the specified file.

@parm	LPCSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to rename.

@parm	LPCSTR | szNewFileName | Specifies a far pointer to a string
containing the new filename.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f mmioRename>.

	If <p lpmmioinfo> is not NULL, all unused fields of the
	<t MMIOINFO> structure it references must be set to zero, including the
	reserved fields.

@parm	DWORD | dwRenameFlags | Specifies option flags for the rename
	operation.  This should be set to zero.

@rdesc	The return value is zero if the file was renamed.  Otherwise, the
return value is an error code returned from <f mmioRename> or from the I/O
procedure.
*/
UINT WINAPI
mmioRename(LPCSTR szFileName, LPCSTR szNewFileName, LPMMIOINFO lpmmioinfo, DWORD dwRenameFlags)
{
	PMMIO	pmmio;
	UINT	uReturn;

	V_FLAGS(dwRenameFlags, 0, mmioRename, MMSYSERR_INVALFLAG);
	V_RPOINTER0(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);

	if ((pmmio = PH(NewHandle(TYPE_MMIO, sizeof(MMIOINFO)))) == NULL)
		return MMIOERR_OUTOFMEMORY;

	if (lpmmioinfo) {
		V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
		*pmmio = *lpmmioinfo;
	}
		
	SetIOProc(szFileName, pmmio);
	uReturn = (UINT)(DWORD) (pmmio->pIOProc((LPSTR) pmmio, MMIOM_RENAME, (LPARAM) szFileName, (LPARAM) szNewFileName));
	FreeHandle((HLOCAL)pmmio);
	return uReturn;
}

/* @doc EXTERNAL

@api	HMMIO | mmioOpen | This function opens a file for unbuffered
	or buffered I/O. The file can be a DOS file, a memory file, or an
	element of a custom storage system.

@parm	LPSTR | szFilename | Specifies a far pointer to a string
containing the filename of the file to open. If no I/O procedure is
specified to open the file, then the filename determines how the file
is opened, as follows:

	-- If the filename does not contain "+", then it is assumed
	to be the name of a DOS file.

	-- If the filename is of the form "foo.ext+bar", then the
	extension "EXT " is assumed to identify an installed I/O procedure
	which is called to perform I/O on the file (see <f mmioInstallIOProc>).

	-- If the filename is NULL and no I/O procedure is given, then
	<e MMIOINFO.adwInfo[0]> is assumed to be the DOS file handle
	of a currently open file.

	The filename should not be longer than 128 bytes, including the
	terminating NULL.

	When opening a memory file, set <p szFilename> to NULL.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure containing extra parameters used by
	<f mmioOpen>. Unless you are opening a memory file, specifying the
	size of a buffer for buffered I/O, or specifying an uninstalled I/O
	procedure to open a file, this parameter should be NULL.

	If <p lpmmioinfo> is not NULL, all unused fields of the
	<t MMIOINFO> structure it references must be set to zero, including the
	reserved fields.

@parm	DWORD | dwOpenFlags | Specifies option flags for the open
	operation. The MMIO_READ, MMIO_WRITE, and MMIO_READWRITE flags are
	mutually exclusive--only one should be specified. The MMIO_COMPAT,
	MMIO_EXCLUSIVE, MMIO_DENYWRITE, MMIO_DENYREAD, and MMIO_DENYNONE flags
	are DOS file-sharing flags, and can only be used after the DOS
	command SHARE has been executed.

	@flag	MMIO_READ | Opens the file for reading only.  This is the
		default, if MMIO_WRITE and MMIO_READWRITE are not specified.

	@flag	MMIO_WRITE | Opens the file for writing.  You should not
		read from a file opened in this mode.

	@flag	MMIO_READWRITE | Opens the file for both reading and writing.

	@flag	MMIO_CREATE | Creates a new file.
		If the file already exists, it is truncated to zero length.
		For memory files, MMIO_CREATE indicates the end of the file
		is initially at the start of the buffer.

	@flag	MMIO_DELETE | Deletes a file. If this flag is specified,
		<p szFilename> should not be NULL. The return
		value will be TRUE (cast to HMMIO) if the file was deleted
		successfully, FALSE otherwise.  Do not call <f mmioClose>
		for a file that has been deleted.  If this flag is specified,
		all other file opening flags are ignored.

	@flag	MMIO_PARSE | Creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
		will be TRUE (cast to HMMIO) if the qualification was
        successful, FALSE otherwise. The file is not opened, and the function
        does not return a valid MMIO file handle, so do not attempt to
        close the file. If this flag is specified, all other file
        opening flags are ignored.

	@flag	MMIO_EXIST | Determines whether the specified file exists
        and creates a fully qualified filename from the path
        specified in <p szFileName>. The fully qualified filename is
        placed back into <p szFileName>. The return value
		will be TRUE (cast to HMMIO) if the qualification was
        successful and the file exists, FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.

	@flag	MMIO_ALLOCBUF | Opens a file for buffered I/O.
		To allocate a buffer larger or smaller than the default
		buffer size (8K), set the <e MMIOINFO.cchBuffer> field of the
		<t MMIOINFO> structure to the desired buffer size. If
		<e MMIOINFO.cchBuffer> is zero, then the default buffer size
		is used. If you are providing your own I/O buffer, then the
		MMIO_ALLOCBUF flag should not be used.
	
	@flag	MMIO_COMPAT | Opens the file with compatibility mode,
		allowing any process on a given machine to open the file
		any number of times.  <f mmioOpen> fails if the file has
		been opened with any of the other sharing modes.

	@flag	MMIO_EXCLUSIVE | Opens the file with exclusive mode,
		denying other processes both read and write access to the file.
		<f mmioOpen> fails if the file has been opened in any other
		mode for read or write access, even by the current process.
		
	@flag	MMIO_DENYWRITE | Opens the file and denies other
		processes write access to the file.  <f mmioOpen> fails
		if the file has been opened in compatibility or for write
		access by any other process.

	@flag	MMIO_DENYREAD | Opens the file and denies other
		processes read access to the file.  <f mmioOpen> fails if the
		file has been opened in compatibility mode or for read access
		by any other process.

	@flag	MMIO_DENYNONE | Opens the file without denying other
		processes read or write access to the file.  <f mmioOpen>
		fails if the file has been opened in compatibility mode
		by any other process.

	@flag	MMIO_GETTEMP | Creates a temporary filename, optionally
        using the parameters passed in <p szFileName> to determine
        the temporary name. For example, you can specify "C:F" to
        create a temporary file residing on drive C, starting with
        letter "F". The resulting filename is placed in the buffer
        pointed to by <p szFileName>.  The return value will be TRUE
        (cast to HMMIO) if the temporary filename was created successfully,
        FALSE otherwise. The file is
        not opened, and the function does not return a valid MMIO file
        handle, so do not attempt to close the file.
		This flag overrides all other flags.

@rdesc	The return value is a handle to the opened file. This handle
	is not a DOS file handle--do not use it with any file I/O functions
	other than MMIO functions.

	If the file cannot be opened, the return value is NULL.  If
	<p lpmmioinfo> is not NULL, then its <e MMIOINFO.wErrorRet> field
	will contain extended error information returned by the I/O
	procedure.

@comm	If <p lpmmioinfo> references an <t MMIOINFO> structure, set
up the fields as described below. All unused fields must be set to
zero, including reserved fields.

-- To request that a file be opened with an installed I/O
procedure, set the <e MMIOINFO.fccIOProc> field
to the four-character code of the I/O procedure,
and set the <e MMIOINFO.pIOProc> field to NULL.

-- To request that a file be opened with an uninstalled I/O procedure,
set the <e MMIOINFO.pIOProc> field to
point to the I/O procedure, and set <e MMIOINFO.fccIOProc> to NULL.

-- To request that <f mmioOpen> determine which I/O procedure to use
to open the file based on the filename contained in <p szFilename>,
set both <e MMIOINFO.fccIOProc> and <e MMIOINFO.pIOProc> to NULL.
This is the default behavior if no <t MMIOINFO> structure is specified.

-- To open a memory file using an internally allocated and managed
buffer, set the <e MMIOINFO.pchBuffer> field to NULL,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the initial size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. This memory file will automatically be expanded in increments of
<e MMIOINFO.adwInfo[0]> bytes when necessary. Specify the MMIO_CREATE
flag for the <p dwOpenFlags> parameter to initially set the end of
the file to be the beginning of the buffer.

-- To open a memory file using a caller-supplied buffer, set
the <e MMIOINFO.pchBuffer> field to point to the memory buffer,
<e MMIOINFO.fccIOProc> to FOURCC_MEM,
<e MMIOINFO.cchBuffer> to the size of the buffer, and
<e MMIOINFO.adwInfo[0]> to the incremental expansion size of the
buffer. The expansion size in <e MMIOINFO.adwInfo[0]> should only
be non-zero if <e MMIOINFO.pchBuffer> is a pointer obtained by calling
<f GlobalAlloc> and <f GlobalLock>, since <f GlobalReAlloc> will be called to
expand the buffer.  In particular, if <e MMIOINFO.pchBuffer> points to a
local or global array, a block of memory in the local heap, or a block
of memory allocated by <f GlobalDosAlloc>, <e MMIOINFO.adwInfo[0]> must
be zero.
Specify the MMIO_CREATE flag for the <p dwOpenFlags> parameter to
initially set the end of the file to be the beginning of the buffer;
otherwise, the entire block of memory will be considered readable.

-- To use a currently open DOS file handle with MMIO, set the
<e MMIOINFO.fccIOProc> field to FOURCC_DOS,
<e MMIOINFO.pchBuffer> to NULL, and <e MMIOINFO.adwInfo[0]> to the
DOS file handle.  Note that offsets within the file will be relative to
the beginning of the file, and will not depend on the DOS file position
at the time <f mmioOpen> is called; the initial MMIO offset will be the same
as the DOS offset when <f mmioOpen> is called.
Later, to close the MMIO file handle without closing the DOS
file handle, pass the MMIO_FHOPEN flag to <f mmioClose>.

You must call <f mmioClose> to close a file opened with <f mmioOpen>.
Open files are not automatically closed when an application exits.

@xref	mmioClose
*/

/* these are the changes to mmioOpen() to support compound files... */

/* @doc CFDOC

@api	HMMIO | mmioOpen | ...The file can be a DOS file, a memory file,
	an element of a RIFF compound file...

@parm	LPSTR | szFilename | ...

	-- If <p szFilename> is of the form "foo+bar", then <f mmioOpen>
	opens the compound file element named "bar" that is stored inside
	the RIFF compound file named "foo".

	-- If <p szFilename> is of the form "foo.ext+bar", then the
	extension "ext" is assumed to identify the installed I/O procedure
	(see <f mmioInstallIOProc>).  The extension "bnd", and any extensions
	that have not been installed, are assumed to refer to a RIFF compound
	file.

@parm	LPMMIOINFO | lpmmioinfo | ...

@parm	DWORD | dwOpenFlags | ...

@rdesc	...

@comm	...

	The following I/O procedure identifiers (type FOURCC) are predefined:

	...

	FOURCC_BND: <p szFilename> is assumed to be the name of
	a RIFF compound file element, and <p adwInfo[0]> should
	contain the HMMCF of the compound file.  Alternatively,
	<p szFilename> can include the name of the compound file
	(e.g. "foo.bnd+bar.dib" as described above), and <p adwInfo[0]>
	should be NULL, to automatically open the compound file.

	...

	The easy way to open an element of a RIFF compound file: just
	include the name of the compound file in <p szFilename> preceded
	by a "+" as described above.  For example, opening
	"c:\data\bar.bnd+blorg.dib" opens the compound file element
	named "blorg.dib" in the compound file "c:\data\bar.bnd".
	<p lpmmioinfo> can be null in this case -- set <p dwOpenFlags>
	as described above.  You can use this same method to open an
	element of a custom storage system, if the file extension of the
	compound file ("bnd" in the above example) corresponds to an
	installed I/O procedure -- see <f mmioInstallIOProc> for details.

	To open an element of a RIFF compound file that was opened using
	<f mmioCFAccess> or <f mmioCFOpen>: set <p szFilename>
	to be the name of the compound file element; set <p fccIOProc>
	to FOURCC_BND; set <p adwInfo[0]> to the HMMCF of the open compound
	file; set <p dwOpenFlags> and <p cchBuffer> as described above;
	set all other fields of <p lpmmioinfo> to zero.

	...
*/
HMMIO WINAPI
mmioOpen(LPSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags)
{
	PMMIO		pmmio;		// MMIO status block
	HPSTR		hpBuffer;
	UINT		w;

        V_FLAGS(dwOpenFlags, MMIO_OPEN_VALID, mmioOpen, NULL);
	V_WPOINTER0(lpmmioinfo, sizeof(MMIOINFO), NULL);

	if (lpmmioinfo) {
		lpmmioinfo->wErrorRet = 0;
		V_CALLBACK0((FARPROC)lpmmioinfo->pIOProc, NULL);
	}

	/* allocate MMIO status information block */
	if ((pmmio = PH(NewHandle(TYPE_MMIO, sizeof(MMIOINFO)))) == NULL)
	{
		if (lpmmioinfo)
			lpmmioinfo->wErrorRet = MMIOERR_OUTOFMEMORY;
		return NULL;
	}

	/* if user supplied <lpmmioinfo>, copy it to <pmmio> */
        if (lpmmioinfo != NULL)
		*pmmio = *lpmmioinfo;
	
	/* <dwOpenFlags> always takes precedence over contents of <pmmio> */
	pmmio->dwFlags = dwOpenFlags;
	pmmio->hmmio = HP(pmmio);

	/* MMIO_ALLOCBUF in the flags means that the user wants a buffer
	 * allocated for buffered I/O, but after this point it means that
	 * a buffer *was* allocated, so turn off the flag until the buffer
	 * is actually allocated (which is done by mmioSetBuffer() below)
	 */
	if (pmmio->dwFlags & MMIO_ALLOCBUF)
	{
		/* if a buffer size is not specified, use the default */
		if (pmmio->cchBuffer == 0)
			pmmio->cchBuffer = MMIO_DEFAULTBUFFER;
		pmmio->dwFlags &= ~MMIO_ALLOCBUF;
	}
	
	/* Set the pIOProc function as determined by the file name or the
	 * parameters in the pmmio structure.
	*/
	SetIOProc(szFileName, pmmio);

	/* The pmmio structure hasn't been set up for buffering, so we must
	 * explicitly make sure that pchBuffer is NULL.
	 */
	hpBuffer = pmmio->pchBuffer;
	pmmio->pchBuffer = NULL;
	
	/* set up buffered I/O however the user requested it */
	if (w = mmioSetBuffer(HP(pmmio), hpBuffer, pmmio->cchBuffer, 0))
	{
		if (lpmmioinfo)
			lpmmioinfo->wErrorRet = w;
		FreeHandle(HP(pmmio));
		return NULL;
	}

	/* let the I/O procedure open/delete/qualify the file */
	w = (UINT)(DWORD) (pmmio->pIOProc((LPSTR) pmmio, MMIOM_OPEN, (LPARAM) szFileName, (LPARAM) 0));

	/* If this is non-zero, return it to the user */
	if (w != 0)
	{
		if (lpmmioinfo != NULL)
			lpmmioinfo->wErrorRet = w;
		FreeHandle(HP(pmmio));
		return NULL;
        }
	
	if (pmmio->dwFlags & (MMIO_DELETE | MMIO_PARSE | MMIO_EXIST | MMIO_GETTEMP))
	{
		/* if the file is being deleted/parsed/name gotten, exit
		 * QUICKLY because the file handle (or whatever) in <pmmio>
		 * is not valid.
		 */
		mmioSetBuffer(HP(pmmio), NULL, 0L, 0);
                FreeHandle(HP(pmmio));
		return (HMMIO) TRUE;
	}
	
	/* the initial "current buffered offset" will be equal to the initial
	 * "current disk offset"
	 */
	pmmio->lBufOffset = pmmio->lDiskOffset;
	
	return HP(pmmio);
}


/* @doc EXTERNAL

@api	UINT | mmioClose | This function closes a file opened with
	<f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file to
	close.

@parm	UINT | wFlags | Specifies options for the close operation.

	@flag	MMIO_FHOPEN | If the file was opened by passing the DOS
		file handle of an already-opened file to <f mmioOpen>, then
		using this flag tells <f mmioClose> to close the MMIO file
		handle, but not the DOS file handle.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value is an error code, either from
	<f mmioFlush> or from the I/O procedure. The error code can be
	one of the following codes:

	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
@xref	mmioOpen mmioFlush
*/
UINT WINAPI
mmioClose(HMMIO hmmio, UINT wFlags)
{
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	
	if (mmioFlush(hmmio, 0) != 0) {
		DebugErr(DBF_WARNING, "MMIO File flush failed during close.\r\n");
		PH(hmmio)->dwFlags &= ~MMIO_DIRTY;
	}

	if ((w = (UINT)(DWORD) PH(hmmio)->pIOProc((LPSTR)PH(hmmio), MMIOM_CLOSE, (LPARAM)(DWORD) wFlags, (LPARAM) 0)) != 0)
		return w;

	/* free the buffer if necessary */
	mmioSetBuffer(hmmio, NULL, 0L, 0);
	
        FreeHandle(hmmio);
	
	return 0;
}


/* @doc EXTERNAL

@api	LONG | mmioRead | This function reads a specified number of
	bytes from a file opened with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file to be
	read.

@parm	HPSTR | pch | Specifies a huge pointer to a buffer to contain
	the data read from the file.

@parm	LONG | cch | Specifies the number of bytes to read from the
	file.

@rdesc	The return value is the number of bytes actually read. If the
	end of the file has been reached and no more bytes can be read, the
	return value is zero. If there is an error reading from the file, the
	return value is -1.

@xref	mmioWrite
*/
LONG WINAPI
mmioRead(HMMIO hmmio, HPSTR pch, LONG cch)
{
	LONG		lTotalBytesRead = 0L;	// total no. bytes read
	LONG		lBytes;			// no. bytes that can be read

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	V_WPOINTER(pch, cch, -1);
	
	while (TRUE)
	{
		/* calculate the number of bytes that can be read */
		lBytes = PH(hmmio)->pchEndRead - PH(hmmio)->pchNext;

		/* can only read at most <cch> bytes from buffer */
		if (lBytes > cch)
			lBytes = cch;

		if (lBytes > 0)
		{
			/* this is where some performance improvements can
			 * be made, especially for small reads... should
			 * special-case cases when segment boundaries are
                         * not crossed (or maybe MemCopy() should do that)
			 */
                        MemCopy(pch, PH(hmmio)->pchNext, lBytes);
			PH(hmmio)->pchNext += lBytes;
			pch += lBytes;
			cch -= lBytes;
			lTotalBytesRead += lBytes;
		}

		/* cannot do MMIOM_READ from memory files */
		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			return lTotalBytesRead;

		if (cch == 0)			// no more to read?
			return lTotalBytesRead;

		/* we need to read beyond this buffer; if we have at least
		 * another bufferful to read, just call the I/O procedure
		 */
		if (cch > PH(hmmio)->cchBuffer)
			break;

		/* read the next bufferful and loop around */
		if (mmioAdvance(hmmio, NULL, MMIO_READ) != 0)
			return -1;
		
		/* if mmioAdvance() couldn't read any more data, we must be
		 * at the end of the file
		 */
		if (PH(hmmio)->pchNext == PH(hmmio)->pchEndRead)
			return lTotalBytesRead;
	}
	
	/* flush and empty the I/O buffer and manipulate <lBufOffset>
	 * directly to change the current file position
	 */
	if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
		return -1;

	/* call the I/O procedure to do the rest of the reading */
	lBytes = mmioDiskIO(PH(hmmio), MMIOM_READ, pch, cch);
	PH(hmmio)->lBufOffset = PH(hmmio)->lDiskOffset;

	return (lBytes == -1L) ? -1L : lTotalBytesRead + lBytes;
}


/* @doc EXTERNAL

@api	LONG | mmioWrite | This function writes a specified number of
	bytes to a file opened with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	char _huge* | pch | Specifies a huge pointer to the buffer to be
	written to the file.

@parm	LONG | cch | Specifies the number of bytes to write to the
	file.

@rdesc	The return value is the number of bytes actually written. If
	there is an error writing to the file, the return value is -1.

@comm	The current file position is incremented by the number of
	bytes written.

@xref	mmioRead
*/
LONG WINAPI
mmioWrite(HMMIO hmmio, const char _huge* pch, LONG cch)
{
	LONG		lTotalBytesWritten = 0L; // total no. bytes written
	LONG		lBytes;			// no. bytes that can be written

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	V_RPOINTER(pch, cch, -1);
	
	while (TRUE)
	{
		/* calculate the number of bytes that can be written */
		lBytes = PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext;

		if ((cch > lBytes) && (PH(hmmio)->fccIOProc == FOURCC_MEM))
		{
			/* this is a memory file -- expand it */
			if (mmioExpandMemFile(PH(hmmio), cch - lBytes) != 0)
				return -1;	// cannot expand
			lBytes = PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext;
		}

		/* can only write at most <cch> bytes into the buffer */
		if (lBytes > cch)
			lBytes = cch;
		
		/* this is where some performance improvements can
		 * be made, especially for small writes... should
		 * special-case cases when segment boundaries are
                 * not crossed (or maybe MemCopy() should do that)
		 */
		if (lBytes > 0)
		{
                        MemCopy(PH(hmmio)->pchNext, pch, lBytes);
			PH(hmmio)->dwFlags |= MMIO_DIRTY;
			PH(hmmio)->pchNext += lBytes;
			pch += lBytes;
			cch -= lBytes;
			lTotalBytesWritten += lBytes;
		}

		/* validate <pchEndRead>, i.e. re-enforce the invariant that
		 * <pchEndRead> points past the last valid byte in the buffer
		 */
		if (PH(hmmio)->pchEndRead < PH(hmmio)->pchNext)
			PH(hmmio)->pchEndRead = PH(hmmio)->pchNext;

		if (cch == 0)			// no more to write?
			return lTotalBytesWritten;

		/* we need to read beyond this buffer; if we have at least
		 * another bufferful to read, just call the I/O procedure
		 */
		if (cch > PH(hmmio)->cchBuffer)
			break;

		/* write this buffer (if needed) and read the next
		 * bufferful (if needed)
		 */
		if (mmioAdvance(hmmio, NULL, MMIO_WRITE) != 0)
			return -1;
	}

	/* we should never need to do MMIOM_WRITE with memory files */

	/* flush and empty the I/O buffer and manipulate <lBufOffset>
	 * directly to change the current file position
	 */
	if (mmioFlush(hmmio, MMIO_EMPTYBUF) != 0)
		return -1;

	/* call the I/O procedure to do the rest of the writing */
	lBytes = mmioDiskIO(PH(hmmio), MMIOM_WRITE, (HPSTR)pch, cch);
	PH(hmmio)->lBufOffset = PH(hmmio)->lDiskOffset;

	return (lBytes == -1L) ? -1L : lTotalBytesWritten + lBytes;
}


/* @doc EXTERNAL

@api	LONG | mmioSeek | This function changes the current file
	position in a file opened with <f mmioOpen>. The current file
	position is the location in the file where data is read or written.

@parm	HMMIO | hmmio | Specifies the file handle of the file to seek
	in.

@parm	LONG | lOffset | Specifies an offset to change the file position.

@parm	int | iOrigin | Specifies how the offset specified by
	<p lOffset> is interpreted. Contains one of the following flags:

	@flag	SEEK_SET | Seeks to <p lOffset> bytes from the beginning
		of the file.

	@flag	SEEK_CUR | Seeks to <p lOffset> bytes from the current
		file position.

	@flag	SEEK_END | Seeks to <p lOffset> bytes from the end
		of the file.

@rdesc	The return value is the new file position in bytes, relative
	to the beginning of the file. If there is an error, the return value
	is -1.

@comm	Seeking to an invalid location in the file, such as past the
	end of the file, may not cause <f mmioSeek> to return an error,
	but may cause subsequent I/O operations on the file to fail.

	To locate the end of a file, call <f mmioSeek> with <p lOffset>
	set to zero and <p iOrigin> set to SEEK_END.
*/
LONG WINAPI
mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin)
{
	LONG		lCurOffset;	// disk offset of <pchNext>
	LONG		lEndBufOffset;	// disk offset of end of buffer
	LONG		lNewOffset;	// new disk offset

	V_HANDLE(hmmio, TYPE_MMIO, -1);
	
	/* careful! all this buffer pointer manipulation is fine, but keep
	 * in mind that buffering may be disabled (in which case <pchEndRead>
	 * and <pchBuffer> will both be NULL, so the buffer will appear to
	 * be zero bytes in size)
	 */

	/* <PH(hmmio)->lBufOffset> is the disk offset of the start of the start
	 * of the buffer; determine <lCurOffset>, the offset of <pchNext>,
	 * and <lEndBufOffset>, the offset of the end of the valid part
	 * of the buffer
	 */
	lCurOffset = PH(hmmio)->lBufOffset +
		(PH(hmmio)->pchNext - PH(hmmio)->pchBuffer);
	lEndBufOffset = PH(hmmio)->lBufOffset +
		(PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer);
	
	/* determine <lNewOffset>, the offset to seek to */
	switch (iOrigin)
	{
	case SEEK_SET:		// seek relative to start of file

		lNewOffset = lOffset;
		break;

	case SEEK_CUR:		// seek relative to current location

		lNewOffset = lCurOffset + lOffset;
		break;

	case SEEK_END:		// seek relative to end of file

		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			lNewOffset = lEndBufOffset - lOffset;
		else
		{
			LONG	lEndFileOffset;

			/* find out where the end of the file is */
			if ((lEndFileOffset = (LONG) PH(hmmio)->pIOProc((LPSTR) PH(hmmio),
					MMIOM_SEEK, (LPARAM) 0, (LPARAM) SEEK_END)) == -1)
				return -1;
			lNewOffset = lEndFileOffset - lOffset;
		}
		break;

	default:
		return -1;
	}

	if ((lNewOffset >= PH(hmmio)->lBufOffset) && (lNewOffset <= lEndBufOffset))
	{
		/* seeking within the valid part of the buffer
		 * (possibly including seeking to <lEndBufOffset>)
		 */
		PH(hmmio)->pchNext = PH(hmmio)->pchBuffer +
			(lNewOffset - PH(hmmio)->lBufOffset);
	}
	else
	{
		/* seeking outside the buffer */
		if (PH(hmmio)->fccIOProc == FOURCC_MEM)
			return -1;	// can't seek outside mem. file buffer
		if (mmioFlush(hmmio, 0) != 0)
			return -1;

		/* the current "buffered file position" (same as <lDiskOffset>
		 * for unbuffered files) equals <lBufOffset> +
		 * (<pchNext> - <pchBuffer>); we'll move the current buffered
		 * file position (and empty the buffer, since it becomes
		 * invalid when <lBufOffset> changes) as follows...
		 */
		PH(hmmio)->lBufOffset = lNewOffset;
		PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;

		/* don't need to actually seek right now, since the next
		 * MMIOM_READ or MMIOM_WRITE will have to seek anyway
		 */
	}

	return lNewOffset;
}


/* @doc EXTERNAL

@api	UINT | mmioGetInfo | This function retrieves information
	about a file opened with <f mmioOpen>. This information allows the
	caller to directly access the I/O buffer, if the file is opened
	for buffered I/O.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to a
	caller-allocated <t MMIOINFO> structure that <f mmioGetInfo>
	fills with information about the file. See the <t MMIOINFO> structure
	and the <f mmioOpen> function for information about the fields in
	this structure.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.

@comm	To directly access the I/O buffer of a file opened for
	buffered I/O, use the following fields of the <t MMIOINFO> structure
	filled by <f mmioGetInfo>:

	-- The <e MMIOINFO.pchNext> field points to the next byte in the
	buffer that can be read or written. When you read or write, increment
	<e MMIOINFO.pchNext> by the number of bytes read or written.

	-- The <e MMIOINFO.pchEndRead> field points to one byte past the
	last valid byte in the buffer that can be read.

	-- The <e MMIOINFO.pchEndWrite> field points to one byte past the
	last location in the buffer that can be written.

	Once you read or write to the buffer and modify
	<e MMIOINFO.pchNext>, do not call any MMIO function except
	<f mmioAdvance> until you call <f mmioSetInfo>. Call <f mmioSetInfo>
	when you are finished directly accessing the buffer.

	When you reach the end of the buffer specified by
	<e MMIOINFO.pchEndRead> or <e MMIOINFO.pchEndWrite>, call
	<f mmioAdvance> to fill the buffer from the disk, or write
	the buffer to the disk. The <f mmioAdvance> function
	will update the <e MMIOINFO.pchNext>, <e MMIOINFO.pchEndRead>, and
	<e MMIOINFO.pchEndWrite> fields in the <t MMIOINFO> structure for the
	file.

	Before calling <f mmioAdvance> or <f mmioSetInfo> to flush a
	buffer to disk, set the MMIO_DIRTY flag in the <e MMIOINFO.dwFlags>
	field of the <t MMIOINFO> structure for the file. Otherwise, the
	buffer will not get written to disk.

	Do not decrement <e MMIOINFO.pchNext> or modify any fields in the
	<t MMIOINFO> structure other than <e MMIOINFO.pchNext> and
	<e MMIOINFO.dwFlags>. Do not set any flags in <e MMIOINFO.dwFlags>
	except MMIO_DIRTY.

@xref	mmioSetInfo MMIOINFO
*/
UINT WINAPI
mmioGetInfo(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags)
{
	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioGetInfo, MMSYSERR_INVALFLAG);
	
	*lpmmioinfo = *PH(hmmio);

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioSetInfo | This function updates the information
	retrieved by <f mmioGetInfo> about a file opened with <f mmioOpen>.
	Use this function to terminate direct buffer access of a file opened
	for buffered I/O.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPMMIOINFO | lpmmioinfo | Specifies a far pointer to an
	<t MMIOINFO> structure filled with information with
	<f mmioGetInfo>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.

@comm	If you have written to the file I/O buffer, set the
	MMIO_DIRTY flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO>
	structure before calling <f mmioSetInfo> to terminate direct buffer
	access. Otherwise, the buffer will not get flushed to disk.
	
@xref	mmioGetInfo MMIOINFO
*/
UINT WINAPI
mmioSetInfo(HMMIO hmmio, const MMIOINFO FAR* lpmmioinfo, UINT wFlags)
{
	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_RPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
	V_WPOINTER0(lpmmioinfo->pchBuffer, lpmmioinfo->cchBuffer, MMSYSERR_INVALPARAM);
	V_CALLBACK((FARPROC)lpmmioinfo->pIOProc, MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioSetInfo, MMSYSERR_INVALFLAG);

	/* copy the relevant information from <lpmmioinfo> back into <hmmio> */
	*PH(hmmio) = *lpmmioinfo;

	/* validate <pchEndRead>, i.e. re-enforce the invariant that
	 * <pchEndRead> points past the last valid byte in the buffer
	 */
	if (PH(hmmio)->pchEndRead < PH(hmmio)->pchNext)
		PH(hmmio)->pchEndRead = PH(hmmio)->pchNext;

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioSetBuffer | This function enables or disables
	buffered I/O, or changes the buffer or buffer size for a file opened
	with <f mmioOpen>.

@parm	HMMIO | hmmio | Specifies the file handle of the file.

@parm	LPSTR | pchBuffer | Specifies a far pointer to a
	caller-supplied buffer to use for buffered I/O. If NULL,
	<f mmioSetBuffer> allocates an internal buffer for buffered I/O.

@parm	LONG | cchBuffer | Specifies the size of the caller-supplied
	buffer, or the size of the buffer for <f mmioSetBuffer> to allocate.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. If an error
	occurs, the file handle remains valid. The error code can be one
	of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the old buffer could
	not be written to disk, so the operation was aborted.
	
	@flag MMIOERR_OUTOFMEMORY | The new buffer could not be allocated,
	probably due to a lack of available memory.

@comm	To enable buffering using an internal buffer, set
	<p pchBuffer> to NULL and <p cchBuffer> to the desired buffer size.

	To supply your own buffer, set <p pchBuffer> to point to the buffer,
	and set <p cchBuffer> to the size of the buffer.

	To disable buffered I/O, set <p pchBuffer> to NULL and
	<p cchBuffer> to zero.

	If buffered I/O is already enabled using an internal buffer, you
	can reallocate the buffer to a different size by setting
	<p pchBuffer> to NULL and <p cchBuffer> to the new buffer size. The
	contents of the buffer may be changed after resizing.
 */
UINT WINAPI
mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT wFlags)
{
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_WPOINTER0(pchBuffer, cchBuffer, MMSYSERR_INVALPARAM);
	V_FLAGS(wFlags, 0, mmioSetBuffer, MMSYSERR_INVALFLAG);
	
	if ((PH(hmmio)->dwFlags & MMIO_ALLOCBUF) &&
	    (pchBuffer == NULL) && (cchBuffer > 0))
	{
		/* grow or shrink buffer in-place */
		HPSTR		pch;
		LONG		lDeltaNext;
		LONG		lDeltaEndRead;

		/* Since the ALLOCBUF flag is set, we must have a buffer */
		
		/* write the buffer to disk, but don't empty it */
		if ((w = mmioFlush(hmmio, 0)) != 0)
			return w;

		while (TRUE)
		{
			/* remember where <pchNext> and <pchEndRead> are
			 * in the buffer
			 */
			lDeltaNext = PH(hmmio)->pchNext - PH(hmmio)->pchBuffer;
			lDeltaEndRead = PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer;

			if (cchBuffer >= lDeltaNext)
				break;

			/* caller wants to truncate the part of the buffer
			 * that contains <pchNext> -- handle this by
			 * emptying the buffer, recalculating <lDeltaNext>
			 * and <lDeltaEndRead>, and continuing below
			 */
			if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
				return w;
		}

		/* reallocate buffer */
		pch = GlobalReAllocPtr(PH(hmmio)->pchBuffer, cchBuffer, GMEM_MOVEABLE);

		/* If we cannot allocate the new buffer, exit with no
		 *   harm done.
		 */
		if (pch == NULL)
			return MMIOERR_OUTOFMEMORY;	// out of memory
		
		/* transfer pointers to new buffer */
		PH(hmmio)->cchBuffer = cchBuffer;
		PH(hmmio)->pchBuffer = pch;
		PH(hmmio)->pchNext = pch + lDeltaNext;
		PH(hmmio)->pchEndRead = pch + lDeltaEndRead;

		/* <pchEndWrite> always points to the end of the buf. */
		PH(hmmio)->pchEndWrite = PH(hmmio)->pchBuffer + cchBuffer;

		/* check if the reallocation truncated valid data */
		if (lDeltaEndRead > cchBuffer)
			PH(hmmio)->pchEndRead = PH(hmmio)->pchEndWrite;
		
		return 0;
	}

	/* write the buffer to disk and stop using the buffer */
	if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
		return w;

	if (PH(hmmio)->dwFlags & MMIO_ALLOCBUF)
	{
		GlobalFreePtr(PH(hmmio)->pchBuffer);
		PH(hmmio)->dwFlags &= ~MMIO_ALLOCBUF;
	}
	
	/* Initially, no error. */
	w = 0;

	if ((pchBuffer == NULL) && (cchBuffer > 0))
	{
		pchBuffer = GlobalAllocPtr(GMEM_MOVEABLE, cchBuffer);
				
		/* If there is an error, change the file to be un-buffered
		 * and return an error code.  The file is still valid.
		 * (Just for a little extra security.)
		 */
		if (pchBuffer == NULL) {
		    w = MMIOERR_OUTOFMEMORY;
		    cchBuffer = 0L;
		} else
		    PH(hmmio)->dwFlags |= MMIO_ALLOCBUF;
	}

	/* invariant: <pchEndRead> points past the end of the "valid" portion
	 * of the buffer, and <pchEndWrite> points past the last byte that
	 * can be written into; <pchNext> points to the next byte to read
	 * or write; <lBufOffset> is the current disk offset of the start
	 * of the buffer, and it will not change
	 */
	PH(hmmio)->pchBuffer = pchBuffer;
	PH(hmmio)->cchBuffer = cchBuffer;
	PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;
	PH(hmmio)->pchEndWrite = PH(hmmio)->pchBuffer + cchBuffer;

	return w;
}


/* @doc EXTERNAL

@api	UINT | mmioFlush | This function writes the I/O buffer of a
	file to disk, if the I/O buffer has been written to.

@parm	HMMIO | hmmio | Specifies the file handle of a file opened
	with <f mmioOpen>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
@comm	Closing a file with <f mmioClose> will automatically flush
	its buffer.

	If there is insufficient disk space to write the
	buffer, <f mmioFlush> will fail, even if the preceding <f mmioWrite>
	calls were successful.
*/
UINT WINAPI
mmioFlush(HMMIO hmmio, UINT wFlags)
{
	LONG		lBytesAsk;		// no. bytes to write
	LONG		lBytesWritten;		// no. bytes actually written

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_FLAGS(wFlags, MMIO_FLUSH_VALID, mmioFlush, MMSYSERR_INVALFLAG);
	
	if ((PH(hmmio)->fccIOProc == FOURCC_MEM) || (PH(hmmio)->pchBuffer == NULL))
		return 0;		// cannot flush memory files
	
	/* if the file is unbuffered then the dirty flag should not be set */
	if (PH(hmmio)->dwFlags & MMIO_DIRTY)
	{
		/* figure out how many bytes need to be flushed */
		lBytesAsk = PH(hmmio)->pchEndRead - PH(hmmio)->pchBuffer;

		/* write the buffer to disk */
		lBytesWritten = mmioDiskIO(PH(hmmio), MMIOM_WRITEFLUSH,
			PH(hmmio)->pchBuffer, lBytesAsk);
		if (lBytesWritten != lBytesAsk)
			return MMIOERR_CANNOTWRITE;
		PH(hmmio)->dwFlags &= ~MMIO_DIRTY;	// buffer is clean now
	}

	if (wFlags & MMIO_EMPTYBUF)
	{
		/* empty the I/O buffer, and update <lBufOffset> to reflect
		 * what the current file position is
		 */
		PH(hmmio)->lBufOffset += (PH(hmmio)->pchNext - PH(hmmio)->pchBuffer);
		PH(hmmio)->pchNext = PH(hmmio)->pchEndRead = PH(hmmio)->pchBuffer;
	}

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioAdvance | This function advances the I/O buffer of
	a file set up for direct I/O buffer access with <f mmioGetInfo>. If
	the file is opened for reading, the I/O buffer is filled from the
	disk.  If the file is opened for writing and the MMIO_DIRTY flag is
	set in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure,
	the buffer is written to disk.  The <e MMIOINFO.pchNext>,
	<e MMIOINFO.pchEndRead>, and <e MMIOINFO.pchEndWrite> fields of the
	<t MMIOINFO> structure are updated to reflect the new state of
	the I/O buffer.

@parm	HMMIO | hmmio | Specifies the file handle for a file opened
	with <f mmioOpen>.

@parm	LPMMIOINFO | lpmmioinfo | Optionally specifies a far pointer to the
	<t MMIOINFO> structure obtained with <f mmioGetInfo>, which is used to
	set the current file information, then updated after the buffer is
	advanced.

@parm	UINT | wFlags | Specifies options for the operation.
	Contains exactly one of the following two flags:

	@flag	MMIO_READ | The buffer is filled from the file.

	@flag	MMIO_WRITE | The buffer is written to the file.

@rdesc	The return value is zero if the operation is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:
	
	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	
	@flag MMIOERR_CANNOTREAD | An error occurred while re-filling
	the buffer.
	
	@flag MMIOERR_UNBUFFERED | The specified file is not opened
	for buffered I/O.
	
	@flag MMIOERR_CANNOTEXPAND | The specified memory file cannot
	be expanded, probably because the <e MMIOINFO.adwInfo[0]> field
	was set to zero in the initial call to <f mmioOpen>.
	
	@flag MMIOERR_OUTOFMEMORY | There was not enough memory to expand
	a memory file for further writing.
	

@comm	If the specified file is opened for writing or for both
	reading and writing, the I/O buffer will be flushed to disk before
	the next buffer is read. If the I/O buffer cannot be written to disk
	because the disk is full, then <f mmioAdvance> will return
	MMIOERR_CANNOTWRITE.
	
	If the specified file is only open for writing, the MMIO_WRITE
	flag must be specified.

	If you have written to the I/O buffer, you must set the MMIO_DIRTY
	flag in the <e MMIOINFO.dwFlags> field of the <t MMIOINFO> structure
	before calling <f mmioAdvance>. Otherwise, the buffer will not be
	written to disk.
	
	If the end of file is reached, <f mmioAdvance> will still return
	success, even though no more data can be read.  Thus, to check for
	the end of the file, it is necessary to see if the
	<e MMIOINFO.pchNext> and <e MMIOINFO.pchEndRead> fields of the
	<t MMIOINFO> structure are equal after calling <f mmioAdvance>.

@xref	mmioGetInfo MMIOINFO
*/
UINT WINAPI
mmioAdvance(HMMIO hmmio, LPMMIOINFO lpmmioinfo, UINT wFlags)
{
	LONG		lBytesRead;		// bytes actually read
	UINT		w;

	V_HANDLE(hmmio, TYPE_MMIO, MMSYSERR_INVALHANDLE);
	V_FLAGS(wFlags, MMIO_ADVANCE_VALID, mmioAdvance, MMSYSERR_INVALFLAG);

	if (PH(hmmio)->pchBuffer == NULL)
		return MMIOERR_UNBUFFERED;
	if (lpmmioinfo != NULL) {
		V_WPOINTER(lpmmioinfo, sizeof(MMIOINFO), MMSYSERR_INVALPARAM);
		mmioSetInfo(hmmio, lpmmioinfo, 0);
	}

	if (PH(hmmio)->fccIOProc == FOURCC_MEM)
	{
		/* this is a memory file:
		 *   -- if the caller is reading, cannot advance
		 *   -- if the caller is writing, then advance by expanding
		 *      the buffer (if possible) if the there is less than
		 *	<adwInfo[0]> bytes left in the buffer
		 */
		if (!(wFlags & MMIO_WRITE))
			return 0;
		if ((DWORD)(PH(hmmio)->pchEndWrite - PH(hmmio)->pchNext) >= PH(hmmio)->adwInfo[0])
			return 0;
		if ((w = mmioExpandMemFile(PH(hmmio), 1L)) != 0)
			return w;	// out of memory, or whatever
		goto GETINFO_AND_EXIT;
	}

	/* empty the I/O buffer, which will effectively advance the
	 * buffer by (<pchNext> - <pchBuffer>) bytes
	 */
	if ((w = mmioFlush(hmmio, MMIO_EMPTYBUF)) != 0)
		return w;
	
	/* if MMIO_WRITE bit is not set in wFlags, fill the buffer  */
	if (!(wFlags & MMIO_WRITE))
	{
		/* read the next bufferful from the file */
		lBytesRead = mmioDiskIO(PH(hmmio), MMIOM_READ,
			PH(hmmio)->pchBuffer, PH(hmmio)->cchBuffer);
		if (lBytesRead == -1)
			return MMIOERR_CANNOTREAD;

		/* reading zero bytes should not be treated as an error
		 * condition -- e.g. open a new file R+W and call
		 * mmioAdvance(), and MMIOM_READ will return zero bytes
		 * because the file started off empty
		 */
		PH(hmmio)->pchEndRead += lBytesRead;
	}

GETINFO_AND_EXIT:

	/* copy <hmmio> back to <lpmmioinfo> if <lpmmioinfo> is provided */
	if (lpmmioinfo != NULL)
		mmioGetInfo(hmmio, lpmmioinfo, 0);
	
	return 0;
}


/* @doc EXTERNAL

@api	FOURCC | mmioStringToFOURCC | This function converts a
	null-terminated string to a four-character code.

@parm	LPCSTR | sz | Specifies a far pointer to a null-terminated
	string to a four-character code.

@parm	UINT | wFlags | Specifies options for the conversion:

	@flag	MMIO_TOUPPER | Converts all characters to uppercase.

@rdesc	The return value is the four character code created from the
	given string.

@comm	This function does not check to see if the string referenced
	by <p sz> follows any conventions regarding which characters to
	include in a four-character code.  The string is
	simply copied to a four-character code and padded with blanks or
    truncated to four characters if required.

@xref	mmioFOURCC
*/
FOURCC WINAPI
mmioStringToFOURCC(LPCSTR sz, UINT wFlags)
{
	FOURCC		fcc;
	LPSTR		pch = (LPSTR) &fcc;
	int		i;

    V_STRING(sz, (UINT)-1, NULL);
	V_FLAGS(wFlags, MMIO_FOURCC_VALID, mmioStringToFOURCC, (FOURCC)-1);

	for (i = sizeof(FOURCC) - 1; i >= 0; i--)
	{
		if (!*sz)
			*pch = ' ';
		else {
            *pch = *sz++;
			if (wFlags & MMIO_TOUPPER)
				*pch = (char)(WORD)(LONG)AnsiUpper((LPSTR)(LONG)*pch);
        }
		pch++;
	}
    return fcc;
}


/* @doc EXTERNAL

@api	LPMMIOPROC | mmioInstallIOProc | This function installs or
	removes a custom I/O procedure. It will also locate an installed I/O
	procedure, given its corresponding four-character code.

@parm	FOURCC | fccIOProc | Specifies a four-character code
	identifying the I/O procedure to install, remove, or locate. All
	characters in this four-character code should be uppercase characters.

@parm	LPMMIOPROC | pIOProc | Specifies the address of the I/O
	procedure to install. To remove or locate an I/O procedure, set this
	parameter to NULL.

@parm	DWORD | dwFlags | Specifies one of the following flags
	indicating whether the I/O procedure is being installed, removed, or
	located:

	@flag	MMIO_INSTALLPROC | Installs the specified I/O procedure.

	@flag	MMIO_GLOBALPROC | This flag is a modifier to the install flag,
		and indicates the I/O procedure should be installed for global
		use.  This flag is ignored on removal or find.

	@flag	MMIO_REMOVEPROC | Removes the specified I/O procedure.

	@flag	MMIO_FINDPROC | Searches for the specified I/O procedure.

@rdesc	The return value is the address of the I/O procedure
	installed, removed, or located. If there is an error, the return value
	is NULL.

@comm	If the I/O procedure resides in the application, use
	<f MakeProcInstance> to get a procedure-instance address and specify
	this address for <p pIOProc>. You don't need to get a procedure-instance
	address if the I/O procedure resides in a DLL.

@cb	LRESULT FAR PASCAL | IOProc | <f IOProc> is a placeholder for the
	application-supplied function name. The actual name must be exported
	by including it in a EXPORTS statement in the application's
	module-definitions file.

	@parm	LPSTR | lpmmioinfo | Specifies a far pointer to an
		<t MMIOINFO> structure containing information about the open
		file.  The I/O procedure must maintain the <e MMIOINFO.lDiskOffset>
		field in this structure to indicate the file offset to the
		next read or write location. The I/O procedure can use the
		<e MMIOINFO.adwInfo[]> field to store state information. The
		I/O procedure should not modify any other fields of the
		<t MMIOINFO> structure.


	@parm	UINT | wMsg | Specifies a message indicating the
		requested I/O operation. Messages that can be received include
		<m MMIOM_OPEN>, <m MMIOM_CLOSE>, <m MMIOM_READ>, <m MMIOM_WRITE>,
		and <m MMIOM_SEEK>.

	@parm	LPARAM | lParam1 | Specifies a parameter for the message.

	@parm	LPARAM | lParam2 | Specifies a parameter for the message.

@rdesc	The return value depends on the message specified by
	<p wMsg>. If the I/O procedure does not recognize a message, it should
	return zero.

@comm	The four-character code specified by the
	<e MMIOINFO.fccIOProc> field in the <t MMIOINFO> structure
	associated with a file identifies a filename extension for a custom
	storage system. When an application calls <f mmioOpen> with a
	filename such as "foo.xyz!bar", the I/O procedure associated with the
	four-character code "XYZ " is called to open the "bar" element of the
	file "foo.xyz".

	The <f mmioInstallIOProc> function maintains a separate list of
	installed I/O procedures for each Windows application. Therefore,
	different applications can use the same I/O procedure identifier for
	different I/O procedures without conflict.  Installing an I/O procedure
	globally however enables any process to use the procedure.

	If an application calls <f mmioInstallIOProc> more than once to
	register the same I/O procedure, then it must call
	<f mmioInstallIOProc> to remove the procedure once for each time it
	installed the procedure.

	<f mmioInstallIOProc> will not prevent an application from
	installing two different I/O procedures with the same identifier, or
	installing an I/O procedure with one of the predefined identifiers
	("DOS ", "MEM "). The most recently installed procedure
	takes precedence, and the most recently installed procedure is the
	first one to get removed.

	When searching for a specified I/O procedure, local procedures are
	searched first, then global procedures.

@xref	mmioOpen
 */
LPMMIOPROC WINAPI
mmioInstallIOProc(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags)
{
	IOProcMapEntry *pEnt;		// an entry in linked list
        HTASK           hTaskCurrent;   // current Windows task handl

        V_FLAGS(dwFlags, MMIO_VALIDPROC, mmioInstallIOProc, NULL);

        if (fccIOProc == 0L)
                return NULL;

	hTaskCurrent = GetCurrentTask();

	if (dwFlags & MMIO_INSTALLPROC)
	{
		/* install I/O procedure -- always add at the beginning of
		 * the list, so it overrides any other I/O procedures
		 * with the same identifier installed by the same task
		 */
		V_CALLBACK((FARPROC)pIOProc, NULL);
		if ((pEnt = (IOProcMapEntry NEAR *)
			NewHandle(TYPE_IOPROC, sizeof(IOProcMapEntry))) == NULL)
				return NULL;		// out of memory
		pEnt->fccIOProc = fccIOProc;
		pEnt->pIOProc = pIOProc;
		if (dwFlags & MMIO_GLOBALPROC) {

            char    libname[128];
            char    aszFour[sizeof(FOURCC)+1];

            pEnt->hTask = NULL;
            SetHandleOwner(pEnt, NULL);

            //
            // This is the hack to allow global IO Procs to be truly
            // global.  That is, if there is a matching 32 bit entry
            // in win.ini under [IOProcs] for this fccIOProc will we try
            // load the dll.   The dll should install its 32 bit
            // equivalent IOProc in the dll initialisation routine.
            //

            *(LPDWORD)&aszFour = (DWORD)fccIOProc;
            aszFour[ sizeof(FOURCC) ] = '\0';
            if ( GetProfileString( "IOProcs", aszFour, "", libname,
                                   sizeof(libname) ) ) {

                LoadLibraryEx32W( libname, 0L, 0L );
            }

        } else {
			pEnt->hTask = hTaskCurrent;
        }
		pEnt->wFlags = 0;
		pEnt->pNext = gIOProcMapHead;
		gIOProcMapHead = pEnt;
		return pIOProc;
	}
	if (!pIOProc)
		if (dwFlags & MMIO_REMOVEPROC) {
			LPMMIOPROC	lpmmioproc;

			lpmmioproc = RemoveIOProc(fccIOProc, hTaskCurrent);
			if (!lpmmioproc)
				lpmmioproc = RemoveIOProc(fccIOProc, NULL);
			return lpmmioproc;
		} else if (dwFlags & MMIO_FINDPROC)
			return FindIOProc(fccIOProc, hTaskCurrent);
	return NULL;		// couldn't find requested I/O procedure
}


/* @doc EXTERNAL

@api	LRESULT | mmioSendMessage | This function sends a message to the
	I/O procedure associated with the specified file.

@parm	HMMIO | hmmio | Specifies the file handle for a file opened
	with <f mmioOpen>.

@parm	UINT | wMsg | Specifies the message to send to the I/O procedure.

@parm	LPARAM | lParam1 | Specifies a parameter for the message.

@parm	LPARAM | lParam2 | Specifies a parameter for the message.

@rdesc	The return value depends on the message. If the I/O procedure
	does not recognize the message, the return value is zero.

@comm	Use this function to send custom user-defined messages. Do
	not use it to send the <m MMIOM_OPEN>, <m MMIOM_CLOSE>,
	<m MMIOM_READ>, <m MMIOM_WRITE>, <m MMIOM_WRITEFLUSH>, or
	<m MMIOM_SEEK> messages. Define
	custom messages to be greater than or equal to the MMIOM_USER constant.

@xref	mmioInstallIOProc
*/
LRESULT WINAPI
mmioSendMessage(HMMIO hmmio, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	V_HANDLE(hmmio, TYPE_MMIO, (LRESULT)0);
	return PH(hmmio)->pIOProc((LPSTR)PH(hmmio), wMsg, lParam1, lParam2);
}


/* @doc INTERNAL

@api	LONG | mmioDiskIO | Perform an unbuffered read or write.
	Do not assume where the current disk offset <p lDiskOffset> will be.

@parm	PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm	UINT | wMsg | MMIOM_READ if <f mmioDiskIO> should read from the disk,
	or MMIOM_WRITE if <f mmioDiskIO> should write to the disk.

@parm	HPSTR | pch | The buffer to read into or write from.

@parm	LONG | cch | The number of bytes to read or write.

	<f mmioDiskIO> changes the disk offset to be <p lBufOffset>
	and then performs an MMIOM_READ or MMIOM_WRITE operation as
	specified by <p wMsg>, <p pch>, and <p cch>.

	Note that if the I/O buffer is not empty at this point, this
	function may not do what you expect.

	Do not call this function for memory files.
*/
static LONG NEAR PASCAL
mmioDiskIO(PMMIO pmmio, UINT wMsg, HPSTR pch, LONG cch)
{
	if (pmmio->lDiskOffset != pmmio->lBufOffset)
	{
		if ((LONG) pmmio->pIOProc((LPSTR) pmmio, MMIOM_SEEK, (LPARAM) pmmio->lBufOffset,
		                   (LPARAM) SEEK_SET) == -1)
			return -1;
	}

	return (LONG) pmmio->pIOProc((LPSTR) pmmio, wMsg, (LPARAM) pch, (LPARAM) cch);
}


/* @doc INTERNAL

@api	UINT | mmioExpandMemFile | Assuming that <p pmmio> is a memory file,
	expand it by <p lExpand> bytes or <p adwInfo[0]> bytes, whichever
	is larger.  Do not disturb the contents of the buffer or change
	the current file position.

@parm	PMMIO | pmmio | The open file handle returned by <f mmioOpen>.

@parm	LONG | lExpand | The minimum number of bytes to expand the buffer by.

@rdesc	If the function succeeds, zero is returned.  If the function fails,
	an error code is returned.  In particular, MMIOERR_OUTOFMEMORY is
	returned if memory reallocation failed.

@comm	Only call this function for memory files.
*/
static UINT NEAR PASCAL
mmioExpandMemFile(PMMIO pmmio, LONG lExpand)
{
	MMIOMEMINFO *	pInfo = (MMIOMEMINFO *) pmmio->adwInfo;
	DWORD		dwFlagsTemp;
	UINT		w;

	/* make sure buffer can be expanded */
	/* Note: we used to check ALLOC_BUF here, we don't now. */
	if (pInfo->lExpand == 0)
		return MMIOERR_CANNOTEXPAND;	// cannot grow file

	/* how much should the buffer be expanded by? */
	if (lExpand < pInfo->lExpand)
		lExpand = pInfo->lExpand;
	
	dwFlagsTemp = pmmio->dwFlags;
	pmmio->dwFlags |= MMIO_ALLOCBUF;
	w = mmioSetBuffer(HP(pmmio), NULL,
		             pmmio->cchBuffer + lExpand, 0);
	pmmio->dwFlags = dwFlagsTemp;
	return w;
}


/************************************************************************/
/*
@doc	INTERNAL

@func	UINT | lrename |
	Renames the specified DOS file.

@parm	LPCSTR | lszOrigPath |
	Points to the DOS file to rename.

@parm	LPCSTR | lszNewPath |
	Points to the new name for the file.

@rdesc	Returns zero if the file was renamed, else the DOS error code.
*/

#pragma warning(4:4035)
#pragma warning(4:4704)

static	UINT PASCAL NEAR lrename(
	LPCSTR	lszOrigPath,
	LPCSTR	lszNewPath)
{
	_asm {
		push	ds
		lds	dx, lszOrigPath	; Original name.
		les	di, lszNewPath	; New name.
		mov	ah, 56H		; Rename file.
                int     21h             ; DOS.
                sbb     bx,bx           ; if error (C) BX=FFFF, (NC) BX=000
                and     ax,bx           ; set ax to zero if no error
		pop	ds
	}
}

/* @doc INTERNAL

@api	LRESULT | mmioDOSIOProc | The 'DOS' I/O procedure, which handles I/O
	on ordinary DOS files.

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	UINT | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
static LRESULT CALLBACK
mmioDOSIOProc(LPSTR lpmmioStr, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (UINT) (LONG) lpmmioStr; // only in DLL!
	MMIODOSINFO *	pInfo = (MMIODOSINFO *) pmmio->adwInfo;
	LONG		lResult;
	OFSTRUCT	of;

	switch (wMsg)
	{

	case MMIOM_OPEN:

		/* If a temporary file name is to be returned, use the file
		 * name parameter as a disk followed by a prefix for the name
		 * to create.  The extra info parameter optionally contains a
		 * sequence number to pass.
		*/
		if (pmmio->dwFlags & MMIO_GETTEMP) {
			V_RPOINTER((LPSTR)lParam1, 4, (LRESULT) MMSYSERR_INVALPARAM);
			return (LRESULT)(LONG) (GetTempFileName(*(LPSTR)lParam1,
				((LPSTR)lParam1) + 3, (UINT)pmmio->adwInfo[0],
				(LPSTR)lParam1) ? 0 : MMIOERR_FILENOTFOUND);
		}

		/* <lParam1> is either a file name or NULL; if it is
		 * NULL, then <adwInfo[0]>, which is actually <pInfo->fh>,
		 * should already contain an open DOS file handle.
		 * note that the low word of <dwFlags> is equivalent to
		 * the <wStyle> parameter of OpenFile()
		 */
		if (lParam1 != 0)
			pInfo->fh = OpenFile((LPSTR) lParam1, &of,
				    LOWORD(pmmio->dwFlags));
		if (pInfo->fh == HFILE_ERROR)
			return (LRESULT)(LONG) ((pmmio->dwFlags & MMIO_DELETE) ? MMIOERR_CANNOTWRITE : MMIOERR_FILENOTFOUND);

		/* if file is being deleted, there's nothing more to do */
		if (pmmio->dwFlags & MMIO_DELETE)
			return (LRESULT) 0;

		/* if file name is being parsed, translate to ansi */
		if (pmmio->dwFlags & (MMIO_PARSE | MMIO_EXIST))
		{
			OemToAnsi(of.szPathName, (LPSTR) lParam1);
			return (LRESULT) 0;
		}

		/* check the current file offset */
		pmmio->lDiskOffset = _llseek(pInfo->fh, 0L, SEEK_CUR);
		
		return (LRESULT) 0;

	case MMIOM_CLOSE:

		/* MMIO_FHOPEN flag means keep the DOS file handle open */
		if (!((DWORD)lParam1 & MMIO_FHOPEN) && (_lclose(pInfo->fh) == HFILE_ERROR))
			return (LRESULT) MMIOERR_CANNOTCLOSE;
		else
			return (LRESULT) 0;

        case MMIOM_READ:
                lResult = _hread(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset += lResult;

                return (LRESULT) lResult;

	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:
                lResult = _hwrite(pInfo->fh, (LPVOID)lParam1, (LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset += lResult;

#ifdef DOSCANFLUSH
		if (wMsg == MMIOM_WRITEFLUSH)
		{
			/* Issue hardware flush command */
		}
#endif
                return (LRESULT) lResult;

        case MMIOM_SEEK:
                lResult = _llseek(pInfo->fh, (LONG)lParam1, (int)(LONG)lParam2);

                if (lResult != -1L)
                        pmmio->lDiskOffset = lResult;

                return (LRESULT) lResult;

	case MMIOM_RENAME:
		if (lrename((LPCSTR)lParam1, (LPCSTR)lParam2))
			return (LRESULT) MMIOERR_FILENOTFOUND;
		break;

	}

	return (LRESULT) 0;
}


/* @doc INTERNAL

@api	LRESULT | mmioMEMIOProc | The 'MEM' I/O procedure, which handles I/O
	on memory files.

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	UINT | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
static LRESULT CALLBACK
mmioMEMIOProc(LPSTR lpmmioStr, UINT wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (UINT) (LONG) lpmmioStr; // only in DLL!

	switch (wMsg)
	{

        case MMIOM_OPEN:

		if (pmmio->dwFlags & ~(MMIO_CREATE | MMIO_READWRITE | MMIO_WRITE | MMIO_EXCLUSIVE | MMIO_DENYWRITE | MMIO_DENYREAD | MMIO_DENYNONE | MMIO_ALLOCBUF))
			return (LRESULT) MMSYSERR_INVALFLAG;

		/* all the data in the buffer is valid */
		if (!(pmmio->dwFlags & MMIO_CREATE))
			pmmio->pchEndRead = pmmio->pchEndWrite;
		return (LRESULT) 0;

	case MMIOM_CLOSE:

		/* nothing special to do on close */
		return (LRESULT) 0;

	case MMIOM_READ:
	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:
	case MMIOM_SEEK:
                return (LRESULT) -1;
	}

	return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmioi.h ===
/* mmioi.h
 *
 * Definitions that are internal to the MMIO library.
 */

typedef MMIOINFO NEAR *PMMIO;

#define	PH(hmmio)	((PMMIO)(hmmio))
#define	HP(pmmio)	((HMMIO)(pmmio))

typedef struct _MMIODOSINFO		// How DOS IOProc uses MMIO.adwInfo[]
{
	HFILE		fh;		// DOS file handle
} MMIODOSINFO;

typedef struct _MMIOMEMINFO		// How MEM IOProc uses MMIO.adwInfo[]
{
	LONG		lExpand;	// increment to expand mem. files by
} MMIOMEMINFO;

#define	STATICIOPROC	0x0001

typedef struct _IOProcMapEntry
{
	FOURCC		fccIOProc;	// ID of installed I/O procedure
	LPMMIOPROC	pIOProc;	// I/O procedure address
	HTASK		hTask;		// task that called mmioRegisterIOProc()
	UINT		wFlags;
	struct _IOProcMapEntry *pNext;	// pointer to next IOProc entry
} IOProcMapEntry;

// standard I/O procedures
LRESULT CALLBACK mmioBNDIOProc(LPSTR, UINT, LPARAM, LPARAM);

/* prototypes from "hmemcpy.asm" */
LPVOID NEAR PASCAL MemCopy(LPVOID dest, const void FAR * source, LONG count);
LPSTR NEAR PASCAL fstrrchr(LPCSTR lsz, char c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmiocf.c ===
/* cf.c
 *
 * MMIO RIFF compound file functions.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmiocf.h"
#include "mmioi.h"

/* @doc CFDOC

@api	HMMCF | mmioCFOpen | Open a RIFF compound file by name.

@parm	LPSTR | szFileName | The name of the RIFF compound file.

@parm	DWORD | dwFlags | Zero or more of the following flags:
	MMIO_READ, MMIO_WRITE, MMIO_READWRITE, MMIO_COMPAT, MMIO_EXCLUSIVE,
	MMIO_DENYWRITE, MMIO_DENYREAD, MMIO_DENYNONE, MMIO_CREATE.
	See <f mmioOpen> for a description of these flags.

@rdesc	Returns a handle to the open compound file.  Returns NULL if the
	compound file could not be opened.  If the compound file was already
	opened by this process, a handle to the compound file is returned,
	and the usage count of the compound file is incremented.

@comm	A RIFF compound file is any RIFF file that contains a 'CTOC'
	chunk (compound file table of contents) and a 'CGRP' chunk
	(compound file resource group).  The RIFF compound file format
	is documented separately.

	If the MMIO_CREATE flag is specified, then:

	-- If the compound file is already open, the handle to that compound
	file is returned.

	-- If <p dwFlags> includes MMIO_WRITE, then the compound file will
	actually be opened for both reading and writing, since a compound
	file cannot be opened for writing alone.

	Every call to <f mmioCFOpen> must be matched by a call to
	<f mmioCFClose>.
*/
HMMCF API
mmioCFOpen(LPSTR szFileName, DWORD dwFlags)
{
	/* TO DO */
	return NULL;
}


/* @doc CFDOC

@api	HMMCF | mmioCFAccess | Open a RIFF compound file by reading the
	'CTOC' chunk (compound file table of contents) from a file that
	was opened by <f mmioOpen>.

@parm	HMMIO | hmmio | The open file handle returned by <f mmioOpen>.

@parm	LPMMCFINFO | lpmmcfinfo | Optional information used if
	<p dwFlags> if the compound file is to be created.  <p lpmmcfinfo>
	may be NULL if default information is to be used.
	If <p lpmmcfinfo> is provided, then the following
	fields should be filled in.  Note that all these fields, including
	the arrays, can be coded in a fixed C structure for a specific
	file format, for the purposes of creating a new compound file.
	However, note that if an existing compound file is opened, the
	caller should expect that additional (possibly unknown) "extra
	fields" may be present.

	@flag	dwEntriesTotal | Should contain the initial number of
		(unused) entries in the table of contents (default 16).

	@flag	dwHeaderFlags | Should contain zero.

	@flag	wNameSize | The size of the <p achName> field of each
		CTOC entry (default 13).

	@flag	wExHdrFields | The number of extra header fields to
		allocate at the end of the CTOC header (default 0).

	@flag	wExEntFields | The number of extra entry fields
		at the end of each CTOC entry (default 0).

	@flag	awExHdrFldUsage | Usage codes for extra header fields
		(default no usage code).

	@flag	awExHdrEntUsage | Usage codes for extra entry fields
		(default no usage code).

	@flag	adwExHdrField | Extra header field values
		(default no extra header field values).

@parm	DWORD | dwFlags | Zero or more of the following flags:

	@flag	MMIO_CREATE | Create a compound file, i.e. create
		the 'CTOC' and 'CGRP' chunks.

	@flag	MMIO_CTOCFIRST | Create the empty 'CTOC' chunk
		immediately and place it before the 'CGRP' chunk.
		If the 'CTOC' chunk gets too big, it may later have to
		be rewritten after the 'CGRP' chunk.

		This flag is ignored unless MMIO_CREATE is specified.

@rdesc	Returns a handle to the open compound file.  Returns NULL if the
	compound file could not be opened.

@comm	This function will open a RIFF compound file, assuming that
	<p hmmio> has already been descended into the RIFF file
	(using <f mmioDescend>) and <p hmmio> points to the beginning
	of a chunk header.  <p mmioCFAccess> scans through the file,
	looking for a 'CTOC' and 'CGRP' chunk.  If these chunks are not
	found but MMIO_CREATE is specified, then a 'CTOC' chunk is created
	(if MMIO_CTOCFIRST is specified) then a 'CGRP' chunk is created.
	The CTOC is then maintained in memory until <f mmioCFClose>
	is called.

	Every call to <f mmioCFAccess> must be matched by a call to
	<f mmioCFClose>.
*/
HMMCF API
mmioCFAccess(HMMIO hmmio, LPMMCFINFO lpmmcfinfo, DWORD dwFlags)
{
	/* TO DO */
	return NULL;
}


/* @doc CFDOC

@api	WORD | mmioCFClose | Close a compound file that was opened by
	<f mmioCFOpen> or <f mmioCFAccess>.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	WORD | wFlags | Is not used and should be set to zero.

@comm	This function decrements the usage count of the compound file
	<p hmmcf>.  If the usage count drops to zero, the compound file
	is closed.  If the compound file was opened by <f mmioCFAccess>,
	then the <p hmmcf> information is deallocated but the HMMIO
	file handle associated with the compound file is not closed.
*/
WORD API
mmioCFClose(HMMCF hmmcf, WORD wFlags)
{
	/* TO DO */
	return 0;
}


/* @doc CFDOC

@api	WORD | mmioCFCopy | Copy the 'CTOC' and 'CGRP' chunks from an open
	RIFF compound file to another file.  The newly written 'CGRP' chunk
	will be compacted, i.e. it will have no deleted elements.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	HMMIO | hmmio | An open file handle returned by <f mmioOpen>.
	The compound file is copied to <p hmmio>.

@parm	DWORD | dwFlags | Is not used and should be set to zero.

@rdesc	If the function succeeds, zero is returned.  If the function fails,
	an error code is returned.

@comm	<f mmioCFCopy> assumes that the current file position of <p hmmio> 
	is the end of a file, descended into a 'RIFF' chunk.  <f mmioCFCopy>
	creates copies the 'CTOC' and 'CGRP' chunks from <p hmmcf> to
	<p hmmio>.  A side effect of the copy operation is that the
	copy of the compound file is compacted, i.e. there are no deleted
	elements.
*/
WORD API
mmioCFCopy(HMMCF hmmcf, HMMIO hmmio, DWORD dwFlags)
{
	/* TO DO */
	return 0;
}


/* @doc CFDOC

@api	DWORD | mmioCFGetInfo | Retrieve information from the CTOC header
	of an open RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPMMCFINFO | lpmmcfinfo | A caller-supplied buffer that will be
	filled in with the CTOC header.

@parm	DWORD | cb | The size of buffer <p lpmmcfinfo>.  At most <p cb> 
	bytes will be copied into <p lpmmcfinfo>.

@rdesc	Returns the number of bytes copied into <p lpmmcfinfo>.

@comm	The information that is copied to <p lpmmcfinfo> consists of
	an MMCFINFO structure followed by the variable-length arrays
	<p awExHdrFldUsage>, <p awExEntFldUsage>, and <p adwExHdrField>.
	See the definition of RIFF Compound Files for more information.

	To find out how big the RIFF CTOC header is (e.g. to allocate
	enough memory for the entire block), call <f mmioCFGetInfo>
	with <p cb> equal to the size of a DWORD, and the function will
	copy the first field of the MMCFINFO structure (i.e.
	<p dwHeaderSize>, the size of the CTOC header) into <p lpmmcfinfo>.
*/
DWORD API
mmioCFGetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb)
{
	DWORD		dwBytes;

	dwBytes = min(cb, PC(hmmcf)->pHeader->dwHeaderSize);
        MemCopy(lpmmcfinfo, PC(hmmcf)->pHeader, dwBytes);
	return dwBytes;
}


/* @doc CFDOC

@api	DWORD | mmioCFSetInfo | Modify information that is stored in the
	CTOC header of an open RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPMMCFINFO | lpmmcfinfo | A caller-supplied buffer that was filled
	in by <f mmioCFGetInfo> and then modified by the caller.  Only
	the <p awExHdrFldUsage> and <p adwExHdrField> fields should be
	modified.

@parm	DWORD | cb | The size of buffer <p lpmmcfinfo>.

@rdesc	Returns the number of bytes copied from <p lpmmcfinfo>.

@comm	See <f mmioCFGetInfo> for more information.
*/
DWORD API
mmioCFSetInfo(HMMCF hmmcf, LPMMCFINFO lpmmcfinfo, DWORD cb)
{
	/* TO DO:
	 * Re-allocate CTOC header if necessary and copy <p lpmmcfinfo> to it.
	 */

	return 0L;
}


/* @doc CFDOC

@api	LPMMCTOCENTRY | mmioCFFindEntry | Find an particular entry in an open
	RIFF compound file.

@parm	HMMCF | hmmcf | A compound file handle returned by <f mmioCFOpen>
	or <f mmioCFAccess>.

@parm	LPSTR | szName | Then name of the compound file element to look for.
	The search is case-insensitive.  Flags in <p wFlags> can be set to
	specify that an element is to be searched for by some attribute other
	than name.

@parm	WORD | wFlags | Zero or more of the following flags:

	@flag	MMIO_FINDFIRST | Find the first entry in the CTOC table.

	@flag	MMIO_FINDNEXT | Find the next entry in the CTOC table
		after the entry <p lParam> (which should be an
		LPMMCTOCENTRY pointer returned by this function).
		Returns NULL if <p lParam> refers to the last entry.

	@flag	MMIO_FINDUNUSED | Find the first entry in the CTOC table
		that is marked as "unused", i.e. the entry does not refer
		to any part of the compound file.

	@flag	MMIO_FINDDELETED | Find the first entry in the CTOC table
		that is marked as "deleted", i.e. the entry refers to a
		compound file element that occupies space in the CGRP
		chunk but is currently unused.

@parm	LPARAM | lParam | Additional information (see <p wFlags> above).

@rdesc	Returns a pointer to the CTOC table entry that was found.
	If no entry was found, NULL is returned.  Warning: assume that
	the returned pointer is invalid after the next call to any MMIO
	function.

@comm	MMIO_FINDFIRST and MMIO_FINDNEXT can be used to enumerate the entries
	in an open RIFF compound file.
*/
LPMMCTOCENTRY API
mmioCFFindEntry(HMMCF hmmcf, LPSTR szName, WORD wFlags, LPARAM lParam)
{
	LPSTR		pchEntry;
	DWORD		dwElemNum;

	if (wFlags & MMIO_FINDFIRST)
		return (LPMMCTOCENTRY) PC(hmmcf)->pEntries;

	if (wFlags & MMIO_FINDNEXT)
	{
		pchEntry = (LPSTR) lParam + PC(hmmcf)->wEntrySize;
		if (pchEntry > PC(hmmcf)->pEntries
			  + PC(hmmcf)->pHeader->dwEntriesTotal * PC(hmmcf)->wEntrySize)
			return NULL;
		else
			return (LPMMCTOCENTRY) pchEntry;
	}

	for (pchEntry = PC(hmmcf)->pEntries, dwElemNum = 0;
	     dwElemNum < PC(hmmcf)->pHeader->dwEntriesTotal;
	     pchEntry += PC(hmmcf)->wEntrySize, dwElemNum++)
	{
		BYTE		bFlags;

		bFlags = *(BYTE FAR *) (pchEntry + PC(hmmcf)->wEntFlagsOffset);

		if ((wFlags & MMIO_FINDUNUSED) && (bFlags & CTOC_EF_UNUSED))
			return (LPMMCTOCENTRY) pchEntry;

		if ((wFlags & MMIO_FINDDELETED) && (bFlags & CTOC_EF_DELETED))
			return (LPMMCTOCENTRY) pchEntry;

		if (bFlags & (CTOC_EF_DELETED | CTOC_EF_UNUSED))
			continue;

		if (lstrcmpi(szName, pchEntry + PC(hmmcf)->wEntNameOffset) == 0)
			return (LPMMCTOCENTRY) pchEntry;
	}

	return NULL;
}


/* @doc INTERNAL

@api	LRESULT | mmioBNDIOProc | The 'BND' I/O procedure, which handles I/O
	on RIFF compound file elements (including BND files).

@parm	LPSTR | lpmmioinfo | A pointer to an MMIOINFO block that
	contains information about the open file.

@parm	WORD | wMsg | The message that the I/O procedure is being
	asked to execute.

@parm	LPARAM | lParam1 | Specifies additional message information.

@parm	LPARAM | lParam2 | Specifies additional message information.

@rdesc	Return value depends on <p wMsg>.
*/
LRESULT CALLBACK
mmioBNDIOProc(LPSTR lpmmioStr, WORD wMsg, LPARAM lParam1, LPARAM lParam2)
{
	PMMIO		pmmio = (PMMIO) (WORD) (LONG) lpmmioStr; // only in DLL!
	MMIOBNDINFO *	pInfo = (MMIOBNDINFO *) pmmio->adwInfo;
	LPSTR		szFileName = (LPSTR) lParam1;
	PMMCF		pmmcf = PC(pInfo->hmmcf); // CF status block
	LPSTR		szElemName;	// name of CF element
	LONG		lBytesLeft;	// bytes left in file
	LONG		lExpand;	// how much element expanded by
	LONG		lEndElement;	// offset of end of element
	LONG		lResult;
	LPSTR		pch;

	switch (wMsg)
	{

	case MMIOM_OPEN:

		if (pmmcf == NULL)
		{

			/* expect <lParam1> is "...foo.bnd!element" */
			if ((pch = fstrrchr(szFileName, CFSEPCHAR)) == NULL)
				return (LRESULT) MMIOERR_CANNOTOPEN;

			*pch = 0;		// temporarily zero the "!"
			if (pch[1] == 0)	// is name of form "foo.bnd!"?
				return (LRESULT) MMIOERR_CANNOTOPEN;
			pInfo->hmmcf = mmioCFOpen(szFileName, (LONG) lParam2);
			pmmcf = (PMMCF) pInfo->hmmcf;
			*pch = CFSEPCHAR;
			if (pInfo->hmmcf == NULL)
				return (LRESULT) MMIOERR_CANNOTOPEN;
			szElemName = pch + 1;

			/* decrement the usage count, since the usage count
			 * was incremented by mmioCFOpen() and will
			 * be incremented below, but this MMIOM_OPEN
			 * represents only a single usage
			 */
			pmmcf->lUsage--;
		}
		else
		{
			/* expect <lParam1> is CF element name */
			szElemName = szFileName;
		}

		/* TO DO...
		 * If compound file is opened for writing or create(truncate),
		 * then make new entry at end (copying entry if required);
		 */

		/* <pmmcf> is a handle to the compound file containing
		 * the element, and <szElemName> is the name of the element
		 */
		if ((pInfo->pEntry = mmioCFFindEntry(pInfo->hmmcf,
				szElemName, 0, 0L)) == NULL)
		{
			mmioCFClose(pInfo->hmmcf, 0);
			return (LRESULT) MMIOERR_CANNOTOPEN;
		}

		if (pmmio->dwFlags & MMIO_DELETE)
		{
			/* TO DO: delete element: mark as deleted, update
			 * CTOC header, etc.
			 */
		}

		if (pmmio->dwFlags & (MMIO_PARSE | MMIO_EXIST))
		{
			/* TO DO: qualify name
			 */
		}

		return (LRESULT) 0;

	case MMIOM_CLOSE:

		mmioCFClose(pInfo->hmmcf, 0);
		return (LRESULT) 0;

	case MMIOM_READ:

		lBytesLeft = pInfo->pEntry->dwSize - pmmio->lDiskOffset;
		if ((LONG) lParam2 > lBytesLeft)
			(LONG) lParam2 = lBytesLeft;
		if (mmioSeek(pmmcf->hmmio, pmmio->lDiskOffset, SEEK_SET) == -1L)
			return (LRESULT) -1L;
		if ((lResult = mmioRead(pmmcf->hmmio,
				        (HPSTR) lParam1, (LONG) lParam2)) == -1L)
			return (LRESULT) -1L;
		pmmio->lDiskOffset += lResult;
		return (LRESULT) lResult;

	case MMIOM_WRITE:
	case MMIOM_WRITEFLUSH:		/* Note: flush not really handled! */

		lEndElement = pmmcf->lStartCGRPData + pInfo->pEntry->dwOffset
			+ pInfo->pEntry->dwSize;
		if ((lEndElement != pmmcf->lEndCGRP) ||
		    (pmmcf->lEndCGRP != pmmcf->lEndFile))
		{
			/* this CF element is not growable -- limit writing
			 * to the current end of the CF element
			 */
			lBytesLeft = pInfo->pEntry->dwSize - pmmio->lDiskOffset;
			if ((LONG) lParam2 > lBytesLeft)
				(LONG) lParam2 = lBytesLeft;
		}
		if ((lResult = mmioWrite(pmmcf->hmmio,
				         (HPSTR) lParam1, (LONG) lParam2)) == -1L)
			return (LRESULT) -1L;
		pmmio->lDiskOffset += lResult;

		if ((lExpand = pmmio->lDiskOffset - pInfo->pEntry->dwSize) > 0)
		{
			pInfo->pEntry->dwSize += lExpand;
			pmmcf->lEndCGRP += lExpand;
			pmmcf->lEndFile += lExpand;
			pmmcf->lTotalExpand += lExpand;
		}

		return (LRESULT) lResult;

	case MMIOM_SEEK:

		/* calculate the new <lDiskOffset> (the current disk offset
		 * relative to the beginning of the compound file); don't
		 * bother seeking, since we'll have to seek again anyway
		 * at the next read (since <pmmcf->hmmio> is shared between
		 * all elements of the compound file)
		 */
		switch ((int)(LONG) lParam2)
		{

		case SEEK_SET:

			pmmio->lDiskOffset = pmmcf->lStartCGRPData
				+ pInfo->pEntry->dwOffset + (DWORD)lParam1;
			break;

		case SEEK_CUR:

			pmmio->lDiskOffset += lParam1;
			break;

		case SEEK_END:

			pmmio->lDiskOffset = pmmcf->lStartCGRPData +
				+ pInfo->pEntry->dwOffset
				+ pInfo->pEntry->dwSize - (DWORD)lParam1;
			break;
		}

		return (LRESULT) pmmio->lDiskOffset;

	case MMIOM_GETCF:

		return (LRESULT)(LONG)(WORD) pInfo->hmmcf;

	case MMIOM_GETCFENTRY:

		return (LRESULT) pInfo->pEntry;
	}

	return (LRESULT) 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmioriff.c ===
/* mmioriff.c
 *
 * MMIO RIFF functions.
 */

#include <windows.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "mmioi.h"

#define BCODE BYTE _based(_segname("_CODE"))
static	BCODE bPad;

/* @doc EXTERNAL

@api	UINT | mmioDescend | This function descends into a chunk of a
	RIFF file opened with <f mmioOpen>. It can also search for a given
	chunk.

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm	LPMMCKINFO | lpck | Specifies a far pointer to a
	caller-supplied  <t MMCKINFO> structure that <f mmioDescend> fills
	with the following information:

	-- The <e MMCKINFO.ckid> field is the chunk ID of the chunk.

	-- The <e MMCKINFO.cksize> field is the size of the data portion
	of the chunk. The data size includes the form type or list type (if
	any), but does not include the 8-byte chunk header or the pad byte at
	the end of the data (if any).

	-- The <e MMCKINFO.fccType> field is the form type if 
	<e MMCKINFO.ckid> is "RIFF", or the list type if 
	<e MMCKINFO.ckid> is "LIST". Otherwise, it is NULL.

	-- The <e MMCKINFO.dwDataOffset> field is the file offset of the
	beginning of the data portion of the chunk.	If the chunk is a
	"RIFF" chunk or a "LIST" chunk, then <e MMCKINFO.dwDataOffset>
	is the offset of the form type or list type.

	-- The <e MMCKINFO.dwFlags> contains other information about the chunk.
	Currently, this information is not used and is set to zero.

	If the MMIO_FINDCHUNK, MMIO_FINDRIFF, or MMIO_FINDLIST flag is
	specified for <p wFlags>, then the <t MMCKINFO> structure is also
	used to pass parameters to <f mmioDescend>:

	-- The <e MMCKINFO.ckid> field specifies the four-character code
	of the chunk ID, form type, or list type to search for.

@parm	LPMMCKINFO | lpckParent | Specifies a far pointer to an
	optional caller-supplied <t MMCKINFO> structure identifying
	the parent of the chunk being searched for.
	A parent of a chunk is the enclosing chunk--only "RIFF" and "LIST"
	chunks can be parents.  If <p lpckParent> is not NULL, then 
	<f mmioDescend> assumes the <t MMCKINFO> structure it refers to
	was filled when <f mmioDescend> was called to descend into the parent
	chunk, and <f mmioDescend> will only search for a chunk within the
	parent chunk. Set <p lpckParent> to NULL if no parent chunk is
	being specified.

@parm	UINT | wFlags | Specifies search options. Contains up to one
	of the following flags. If no flags are specified, 
	<f mmioDescend> descends into the chunk beginning at the current file
	position. 

	@flag	MMIO_FINDCHUNK | Searches for a chunk with the specified chunk ID.

	@flag	MMIO_FINDRIFF | Searches for a chunk with chunk ID "RIFF"
		and with the specified form type.

	@flag	MMIO_FINDLIST | Searches for a chunk with chunk ID "LIST"
		and with the specified form type.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. If the end of
	the file (or the end of the parent chunk, if given) is reached before
	the desired chunk is found, the return value is
	MMIOERR_CHUNKNOTFOUND. 

@comm	A RIFF chunk consists of a four-byte chunk ID (type FOURCC),
	followed by a four-byte chunk size (type DWORD), followed
	by the data portion of the chunk, followed by a null pad byte if
	the size of the data portion is odd. If the chunk ID is "RIFF" or
	"LIST", the first four bytes of the data portion of the chunk are
	a form type or list type (type FOURCC).

	If <f mmioDescend> is used to search for a chunk, the file 
	position should be at the beginning of a
	chunk before calling <f mmioDescend>. The search begins at the
	current file position and continues to the end of the file. If a
	parent chunk is specified, the file position should be somewhere
	within the parent chunk before calling <f mmioDescend>. In this case,
	the search begins at the current file position and continues to the
	end of the parent chunk.

	If <f mmioDescend> is unsuccessful in searching for a chunk, the
	current file position is undefined. If <f mmioDescend> is
	successful, the current file position is changed. If the chunk 
	is a "RIFF" or "LIST" chunk, the new file position
	will be just after the form type or list type (12 bytes from the
	beginning of the chunk). For other chunks, the new file position will be
	the start of the data portion of the chunk (8 bytes from the
	beginning of the chunk).
		
	For efficient RIFF file I/O, use buffered I/O.

	@xref	mmioAscend MMCKINFO
*/
UINT WINAPI
mmioDescend(HMMIO hmmio, LPMMCKINFO lpck, const MMCKINFO FAR* lpckParent, UINT wFlags)
{
	FOURCC		ckidFind;	// chunk ID to find (or NULL)
	FOURCC		fccTypeFind;	// form/list type to find (or NULL)

	V_FLAGS(wFlags, MMIO_DESCEND_VALID, mmioDescend, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);
	V_RPOINTER0(lpckParent, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	/* figure out what chunk id and form/list type to search for */
	if (wFlags & MMIO_FINDCHUNK)
		ckidFind = lpck->ckid, fccTypeFind = NULL;
	else
	if (wFlags & MMIO_FINDRIFF)
		ckidFind = FOURCC_RIFF, fccTypeFind = lpck->fccType;
	else
	if (wFlags & MMIO_FINDLIST)
		ckidFind = FOURCC_LIST, fccTypeFind = lpck->fccType;
	else
		ckidFind = fccTypeFind = NULL;
	
	lpck->dwFlags = 0L;

	while (TRUE)
	{
		UINT		w;

		/* read the chunk header */
		if (mmioRead(hmmio, (HPSTR) lpck, 2 * sizeof(DWORD)) !=
		    2 * sizeof(DWORD))
			return MMIOERR_CHUNKNOTFOUND;

		/* store the offset of the data part of the chunk */
		if ((lpck->dwDataOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		
		/* see if the chunk is within the parent chunk (if given) */
		if ((lpckParent != NULL) &&
		    (lpck->dwDataOffset - 8L >=
		     lpckParent->dwDataOffset + lpckParent->cksize))
			return MMIOERR_CHUNKNOTFOUND;

		/* if the chunk if a 'RIFF' or 'LIST' chunk, read the
		 * form type or list type
		 */
		if ((lpck->ckid == FOURCC_RIFF) || (lpck->ckid == FOURCC_LIST))
		{
			if (mmioRead(hmmio, (HPSTR) &lpck->fccType,
				     sizeof(DWORD)) != sizeof(DWORD))
				return MMIOERR_CHUNKNOTFOUND;
		}
		else
			lpck->fccType = NULL;

		/* if this is the chunk we're looking for, stop looking */
		if ( ((ckidFind == NULL) || (ckidFind == lpck->ckid)) &&
		     ((fccTypeFind == NULL) || (fccTypeFind == lpck->fccType)) )
			break;
		
		/* ascend out of the chunk and try again */
		if ((w = mmioAscend(hmmio, lpck, 0)) != 0)
			return w;
	}

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioAscend | This function ascends out of a chunk in a
	RIFF file descended into with <f mmioDescend> or created with 
	<f mmioCreateChunk>. 

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF file.

@parm	LPMMCKINFO | lpck | Specifies a far pointer to a
	caller-supplied <t MMCKINFO> structure previously filled by 
	<f mmioDescend> or <f mmioCreateChunk>.

@parm	UINT | wFlags | Is not used and should be set to zero.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:

	@flag MMIOERR_CANNOTWRITE | The contents of the buffer could
	not be written to disk.
	    
	@flag MMIOERR_CANNOTSEEK | There was an error while seeking to
	the end of the chunk.

@comm	If the chunk was descended into using <f mmioDescend>, then
	<f mmioAscend> seeks to the location following the end of the
	chunk (past the extra pad byte, if any).

	If the chunk was created and descended into using
	<f mmioCreateChunk>, or if the MMIO_DIRTY flag is set in the 
	<e MMCKINFO.dwFlags> field of the <t MMCKINFO> structure
	referenced by <p lpck>, then the current file position
	is assumed to be the end of the data portion of the chunk.
	If the chunk size is not the same as the value stored
	in the <e MMCKINFO.cksize> field when <f mmioCreateChunk>
	was called, then <f mmioAscend> corrects the chunk
	size in the file before ascending from the chunk. If the chunk
	size is odd, <f mmioAscend> writes a null pad byte at the end of the
	chunk. After ascending from the chunk, the current file position is
	the location following the end of the chunk (past the extra pad byte,
	if any).

@xref	mmioDescend mmioCreateChunk MMCKINFO
*/
UINT WINAPI
mmioAscend(HMMIO hmmio, LPMMCKINFO lpck, UINT wFlags)
{
	V_FLAGS(wFlags, 0, mmioAscend, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	if (lpck->dwFlags & MMIO_DIRTY)
	{
		/* <lpck> refers to a chunk created by mmioCreateChunk();
		 * check that the chunk size that was written when
		 * mmioCreateChunk() was called is the real chunk size;
		 * if not, fix it
		 */
		LONG		lOffset;	// current offset in file
		LONG		lActualSize;	// actual size of chunk data

		if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
			return MMIOERR_CANNOTSEEK;
		if ((lActualSize = lOffset - lpck->dwDataOffset) < 0)
			return MMIOERR_CANNOTWRITE;

		if (LOWORD(lActualSize) & 1)
		{
			/* chunk size is odd -- write a null pad byte */
			if (mmioWrite(hmmio, (HPSTR) &bPad, sizeof(bPad))
					!= sizeof(bPad))
				return MMIOERR_CANNOTWRITE;
			
		}

		if (lpck->cksize == (DWORD)lActualSize)
			return 0;

		/* fix the chunk header */
		lpck->cksize = lActualSize;
		if (mmioSeek(hmmio, lpck->dwDataOffset
				- sizeof(DWORD), SEEK_SET) == -1)
			return MMIOERR_CANNOTSEEK;
		if (mmioWrite(hmmio, (HPSTR) &lpck->cksize,
				sizeof(DWORD)) != sizeof(DWORD))
			return MMIOERR_CANNOTWRITE;
	}

	/* seek to the end of the chunk, past the null pad byte
	 * (which is only there if chunk size is odd)
	 */
	if (mmioSeek(hmmio, lpck->dwDataOffset + lpck->cksize
		+ (lpck->cksize & 1L), SEEK_SET) == -1)
		return MMIOERR_CANNOTSEEK;

	return 0;
}


/* @doc EXTERNAL

@api	UINT | mmioCreateChunk | This function creates a chunk in a
	RIFF file opened with <f mmioOpen>. The new chunk is created at the
	current file position. After the new chunk is created, the current
	file position is the beginning of the data portion of the new chunk.

@parm	HMMIO | hmmio | Specifies the file handle of an open RIFF
	file.

@parm	LPMMCKINFO | lpck | Specifies a pointer to a caller-supplied
	<t MMCKINFO> structure containing information about the chunk to be
	created. The <t MMCKINFO> structure should be set up as follows:

	-- The <e MMCKINFO.ckid> field specifies the chunk ID of the
	chunk. If <p wFlags> includes MMIO_CREATERIFF or MMIO_CREATELIST,
	this field will be filled by <f mmioCreateChunk>.

	-- The <e MMCKINFO.cksize> field specifies the size of the data
	portion of the chunk, including the form type or list type (if any).
	If this value is not correct when <f mmioAscend> is called to mark
	the end of the chunk, them <f mmioAscend> will correct the chunk
	size.

	-- The <e MMCKINFO.fccType> field specifies the form type or list
	type if the chunk is a "RIFF" or "LIST" chunk. If the chunk is not a
	"RIFF" or "LIST" chunk, this field need not be filled in.

	-- The <e MMCKINFO.dwDataOffset> field need not be filled in. The
	<f mmioCreateChunk> function will fill this field with the file
	offset of the data portion of the chunk.

	-- The <e MMCKINFO.dwFlags> field need not be filled in. The 
	<f mmioCreateChunk> function will set the MMIO_DIRTY flag in 
	<e MMCKINFO.dwFlags>.

@parm	UINT | wFlags | Specifies flags to optionally create either a
	"RIFF" chunk or a "LIST" chunk. Can contain one of the following
	flags: 

	@flag	MMIO_CREATERIFF | Creates a "RIFF" chunk.

	@flag	MMIO_CREATELIST | Creates a "LIST" chunk.

@rdesc	The return value is zero if the function is successful.
	Otherwise, the return value specifies an error code. The error
	code can be one of the following codes:

	@flag MMIOERR_CANNOTWRITE | Unable to write the chunk header.

	@flag MMIOERR_CANNOTSEEK | Uanble to determine offset of data
    portion of the chunk.

@comm	This function cannot insert a chunk into the middle of a
	file. If a chunk is created anywhere but the end of a file, 
	<f mmioCreateChunk> will overwrite existing information in the file.
*/
UINT WINAPI
mmioCreateChunk(HMMIO hmmio, LPMMCKINFO lpck, UINT wFlags)
{
	int		iBytes;			// bytes to write
	LONG		lOffset;	// current offset in file

	V_FLAGS(wFlags, MMIO_CREATE_VALID, mmioCreateChunk, MMSYSERR_INVALFLAG);
	V_WPOINTER(lpck, sizeof(MMCKINFO), MMSYSERR_INVALPARAM);

	/* store the offset of the data part of the chunk */
	if ((lOffset = mmioSeek(hmmio, 0L, SEEK_CUR)) == -1)
		return MMIOERR_CANNOTSEEK;
	lpck->dwDataOffset = lOffset + 2 * sizeof(DWORD);

	/* figure out if a form/list type needs to be written */
	if (wFlags & MMIO_CREATERIFF)
		lpck->ckid = FOURCC_RIFF, iBytes = 3 * sizeof(DWORD);
	else
	if (wFlags & MMIO_CREATELIST)
		lpck->ckid = FOURCC_LIST, iBytes = 3 * sizeof(DWORD);
	else
		iBytes = 2 * sizeof(DWORD);

	/* write the chunk header */
	if (mmioWrite(hmmio, (HPSTR) lpck, (LONG) iBytes) != (LONG) iBytes)
		return MMIOERR_CANNOTWRITE;

	lpck->dwFlags = MMIO_DIRTY;

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmsysi.h ===
/*
    mmsysi.h

    private include file for mm kitchen sink

*/

#include <logerror.h>

#ifdef DEBUG
    #define DEBUG_RETAIL
#endif

#define WinFlags (WORD)(&__WinFlags)
extern short pascal __WinFlags;

extern HINSTANCE ghInst;

// Define the product version to be returned from
// mmsystemgetversion and any other messagebox or
// API that needs the public product version.

#define MMSYSTEM_VERSION 0X0101

#define MM_SND_PLAY     (WM_MM_RESERVED_FIRST+0x2B)

/* -------------------------------------------------------------------------
** Thunking stuff
** -------------------------------------------------------------------------
*/
DWORD
mciAppExit(
    HTASK hTask
    );

/****************************************************************************

    external interupt time data (in INTDS)

    this global data is in the FIXED DATA SEGMENT.

****************************************************************************/

extern WORD         FAR PASCAL gwStackFrames;           // in STACK.ASM
extern WORD         FAR PASCAL gwStackSize;             // in STACK.ASM
extern HGLOBAL      FAR PASCAL gwStackSelector;         // in STACK.ASM
extern WORD         FAR PASCAL gwStackUse;              // in STACK.ASM
extern HLOCAL       FAR PASCAL hdrvDestroy;             // in STACK.ASM
extern HDRVR        FAR PASCAL hTimeDrv;                // in TIMEA.ASM
extern FARPROC      FAR PASCAL lpTimeMsgProc;           // in TIMEA.ASM
extern WORD         FAR PASCAL fDebugOutput;            // in COMM.ASM

/****************************************************************************

KERNEL APIs we use that are not in WINDOWS.H

****************************************************************************/

//extern long WINAPI _hread(HFILE, void _huge*, long);
//extern long WINAPI _hwrite(HFILE, const void _huge*, long);

extern UINT FAR PASCAL LocalCountFree(void);
extern UINT FAR PASCAL LocalHeapSize(void);

/****************************************************************************

  API to install/remove a MMSYS driver

****************************************************************************/

#define MMDRVI_TYPE          0x000F  // low 4 bits give driver type
#define MMDRVI_WAVEIN        0x0001
#define MMDRVI_WAVEOUT       0x0002
#define MMDRVI_MIDIIN        0x0003
#define MMDRVI_MIDIOUT       0x0004
#define MMDRVI_AUX           0x0005

#define MMDRVI_MAPPER        0x8000  // install this driver as the mapper
#define MMDRVI_HDRV          0x4000  // hDriver is a installable driver
#define MMDRVI_REMOVE        0x2000  // remove the driver

// generic prototype for audio device driver entry-point functions
// midMessage(), modMessage(), widMessage(), wodMessage(), auxMessage()
typedef DWORD (CALLBACK *DRIVERMSGPROC)(UINT wDeviceID, UINT message, DWORD dwInstance, DWORD dwParam1, DWORD dwParam2);

BOOL WINAPI mmDrvInstall(HANDLE hDriver, DRIVERMSGPROC *drvMessage, UINT wFlags);
HDRVR NEAR PASCAL mmDrvOpen( LPSTR szAlias );

/****************************************************************************
****************************************************************************/

//
// exclude some stuff if MMDDK.H is not included
//
#ifdef MMDDKINC   // use this to test for MMDDK.H

    //
    // note this must be the same as MIDIDRV/WAVEDRV/AUXDRV
    //
    typedef struct {
        HDRVR hDriver;              // handle to the module
        DRIVERMSGPROC drvMessage;   // pointer to entry point
        BYTE bNumDevs;              // number of devices supported
        BYTE bUsage;                // usage count (number of handle's open)
    } MMDRV, *PMMDRV;

    #ifndef MMNOMIDI

    typedef MMDRV MIDIDRV, *PMIDIDRV;


    #endif //ifndef MMNOMIDI

    #ifndef MMNOWAVE

    typedef MMDRV WAVEDRV, *PWAVEDRV;

    //
    // Wave Mapper support
    //
    extern LPSOUNDDEVMSGPROC  PASCAL wodMapper;
    extern LPSOUNDDEVMSGPROC  PASCAL widMapper;

    #endif //ifndef MMNOWAVE

    #ifndef MMNOAUX

    typedef MMDRV AUXDRV, *PAUXDRV;

    #endif //ifndef MMNOAUX

    #ifdef DEBUG_RETAIL
    extern BYTE    fIdReverse;
    #endif //ifdef DEBUG_RETAIL

#endif //ifdef MMDDKINC

/****************************************************************************

    prototypes

****************************************************************************/

BOOL FAR  PASCAL JoyInit(void);
BOOL NEAR PASCAL TimeInit(void);

BOOL NEAR PASCAL MCIInit(void);
void NEAR PASCAL MCITerminate(void);

BOOL FAR  PASCAL StackInit(void);           // in init.c

#define IDS_TASKSTUB           2000
#define STR_MCIUNKNOWN         2001
//#define STR_WAVEINPUT          2004
//#define STR_WAVEOUTPUT         2005
//#define STR_MIDIINPUT          2006
//#define STR_MIDIOUTPUT         2007
#ifdef DEBUG
#define STR_MCISSERRTXT        2009
#define STR_MCISCERRTXT        2010
#endif

#define MAXPATHLEN	157	// 144 chars + "\12345678.123"

BOOL FAR PASCAL HugePageLock(LPVOID lpArea, DWORD dwLength);
void FAR PASCAL HugePageUnlock(LPVOID lpArea, DWORD dwLength);

/****************************************************************************

    MMSYSTEM global notify window

****************************************************************************/

extern HWND hwndNotify;                                     // in MMWND.C

BOOL NEAR PASCAL WndInit(void);                             // in MMWND.C
void NEAR PASCAL WndTerminate(void);                        // in MMWND.C

void FAR PASCAL MciNotify(WPARAM wParam, LPARAM lParam);    // in MCI.C
void FAR PASCAL WaveOutNotify(WPARAM wParam, LPARAM lParam);// in PLAYWAV.C
BOOL FAR PASCAL sndPlaySoundI(LPCSTR lszSoundName, UINT wFlags);// in SOUND.C
BOOL FAR PASCAL sndMessage(LPSTR lszSoundName, UINT wFlags);// in SOUND.C

/****************************************************************************

    MCI allocation stuff

****************************************************************************/

extern HGLOBAL FAR PASCAL HeapCreate(int cbSize);
extern void   FAR PASCAL HeapDestroy(HGLOBAL hHeap);
extern LPVOID FAR PASCAL HeapAlloc(HGLOBAL hHeap, int cbSize);
extern LPVOID FAR PASCAL HeapReAlloc(LPVOID lp, int cbSize);
extern void   FAR PASCAL HeapFree(LPVOID lp);

extern  HGLOBAL hMciHeap;            // in MCISYS.C

#define BMCIHEAP _based((_segment)hMciHeap)

#define mciAlloc(cb)            HeapAlloc(hMciHeap, cb)
#define mciReAlloc(lp, size)    HeapReAlloc (lp, size)
#define mciFree(lp)             HeapFree(lp)

/****************************************************************************

    strings

****************************************************************************/

#define SZCODE char _based(_segname("_CODE"))

/****************************************************************************

    handle apis's

****************************************************************************/

//
// all MMSYSTEM handles are tagged with the following structure.
//
// a MMSYSTEM handle is really a fixed local memory object.
//
// the functions NewHandle() and FreeHandle() create and release a MMSYSTEM
// handle.
//
//
//**************************************************************************;
//   IF YOU CHANGE THIS STRUCTURE YOU MUST ALSO CHANGE THE ONE IN DEBUG.ASM
//**************************************************************************;
typedef	struct tagHNDL {
	struct	tagHNDL *pNext;	// link to next handle
	WORD	wType;		// type of handle wave, midi, mmio, ...
	HTASK	hTask;		// task that owns it
}       HNDL,   NEAR *PHNDL;
//**************************************************************************;

#define	HtoPH(h)	((PHNDL)(h)-1)
#define	PHtoH(ph)	((ph) ? (HLOCAL)((PHNDL)(ph)+1) : 0)

//
// all wave and midi handles will be linked into
// a global list, so we can enumerate them latter if needed.
//
// all handle structures start with a HNDL structure, that contain common fields
//
// pHandleList points to the first handle in the list
//
// the NewHandle() and FreeHandle() functions are used to add/remove
// a handle to/from the list
//
extern PHNDL pHandleList;

extern HLOCAL FAR PASCAL NewHandle(WORD wType, WORD size);
extern HLOCAL FAR PASCAL FreeHandle(HLOCAL h);

#define GetHandleType(h)        (HtoPH(h)->wType)
#define GetHandleOwner(h)       (HtoPH(h)->hTask)
#define GetHandleFirst()        (PHtoH(pHandleList))
#define GetHandleNext(h)        (PHtoH(HtoPH(h)->pNext))
#define SetHandleOwner(h,hOwn)  (HtoPH(h)->hTask = (hOwn))

/****************************************************************************

    debug support

****************************************************************************/

#if 1   // was #ifdef DEBUG_RETAIL

#define MM_GET_DEBUG        DRV_USER
#define MM_GET_DEBUGOUT     DRV_USER+1
#define MM_SET_DEBUGOUT     DRV_USER+2
#define MM_GET_MCI_DEBUG    DRV_USER+3
#define MM_SET_MCI_DEBUG    DRV_USER+4
#define MM_GET_MM_DEBUG     DRV_USER+5
#define MM_SET_MM_DEBUG     DRV_USER+6

#define MM_HINFO_NEXT       DRV_USER+10
#define MM_HINFO_TASK       DRV_USER+11
#define MM_HINFO_TYPE       DRV_USER+12
#define MM_HINFO_MCI        DRV_USER+20

#define MM_DRV_RESTART      DRV_USER+30

//
// these validation routines can be found in DEBUG.ASM
//
extern BOOL   FAR PASCAL ValidateHandle(HANDLE h, WORD wType);
extern BOOL   FAR PASCAL ValidateHeader(const void FAR* p, UINT wSize, WORD wType);
extern BOOL   FAR PASCAL ValidateReadPointer(const void FAR* p, DWORD len);
extern BOOL   FAR PASCAL ValidateWritePointer(const void FAR* p, DWORD len);
extern BOOL   FAR PASCAL ValidateDriverCallback(DWORD dwCallback, UINT wFlags);
extern BOOL   FAR PASCAL ValidateCallback(FARPROC lpfnCallback);
extern BOOL   FAR PASCAL ValidateString(LPCSTR lsz, UINT max_len);

#ifndef MMNOTIMER
extern BOOL   FAR PASCAL ValidateTimerCallback(LPTIMECALLBACK lpfn);
#endif

#define	V_HANDLE(h, t, r)	{ if (!ValidateHandle(h, t)) return (r); }
#define	V_HEADER(p, w, t, r)	{ if (!ValidateHeader((p), (w), (t))) return (r); }
#define	V_RPOINTER(p, l, r)	{ if (!ValidateReadPointer((p), (l))) return (r); }
#define	V_RPOINTER0(p, l, r)	{ if ((p) && !ValidateReadPointer((p), (l))) return (r); }
#define	V_WPOINTER(p, l, r)	{ if (!ValidateWritePointer((p), (l))) return (r); }
#define	V_WPOINTER0(p, l, r)	{ if ((p) && !ValidateWritePointer((p), (l))) return (r); }
#define	V_DCALLBACK(d, w, r)	{ if (!ValidateDriverCallback((d), (w))) return (r); }
#define	V_TCALLBACK(d, r)	{ if (!ValidateTimerCallback((d))) return (r); }
#define	V_CALLBACK(f, r)	{ if (!ValidateCallback(f)) return (r); }
#define	V_CALLBACK0(f, r)	{ if ((f) && !ValidateCallback(f)) return (r); }
#define V_STRING(s, l, r)       { if (!ValidateString(s,l)) return (r); }
#define V_FLAGS(t, b, f, r)     { if ((t) & ~(b)) {LogParamError(ERR_BAD_FLAGS, (FARPROC)(f), (LPVOID)(DWORD)(t)); return (r); }}

#else //ifdef DEBUG_RETAIL

#define	V_HANDLE(h, t, r)	{ if (!(h)) return (r); }
#define	V_HEADER(p, w, t, r)	{ if (!(p)) return (r); }
#define	V_RPOINTER(p, l, r)	{ if (!(p)) return (r); }
#define	V_RPOINTER0(p, l, r)	0
#define	V_WPOINTER(p, l, r)	{ if (!(p)) return (r); }
#define	V_WPOINTER0(p, l, r)	0
#define	V_DCALLBACK(d, w, r)	0
#define	V_TCALLBACK(d, r)	0
#define	V_CALLBACK(f, r)	{ if (!(f)) return (r); }
#define	V_CALLBACK0(f, r)	0
#define V_STRING(s, l, r)       { if (!(s)) return (r); }
#define	V_FLAGS(t, b, f, r)	0

#endif //ifdef DEBUG_RETAIL

//**************************************************************************;
//   IF YOU CHANGE THESE TYPES YOU MUST ALSO CHANGE THE ONES IN DEBUG.ASM
//**************************************************************************;
#define TYPE_WAVEOUT            1
#define TYPE_WAVEIN             2
#define TYPE_MIDIOUT            3
#define TYPE_MIDIIN             4
#define TYPE_MMIO               5
#define TYPE_IOPROC             6
#define TYPE_MCI                7
#define TYPE_DRVR               8
#define TYPE_MIXER              9
//**************************************************************************;

/****************************************************************************

    support for debug output

****************************************************************************/

#ifdef DEBUG_RETAIL

    #define ROUT(sz)                    {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach); }
    #define ROUTS(sz)                   {DebugOutput(DBF_TRACE | DBF_MMSYSTEM, sz);}
    #define DebugErr(flags, sz)         {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach); }
    #define DebugErr1(flags, sz, a)     {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach,a); }
    #define DebugErr2(flags, sz, a, b)  {static SZCODE ach[] = "MMSYSTEM: "sz; DebugOutput((flags)   | DBF_MMSYSTEM, ach,a,b); }

    #define RPRINTF1(sz,x)              {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach, x); }
    #define RPRINTF2(sz,x,y)            {static SZCODE ach[] = sz; DebugOutput(DBF_TRACE | DBF_MMSYSTEM, ach, x, y); }

#else //ifdef DEBUG_RETAIL

    #define ROUT(sz)
    #define ROUTS(sz)
    #define DebugErr(flags, sz)
    #define DebugErr1(flags, sz, a)
    #define DebugErr2(flags, sz, a, b)

    #define RPRINTF1(sz,x)
    #define RPRINTF2(sz,x,y)

#endif //ifdef DEBUG_RETAIL

#ifdef DEBUG

    extern void FAR cdecl  dprintf(LPSTR, ...);           // in COMM.ASM
    extern void FAR PASCAL dout(LPSTR);                   // in COMM.ASM

    #define DOUT(sz)            {static SZCODE buf[] = sz; dout(buf); }
    #define DOUTS(sz)           dout(sz);
    #define DPRINTF(x)          dprintf x
    #define DPRINTF1(sz,a)      {static SZCODE buf[] = sz; dprintf(buf, a); }
    #define DPRINTF2(sz,a,b)    {static SZCODE buf[] = sz; dprintf(buf, a, b); }

#else //ifdef DEBUG

    #define DOUT(sz)	0
    #define DOUTS(sz)	0
    #define DPRINTF(x)  0
    #define DPRINTF1(sz,a)   0
    #define DPRINTF2(sz,a,b) 0

#endif //ifdef DEBUG

#ifndef MMNOMCI
/****************************************************************************

    Internal MCI stuff

****************************************************************************/

#define MCI_VALID_DEVICE_ID(wID) ((wID) > 0 && (wID) < MCI_wNextDeviceID && MCI_lpDeviceList[wID])

#define MCI_MAX_PARAM_SLOTS 30

#define MCI_TOLOWER(c)  ((char)((c) >= 'A' && (c) <= 'Z' ? (c) + 0x20 : (c)))

typedef struct
{
    HGLOBAL             hResource;
    HINSTANCE           hModule;        // If not NULL then free module
                                        // when device is free'd
    UINT                wType;
    UINT FAR *          lpwIndex;
    LPSTR               lpResource;
#ifdef DEBUG
    WORD                wLockCount;     // Used for debugging
#endif //ifdef DEBUG
} command_table_type;

#define MCINODE_ISCLOSING       0x00000001   // Lock out all cmd's during close
#define MCINODE_ISAUTOCLOSING   0x00010000   // Lock out all cmd's during close
                                             // except internally generated close
#define MCINODE_ISAUTOOPENED    0x00020000   // Device was auto opened
#define MCINODE_16BIT_DRIVER    0x80000000   // Device is a 16-bit driver

typedef struct {
    LPSTR   lpstrName;      // The name used in subsequent calls to
                            // mciSendString to refer to the device
    LPSTR   lpstrInstallName;// The device name from system.ini
    DWORD   dwMCIOpenFlags; // Flags set on open may be:
    DWORD   lpDriverData;   // DWORD of driver instance data
    DWORD   dwElementID;    // The element ID set by MCI_OPEN_ELEMENT_ID
    YIELDPROC fpYieldProc;  // The current yield procedure if any
    DWORD   dwYieldData;    // Data send to the current yield procedure
    UINT    wDeviceID;      // The ID used in subsequent calls to
                            // mciSendCommand to refer to the device
    UINT    wDeviceType;    // The type returned from the DRV_OPEN call
                            // MCI_OPEN_SHAREABLE
                            // MCI_OPEN_ELEMENT_ID
    UINT    wCommandTable;  // The device type specific command table
    UINT    wCustomCommandTable;    // The custom device command table if any
                                    //(-1 if none)
    HINSTANCE  hDriver;     // Module instance handle for the driver
    HTASK   hCreatorTask;   // The task context the device is in
    HTASK   hOpeningTask;   // The task context which send the open command
    HDRVR   hDrvDriver;     // The installable driver handle
    DWORD   dwMCIFlags;     // Internal MCI flags
} MCI_DEVICE_NODE;

typedef MCI_DEVICE_NODE FAR      *LPMCI_DEVICE_NODE;
typedef MCI_DEVICE_NODE BMCIHEAP *PMCI_DEVICE_NODE;

typedef struct {
    LPSTR               lpstrParams;
    LPSTR FAR *         lpstrPointerList;
    HTASK               hCallingTask;
    UINT                wParsingError;
} MCI_INTERNAL_OPEN_INFO;
typedef MCI_INTERNAL_OPEN_INFO FAR *LPMCI_INTERNAL_OPEN_INFO;

typedef struct {
    LPSTR   lpstrCommand;
    LPSTR   lpstrReturnString;
    UINT    wReturnLength;
    HTASK   hCallingTask;
    LPSTR   lpstrNewDirectory;      // The current directory of the calling
                                    // task
    int     nNewDrive;              // The current drive of the calling task
} MCI_SYSTEM_MESSAGE;
typedef MCI_SYSTEM_MESSAGE FAR *LPMCI_SYSTEM_MESSAGE;

#define MCI_INIT_DEVICE_LIST_SIZE   4
#define MCI_DEVICE_LIST_GROW_SIZE   4

#define MAX_COMMAND_TABLES 20

extern BOOL MCI_bDeviceListInitialized;

extern LPMCI_DEVICE_NODE FAR *MCI_lpDeviceList;
extern UINT MCI_wDeviceListSize;

extern UINT MCI_wNextDeviceID;   // the next device ID to use for a new device

extern command_table_type command_tables[MAX_COMMAND_TABLES];

// In mciparse.c
extern void PASCAL NEAR mciToLower (LPSTR lpstrString);

extern UINT NEAR PASCAL mciLoadTableType(UINT wType);

extern LPSTR PASCAL NEAR FindCommandInTable (UINT wTable, LPCSTR lpstrCommand,
                                      UINT FAR * lpwMessage);

extern LPSTR PASCAL NEAR FindCommandItem (UINT wDeviceID, LPCSTR lpstrType,
                                   LPCSTR lpstrCommand, UINT FAR * lpwMessage,
                                   UINT FAR* lpwTable);

extern UINT PASCAL NEAR mciEatToken (LPCSTR FAR *lplpstrInput, char cSeparater,
                              LPSTR FAR *lplpstrOutput, BOOL bMustFind);

extern UINT PASCAL NEAR mciParseParams (LPCSTR lpstrParams,
                                 LPCSTR lpCommandList,
                                 LPDWORD lpdwFlags,
                                 LPSTR lpOutputParams,
                                 UINT wParamsSize,
                                 LPSTR FAR * FAR * lpPointerList,
                                 UINT FAR* lpwParsingError);

extern void NEAR PASCAL mciParserFree (LPSTR FAR *lpstrPointerList);

extern UINT NEAR PASCAL mciEatCommandEntry(LPCSTR lpEntry, LPDWORD lpValue,
                                    UINT FAR* lpID);

extern UINT NEAR PASCAL mciParseCommand (UINT wDeviceID,
                                         LPSTR lpstrCommand,
                                         LPCSTR lpstrDeviceName,
                                         LPSTR FAR * lpCommandList,
                                         UINT FAR* lpwTable);

extern UINT PASCAL NEAR mciGetParamSize (DWORD dwValue, UINT wID);

extern BOOL PASCAL NEAR mciUnlockCommandTable (UINT wCommandTable);

// In mcisys.c
extern BOOL NEAR PASCAL mciInitDeviceList(void);

extern UINT NEAR PASCAL mciOpenDevice(DWORD dwFlags,
                                     LPMCI_OPEN_PARMS lpOpenParms,
                                     LPMCI_INTERNAL_OPEN_INFO lpOpenInfo);

extern UINT NEAR PASCAL mciCloseDevice(UINT wID, DWORD dwFlags,
                                      LPMCI_GENERIC_PARMS lpGeneric,
                                      BOOL bCloseDriver);

extern UINT NEAR PASCAL mciExtractTypeFromID (LPMCI_OPEN_PARMS lpOpen);

extern DWORD PASCAL NEAR mciSysinfo (UINT wDeviceID, DWORD dwFlags,
                              LPMCI_SYSINFO_PARMS lpSysinfo);

extern UINT PASCAL NEAR mciLookUpType (LPCSTR lpstrTypeName);

extern BOOL PASCAL NEAR mciExtractDeviceType (LPCSTR lpstrDeviceName,
                                       LPSTR lpstrDeviceType,
                                       UINT wBufLen);

extern UINT NEAR PASCAL mciSetBreakKey (UINT wDeviceID, int nVirtKey, HWND hwndTrap);

extern UINT NEAR PASCAL mciGetDeviceIDInternal (LPCSTR lpstrName, HTASK hTask);

extern BOOL NEAR PASCAL Is16bitDrv(UINT wDeviceID);
extern BOOL NEAR PASCAL CouldBe16bitDrv(UINT wDeviceID);

// In mci.c
extern DWORD FAR PASCAL mciRelaySystemString (LPMCI_SYSTEM_MESSAGE lpMessage);

#endif //ifndef MMNOMCI
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmreg.h ===
/****************************************************************************
 *
 *   mmreg.h  - Registered Multimedia Information Public Header File
 *
 *   Copyright (c) 1991,1992,1993 Microsoft Corporation.  All Rights Reserved.
 *
 * Multimedia Registration
 *
 * Place this system include file in your INCLUDE path with the Windows SDK
 * include files.
 *
 * Obtain the Multimedia Developer Registration Kit from:
 *
 *  Microsoft Corporation
 *  Multimedia Systems Group
 *  Product Marketing
 *  One Microsoft Way
 *  Redmond, WA 98052-6399
 *
 * 800-227-4679 x11771
 *
 * Last Update:  01/21/93
 *
 ***************************************************************************/

// Define the following to skip definitions
//
// NOMMIDS    Multimedia IDs are not defined
// NONEWWAVE    No new waveform types are defined except WAVEFORMATEX
// NONEWRIFF    No new RIFF forms are defined
// NONEWIC    No new Image Compressor types are defined

#ifndef _INC_MMREG
/* use version number to verify compatibility */
#define _INC_MMREG     130    // version * 100 + revision

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif    /* __cplusplus */

#ifndef NOMMIDS

/* manufacturer IDs */
#ifndef MM_MICROSOFT
#define MM_MICROSOFT            1   /* Microsoft Corporation */
#endif
#define MM_CREATIVE             2   /* Creative Labs Inc. */
#define MM_MEDIAVISION          3   /* Media Vision Inc. */
#define MM_FUJITSU              4
#define MM_ARTISOFT            20   /* Artisoft Inc. */
#define MM_TURTLE_BEACH        21
#define MM_IBM                 22   /* International Bussiness Machines Corp. */
#define MM_VOCALTEC            23   /* Vocaltec LTD. */
#define MM_ROLAND              24
#define MM_DIGISPEECH          25   /* Digispeech, Inc. */
#define MM_NEC                 26   /* NEC */
#define MM_ATI                 27   /* ATI */
#define MM_WANGLABS            28   /* Wang Laboratories, Inc. */
#define MM_TANDY               29   /* Tandy Corporation */
#define MM_VOYETRA             30   /* Voyetra */
#define MM_ANTEX               31   /* Antex */
#define MM_ICL_PS              32
#define MM_INTEL               33
#define MM_GRAVIS              34
#define MM_VAL                 35   /* Video Associates Labs */
#define MM_INTERACTIVE         36   /* InterActive, Inc. */
#define MM_YAMAHA              37   /* Yamaha Corp. of America */
#define MM_EVEREX              38   /* Everex Systems, Inc. */
#define MM_ECHO                39   /* Echo Speech Corporation */
#define MM_SIERRA              40   /* Sierra Semiconductor */
#define MM_CAT                 41   /* Computer Aided Technologies */
#define MM_APPS                42   /* APPS Software International */
#define MM_DSP_GROUP           43   /* DSP Group, Inc. */
#define MM_MELABS              44   /* microEngineering Labs */
#define MM_COMPUTER_FRIENDS    45   /* Computer Friends, Inc */

/* MM_MICROSOFT product IDs */
#ifndef MM_MIDI_MAPPER

#define MM_MIDI_MAPPER          1   /* MIDI Mapper */
#define MM_WAVE_MAPPER          2   /* Wave Mapper */
#define MM_SNDBLST_MIDIOUT      3   /* Sound Blaster MIDI output port */
#define MM_SNDBLST_MIDIIN       4   /* Sound Blaster MIDI input port */
#define MM_SNDBLST_SYNTH        5   /* Sound Blaster internal synthesizer */
#define MM_SNDBLST_WAVEOUT      6   /* Sound Blaster waveform output */
#define MM_SNDBLST_WAVEIN       7   /* Sound Blaster waveform input */
#define MM_ADLIB                9   /* Ad Lib-compatible synthesizer */
#define MM_MPU401_MIDIOUT      10   /* MPU401-compatible MIDI output port */
#define MM_MPU401_MIDIIN       11   /* MPU401-compatible MIDI input port */
#define MM_PC_JOYSTICK         12   /* Joystick adapter */
#endif

#define MM_PCSPEAKER_WAVEOUT           13  /* PC Speaker waveform output */

#define MM_MSFT_WSS_WAVEIN             14  /* MS Audio Board waveform input */
#define MM_MSFT_WSS_WAVEOUT            15  /* MS Audio Board waveform output */
#define MM_MSFT_WSS_FMSYNTH_STEREO     16  /* MS Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_OEM_WAVEIN         18  /* MS OEM Audio Board waveform input */
#define MM_MSFT_WSS_OEM_WAVEOUT        19  /* MS OEM Audio Board waveform Output */
#define MM_MSFT_WSS_OEM_FMSYNTH_STEREO 20  /* MS OEM Audio Board Stereo FM synthesizer */
#define MM_MSFT_WSS_AUX                21  /* MS Audio Board Auxiliary Port */
#define MM_MSFT_WSS_OEM_AUX            22  /* MS OEM Audio Auxiliary Port */

#define MM_MSFT_GENERIC_WAVEIN         23  /* MS vanilla driver waveform input */
#define MM_MSFT_GENERIC_WAVEOUT        24  /* MS vanilla driver waveform output */
#define MM_MSFT_GENERIC_MIDIIN         25  /* MS vanilla driver MIDI input */
#define MM_MSFT_GENERIC_MIDIOUT        26  /* MS vanilla driver external MIDI output */
#define MM_MSFT_GENERIC_MIDISYNTH      27  /* MS vanilla driver MIDI synthesizer */
#define MM_MSFT_GENERIC_AUX_LINE       28  /* MS vanilla driver aux (line in) */
#define MM_MSFT_GENERIC_AUX_MIC        29  /* MS vanilla driver aux (mic) */
#define MM_MSFT_GENERIC_AUX_CD         30  /* MS vanilla driver aux (CD) */


/* MM_CREATIVE product IDs */
#define MM_CREATIVE_SB15_WAVEIN         1   /* SB (r) 1.5 waveform input */
#define MM_CREATIVE_SB20_WAVEIN         2   /* SB (r) 2.0 waveform input */
#define MM_CREATIVE_SBPRO_WAVEIN        3   /* SB Pro (r) waveform input */
#define MM_CREATIVE_SBP16_WAVEIN        4   /* SBP16 (r) waveform input */
#define MM_CREATIVE_SB15_WAVEOUT      101   /* SB (r) 1.5 waveform output */
#define MM_CREATIVE_SB20_WAVEOUT      102   /* SB (r) 2.0 waveform output */
#define MM_CREATIVE_SBPRO_WAVEOUT     103   /* SB Pro (r) waveform output */
#define MM_CREATIVE_SBP16_WAVEOUT     104   /* SBP16 (r) waveform output */
#define MM_CREATIVE_MIDIOUT           201   /* SB (r) MIDI output port */
#define MM_CREATIVE_MIDIIN            202   /* SB (r) MIDI input port */
#define MM_CREATIVE_FMSYNTH_MONO      301   /* SB (r) FM synthesizer */
#define MM_CREATIVE_FMSYNTH_STEREO    302   /* SB Pro (r) stereo FM synthesizer */
#define MM_CREATIVE_AUX_CD            401   /* SB Pro (r) aux (CD) */
#define MM_CREATIVE_AUX_LINE          402   /* SB Pro (r) aux (line in) */
#define MM_CREATIVE_AUX_MIC           403   /* SB Pro (r) aux (mic) */


/* MM_ARTISOFT product IDs */
#define MM_ARTISOFT_SBWAVEIN     1   /* Artisoft Sounding Board waveform input */
#define MM_ARTISOFT_SBWAVEOUT    2   /* Artisoft Sounding Board waveform output */

/* MM_IBM Product IDs */
#define MM_MMOTION_WAVEAUX       1    /* IBM M-Motion Auxiliary Device */
#define MM_MMOTION_WAVEOUT       2    /* IBM M-Motion Waveform Output */
#define MM_MMOTION_WAVEIN        3    /* IBM M-Motion Waveform Input */

/* MM_MEDIAVISION Product IDs */
#define MM_MEDIAVISION_PROAUDIO       0x10
#define MM_PROAUD_MIDIOUT             MM_MEDIAVISION_PROAUDIO+1
#define MM_PROAUD_MIDIIN              MM_MEDIAVISION_PROAUDIO+2
#define MM_PROAUD_SYNTH               MM_MEDIAVISION_PROAUDIO+3
#define MM_PROAUD_WAVEOUT             MM_MEDIAVISION_PROAUDIO+4
#define MM_PROAUD_WAVEIN              MM_MEDIAVISION_PROAUDIO+5
#define MM_PROAUD_MIXER               MM_MEDIAVISION_PROAUDIO+6
#define MM_PROAUD_AUX                 MM_MEDIAVISION_PROAUDIO+7

#define MM_MEDIAVISION_THUNDER        0x20
#define MM_THUNDER_WAVEOUT            MM_MEDIAVISION_THUNDER+1
#define MM_THUNDER_WAVEIN             MM_MEDIAVISION_THUNDER+2
#define MM_THUNDER_SYNTH              MM_MEDIAVISION_THUNDER+3

#define MM_MEDIAVISION_TPORT          0x40
#define MM_TPORT_WAVEOUT              MM_MEDIAVISION_TPORT+1
#define MM_TPORT_WAVEIN               MM_MEDIAVISION_TPORT+2
#define MM_TPORT_SYNTH                MM_MEDIAVISION_TPORT+3

// THIS CARD IS THE OEM VERSION OF THE NEXT PAS
#define MM_MEDIAVISION_PROAUDIO_PLUS  0x50
#define MM_PROAUD_PLUS_MIDIOUT        MM_MEDIAVISION_PROAUDIO_PLUS+1
#define MM_PROAUD_PLUS_MIDIIN         MM_MEDIAVISION_PROAUDIO_PLUS+2
#define MM_PROAUD_PLUS_SYNTH          MM_MEDIAVISION_PROAUDIO_PLUS+3
#define MM_PROAUD_PLUS_WAVEOUT        MM_MEDIAVISION_PROAUDIO_PLUS+4
#define MM_PROAUD_PLUS_WAVEIN         MM_MEDIAVISION_PROAUDIO_PLUS+5
#define MM_PROAUD_PLUS_MIXER          MM_MEDIAVISION_PROAUDIO_PLUS+6
#define MM_PROAUD_PLUS_AUX            MM_MEDIAVISION_PROAUDIO_PLUS+7


// THIS CARD IS THE NEW MEDIA VISION 16-bit card
#define MM_MEDIAVISION_PROAUDIO_16    0x60
#define MM_PROAUD_16_MIDIOUT          MM_MEDIAVISION_PROAUDIO_16+1
#define MM_PROAUD_16_MIDIIN           MM_MEDIAVISION_PROAUDIO_16+2
#define MM_PROAUD_16_SYNTH            MM_MEDIAVISION_PROAUDIO_16+3
#define MM_PROAUD_16_WAVEOUT          MM_MEDIAVISION_PROAUDIO_16+4
#define MM_PROAUD_16_WAVEIN           MM_MEDIAVISION_PROAUDIO_16+5
#define MM_PROAUD_16_MIXER            MM_MEDIAVISION_PROAUDIO_16+6
#define MM_PROAUD_16_AUX              MM_MEDIAVISION_PROAUDIO_16+7


// THIS CARD IS THE NEW MEDIA VISION CDPC card
#define MM_MEDIAVISION_CDPC           0x70
#define MM_CDPC_MIDIOUT               MM_MEDIAVISION_CDPC+1
#define MM_CDPC_MIDIIN                MM_MEDIAVISION_CDPC+2
#define MM_CDPC_SYNTH                 MM_MEDIAVISION_CDPC+3
#define MM_CDPC_WAVEOUT               MM_MEDIAVISION_CDPC+4
#define MM_CDPC_WAVEIN                MM_MEDIAVISION_CDPC+5
#define MM_CDPC_MIXER                 MM_MEDIAVISION_CDPC+6
#define MM_CDPC_AUX                   MM_MEDIAVISION_CDPC+7


//
// Opus MV1208 Chipset
//
#define MM_MEDIAVISION_OPUS1208       0x80
#define MM_OPUS401_MIDIOUT            MM_MEDIAVISION_OPUS1208+1
#define MM_OPUS401_MIDIIN             MM_MEDIAVISION_OPUS1208+2
#define MM_OPUS1208_SYNTH             MM_MEDIAVISION_OPUS1208+3
#define MM_OPUS1208_WAVEOUT           MM_MEDIAVISION_OPUS1208+4
#define MM_OPUS1208_WAVEIN            MM_MEDIAVISION_OPUS1208+5
#define MM_OPUS1208_MIXER             MM_MEDIAVISION_OPUS1208+6
#define MM_OPUS1208_AUX               MM_MEDIAVISION_OPUS1208+7


//
// Opus MV1216 Chipset
//
#define MM_MEDIAVISION_OPUS1216       0x90
#define MM_OPUS1216_MIDIOUT           MM_MEDIAVISION_OPUS1216+1
#define MM_OPUS1216_MIDIIN            MM_MEDIAVISION_OPUS1216+2
#define MM_OPUS1216_SYNTH             MM_MEDIAVISION_OPUS1216+3
#define MM_OPUS1216_WAVEOUT           MM_MEDIAVISION_OPUS1216+4
#define MM_OPUS1216_WAVEIN            MM_MEDIAVISION_OPUS1216+5
#define MM_OPUS1216_MIXER             MM_MEDIAVISION_OPUS1216+6
#define MM_OPUS1216_AUX               MM_MEDIAVISION_OPUS1216+7


//
// Mixer
//
#define MIXERR_BASE                   512

/* MM_VOCALTEC Product IDs */
#define MM_VOCALTEC_WAVEOUT       1    /* Vocaltec Waveform output port */
#define MM_VOCALTEC_WAVEIN        2    /* Vocaltec Waveform input port */

/* MM_ROLAND Product IDs */
#define MM_ROLAND_MPU401_MIDIOUT    15
#define MM_ROLAND_MPU401_MIDIIN     16
#define MM_ROLAND_SMPU_MIDIOUTA     17
#define MM_ROLAND_SMPU_MIDIOUTB     18
#define MM_ROLAND_SMPU_MIDIINA      19
#define MM_ROLAND_SMPU_MIDIINB      20
#define MM_ROLAND_SC7_MIDIOUT       21
#define MM_ROLAND_SC7_MIDIIN        22


/* MM_DIGISPEECH Product IDs */
#define MM_DIGISP_WAVEOUT    1    /* Digispeech Waveform output port */
#define MM_DIGISP_WAVEIN     2    /* Digispeech Waveform input port */

/* MM_NEC Product IDs */

/* MM_ATI Product IDs */

/* MM_WANGLABS Product IDs */

#define MM_WANGLABS_WAVEIN1    1
/* Input audio wave device present on the CPU board of the following Wang models: Exec 4010, 4030 and 3450; PC 251/25C, PC 461/25S and PC 461/33C */
#define MM_WANGLABS_WAVEOUT1   2
/* Output audio wave device present on the CPU board of the Wang models listed above. */

/* MM_TANDY Product IDs */

/* MM_VOYETRA Product IDs */

/* MM_ANTEX Product IDs */

/* MM_ICL_PS Product IDs */

/* MM_INTEL Product IDs */

#define MM_INTELOPD_WAVEIN       1    // HID2 WaveAudio Input driver
#define MM_INTELOPD_WAVEOUT    101    // HID2 WaveAudio Output driver
#define MM_INTELOPD_AUX        401    // HID2 Auxiliary driver (required for mixing functions)

/* MM_GRAVIS Product IDs */

/* MM_VAL Product IDs */

// values not defined by Manufacturer

// #define MM_VAL_MICROKEY_AP_WAVEIN    ???    // Microkey/AudioPort Waveform Input
// #define MM_VAL_MICROKEY_AP_WAVEOUT    ???    // Microkey/AudioPort Waveform Output

/* MM_INTERACTIVE Product IDs */

#define MM_INTERACTIVE_WAVEIN     0x45    // no comment provided by Manufacturer
#define MM_INTERACTIVE_WAVEOUT    0x45    // no comment provided by Manufacturer

/* MM_YAMAHA Product IDs */

#define MM_YAMAHA_GSS_SYNTH     0x01    // Yamaha Gold Sound Standard FM sythesis driver
#define MM_YAMAHA_GSS_WAVEOUT   0x02    // Yamaha Gold Sound Standard wave output driver
#define MM_YAMAHA_GSS_WAVEIN    0x03    // Yamaha Gold Sound Standard wave input driver
#define MM_YAMAHA_GSS_MIDIOUT   0x04    // Yamaha Gold Sound Standard midi output driver
#define MM_YAMAHA_GSS_MIDIIN    0x05    // Yamaha Gold Sound Standard midi input driver
#define MM_YAMAHA_GSS_AUX       0x06    // Yamaha Gold Sound Standard auxillary driver for mixer functions

/* MM_EVEREX Product IDs */

#define MM_EVEREX_CARRIER    0x01    // Everex Carrier SL/25 Notebook

/* MM_ECHO Product IDs */

#define MM_ECHO_SYNTH     0x01    // Echo EuSythesis driver
#define MM_ECHO_WAVEOUT   0x02    // Wave output driver
#define MM_ECHO_WAVEIN    0x03    // Wave input driver
#define MM_ECHO_MIDIOUT   0x04    // MIDI output driver
#define MM_ECHO_MIDIIN    0x05    // MIDI input driver
#define MM_ECHO_AUX       0x06    // auxillary driver for mixer functions


/* MM_SIERRA Product IDs */

#define MM_SIERRA_ARIA_MIDIOUT   0x14    // Sierra Aria MIDI output
#define MM_SIERRA_ARIA_MIDIIN    0x15    // Sierra Aria MIDI input
#define MM_SIERRA_ARIA_SYNTH     0x16    // Sierra Aria Synthesizer
#define MM_SIERRA_ARIA_WAVEOUT   0x17    // Sierra Aria Waveform output
#define MM_SIERRA_ARIA_WAVEIN    0x18    // Sierra Aria Waveform input
#define MM_SIERRA_ARIA_AUX       0x19    // Siarra Aria Auxiliary device

/* MM_CAT Product IDs */

/* MM_APPS Product IDs */

/* MM_DSP_GROUP Product IDs */

#define MM_DSP_GROUP_TRUESPEECH    0x01    // High quality 9.54:1 Speech Compression Vocoder

/* MM_MELABS Product IDs */

#define MM_MELABS_MIDI2GO    0x01    // parellel port MIDI interface

#endif

/*////////////////////////////////////////////////////////////////////////// */

#ifndef NONEWWAVE

/* WAVE form wFormatTag IDs */
#define WAVE_FORMAT_UNKNOWN                (0x0000)
#define WAVE_FORMAT_ADPCM                  (0x0002)
#define WAVE_FORMAT_IBM_CVSD               (0x0005)
#define WAVE_FORMAT_ALAW                   (0x0006)
#define WAVE_FORMAT_MULAW                  (0x0007)
#define WAVE_FORMAT_OKI_ADPCM              (0x0010)
#define WAVE_FORMAT_DVI_ADPCM              (0x0011)
#define WAVE_FORMAT_IMA_ADPCM              (WAVE_FORMAT_DVI_ADPCM)
#define WAVE_FORMAT_DIGISTD                (0x0015)
#define WAVE_FORMAT_DIGIFIX                (0x0016)
#define WAVE_FORMAT_YAMAHA_ADPCM           (0x0020)
#define WAVE_FORMAT_SONARC                 (0x0021)
#define WAVE_FORMAT_DSPGROUP_TRUESPEECH    (0x0022)
#define WAVE_FORMAT_ECHOSC1                (0x0023)
#define WAVE_FORMAT_CREATIVE_ADPCM         (0x0200)

#endif /* NONEWWAVE */


#ifndef WAVE_FORMAT_PCM

/* general waveform format structure (information common to all formats) */
typedef struct waveformat_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
} WAVEFORMAT;
typedef WAVEFORMAT      *PWAVEFORMAT;
typedef WAVEFORMAT NEAR *NPWAVEFORMAT;
typedef WAVEFORMAT FAR  *LPWAVEFORMAT;

/* flags for wFormatTag field of WAVEFORMAT */
#define WAVE_FORMAT_PCM     1

/* specific waveform format structure for PCM data */
typedef struct pcmwaveformat_tag {
    WAVEFORMAT  wf;
    WORD        wBitsPerSample;
} PCMWAVEFORMAT;
typedef PCMWAVEFORMAT       *PPCMWAVEFORMAT;
typedef PCMWAVEFORMAT NEAR *NPPCMWAVEFORMAT;
typedef PCMWAVEFORMAT FAR  *LPPCMWAVEFORMAT;


#endif /* WAVE_FORMAT_PCM */



/* general extended waveform format structure
   Use this for all NON PCM formats
   (information common to all formats)
*/

typedef struct waveformat_extended_tag {
    WORD    wFormatTag;        /* format type */
    WORD    nChannels;         /* number of channels (i.e. mono, stereo...) */
    DWORD   nSamplesPerSec;    /* sample rate */
    DWORD   nAvgBytesPerSec;   /* for buffer estimation */
    WORD    nBlockAlign;       /* block size of data */
    WORD    wBitsPerSample;    /* Number of bits per sample of mono data */
    WORD    cbSize;            /* The count in bytes of the size of
                                  extra information (after cbSize) */

} WAVEFORMATEX;
typedef WAVEFORMATEX      *PWAVEFORMATEX;
typedef WAVEFORMATEX NEAR *NPWAVEFORMATEX;
typedef WAVEFORMATEX FAR  *LPWAVEFORMATEX;


#ifndef NONEWWAVE

/* Define data for MS ADPCM */

typedef struct adpcmcoef_tag {
    short    iCoef1;
    short    iCoef2;
} ADPCMCOEFSET;
typedef ADPCMCOEFSET      *PADPCMCOEFSET;
typedef ADPCMCOEFSET NEAR *NPADPCMCOEFSET;
typedef ADPCMCOEFSET FAR  *LPADPCMCOEFSET;

typedef struct adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
    WORD            wNumCoef;
    ADPCMCOEFSET    aCoef[];
} ADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT      *PADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT NEAR *NPADPCMWAVEFORMAT;
typedef ADPCMWAVEFORMAT FAR  *LPADPCMWAVEFORMAT;


//
//  Intel's DVI ADPCM structure definitions
//
//      for WAVE_FORMAT_DVI_ADPCM   (0x0011)
//
//

typedef struct dvi_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
} DVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT      *PDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT NEAR *NPDVIADPCMWAVEFORMAT;
typedef DVIADPCMWAVEFORMAT FAR  *LPDVIADPCMWAVEFORMAT;


//
//  IMA endorsed ADPCM structure definitions--note that this is exactly
//  the same format as Intel's DVI ADPCM.
//
//      for WAVE_FORMAT_IMA_ADPCM   (0x0011)
//
//

typedef struct ima_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wSamplesPerBlock;
} IMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT      *PIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT NEAR *NPIMAADPCMWAVEFORMAT;
typedef IMAADPCMWAVEFORMAT FAR  *LPIMAADPCMWAVEFORMAT;


//
//  Speech Compression's Sonarc structure definitions
//
//      for WAVE_FORMAT_SONARC   (0x0021)
//
//

typedef struct sonarcwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wCompType;
} SONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT      *PSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT NEAR *NPSONARCWAVEFORMAT;
typedef SONARCWAVEFORMAT FAR  *LPSONARCWAVEFORMAT;

//
//  DSP Groups's TRUESPEECH structure definitions
//
//      for WAVE_FORMAT_DSPGROUP_TRUESPEECH   (0x0022)
//
//

typedef struct truespeechwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            nSamplesPerBlock;
} TRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT      *PTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT NEAR *NPTRUESPEECHWAVEFORMAT;
typedef TRUESPEECHWAVEFORMAT FAR  *LPTRUESPEECHWAVEFORMAT;



//
//  Creative's ADPCM structure definitions
//
//      for WAVE_FORMAT_CREATIVE_ADPCM   (0x0200)
//
//

typedef struct creative_adpcmwaveformat_tag {
    WAVEFORMATEX    wfx;
    WORD            wRevision;
} CREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT      *PCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT NEAR *NPCREATIVEADPCMWAVEFORMAT;
typedef CREATIVEADPCMWAVEFORMAT FAR  *LPCREATIVEADPCMWAVEFORMAT;

/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF WAVE Chunks
//
*/

#define RIFFWAVE_inst    mmioFOURCC('i','n','s','t')

struct tag_s_RIFFWAVE_inst {
    BYTE    bUnshiftedNote;
    char    chFineTune;
    char    chGain;
    BYTE    bLowNote;
    BYTE    bHighNote;
    BYTE    bLowVelocity;
    BYTE    bHighVelocity;
};

typedef struct tag_s_RIFFWAVE_INST s_RIFFWAVE_inst;

#endif

/*//////////////////////////////////////////////////////////////////////////
//
// New RIFF Forms
//
*/

#ifndef NONEWRIFF

/* RIFF AVI */

//
// AVI file format is specified in a seperate file (AVIFMT.H),
// which is available from the sources listed in MSFTMM
//

/* RIFF CPPO */

#define RIFFCPPO         mmioFOURCC('C','P','P','O')

#define RIFFCPPO_objr    mmioFOURCC('o','b','j','r')
#define RIFFCPPO_obji    mmioFOURCC('o','b','j','i')

#define RIFFCPPO_clsr    mmioFOURCC('c','l','s','r')
#define RIFFCPPO_clsi    mmioFOURCC('c','l','s','i')

#define RIFFCPPO_mbr     mmioFOURCC('m','b','r',' ')

#define RIFFCPPO_char    mmioFOURCC('c','h','a','r')


#define RIFFCPPO_byte    mmioFOURCC('b','y','t','e')
#define RIFFCPPO_int     mmioFOURCC('i','n','t',' ')
#define RIFFCPPO_word    mmioFOURCC('w','o','r','d')
#define RIFFCPPO_long    mmioFOURCC('l','o','n','g')
#define RIFFCPPO_dwrd    mmioFOURCC('d','w','r','d')
#define RIFFCPPO_flt     mmioFOURCC('f','l','t',' ')
#define RIFFCPPO_dbl     mmioFOURCC('d','b','l',' ')
#define RIFFCPPO_str     mmioFOURCC('s','t','r',' ')


#endif

/*//////////////////////////////////////////////////////////////////////////
//
// DIB Compression Defines
//
*/

#ifndef BI_BITFIELDS
#define BI_BITFIELDS    3
#endif

#ifndef QUERYDIBSUPPORT

#define QUERYDIBSUPPORT   3073
#define QDI_SETDIBITS     0x0001
#define QDI_GETDIBITS     0x0002
#define QDI_DIBTOSCREEN   0x0004
#define QDI_STRETCHDIB    0x0008

#endif


/*//////////////////////////////////////////////////////////////////////////
//
// Defined IC types
*/

#ifndef NONEWIC

#ifndef ICTYPE_VIDEO
#define ICTYPE_VIDEO    mmioFOURCC('v', 'i', 'd', 'c')
#define ICTYPE_AUDIO    mmioFOURCC('a', 'u', 'd', 'c')
#endif

#endif

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif    /* __cplusplus */

#endif    /* _INC_MMREG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmsex.c ===
/*
**  MMSEX.C
**
**  Example applet DLL to be displayed by the Multimedia Control Panel.
**
**  History:
**
**  Wed Apr 18 1990 -by- MichaelE
**
*/

#ifndef DEBUG
    #define DEBUG
#endif

#include <windows.h>
#include "mmsystem.h"
#include <cpl.h>
#include "mmsysi.h"
#include "mmsex.dlg"

LRESULT FAR PASCAL _loadds _export CPlApplet   ( HWND, UINT, LPARAM, LPARAM );
BOOL FAR PASCAL _loadds            DebugDlg    ( HWND, UINT, WPARAM, LPARAM );

static SZCODE szMenuName[] = "mmse&x";
static SZCODE szInfoName[] = "change mmsystem debug settings 1.01";
static SZCODE szHelpFile[] = "";

#define MAX_TYPE 7
static SZCODE szTypes[] =
    "???????\0"         // 0
    "WaveOut\0"         // 1 TYPE_WAVEOUT
    "WaveIn \0"         // 2 TYPE_WAVEIN
    "MidiOut\0"         // 3 TYPE_MIDIOUT
    "MidiIn \0"         // 4 TYPE_MIDIIN
    "mmio   \0"         // 5 TYPE_MMIO
    "IOProc \0";        // 6 TYPE_IOPROC

int nLoadedCount = 0;
HDRVR hdrv;
int iNumHandles = 0;

/* This function is exported so CPL.EXE can do a GetProcAddress() on
** the label and send the messages described below.
** To make MMCPL.EXE load your DLL, and thus add your applets to its
** window, add a keyname under the [MMCPL] application in
** WIN.INI:
**
** [MMCPL]
** myapplets=c:\mydir\applet.dll
**
** CPL.EXE loads the WIN3 Control Panel applets first, followed by the
** applets named in WIN.INI, then those from the directory it was loaded,
** and finally those in the WIN3 SYSTEM directory.
**
*/
LRESULT FAR PASCAL _loadds _export CPlApplet(
HWND            hCPlWnd,
UINT            Msg,
LPARAM          lParam1,
LPARAM          lParam2)
{
    LPNEWCPLINFO   lpCPlInfo;
    int i;

    switch( Msg )
    {
        case CPL_INIT:
            if (!hdrv)
                hdrv = OpenDriver("mmsystem.dll", NULL, 0);

            if (!hdrv)
                return (LRESULT)FALSE;

// #if 0
            if (!SendDriverMessage(hdrv, MM_GET_DEBUG, 0, 0))
            {
                CloseDriver(hdrv,0,0);
                hdrv = NULL;
                return (LRESULT)FALSE;
            }
// #endif
            nLoadedCount++;

            // first message to CPlApplet(), sent once only
            return (LRESULT)TRUE;

        case CPL_GETCOUNT:
            // second message to CPlApplet(), sent once only
            return (LRESULT)1;

        case CPL_NEWINQUIRE:
            /* third message to CPlApplet().  It is sent as many times
               as the number of applets returned by CPL_GETCOUNT message
            */
            lpCPlInfo = (LPNEWCPLINFO)lParam2;

            // lParam1 is an index ranging from 0 to (NUM_APPLETS-1)
            i = (int)lParam1;

            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->dwFlags = 0;
            lpCPlInfo->dwHelpContext = 0;  // help context to use
            lpCPlInfo->lData = 0;          // user defined data
            lpCPlInfo->hIcon = LoadIcon(ghInst, MAKEINTATOM(DLG_MMSEX));
            lstrcpy(lpCPlInfo->szName, szMenuName);
            lstrcpy(lpCPlInfo->szInfo, szInfoName);
            lstrcpy(lpCPlInfo->szHelpFile, szHelpFile);

            return (LRESULT)TRUE;

        case CPL_SELECT:
            /* One of your applets has been selected.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            break;

        case CPL_DBLCLK:
            /* One of your applets has been double-clicked.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            DialogBox(ghInst,MAKEINTRESOURCE(DLG_MMSEX),hCPlWnd,DebugDlg);
            break;

        case CPL_STOP:
            /* Sent once for each applet prior to the CPL_EXIT msg.
               lParam1 is an index from 0 to (NUM_APPLETS-1)
               lParam2 is the lData value associated with the applet
            */
            break;

        case CPL_EXIT:
            /* Last message, sent once only, before MMCPL.EXE calls
               FreeLibrary() on your DLL.
            */
            nLoadedCount--;

            if (hdrv && !nLoadedCount)
            {
                CloseDriver(hdrv,0,0);
                hdrv = NULL;
            }
            break;

        default:
            break;
    }
    return( 0L );
}

int QueryRadioButton(HWND hdlg, int idFirst, int idLast)
{
    int id;

    for (id=idFirst; id<=idLast; id++)
    {
        if (IsDlgButtonChecked(hdlg, id))
            return id;
    }

    return 0;
}

#if 0   // API in win31

BOOL NEAR PASCAL IsTask(HANDLE hTask)
{
_asm {
;       push    si
        mov     ax,hTask
        or      ax,ax
        jz      error

        lsl     si,ax
        jnz     error

        call    GetCurrentTask
        lsl     ax,ax
        cmp     si,ax
        je      exit
error:
        xor     ax,ax
exit:
;       pop     si
}}

#endif


void NEAR PASCAL GetTaskName(HANDLE hTask, LPSTR pname)
{
    if (!IsTask(hTask))
    {
        lstrcpy(pname,"????");
    }
    else
    {
        ((LPDWORD)pname)[0] = ((LPDWORD)MAKELONG(0xF2,hTask))[0];
        ((LPDWORD)pname)[1] = ((LPDWORD)MAKELONG(0xF2,hTask))[1];
        pname[8] = 0;
    }
}

#define SLASH(c)   ((c) == '/' || (c) == '\\')

LPSTR FileName(LPSTR szPath)
{
    LPSTR   sz;

    for (sz=szPath; *sz; sz++)
	;
    for (; sz>=szPath && !SLASH(*sz) && *sz!=':'; sz--)
	;
    return ++sz;
}

int fQuestion(LPSTR sz,...)
{
    char ach[128];

    wvsprintf (ach,sz,(LPSTR)(&sz+1));    /* Format the string */
    return MessageBox(NULL,ach,"mmsex",MB_YESNO|MB_ICONQUESTION|MB_TASKMODAL);
}

void GetHandles(HWND hdlg)
{
    HLOCAL  h;
    HTASK   hTask;
    DWORD   wType;
    UINT    n;
    int     i;
    UINT    j;
    int     iSel;
    char    ach[80];
    char    szTask[80];
    char    szName[80];
    HWND    hlb;

    iNumHandles=0;

    hlb = GetDlgItem(hdlg, ID_HANDLES);

    iSel = (int)SendMessage(hlb,LB_GETCURSEL,0,0L);
    SendMessage(hlb, WM_SETREDRAW, (WPARAM)FALSE, 0);
    SendMessage(hlb, LB_RESETCONTENT, 0, 0);

    //
    // fill listbox with all active handles in system
    //
    for (h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, NULL, 0);
         h;
         h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, (LPARAM)(LONG)(UINT)h, 0) )
    {
        iNumHandles++;

        wType  = (UINT)SendDriverMessage(hdrv, MM_HINFO_TYPE, (LPARAM)(LONG)(UINT)h, 0);
        hTask  = (HTASK)(LONG)SendDriverMessage(hdrv, MM_HINFO_TASK, (LPARAM)(LONG)(UINT)h, 0);

        if (wType >= MAX_TYPE)
            wType = 0;

        GetTaskName(hTask, szTask);

        wsprintf(ach, "%ls %04X %ls",(LPSTR)szTypes + wType*(sizeof(szTypes)-1)/MAX_TYPE,h,(LPSTR)szTask);

        i = (int)(LONG)SendMessage(hlb, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
        SendMessage(hlb, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(h, wType));
    }

    //
    // add to that all MCI handles
    //
    n = (UINT)(LONG)SendDriverMessage(hdrv, MM_HINFO_MCI, 0, 0);

    for (j = 1; j < n; j++)
    {
        MCI_DEVICE_NODE node;

        if (!SendDriverMessage(hdrv, MM_HINFO_MCI, (LPARAM)j, (LPARAM)(LPVOID)&node))
            continue;

        iNumHandles++;

        if (node.lpstrName == NULL)
            node.lpstrName = "";
        if (node.lpstrInstallName == NULL)
            node.lpstrInstallName = "";

        GetTaskName(node.hCreatorTask, szTask);
        wsprintf(ach, "mci %04X %ls %ls %ls",j,(LPSTR)szTask,node.lpstrInstallName,node.lpstrName);

        i = (int)(LONG)SendMessage(hlb, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
        SendMessage(hlb, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(j, TYPE_MCI));
    }

    //
    // add to that all DRV handles
    //
    for (h=GetNextDriver(NULL, 0); h; h=GetNextDriver(h, 0))
    {
        if (GetDriverModuleHandle(h))
        {
            DRIVERINFOSTRUCT di;

            di.length = sizeof(di);
            di.szAliasName[0] = 0;
            GetDriverInfo(h, &di);

            iNumHandles++;

            GetModuleFileName(GetDriverModuleHandle(h), szName, sizeof(szName));

            wsprintf(ach, "Driver %04X %ls (%ls)",h,(LPSTR)di.szAliasName,(LPSTR)FileName(szName));
            i = (int)(LONG)SendDlgItemMessage(hdlg, ID_HANDLES, LB_ADDSTRING, 0, (LPARAM)(LPSTR)ach);
            SendDlgItemMessage(hdlg, ID_HANDLES, LB_SETITEMDATA, (WPARAM)i, MAKELPARAM(h,TYPE_DRVR));
        }
    }

    SendMessage(hlb,LB_SETCURSEL,(WPARAM)iSel,0L);
    SendMessage(hlb,WM_SETREDRAW,(WPARAM)TRUE,0);
    InvalidateRect(hlb, NULL, TRUE);
}

int CountHandles(void)
{
    HLOCAL  h;
    int     cnt=0;
    UINT    n;
    UINT    j;

    for (h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, NULL, 0);
         h;
         h = (HLOCAL)(LONG)SendDriverMessage(hdrv, MM_HINFO_NEXT, (LPARAM)(LONG)(UINT)h, 0) )
    {
        cnt++;
    }

    n = (UINT)(LONG)SendDriverMessage(hdrv, MM_HINFO_MCI, 0, 0);

    for (j=1; j<n; j++)
    {
        MCI_DEVICE_NODE node;

        if (!SendDriverMessage(hdrv, MM_HINFO_MCI, (LPARAM)j, (LPARAM)(LPVOID)&node))
            continue;

        cnt++;
    }

    for (h=GetNextDriver(NULL,0); h; h=GetNextDriver(h, 0))
    {
        if (GetDriverModuleHandle(h))
            cnt++;
    }

    return cnt;
}

void CloseHandle(DWORD dw)
{
    HLOCAL h;
    h = (HLOCAL)LOWORD(dw);

    switch(HIWORD(dw))
    {
        case TYPE_WAVEOUT:
            if (IDYES == fQuestion("Close WaveOut handle %04X?",h))
            {
                waveOutReset(h);
                waveOutClose(h);
            }
            break;
        case TYPE_WAVEIN:
            if (IDYES == fQuestion("Close WaveIn handle %04X?",h))
            {
                waveInStop(h);
                waveInClose(h);
            }
            break;
        case TYPE_MIDIOUT:
            if (IDYES == fQuestion("Close MidiOut handle %04X?",h))
            {
                midiOutReset(h);
                midiOutClose(h);
            }
            break;
        case TYPE_MIDIIN:
            if (IDYES == fQuestion("Close MidiIn handle %04X?",h))
            {
                midiInStop(h);
                midiInClose(h);
            }
            break;
        case TYPE_MCI:
            if (IDYES == fQuestion("Close Mci device %04X?",h))
            {
                mciSendCommand((UINT)h, MCI_CLOSE, 0, 0);
            }
            break;
        case TYPE_MMIO:
            if (IDYES == fQuestion("Close MMIO handle %04X?",h))
            {
                mmioClose(h,MMIO_FHOPEN);
            }
            break;
        case TYPE_DRVR:
            break;
    }
}


BOOL FAR PASCAL _loadds DebugDlg(HWND hdlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    DWORD dw;
    int i;

    switch (msg)
    {
        case WM_INITDIALOG:
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"(none)");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"COM1:");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"Mono Monitor");
            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_ADDSTRING, 0, (LONG)(LPSTR)"Windows");

            SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_SETCURSEL, (int)(LONG)SendDriverMessage(hdrv, MM_GET_DEBUGOUT, 0, 0), 0L);

            CheckDlgButton(hdlg, ID_DEBUG_MCI, (int)(LONG)SendDriverMessage(hdrv, MM_GET_MCI_DEBUG, 0, 0));
            CheckDlgButton(hdlg, ID_DEBUG_MMSYS, (int)(LONG)SendDriverMessage(hdrv, MM_GET_MM_DEBUG, 0, 0));

            iNumHandles = CountHandles();
            GetHandles(hdlg);

            SetTimer(hdlg, 500, 500, NULL);
            return TRUE;

        case WM_TIMER:
            i = CountHandles();
            if (iNumHandles != i)
            {
                iNumHandles = i;
                GetHandles(hdlg);
            }
            break;

        case WM_COMMAND:
            switch ((UINT)wParam)
            {
                case IDOK:
                    SendDriverMessage(hdrv, MM_SET_DEBUGOUT,
                        (LPARAM)SendDlgItemMessage(hdlg, ID_DEBUG_OUT, CB_GETCURSEL, 0, 0), 0);

                    SendDriverMessage(hdrv, MM_SET_MCI_DEBUG,
                        (LPARAM)IsDlgButtonChecked(hdlg, ID_DEBUG_MCI),0);

                    SendDriverMessage(hdrv, MM_SET_MM_DEBUG,
                        (LPARAM)IsDlgButtonChecked(hdlg, ID_DEBUG_MMSYS),0);

                    // fall through
                case IDCANCEL:
                    EndDialog(hdlg, wParam);
                    break;

                case ID_RESTART:
                    SendDriverMessage(hdrv, MM_DRV_RESTART, 0, 0);
                    break;

                case ID_HANDLES:
                    if (HIWORD(lParam) != LBN_DBLCLK)
                        break;

                    i = (int)(LONG)SendDlgItemMessage(hdlg,wParam,LB_GETCURSEL,0,0L);
                    dw = (DWORD)SendDlgItemMessage(hdlg,wParam,LB_GETITEMDATA,(WPARAM)i,0L);

                    CloseHandle(dw);
                    GetHandles(hdlg);
                    break;
            }
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\sources.inc ===
TARGETNAME=
TARGETTYPE=NOTARGET
TARGETPATH=
SOURCES=

NTTARGETFILE1=buildall

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmwnd.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   mmwnd.c - contains the window procedure for the MMSYSTEM 'global'
                      window

                      the global window is used by sndPlaySound and MCI for
                      reciving notification messages.

   Version: 1.00

   Date:    04-Sep-1990

   Author:  ToddLa

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "mmsysver.h"

#define CLASS_NAME MAKEINTATOM(42)

/*
   SOUND_DELAY is the number of ms to delay before closing the wave device
   after the buffer is done.
*/

#define SOUND_DELAY 300

typedef LRESULT (CALLBACK *LPWNDPROC)(HWND, UINT, WPARAM, LPARAM);

// Place the normal code in the _TEXT segment

static LRESULT CALLBACK mmWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

#pragma alloc_text(_TEXT, mmWndProc)

HWND hwndNotify;


/****************************************************************************

    strings

****************************************************************************/

SZCODE  szStartupSound[]        = "SystemStart";


/***************************************************************************/

static BOOL PASCAL FAR CreateMMClass(void)
{
    WNDCLASS cls;

    cls.hCursor        = NULL;
    cls.hIcon          = NULL;
    cls.lpszMenuName   = NULL;
    cls.lpszClassName  = CLASS_NAME;
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = ghInst;
    cls.style          = CS_GLOBALCLASS;
    cls.lpfnWndProc    = (WNDPROC)mmWndProc;
    cls.cbWndExtra     = 0;
    cls.cbClsExtra     = 0;

    return RegisterClass(&cls);
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     BOOL | WndInit | called to create the MMSYSTEM global window.
 *
 * @comm    we need to create this window on be-half of the SHELL task
 *          so it will be around all the time.
 *
 ***************************************************************************/

BOOL NEAR PASCAL WndInit(void)
{
    if (hwndNotify)    // if we are init'ed already, just get out
        return TRUE;

    if (!CreateMMClass())
        return FALSE;

    if (!(hwndNotify = CreateWindowEx(0, CLASS_NAME, NULL, WS_OVERLAPPED,
        0, 0, 0, 0, NULL, NULL, ghInst, NULL))) {
        UnregisterClass(CLASS_NAME, ghInst);
        return FALSE;
    }


#ifdef DEBUGX
    {
    DPRINTF(("MMSYSTEM: Creating Notify Window: htask=%04X hwnd=%04X\r\n", GetCurrentTask(),hwndNotify));
    }
#endif // DEBUGX
    return TRUE;
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     void | WndTerminate | called when MMSYSTEM is terminating
 *
 ***************************************************************************/

void NEAR PASCAL WndTerminate(void)
{
    if (hwndNotify)
    {
        SendMessage(hwndNotify, WM_CLOSE, 0, 0L);
        UnregisterClass(CLASS_NAME, ghInst);
    }
}

/***************************************************************************
 *
 * @doc     INTERNAL    MMSYSTEM
 *
 * @api     LRESULT | mmWndProc | The Window procedure for the MMSYSTEM window
 *
 * @comm    mmWndProc calls DefWindowProc for all messages except:
 *
 *          MM_MCINOTIFY:       calls MciNotify()        in MCI.C
 *          MM_WOM_DONE:        calls WaveOutNotify()    in PLAYWAV.C
 *
 * @xref    sndPlaySound
 *
 ***************************************************************************/

static LRESULT CALLBACK mmWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
        case WM_CREATE:
            hwndNotify = hwnd;
            // sndPlaySound(szStartupSound, SND_ASYNC | SND_NODEFAULT);
            break;

        case WM_TIMER:
            KillTimer(hwnd, (UINT)wParam);
            WaveOutNotify(0,0);
            break;

        case MM_MCINOTIFY:
            MciNotify(wParam, lParam);
            break;

        case MM_WOM_DONE:

            /*
                The sound started with sndPlaySound has completed
                so we should call the cleanup routine. We delay
                this call for several hundred milliseconds because
                some sound drivers have a nasty characteristic - they
                will notify before the final DMA transfer is complete
                because the app. supplied buffer is no longer required.
                This means that they may have to spin inside a close
                request until the dma transfer completes. This hangs
                the system for hundreds of milliseconds.

            */

            SetTimer(hwndNotify, 1, SOUND_DELAY, NULL);
            break;

        case MM_SND_PLAY:
            return (LRESULT)(LONG)sndMessage((LPSTR)lParam, (UINT)wParam);

        case MM_MCISYSTEM_STRING:
            return (LRESULT)mciRelaySystemString ((LPMCI_SYSTEM_MESSAGE)lParam);

        default:
            return DefWindowProc(hwnd, msg, wParam,lParam);
    }

    return (LRESULT)0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\playwav.h ===
/*****************************************************************************

    playwav.h

 ****************************************************************************/

BOOL    NEAR PASCAL soundPlay(HGLOBAL hSound, UINT wFlags);
void    NEAR PASCAL soundFree(HGLOBAL hSound);
HGLOBAL NEAR PASCAL soundLoadFile(LPCSTR szFileName);
HGLOBAL NEAR PASCAL soundLoadMemory(LPCSTR lpMem);

/*****************************************************************************

      STUFF TO SUPPORT MS-WAVE FORMAT FILES

 ****************************************************************************/

#define FOURCC( ch0, ch1, ch2, ch3 )                         \
		( (DWORD)(BYTE)(ch0) | ( (DWORD)(BYTE)(ch1) << 8 ) |	\
		( (DWORD)(BYTE)(ch2) << 16 ) | ( (DWORD)(BYTE)(ch3) << 24 ) )

typedef struct _FileHeader {
	DWORD	dwRiff;
	DWORD	dwSize;
	DWORD	dwWave;
} FileHeader;
typedef FileHeader FAR *FPFileHeader;

typedef struct _ChunkHeader {
	DWORD	dwCKID;
	DWORD	dwSize;
} ChunkHeader;
typedef ChunkHeader FAR *FPChunkHeader;

/*  Chunk Types  */
#define RIFF_FILE       FOURCC('R','I','F','F')
#define RIFF_WAVE       FOURCC('W','A','V','E')
#define RIFF_FORMAT     FOURCC('f','m','t',' ')
#define RIFF_CHANNEL    FOURCC('d','a','t','a')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\playwav.c ===
#include <windows.h>
#define MMNOTIMER
#define MMNOSEQ
#define MMNOJOY
#define MMNOMIDI
#define MMNOMCI
#include "mmsystem.h"
#include "mmsysi.h"         // to get DOUT() and _hread()
#include "playwav.h"

//
// These globals are used to keep track of the currently playing sound, and
// the handle to the wave device.  only 1 sound can be playing at a time.
//

static HWAVEOUT    hWaveOut;         // handle to open wave device
LPWAVEHDR   lpWavHdr;         // current wave file playing

/* flags for _lseek */
#define  SEEK_CUR 1
#define  SEEK_END 2
#define  SEEK_SET 0

#define FMEM                (GMEM_MOVEABLE|GMEM_SHARE)

BOOL  NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPCSTR lpMem, DWORD dwLen);
BOOL  NEAR PASCAL soundOpen(HGLOBAL hSound, UINT wFlags);
BOOL  NEAR PASCAL soundClose(void);
void  NEAR PASCAL soundWait(void);

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | WaveOutNotify  | called by mmWndProc when it recives a
 *                              MM_WOM_DONE message
 * @rdesc None.
 *
 ****************************************************************************/

void FAR PASCAL WaveOutNotify(WPARAM wParam, LPARAM lParam)
{
    if (hWaveOut && !(lpWavHdr->dwFlags & WHDR_DONE))
        return;         // wave is not done! get out

    //
    // wave file is done! release the device
    //

    DOUT("MMSYSTEM: ASYNC sound done, closing wave device\r\n");

    soundClose();
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundPlay   | Pretty much speaks for itself!
 *
 * @parm HGLOBAL | hSound | The sound resource to play.
 *
 * @parm wFlags | UINT | flags controlling sync/async etc.
 *
 *  @flag  SND_SYNC            | play synchronously (default)
 *  @flag  SND_ASYNC           | play asynchronously
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundPlay(HGLOBAL hSound, UINT wFlags)
{
    //
    // Before playing a sound release it
    //
    soundClose();

    //
    // open the sound device and write the sound to it.
    //
    if (!soundOpen(hSound, wFlags))
        return FALSE;

    if (!(wFlags & SND_ASYNC))
    {
        soundWait();
        soundClose();
    }
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundOpen  | Open the wave device and write a sound to it.
 *
 * @parm HGLOBAL | hSound | The sound resource to play.
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundOpen(HGLOBAL hSound, UINT wFlags)
{
    UINT        wErr;

    if (!hSound || !hwndNotify)
        return FALSE;

    if (hWaveOut)
    {
        DOUT("MMSYSTEM: soundOpen() wave device is currently open.\r\n");
        return FALSE;
    }

    lpWavHdr = (LPWAVEHDR)GlobalLock(hSound);

    if (!lpWavHdr)
        {
#ifdef DEBUG
        if ((GlobalFlags(hSound) & GMEM_DISCARDED))
            DOUT("MMSYSTEM: sound was discarded before play could begin.\r\n");
#endif
        return FALSE;
        }

    //
    // open the wave device, open any wave device that supports the
    // format
    //
    wErr = waveOutOpen(&hWaveOut,           // returns handle to device
            (UINT)WAVE_MAPPER,                    // device id (any device)
            (LPWAVEFORMAT)lpWavHdr->dwUser, // wave format
            (DWORD)(UINT)hwndNotify,        // callback function
            0L,                      // callback instance data
            WAVE_ALLOWSYNC | CALLBACK_WINDOW);               // flags

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() unable to open wave device\r\n");
        GlobalUnlock(hSound);
        lpWavHdr = NULL;
        hWaveOut = NULL;
        return FALSE;
    }

    wErr = waveOutPrepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() waveOutPrepare failed\r\n");
        soundClose();
        return FALSE;
    }

    //
    // Only allow sound looping if playing ASYNC sounds
    //
    if ((wFlags & SND_ASYNC) && (wFlags & SND_LOOP))
    {
        lpWavHdr->dwLoops  = 0xFFFFFFFF;     // infinite loop
        lpWavHdr->dwFlags |= WHDR_BEGINLOOP|WHDR_ENDLOOP;
    }
    else
    {
        lpWavHdr->dwLoops  = 0;
        lpWavHdr->dwFlags &=~(WHDR_BEGINLOOP|WHDR_ENDLOOP);
    }

    lpWavHdr->dwFlags &= ~WHDR_DONE;        // mark as not done!
    wErr = waveOutWrite(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundOpen() waveOutWrite failed\r\n");
        soundClose();
        return FALSE;
    }

    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @func BOOL | soundClose | This function closes the sound device
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
BOOL NEAR PASCAL soundClose(void)
{
    UINT        wErr;

    //
    // Do we have the sound device open?
    //
    if (!lpWavHdr || !hWaveOut)
        return TRUE;

    //
    // if the block is still playing, stop it!
    //
    if (!(lpWavHdr->dwFlags & WHDR_DONE))
        waveOutReset(hWaveOut);

#ifdef DEBUG
    if (!(lpWavHdr->dwFlags & WHDR_DONE))
    {
        DOUT("MMSYSTEM: soundClose() data is not DONE!???\r\n");
        lpWavHdr->dwFlags |= WHDR_DONE;
    }

    if (!(lpWavHdr->dwFlags & WHDR_PREPARED))
    {
        DOUT("MMSYSTEM: soundClose() data not prepared???\r\n");
    }
#endif

    //
    // unprepare the data anyway!
    //
    wErr = waveOutUnprepareHeader(hWaveOut, lpWavHdr, sizeof(WAVEHDR));

    if (wErr != 0)
    {
        DOUT("MMSYSTEM: soundClose() waveOutUnprepare failed?\r\n");
    }

    //
    // finaly actually close the device, and unlock the data
    //
    waveOutClose(hWaveOut);
    GlobalUnlock((HGLOBAL)HIWORD(lpWavHdr));

    //
    // update globals, claiming the device is closed.
    //
    hWaveOut = NULL;
    lpWavHdr = NULL;
    return TRUE;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundWait | wait for the sound device to complete
 *
 * @rdesc none
 ****************************************************************************/
void NEAR PASCAL soundWait(void)
{
    if (lpWavHdr)
        while (!(lpWavHdr->dwFlags & WHDR_DONE))
            ;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api void | soundFree | This function frees a sound resource created
 *      with soundLoadFile or soundLoadMemory
 *
 * @rdesc Returns TRUE if successful and FALSE on failure.
 ****************************************************************************/
void NEAR PASCAL soundFree(HGLOBAL hSound)
{
    if (!hSound)
        return;

    // !!! we should only close the sound device iff this hSound is playing!
    //
    soundClose();
    GlobalFree(hSound);
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HGLOBAL | soundLoadFile | Loads a specified sound resource from a
 *	file into a global, discardable object.
 *
 * @parm LPCSTR | lpszFile | The file from which to load the sound resource.
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HGLOBAL NEAR PASCAL soundLoadFile(LPCSTR szFileName)
{
    HFILE       fh;
    OFSTRUCT    of;
    DWORD       dwSize;
    LPSTR       lpData;
    HGLOBAL     h;
    UINT        wNameLen;

    // open the file
    fh = OpenFile(szFileName, &of, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR)
        return NULL;

    wNameLen = lstrlen(szFileName) + 1;
    dwSize = _llseek(fh, 0l, SEEK_END);   // get the size of file
    _llseek(fh, 0l, SEEK_SET);            // seek back to the start

    // allocate some discardable memory for a wave hdr, name and the file data.
    h = GlobalAlloc(FMEM+GMEM_DISCARDABLE, sizeof(WAVEHDR) + wNameLen + dwSize);
    if (!h)
        goto error1;

    // lock it down
    lpData = GlobalLock(h);

    // read the file into the memory block

    if (_hread(fh,lpData+sizeof(WAVEHDR)+wNameLen,(LONG)dwSize) != (LONG)dwSize)
        goto error3;

    // do the rest of it from the memory image
    if (!soundInitWavHdr((LPWAVEHDR)lpData, lpData+sizeof(WAVEHDR)+wNameLen, dwSize))
        goto error3;

    _lclose(fh);

    lstrcpy(lpData+sizeof(WAVEHDR), szFileName);
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
    GlobalFree(h);
error1:
    _lclose(fh);
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api HGLOBAL | soundLoadMemory | Loads a user specified sound resource from a
 *	a memory block supplied by the caller.
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of the file
 *
 * @rdesc Returns NULL on failure, GLOBAL HANDLE to a WAVEHDR iff success
 ****************************************************************************/
HGLOBAL NEAR PASCAL soundLoadMemory(LPCSTR lpMem)
{
    HGLOBAL h;
    LPSTR lp;

    // allocate some memory, for a wave hdr
    h = GlobalAlloc(FMEM, (LONG)sizeof(WAVEHDR)+1);
    if (!h)
        goto error1;

    // lock it down
    lp = GlobalLock(h);

    //
    // we must assume the memory pointer is correct! (hence the -1l)
    //
    if (!soundInitWavHdr((LPWAVEHDR)lp, lpMem, (DWORD)-1l))
        goto error3;

    lp[sizeof(WAVEHDR)] = (char)0;        // No file name for memory file
    GlobalUnlock(h);
    return h;

error3:
    GlobalUnlock(h);
    GlobalFree(h);
error1:
    return NULL;
}

/*****************************************************************************
 * @doc INTERNAL
 *
 * @api BOOL | soundInitWavHdr | Initializes a WAVEHDR data structure from a
 *                         pointer to a memory image of a RIFF WAV file.
 *
 * @parm LPWAVHDR | lpwh | Pointer to a WAVEHDR
 *
 * @parm LPCSTR | lpMem | Pointer to a memory image of a RIFF WAV file
 *
 * @rdesc Returns FALSE on failure, TRUE on success.
 *
 * @comm the dwUser field of the WAVEHDR structure is initialized to point
 * to the WAVEFORMAT structure that is inside the RIFF data
 *
 ****************************************************************************/
BOOL NEAR PASCAL soundInitWavHdr(LPWAVEHDR lpwh, LPCSTR lpMem, DWORD dwLen)
{
    FPFileHeader fpHead;
    LPWAVEFORMAT lpFmt;
    LPCSTR	 lpData;
    DWORD	 dwFileSize,dwCurPos;
    DWORD        dwSize;

    if (dwLen < sizeof(FileHeader))
        return FALSE;

    // assume the first few bytes are the file header
    fpHead = (FPFileHeader) lpMem;

    // check that it's a valid RIFF file and a valid WAVE form.
    if (fpHead->dwRiff != RIFF_FILE || fpHead->dwWave != RIFF_WAVE ) {
        return FALSE;
    }

    dwFileSize = fpHead->dwSize;
    dwCurPos = sizeof(FileHeader);
    lpData = lpMem + sizeof(FileHeader);

    if (dwLen < dwFileSize)     // RIFF header
        return FALSE;

    // scan until we find the 'fmt' chunk
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_FORMAT )
            break; // from the while loop that's looking for it
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
	if( dwCurPos >= dwFileSize )
            return FALSE;
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'fmt' chunk data
    lpFmt = (LPWAVEFORMAT) (lpData + sizeof(ChunkHeader));

    // scan until we find the 'data' chunk
    lpData = lpData + ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    while( 1 ) {
        if( ((FPChunkHeader)lpData)->dwCKID == RIFF_CHANNEL)
            break; // from the while loop that's looking for it
        dwCurPos += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
	if( dwCurPos >= dwFileSize )
	    return NULL;
        lpData += ((FPChunkHeader)lpData)->dwSize + sizeof(ChunkHeader);
    }

    // now we're at the beginning of the 'data' chunk data
    dwSize = ((FPChunkHeader)lpData)->dwSize;
    lpData = lpData + sizeof(ChunkHeader);

    // initialize the WAVEHDR

    lpwh->lpData    = (LPSTR)lpData;    // pointer to locked data buffer
    lpwh->dwBufferLength  = dwSize;     // length of data buffer
    lpwh->dwUser    = (DWORD)lpFmt;     // for client's use
    lpwh->dwFlags   = WHDR_DONE;        // assorted flags (see defines)
    lpwh->dwLoops   = 0;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\sound.c ===
/*
    sound.c

    Level 1 kitchen sink DLL sound driver functions

    Copyright (c) Microsoft Corporation 1990. All rights reserved

*/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "playwav.h"

BOOL WINAPI IsTaskLocked(void); // In Kernel

//
// place sndPlaySound in the _TEXT segment so the entire wave segment
// does not come in if no wave devices are loaded.
//

#pragma alloc_text(_TEXT, sndPlaySound)

static SZCODE szNull[]          = "";
static SZCODE szSoundSection[]  = "sounds";        // WIN.INI section for sounds
       SZCODE szSystemDefault[] = "SystemDefault"; // Name of the default sound

#define SOUNDNAMELEN 128
static HGLOBAL hCurrentSound;                      // handle to current sound.

extern LPWAVEHDR lpWavHdr;                  // current playing sound PLAYWAV.C

/****************************************************************************/

static void PASCAL NEAR GetSoundName(
	LPCSTR	lszSoundName,
	LPSTR	lszBuffer)
{
	OFSTRUCT	of;
	int	i;

        //
        //  if the sound is defined in the [sounds] section of WIN.INI
        //  get it and remove the description, otherwise assume it is a
        //  file and qualify it.
        //
        GetProfileString(szSoundSection, lszSoundName, lszSoundName, lszBuffer, SOUNDNAMELEN);

        // remove any trailing text first

        for (i = 0; lszBuffer[i] && (lszBuffer[i] != ' ') && (lszBuffer[i] != '\t') && (lszBuffer[i] != ','); i++)
                ;
        lszBuffer[i] = (char)0;

        if (OpenFile(lszBuffer, &of, OF_EXIST | OF_READ | OF_SHARE_DENY_NONE) != HFILE_ERROR)
            OemToAnsi(of.szPathName, lszBuffer);
}

/*****************************************************************************
 * @doc EXTERNAL
 *
 * @api BOOL | sndPlaySound | This function plays a waveform
 *      sound specified by a filename or by an entry in the [sounds] section
 *      of WIN.INI.  If the sound can't be found, it plays the
 *      default sound specified by the SystemDefault entry in the
 *      [sounds] section of WIN.INI. If there is no SystemDefault
 *      entry or if the default sound can't be found, the function
 *      makes no sound and returns FALSE.
 *
 * @parm LPCSTR | lpszSoundName | Specifies the name of the sound to play.
 *      The function searches the [sounds] section of WIN.INI for an entry
 *      with this name and plays the associated waveform file.
 *      If no entry by this name exists, then it assumes the name is
 *      the name of a waveform file. If this parameter is NULL, any
 *     currently playing sound is stopped.
 *
 * @parm UINT | wFlags | Specifies options for playing the sound using one
 *      or more of the following flags:
 *
 * @flag  SND_SYNC            | The sound is played synchronously and the
 *      function does not return until the sound ends.
 * @flag  SND_ASYNC           | The sound is played asynchronously and the
 *      function returns immediately after beginning the sound. To terminate
 *      an asynchronously-played sound, call <f sndPlaySound> with
 *      <p lpszSoundName> set to NULL.
 * @flag  SND_NODEFAULT       | If the sound can't be found, the function
 *      returns silently without playing the default sound.
 * @flag  SND_MEMORY          | The parameter specified by <p lpszSoundName>
 *      points to an in-memory image of a waveform sound.
 * @flag  SND_LOOP            | The sound will continue to play repeatedly
 *      until <f sndPlaySound> is called again with the
 *      <p lpszSoundName> parameter set to NULL.  You must also specify the
 *      SND_ASYNC flag to loop sounds.
 * @flag  SND_NOSTOP          | If a sound is currently playing, the
 *      function will immediately return FALSE without playing the requested
 *      sound.
 *
 * @rdesc Returns TRUE if the sound is played, otherwise
 *      returns FALSE.
 *
 * @comm The sound must fit in available physical memory and be playable
 *      by an installed waveform audio device driver. The directories
 *      searched for sound files are, in order: the current directory;
 *      the Windows directory; the Windows system directory; the directories
 *      listed in the PATH environment variable; the list of directories
 *      mapped in a network. See the Windows <f OpenFile> function for
 *      more information about the directory search order.
 *
 *      If you specify the SND_MEMORY flag, <p lpszSoundName> must point
 *      to an in-memory image of a waveform sound. If the sound is stored
 *      as a resource, use <f LoadResource> and <f LockResource> to load
 *      and lock the resource and get a pointer to it. If the sound is not
 *      a resource, you must use <f GlobalAlloc> with the GMEM_MOVEABLE and
 *      GMEM_SHARE flags set and then <f GlobalLock> to allocate and lock
 *      memory for the sound.
 *
 * @xref MessageBeep
 ****************************************************************************/

BOOL WINAPI sndPlaySound(LPCSTR szSoundName, UINT wFlags)
{
    //
    //  !!! quick exit for no wave devices !!!
    //
    static UINT wTotalWaveOutDevs = (UINT)-1;

    if (wTotalWaveOutDevs == -1 ) {
        wTotalWaveOutDevs = waveOutGetNumDevs();
    }

    if (wTotalWaveOutDevs)
        return sndPlaySoundI(szSoundName, wFlags);
    else
        return FALSE;
}

/****************************************************************************/
/*
@doc	INTERNAL

@func	BOOL | sndPlaySoundI | Internal version of <f>sndPlaySound<d> which
	resides in the WAVE segment instead.

	If the SND_NOSTOP flag is specifed and a wave file is currently
	playing, or if for some reason no mmsystem window is present, the
	function returns failure immediately.  The first condition ensures
	that a current sound is not interrupted if the flag is set.  The
	second condition is only in case of some start up error in which
	the notification window was not created, or mmsystem was not
	specified in the [drivers] line, and therefore never loaded.

	Next, if the <p>lszSoundName<d> parameter does not represent a memory
	file, and it is non-NULL, then it must represent a string.  Therefore
	the string must be parsed before sending the sound message to the
	mmsystem window.  This is because the mmsystem window may reside in a
	a different task than the task which is calling the function, and
	would most likely have a different current directory.

	In this case, the parameter is first checked to determine if it
	actually contains anything.  For some reason a zero length string
	was determined to be able to return TRUE from this function, so that
	is checked.

	Next the string is checked against INI entries, then parsed.

	After parsing the sound name, ensure that a task switch only occurs if
	the sound is asyncronous (SND_ASYNC), and a previous sound does not
	need to be discarded.

	If a task switch is needed, first ensure that intertask messages can
	be sent by checking to see that this task is not locked, or that the
	notification window is in the current task.

@parm	LPCSTR | lszSoundName | Specifies the name of the sound to play.

@parm	UINT | wFlags | Specifies options for playing the sound.

@rdesc	Returns TRUE if the function was successful, else FALSE if an error
	occurred.
*/
BOOL FAR PASCAL sndPlaySoundI(LPCSTR lszSoundName, UINT wFlags)
{
	BOOL	fPlayReturn;
        PSTR    szSoundName;

        V_FLAGS(wFlags, SND_VALID, sndPlaySound, NULL);

        if ((wFlags & SND_LOOP) && !(wFlags & SND_ASYNC)) {
            LogParamError(ERR_BAD_FLAGS, (FARPROC)sndPlaySound,  (LPVOID)(DWORD)wFlags);
            return FALSE;
        }

        if (!(wFlags & SND_MEMORY) && lszSoundName)
                V_STRING(lszSoundName, 128, FALSE);

#ifdef  DEBUG
        if (wFlags & SND_MEMORY) {
            DPRINTF1("MMSYSTEM: sndPlaySound(%lx)\r\n", lszSoundName);
        }
        else if (lszSoundName) {
            if (wFlags & SND_ASYNC) {
                if (wFlags & SND_LOOP) {
                    DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_ASYNC|SND_LOOP)\r\n", lszSoundName);
                }
                else {
                    DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_ASYNC)\r\n", lszSoundName);
                }
            }
            else
                DPRINTF1("MMSYSTEM: sndPlaySound(%ls, SND_SYNC)\r\n", lszSoundName);
        }
        else
            DOUT("MMSYSTEM: sndPlaySound(NULL)\r\n");

#endif  //ifdef DEBUG

	if (((wFlags & SND_NOSTOP) && lpWavHdr) || !hwndNotify)
                return FALSE;

	if (!(wFlags & SND_MEMORY) && lszSoundName) {
		if (!*lszSoundName)
			return TRUE;
                if (!(szSoundName = (PSTR)LocalAlloc(LMEM_FIXED, SOUNDNAMELEN)))
			return FALSE;
		GetSoundName(lszSoundName, szSoundName);
		lszSoundName = (LPCSTR)szSoundName;
	} else
                szSoundName = NULL;

	if (!(wFlags & SND_ASYNC) && !lpWavHdr)
		fPlayReturn = sndMessage((LPSTR)lszSoundName, wFlags);
	else {
		if (!IsTaskLocked() || (GetWindowTask(hwndNotify) == GetCurrentTask())) {
			fPlayReturn = (BOOL)(LONG)SendMessage(hwndNotify, MM_SND_PLAY, (WPARAM)wFlags, (LPARAM)lszSoundName);
		} else
			fPlayReturn = FALSE;
	}
	if (szSoundName)
                LocalFree((HLOCAL)szSoundName);

	return fPlayReturn;
}

/****************************************************************************/
static BOOL PASCAL NEAR SetCurrentSound(
	LPCSTR	lszSoundName)
{
	HGLOBAL	hSound;
        BOOL    f;
        LPSTR   lp;

        if (hCurrentSound && (lp = GlobalLock(hCurrentSound))) {
                f = lstrcmpi(lszSoundName, lp + sizeof(WAVEHDR)) == 0;
                GlobalUnlock(hCurrentSound);
                if (f)
                    return TRUE;
	}

        DPRINTF(("MMSYSTEM: soundLoadFile(%ls)\r\n",lszSoundName));

        if (hSound = soundLoadFile(lszSoundName)) {
		soundFree(hCurrentSound);
		hCurrentSound = hSound;
		return TRUE;
	}
	return FALSE;
}
/****************************************************************************/
/*
@doc	INTERNAL

@func	BOOL | sndMessage | This function is called in response to an
	MM_SND_PLAY message sent to the mmsystem window, and attempts to
	play the specified file, or dump current sound caching.

	If <p>lszSoundName<d> is NULL, any currently cached sound is
	discarded, and the function returns success.

	If the SND_MEMORY flag is set, then <p>lszSoundName<d> actually
	points to a buffer containing a RIFF format WAVE memory file, and
	the function attempts to play it.  The load function performs
	validation on this memory file.  Unlike playing sound names,
	memory files are not cached for future use.

	Otherwise the <p>lszSoundName<d> parameter is actually an INI entry
	or file name.  The function initially attempts to load that sound,
	and if it fails, attempts to load the system default sound.  Note of
	course that the SND_NODEFAULT flag is first checked to determine if
	the default sound is to be played when the original name cannot be
	located.  If no default is wanted, or the default cannot be located,
	the function returns failure.  Note that in calling <f>GetSoundName<d>,
	the <p>lszSoundName<d> parameter is modified.  This function assumes
	that the parameter passed has been previously allocated if a string is
	passed to this function, and is not the actual user's parameter passed
	to <f>sndPlaySound<d>.

@parm	LPSTR | lszSoundName | Specifies the name of the sound to play.

@parm	UINT | wFlags | Specifies options for playing the sound.

@rdesc	Returns TRUE if the function was successful, else FALSE if an error
	occurred.
*/
BOOL FAR PASCAL sndMessage(LPSTR lszSoundName, UINT wFlags)
{
	if (!lszSoundName) {
		soundFree(hCurrentSound);
		hCurrentSound = NULL;
		return TRUE;
	}
	if (wFlags & SND_MEMORY) {
                soundFree(hCurrentSound);
		hCurrentSound = soundLoadMemory(lszSoundName);
	} else if (!SetCurrentSound(lszSoundName)) {
		if (wFlags & SND_NODEFAULT)
			return FALSE;
		GetSoundName(szSystemDefault, lszSoundName);
		if (!SetCurrentSound(lszSoundName))
			return FALSE;
	}
	return soundPlay(hCurrentSound, wFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\stack.asm ===
page 80,132
;***************************************************************************;
;
;   STACK.ASM
;
;   Copyright (c) Microsoft Corporation 1989, 1990. All rights reserved.
;
;   This module contains a routine that calls a callback function on a
;   internal stack.  This is designed to be used by MMSYSTEM drivers that
;   call user callback functions at async interupt time.
;
;   Revision history:
;
;   07/30/90        First created by ToddLa (moved from SndBlst driver)
;   04/24/91        MikeRo. Added stack usage stuff.
;   07/07/91        CurtisP. New stack switcher code that allows user to
;                   configure size and number of stacks.  Default is 3
;                   frames of 1.5kb each.  This is the minimum that MCISEQ
;                   needs in standard mode (running concurrent with wave).
;                   [mmsystem]!stackframes= and !stacksize=.  stackframes
;                   mul stacksize can not be > 64k.
;   07/24/91        ToddLa. even newer stack switcher code! export StackEnter
;                   and StackLeave
;   11/02/92        StephenE. Hacked the code to make it work on NT/WOW.
;
;***************************************************************************;

ifdef MYDEBUG
        DEBUG_RETAIL equ 1
endif

?PLM=1  ; pascal call convention
?WIN=0  ; NO! Windows prolog/epilog code

        .286p
        .xlist
        include wow.inc
        include wowmmcb.inc
        include wowmmed.inc
        include cmacros.inc

;       include windows.inc
;       include mmsystem.inc
;       include mmddk.inc
;       include wowmmcb.inc

	include vint.inc
        .list

OFFSEL	STRUC
Off	dw  ?
Sel	dw  ?
OFFSEL	ENDS

LOHI	STRUC
Lo	dw  ?
Hi	dw  ?
LOHI	ENDS

DCB_NOSWITCH    equ   0008h           ; don't switch stacks for callback
DCB_TYPEMASK    equ   0007h           ; callback type mask
DCB_NULL        equ   0000h           ; unknown callback type

; flags for wFlags parameter of DriverCallback()
DCB_WINDOW     equ    0001h           ; dwCallback is a HWND
DCB_TASK       equ    0002h           ; dwCallback is a HTASK
DCB_FUNCTION   equ    0003h           ; dwCallback is a FARPROC

        externFP        PostMessage         ; in USER
        externFP        PostAppMessage      ; in USER
        externFP        CALLPROC32W         ; in Kernel
        externFP        ThunkInit           ; in init.c
        externFP        WOW16Call           ; in Kernel

;******************************************************************************
;
;   SEGMENTS
;
;******************************************************************************
createSeg FIX,          CodeFix, word, public, CODE
createSeg INTDS,        DataFix, byte, public, DATA

;***************************************************************************;
;
;   equates and structure definitions
;
;***************************************************************************;

STACK_MAGIC         equ     0BBADh


;***************************************************************************;
;
;   Local data segment
;
;***************************************************************************;

sBegin DataFix
;
; This is the stack we will switch to whenever we are calling
; a user call back
;
        public  gwStackSize
        public  gwStackFrames
        public  gwStackUse
        public  gwStackSelector
        public  hdrvDestroy
        public  vpCallbackData
        public  hGlobal
        public  DoInterrupt
        public  tid32Message
        public  mmwow32Lib
        public  CheckThunkInit

gwStackSize     dw      0
gwStackFrames   dw      0
gwStackUse      dw      0
gwStackSelector dw      0
hdrvDestroy     dw      -1      ; this handle is being closed
vpCallbackData  dd      0
hGlobal         dd      0
tid32Message    dd      0       ; timer driver entry point
mmwow32Lib      dd      0

sEnd    DataFix

;-------------------------------------------------------------------------;
;
;   debug support
;
;-------------------------------------------------------------------------;
externFP        OutputDebugString

;--------------------------Private-Macro----------------------------------;
; DOUT String - send a debug message to the debugger
;
; Entry:
;       String      String to send to the COM port, does not need a CR,LF
;
; Registers Destroyed:
;       none
;
; NOTE no code is generated unless the MYDEBUG symbol is defined
;
; History:
;       Sun 31-Jul-1989  -by-  ToddLa
;        Wrote it.
;-------------------------------------------------------------------------;

DOUT    macro   text
        local string_buffer_stack
ifdef MYDEBUG
        push    cs
        push    offset string_buffer_stack
        call    OutputDebugString
        jmp     @F
string_buffer_stack label byte
        db      "mmsystem: "
        db      "&text&",13,10,0
@@:
endif
        endm


;***************************************************************************;
;
;   code segment
;
;***************************************************************************;

sBegin CodeFix
        assumes cs, CodeFix
        assumes ds, nothing
        assumes es, nothing

externA     __WinFlags

public      CodeFixWinFlags
public      CodeFixDS

CodeFixWinFlags     dw      __WinFlags
CodeFixDS           dw      DataFixBASE

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @asm StackEnter |
;
;   This function switches to the next internal mmsystem interupt stack
;   available.
;
;   if one is not available we stay on the current stack.
;
;   the size and number of mmsystem stacks is controlable from SYSTEM.INI
;   (these are the defaults)
;
;       [mmsystem]
;           StackSize   = 1536
;           StackFrames = 3
;
;   for every call to StackEnter a call to StackLeave *must* be made (even
;   if StackEnter fails!)
;
;   this function is intended to be used as the first thing done by a ISR
;
;       MyISR proc far
;
;               call    StackEnter          ; switch to a safe stack
;
;               pusha                       ; save registers we use
;
;               <handle IRQ>
;
;               popa                        ; restore registers
;
;               call    StackLeave          ; return to interupt stack
;               iret                        ; done with ISR
;
;       MyISR endp
;
;   The old SS:SP is pushed onto the new stack, and the function returns.
;
;   @rdesc NC   ** succesfuly switced to a new stack
;           C   ** you are hosed jack, no stacks left
;                  (you remain on current stack)
;
;   @uses flags
;
;   @saves all
;
;   @xref StackLeave, DriverCallback
;
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc   StackEnter, <FAR, PUBLIC>, <>
cBegin  nogen

        ;
        ; On WOW we only emulate Standard mode therefore I won't bother
        ; with the test described below.
        ;
        ; if we are in 386 mode or better (ie *not* standard mode) then, just
        ; get out.
        ;
;       test    cs:[CodeFixWinFlags],WF_WIN286
;       jz      stack_enter_retf

        push    ds

        mov     ds,[CodeFixDS]
        assumes ds,DataFix

        cmp     [gwStackUse], 0                     ; are we out of stacks?
        jne     stack_enter_have_stack_will_travel  ; ..no go grab it

;**********************************************************************-;
;
;  We are out of internal stacks.  To give us the greates chance
;  of coming out of this condition alive, we stay on the current
;  stack.  This could fail miserably if we are on a very small
;  stack**but it is better than crashing outright.
;
;**********************************************************************-;

ifdef DEBUG_RETAIL
        cmp     [gwStackSelector], 0
        je      stack_enter_stay_here

        DOUT    <StackEnter: All stacks in use, increase StackFrames>
        int     3
endif

ifdef MYDEBUG
        call    dump_stack_users
endif

stack_enter_stay_here:
        pop     ds
        assumes ds,nothing
        push    bp
        mov     bp,sp
        push    ax

        xor     ax,ax
        xchg    [bp+4],ax
        xchg    [bp+2],ax
        xchg    [bp],ax
        xchg    [bp-2],ax

        pop     bp
stack_enter_retf:
        stc
        retf

;**********************************************************************-;
;
;   we have a stack to use, allocate stack FIRST, then muck with it
;   leave no window for interrupts to blast us.
;
;   It does this by using the contents of the gwStackUse variable as
;   the new SP.  This initially contains the address of the start (ie top)
;   of the internal stack area, and is subtracted from each time a StackEnter
;   occurs.  It is of course added to again when StackLeave is called
;   freeing up that area of stack for the next use.
;
;   Note that the stack usage counter is modified before anything is
;   is pushed onto the new stack.  If an interrupt occurs after the stack
;   switch, but before the usage is set, it will be fine.
;
;**********************************************************************-;
        assumes ds,DataFix

stack_enter_have_stack_will_travel:
        push    ax
        push    bx
        mov     bx,sp

        mov     ax, [gwStackSize]
        sub     [gwStackUse], ax        ; reserve stack before using
        add     ax, [gwStackUse]        ; get current value and hang onto it

;**********************************************************************-;
;
;   debug code, in the debug version we do crazy things like filling
;   the stack with magic numbers.
;
;**********************************************************************-;
ifdef MYDEBUG
;       **  This code will fill the stack with the magic cookie**this
;       **  is used to see how much stack space is being used at any
;       **  time.

        push    es
        push    di
        push    ax
        push    cx
        mov     di, ax                  ; es:di -> top of stack
        mov     es, [gwStackSelector]
        mov     cx, [gwStackSize]       ; get size to fill
        sub     di, cx                  ; es:di -> bottom of stack
        shr     cx, 1                   ; in words
        mov     ax, STACK_MAGIC         ; what to fill with
        cld                             ; bottom up
        rep     stosw
        pop     cx                      ; restore munged regs
        pop     ax
        pop     di
        pop     es
endif

ifdef DEBUG_RETAIL
;       **  This code puts a single magic cookie at the end of the stack.
;       **  This is used by the stack leave routine to check for overflow.
;       **  If the above code (the fill) is running, then this code is
;       **  redundant.

        push    es
        push    bx
        mov     es,[gwStackSelector]
        mov     bx,[gwStackUse]         ;   new stack
        mov     es:[bx], STACK_MAGIC
        pop     bx
        pop     es
endif

;**********************************************************************-;
;
;   time to switch to the *new* stack, [gwStackSelector]:AX contains
;   the new SS:SP, but first save the *old* SS:SP and restore
;   the registers we nuked to get here
;
;**********************************************************************-;

        push    [gwStackSelector]       ; push *new* ss

        push    ss                      ; save current ss in ds
        pop     ds
        assumes ds, nothing

        pop     ss                      ; switch to new stack
        mov     sp, ax                  ; ints off until after this on >= 286

;**********************************************************************-;
;
;   now that we are on the new stack, copy some important info from
;   the old stack to this one.  note DS:[BX] points to the old stack
;
;       [BX+0]        ==> saved  BX
;       [BX+2]        ==> saved  AX
;       [BX+4]        ==> saved  DS
;       [BX+6]        ==> return IP
;       [BX+8]        ==> return CS
;
;   in the MYDEBUG version we save the callers CS:IP on the stack so we
;   can (in dump_stack_users) walk all the stacks
;
;**********************************************************************-;

ifdef MYDEBUG
        push    [bx+8]                  ; push a CS:IP for dumping stack users
        push    [bx+6]
endif
        add     bx,10                   ; 10 = ax+bx+dx+retf
        push    ds                      ; save old SS:SP (SP = BX+N)
        push    bx
        sub     bx,10

        push    [bx+8]                  ; push return addr
        push    [bx+6]

        push    [bx+4]                  ; push saved DS
        push    [bx]                    ; push saved BX

        mov     ax,[bx+2]               ; restore ax
        pop     bx                      ; restore bx
        pop     ds                      ; restore ds
        clc                             ; show success
stack_leave_retf:
        retf                            ; return to caller

cEnd    nogen

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @asm StackLeave |
;
;   This function returns the stack to the original stack saved by StackEnter
;
;   @uses flags
;
;   @saves all
;
;   @xref   StackEnter, DriverCallback
;
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc   StackLeave, <FAR, PUBLIC>, <>
cBegin  nogen
        ;
        ; if we are in 386 mode or better (ie *not* standard mode) then, just
        ; get out.
        ;
;       test    cs:[CodeFixWinFlags],WF_WIN286
;       jz      stack_leave_retf

        push    bx
        mov     bx,sp

;**********************************************************************-;
;
;   here is the state of things:
;
;       [BX+0]        ==> saved  BX
;       [BX+2]        ==> return IP
;       [BX+4]        ==> return CS
;       [BX+6]        ==> saved  SP
;       [BX+8]        ==> saved  SS
;
;   the first thing we must check for is EnterStack running out of
;   stacks.  in this case StackEnter pushed a single zero where the
;   saved SS should be
;
;**********************************************************************-;

        cmp     word ptr ss:[bx+6],0    ; check saved SP
        jnz     stack_leave_normal

;**********************************************************************-;
;
;   StackEnter ran out of stacks, stay on the current stack, but remove
;   the bogus SS
;
;**********************************************************************-;
stack_leave_abby_normal:
        pop     bx                      ; return to caller taking the
        retf    2                       ; bogus zero SP with us

;**********************************************************************-;
;
;   we need to return to the stack saved by StackEnter
;
;**********************************************************************-;
stack_leave_normal:
        push    ds                      ; [BX-2] ==> saved DS

        push    ss                      ; DS = old stack
        pop     ds
        assumes ds,nothing

ifdef MYDEBUG
        push    ax
        mov     ax,[bx+8]
        lar     ax,ax
        jz      @f
        DOUT    <StackLeave: invalid stack>
        int     3
@@:     pop     ax
endif

        mov     ss,[bx+8]               ; switch to new stack
        mov     sp,[bx+6]               ; ints off until after this on >= 286

        push    [bx+4]                  ; push return addr
        push    [bx+2]

        push    [bx]                    ; push old BX
        push    [bx-2]                  ; push old DS

;**********************************************************************-;
;
;   we are back on the original stack, now it is time to deallocate
;   the stack.
;
;   The stack usage must only be released after all
;   values have been removed from the stack so that an interrupt can be
;   serviced without writing over any values.
;
;**********************************************************************-;

        mov     ds,[CodeFixDS]          ; get at our globals
        assumes ds,DataFix

ifdef DEBUG_RETAIL
        push    es
        push    bx
        mov     bx,[gwStackUse]         ; before we release it
        mov     es,[gwStackSelector]
        cmp     es:[bx], STACK_MAGIC
        mov     es:[bx], STACK_MAGIC    ; and try to recover...
        pop     bx
        pop     es
        je      @f                      ; true if magic cookie existed

        DOUT    <StackLeave: STACK OVERFLOW>
        int     3
ifdef MYDEBUG
        call    dump_stack_users
endif
@@:
endif
        mov     bx, [gwStackSize]       ; get the size of the stacks
        add     [gwStackUse], bx        ; release stack frame after use

        pop     ds
        assumes ds,nothing
        pop     bx
        retf

cEnd nogen

;****************************************************************************
;   FUNCTION:  DoInterrupt()
;
;   PURPOSE:
;       This routine is called by the ISR in the InstallInerruptHandler
;       routine.
;
;   void DoInterrupt( void )
;   {
;       VPCALLBACK_ARGS     pArgs;
;       WORD                wSendCount = vpCallbackData->wSendCount;
;       WORD                wTempRecvCount;
;
;       /*
;       ** At entry to this function the receive count should be one less than
;       ** than the send count.  However, it is possible that we have lost some
;       ** interrupts in which case we should try to "catch up" here.
;       **
;       ** The 32 bit side does not increament wSendCount until the
;       ** callback data buffer has been updated. This means that although it
;       ** is possible that it could have been changed before this interrupt
;       ** was generated it will never point to an invalid buffer location.
;       ** We simply process two interrupt request from the first interrupt,
;       ** when the second interrupt goes off we return straight away.
;       */
;       vpCallbackData->wIntsCount++;
;
;       while ( vpCallbackData->wRecvCount != wSendCount ) {
;
;           /*
;           ** Increment the recv count.  Use of the % operator to makes sure
;           ** that we wrap around to the begining of the array correctly.
;           */
;           wTempRecvCount = (vpCallbackData->wRecvCount + 1)
;                               % CALLBACK_ARGS_SIZE;
;
;           pArgs = &vpCallbackData->args[ wTempRecvCount ];
;           DriverCallback( pArgs->dwFunctionAddr,
;                           LOWORD( pArgs->dwFlags ),
;                           pArgs->wHandle,
;                           pArgs->wMessage,
;                           pArgs->dwInstance,
;                           pArgs->dwParam1,
;                           pArgs->dwParam2 );
;
;           vpCallbackData->wRecvCount = wTempRecvCount;
;       }
;
;   }
;
;****************************************************************************
cProc DoInterrupt, <FAR,PUBLIC>, <si,di>

localW  wSendCount                     ;number of interrupts sent

cBegin  DoInt

        DOUT    <Multi-Media Interupt called>

;
;       Now we take the parameters from the global callback data array
;       and increment the dwRecvCount field.  Then we make the
;       callback into the apps routine.  Note that the es:bx registers are used
;       instead of the local variable pArgs.
;

        mov     es,[CodeFixDS]
        assumes es,DataFix

;
;       wSendCount = vpCallbackData->wSendCount
;       vpCallbackData->wIntsCount++;
;
	les	bx,DWORD PTR es:vpCallbackData
	mov	ax,WORD PTR es:[bx+2]
	mov	wSendCount,ax	
        inc     WORD PTR es:[bx+388]    ; increment the count of interrupts rcv

        jmp     DoIntMakeTheTest

;
;       Make es:bx point to the correct slot in the callback data table.
;

DoIntMakeTheCall:

;
;       Increment the recv count.  Use of the % operator above makes sure
;       that we wrap around to the begining of the array correctly.
;
;       wTempRecvCount = (vpCallbackData->wRecvCount + 1) % CALLBACK_ARGS_SIZE;
;

	mov	al,BYTE PTR es:[bx]
	inc	al
	and	ax,15
        mov     cx,ax

;
;       pArgs = &vpCallbackData->args[ vpCallbackData->wRecvCount ];
;       vpCallbackData->wRecvCount = wTempRecvCount;
;       Note that pArgs is really es:bx.
;

        mov     es,[CodeFixDS]
	les	bx,DWORD PTR es:vpCallbackData
	imul	ax,WORD PTR es:[bx],24  ;ax = wRecvCount * sizeof(CALLBACKDATA)

;
;       Note: our caller saves ALL registers.  We do not need to preserve si
;
        mov     si,bx
	add	bx,ax                   ;bx = bx + ax
	add	bx,4                    ;bx += sizeof(WORD) * 2

;
;       Set up the stack frame for DriverCallback
;
	push	WORD PTR es:[bx+6]
	push	WORD PTR es:[bx+4]
	push	WORD PTR es:[bx]
	push	WORD PTR es:[bx+8]
	push	WORD PTR es:[bx+10]
	push	WORD PTR es:[bx+14]
	push	WORD PTR es:[bx+12]
	push	WORD PTR es:[bx+18]
	push	WORD PTR es:[bx+16]
	push	WORD PTR es:[bx+22]
	push	WORD PTR es:[bx+20]

;
;       We have to set up the stack frame before incrementing wRecvCount to
;       prevent the 32 bit code from eating our slot in the buffer.
;
	mov	WORD PTR es:[si],cx      ;wRecvCount = wTempRecvCount

	call	FAR PTR DriverCallback


;
;       Reload es:bx and ax ready for the loop test
;
	mov	ax,wSendCount
        mov     es,[CodeFixDS]
	les	bx,DWORD PTR es:vpCallbackData

DoIntMakeTheTest:
	cmp	WORD PTR es:[bx],ax
	jne     DoIntMakeTheCall

cEnd    DoInt


ifdef XDEBUG
public  stack_enter_stay_here
public  stack_enter_have_stack_will_travel
public  stack_leave_abby_normal
public  stack_leave_normal
endif

;***************************************************************************;
;
;   @doc DDK MMSYSTEM
;
;   @api BOOL | DriverCallback | This function notifies a client
;     application by sending a message to a window or callback
;     function or by unblocking a task.
;
;   @parm   DWORD   | dwCallBack    | Specifies either the address of
;     a callback function, a window handle, or a task handle, depending on
;     the flags specified in the <p wFlags> parameter.
;
;   @parm   WORD    | wFlags        | Specifies how the client
;     application is notified, according to one of the following flags:
;
;   @flag   DCB_FUNCTION        | The application is notified by
;     sending a message to a callback function.  The <p dwCallback>
;     parameter specifies a procedure-instance address.
;   @flag   DCB_WINDOW          | The application is notified by
;     sending a message to a window.  The low-order word of the
;     <p dwCallback> parameter specifies a window handle.
;
;   @flag   DCB_NOSWITCH | DriverCallback should *not* switch to a new stack
;
;   @parm   WORD    | hDevice       | Specifies a handle to the device
;     associated with the notification.  This is the handle assigned by
;     MMSYSTEM when the device was opened.
;
;   @parm   WORD    | wMsg          | Specifies a message to send to the
;     application.
;
;   @parm   DWORD   | dwUser        | Specifies the DWORD of user instance
;     data supplied by the application when the device was opened.
;
;   @parm   DWORD   | dwParam1      | Specifies a message-dependent parameter.
;   @parm   DWORD   | dwParam2      | Specifies a message-dependent parameter.
;
;   @rdesc Returns TRUE if the callback was performed, else FALSE if an invalid
;     parameter was passed, or the task's message queue was full.
;
;   @comm  This function can be called at interrupt time.
;
;   The flags DCB_FUNCTION and DCB_WINDOW are equivalent to the
;   high-order word of the corresponding flags CALLBACK_FUNCTION
;   and CALLBACK_WINDOW specified when the device was opened.
;
;   If notification is done with a callback function, <p hDevice>,
;   <p wMsg>, <p dwUser>, <p dwParam1>, and <p dwParam2> are passed to
;   the callback.  If notification is done with a window, only <p wMsg>,
;   <p hDevice>, and <p dwParam1> are passed to the window.
;***************************************************************************;

        assumes ds, nothing
        assumes es, nothing

cProc DriverCallback, <FAR, PASCAL, PUBLIC>, <>

        parmD dwCallBack                ; callback procedure to call
        parmW fCallBack                 ; callback flags
        parmW hdrv                      ; handle to the driver
        parmW msg                       ; driver message
        parmD dwUser                    ; user instance data
        parmD dw1                       ; message specific
        parmD dw2                       ; message specific

cBegin
        cld                      ; lets not make any assumptions about this!!!!

;**************************************************************************-;
;   check for quick exit cases and get out fast
;**************************************************************************-;
        mov     ax,dwCallback.lo        ; check for dwCallback == NULL
        or      ax,dwCallback.hi
        jz      dcb_error_exit_now      ; if NULL get out fast

        mov     ax,fCallback            ; get flags and mask out the type bits
        test    ax,DCB_TYPEMASK
        jz      dcb_error_exit_now      ; if NULL get out fast

ifdef NEVER
;**************************************************************************-;
;   if this handle is being NUKED don't allow callbacks into the app
;
;   I won't bother with this test on WOW either.   -- StephenE 2nd Nov 1992
;**************************************************************************-;
        mov     es,[CodeFixDS]
        assumes es,DataFix
        mov     bx,hdrv
        cmp     bx,es:[hdrvDestroy]     ; same as the handle being nuked?
        je      dcb_error_exit_now      ; if yes, get out'a here
        assumes es,nothing
endif

;**************************************************************************-;
;   set up ES == SS, so we can access stack params after switching
;   stacks, NOTE!! ES:[bp+##] *must* be used to access parameters!
;**************************************************************************-;
        mov     cx,ss                   ; set ES == callers stack
        mov     es,cx                   ;   use ES to get at local vars
        assumes es,nothing

;**************************************************************************-;
;   We won't switch stacks on WOW since DPMI does this for us. Win 3.1
;   would only switch stacks in Standard mode which we no longer support.
;**************************************************************************-;

;        test    ax,DCB_NOSWITCH         ; should we switch stacks?
;        jnz     dcb_on_stack

;        call    StackEnter              ; switch to new stack

;**************************************************************************-;
;   determine the type of the callback, dwCallback is either a FARPROC, HWND
;   or HTASK depending on the value of fCallback
;**************************************************************************-;
dcb_on_stack:
                                        ;
        pushf                           ; Save the interrupt flag state
        FSTI                            ; ** Enable interrupts here **
                                        ;

;        push    ax                      ; save flags for StackLeave test

        and     ax,DCB_TYPEMASK         ; mask out the type bits

        cmp     ax,DCB_WINDOW           ; is it a window handle?
        je      dcb_post_message

        cmp     ax,DCB_TASK             ; is it a task handle?
        je      dcb_post_event

        cmp     ax,DCB_FUNCTION         ; is it a procedure?
        je      dcb_call_callback

        DOUT    <DriverCallback: Invalid flags #ax>
        xor     ax,ax
        jmp     dcb_exit

dcb_error_exit_now:
        xor     ax,ax
        jmp     dcb_exit_now

ifdef NEVER
;**************************************************************************-;
;   the Callback flags are NULL determine the callback type by the HIWORD
;   of dwCallback, if it is NULL assume it is a WINDOW otherwise it is a
;   FARPROC
;**************************************************************************-;
dcb_null_flags:
        mov     ax,es:dwCallback.hi     ; get selector of callback
        or      ax,ax
        jnz     dcb_call_callback       ; if NULL then assume it is a window
        errn$   dcb_post_message        ;   otherwise assume a FARPROC
endif

;**************************************************************************-;
;   dwCallback is a window handle, call PostMessage() to insert a message in
;   the applications message Que
;**************************************************************************-;
dcb_post_event:
        cmc
dcb_post_message:
        push    es:dwCallback.lo            ; hwnd
        push    es:msg                      ; message
        push    es:hdrv                     ; wParam = hdrv
        push    es:dw1.hi                   ; lParam = dw1
        push    es:dw1.lo

        jc      dcb_post_app_message
        call    PostMessage
        jmp     dcb_exit

;**************************************************************************-;
;   dwCallback is a task handle, call PostAppMessage() to 'wake' the task up
;**************************************************************************-;
dcb_post_app_message:
        call    PostAppMessage
        jmp     dcb_exit

;**************************************************************************-;
;   dwCallback is a callback procedure, we will call it.
;**************************************************************************-;
dcb_call_callback:
        ;
        ; is the callback a valid function?
        ;
        lar     ax,es:dwCallback.hi
        jnz     dcb_invalid_callback
        test    ax,0800H                    ; test for code/data selector
        jnz     dcb_valid_callback

dcb_invalid_callback:
ifdef MYDEBUG_RETAIL
        mov     ax,es:dwCallback.lo
        mov     dx,es:dwCallback.hi
        DOUT    <DriverCallback: Invalid callback function #dx:#ax>
        int     3
endif
        xor     ax,ax
        jmp     dcb_exit

dcb_valid_callback:
        push    es:hdrv
        push    es:msg
        push    es:dwUser.hi
        push    es:dwUser.lo
        push    es:dw1.hi
        push    es:dw1.lo
        push    es:dw2.hi
        push    es:dw2.lo
        call    es:dwCallback
        mov     ax,1
        errn$   dcb_exit

dcb_exit:
                                            ;
        popf                                ; ** restore the interrupt flag **
                                            ;

;        pop     bx                          ; restore flags
;        test    bx,DCB_NOSWITCH             ; should we switch back?
;        jnz     dcb_exit_now

;        call    StackLeave                  ; return to previous stack
        errn$   dcb_exit_now

dcb_exit_now:
cEnd

ifdef MYDEBUG
;**************************************************************************-;
;
; each mmsystem stack has a SS:SP and in MYDEBUG a CS:IP of the caller of
; StackEnter, the top of each stack looks like this.
;
;   +-------------------------------------+
;   | CS:IP of caller of StackEnter() (in MYDEBUG)
;   +-------------------------------------+
;   | SS:SP to restore
;   +-------------------------------------+
;
;**************************************************************************-;
        assumes ds,DataFix
        assumes es,nothing

        public  dump_stack_users
dump_stack_users proc near

        cmp     [gwStackSelector],0
        jne     @f
        ret

@@:     pusha
        push    es

        mov     cx,[gwStackFrames]
        mov     di,[gwStackSize]
        mov     si,[gwStackUse]
        mov     es,gwStackSelector

        DOUT    <StackUsers: Frames[#cx] Size[#di] Use[#si]>

dump_stack_loop:
        lar     ax,es:[di-4].sel
        jnz     dump_stack_next

        mov     ax,es:[di-4].off        ; get CS:IP of StackEnter caller
        mov     dx,es:[di-4].sel

        mov     si,es:[di-8].off        ; get SS:SP of StackEnter caller
        mov     bx,es:[di-8].sel

        DOUT    <StackUser #cx is CS:IP = #dx:#ax SS:SP = #bx:#si>

dump_stack_next:
        add     di,[gwStackSize]
        loop    dump_stack_loop

        pop     es
        popa
        ret

dump_stack_users endp

endif

;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | CheckThunkInit | send a message to the timer driver
;
;    @rdesc Returns 0 if successful, otherwise an error code,
;           (typically MMSYSERR_NODRIVER).
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   CheckThunkInit, <FAR, PUBLIC, PASCAL>, <>
cBegin
        mov     es,[CodeFixDS]
        assumes es,DataFix

        sub     ax,ax                           ; assume sucess
        mov     bx,WORD PTR es:[mmwow32Lib]     ; is mmwow32Lib loaded ?
        mov     cx,WORD PTR es:[mmwow32Lib+2]   ; try to load it
        or      cx,bx                           ; ThunkInit returns ax=1
        jnz     @F                              ; if it loaded OK, otherwise
        call    ThunkInit                       ; ax=MMSYSERR_NODRIVER
@@:
cEnd


;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | timeMessage | send a message to the timer driver
;
;    @parm WORD | msg | message to send
;
;    @parm DWORD | dw1 | first DWORD
;
;    @parm DWORD | dw2 | first DWORD
;
;    @rdesc Returns zero if successful, error code otherwise
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   timeMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   msg
        ParmD   dw1
        ParmD   dw2
cBegin
        mov     es,[CodeFixDS]
        assumes es,DataFix

        sub     ax,ax                           ; assume sucess
        mov     bx,WORD PTR es:[mmwow32Lib]     ; is mmwow32Lib loaded ?
        mov     cx,WORD PTR es:[mmwow32Lib+2]   ; try to load it
        or      cx,bx                           ; ThunkInit returns ax=1
        jnz     timer_have_thunks               ; if it loaded OK, otherwise
        push    es
        call    ThunkInit                       ; ax=MMSYSERR_NODRIVER
        pop     es
        or      ax,ax
        jnz     timeMessageExit

timer_have_thunks:

        push    ax                              ; uDevID
        push    ax                              ;

        push    ax                              ; Message passed
        push    msg                             ;

        push    ax                              ; dwInstance
        push    ax                              ;

        push    dw1.hi                          ; dwParam1
        push    dw1.lo                          ;

        push    dw2.hi                          ; dwParam2
        push    dw2.lo                          ;

        push    WORD PTR es:[tid32Message+2]    ; Address of function to call
        push    WORD PTR es:[tid32Message]      ;

        push    ax                              ; No directory change
        push    ax

      	call	FAR PTR MMCALLPROC32
timeMessageExit:
cEnd

       MMediaThunk    MMCALLPROC32

sEnd CodeFix

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\thunks.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  thunks.asm - Passes control to 32 bit code.
;
;
; Created:  27-09-93
; Author:   Stephen Estrop [StephenE]
;
; Copyright (c) 1993 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE   = 1

        .xlist
        include cmacros.inc
        include windows.inc
        .list

;-----------------------------------------------------------------------;
;
;-----------------------------------------------------------------------;
        externFP    MMCALLPROC32                ; in Stack.asm
        externFP    wod32Message
        externFP    wid32Message
        externFP    mod32Message
        externFP    mid32Message
        externFP    joy32Message                ; in joy.c
        externFP    aux32Message                ; in init.c
        externFP    mci32Message                ; in mci.c
        externFP    cb32                        ; in init.c
        externFP    CheckThunkInit              ; in stack.asm
        externFP    wodMapper                   ; in init.c
        externFP    widMapper                   ; in init.c

WAVE_MAPPER    equ   (-1)                       ;
;
; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".
;
LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends



createSeg WAVE, WaveSeg, word, public, CODE

sBegin  WaveSeg
        assumes cs,WaveSeg
        assumes ds,nothing
        assumes es,nothing


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func DWORD | waveOMessage | This function sends messages to the waveform
;   output device drivers.
;
; @parm HWAVE | hWave | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc waveOMessage, <NEAR, PUBLIC, PASCAL>, <>
        ParmW   hWave
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit          ; returns ax=0 if sucessful
        or      ax,ax
        jnz     waveOMessage_exit

        mov     bx,hWave                ; bx = hWave
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID


        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [wodMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [wodMapper]

        jmp     waveOMessage_exit

@@:
        sub     dx,dx                   ; dx = 0
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wod32Message.sel
        push    wod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveOMessage_exit:
cEnd


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func UINT | waveOIDMessage | This function opens a 32 bit wave device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc waveOIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveOIDMessage_exit


        mov     ax,wDeviceID
        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [wodMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    dwUser.hi
        push    dwUser.lo
        push    dw1.hi
        push    dw1.lo
        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [wodMapper]

        jmp     waveOIDMessage_exit

@@:
        sub     dx,dx
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wod32Message.sel
        push    wod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveOIDMessage_exit:
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func DWORD | waveIMessage | This function sends messages to the waveform
;   output device drivers.
;
; @parm HWAVE | hWave | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc waveIMessage, <NEAR, PUBLIC, PASCAL>, <>
        ParmW   hWave
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveIMessage_exit

        mov     bx,hWave                ; bx = hWave
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID

        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [widMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [widMapper]

        jmp     waveIMessage_exit

@@:
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wid32Message.sel
        push    wid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveIMessage_exit:
cEnd


;-----------------------------------------------------------------------;
; @doc INTERNAL  WAVE
;
; @func UINT | waveIIDMessage | This function opens a 32 bit wave device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc waveIIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     waveIIDMessage_exit

        mov     ax,wDeviceID
        cmp     ax,WAVE_MAPPER          ; Is this the wave mapper
        jnz     @f                      ; No so thunk to the 32 bit code.

        cmp     [widMapper].hi,0        ; No wave mapper loaded
        jz      @f                      ; so jump to 32 bit code

        push    ax                      ; push device id
        push    wMsg                    ; push message

        push    dwUser.hi
        push    dwUser.lo
        push    dw1.hi
        push    dw1.lo
        push    dw2.hi
        push    dw2.lo

        call    DWORD PTR [widMapper]

        jmp     waveIIDMessage_exit

@@:
        sub     dx,dx
        push    dx
        push    ax

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    wid32Message.sel
        push    wid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
waveIIDMessage_exit:
cEnd

sEnd


createSeg FIX, CodeFix, word, public, CODE

sBegin  CodeFix
        assumes cs,CodeFix
        assumes ds,nothing
        assumes es,nothing


;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func DWORD | midiOMessage | This function sends messages to the midiform
;   output device drivers.
;
; @parm HMIDI | hMidi | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc midiOMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   hMidi
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        mov     bx,hMidi                ; bx = hMidi
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mod32Message.sel
        push    mod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func DWORD | midiIMessage | This function sends messages to the midiform
;   output device drivers.
;
; @parm HMIDI | hMidi | The handle to the audio device.
;
; @parm UINT | wMsg | The message to send.
;
; @parm DWORD | dwP1 | Parameter 1.
;
; @parm DWORD | dwP2 | Parameter 2.
;
; @rdesc Returns the value returned from the thunk.
;-----------------------------------------------------------------------;
cProc midiIMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   hMidi
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        mov     bx,hMidi                ; bx = hMidi
        mov     ax,WORD PTR [bx+8]      ; ax = bx->wDeviceID
        sub     dx,dx                   ; dx = 0

        push    dx
        push    ax

        push    dx
        push    wMsg

        push    WORD PTR [bx+6]         ; push bx->dwDrvUser.hi
        push    WORD PTR [bx+4]         ; push bx->dwDrvUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mid32Message.sel
        push    mid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd
sEnd


createSeg MIDI, MidiSeg, word, public, CODE

sBegin  MidiSeg
        assumes cs,MidiSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func UINT | midiOIDMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc midiOIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        sub     dx,dx

        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mod32Message.sel
        push    mod32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
cEnd

;-----------------------------------------------------------------------;
; @doc INTERNAL  MIDI
;
; @func UINT | midiIIDMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwUser | The users private DWORD.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc midiIIDMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dwUser
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dwUser.hi
        push    dwUser.lo

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    mid32Message.sel
        push    mid32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32    ; call the 32 bit code
@@:
cEnd

sEnd


createSeg MCI, MciSeg, word, public, CODE

sBegin MciSeg
        assumes cs,MciSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; mciMessage
;
;
;-----------------------------------------------------------------------;
cProc mciMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
        ParmD   dw3
        ParmD   dw4
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wMsg

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    dw3.hi
        push    dw3.lo

        push    dw4.hi
        push    dw4.lo

        push    mci32Message.sel
        push    mci32Message.off

        push    dx
        push    1                       ; set directory change

        call    FAR PTR MMCALLPROC32    ; call the 32 bit code
@@:
cEnd
sEnd


createSeg RARE, RareSeg, word, public, CODE

sBegin  RareSeg
        assumes cs,RareSeg
        assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
; @doc INTERNAL  AUX
;
; @func UINT | auxOutMessage | This function opens a 32 bit midi device
; on behalf of a 16 bit application.
;
; @parm FARPROC | lpProc | The 32 bit function that will get called.
;
; @parm UINT | wDeviceID | Device ID to send message to.
;
; @parm UINT | wMessage | The message to send.
;
; @parm DWORD | dwParam1 | Parameter 1.
;
; @parm DWORD | dwParam2 | Parameter 2.
;
; @rdesc The return value is the low word of the returned message.
;-----------------------------------------------------------------------;
cProc auxOutMessage, <FAR, PUBLIC, PASCAL, LOADDS>, <>
        ParmW   wDeviceID
        ParmW   wMsg
        ParmD   dw1
        ParmD   dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        push    wDeviceID

        push    dx
        push    wMsg

        push    dx
        push    dx

        push    dw1.hi
        push    dw1.lo

        push    dw2.hi
        push    dw2.lo

        push    aux32Message.sel
        push    aux32Message.off

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;*****************************Private*Routine******************************\
; joyMessage
;
;
;
; History:
; 27-09-93 - StephenE - Created
;
;**************************************************************************/
cProc joyMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW hdrv,
        ParmW wMsg,
        ParmD dw1,
        ParmD dw2
cBegin
        call    CheckThunkInit
        or      ax,ax
        jnz     @F

        sub     dx,dx
        push    dx
        mov     ax,hdrv

        dec     ax                       ; uDevID
        push    ax                       ;

        push    dx                       ; uMsg
        push    wMsg                     ;

        push    dx                       ; dummy dwInstance
        push    dx                       ;

        push    dw1.hi                   ; dwParam1
        push    dw1.lo                   ;

        push    dw2.hi                   ; dwParam2
        push    dw2.lo                   ;

        push    joy32Message.sel         ; Address of function to be called
        push    joy32Message.off         ;

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
@@:
cEnd

;******************************Public*Routine******************************\
; Notify_Callback_Data
;
;
;
; History:
; 27-09-93 - StephenE - Created
;
;**************************************************************************/
cProc Notify_Callback_Data, <FAR, PUBLIC, PASCAL>, <>
        ParmD CallbackData
cBegin
        sub     dx,dx

        push    dx                       ; Dummy uDevId
        push    dx                       ;

        push    dx                       ; Dummy uMsg
        push    dx                       ;

        push    dx                       ; Dummy dwInstance
        push    dx                       ;

        push    dx                       ; Dummy dwParam1
        push    dx                       ;

        push    CallbackData.hi          ; Real dwParam2
        push    CallbackData.lo          ;

        push    cb32.sel                 ; Address of function to be called
        push    cb32.off                 ;

        push    dx
        push    dx                       ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code
cEnd

sEnd

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\task.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:   task.c - support for task creation and blocking

   Version: 1.00

   Date:    05-Mar-1990

   Author:  ROBWI

------------------------------------------------------------------------------

   Change log:

      DATE        REV            DESCRIPTION
   -----------   ----- -----------------------------------------------------------
   05-MAR-1990   ROBWI First Version - APIs and structures
   18-APR-1990   ROBWI Ported from Resman to mmsystem
   25-JUN-1990   ROBWI Added mmTaskYield
   07-JUL-1991   CJP   Modified to work with new stack switcher code

*****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmsysi.h"
#include "mmddk.h"
#include "mmtask\mmtask.h"

UINT  FAR PASCAL BWinExec(LPSTR lpModuleName, UINT wCmdShow, LPVOID lpParameters);

/***************************************************************************
 *
 * @doc     DDK    MMSYSTEM    TASK
 *
 * @api     UINT | mmTaskCreate | This function creates a new task.
 * 
 *   @parm    LPTASKCALLBACK | lpfn |  Points to a program supplied
 *            function and represents the starting address of the new
 *            task.
 *
 *   @parm    HTASK FAR * | lph | Points to the variable that receives the
 *            task identifier. This may be NULL in some versions. This
 *            is not an error it simply means that the system could not
 *            determine the task handle of the newly created task.
 *
 *   @parm    DWORD | dwStack | Specifies the size of the stack to be
 *            provided to the task.
 *
 *   @parm    DWORD | dwInst | DWORD of instance data to pass to the task
 *            routine.
 *
 *   @rdesc   Returns zero if the function is successful. Otherwise it
 *            returns an error value which may be one of the following:
 *
 *     @flag    TASKERR_NOTASKSUPPORT | Task support is not available.
 *     @flag    TASKERR_OUTOFMEMORY | Not enough memory to create task.
 *            
 * @comm    When a mmsystem task is created, the system will make a far
 *          call to the program-supplied function whose address is
 *          specified by the lpfn parameter. This function may include
 *          local variables and may call other functions as long as
 *          the stack has sufficient space.
 *
 *          The task terminates when it returns.
 *
 * @xref    mmTaskSignal mmTaskBlock
 *
 ***************************************************************************/

UINT WINAPI mmTaskCreate(LPTASKCALLBACK lpfn, HTASK FAR * lph, DWORD dwInst)
{
    MMTaskStruct     TaskStruct;
    char             szName[20];
    UINT             wRes;
    HTASK            hTask;

    /*
        create another app. so that we can run the stream outside of
        the context of the app. 
    */

    if (!LoadString(ghInst, IDS_TASKSTUB, szName, sizeof(szName)))
        return TASKERR_NOTASKSUPPORT;

    TaskStruct.cb = sizeof(TaskStruct);
    TaskStruct.lpfn = lpfn;
    TaskStruct.dwInst = dwInst;
    TaskStruct.dwStack = 0L;

    wRes = BWinExec(szName, SW_SHOWNOACTIVATE, &TaskStruct);

    if (wRes > 32)
    {
        hTask = wRes;
        wRes = MMSYSERR_NOERROR;
    }
    else if (wRes == 0)
    {
        wRes = TASKERR_OUTOFMEMORY;
        hTask = NULL;
    }
    else
    {
        wRes  = TASKERR_NOTASKSUPPORT;
        hTask = NULL;
    }
    
    if (lph)
        *lph = hTask;

    DPRINTF2("mmTaskCreate: hTask = %04X, wErr = %04X\r\n", hTask, wRes);

    return wRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\thunks.h ===
/******************************Module*Header*******************************\
* Module Name: thunks.h
*
*  Function prototypes for Multi-Media thunk functions
*
*
* Created: 27-09-93
* Author:  Stephen Estrop [StephenE]
*
* Copyright (c) 1993 Microsoft Corporation
\**************************************************************************/
#include <wowmmcb.h>

extern DWORD FAR PASCAL mmwow32Lib;     // in stack.asm

/* -------------------------------------------------------------------------
** Wave stuff
** -------------------------------------------------------------------------
*/
#ifndef MMNOWAVE
extern DWORD NEAR PASCAL
waveOMessage(
    HWAVE hWave,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern DWORD NEAR PASCAL
waveIMessage(
    HWAVE hWave,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
waveOIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );

extern UINT FAR PASCAL
waveIIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
#endif

/* -------------------------------------------------------------------------
** midi stuff
** -------------------------------------------------------------------------
*/
#ifndef MMNOWAVE
extern DWORD FAR PASCAL
midiOMessage(
    HMIDI hMidi,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
midiOIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
extern DWORD FAR PASCAL
midiIMessage(
    HMIDI hMidi,
    UINT msg,
    DWORD dwP1,
    DWORD dwP2
    );

extern UINT FAR PASCAL
midiIIDMessage(
    UINT wDeviceID,
    UINT wMessage,
    DWORD dwUser,
    DWORD dwParam1,
    DWORD dwParam2
    );
#endif

/* -------------------------------------------------------------------------
** Joystick stuff
** -------------------------------------------------------------------------
*/
typedef DWORD (FAR PASCAL *JOYMESSAGEPROC)( HDRVR, UINT, DWORD, DWORD );
extern UINT FAR PASCAL
joyMessage(
    HDRVR hdrv,
    UINT msg,
    LPARAM dw1,
   LPARAM dw2
    );

/* -------------------------------------------------------------------------
** Timer stuff
** -------------------------------------------------------------------------
*/
typedef LRESULT (FAR PASCAL *TIDMESSAGEPROC)( UINT, LPARAM, LPARAM );
extern TIDMESSAGEPROC FAR PASCAL tid32Message;              // stack.asm
extern DWORD FAR PASCAL                                     // stack.asm
timeMessage(
    UINT msg,
    LPARAM dw1,
    LPARAM dw2
    );


/* -------------------------------------------------------------------------
** MCI Stuff
** -------------------------------------------------------------------------
*/
typedef DWORD (CALLBACK MCIMESSAGE)( DWORD, DWORD, DWORD, DWORD, DWORD );
typedef MCIMESSAGE FAR *LPMCIMESSAGE;
extern LPMCIMESSAGE PASCAL mci32Message;

extern DWORD FAR PASCAL
mciMessage(
    UINT wMsg,
    DWORD dwP1,
    DWORD dwP2,
    DWORD dwP3,
    DWORD dwP4
    );

#define THUNK_MCI_SENDCOMMAND                0x0001
#define THUNK_MCI_SENDSTRING                 0x0002
#define THUNK_MCI_GETDEVICEID                0x0003
#define THUNK_MCI_GETDEVIDFROMELEMID         0x0004
#define THUNK_MCI_GETERRORSTRING             0x0005
#define THUNK_MCI_EXECUTE                    0x0006
#define THUNK_MCI_SETYIELDPROC               0x0007
#define THUNK_MCI_GETYIELDPROC               0x0008
#define THUNK_MCI_GETCREATORTASK             0x0009
#define THUNK_TIMEGETTIME                    0x000A
#define THUNK_APP_EXIT                       0x000B
#define THUNK_MCI_ALLOCATE_NODE              0x000C
#define THUNK_MCI_FREE_NODE                  0x000D

/* -------------------------------------------------------------------------
** Interrupt callback stuff
** -------------------------------------------------------------------------
*/
typedef VOID (CALLBACK CB32)( VPCALLBACK_DATA vpCallbackData );
typedef CB32 FAR *  LPCB32;
extern VPCALLBACK_DATA FAR PASCAL   vpCallbackData;          // in STACK.ASM
extern HGLOBAL         FAR PASCAL   hGlobal;                 // in STACK.ASM
int FAR PASCAL
InstallInterruptHandler(
    void
    );

int FAR PASCAL
DeInstallInterruptHandler(
    void
    );

VOID FAR PASCAL
Notify_Callback_Data(
    VPCALLBACK_DATA vpCallbackData
    );

BOOL FAR  PASCAL
    StackInit(
    void
    );

BOOL NEAR PASCAL
StackTerminate(
    void
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\timea.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  TIMEA.ASM - Some time functions
;
; Copyright (c) 1984-1991 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE	= 1

	.xlist
	include cmacros.inc
        include windows.inc
	include mmsystem.inc
	include mmddk.inc
        .list

        externFP        DefTimerProc                ; in TIME.C
        externFP        StackInit                   ; in INIT.C
        externFP        CheckThunkInit              ; in stack.asm
        externFP        MMCALLPROC32                ; in Stack.asm

;-----------------------------------------------------------------------;

createSeg FIX,   CodeFix, word, public, CODE
createSeg INTDS, DataFix, byte, public, DATA

sBegin  DataFix
        public lpTimeMsgProc
        public hTimeDrv

        lpTimeMsgProc   dd       DefTimerProc       ; timer driver entry point
        hTimeDrv        dw       0                  ; driver handle for timer

        externW         gwStackSize                 ; in STACK.ASM
        externD         tid32Message                ; in Stack.asm
sEnd

sBegin  CodeFix
        assumes cs,CodeFix
	assumes ds,nothing
        assumes es,nothing

        externW CodeFixDS                           ; in STACK.ASM
        externW CodeFixWinFlags

;-----------------------------------------------------------------------;
;
;    @doc EXTERNAL
;
;    @api WORD | timeBeginPeriod | This function sets the minimum (lowest
;    number of milliseconds) timer resolution that an application or
;    driver is going to use. Call this function immediately before starting
;    to use timer-event services, and call <f timeEndPeriod> immediately
;    after finishing with the timer-event services.
;
;    @parm WORD | wPeriod | Specifies the minimum timer-event resolution
;    that the application or driver will use.
;
;    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
;    <p wPeriod> resolution value is out of range.
;
;    @xref timeEndPeriod timeSetEvent
;
;    @comm For each call to <f timeBeginPeriod>, you must call
;    <f timeEndPeriod> with a matching <p wPeriod> value.
;    An application or driver can make multiple calls to <f timeBeginPeriod>,
;    as long as each <f timeBeginPeriod> call is matched with a
;    <f timeEndPeriod> call.
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc	timeBeginPeriod, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	wPeriod
cBegin <nogen>
;
; Below is a hack to knobble the minimum period that we support
; on WOW.  6 ms is about all that a 486dx can cope with.
;
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+6]
        cmp     ax,5

        ja      @f
        mov     word ptr [bp+6],6
@@:
        pop     bp

;
; start of original code.
;
        mov     bx, TDD_BEGINMINPERIOD
        jmp     short timeMessageWord
cEnd <nogen>

;-----------------------------------------------------------------------;
;
;    @doc EXTERNAL
;
;    @api WORD | timeEndPeriod | This function clears a previously set
;    minimum (lowest number of milliseconds) timer resolution that an
;    application or driver is going to use. Call this function
;    immediately after using timer event services.
;
;    @parm WORD | wPeriod | Specifies the minimum timer-event resolution
;    value specified in the previous call to <f timeBeginPeriod>.
;
;    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
;    <p wPeriod> resolution value is out of range.
;
;    @xref timeBeginPeriod timeSetEvent
;
;    @comm For each call to <f timeBeginPeriod>, you must call
;    <f timeEndPeriod> with a matching <p wPeriod> value.
;    An application or driver can make multiple calls to <f timeBeginPeriod>,
;    as long as each <f timeBeginPeriod> call is matched with a
;    <f timeEndPeriod> call.
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc	timeEndPeriod, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	wPeriod
cBegin <nogen>
;
; Below is a hack to knobble the minimum period that we support
; on WOW.  6 ms is about all that a 486dx can cope with.
;
        push    bp
        mov     bp,sp
        mov     ax,word ptr [bp+6]
        cmp     ax,5

        ja      @f
        mov     word ptr [bp+6],6
@@:
        pop     bp

;
; start of original code.
;
        mov     bx, TDD_ENDMINPERIOD
        jmp     short timeMessageWord
cEnd <nogen>

;-----------------------------------------------------------------------;
;
;    @doc EXTERNAL
;
;    @api WORD | timeKillEvent | This functions destroys a specified timer
;    callback event.
;
;    @parm WORD | wID | Identifies the event to be destroyed.
;
;    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the
;    specified timer event does not exist.
;
;    @comm The timer event ID specified by <p wID> must be an ID
;        returned by <f timeSetEvent>.
;
;    @xref  timeSetEvent
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc	timeKillEvent, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	wId
cBegin <nogen>
        mov     bx, TDD_KILLTIMEREVENT
        errn$   timeMessageWord
cEnd <nogen>

;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | timeMessageWord | send a message to the timer driver
;
;    @reg  bx | message to send to driver
;
;    @parm WORD | w | WORD to send to driver
;
;    @rdesc Returns zero if successful, error code otherwise
;
;-----------------------------------------------------------------------;
        assumes ds,nothing
        assumes es,nothing

cProc   timeMessageWord, <FAR, PUBLIC, PASCAL>, <>
;       ParmW   w
cBegin <nogen>
        pop     ax          ; DX:AX = return addr.
        pop     dx
	pop	cx	    ; CX = LOWORD(dw1)

        mov     es, [CodeFixDS]
        assumes es, DataFix

	push	0			; 0
	push	0			; 0
        push    es:[hTimeDrv]
	push	bx			; Message
	xor	bx,bx
        push    bx                      ; 0
	push	cx			; wParam
        push    bx                      ; 0
        push    bx                      ; 0
        push    dx                      ; Return address
	push	ax
        jmp     DWORD PTR es:[lpTimeMsgProc]

cEnd <nogen>

;-----------------------------------------------------------------------;
;
;    @doc EXTERNAL
;
;    @api DWORD | timeGetTime | This function retrieves the system time
;    in milliseconds.  The system time is the time elapsed since
;    Windows was started.
;
;    @rdesc The return value is the system time in milliseconds.
;
;    @comm The only difference between this function and
;        the <f timeGetSystemTime> function is <f timeGetSystemTime>
;        uses the standard multimedia time structure <t MMTIME> to return
;        the system time.  The <f timeGetTime> function has less overhead than
;        <f timeGetSystemTime>.
;
;    @xref timeGetSystemTime
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
	assumes es,nothing

cProc	timeGetTime, <FAR, PUBLIC, PASCAL>, <>
cBegin
        call    CheckThunkInit  ; changes es to point to fixed data seg
        or      ax,ax
        jnz     @F

        sub     dx,dx

        push    dx              ; api encoded number
        push    0Ah             ; see THUNK_TIMEGETTIME in thunks.h

        push    dx              ; Dummy dw1
        push    dx              ;

        push    dx              ; Dummy dw2
        push    dx              ;

        push    dx              ; Dummy dw3
        push    dx              ;

        push    dx              ; Dummy dw4
        push    dx              ;

        push    es:tid32Message.sel ; Address of function to be called
        push    es:tid32Message.off ;

        push    dx
        push    dx              ; no directory change

        call    FAR PTR MMCALLPROC32     ; call the 32 bit code

@@:
cEnd


;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api void | timeStackInit | in 286p mode init the stacks when
;           timeSetEvent() is called for the first time.
;
;    @xref timeSetEvent
;
;    @rdesc none
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   timeStackInit, <NEAR, PUBLIC, PASCAL>, <>
cBegin
        test    cs:[CodeFixWinFlags], WF_WIN386
        jnz     timeStackInitExit

        mov     es,[CodeFixDS]
        assumes es,DataFix

        mov     ax,es:[gwStackSize]
        or      ax,ax
        jnz     timeStackInitExit

        push    ds                      ; set DS = DGROUP
        mov     ax,DGROUP
        mov     ds,ax
        cCall   StackInit
        pop     ds

timeStackInitExit:
cEnd

;-----------------------------------------------------------------------;
;
;    @doc INTERNAL
;
;    @api DWORD | timeMessage | send a message to the timer driver
;
;    @parm WORD | msg | message to send
;
;    @parm DWORD | dw1 | first DWORD
;
;    @parm DWORD | dw2 | first DWORD
;
;    @rdesc Returns zero if successful, error code otherwise
;
;-----------------------------------------------------------------------;
	assumes ds,nothing
        assumes es,nothing

cProc   timeMessage, <FAR, PUBLIC, PASCAL>, <>
        ParmW   msg
        ParmD   dw1
        ParmD   dw2
cBegin
        mov     es,[CodeFixDS]
        assumes es,DataFix

        xor     ax,ax
        push    ax                      ; dwDriverId
        push    ax
        push    es:[hTimeDrv]
        push    msg                     ; Message passed
        push    dw1.hi
        push    dw1.lo
        push    dw2.hi
        push    dw2.lo
        call    DWORD PTR es:[lpTimeMsgProc]

timeMessageExit:
cEnd

;-----------------------------------------------------------------------;

sEnd CodeFix

;-----------------------------------------------------------------------;

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\time.c ===
/******************************************************************************

   Copyright (C) Microsoft Corporation 1985-1991. All rights reserved.

   Title:   TIME.C : MMSYSTEM TIMER API

   Version: 1.00

*****************************************************************************/

//
//  ***DANGER WARNING****
//
//  none of these functions in this file need the default data segment
//  so we undefine BUILDDLL, if you write code in this file that needs
//  DS == DGROUP be warned!
//
//  NOTE: most of this code is interupt time enterable, so we don't want
//  it touching DGROUP anyway!
//
#undef BUILDDLL

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "drvr.h"
#include "thunks.h"


#define MIN_RES     1
#define MIN_DELAY   6

//
//  Define moveable code for timer interface.
//
#pragma alloc_text( RARE, timeGetDevCaps )

extern SZCODE  szTimerDrv[];    // see init.c

DWORD dwLastGetTime = 0;        // last TimeGetTime return value can be bigger than system TimeGetTime
DWORD dwRealLastGetTime = 0;    // last system TimeGetTime return value
DWORD pfnDelayTimeGetTime = 0;  // 32-bit function that sleeps for 1ms and returns if TimeGetTime flag applied 
                                // look in timeTimeGetTime and WOWDelayTimeGetTime in wow32                             
//
//  Define the init code for this file.
//
#pragma alloc_text( INIT, TimeInit )


/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeGetSystemTime | This function retrieves the system time
    in milliseconds.  The system time is the time elapsed since
    Windows was started.

    @parm LPMMTIME | lpTime | Specifies a far pointer to an <t MMTIME> data
    structure.

    @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.

    @rdesc Returns zero.
    The system time is returned in the <e MMTIME.ms> field of the <t MMTIME>
    structure.

    @comm The time is always returned in milliseconds.

    @xref timeGetTime
****************************************************************************/
UINT WINAPI
timeGetSystemTime(
    LPMMTIME lpTime,
    UINT wSize
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    if (wSize < sizeof(MMTIME))
        return TIMERR_STRUCT;

    lpTime->u.ms  = timeGetTime();
    lpTime->wType = TIME_MS;

    return TIMERR_NOERROR;
}


/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeSetEvent | This function sets up a timed callback event.
    The event can be a one-time event or a periodic event.  Once activated,
    the event calls the specified callback function.

    @parm UINT | wDelay | Specifies the event period in milliseconds.
    If the delay is less than the minimum period supported by the timer,
    or greater than the maximum period supported by the timer, the
    function returns an error.

    @parm UINT | wResolution | Specifies the accuracy of the delay in
    milliseconds. The resolution of the timer event increases with
    smaller <p wResolution> values. To reduce system overhead, use
    the maximum <p wResolution> value appropriate for your application.

    @parm LPTIMECALLBACK | lpFunction | Specifies the procedure address of
    a callback function that is called once upon expiration of a one-shot
    event or periodically upon expiration of periodic events.

    @parm DWORD | dwUser | Contains user-supplied callback data.

    @parm UINT | wFlags | Specifies the type of timer event, using one of
    the following flags:

    @flag TIME_ONESHOT | Event occurs once, after <p wPeriod> milliseconds.

    @flag TIME_PERIODIC | Event occurs every <p wPeriod> milliseconds.

    @rdesc Returns an ID code that identifies the timer event. Returns
    NULL if the timer event was not created. The ID code is also passed to
        the callback function.

    @comm Using this function to generate a high-frequency periodic-delay
    event (with a period less than 10 milliseconds) can consume a
        significant portion of the system CPU bandwidth.  Any call to
    <f timeSetEvent> for a periodic-delay timer
    must be paired with a call to <f timeKillEvent>.

    The callback function must reside in a DLL.  You don't have to use
    <f MakeProcInstance> to get a procedure-instance address for the callback
    function.

    @cb void CALLBACK | TimeFunc | <f TimeFunc> is a placeholder for the
    application-supplied function name.  The actual name must be exported by
    including it in the EXPORTS statement of the module-definition file for
    the DLL.

    @parm UINT | wID | The ID of the timer event.  This is the ID returned
       by <f timeSetEvent>.

    @parm UINT | wMsg | Not used.

    @parm DWORD | dwUser | User instance data supplied to the <p dwUser>
    parameter of <f timeSetEvent>.

    @parm DWORD | dw1 | Not used.

    @parm DWORD | dw2 | Not used.

    @comm Because the callback is accessed at interrupt time, it must
    reside in a DLL, and its code segment must be specified as FIXED
    in the module-definition file for the DLL.  Any data that the
    callback accesses must be in a FIXED data segment as well.
    The callback may not make any system calls except for <f PostMessage>,
    <f timeGetSystemTime>, <f timeGetTime>, <f timeSetEvent>,
    <f timeKillEvent>, <f midiOutShortMsg>,
    <f midiOutLongMsg>, and <f OutputDebugStr>.

    @xref timeKillEvent timeBeginPeriod timeEndPeriod

****************************************************************************/
UINT WINAPI
timeSetEvent(
    UINT wDelay,
    UINT wResolution,
    LPTIMECALLBACK lpFunction,
    DWORD dwUser,
    UINT wFlags
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    TIMEREVENT timerEvent;

    V_TCALLBACK(lpFunction, MMSYSERR_INVALPARAM);

    //
    // the first time this is called init the stacks
    // !!!this assumes the first caller will not be at interupt time!!
    //
//  if (!(WinFlags & WF_ENHANCED))
//      timeStackInit();

    wDelay = max( MIN_DELAY, wDelay );
    wResolution = max( MIN_RES, wResolution );

    timerEvent.wDelay = wDelay;
    timerEvent.wResolution = wResolution;
    timerEvent.lpFunction = lpFunction;
    timerEvent.dwUser = dwUser;  
    timerEvent.wFlags = wFlags;

    return (UINT)timeMessage( TDD_SETTIMEREVENT, (LPARAM)(LPVOID)&timerEvent,
                              (LPARAM)GetCurrentTask() );
}



/****************************************************************************

    @doc EXTERNAL

    @api UINT | timeGetDevCaps | This function queries the timer device to
    determine its capabilities.

    @parm LPTIMECAPS | lpTimeCaps | Specifies a far pointer to a
        <t TIMECAPS> structure.  This structure is filled with information
        about the capabilities of the timer device.

    @parm UINT | wSize | Specifies the size of the <t TIMECAPS> structure.

    @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if it fails
    to return the timer device capabilities.

****************************************************************************/
UINT WINAPI
timeGetDevCaps(
    LPTIMECAPS lpTimeCaps,
    UINT wSize
    )
{
    //
    // !!!WARNING DS is not setup right!!! see above
    //
    return (UINT)timeMessage( TDD_GETDEVCAPS, (LPARAM)lpTimeCaps,
                              (LPARAM)(DWORD)wSize);
}



/******************************Public*Routine******************************\
*  timeBeginPeriod
*
*  @doc EXTERNAL
*
*  @api WORD | timeBeginPeriod | This function sets the minimum (lowest
*  number of milliseconds) timer resolution that an application or
*  driver is going to use. Call this function immediately before starting
*  to use timer-event services, and call <f timeEndPeriod> immediately
*  after finishing with the timer-event services.
*
*  @parm WORD | wPeriod | Specifies the minimum timer-event resolution
*  that the application or driver will use.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
*  <p wPeriod> resolution value is out of range.
*
*  @xref timeEndPeriod timeSetEvent
*
*  @comm For each call to <f timeBeginPeriod>, you must call
*  <f timeEndPeriod> with a matching <p wPeriod> value.
*  An application or driver can make multiple calls to <f timeBeginPeriod>,
*  as long as each <f timeBeginPeriod> call is matched with a
*  <f timeEndPeriod> call.
*
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeBeginPeriod(
    UINT uPeriod
    )
{
    uPeriod = max( MIN_RES, uPeriod );
    return (UINT)timeMessage( TDD_BEGINMINPERIOD, (LPARAM)uPeriod, 0L );
}



/******************************Public*Routine******************************\
*  timeEndPeriod
*
*  @doc EXTERNAL
*
*  @api WORD | timeEndPeriod | This function clears a previously set
*  minimum (lowest number of milliseconds) timer resolution that an
*  application or driver is going to use. Call this function
*  immediately after using timer event services.
*
*  @parm WORD | wPeriod | Specifies the minimum timer-event resolution
*  value specified in the previous call to <f timeBeginPeriod>.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the specified
*  <p wPeriod> resolution value is out of range.
*
*  @xref timeBeginPeriod timeSetEvent
*
*  @comm For each call to <f timeBeginPeriod>, you must call
*  <f timeEndPeriod> with a matching <p wPeriod> value.
*  An application or driver can make multiple calls to <f timeBeginPeriod>,
*  as long as each <f timeBeginPeriod> call is matched with a
*  <f timeEndPeriod> call.
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeEndPeriod(
    UINT uPeriod
    )
{
    uPeriod = max( MIN_RES, uPeriod );
    return (UINT)timeMessage( TDD_ENDMINPERIOD, (LPARAM)uPeriod, 0L );
}



/******************************Public*Routine******************************\
*
*  timeKillEvent
*
*  @doc EXTERNAL
*
*  @api WORD | timeKillEvent | This functions destroys a specified timer
*  callback event.
*
*  @parm WORD | wID | Identifies the event to be destroyed.
*
*  @rdesc Returns zero if successful. Returns TIMERR_NOCANDO if the
*  specified timer event does not exist.
*
*  @comm The timer event ID specified by <p wID> must be an ID
*      returned by <f timeSetEvent>.
*
*  @xref  timeSetEvent
*
*
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
UINT WINAPI
timeKillEvent(
    UINT wID
    )
{
    if ( 0 == wID ) {
        return 0;
    }
    return (UINT)timeMessage( TDD_KILLTIMEREVENT, (LPARAM)wID, 0L );
}

/******************************Public*Routine******************************\
* timeGetTime
*
* @doc EXTERNAL
*
* @api DWORD | timeGetTime | This function retrieves the system time
* in milliseconds.  The system time is the time elapsed since
* Windows was started.
*
* @rdesc The return value is the system time in milliseconds.
*
* @comm The only difference between this function and
*     the <f timeGetSystemTime> function is <f timeGetSystemTime>
*     uses the standard multimedia time structure <t MMTIME> to return
*     the system time.  The <f timeGetTime> function has less overhead than
*     <f timeGetSystemTime>.
*
* @xref timeGetSystemTime
*
*
* @comment: on faster machines timeGetTime can return the same value
* and some apps will take diff (0) to divide and fault  
* to prevent that call DelayTimeGetTime which will check if it is one
* of the known apps that do that and sleep if necessary 
*
* History:
* dd-mm-93 - StephenE - Created
*
\**************************************************************************/
DWORD WINAPI
timeGetTime(
    void
    )
{
    DWORD  dwGetTime;
    DWORD  bDelay = 0;

    if (pfnDelayTimeGetTime == 0) {
        DWORD hmodWow32;
        hmodWow32 = LoadLibraryEx32W("wow32.dll", 0, 0);
        pfnDelayTimeGetTime = GetProcAddress32W(hmodWow32, "WOWDelayTimeGetTime");
    }

RepeatTGT:
    dwGetTime = timeMessage( TDD_GETSYSTEMTIME, 0L, 0L );
    
    // check if it wrapped around
    if (dwGetTime < dwRealLastGetTime) {
        dwLastGetTime = dwRealLastGetTime = dwGetTime;
        return dwGetTime;
    }
    dwRealLastGetTime = dwGetTime;
    
    if (dwGetTime == dwLastGetTime) {
        if (!bDelay) {
                      
            bDelay = (DWORD) CallProc32W((LPVOID)pfnDelayTimeGetTime,(DWORD)0,(DWORD)0);        
            if(bDelay) {
               goto RepeatTGT;
            }
        }
        else {
            dwGetTime = ++dwLastGetTime;
        }
    } 
    dwLastGetTime = dwGetTime;
    return dwGetTime;
}


/****************************************************************************

    @doc INTERNAL

    @api BOOL | TimeInit | This function initialises the timer services.

    @rdesc The return value is TRUE if the services are initialised, FALSE
        if an error occurs.

    @comm it is not a FATAL error if a timer driver is not installed, this
          routine will allways return TRUE

****************************************************************************/
BOOL NEAR PASCAL TimeInit(void)
{
    OpenDriver(szTimerDrv, NULL, 0L) ;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\taska.asm ===
page    ,132
;-----------------------------Module-Header-----------------------------;
; Module Name:  TASKA.ASM - Some task functions
;
; Copyright (c) 1984-1991 Microsoft Corporation
;
;-----------------------------------------------------------------------;

        ?PLM    = 1
        ?WIN    = 0
        PMODE	= 1

	.xlist
	include cmacros.inc
        include windows.inc
        include mmsystem.inc
        .list

	externFP	Yield
	externFP	GetCurrentTask
	externFP	PostAppMessage
	externFP	PostMessage
        externFP        PeekMessage
	externFP	GetMessage
	externFP	DispatchMessage
	externFP	TranslateMessage

ifndef SEGNAME
	SEGNAME equ <_TEXT>
endif

;-----------------------------------------------------------------------;

createSeg %SEGNAME, CodeSeg, word, public, CODE

sBegin  CodeSeg
	assumes cs,CodeSeg
	assumes ds,nothing
	assumes es,nothing

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     void | mmTaskYield | This function causes the current task
;          to yield.
;
; @comm    For predictable results and future compatibility, use this
;          function rather than <f Yield> or the undocumented Kernel yield
;          function to yield within a task created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc   mmTaskYield, <FAR, PUBLIC, PASCAL>, <>
	LocalV	msg, %(SIZE MSGSTRUCT)
cBegin
        ;
        ;   we need to call PeekMessage() so ScanSysQue gets called
        ;   and USER gets the mouse/keyboard input right
        ;
        ;   PeekMessage() may not Yield if there is a message in the
        ;   Queue so we yield if it did not.
        ;

        lea     ax, msg
        cCall   PeekMessage, <ss, ax, NULL, 0, 0, PM_NOREMOVE>
        or      ax,ax
        jz      mmTaskYieldExit

        cCall   Yield           ; PeekMessage() did not yield, so yield

mmTaskYieldExit:
cEnd

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     HTASK | mmGetCurrentTask |  This function returns the
;          handle of the currently executing task created with
;          <f mmTaskCreate>.
;
; @rdesc   Returns a task handle. For predictable results and future
;          compatibility, use this function rather than <f GetCurrentTask>
;          to get the task handle of a task created with <f mmTaskCreate>.
;
; @xref    mmTaskCreate
;
;-----------------------------------------------------------------------;
cProc	mmGetCurrentTask, <FAR, PUBLIC, PASCAL>, <>
cBegin <nogen>
	jmp	FAR PTR GetCurrentTask	; Jump directly to avoid returning to here
cEnd <nogen>

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     UINT | mmTaskBlock |  This function blocks the current
;          task context if its event count is 0.
;
;   @parm  HTASK | hTask | Task handle of the current task. For predictable
;          results, get the task handle from <f mmGetCurrentTask>.
;
; @xref    mmTaskSignal mmTaskCreate
;
; @comm    WARNING : For predictable results, must only be called from a
;          task created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc	mmTaskBlock, <FAR, PUBLIC, PASCAL, NODATA>, <>
	ParmW	hTask
	LocalV	msg, %(SIZE MSGSTRUCT)
cBegin

mmTaskBlock_GetMessage:
	lea	ax, msg
	cCall	GetMessage, <ss, ax, NULL, 0, 0>; Retrieve any message for task
	cmp	msg.msHWND, 0			; Message sent to a window?
	je	mmTaskBlock_CheckMessage	; If so, dispatch it
	lea	ax, msg
        cCall   TranslateMessage, <ss, ax>      ; Probably a TaskMan message
	lea	ax, msg
        cCall   DispatchMessage, <ss, ax>
        jmp     mmTaskBlock_GetMessage

;
;   we got a message, wake up on any message >= WM_MM_RESERVED_FIRST
;
mmTaskBlock_CheckMessage:
        mov     ax,msg.msMESSAGE
        cmp     ax,WM_MM_RESERVED_FIRST
        jb      mmTaskBlock_GetMessage
cEnd

sEnd

;-----------------------------------------------------------------------;

createSeg FIX, FixSeg, word, public, CODE

sBegin	FixSeg
	assumes cs,FixSeg
	assumes ds,nothing
        assumes es,nothing

;-----------------------------------------------------------------------;
;
; @doc     DDK    MMSYSTEM    TASK
;
; @api     BOOL | mmTaskSignal |  This function signals the specified
;          task, incrementing its event count and unblocking
;          it.
;
; @parm    HTASK | hTask | Task handle. For predictable results, get the
;          task handle from <f mmGetCurrentTask>.
;
; @rdesc   Returns TRUE if the signal was sent, else FALSE if the message
;          queue was full.
;
; @xref    mmTaskBlock  mmTaskCreate
;
; @comm    Must be callable at interrupt time! WARNING : For
;          predictable results, must only be called from a task
;          created with <f mmTaskCreate>.
;
;-----------------------------------------------------------------------;
cProc	mmTaskSignal, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	hTask
cBegin <nogen>
	pop	bx			; Fetch the return address
	pop	dx
	push	WM_USER			; Message
	xor	ax, ax
	push	ax			; wParam
	push	ax			; lParam
	push	ax
	push	dx			; Put return address back
	push	bx
	jmp	FAR PTR PostAppMessage	; Jump directly to avoid returning to here
cEnd <nogen>

;-----------------------------------------------------------------------;
;
; @doc     DDK MCI
; @api     BOOL | mciDriverNotify | Used by a driver to send
;          a notification message
;
; @parm    HWND | hwndCallback | The window to notify
;
; @parm    UINT | wDeviceID | The device ID which triggered the callback
;
; @parm    UINT | wStatus | The status of the callback.  May be one of
;          MCI_NOTIFY_SUCCESSFUL or MCI_NOTIFY_SUPERSEDED or MCI_NOTIFY_ABORTED
;          or MCI_NOTIFY_FAILURE
;
; @rdesc   Returns TRUE if notify was successfully sent, FALSE if the
;          application's message queue was full.
;
; @comm    This function is callable at interrupt time.
;
;-----------------------------------------------------------------------;

cProc	mciDriverNotify, <FAR, PUBLIC, PASCAL>, <>
;	ParmW	hwndCallback
;	ParmW	wDeviceID
;	ParmW	wStatus
cBegin <nogen>
	pop	bx			; Fetch the return address
	pop	dx
	pop	ax			; Fetch wStatus
	pop	cx			; Fetch wDeviceID
	push	MM_MCINOTIFY		; Message
	push	ax			; wParam == wStatus
	push	0			; HIWORD of lParam
	push	cx			; LOWORD of lParam == wDeviceID
	push	dx			; Put return address back
	push	bx
	jmp	FAR PTR PostMessage	; Jump directly to avoid returning to here
cEnd <nogen>

sEnd

;-----------------------------------------------------------------------;

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\usa\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH)
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmtask\mmtask.h ===
/*****************************************************************************

   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.

   Title:      mmtask.h - header file for mmtask app!

   Version:    1.00

   Date:       12-Mar-1990

   Author:     ROBWI

-----------------------------------------------------------------------------

   Change log:

      DATE     REV            DESCRIPTION
   ----------- ---   --------------------------------------------------------
   12-Mar-1990 ROBWI First Version 
   18-Apr-1990 ROBWI Moved to mmtask

****************************************************************************/

/* 
   The mmtask app. expects this structure to be passed as the 
   command tail when the app. is exec'd
*/

typedef struct _MMTaskStruct {
    BYTE        cb;             
    LPTASKCALLBACK    lpfn;
    DWORD       dwInst;
    DWORD       dwStack;
} MMTaskStruct;

#define MMTASK_STACK 4096
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\wave.c ===
/****************************************************************************
    wave.c

    Level 1 kitchen sink DLL wave support module

    Copyright (c) Microsoft Corporation 1990. All rights reserved

****************************************************************************/

#include <windows.h>
#include "mmsystem.h"
#include "mmddk.h"
#include "mmsysi.h"
#include "thunks.h"

/* -------------------------------------------------------------------------
** Local functions
** -------------------------------------------------------------------------
*/
static UINT NEAR PASCAL
waveGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    );

/* -------------------------------------------------------------------------
** Local structures
** -------------------------------------------------------------------------
*/
typedef struct wavedev_tag {
    PWAVEDRV    wavedrv;
    UINT    wDevice;
    DWORD   dwDrvUser;
    UINT    wDeviceID;
} WAVEDEV, *PWAVEDEV;

/* -------------------------------------------------------------------------
** @doc INTERNAL  WAVE validation code for WAVEHDRs
** -------------------------------------------------------------------------
*/
#define IsWaveHeaderPrepared(hWave, lpwh)      \
    ((lpwh)->dwFlags &  WHDR_PREPARED)

#define MarkWaveHeaderPrepared(hWave, lpwh)    \
    ((lpwh)->dwFlags |= WHDR_PREPARED)

#define MarkWaveHeaderUnprepared(hWave, lpwh)  \
    ((lpwh)->dwFlags &=~WHDR_PREPARED)


/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api UINT | wavePrepareHeader | This function prepares the header and data
 *   if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it
 *   specifies an error number.
 ****************************************************************************/
static UINT NEAR PASCAL
wavePrepareHeader(
    LPWAVEHDR lpWaveHdr,
    UINT wSize
    )
{
    if (!HugePageLock(lpWaveHdr, (DWORD)sizeof(WAVEHDR))) {
        return MMSYSERR_NOMEM;
    }

    if (!HugePageLock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength)) {
        HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));
        return MMSYSERR_NOMEM;
    }

//  lpWaveHdr->dwFlags |= WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc INTERNAL  WAVE
 *
 * @api UINT | waveUnprepareHeader | This function unprepares the header and
 *   data if the driver returns MMSYSERR_NOTSUPPORTED.
 *
 * @rdesc Currently always returns MMSYSERR_NOERROR.
 ****************************************************************************/
static UINT NEAR PASCAL
waveUnprepareHeader(
    LPWAVEHDR lpWaveHdr,
    UINT wSize
    )
{
    HugePageUnlock(lpWaveHdr->lpData, lpWaveHdr->dwBufferLength);
    HugePageUnlock(lpWaveHdr, (DWORD)sizeof(WAVEHDR));

//  lpWaveHdr->dwFlags &= ~WHDR_PREPARED;

    return MMSYSERR_NOERROR;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetNumDevs | This function retrieves the number of
 *   waveform output devices present in the system.
 *
 * @rdesc Returns the number of waveform output devices present in the system.
 *
 * @xref waveOutGetDevCaps
 ****************************************************************************/
UINT WINAPI
waveOutGetNumDevs(
    void
    )
{
    return waveOIDMessage( 0, WODM_GETNUMDEVS, 0L, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api DWORD | waveOutMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEOUT | hWaveOut | The handle to the audio device.
 *
 * @parm UINT | msg  | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
DWORD WINAPI
waveOutMessage(
    HWAVEOUT hWaveOut,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, 0L);

    return waveOMessage( (HWAVE)hWaveOut, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetDevCaps | This function queries a specified waveform
 *   device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm LPWAVEOUTCAPS | lpCaps | Specifies a far pointer to a <t WAVEOUTCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEOUTCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveOutGetNumDevs
 ****************************************************************************/
UINT WINAPI
waveOutGetDevCaps(
    UINT wDeviceID,
    LPWAVEOUTCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0)
        return MMSYSERR_NOERROR;

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {
       return((UINT)waveOMessage((HWAVE)wDeviceID,
                                 WODM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return waveOIDMessage( wDeviceID, WODM_GETDEVCAPS, 0L,
                          (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetVolume | This function queries the current volume
 *   setting of a waveform output device.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm LPDWORD | lpdwVolume | Specifies a far pointer to a location to
 *   be filled with the current volume setting.  The low-order word of
 *   this location contains the left channel volume setting, and the high-order
 *   WORD contains the right channel setting. A value of 0xFFFF represents
 *   full volume, and a value of 0x0000 is silence.
 *
 *   If a device does not support both left and right volume
 *   control, the low-order word of the specified location contains
 *   the mono volume level.
 *
 *   The full 16-bit setting(s)
 *   set with <f waveOutSetVolume> is returned, regardless of whether
 *   the device supports the full 16 bits of volume-level control.
 *
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both
 *   the left and right channels, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetVolume
 ****************************************************************************/
UINT WINAPI
waveOutGetVolume(
    UINT wDeviceID,
    LPDWORD lpdwVolume
    )
{
    V_WPOINTER(lpdwVolume, sizeof(DWORD), MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {

       return ( (UINT)waveOMessage( (HWAVE)wDeviceID,
                                    WODM_GETVOLUME,
                                    (DWORD)lpdwVolume,
                                    0
                                  ));

    }

    return waveOIDMessage( wDeviceID,
                          WODM_GETVOLUME, 0L, (DWORD)lpdwVolume, 0);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetVolume | This function sets the volume of a
 *   waveform output device.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device.
 *
 * @parm DWORD | dwVolume | Specifies the new volume setting.  The
 *   low-order word contains the left channel volume setting, and the
 *   high-order word contains the right channel setting. A value of
 *   0xFFFF represents full volume, and a value of 0x0000 is silence.
 *
 *   If a device does
 *   not support both left and right volume control, the low-order word of
 *   <p dwVolume> specifies the volume level, and the high-order word is
 *   ignored.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Not all devices support volume changes. To determine whether the
 *   device supports volume control, use the WAVECAPS_VOLUME
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   To determine whether the device supports volume control on both the
 *   left and right channels, use the WAVECAPS_LRVOLUME flag
 *   flag to test the <e WAVEOUTCAPS.dwSupport> field of the <t WAVEOUTCAPS>
 *   structure (filled by <f waveOutGetDevCaps>).
 *
 *   Most devices don't support the full 16 bits of volume level control
 *   and will not use the high-order bits of the requested volume setting.
 *   For example, for a device that supports 4 bits of volume control,
 *   requested volume level values of 0x4000, 0x4fff, and 0x43be
 *   all produce the same physical volume setting, 0x4000. The
 *   <f waveOutGetVolume> function returns the full 16-bit setting set
 *   with <f waveOutSetVolume>.
 *
 *   Volume settings are interpreted logarithmically. This means the
 *   perceived increase in volume is the same when increasing the
 *   volume level from 0x5000 to 0x6000 as it is from 0x4000 to 0x5000.
 *
 * @xref waveOutGetVolume
 ****************************************************************************/
UINT WINAPI
waveOutSetVolume(
    UINT wDeviceID,
    DWORD dwVolume
    )
{

   if (ValidateHandle((HWAVEOUT)wDeviceID, TYPE_WAVEOUT)) {
      return((UINT)waveOMessage((HWAVE)wDeviceID, WODM_SETVOLUME, dwVolume, 0));
   }

   return waveOIDMessage( wDeviceID, WODM_SETVOLUME, 0L, dwVolume, 0);
}

/*****************************************************************************
 * @doc INTERNAL WAVE
 *
 * @func UINT | waveGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer which
 *   is filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed to by
 *   <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied and MMSYSERR_NOERROR
 *   is returned.
 ****************************************************************************/
static UINT NEAR PASCAL
waveGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    lpText[0] = 0;

#if MMSYSERR_BASE
    if ( ((wError < MMSYSERR_BASE) || (wError > MMSYSERR_LASTERROR))
      && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#else
    if ( (wError > MMSYSERR_LASTERROR)
     && ((wError < WAVERR_BASE) || (wError > WAVERR_LASTERROR))) {

        return MMSYSERR_BADERRNUM;
    }
#endif

    if (wSize > 1) {
        if (!LoadString(ghInst, wError, lpText, wSize)) {
            return MMSYSERR_BADERRNUM;
        }
    }

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetErrorText | This function retrieves a
 *   textual description of the error identified by the specified
 *   error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to a buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the length of the buffer pointed
 *   to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
waveOutGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutOpen | This function opens a specified waveform output
 *   device for playback.
 *
 * @parm LPHWAVEOUT | lphWaveOut | Specifies a far pointer to an HWAVEOUT
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform output device.  Use the handle to identify the device when
 *   calling other waveform output functions.  This parameter may be
 *   NULL if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | wDeviceID | Identifies the waveform output device to open.
 *  Use a valid device ID or the following flag:
 *
 *   @flag WAVE_MAPPER | If this flag is specified, the function
 *     selects a waveform output device
 *     capable of playing the given format.
 *
 * @parm LPWAVEFORMAT | lpFormat | Specifies a pointer to a <t WAVEFORMAT>
 *   structure that identifies the format of the waveform data
 *   to be sent to the waveform output device.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   playback to process messages related to the progress of the playback.
 *   Specify NULL for this parameter if no callback is desired.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user instance data
 *   passed to the callback.  This parameter is not used with
 *   window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device is
 *   queried to determine if it supports the given format but is not
 *      actually opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveOutGetNumDevs> to determine the number of waveform output
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   The <t WAVEFORMAT> structure pointed to by <p lpFormat> may be extended
 *   to include type-specific information for certain data formats.
 *   For example, for PCM data, an extra UINT is added to specify the number
 *   of bits per sample.  Use the <t PCMWAVEFORMAT> structure in this case.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform output:  <m MM_WOM_OPEN>, <m MM_WOM_CLOSE>,
 *   <m MM_WOM_DONE>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   output: <m WOM_OPEN>, <m WOM_CLOSE>, <m WOM_DONE>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveOutFunc | <f WaveOutFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform output message.
 *
 * @parm DWORD | dwInstance | Specifies the user instance data
 *   specified with <f waveOutOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveOutClose
 ****************************************************************************/
UINT WINAPI
waveOutOpen(
    LPHWAVEOUT lphWaveOut,
    UINT wDeviceID,
    const WAVEFORMAT FAR* lpFormat,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    UINT         wRet;
    DWORD        dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveOutOpen, MMSYSERR_INVALFLAG);

    if (!(dwFlags & WAVE_FORMAT_QUERY)) {
        V_WPOINTER(lphWaveOut, sizeof(HWAVEOUT), MMSYSERR_INVALPARAM);
        *lphWaveOut = NULL;
    }


    /*
    ** Check for no devices
    */
//  if (wTotalWaveOutDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != WAVE_MAPPER ) {
//      if ( wDeviceID >= wTotalWaveOutDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }

    if (dwFlags & WAVE_FORMAT_QUERY) {
        pdev = NULL;
    }
    else {

        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEOUT, sizeof(WAVEDEV)))) {
            return MMSYSERR_NOMEM;
        }

        pdev->wDevice = wDeviceID;
        pdev->wDeviceID = wDeviceID;

    }

    wo.hWave      = (HWAVE)pdev;
    wo.dwCallback = dwCallback;
    wo.dwInstance = dwInstance;
    wo.lpFormat   = lpFormat;

    if ( (wDeviceID == WAVE_MAPPER) && (wodMapper != NULL) ) {

        wRet = (UINT)((*(wodMapper))(0, WODM_OPEN,
                                     (DWORD)(LPDWORD)&dwDrvUser,
                                     (DWORD)(LPWAVEOPENDESC)&wo,
                                     dwFlags));
    }
    else {

        wRet = waveOIDMessage( wDeviceID, WODM_OPEN, (DWORD)(LPDWORD)&dwDrvUser,
                               (DWORD)(LPWAVEOPENDESC)&wo, dwFlags );
    }

    if (pdev) {
        if (wRet) {
            FreeHandle((HWAVEOUT)pdev);
        }
        else {
            *lphWaveOut = (HWAVEOUT)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutClose | This function closes the specified waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device. If the function is successful, the handle is no
 *   longer valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If the device is still playing a waveform, the close
 *   operation will fail.  Use <f waveOutReset> to terminate waveform
 *   playback before calling <f waveOutClose>.
 *
 * @xref waveOutOpen waveOutReset
 ****************************************************************************/
UINT WINAPI waveOutClose(HWAVEOUT hWaveOut)
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_CLOSE, 0L,0L);

    if (!wRet) {
        FreeHandle(hWaveOut);
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutPrepareHeader | This function prepares a
 *   waveform data block for playback.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the data block to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared has no effect, and
 *   the function returns zero.
 *
 * @xref waveOutUnprepareHeader
 ****************************************************************************/
UINT WINAPI
waveOutPrepareHeader(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveOutHdr->dwFlags &= (WHDR_BEGINLOOP | WHDR_ENDLOOP);

    wRet = wavePrepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_PREPARE,
                                   (DWORD)lpWaveOutHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutUnprepareHeader | This function cleans up the
 *   preparation performed by <f waveOutPrepareHeader>. The function
 *   must be called after
 *   the device driver is finished with a data block. You must call this
 *   function before freeing the data buffer.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data block to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveOutHdr> is still in the queue.
 *
 * @comm This function is the complementary function to
 * <f waveOutPrepareHeader>. You must call this function before freeing the
 *  data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveOutWrite>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveOutUnprepareHeader>.
 *
 *  Unpreparing a buffer that has not been
 *  prepared has no effect, and the function returns zero.
 *
 * @xref waveOutPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveOutUnprepareHeader(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if(lpWaveOutHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    wRet = waveUnprepareHeader(lpWaveOutHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_UNPREPARE,
                                   (DWORD)lpWaveOutHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutWrite | This function sends a data block to the
 *   specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *  device.
 *
 * @parm LPWAVEHDR | lpWaveOutHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure containing information about the data block.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveOutHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f waveOutPrepareHeader> before
 *   it is passed to <f waveOutWrite>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.  Unless the device is paused by calling
 *   <f waveOutPause>, playback begins when the first data block is sent to
 *   the device.
 *
 * @xref waveOutPrepareHeader waveOutPause waveOutReset waveOutRestart
 ****************************************************************************/
UINT WINAPI
waveOutWrite(
    HWAVEOUT hWaveOut,
    LPWAVEHDR lpWaveOutHdr,
    UINT wSize
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveOutHdr, wSize, TYPE_WAVEOUT, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveOut, lpWaveOutHdr)) {
        DebugErr(DBF_WARNING,"waveOutWrite: header not prepared");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveOutHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING,"waveOutWrite: header is still in queue");
        return WAVERR_STILLPLAYING;
    }

    lpWaveOutHdr->dwFlags &= ~WHDR_DONE;

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_WRITE,
                               (DWORD)lpWaveOutHdr, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutPause | This function pauses playback on a specified
 *   waveform output device.  The current playback position is saved.  Use
 *   <f waveOutRestart> to resume playback from the current playback position.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Calling this function when the output is already paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutRestart waveOutBreakLoop
 ****************************************************************************/
UINT WINAPI
waveOutPause(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_PAUSE, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutRestart | This function restarts a paused waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Calling this function when the output is not paused has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutPause waveOutBreakLoop
 ****************************************************************************/
UINT WINAPI
waveOutRestart(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_RESTART, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutReset | This function stops playback on a given waveform
 *   output device and resets the current position to 0.  All pending
 *   playback buffers are marked as done and returned to the application.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref waveOutWrite waveOutClose
/****************************************************************************/
UINT WINAPI
waveOutReset(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_RESET, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutBreakLoop | This function breaks a loop on a
 *   given waveform output device and allows playback to continue with the
 *   next block in the driver list.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Waveform looping is controlled by the <e WAVEHDR.dwLoops> and
 *   <e WAVEHDR.dwFlags> fields in the <t WAVEHDR> structures passed to the device
 *   with <f waveOutWrite>. Use the WHDR_BEGINLOOP and WHDR_ENDLOOP flags
 *   in the <e WAVEHDR.dwFlags> field to specify the beginning and ending data
 *   blocks for looping.
 *
 *   To loop on a single block, specify both flags for the same block.
 *   To specify the number of loops, use the <e WAVEHDR.dwLoops> field in
 *   the <t WAVEHDR> structure for the first block in the loop.
 *
 *   The blocks making up the loop are played to the end before the loop
 *   is terminated.
 *
 *   Calling this function when the nothing is playing or looping has no
 *   effect, and the function returns zero.
 *
 * @xref waveOutWrite waveOutPause waveOutRestart
/****************************************************************************/
UINT WINAPI
waveOutBreakLoop(
    HWAVEOUT hWaveOut
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_BREAKLOOP, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveOutGetPosition | This function retrieves the current
 *   playback position of the specified waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveOutGetPosition>, set the <e MMTIME.wType> field of the
 *   MMTIME structure to indicate the time format that you desire.  After
 *   calling <f waveOutGetPosition>, check the <e MMTIME.wType> field
 *   to determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
UINT WINAPI
waveOutGetPosition(
    HWAVEOUT hWaveOut,
    LPMMTIME lpInfo,
    UINT wSize
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_GETPOS,
                              (DWORD)lpInfo, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetPitch | This function queries the the current pitch
 *   setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwPitch | Specifies a far pointer to a location
 *   to be filled with the current pitch multiplier setting. The pitch
 *   multiplier indicates the current change in pitch from the original
 *   authored setting. The pitch multiplier must be a positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no pitch change), and a value of
 * 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the pitch does not change the playback rate, sample
 *   rate, or playback time.  Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPitch waveOutGetPlaybackRate waveOutSetPlaybackRate
 ****************************************************************************/
UINT WINAPI
waveOutGetPitch(
    HWAVEOUT hWaveOut,
    LPDWORD lpdwPitch
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpdwPitch, sizeof(DWORD), MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_GETPITCH,
                               (DWORD)lpdwPitch, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetPitch | This function sets the pitch of a waveform
 *   output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwPitch | Specifies the new pitch multiplier setting.
 *  The pitch multiplier setting indicates the current change in pitch
 *  from the original authored setting. The pitch multiplier must be a
 *  positive value.
 *
 * The pitch multiplier is specified as a fixed-point value. The high-order word
 * location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier
 * of 1.0 (no pitch change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the pitch does not change the playback rate or the sample
 *   rate.  The playback time is also unchanged. Not all devices support
 *   pitch changes. To determine whether the device supports pitch control,
 *   use the WAVECAPS_PITCH flag to test the <e WAVEOUTCAPS.dwSupport>
 *   field of the <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPitch waveOutSetPlaybackRate waveOutGetPlaybackRate
 ****************************************************************************/
UINT WINAPI
waveOutSetPitch(
    HWAVEOUT hWaveOut,
    DWORD dwPitch
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_SETPITCH, dwPitch, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetPlaybackRate | This function queries the
 *   current playback rate setting of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform output
 *   device.
 *
 * @parm LPDWORD | lpdwRate | Specifies a far pointer to a location
 *   to be filled with the current playback rate. The playback rate setting
 *  is a multiplier indicating the current change in playback rate from
 *  the original authored setting. The playback rate multiplier must be
 *  a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * of the DWORD location contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter. For example, the value 0x00010000
 * specifies a multiplier of 1.0 (no playback rate change), and a value
 * of 0x000F8000 specifies a multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 *   Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes, use
 *   the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutSetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
UINT WINAPI
waveOutGetPlaybackRate(
    HWAVEOUT hWaveOut,
    LPDWORD lpdwRate
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpdwRate, sizeof(DWORD), MMSYSERR_INVALPARAM);

    return (UINT)waveOMessage( (HWAVE)hWaveOut,
                               WODM_GETPLAYBACKRATE, (DWORD)lpdwRate, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutSetPlaybackRate | This function sets the
 *   playback rate of a waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies a handle to the waveform
 *   output device.
 *
 * @parm DWORD | dwRate | Specifies the new playback rate setting.
 *  The playback rate setting is a multiplier indicating the current
 *  change in playback rate from the original authored setting. The playback
 *  rate multiplier must be a positive value.
 *
 * The rate is specified as a fixed-point value. The high-order word
 * contains the signed integer part of the number,
 * and the low-order word contains the fractional part. The fraction is
 * expressed as a WORD in which a value of 0x8000 represents one half,
 * and 0x4000 represents one quarter.
 * For example, the value 0x00010000 specifies a multiplier of 1.0 (no
 * playback rate change), and a value of 0x000F8000 specifies a
 * multiplier of 15.5.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOTSUPPORTED | Function isn't supported.
 *
 * @comm Changing the playback rate does not change the sample rate but does
 *   change the playback time.
 *
 * Not all devices support playback rate changes. To determine whether a
 *   device supports playback rate changes,
 *   use the WAVECAPS_PLAYBACKRATE flag to test the <e WAVEOUTCAPS.dwSupport> field of the
 *   <t WAVEOUTCAPS> structure (filled by <f waveOutGetDevCaps>).
 *
 * @xref waveOutGetPlaybackRate waveOutSetPitch waveOutGetPitch
 ****************************************************************************/
UINT WINAPI
waveOutSetPlaybackRate(
    HWAVEOUT hWaveOut,
    DWORD dwRate
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);

    return (UINT)waveOMessage( (HWAVE)hWaveOut, WODM_SETPLAYBACKRATE, dwRate, 0L );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetNumDevs | This function returns the number of waveform
 *   input devices.
 *
 * @rdesc Returns the number of waveform input devices present in the system.
 *
 * @xref waveInGetDevCaps
 ****************************************************************************/
UINT WINAPI
waveInGetNumDevs(
    void
    )
{
   return waveIIDMessage( 0, WIDM_GETNUMDEVS, 0L, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api DWORD | waveInMessage | This function sends messages to the waveform
 *   output device drivers.
 *
 * @parm HWAVEIN | hWave | The handle to the audio device.
 *
 * @parm UINT | wMsg | The message to send.
 *
 * @parm DWORD | dw1 | Parameter 1.
 *
 * @parm DWORD | dw2 | Parameter 2.
 *
 * @rdesc Returns the value returned from the driver.
 ****************************************************************************/
DWORD WINAPI
waveInMessage(
    HWAVEIN hWaveIn,
    UINT msg,
    DWORD dw1,
    DWORD dw2
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, 0L);

    return waveIMessage((HWAVE)hWaveIn, msg, dw1, dw2);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetDevCaps | This function queries a specified waveform
 *   input device to determine its capabilities.
 *
 * @parm UINT | wDeviceID | Identifies the waveform input device.
 *
 * @parm LPWAVEINCAPS | lpCaps | Specifies a far pointer to a <t WAVEINCAPS>
 *   structure.  This structure is filled with information about the
 *   capabilities of the device.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEINCAPS> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_NODRIVER | The driver was not installed.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id. Only
 *   <p wSize> bytes (or less) of information is copied to the location
 *   pointed to by <p lpCaps>.  If <p wSize> is zero, nothing is copied, and
 *   the function returns zero.
 *
 * @xref waveInGetNumDevs
 ****************************************************************************/
UINT WINAPI
waveInGetDevCaps(
    UINT wDeviceID,
    LPWAVEINCAPS lpCaps,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpCaps, wSize, MMSYSERR_INVALPARAM);

    if (ValidateHandle((HWAVEIN)wDeviceID, TYPE_WAVEIN)) {
       return((UINT)waveIMessage((HWAVE)wDeviceID,
                                 WIDM_GETDEVCAPS,
                                 (DWORD)lpCaps,
                                 (DWORD)wSize));
    }

    return waveIIDMessage( wDeviceID, WIDM_GETDEVCAPS,
                           0L, (DWORD)lpCaps, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetErrorText | This function retrieves a textual
 *   description of the error identified by the specified error number.
 *
 * @parm UINT | wError | Specifies the error number.
 *
 * @parm LPSTR | lpText | Specifies a far pointer to the buffer to be
 *   filled with the textual error description.
 *
 * @parm UINT | wSize | Specifies the size of the buffer pointed
 *   to by <p lpText>.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADERRNUM | Specified error number is out of range.
 *
 * @comm If the textual error description is longer than the specified buffer,
 *   the description is truncated.  The returned error string is always
 *   null-terminated. If <p wSize> is zero, nothing is copied, and the function
 *   returns zero. All error descriptions are less than MAXERRORLENGTH characters long.
 ****************************************************************************/
UINT WINAPI
waveInGetErrorText(
    UINT wError,
    LPSTR lpText,
    UINT wSize
    )
{
    if (wSize == 0) {
        return MMSYSERR_NOERROR;
    }

    V_WPOINTER(lpText, wSize, MMSYSERR_INVALPARAM);

    return waveGetErrorText(wError, lpText, wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInOpen | This function opens a specified waveform
 *   input device for recording.
 *
 * @parm LPHWAVEIN | lphWaveIn | Specifies a far pointer to a HWAVEIN
 *   handle.  This location is filled with a handle identifying the opened
 *   waveform input device.  Use this handle to identify the device when
 *   calling other waveform input functions.  This parameter may be NULL
 *   if the WAVE_FORMAT_QUERY flag is specified for <p dwFlags>.
 *
 * @parm UINT | wDeviceID | Identifies the waveform input device to open. Use
 *  a valid device ID or the following flag:
 *
 * @flag WAVE_MAPPER | If this flag is specified, the function
 *   selects a waveform input device capable of recording in the
 *   given format.
 *
 * @parm LPWAVEFORMAT | lpFormat | Specifies a pointer to a <t WAVEFORMAT>
 *   data structure that identifies the desired format for recording
 *   waveform data.
 *
 * @parm DWORD | dwCallback | Specifies the address of a callback
 *   function or a handle to a window called during waveform
 *   recording to process messages related to the progress of recording.
 *
 * @parm DWORD | dwCallbackInstance | Specifies user
 *  instance data passed to the callback.  This parameter is not
 *  used with window callbacks.
 *
 * @parm DWORD | dwFlags | Specifies flags for opening the device.
 *   @flag WAVE_FORMAT_QUERY | If this flag is specified, the device will
 *   be queried to determine if it supports the given format but will not
 *      actually be opened.
 *   @flag WAVE_ALLOWSYNC | If this flag is not specified, then the
 *   device will fail to open if it is a synchronous device.
 *   @flag CALLBACK_WINDOW | If this flag is specified, <p dwCallback> is
 *      assumed to be a window handle.
 *   @flag CALLBACK_FUNCTION | If this flag is specified, <p dwCallback> is
 *      assumed to be a callback procedure address.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_BADDEVICEID | Specified device ID is out of range.
 *   @flag MMSYSERR_ALLOCATED | Specified resource is already allocated.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *   @flag WAVERR_BADFORMAT | Attempted to open with an unsupported wave format.
 *
 * @comm Use <f waveInGetNumDevs> to determine the number of waveform input
 *   devices present in the system.  The device ID specified by <p wDeviceID>
 *   varies from zero to one less than the number of devices present.
 *   The WAVE_MAPPER constant may also be used as a device id.
 *
 *   If a window is chosen to receive callback information, the following
 *   messages are sent to the window procedure function to indicate the
 *   progress of waveform input:  <m MM_WIM_OPEN>, <m MM_WIM_CLOSE>,
 *   <m MM_WIM_DATA>
 *
 *   If a function is chosen to receive callback information, the following
 *   messages are sent to the function to indicate the progress of waveform
 *   input: <m WIM_OPEN>, <m WIM_CLOSE>, <m WIM_DATA>.  The callback function
 *   must reside in a DLL.  You do not have to use <f MakeProcInstance> to get
 *   a procedure-instance address for the callback function.
 *
 * @cb void CALLBACK | WaveInFunc | <f WaveInFunc> is a placeholder for the
 *   application-supplied function name.  The actual name must be exported by
 *   including it in an EXPORTS statement in the DLL's module-definition file.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform device
 *   associated with the callback.
 *
 * @parm UINT | wMsg | Specifies a waveform input device.
 *
 * @parm DWORD | dwInstance | Specifies the user instance
 *   data specified with <f waveInOpen>.
 *
 * @parm DWORD | dwParam1 | Specifies a parameter for the message.
 *
 * @parm DWORD | dwParam2 | Specifies a parameter for the message.
 *
 * @comm Because the callback is accessed at interrupt time, it must reside
 *   in a DLL and its code segment must be specified as FIXED in the
 *   module-definition file for the DLL.  Any data that the callback accesses
 *   must be in a FIXED data segment as well. The callback may not make any
 *   system calls except for <f PostMessage>, <f timeGetSystemTime>,
 *   <f timeGetTime>, <f timeSetEvent>, <f timeKillEvent>,
 *   <f midiOutShortMsg>, <f midiOutLongMsg>, and <f OutputDebugStr>.
 *
 * @xref waveInClose
 ****************************************************************************/
UINT WINAPI
waveInOpen(
    LPHWAVEIN lphWaveIn,
    UINT wDeviceID,
    const WAVEFORMAT FAR* lpFormat,
    DWORD dwCallback,
    DWORD dwInstance,
    DWORD dwFlags
    )
{
    WAVEOPENDESC wo;
    PWAVEDEV     pdev;
    UINT         wRet;
    DWORD        dwDrvUser;

    V_RPOINTER(lpFormat, sizeof(WAVEFORMAT), MMSYSERR_INVALPARAM);
    V_DCALLBACK(dwCallback, HIWORD(dwFlags), MMSYSERR_INVALPARAM);
    V_FLAGS(LOWORD(dwFlags), WAVE_VALID, waveInOpen, MMSYSERR_INVALFLAG);

    if (!(dwFlags & WAVE_FORMAT_QUERY)) {
        V_WPOINTER(lphWaveIn, sizeof(HWAVEIN), MMSYSERR_INVALPARAM);
        *lphWaveIn = NULL;
    }

    /*
    ** Check for no devices
    */
//  if (wTotalWaveInDevs == 0 ) {
//      return MMSYSERR_BADDEVICEID;
//  }
//
//  /*
//  ** check for device ID being to large
//  */
//  if ( wDeviceID != WAVE_MAPPER ) {
//      if ( wDeviceID >= wTotalWaveInDevs ) {
//          return MMSYSERR_BADDEVICEID;
//      }
//  }


    if (dwFlags & WAVE_FORMAT_QUERY) {
        pdev = NULL;
    }
    else {
        if (!(pdev = (PWAVEDEV)NewHandle(TYPE_WAVEIN, sizeof(WAVEDEV))))
            return MMSYSERR_NOMEM;

        pdev->wDevice = wDeviceID;
        pdev->wDeviceID = wDeviceID;
    }

    wo.hWave        = (HWAVE)pdev;
    wo.dwCallback   = dwCallback;
    wo.dwInstance   = dwInstance;
    wo.lpFormat     = lpFormat;

    if ( (wDeviceID == WAVE_MAPPER) && (wodMapper != NULL) ) {

        wRet = (UINT)((*(widMapper))(0, WIDM_OPEN,
                                     (DWORD)(LPDWORD)&dwDrvUser,
                                     (DWORD)(LPWAVEOPENDESC)&wo,
                                     dwFlags));
    }
    else {

        wRet = waveIIDMessage( wDeviceID, WIDM_OPEN,
                               (DWORD)(LPDWORD)&dwDrvUser,
                               (DWORD)(LPWAVEOPENDESC)&wo, dwFlags );
    }

    if (pdev) {

        if (wRet)
            FreeHandle((HWAVEIN)pdev);
        else {
            *lphWaveIn = (HWAVEIN)pdev;
            pdev->dwDrvUser = dwDrvUser;
        }
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInClose | This function closes the specified waveform
 *   input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *  If the function is successful, the handle is no longer
 *   valid after this call.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | There are still buffers in the queue.
 *
 * @comm If there are input buffers that have been sent with
 *   <f waveInAddBuffer>, and haven't been returned to the application,
 *   the close operation will fail.  Call <f waveInReset> to mark all
 *   pending buffers as done.
 *
 * @xref waveInOpen waveInReset
 ****************************************************************************/
UINT WINAPI
waveInClose(
    HWAVEIN hWaveIn
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_CLOSE, 0L, 0L);
    if (!wRet) {
        FreeHandle(hWaveIn);
    }
    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInPrepareHeader | This function prepares a buffer
 *   for waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a pointer to a
 *   <t WAVEHDR> structure that identifies the buffer to be prepared.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag MMSYSERR_NOMEM | Unable to allocate or lock memory.
 *
 * @comm The <t WAVEHDR> data structure and the data block pointed to by its
 *   <e WAVEHDR.lpData> field must be allocated with <f GlobalAlloc> using the
 *   GMEM_MOVEABLE and GMEM_SHARE flags, and locked with <f GlobalLock>.
 *   Preparing a header that has already been prepared will have no effect,
 *   and the function will return zero.
 *
 * @xref waveInUnprepareHeader
 ****************************************************************************/
UINT WINAPI
waveInPrepareHeader(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING,"waveInPrepareHeader: header is already prepared.");
        return MMSYSERR_NOERROR;
    }

    lpWaveInHdr->dwFlags = 0;

    wRet = wavePrepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_PREPARE,
                                   (DWORD)lpWaveInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInUnprepareHeader | This function cleans up the
 * preparation performed by <f waveInPrepareHeader>. The function must
 * be called after the device
 *   driver fills a data buffer and returns it to the application. You
 *  must call this function before freeing the data buffer.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr |  Specifies a pointer to a <t WAVEHDR>
 *   structure identifying the data buffer to be cleaned up.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_STILLPLAYING | <p lpWaveInHdr> is still in the queue.
 *
 * @comm This function is the complementary function to <f waveInPrepareHeader>.
 * You must call this function before freeing the data buffer with <f GlobalFree>.
 *   After passing a buffer to the device driver with <f waveInAddBuffer>, you
 *   must wait until the driver is finished with the buffer before calling
 *   <f waveInUnprepareHeader>. Unpreparing a buffer that has not been
 *   prepared has no effect, and the function returns zero.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveInUnprepareHeader(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    UINT         wRet;

    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "waveInUnprepareHeader: buffer still in queue.");
        return WAVERR_STILLPLAYING;
    }

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING,"waveInUnprepareHeader: header is not prepared.");
        return MMSYSERR_NOERROR;
    }

    wRet = waveUnprepareHeader(lpWaveInHdr, wSize);

    if (wRet == MMSYSERR_NOERROR) {
        wRet = (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_UNPREPARE,
                                   (DWORD)lpWaveInHdr, (DWORD)wSize);
    }

    return wRet;
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInAddBuffer | This function sends an input buffer to a
 *   waveform input device.  When the buffer is filled, it is sent back
 *   to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPWAVEHDR | lpWaveInHdr | Specifies a far pointer to a <t WAVEHDR>
 *   structure that identifies the buffer.
 *
 * @parm UINT | wSize | Specifies the size of the <t WAVEHDR> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *   @flag WAVERR_UNPREPARED | <p lpWaveInHdr> hasn't been prepared.
 *
 * @comm The data buffer must be prepared with <f waveInPrepareHeader> before
 *   it is passed to <f waveInAddBuffer>.  The <t WAVEHDR> data structure
 *   and the data buffer pointed to by its <e WAVEHDR.lpData> field must be allocated
 *   with <f GlobalAlloc> using the GMEM_MOVEABLE and GMEM_SHARE flags, and
 *   locked with <f GlobalLock>.
 *
 * @xref waveInPrepareHeader
 ****************************************************************************/
UINT WINAPI
waveInAddBuffer(
    HWAVEIN hWaveIn,
    LPWAVEHDR lpWaveInHdr,
    UINT wSize
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_HEADER(lpWaveInHdr, wSize, TYPE_WAVEIN, MMSYSERR_INVALPARAM);

    if (!IsWaveHeaderPrepared(hWaveIn, lpWaveInHdr)) {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer not prepared.");
        return WAVERR_UNPREPARED;
    }

    if (lpWaveInHdr->dwFlags & WHDR_INQUEUE) {
        DebugErr(DBF_WARNING, "waveInAddBuffer: buffer already in queue.");
        return WAVERR_STILLPLAYING;
    }

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_ADDBUFFER,
                               (DWORD)lpWaveInHdr, (DWORD)wSize);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInStart | This function starts input on the specified
 *   waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Buffers are returned to the client when full or when <f waveInReset>
 *   is called (the <e WAVEHDR.dwBytesRecorded> field in the header will contain the
 *   actual length of data). If there are no buffers in the queue, the data is
 *   thrown away without notification to the client, and input continues.
 *
 *   Calling this function when input is already started has no effect, and
 *   the function returns zero.
 *
 * @xref waveInStop waveInReset
 ****************************************************************************/
UINT WINAPI
waveInStart(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_START, 0L, 0L);
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInStop | This function stops waveform input.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input
 *   device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm If there are any buffers in the queue, the current buffer will be
 *   marked as done (the <e WAVEHDR.dwBytesRecorded> field in the header will contain
 *   the actual length of data), but any empty buffers in the queue will remain
 *   there.  Calling this function when input is not started has no effect,
 *   and the function returns zero.
 *
 * @xref waveInStart waveInReset
 ****************************************************************************/
UINT WINAPI
waveInStop(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_STOP, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInReset | This function stops input on a given waveform
 *   input device and resets the current position to 0.  All pending
 *   buffers are marked as done and returned to the application.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @xref waveInStart waveInStop waveInAddBuffer waveInClose
/****************************************************************************/
UINT WINAPI
waveInReset(
    HWAVEIN hWaveIn
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);

    return (UINT)waveIMessage( (HWAVE)hWaveIn, WIDM_RESET, 0L, 0L );
}

/*****************************************************************************
 * @doc EXTERNAL  WAVE
 *
 * @api UINT | waveInGetPosition | This function retrieves the current input
 *   position of the specified waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies a handle to the waveform input device.
 *
 * @parm LPMMTIME | lpInfo | Specifies a far pointer to an <t MMTIME>
 *   structure.
 *
 * @parm UINT   | wSize | Specifies the size of the <t MMTIME> structure.
 *
 * @rdesc Returns zero if the function was successful.  Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | Specified device handle is invalid.
 *
 * @comm Before calling <f waveInGetPosition>, set the <e MMTIME.wType> field of the
 *   <t MMTIME> structure to indicate the time format that you desire.  After
 *   calling <f waveInGetPosition>, be sure to check the <e MMTIME.wType> field to
 *   determine if the desired time format is supported.  If the desired
 *   format is not supported, <e MMTIME.wType> will specify an alternative format.
 *
 *  The position is set to zero when the device is opened or reset.
 ****************************************************************************/
UINT WINAPI
waveInGetPosition(
    HWAVEIN hWaveIn,
    LPMMTIME lpInfo,
    UINT wSize
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpInfo, wSize, MMSYSERR_INVALPARAM);

    return (UINT)waveIMessage( (HWAVE)hWaveIn,
                               WIDM_GETPOS, (DWORD)lpInfo, (DWORD)wSize );
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveInGetID | This function gets the device ID for a
 * waveform input device.
 *
 * @parm HWAVEIN | hWaveIn | Specifies the handle to the waveform
 * input device.
 * @parm UINT FAR*  | lpwDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 *   @flag MMSYSERR_INVALHANDLE | The <p hWaveIn> parameter specifies an
 * invalid handle.
 *
 ****************************************************************************/
UINT WINAPI
waveInGetID(
    HWAVEIN hWaveIn,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hWaveIn, TYPE_WAVEIN, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PWAVEDEV)hWaveIn)->wDeviceID;

    return MMSYSERR_NOERROR;
}

/*****************************************************************************
 * @doc EXTERNAL WAVE
 *
 * @api UINT | waveOutGetID | This function gets the device ID for a
 * waveform output device.
 *
 * @parm HWAVEOUT | hWaveOut | Specifies the handle to the waveform
 * output device.
 * @parm UINT FAR* | lpwDeviceID | Specifies a pointer to the UINT-sized memory
 * location to be filled with the device ID.
 *
 * @rdesc Returns zero if successful. Otherwise, it returns
 *   an error number.  Possible error returns are:
 * @flag MMSYSERR_INVALHANDLE | The <p hWaveOut> parameter specifies an
 * invalid handle.
 ****************************************************************************/
UINT WINAPI
waveOutGetID(
    HWAVEOUT hWaveOut,
    UINT FAR* lpwDeviceID
    )
{
    V_HANDLE(hWaveOut, TYPE_WAVEOUT, MMSYSERR_INVALHANDLE);
    V_WPOINTER(lpwDeviceID, sizeof(UINT), MMSYSERR_INVALPARAM);

    *lpwDeviceID = ((PWAVEDEV)hWaveOut)->wDeviceID;

    return MMSYSERR_NOERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\mmtask\mmtask.asm ===
PAGE 58,132
;*****************************************************************************
TITLE MMTASK.ASM - Windows MultiMedia Systems Task Stub
;*****************************************************************************
;
;   Copyright (C) Microsoft Corporation 1985-1990. All rights reserved.
;
;   Title:      MMTASK.asm - a windows application that acts as a
;               task stub.
;
;   Version:    1.00
;
;   Date:       12-Mar-1990
;
;   Author:     ROBWI
;
;-----------------------------------------------------------------------------
;
;   Change log:
;
;      DATE     REV            DESCRIPTION
;   ----------- ---   --------------------------------------------------------
;   12-Mar-1990 ROBWI First Version 
;   18-APR-1990 ROBWI Moved from idle.asm to mmtask.asm
;
;=============================================================================


?WIN=0
?PLM=1

    
    PMODE = 1
    
    .xlist
    include cmacros.inc
    .list

wptr equ WORD PTR

; The following structure should be used to access high and low
; words of a DWORD.  This means that "word ptr foo[2]" -> "foo.hi".

LONG    struc
lo      dw      ?
hi      dw      ?
LONG    ends

FARPOINTER      struc
off     dw      ?
sel     dw      ?
FARPOINTER      ends


;----------------------------------------------------------------------
;
; MMTASKSTRUC : The following structure should be passed to mmtask (in
; the command line) when it is exec'd.


MMTASKSTRUC       struc
lpfn    dd      ?           ; fp to function to call. 
inst    dd      ?           ; instance data to pass to lpfn
dwstck  dd      ?           ; stack size.
MMTASKSTRUC       ends

EXIT_PROCESS equ 1

;-----------------------------------------------------------------------;
;
; externals from KERNEL

        externFP    WaitEvent
        externFP    PostEvent
        externFP    OldYield
        externFP    InitTask
        externFP    InitApp     ; to get a msg q so that we can call user
        externFP    OutputDebugString

        externFP    SetMessageQueue


sBegin  DATA
assumes DS,DATA

; Stuff needed to avoid the C runtime coming in

            DD  0               ; So null pointers get 0
maxRsrvPtrs = 5
            DW  maxRsrvPtrs
usedRsrvPtrs = 0
labelDP     <PUBLIC,rsrvptrs>

DefRsrvPtr  MACRO   name
globalW     name,0
usedRsrvPtrs = usedRsrvPtrs + 1
ENDM

DefRsrvPtr  pLocalHeap          ; Local heap pointer
DefRsrvPtr  pAtomTable          ; Atom table pointer
DefRsrvPtr  pStackTop           ; top of stack
DefRsrvPtr  pStackMin           ; minimum value of SP
DefRsrvPtr  pStackBot           ; bottom of stack

if maxRsrvPtrs-usedRsrvPtrs
            DW maxRsrvPtrs-usedRsrvPtrs DUP (0)
endif

public  __acrtused
	__acrtused = 1

loadparams  DB  (SIZE MMTASKSTRUC) DUP (0)

sEnd        DATA


sBegin Code
        assumes cs, Code
        assumes ds, Data
        assumes es, nothing
        assumes ss, nothing

;--------------------------Private-Routine-----------------------------;
;
; @doc      INTERNAL    MMTASKAPP
; 
; @asm      AppEntry | called when the APP is loaded
;
;   @reg      CX    | size of heap
;   @reg      DI    | module handle
;   @reg      DS    | automatic data segment
;   @reg      ES:SI | address of command line (not used)
;   @reg     
; 
; @rdesc    Register values at return
;
;   @reg      AX | 1 if success, 0 if error
; 
; @uses     AX BX CX DX FLAGS
;
; @comm     Preserves: SI DI DS BP
; 
;           Calls: None
;       
;           History:
;
;           06-27-89 -by-       Todd Laney [ToddLa] Created shell appentry 
;                               routine
;           03-13-90 -stolen-   Rob Williams [RobWi] Added all kinds o'
;                               stuff for making it an MMTASK application.
;
;-----------------------------------------------------------------------;
cProc   AppEntry,<FAR,PUBLIC,NODATA>,<>

cBegin

; Copy the parameters out of the command line before
; InitTask gets a chance to modify them.

        push    di                            
        push    si
        push    cx

; switch ds and es so that we can do a string move
; into the data segment

        push    ds                      ; save ds o
        mov     ax, es                  
        mov     ds, ax                  ; ds = es 0
        pop     es                      ; es = ds 0

; copy the command line if it is the correct length

        mov     si, 81h
        lea     di, loadparams
        mov     cx, SIZE MMTASKSTRUC / 2
        xor     ax, ax
        mov     al, byte ptr ds:[80h]
        shr     ax, 1
        cmp     ax, cx                  ; Q: structure size correct
        jne     Skip_Copy               ;    N: Skip the copy

.ERRNZ SIZE MMTASKSTRUC MOD 2

        cld                             ;    Y: Copy the structure
        rep     movsw

Skip_Copy:

; restore original es and ds
        
        push    es
        mov     ax, ds
        mov     es, ax                  ; es = ds = es 0
        pop     ds
        pop     cx
        pop     si
        pop     di

; pretend the command string is 0 length.

        xor     ax, ax
        mov     es:[80h], ax

; initialize the task and the event queue
        
        cCall   InitTask
        cCall   InitApp, <di>

        cCall   SetMessageQueue, <64>
        or      ax,ax
        jz      MMTASKexit

; DX is now the CmdShow value. 
; CX is stack size.

; event count is initially one so call waitevent to clear the event count

        cCall   WaitEvent, <0>  

; check parameters
        
        mov     dx, loadparams.lpfn.hi
        or      dx, dx                  ; callback ok?
        jz      MMTASKExit              ; N: out'a here

        cCall   OldYield                ; be polite.

        mov     ax, loadparams.inst.lo
        mov     dx, loadparams.inst.hi
        cCall   loadparams.lpfn, <dx, ax>

MMTASKExit:

ifdef DEBUG
        ; lets make sure the app did not do anything evil

        cmp     wptr ds:[0],0
        jne     evil
        cmp     wptr ds:[2],0
        jne     evil
        cmp     wptr ds:[4],5
        jne     evil
        je      not_evil
evil:
        lea     ax,evil_str
        cCall   OuputDebugString, <cs,ax>
        int 3
        jmp     not_evil
evil_str:
        db      "MMTASK: NULL pointer assignment! fag!",13,10,0
not_evil:
endif
        ; before we actualy exit lets yield, so we don't re-enter
        ; USERS AppExit code.....

        cCall   OldYield
        cCall   OldYield
        cCall   OldYield

        mov     ah, 4Ch
        int     21h
cEnd

sEnd

end     AppEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\nec_98\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/

buildall:
    cd..   
    nmake /fmakefile.sub \
	 ALT_PROJECT=$(ALT_PROJECT) \
	 ALT_PROJECT_TARGET=$(ALT_PROJECT_TARGET) \
     PROJECT_INC_PATH=$(PROJECT_INC_PATH) \
	 DBCS_FLAGS="-DNEC_98"
    cd $(ALT_PROJECT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\mmsystem\rinc\mmsysver.h ===
/*
 *  mmsysver.h - internal header file to define the build version for sonic
 *
 */

/*
 *  All strings MUST have an explicit \0
 *
 *  MMSYSRELEASE should be changed every build
 *
 *  Version string should be changed each build
 *
 *  Remove build extension on final release
 */

#define OFFICIAL                1
#define FINAL                   1

#define MMSYSVERSION            03
#define MMSYSREVISION           10
#define MMSYSRELEASE            103

#define MMSYSVERSIONSTR         "3.1\0"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\cmacs.h ===
/****************************** Module Header ******************************\
* Module Name: CMACS.H
*
* This module contains common macros used by C routines.
*
* Created: 9-Feb-1989
*
* Copyright (c) 1985 - 1989  Microsoft Corporation
*
* History:
*   Created by Raor
*
\***************************************************************************/

#undef _WINDOWS
#define _WINDOWS
#define  DLL_USE

#define INTERNAL        PASCAL NEAR
#define FARINTERNAL     PASCAL FAR

#ifdef FIREWALLS
extern short ole_flags;

#define DEBUG_PUTS          0x01
#define DEBUG_DEBUG_OUT     0x02
#define DEBUG_MESSAGEBOX    0x04

extern char    szDebugBuffer[];

#define DEBUG_OUT(parm1,parm2){\
    if(ole_flags & DEBUG_DEBUG_OUT){\
            wsprintf(szDebugBuffer,parm1,parm2);\
        OutputDebugString(szDebugBuffer);\
            OutputDebugString ("^^^  ");\
        }\
    }

#define ASSERT(x,y) {\
    if (!(x)) { \
        wsprintf (szDebugBuffer, "Assert Failure file %s, line %d\r\n     ", \
            (LPSTR) __FILE__, __LINE__);\
        OutputDebugString (szDebugBuffer);\
        OutputDebugString ((LPSTR) (y));\
        OutputDebugString ("@@@  ");\
    } \
}

#define Puts(msg) {\
                    if(ole_flags & DEBUG_PUTS){\
                        OutputDebugString ((LPSTR)(msg));\
                        OutputDebugString ("**  ");\
                    }\
                  }

#else

#define DEBUG_OUT(err, val) ;
#define ASSERT(cond, msg)
#define Puts(msg)

#endif /* FIREWALLS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\bm.c ===
/****************************** Module Header ******************************\
* Module Name: BM.C
*
* Handles all API routines for the bitmap sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor,Srinik  (../../1990,91)    Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

extern int   maxPixelsX, maxPixelsY;
void INTERNAL GetHimetricUnits(HBITMAP, LPPOINT);

#pragma alloc_text(_TEXT, BmSaveToStream, BmStreamWrite, BmLoadFromStream, BmStreamRead, GetBytes, PutBytes, PutStrWithLen, BmQueryBounds, BmChangeData, BmCopy, BmDuplicate, BmUpdateStruct, GetHimetricUnits)


OLEOBJECTVTBL    vtblBM  = {

        ErrQueryProtocol,  // check whether the speced protocol is supported

        BmRelease,         // Release
        ErrShow,           // Show
        ErrPlay,           // play
        BmGetData,         // Get the object data
        ErrSetData,        // Set the object data
        ErrSetTargetDevice,//
    
        ErrSetBounds,      // set viewport bounds
        BmEnumFormat,      // enumerate supported formats
        ErrSetColorScheme, //   
        BmRelease,         // delete
        ErrSetHostNames,   //

        BmSaveToStream,    // write to file
        BmClone,           // clone object
        ErrCopyFromLink,   // Create embedded from Link

        BmEqual,           // compares the given objects for data equality

        BmCopy,            // copy to clip

        BmDraw,            // draw the object
            
        ErrActivate,       // open
        ErrExecute,        // excute 
        ErrClose,          // Stop
        ErrUpdate,         // Update
        ErrReconnect,      // Reconnect

        ErrObjectConvert,  // convert object to specified type

        ErrGetUpdateOptions,// update options
        ErrSetUpdateOptions,// update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name

        ObjQueryType,      // Object type
        BmQueryBounds,     // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        BmChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL BmRelease (lpobj)
LPOBJECT_BM     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hBitmap) {
        DeleteObject (lpobj->hBitmap);
        lpobj->hBitmap = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL BmSaveToStream (lpobj, lpstream)
LPOBJECT_BM     lpobj;
LPOLESTREAM     lpstream;
{
    if (!lpobj->hBitmap || !lpobj->sizeBytes)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen(lpstream, (LPSTR)"BITMAP"))
        return OLE_ERROR_STREAM;

    if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
            if (!PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD)))
            return BmStreamWrite (lpstream, lpobj);
    }
    return OLE_ERROR_STREAM;
}


OLESTATUS FARINTERNAL  BmClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_BM         lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_BM  FAR *  lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC)lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = BmCreateObject (lpobjsrc->hBitmap, lpclient, FALSE,
                            lhclientdoc, lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}


OLESTATUS FARINTERNAL  BmEqual (lpobj1, lpobj2)
LPOBJECT_BM lpobj1;
LPOBJECT_BM lpobj2;
{
    HANDLE      hBits1 = NULL, hBits2 = NULL;
    LPSTR       lpBits1 = NULL, lpBits2 = NULL;
    OLESTATUS   retVal;
    DWORD       dwBytes1, dwBytes2;

    if (lpobj1->sizeBytes != lpobj2->sizeBytes)
        return OLE_ERROR_NOT_EQUAL;
    
    retVal = OLE_ERROR_MEMORY;
    
    if (!(hBits1 = GlobalAlloc (GMEM_MOVEABLE, lpobj1->sizeBytes)))
        goto errEqual;
    
    if (!(lpBits1 = GlobalLock (hBits1)))
        goto errEqual;
    
    if (!(hBits2 = GlobalAlloc (GMEM_MOVEABLE, lpobj2->sizeBytes)))
        goto errEqual;
    
    if (!(lpBits2 = GlobalLock (hBits2)))
        goto errEqual;
        
    dwBytes1 = GetBitmapBits (lpobj1->hBitmap, lpobj1->sizeBytes, lpBits1);
    dwBytes2 = GetBitmapBits (lpobj2->hBitmap, lpobj2->sizeBytes, lpBits2);
    
    if (dwBytes1 != dwBytes2) {
        retVal = OLE_ERROR_NOT_EQUAL;
        goto errEqual;
    }
    
    // !!! UtilMemCmp has to be redone for >64k bitmaps
    if (UtilMemCmp (lpBits1, lpBits2, dwBytes1))
        retVal = OLE_ERROR_NOT_EQUAL;
    else
        retVal = OLE_OK;

errEqual:   
    if (lpBits1)
        GlobalUnlock (hBits1);
    
    if (lpBits2)
        GlobalUnlock (hBits2);
    
    if (hBits1)
        GlobalFree (hBits1);
    
    if (hBits2)
        GlobalFree (hBits2);
    
    return retVal;
}



OLESTATUS FARINTERNAL BmCopy (lpobj)
LPOBJECT_BM lpobj;
{
    HBITMAP hBitmap;
    DWORD   size;
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    if(!(hBitmap = BmDuplicate (lpobj->hBitmap, &size, NULL)))
        return OLE_ERROR_MEMORY;

    SetClipboardData(CF_BITMAP, hBitmap);
    return OLE_OK;
}


OLESTATUS FARINTERNAL BmQueryBounds (lpobj, lpRc)
LPOBJECT_BM     lpobj;
LPRECT          lpRc;
{
    Puts("BmQueryBounds");
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    lpRc->left      = 0;
    lpRc->top       = 0;
    lpRc->right     = (int) lpobj->head.cx;
    lpRc->bottom    = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL BmEnumFormat (lpobj, cfFormat)
LPOBJECT_BM lpobj;
OLECLIPFORMAT    cfFormat;
{
    if (!cfFormat)
        return CF_BITMAP;
    
    return NULL;
}



OLESTATUS FARINTERNAL BmGetData (lpobj, cfFormat, lphandle)
LPOBJECT_BM     lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_BITMAP) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = lpobj->hBitmap))
        return OLE_ERROR_BLANK;
    return OLE_OK;

}




OLESTATUS FARINTERNAL BmLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    LPOBJECT_BM lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;

    if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG))) {
        if (!GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG))) 
            if (!GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(DWORD))) 
            if (BmStreamRead (lpstream, lpobj)) {
                *lplpoleobject = (LPOLEOBJECT)lpobj;
                return OLE_OK;
            }
    }
    
    OleDelete ((LPOLEOBJECT)lpobj);
    return OLE_ERROR_STREAM;;
}



OLESTATUS INTERNAL BmStreamWrite (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_BM     lpobj;
{
    HANDLE      hBits;
    LPSTR       lpBits;
    int         retVal = OLE_ERROR_STREAM;
    BITMAP      bm;
    DWORD       dwSize;  // size of bit array

    dwSize = lpobj->sizeBytes - sizeof(BITMAP);
    
    if (hBits = GlobalAlloc (GMEM_MOVEABLE, dwSize)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (GetBitmapBits (lpobj->hBitmap, dwSize, lpBits)) {
                GetObject (lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm);
                if (!PutBytes (lpstream, (LPSTR) &bm, sizeof(BITMAP)))
                    if (!PutBytes (lpstream, (LPSTR) lpBits, dwSize))
                        retVal = OLE_OK;
            }
            GlobalUnlock(hBits);
        } else
            retVal = OLE_ERROR_MEMORY;
        GlobalFree(hBits);
    } else
        retVal = OLE_ERROR_MEMORY;

    return retVal;
}



BOOL INTERNAL BmStreamRead (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_BM     lpobj;
{
    HANDLE      hBits;
    LPSTR       lpBits;
    BOOL        retVal = FALSE;
    BITMAP      bm;
    POINT       point;

    if (GetBytes (lpstream, (LPSTR)&bm, sizeof(BITMAP)))
        return FALSE;

    lpobj->sizeBytes = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
                       ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    
    if (hBits = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpBits = (LPSTR) GlobalLock (hBits)) {
            if (!GetBytes(lpstream, lpBits, lpobj->sizeBytes)) {
                if (lpobj->hBitmap = CreateBitmap (bm.bmWidth,
                                            bm.bmHeight,
                                            bm.bmPlanes, 
                                            bm.bmBitsPixel, 
                                            lpBits)) {
                    retVal = TRUE;
                    lpobj->xSize = point.x = bm.bmWidth;
                    lpobj->ySize = point.y = bm.bmHeight;
                    
                    // size of (bitmap header + bits)
                    lpobj->sizeBytes += sizeof(BITMAP);
#ifdef OLD                    
                    // !!! We shouldn't do the conversion. The info should be
                    // part of the stream.
                    if (!lpobj->head.cx) {
                        ConvertToHimetric (&point);
                        lpobj->head.cx = (LONG) point.x;
                        lpobj->head.cy = (LONG) point.y;
                    }
#endif                  
                 }
             }
             GlobalUnlock(hBits);
        }
        GlobalFree(hBits);
    }
    return  retVal;
}


OLESTATUS FARINTERNAL BmPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HBITMAP     hBitmap;

    *lplpoleobject = NULL;

    if ((hBitmap = (HBITMAP) GetClipboardData(CF_BITMAP)) == NULL)
        return OLE_ERROR_MEMORY;

    if (!(*lplpoleobject = (LPOLEOBJECT) BmCreateObject (hBitmap, 
                                                lpclient, FALSE, lhclientdoc,
                                                lpobjname, objType)))
        return OLE_ERROR_MEMORY;
    
    return OLE_OK;

}


LPOBJECT_BM INTERNAL BmCreateObject (hBitmap, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HBITMAP     hBitmap;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_BM     lpobj;
    
    if (lpobj = BmCreateBlank (lhclientdoc, lpobjname, objType)) {
        if (BmChangeData (lpobj, hBitmap, lpclient, fDelete) != OLE_OK) {
            BmRelease (lpobj);
            lpobj = NULL;
        }
    }

    return lpobj;
}


// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewBitmap will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL BmChangeData (lpobj, hNewBitmap, lpclient, fDelete)
LPOBJECT_BM lpobj;
HBITMAP     hNewBitmap;
LPOLECLIENT lpclient;
BOOL        fDelete;
{
    BITMAP      bm;
    DWORD       dwSize;
    HBITMAP     hOldBitmap;
    
    hOldBitmap = lpobj->hBitmap; 

    if (!fDelete) {
        if (!(hNewBitmap = BmDuplicate (hNewBitmap, &dwSize, &bm)))
            return OLE_ERROR_MEMORY;
    }
    else {
        if (!GetObject (hNewBitmap, sizeof(BITMAP), (LPSTR) &bm)) {
            DeleteObject (hNewBitmap);
            return OLE_ERROR_MEMORY;
        }

        dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
                 ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);
    }

    BmUpdateStruct (lpobj, lpclient, hNewBitmap, &bm, dwSize);
    if (hOldBitmap)
        DeleteObject (hOldBitmap);
    
    return OLE_OK;
}


void INTERNAL BmUpdateStruct (lpobj, lpclient, hBitmap, lpBm, dwBytes)
LPOBJECT_BM lpobj;
LPOLECLIENT lpclient;
HBITMAP     hBitmap;
LPBITMAP    lpBm;
DWORD       dwBytes;
{
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->xSize = point.x = lpBm->bmWidth;
    lpobj->ySize = point.y = lpBm->bmHeight;
    GetHimetricUnits (hBitmap, &point);
    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->sizeBytes = dwBytes + sizeof(BITMAP);
    lpobj->hBitmap = hBitmap;
}



LPOBJECT_BM FARINTERNAL BmCreateBlank (lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT hobj;
    LPOBJECT_BM lpobj;

    if ((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_BM)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_BM) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblBM;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    
    if (objType == CT_STATIC) 
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                    (LPOLEOBJECT) lpobj, lpobjname);

    return lpobj;
}



HBITMAP FARINTERNAL BmDuplicate (hold, lpdwSize, lpBm)
HBITMAP     hold;
DWORD FAR * lpdwSize;
LPBITMAP    lpBm;
{
    HBITMAP     hnew;
    HANDLE      hMem;
    LPSTR       lpMem;
    LONG        retVal = TRUE;
    DWORD       dwSize;
    BITMAP      bm;
    DWORD       dwExtents = NULL;
    
     // !!! another way to duplicate the bitmap

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
             ((DWORD) bm.bmPlanes) * ((DWORD) bm.bmBitsPixel);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = GlobalLock (hMem))){
        GlobalFree (hMem);
        return NULL;
    }
    
    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight, 
                    bm.bmPlanes, bm.bmBitsPixel, NULL))
        retVal = SetBitmapBits (hnew, dwSize, lpMem);

    GlobalUnlock (hMem);
    GlobalFree (hMem);

    if (hnew && (!retVal)) {
        DeleteObject (hnew);
        hnew = NULL;
    }
    *lpdwSize = dwSize;
    if (lpBm)
        *lpBm = bm;
    
    if (dwExtents = GetBitmapDimension (hold))
        SetBitmapDimension (hnew, LOWORD(dwExtents), HIWORD(dwExtents));
        
    return hnew;
}


void INTERNAL GetHimetricUnits(HBITMAP hBitmap, LPPOINT lpPoint)
{
    HDC     hdc;
    DWORD   dwDim;
    
    if (dwDim = GetBitmapDimension (hBitmap)) {
        lpPoint->x = 10 * LOWORD(dwDim);
        lpPoint->y = - (10 * HIWORD(dwDim));
        return;
    }
    
    // clip if it exceeds maxPixels. Note that we have a limitation of 
    // 0x8FFF HIMETRIC units in OLE1.0
        
    if (lpPoint->x > maxPixelsX)
        lpPoint->x = maxPixelsX;
    
    if (lpPoint->y > maxPixelsY)
        lpPoint->y = maxPixelsY;
    
    if (hdc = GetDC (NULL)) {
        lpPoint->x = MulDiv (lpPoint->x, 2540, 
                         GetDeviceCaps (hdc, LOGPIXELSX));
        lpPoint->y = - MulDiv (lpPoint->y, 2540,
                         GetDeviceCaps (hdc, LOGPIXELSY));
        ReleaseDC (NULL, hdc);
    }
    else {
        lpPoint->x = 0;
        lpPoint->y = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\defcreat.c ===
/****************************** Module Header ******************************\
* Module Name: defcreat.c
*
* Purpose: Handles the various object creation routines, which are exported
*          to the DLL writers.
*
* Created: November 1990
*
* Copyright (c) 1985, 1986, 1987, 1988, 1989  Microsoft Corporation
*
* History:
*   Srinik (11/12/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfNative;


RENDER_ENTRY stdRender[NUM_RENDER] = {
    { "METAFILEPICT",   0, MfLoadFromStream}, 
    { "DIB",            0, DibLoadFromStream},
    { "BITMAP",         0, BmLoadFromStream}
};


OLESTATUS  FARINTERNAL  DefLoadFromStream (lpstream, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, objType, aClass, cfFormat)
LPOLESTREAM         lpstream;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
LONG                objType;
ATOM                aClass;
OLECLIPFORMAT       cfFormat;
{
    OLESTATUS   retVal;
    int         i;

    *lplpobj = NULL;        

    if ((objType == CT_PICTURE) || (objType == CT_STATIC)) {
        for (i = 0; i < NUM_RENDER; i++) {
            if (stdRender[i].aClass == aClass) {
                retVal = (*stdRender[i].Load) (lpstream, lpclient, 
                                lhclientdoc, lpobjname, lplpobj, objType);
                if (aClass)
                    GlobalDeleteAtom (aClass);
                return retVal;
            }
        }
        
        return GenLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
    else {
        return LeLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname,
                        lplpobj, objType, aClass, cfFormat);
    }
}


OLESTATUS FAR PASCAL DefCreateFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    if (objType == CT_EMBEDDED)
        return EmbPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat);
    
    if (objType == CT_LINK)
        return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                    optRender, cfFormat, cfOwnerLink);

    return OLE_ERROR_CLIPBOARD;                          
}




OLESTATUS FAR PASCAL DefCreateLinkFromClip (lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LnkPaste (lpclient, lhclientdoc, lpobjname, lplpobj, 
                optRender, cfFormat, cfObjectLink);
}


OLESTATUS FAR PASCAL DefCreateFromTemplate (lpprotocol, lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LeCreateFromTemplate (lpclient,
                    lptemplate,
                    lhclientdoc,
                    lpobjname,
                    lplpoleobject,
                    optRender,
                    cfFormat);
}


OLESTATUS FAR PASCAL DefCreate (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return LeCreate (lpclient,
                lpclass,
                lhclientdoc,
                lpobjname,
                lplpoleobject,
                optRender,
                cfFormat);
}



OLESTATUS FAR PASCAL DefCreateFromFile (lpprotocol, lpclient, lpclass, lpfile, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        NULL,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_EMBEDDED);
}


OLESTATUS FAR PASCAL DefCreateLinkFromFile (lpprotocol, lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    return CreateEmbLnkFromFile (lpclient,
                        lpclass,
                        lpfile,
                        lpitem,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        CT_LINK);
}


OLESTATUS FAR PASCAL DefCreateInvisible (lpprotocol, lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, fActivate)
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    return LeCreateInvisible (lpclient,
                        lpclass,
                        lhclientdoc,
                        lpobjname,
                        lplpoleobject,
                        optRender,
                        cfFormat,
                        fActivate);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\doc.c ===
/****************************** Module Header ******************************\
* Module Name: doc.c 
*
* PURPOSE: Contains client document maipulation routines.
*
* Created: Jan 1991
*
* Copyright (c) 1991  Microsoft Corporation
*
* History:
*   Srinik  01/11/1191  Orginal
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#ifdef FIREWALLS
extern BOOL     bShowed;
extern void FARINTERNAL ShowVersion (void);
#endif

LPCLIENTDOC lpHeadDoc = NULL;
LPCLIENTDOC lpTailDoc  = NULL;

extern ATOM aClipDoc;
extern int  iUnloadableDll;

#pragma alloc_text(_TEXT, CheckClientDoc, CheckPointer)


OLESTATUS FAR PASCAL OleRegisterClientDoc (lpClassName, lpDocName, future, lplhclientdoc)
LPSTR               lpClassName;
LPSTR               lpDocName;
LONG                future;
LHCLIENTDOC FAR *   lplhclientdoc;
{
    HANDLE      hdoc = NULL;
    LPCLIENTDOC lpdoc;
    OLESTATUS   retVal;
    ATOM        aClass, aDoc;
    
    
#ifdef FIREWALLS
    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX))
        ShowVersion ();
#endif

    Puts ("OleRegisterClientDoc");

    PROBE_MODE(bProtMode);
    FARPROBE_WRITE(lplhclientdoc);
    *lplhclientdoc = NULL;
    FARPROBE_READ(lpClassName);
    FARPROBE_READ(lpDocName);
    if (!lpDocName[0])
        return OLE_ERROR_NAME;
    
    aDoc = GlobalAddAtom (lpDocName); 
    aClass = GlobalAddAtom (lpClassName);

    if (!(hdoc = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT | GMEM_SHARE, 
                        sizeof(CLIENTDOC)))
            || !(lpdoc = (LPCLIENTDOC) GlobalLock (hdoc))) {
        retVal =  OLE_ERROR_MEMORY;
        goto err;
    }

    lpdoc->docId[0] = 'C';
    lpdoc->docId[1] = 'D';
    lpdoc->aClass   = aClass;
    lpdoc->aDoc     = aDoc;
    lpdoc->hdoc     = hdoc;
        
    // Documents are doubly linked
        
    if (!lpHeadDoc) {
#ifdef FIREWALLS        
        ASSERT(!lpTailDoc, "lpTailDoc is not NULL");
#endif  
        lpHeadDoc = lpTailDoc = lpdoc;
    }
    else {
        lpTailDoc->lpNextDoc = lpdoc;
        lpdoc->lpPrevDoc = lpTailDoc;
        lpTailDoc = lpdoc;
    }
    
    *lplhclientdoc = (LHCLIENTDOC) lpdoc;

    // inform the link manager;
    return OLE_OK;
    
err:
    if (aClass) 
        GlobalDeleteAtom (aClass);

    if (aDoc)
        GlobalDeleteAtom (aDoc);    
    
    if (hdoc)
        GlobalFree (hdoc);

    return retVal;
}


OLESTATUS FAR PASCAL OleRevokeClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    LPCLIENTDOC lpdoc;
    
    Puts ("OleRevokeClientDoc");

    // if there is any handler dll that can be freed up, free it now. 
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll) 
        UnloadDll ();
    
    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (lpdoc->lpHeadObj) {
        ASSERT (0, "OleRevokeClientDoc() called without freeing all objects");
        return OLE_ERROR_NOT_EMPTY;
    }
    
    if (lpdoc->aClass)
        GlobalDeleteAtom (lpdoc->aClass);   

    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);

    // if only one doc is in the list then it's prev and next docs are NULL
        
    if (lpdoc == lpHeadDoc)
        lpHeadDoc = lpdoc->lpNextDoc;

    if (lpdoc == lpTailDoc)
        lpTailDoc = lpdoc->lpPrevDoc;       

    if (lpdoc->lpPrevDoc)
        lpdoc->lpPrevDoc->lpNextDoc = lpdoc->lpNextDoc;

    if (lpdoc->lpNextDoc)   
        lpdoc->lpNextDoc->lpPrevDoc = lpdoc->lpPrevDoc;     

    GlobalUnlock (lpdoc->hdoc);
    GlobalFree (lpdoc->hdoc);
    
    // inform link manager
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRenameClientDoc (lhclientdoc, lpNewDocName)
LHCLIENTDOC lhclientdoc;
LPSTR       lpNewDocName;
{
    LPCLIENTDOC lpdoc;
    ATOM        aNewDoc;
    LPOLEOBJECT lpobj = NULL;
    
    if (!CheckClientDoc (lpdoc = (LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    FARPROBE_READ(lpNewDocName);
    
    aNewDoc = GlobalAddAtom (lpNewDocName);
    if (aNewDoc == lpdoc->aDoc) {
        if (aNewDoc)
            GlobalDeleteAtom (aNewDoc);
        return OLE_OK;
    }
    
    // Document name has changed. So, change the topic of all embedded objects
    if (lpdoc->aDoc)
        GlobalDeleteAtom (lpdoc->aDoc);
    lpdoc->aDoc = aNewDoc;
    
    while (lpobj = DocGetNextObject (lpdoc, lpobj)) {
        if (lpobj->ctype == CT_EMBEDDED)
            if (OleQueryReleaseStatus (lpobj) != OLE_BUSY)
                SetEmbeddedTopic ((LPOBJECT_LE) lpobj);
    }
    
    return OLE_OK;
}


OLESTATUS FAR PASCAL OleRevertClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    // if there is any handler dll that can be freed up, free it now.
    // Otherwise it might become too late if the app quits.
    if (iUnloadableDll) 
        UnloadDll ();
    
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}


OLESTATUS FAR PASCAL OleSavedClientDoc (lhclientdoc)
LHCLIENTDOC lhclientdoc;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    return OLE_OK;
}

OLESTATUS FAR PASCAL OleEnumObjects (lhclientdoc, lplpobj)
LHCLIENTDOC         lhclientdoc;
LPOLEOBJECT FAR *   lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;

    FARPROBE_WRITE(lplpobj);

    if (*lplpobj) {
        // we are making lhclientdoc field of the object NULL at deletion 
        // time. The check (*lpobj->lhclientdoc != lhclientdoc) will take care
        // of the case where same chunk of memory is allocated again for the
        // same pointer and old contents are not erased yet.
        if (!FarCheckObject (*lplpobj) 
                || ((*lplpobj)->lhclientdoc != lhclientdoc))
            return OLE_ERROR_OBJECT;    
    }
    
    *lplpobj = DocGetNextObject ((LPCLIENTDOC) lhclientdoc, *lplpobj);
    return OLE_OK;
}


    
LPOLEOBJECT INTERNAL DocGetNextObject (lpdoc, lpobj)
LPCLIENTDOC lpdoc;
LPOLEOBJECT lpobj;
{
    if (!lpobj)
        return lpdoc->lpHeadObj;
    
    return lpobj->lpNextObj;
}


BOOL FARINTERNAL CheckClientDoc (lpdoc)
LPCLIENTDOC lpdoc;
{
    if (!CheckPointer(lpdoc, WRITE_ACCESS))
        return FALSE;

    if ((lpdoc->docId[0] == 'C') && (lpdoc->docId[1] == 'D'))
        return TRUE;
    return FALSE;
}


void FARINTERNAL DocAddObject (lpdoc, lpobj, lpobjname)
LPCLIENTDOC lpdoc;
LPOLEOBJECT lpobj;
LPSTR       lpobjname;
{
    if (lpobjname) 
        lpobj->aObjName = GlobalAddAtom (lpobjname);
    else
        lpobj->aObjName = NULL;
    
    // Objects of a doc are doubly linked
        
    if (!lpdoc->lpHeadObj)
        lpdoc->lpHeadObj = lpdoc->lpTailObj = lpobj;
    else {
        lpdoc->lpTailObj->lpNextObj = lpobj;
        lpobj->lpPrevObj = lpdoc->lpTailObj;
        lpdoc->lpTailObj = lpobj;
    }
    lpobj->lhclientdoc = (LHCLIENTDOC)lpdoc;
}


void FARINTERNAL DocDeleteObject (lpobj)
LPOLEOBJECT lpobj;
{
    LPCLIENTDOC lpdoc;

    if (!(lpdoc = (LPCLIENTDOC) lpobj->lhclientdoc))
        return;

    if (lpobj->aObjName) {
        GlobalDeleteAtom (lpobj->aObjName);
        lpobj->aObjName = NULL;
    }
    
    // Remove this obj from object chain of the relevant client doc.
    // The objects of a doc are doubly linked.
                
    if (lpdoc->lpHeadObj == lpobj)
        lpdoc->lpHeadObj = lpobj->lpNextObj;

    if (lpdoc->lpTailObj == lpobj)
        lpdoc->lpTailObj = lpobj->lpPrevObj;       

    if (lpobj->lpPrevObj)
        lpobj->lpPrevObj->lpNextObj = lpobj->lpNextObj;

    if (lpobj->lpNextObj)   
        lpobj->lpNextObj->lpPrevObj = lpobj->lpPrevObj;     

    lpobj->lhclientdoc = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\dib.c ===
/****************************** Module Header ******************************\
* Module Name: DIB.C
*
* Handles all API routines for the device independent bitmap sub-dll of 
* the ole dll.
*
* Created: Oct-1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik, Raor  (../../1990,91)   Designed, coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

void FARINTERNAL DibGetExtents (LPSTR, LPPOINT);

#pragma alloc_text(_TEXT, DibSaveToStream, DibLoadFromStream, DibStreamRead, GetBytes, PutBytes, PutStrWithLen, DibGetExtents)

OLEOBJECTVTBL    vtblDIB  = {

        ErrQueryProtocol,   // check whether the speced protocol is supported

        DibRelease,         // Release          
        ErrShow,            // Show
        ErrPlay,            // show
        DibGetData,         // Get the object data
        ErrSetData,         // Set the object data
        ErrSetTargetDevice, //
    
        ErrSetBounds,       // set viewport bounds
        DibEnumFormat,      // enumerate supported formats
        ErrSetColorScheme,  //
        DibRelease,         // delete
        ErrSetHostNames,    //

        DibSaveToStream,    // write to file
        DibClone,           // clone object
        ErrCopyFromLink,    // Create embedded from Lnk

        DibEqual,           // compares the given objects for data equality

        DibCopy,            // copy to clip

        DibDraw,            // draw the object
            
        ErrActivate,        // open
        ErrExecute,         // excute 
        ErrClose,           // Stop
        ErrUpdate,          // Update
        ErrReconnect,       // Reconnect

        ErrObjectConvert,   // convert object to specified type

        ErrGetUpdateOptions, // update options
        ErrSetUpdateOptions, // update options

        ObjRename,         // Change Object name
        ObjQueryName,      // Get current object name
            
        ObjQueryType,      // Object type
        DibQueryBounds,    // QueryBounds
        ObjQuerySize,      // Find the size of the object
        ErrQueryOpen,      // Query open
        ErrQueryOutOfDate, // query whether object is current
            
        ErrQueryRelease,      // release related stuff
        ErrQueryRelease,
        ErrQueryRelease,

        ErrRequestData,    // requestdata
        ErrObjectLong,     // objectLong
        DibChangeData        // change data of the existing object
};



OLESTATUS  FARINTERNAL DibRelease (lpobj)
LPOBJECT_DIB     lpobj;
{
    HOBJECT hobj;

    if (lpobj->hDIB){
        GlobalFree (lpobj->hDIB);
        lpobj->hDIB = NULL;
    }

    if (lpobj->head.lhclientdoc)
        DocDeleteObject ((LPOLEOBJECT) lpobj);
    
    if (hobj = lpobj->head.hobj){
        lpobj->head.hobj = NULL;
        GlobalUnlock (hobj);
        GlobalFree (hobj);
    }

    return OLE_OK;
}



OLESTATUS FARINTERNAL DibSaveToStream (lpobj, lpstream)
LPOBJECT_DIB    lpobj;
LPOLESTREAM     lpstream;
{
    LPSTR   lpDIBbuf;
    
    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;
    
    if (PutBytes (lpstream, (LPSTR) &dwVerToFile, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.ctype, sizeof(LONG)))
        return  OLE_ERROR_STREAM;

    if (PutStrWithLen (lpstream, (LPSTR)"DIB"))
        return OLE_ERROR_STREAM;

    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (PutBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        return OLE_ERROR_STREAM;

    lpobj->sizeBytes = GlobalSize (lpobj->hDIB);
    if (PutBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        return OLE_ERROR_STREAM;
    
    if (!(lpDIBbuf = GlobalLock (lpobj->hDIB)))
        return OLE_ERROR_MEMORY;

    if (PutBytes (lpstream, lpDIBbuf, lpobj->sizeBytes))
        return OLE_ERROR_STREAM;
    
    GlobalUnlock (lpobj->hDIB);
    return OLE_OK;
}



OLESTATUS FARINTERNAL  DibClone (lpobjsrc, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOBJECT_DIB        lpobjsrc;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOBJECT_DIB FAR *  lplpobj;
{
    if (!CheckClientDoc ((LPCLIENTDOC) lhclientdoc))
        return OLE_ERROR_HANDLE;
    
    if (!(*lplpobj = DibCreateObject (lpobjsrc->hDIB, lpclient, FALSE,
                            lhclientdoc, lpobjname, lpobjsrc->head.ctype)))
        return OLE_ERROR_MEMORY;
    else
        return OLE_OK;
}



OLESTATUS FARINTERNAL  DibEqual (lpobj1, lpobj2)
LPOBJECT_DIB lpobj1;
LPOBJECT_DIB lpobj2;
{
    if (CmpGlobals (lpobj1->hDIB, lpobj1->hDIB))
        return OLE_OK;
    
    return OLE_ERROR_NOT_EQUAL;
}


OLESTATUS FARINTERNAL DibCopy (lpobj)
LPOBJECT_DIB    lpobj;
{
    HANDLE hDIB;

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    if (!(hDIB = DuplicateGlobal (lpobj->hDIB, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    SetClipboardData (CF_DIB, hDIB);
    return OLE_OK;
}


OLESTATUS FARINTERNAL DibQueryBounds (lpobj, lpRc)
LPOBJECT_DIB    lpobj;
LPRECT          lpRc;
{
    Puts("DibQueryBounds");

    if (!lpobj->hDIB)
        return OLE_ERROR_BLANK;

    lpRc->left     = 0;
    lpRc->top      = 0;
    lpRc->right    = (int) lpobj->head.cx;
    lpRc->bottom   = (int) lpobj->head.cy;
    return OLE_OK;
}



OLECLIPFORMAT FARINTERNAL DibEnumFormat (lpobj, cfFormat)
LPOBJECT_DIB    lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (!cfFormat)
        return CF_DIB;
    
    return NULL;
}


OLESTATUS FARINTERNAL DibGetData (lpobj, cfFormat, lphandle)
LPOBJECT_DIB    lpobj;
OLECLIPFORMAT   cfFormat;
LPHANDLE        lphandle;
{
    if (cfFormat != CF_DIB) 
        return OLE_ERROR_FORMAT;
    
    if (!(*lphandle = lpobj->hDIB))
        return OLE_ERROR_BLANK;
    
    return OLE_OK;
}



LPOBJECT_DIB FARINTERNAL DibCreateObject (hDIB, lpclient, fDelete, lhclientdoc, lpobjname, objType)
HANDLE      hDIB;
LPOLECLIENT lpclient;
BOOL        fDelete;
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    LPOBJECT_DIB    lpobj;

    if (lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)) { 
        if (DibChangeData (lpobj, hDIB, lpclient, fDelete) != OLE_OK) {
            DibRelease (lpobj);
            lpobj = NULL;
        }
    }
    
    return lpobj;
}



// If the routine fails then the object will be left with it's old data.
// If fDelete is TRUE, then hNewDIB will be deleted whether the routine
// is successful or not.

OLESTATUS FARINTERNAL DibChangeData (lpobj, hNewDIB, lpclient, fDelete)
LPOBJECT_DIB    lpobj;
HANDLE          hNewDIB;
LPOLECLIENT     lpclient;
BOOL            fDelete;
{
    BITMAPINFOHEADER    bi;
    DWORD               dwSize;
    LPBITMAPINFOHEADER  lpBi;

    if (!hNewDIB)
        return OLE_ERROR_BLANK;
    
    lpBi = (LPBITMAPINFOHEADER) &bi;
    if (!fDelete) {
        if (!(hNewDIB = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE)))
            return OLE_ERROR_MEMORY;
    }
    else {
        // change the ownership to yourself

        HANDLE htmp;
        
        if (!(htmp = GlobalReAlloc (hNewDIB, 0L, GMEM_MODIFY|GMEM_SHARE))) {
            htmp = DuplicateGlobal (hNewDIB, GMEM_MOVEABLE);
            GlobalFree (hNewDIB);
            if (!htmp)
                return OLE_ERROR_MEMORY;
        }
        
        hNewDIB = htmp;
    }
    
    if (!(lpBi = (LPBITMAPINFOHEADER) GlobalLock (hNewDIB))) {
        GlobalFree (hNewDIB);
        return OLE_ERROR_MEMORY;
    }

    dwSize = GlobalSize (hNewDIB);
    if (lpobj->hDIB)
        GlobalFree (lpobj->hDIB);
    DibUpdateStruct (lpobj, lpclient, hNewDIB, lpBi, dwSize);
    return OLE_OK;
}


void INTERNAL DibUpdateStruct (lpobj, lpclient, hDIB, lpBi, dwBytes)
LPOBJECT_DIB        lpobj;
LPOLECLIENT         lpclient;
HANDLE              hDIB;
LPBITMAPINFOHEADER  lpBi;
DWORD               dwBytes;
{
    POINT       point;

    lpobj->head.lpclient = lpclient;
    lpobj->sizeBytes = dwBytes;
    
#ifdef OLD  
    lpobj->xSize = point.x = (int) lpBi->biWidth;
    lpobj->ySize = point.y = (int) lpBi->biHeight; 
    ConvertToHimetric (&point);
#else
    DibGetExtents ((LPSTR) lpBi, &point);
#endif

    lpobj->head.cx = (LONG) point.x;
    lpobj->head.cy = (LONG) point.y;
    lpobj->hDIB = hDIB;
}



OLESTATUS FARINTERNAL DibLoadFromStream (lpstream, lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLESTREAM         lpstream;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    LPOBJECT_DIB lpobj = NULL;

    *lplpoleobject = NULL;

    if (!(lpobj = DibCreateBlank (lhclientdoc, lpobjname, objType)))
        return OLE_ERROR_MEMORY;

    lpobj->head.lpclient = lpclient;
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cx, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->head.cy, sizeof(LONG)))
        goto errLoad;
    
    if (GetBytes (lpstream, (LPSTR) &lpobj->sizeBytes, sizeof(LONG)))
        goto errLoad;
    
     if (DibStreamRead (lpstream, lpobj)) {
         *lplpoleobject = (LPOLEOBJECT) lpobj;
         return OLE_OK;
    }

errLoad:    
    OleDelete ((LPOLEOBJECT) lpobj);
    return OLE_ERROR_STREAM;
}



LPOBJECT_DIB FARINTERNAL DibCreateBlank (lhclientdoc, lpobjname, objType)
LHCLIENTDOC lhclientdoc;
LPSTR       lpobjname;
LONG        objType;
{
    HOBJECT hobj;
    LPOBJECT_DIB lpobj;

    if((hobj = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT,sizeof (OBJECT_DIB)))
            == NULL)
        return NULL;

    if (!(lpobj = (LPOBJECT_DIB) GlobalLock (hobj))){
        GlobalFree (hobj);
        return NULL;
    }

    // The structure is ZERO initialized at allocation time. So only the 
    // fields that need to be filled with values other than ZEROS are
    // initialized below
        
    lpobj->head.objId[0]    = 'L';
    lpobj->head.objId[1]    = 'E';
    lpobj->head.mm          = MM_TEXT;
    lpobj->head.ctype       = objType;
    lpobj->head.lpvtbl      = (LPOLEOBJECTVTBL)&vtblDIB;
    lpobj->head.iTable      = INVALID_INDEX;
    lpobj->head.hobj        = hobj;
    
    if (objType == CT_STATIC)
        DocAddObject ((LPCLIENTDOC) lhclientdoc, 
                (LPOLEOBJECT) lpobj, lpobjname);
    return lpobj;
}




BOOL INTERNAL DibStreamRead (lpstream, lpobj)
LPOLESTREAM     lpstream;
LPOBJECT_DIB    lpobj;
{
    HANDLE              hDIBbuf;
    LPSTR               lpDIBbuf;
    BOOL                retVal = FALSE;
    BITMAPINFOHEADER    bi;

    if (GetBytes (lpstream, (LPSTR) &bi, sizeof(bi)))
        return FALSE;

    if (hDIBbuf = GlobalAlloc (GMEM_MOVEABLE, lpobj->sizeBytes)) {
        if (lpDIBbuf = (LPSTR)GlobalLock (hDIBbuf)){
            *((LPBITMAPINFOHEADER) lpDIBbuf) = bi;
            if (!GetBytes (lpstream, lpDIBbuf+sizeof(bi), 
                     (lpobj->sizeBytes - sizeof(bi)))) {

                lpobj->hDIB = hDIBbuf;
#ifdef OLD
                //!!! this info should be part of the stream
                if (!lpobj->head.cx) {
                    DibGetExtents ((LPSTR) lpDIBbuf, &point);
                    lpobj->head.cx = (LONG) point.x;
                    lpobj->head.cy = (LONG) point.y;
                }
#endif
                retVal = TRUE;
            }
            GlobalUnlock(hDIBbuf);
        }
        //* Hang on to the memory allocated for the DIB
    }               
    return  retVal;
}


OLESTATUS FARINTERNAL DibPaste (lpclient, lhclientdoc, lpobjname, lplpoleobject, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
LONG                objType;
{
    HANDLE     hDIB;

    if ((hDIB = GetClipboardData (CF_DIB)) == NULL)
        return  OLE_ERROR_MEMORY;

    *lplpoleobject = (LPOLEOBJECT) DibCreateObject (hDIB, lpclient, FALSE,
                                        lhclientdoc, lpobjname, objType);

    return OLE_OK;

}


void FARINTERNAL DibGetExtents (lpData, lpPoint)
LPSTR   lpData;
LPPOINT lpPoint;
{
    #define HIMET_PER_METER     100000L  // number of HIMETRIC units / meter
        
    LPBITMAPINFOHEADER  lpbmi;
        
    lpbmi = (LPBITMAPINFOHEADER)lpData;
    
    if (!(lpbmi->biXPelsPerMeter && lpbmi->biYPelsPerMeter)) {
        HDC hdc;
        
        hdc = GetDC (NULL);
        lpbmi->biXPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSX),
                                    10000, 254);
        lpbmi->biYPelsPerMeter = MulDiv (GetDeviceCaps (hdc, LOGPIXELSY),
                                    10000, 254);
                                    
        ReleaseDC (NULL, hdc);
    }

    lpPoint->x = (int) (lpbmi->biWidth * HIMET_PER_METER
                            / lpbmi->biXPelsPerMeter);
    lpPoint->y = -(int) (lpbmi->biHeight * HIMET_PER_METER
                            / lpbmi->biYPelsPerMeter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\dde.c ===
/****************************** Module Header ******************************\
* Module Name: DDE.C (Extensible Compound Documents -DDE)
*
* Copyright (c) 1985 - 1991 Microsoft Corporation
*
* PURPOSE: Handles all API routines for the dde sub-dll of the ole dll.
*
* History:
*   Raor,Srinik  (../../90,91)  Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"

#define WIN32S

/* #define GRAPHBUG */


// ### may not need seperate wndproc for system topic!
HANDLE  GetDDEDataHandle (DDEDATA FAR *, WORD, HANDLE);

extern  ATOM        aSystem;
extern  ATOM        aOle;
extern  HANDLE      hInstDLL;


// DocWndProc: Window procedure used to document DDE conversations
long FAR PASCAL DocWndProc(hwnd, message, wParam, lParam)
HWND        hwnd;
unsigned    message;
WORD        wParam;
LONG        lParam;

{
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;



    Puts("DocWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLong (hwnd, 0))
        pedit = lpobj->pDocEdit;

    switch (message){

        case WM_DDE_ACK:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_ACK ", 0);
            if (pedit->bTerminating){
                // ### this error recovery may not be correct.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch(pedit->awaitAck){

                case AA_INITIATE:
                    HandleAckInitMsg (pedit, (HWND)wParam);
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));
                    break;

                case AA_REQUEST:
                case AA_UNADVISE:
                case AA_EXECUTE:
                case AA_ADVISE:
                    HandleAck (lpobj, pedit, lParam);
                    break;

                case AA_POKE:

                    // freeing pokedata is done in handleack
                    HandleAck (lpobj, pedit, lParam);
                    break;

                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;

            } // end of switch
            break;

        case WM_TIMER:
            HandleTimerMsg (lpobj, pedit);
            break;

        case WM_DDE_DATA:
#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_DATA",0);
            HandleDataMsg (lpobj, LOWORD(lParam), HIWORD(lParam));
            break;

        case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("WM_DDE_TERMINATE",0);
            HandleTermMsg (lpobj, pedit, (HWND)wParam, TRUE);
            break;

        case WM_DESTROY:

#ifdef  FIREWALLS
        ASSERT (pedit, "Doc conv channel missing");
#endif
            DEBUG_OUT ("Client window being destroyed", 0)
            pedit->hClient = NULL;
            break;

        default:
            return DefWindowProc (hwnd, message, wParam, lParam);

    }
    return 0L;
}



// SrvrWndProc: Window Procedure for System Topic DDE conversations
// wndproc for system topic

long FAR PASCAL SrvrWndProc(hwnd, message, wParam, lParam)
HWND        hwnd;
unsigned    message;
WORD        wParam;
LONG        lParam;

{
    PEDIT_DDE   pedit = NULL;
    LPOBJECT_LE lpobj  = NULL;

    Puts("SysWndProc");

    if (lpobj  = (LPOBJECT_LE) GetWindowLong (hwnd, 0))
        pedit = lpobj->pSysEdit;

    switch (message){

       case WM_DDE_ACK:

#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif

            DEBUG_OUT ("SYS: WM_DDE_ACK",0);

            if(pedit->bTerminating){
                //### Error recovery may not be OK.
                DEBUG_OUT ("No action due to termination process",0)
                break;
            }

            switch (pedit->awaitAck) {


                case AA_INITIATE:

#ifdef      HISTORY
                    if (GetWindowWord ((HWND)wParam, GWW_HINSTANCE) == pedit->hInst ||
                            IsSrvrDLLwnd ((HWND)wParam, pedit->hInst)) {
                        // For exact instance match or for
                        // DLL instance match, keep the new one
#ifdef  FIREWALLS
        ASSERT (!pedit->hServer, "Two instances are matching");
#endif

                        pedit->hServer = (HWND)wParam;
                    } else {

                        ++pedit->extraTerm;
                        // This post directly is alright since we are
                        // terminating extra initiates.

                        PostMessage ((HWND)wParam,
                                WM_DDE_TERMINATE, hwnd, 0);
                    }
#else

                    HandleAckInitMsg (pedit, (HWND)wParam);
#endif
                    if (LOWORD(lParam))
                        GlobalDeleteAtom (LOWORD(lParam));
                    if (HIWORD(lParam))
                        GlobalDeleteAtom (HIWORD(lParam));

                    break;

                case AA_EXECUTE:
                    HandleAck(lpobj, pedit, lParam);
                    break;


                default:
                    DEBUG_OUT ("received ACK We don't know how to handle ",0)
                    break;


            }

            break;

       case WM_TIMER:
            HandleTimerMsg (lpobj, pedit);
            break;

       case WM_DDE_TERMINATE:

#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            HandleTermMsg (lpobj, pedit, (HWND)wParam, FALSE);
            break;

       case WM_DESTROY:
#ifdef  FIREWALLS
        ASSERT (pedit, "sys conv edit block missing");
#endif
            DEBUG_OUT ("destroy window for the sys connection", 0);
            pedit->hClient = NULL;
            break;


       default:
            return DefWindowProc (hwnd, message, wParam, lParam);

       }
       return 0L;
}

void    INTERNAL    HandleTimerMsg (lpobj, pedit)
PEDIT_DDE   pedit;
LPOBJECT_LE lpobj;
{


    // Since there is only one timer for each client, just
    // repost the message and delete the timer.

    KillTimer (pedit->hClient, 1);
    pedit->wTimer = 0;

    if (PostMessageToServer(pedit, pedit->msg, pedit->lParam))
        return ; // return something.

    // Postmessage failed. We need to getback to the main stream of
    // commands for the object.
    HandleAck (lpobj, pedit, pedit->lParam);
    return ;
}


void INTERNAL   HandleTermMsg (lpobj, pedit, hwndPost, bDoc)
LPOBJECT_LE     lpobj;
PEDIT_DDE       pedit;
HWND            hwndPost;
BOOL            bDoc;
{
    WORD    asyncCmd;
    BOOL    bBusy;

    if (pedit->hServer != hwndPost){
        DEBUG_OUT ("Got terminate for extra conversation",0)
        if (--pedit->extraTerm == 0 && pedit->bTerminating)
            ScheduleAsyncCmd (lpobj);
        return;

    }

    if (!pedit->bTerminating){

        // If we are waiting for any ack, then goto next step with error

        // delete any data if we were in busy mode.
        bBusy = DeleteBusyData (lpobj, pedit);

        asyncCmd = lpobj->asyncCmd;
        PostMessageToServer(pedit, WM_DDE_TERMINATE, NULL);
        pedit->hServer = NULL;
        if (pedit->awaitAck || bBusy) {
            // Set error and goto next step.
            lpobj->subErr = OLE_ERROR_COMM;
            pedit->awaitAck = NULL;
            ScheduleAsyncCmd (lpobj);
        }

        // If the command is delete, do not delete
        // the edit blocks. It will be deleted
        // in the OleLnkDelete routine and for delete it is
        // possible that by the time we come here, the object
        // may not exist at all.

        if (asyncCmd != OLE_DELETE){
            // QueryOpen() is done because excel is sending WM_DDE_TERMINATE
            // for system without sending for doc in case of failure.

            if (bDoc || QueryOpen (lpobj)) {
                // if the termination is for document and no async command
                // terminate the server conversation also.
                if ((asyncCmd == OLE_NONE) || (asyncCmd == OLE_REQUESTDATA)
                       || (asyncCmd == OLE_OTHER) || (asyncCmd == OLE_SETDATA)
                       || (asyncCmd == OLE_RUN) || (asyncCmd == OLE_SHOW)
                       || (asyncCmd == OLE_SETUPDATEOPTIONS)) {
                    if (lpobj->pDocEdit->awaitAck)
                        // we are waiting for an ack on Doc channel. So start
                        // the unlaunch process after we get the ack.
                        lpobj->bUnlaunchLater = TRUE;
                    else
                        CallEmbLnkDelete (lpobj);
                } else {
                    if (bDoc)
                        DeleteDocEdit (lpobj);

                }
            }else
                DeleteSrvrEdit (lpobj);

        }
    } else {
        pedit->hServer = NULL;
        if (pedit->extraTerm == 0)
            ScheduleAsyncCmd (lpobj);
    }
}

#ifdef FIREWALLS
BOOL INTERNAL CheckAtomValid (ATOM aItem)
{
    char    buffer[MAX_ATOM];
    int     len, val;


        Puts("CheckAtomValid");

    if (aItem == NULL)
             return TRUE;

    val = GlobalGetAtomName (aItem, buffer, MAX_ATOM);
    len = lstrlen (buffer);
    return ((val != 0) && (val == len));
}
#endif




//  HandleAckInitMsg: Handles WM_DDE_ACKs received while in initiate state.  If
//  this is the first reply, save its window handle.  If multiple replies
//  are received, take the one with the prefered instance, if there is
//  one.  Keep a count of WM_DDE_TERMINATEs we send so that we don't shut
//  the window until we get all of the responses for  WM_DDE_TERMINATEs.

void INTERNAL HandleAckInitMsg (pedit, hserver)
PEDIT_DDE      pedit;
HWND           hserver;
{

    Puts("HandleAckInitMsg");

    if (pedit->hServer){
        // just take the very first one. Direct post is OK
        PostMessage (hserver, WM_DDE_TERMINATE, pedit->hClient, 0);
        ++pedit->extraTerm;
    } else
        pedit->hServer = hserver;

}


// HandleAck: returns 0 if <ack> is not positive, else non-0.  Should probably be
//  a macro.

BOOL INTERNAL HandleAck (lpobj, pedit, lParam)
LPOBJECT_LE     lpobj;
PEDIT_DDE       pedit;
DWORD           lParam;
{

    BOOL    retval = TRUE;


    // check for busy bit
    if ((LOWORD (lParam) & 0x4000) && ContextCallBack (lpobj, OLE_QUERY_RETRY)){
        // we got busy from the server. create a timer and wait for time out.

        // We do not need makeprocinstance since, DLLs are single insance, all
        // we need to do is export for this function.

        if (pedit->wTimer = SetTimer (pedit->hClient, 1, 3000, NULL))
            return TRUE;
    }

    // even if the client got terminate we have to go thru this path.

    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }

    if (pedit->awaitAck == AA_POKE)
        // We have to free the data first. Handleack can trigger
        // another Poke (like pokehostnames)
        FreePokeData (lpobj, pedit);

    if (pedit->awaitAck == AA_EXECUTE)
        GlobalFree (HIWORD (lParam));
    else {
        ASSERT (CheckAtomValid(HIWORD(lParam)),"Invalid atom in ACK")
        if (HIWORD (lParam))
            GlobalDeleteAtom (HIWORD (lParam));
    }

    if (!(LOWORD (lParam) & 0x8000)) {
        // error case. set the error
        DEBUG_OUT ("DDE ACK with failure", 0)

        if (lpobj->errHint){
            lpobj->subErr = lpobj->errHint;
            lpobj->errHint = OLE_OK;
        } else
            lpobj->subErr = OLE_ERROR_COMM;

        retval = FALSE;

        if (pedit->awaitAck == AA_ADVISE) {

#ifdef  ASSERT
        ASSERT (pedit->hopt, "failed advise, options block missing");
#endif
           GlobalFree (pedit->hopt);
        }
    }

    pedit->hopt = NULL;
    pedit->awaitAck = NULL;
    ScheduleAsyncCmd (lpobj);
    return retval;
}

// HandleDataMsg: Called for WM_DDE_DATA message.  If data is from an
//  ADVISE-ON-CLOSE and this is there are no more outstanding
//  ADVISE-ON-CLOSE requests, close the document and end the
//  conversation.

void INTERNAL HandleDataMsg (lpobj, hdata, aItem)
LPOBJECT_LE     lpobj;
HANDLE          hdata;
ATOM            aItem;
{
    DDEDATA         far *lpdata = NULL;
    BOOL            fAck;
    BOOL            fRelease;
    int             options;
    PEDIT_DDE       pedit;

    Puts("HandleDataMsg");

    if (ScanItemOptions (aItem, (int far *)&options) != OLE_OK) {
        DEBUG_OUT (FALSE, "Improper item options");
        return;
    }

    pedit = lpobj->pDocEdit;

    if (hdata) {
        if (!(lpdata = (DDEDATA FAR *) GlobalLock(hdata)))
            return;

        fAck = lpdata->fAckReq;
        fRelease = lpdata->fRelease;

        if (pedit->bTerminating) {
            DEBUG_OUT ("Got DDE_DATA in terminate sequence",0)
            fRelease = TRUE;
        }
        else {
            if (lpdata->cfFormat == (int)cfBinary && aItem == aStdDocName) {
                ChangeDocName (lpobj, (LPSTR)lpdata->Value);
            }
            else
                SetData (lpobj, hdata, options);

            #ifdef  FIREWALLS
                ASSERT (IsWindowValid(pedit->hServer),
                    "Server window missing in HandleDataMsg")
                ASSERT (CheckAtomValid(aItem),"HandleDataMsg invalid atom")
            #endif

            // important that we post the acknowledge first. Otherwist the
            // messages are not in sync.

            if (fAck)
                PostMessageToServer (pedit, WM_DDE_ACK,
                        MAKELONG(POSITIVE_ACK,aItem));
            else if (aItem)
                GlobalDeleteAtom (aItem);

            if ((lpdata->fResponse) && (pedit->awaitAck == AA_REQUEST)) {
                // we sent the request. So, schedule next step.
                pedit->awaitAck = NULL;
                ScheduleAsyncCmd (lpobj);
            }
        }

        GlobalUnlock (hdata);
        if (fRelease)
            GlobalFree (hdata);
    }
    else {
        if (CanCallback (lpobj, options)) {
            if (options != OLE_CLOSED)
                ContextCallBack (lpobj, options);
            else
                lpobj->bSvrClosing = FALSE;

        }
    }

    if (options == OLE_CLOSED && (lpobj->pDocEdit->nAdviseClose <= 2)
            && (lpobj->asyncCmd == OLE_NONE)) {
        InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH, EMBLNKDELETE);
        EmbLnkDelete (lpobj);
    }
}


HANDLE  GetDDEDataHandle (lpdata, cfFormat, hdata)
DDEDATA far     *lpdata;
WORD            cfFormat;
HANDLE          hdata;
{
    if (cfFormat == CF_BITMAP || cfFormat == CF_METAFILEPICT)
         return *(LPHANDLE)lpdata->Value;

    if (cfFormat == CF_DIB)
        return GlobalReAlloc (*(LPHANDLE)lpdata->Value, 0L,
                    GMEM_MODIFY|GMEM_SHARE);

    return CopyData (((LPSTR)lpdata)+4, GlobalSize (hdata) - 4);
}

// SetData: Given the DDEDATA structure from a WM_DDE_DATA message, set up the
//  appropriate data in lpobj.  If the native is in native format, add
//  that field, otherwise, if it is in picture format, ask the picture
//  to add it itself.

void INTERNAL SetData (lpobj, hdata, options)
LPOBJECT_LE     lpobj;
HANDLE          hdata;
int             options;
{
    DDEDATA far     *lpdata   = NULL;
    OLESTATUS       retVal = OLE_ERROR_MEMORY;
    HANDLE          hdataDDE;

    Puts("SetData");

    if (!(lpdata = (DDEDATA far *) (GlobalLock (hdata))))
        goto errrtn;


    if (!(hdataDDE =  GetDDEDataHandle (lpdata, lpdata->cfFormat, hdata))) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errrtn;
    }

    if (lpdata->cfFormat == (int)cfNative) {
        retVal = (*lpobj->head.lpvtbl->ChangeData) ( lpobj,
                        hdataDDE,
                        lpobj->head.lpclient,
                        TRUE);  // use this data, don't copy

    }
    else if (lpdata->cfFormat && (lpdata->cfFormat == GetPictType (lpobj))) {

            retVal = (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                        hdataDDE,
                        lpobj->head.lpclient,
                        lpdata->fRelease);

    } else {
        // case of extra data in the object.
        DeleteExtraData (lpobj);
        lpobj->cfExtra = lpdata->cfFormat;
        lpobj->hextraData = hdataDDE;
        goto end;
    }

    if (retVal == OLE_OK) {
        SetExtents (lpobj);
        if (CanCallback (lpobj, options)) {
            if (options == OLE_CLOSED) {
                ContextCallBack (lpobj, OLE_CHANGED);
                ContextCallBack (lpobj, OLE_CLOSED);
                lpobj->bSvrClosing = FALSE;
            }
            else
                ContextCallBack (lpobj, options);
        }
    }

end:
errrtn:
    if (lpdata)
        GlobalUnlock (hdata);

    return;
}


// SysStartConvDDE: Starts a system conversation.  Returns a handle to that
//  conversation, or NULL.

BOOL INTERNAL InitSrvrConv (lpobj, hInst)
LPOBJECT_LE     lpobj;
HANDLE          hInst;
{
    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;

    Puts("InitSrvrConv");

    if (!lpobj->hSysEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL))
            goto errRtn;

    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pSysEdit->hClient, "Sys conv lptr is present");
#endif
        hedit  =  lpobj->hSysEdit;
        pedit =   lpobj->pSysEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if((pedit->hClient = CreateWindow ("OleSrvrWndClass", "",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL)
        goto errRtn;


    lpobj->hSysEdit     = hedit;
    lpobj->pSysEdit     = pedit;
    pedit->hInst        = hInst;
    pedit->awaitAck     = AA_INITIATE;

    SetWindowLong (pedit->hClient, 0, (LONG)lpobj);
    SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
             MAKELONG (lpobj->app, aOle));

    ASSERT (CheckAtomValid(aOle),"systopic invalid atom")

    pedit->awaitAck    = NULL;
    if (pedit->hServer == NULL) {
        pedit->awaitAck    = AA_INITIATE;
        // Now try the System topic
        SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
                 MAKELONG (lpobj->app, aSystem));

        ASSERT (CheckAtomValid(aSystem),"systopic invalid atom")

        pedit->awaitAck    = NULL;
        if (pedit->hServer == NULL) {
            DEBUG_OUT ("Srver connection failed", 0);
            goto errRtn;
        }
    }

    // Put the long ptr handle in the object.
    return TRUE;

errRtn:
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hSysEdit     = NULL;
    lpobj->pSysEdit    = NULL;

    return FALSE;
}


// TermSrvrConv: Ends conversation indicated by hedit.
void INTERNAL TermSrvrConv (lpobj)
LPOBJECT_LE    lpobj;
{
    PEDIT_DDE pedit;

    Puts("TermSrvrConv");


    if (!(pedit = lpobj->pSysEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)){
        lpobj->bAsync        = TRUE;
        pedit->bTerminating = TRUE;
    } else {
        pedit->bTerminating = FALSE;
        lpobj->subErr = OLE_ERROR_TERMINATE;
    }
    return;
}


void INTERNAL  DeleteAbortData (lpobj, pedit)
LPOBJECT_LE    lpobj;
PEDIT_DDE     pedit;
{

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;
    }
    return;


}

BOOL INTERNAL   DeleteBusyData (lpobj, pedit)
LPOBJECT_LE    lpobj;
PEDIT_DDE     pedit;
{

    // kill if any timer active.
    if (pedit->wTimer) {
        KillTimer (pedit->hClient, 1);
        pedit->wTimer = 0;

        if (pedit->hData) {
            GlobalFree (pedit->hData);
            pedit->hData = NULL;
        }

        if (pedit->hopt) {
            GlobalFree (pedit->hopt);
            pedit->hopt = NULL;
        }

        if (pedit->awaitAck && (HIWORD(pedit->lParam))) {
            if (pedit->awaitAck == AA_EXECUTE)
                GlobalFree (HIWORD (pedit->lParam));
            else {
                ASSERT (CheckAtomValid(HIWORD(pedit->lParam)),
                    "Invalid atom in ACK")
                if (HIWORD(pedit->lParam))
                    GlobalDeleteAtom (HIWORD(pedit->lParam));
            }

            // we want to wipe out the HIWORD of lParam
            pedit->lParam &= 0x0000FFFF;
        }

        return TRUE;
    }

    return FALSE;
}

void INTERNAL   DeleteSrvrEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts("deleteSrvrEdit");

    if (!(pedit = lpobj->pSysEdit))
        return;


    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pSysEdit)
        LocalUnlock (lpobj->hSysEdit);

    if (lpobj->hSysEdit)
        LocalFree (lpobj->hSysEdit);

    lpobj->hSysEdit  = NULL;
    lpobj->pSysEdit = NULL;

    return;
}


void INTERNAL   SendStdExit (lpobj)
LPOBJECT_LE    lpobj;
{


    Puts("SendSrvrExit");

    if (!lpobj->pSysEdit)
        return;

    SrvrExecute (lpobj, MapStrToH ("[StdExit]"));

}

void INTERNAL   SendStdClose (lpobj)
LPOBJECT_LE    lpobj;
{


    Puts("SendDocClose");

    if (!lpobj->pDocEdit)
        return;

    DocExecute (lpobj, MapStrToH ("[StdCloseDocument]"));

}


// SrvrExecute: Sends execute command to system conversation.
BOOL INTERNAL SrvrExecute (lpobj, hdata)
LPOBJECT_LE    lpobj;
HANDLE      hdata;
{
    PEDIT_DDE   pedit = NULL;
    int         retval = FALSE;

    Puts("SrvrExecute");

#ifdef  FIREWALLS

    ASSERT (lpobj->hSysEdit, "Sys conv handle missing");
    ASSERT (lpobj->pSysEdit, "sys conv lptr is missing");

#endif
    pedit = lpobj->pSysEdit;

    if (hdata == NULL || pedit == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        return FALSE;
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "In terminate state")
    ASSERT (pedit->awaitAck == NULL, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }


    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, MAKELONG (0, hdata))) {
        // data is being freed in the acknowledge
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_EXECUTE;
        return TRUE;
    } else {
        lpobj->subErr = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}

// StartConvDDE: Starts the document conversation for an object based on
// .app and .topic atoms.
BOOL FARINTERNAL InitDocConv (lpobj, fNetDlg)
LPOBJECT_LE lpobj;
BOOL        fNetDlg;
{

    // ### This routine looks very similar to IitSrvrConv
    // combine with the it

    HANDLE      hedit = NULL;
    PEDIT_DDE   pedit = NULL;
    char        buf[MAX_NET_NAME];
    int         nDrive = 2;     // drive C
    char        cOldDrive;

    Puts("InitDocConv");

    if (QueryOpen (lpobj)){
        DEBUG_OUT ("Attempt to start already existing conversation",0);
        return FALSE;
    }

    cOldDrive = lpobj->cDrive;
    if (CheckNetDrive (lpobj, fNetDlg) != OLE_OK)
        return FALSE;

    if (!lpobj->pDocEdit) {
        hedit = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (EDIT_DDE));

        if (hedit == NULL || ((pedit = (PEDIT_DDE) LocalLock (hedit)) == NULL)){
            lpobj->subErr = OLE_ERROR_MEMORY;
            goto errRtn;
        }
    } else {
#ifdef  FIREWALLS
    ASSERT (!lpobj->pDocEdit->hClient, "Doc conv lptr is present");
#endif
        hedit  =  lpobj->hDocEdit;
        pedit =  lpobj->pDocEdit;
        UtilMemClr ((PSTR) pedit, sizeof (EDIT_DDE));
    }

    if ((pedit->hClient = CreateWindow ("OleDocWndClass", "Window Name",
        WS_OVERLAPPED,0,0,0,0,NULL,NULL, hInstDLL, NULL)) == NULL) {
        lpobj->subErr = OLE_ERROR_MEMORY;
        goto errRtn;
    }
    lpobj->hDocEdit     = hedit;
    lpobj->pDocEdit     = pedit;
    SetWindowLong (pedit->hClient, 0, (LONG)lpobj);

    // buf will filled by netname in the first call to SetNextNetDrive()
    buf[0] = '\0';
    do {
        pedit->awaitAck = AA_INITIATE;

        // !!! Where are the atom counts bumped?

        SendMessage (-1, WM_DDE_INITIATE, pedit->hClient,
                MAKELONG (lpobj->app, lpobj->topic));

        pedit->awaitAck = NULL;

        if (pedit->hServer) {
            if ((cOldDrive != lpobj->cDrive)
                    && (lpobj->asyncCmd != OLE_CREATEFROMFILE))
                ContextCallBack (lpobj, OLE_RENAMED);
            return TRUE;
        }

    } while ((lpobj->head.ctype == CT_LINK) && (lpobj->aNetName)
                && SetNextNetDrive (lpobj, &nDrive, buf)) ;

errRtn:
    if (cOldDrive != lpobj->cDrive) {
        // put back the old drive
        lpobj->cDrive = cOldDrive;
        ChangeTopic (lpobj);
    }

    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (pedit)
        LocalUnlock (hedit);

    if (hedit)
        LocalFree (hedit);

    lpobj->hDocEdit     = NULL;
    lpobj->pDocEdit     = NULL;
    return FALSE;
}


// Execute: Sends an execute string WM_DDE_EXECUTE to the document conversation.
BOOL INTERNAL DocExecute (lpobj, hdata)
LPOBJECT_LE    lpobj;
HANDLE          hdata;
{
    PEDIT_DDE  pedit;

    Puts("DocExecute");
    pedit = lpobj->pDocEdit;

    if (hdata == NULL || pedit == NULL)
        return FALSE;


#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "Execute: terminating")
    ASSERT (pedit->hClient, "Client null")
    ASSERT (IsWindowValid(pedit->hClient),"Invalid client")
    ASSERT (pedit->awaitAck == NULL, "trying to Post msg while waiting for ack")
#endif

    if (lpobj->bOldLink) {
        GlobalFree (hdata);
        return TRUE;
    }

    if (PostMessageToServer (pedit, WM_DDE_EXECUTE, MAKELONG (0, hdata))) {
        // data is being freed in the execute command
        pedit->awaitAck    = AA_EXECUTE;
        lpobj->bAsync       = TRUE;
        return TRUE;
    } else {
        lpobj->subErr    = OLE_ERROR_COMMAND;
        GlobalFree (hdata);
        return FALSE;
    }
}


// EndConvDDE: terminates the doc level conversation.
void INTERNAL TermDocConv (lpobj)
LPOBJECT_LE    lpobj;
{
    PEDIT_DDE pedit;

    Puts ("TermDocConv");

    DEBUG_OUT ("About to terminate convs from destroy",0)

    if (!(pedit = lpobj->pDocEdit))
        return;

    if (PostMessageToServer (pedit, WM_DDE_TERMINATE, 0)) {
        pedit->bTerminating = TRUE;
        lpobj->bAsync        = TRUE;
    } else
        lpobj->subErr = OLE_ERROR_TERMINATE;

    return;

}

// Deletes the document conversdation memory.
void INTERNAL DeleteDocEdit (lpobj)
LPOBJECT_LE    lpobj;
{

    PEDIT_DDE pedit;

    Puts ("DeleteDocEdit");

    if (!(pedit = lpobj->pDocEdit))
        return;

    // delete any data if we were in busy mode.
    DeleteBusyData (lpobj, pedit);

    // Delete if any data blocks.
    if (pedit->hClient)
        DestroyWindow (pedit->hClient);

    if (lpobj->pDocEdit)
        LocalUnlock (lpobj->hDocEdit);

    if (lpobj->hDocEdit)
        LocalFree (lpobj->hDocEdit);

    lpobj->hDocEdit  = NULL;
    lpobj->pDocEdit = NULL;

    return;
}


// LeLauchApp: Launches app based on the ClassName in lpobj.
HANDLE INTERNAL  LeLaunchApp (lpobj)
LPOBJECT_LE lpobj;
{
    struct CMDSHOW
    {
        WORD first;
        WORD second;
    } cmdShow = {2, SW_SHOWNORMAL};

    struct
    {
        WORD wEnvSeg;
        LPSTR lpcmdline;
        struct CMDSHOW FAR *lpCmdShow;
        DWORD dwReserved;
    } paramBlock;

    char    cmdline[MAX_STR];
    char    exeName[MAX_STR];
#ifdef WIN32S
    char    execCmdLine[MAX_STR];
#endif
    HANDLE  hInst;

    #define EMB_STR     " -Embedding "

    Puts("LeLaunchApp");

    GlobalGetAtomName (lpobj->aServer, exeName, MAX_STR);

    if (lpobj->bOldLink) {
        cmdShow.second = SW_SHOWMINIMIZED;
        cmdline[0] = ' ';
        GlobalGetAtomName (lpobj->topic, cmdline + 1, MAX_STR);
    } else {
        lstrcpy ((LPSTR)cmdline, (LPSTR) EMB_STR);

        // For all link servers we want to give the filename on the command
        // line. But Excel is not registering the document before returning
        // from WinMain, if it has auto load macros. So, we want send StdOpen
        // for the old servers, instead of giving the file name on the command
        // line.

        if (lpobj->bOleServer && (lpobj->fCmd & LN_MASK) == LN_LNKACT)
            GlobalGetAtomName (lpobj->topic, cmdline+sizeof(EMB_STR)-1,
                    MAX_STR-sizeof(EMB_STR));
        if (lpobj->fCmd & ACT_MINIMIZE)
            cmdShow.second = SW_SHOWMINIMIZED;
        else if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB))
                    // we want to launch with show in create invisible case
                    // even though ACT_SHOW flag will be false
                    && ((lpobj->fCmd & LN_MASK) != LN_NEW))
            cmdShow.second = SW_HIDE;
    }

    paramBlock.wEnvSeg      = NULL;
    paramBlock.lpcmdline    = (LPSTR)cmdline;
    paramBlock.lpCmdShow    = &cmdShow;
    paramBlock.dwReserved   = NULL;

#ifdef WIN32S
    if (wWinVer != 0x0003) {
        lstrcpy( (LPSTR)execCmdLine, (LPSTR)exeName);
        lstrcat( (LPSTR)execCmdLine, (LPSTR)" ");
        lstrcat( (LPSTR)execCmdLine, (LPSTR)paramBlock.lpcmdline);
        if ((hInst =  WinExec ((LPSTR)execCmdLine, cmdShow.second)) <= 32)
            hInst = NULL;
    } else
#endif
    if ((hInst =  LoadModule ((LPSTR)exeName, &paramBlock)) <= 32)
        hInst = NULL;

    if (!hInst) {
        LPSTR   lptmp;
        char    ch;

        // strip off the path and try again
        lptmp = (LPSTR)exeName;
        lptmp += lstrlen ((LPSTR) exeName);
        ch = *lptmp;
        while (ch != '\\' && ch != ':') {
            if (lptmp == (LPSTR) exeName) {
                // exe did not have path in it's name. we already tried
                // loading and it failed, no point trying again.
                return NULL;
            }
            else
                ch = *--lptmp;
        }

#ifdef WIN32S
        if (wWinVer != 0x0003) {
            lstrcpy( (LPSTR)execCmdLine, (LPSTR)++lptmp);
            lstrcat( (LPSTR)execCmdLine, (LPSTR)" ");
            lstrcat( (LPSTR)execCmdLine, (LPSTR)paramBlock.lpcmdline);
            if ((hInst =  WinExec ((LPSTR)execCmdLine, cmdShow.second)) <= 32)
                hInst = NULL;
        } else
#endif
        if ((hInst =  LoadModule (++lptmp, &paramBlock)) <= 32)
            hInst = NULL;
    }

    return hInst;
}



//ScanItemOptions: Scan for the item options like Close/Save etc.

int INTERNAL ScanItemOptions (aItem, lpoptions)
ATOM    aItem;
int far *lpoptions;
{

    ATOM    aModifier;

    LPSTR   lpbuf;
    char    buf[MAX_STR];

    *lpoptions = OLE_CHANGED;

    if (!aItem) {
        // NULL item with no modifier means OLE_CHANGED for NULL item
        return OLE_OK;
    }

    GlobalGetAtomName (aItem, (LPSTR)buf, MAX_STR);
    lpbuf = (LPSTR)buf;

    while ( *lpbuf && *lpbuf != '/')
           lpbuf++;

    // no modifier same as /change

    if (*lpbuf == NULL)
        return OLE_OK;

    *lpbuf++ = NULL;        // seperate out the item string
                            // We are using this in the caller.

    if (!(aModifier = GlobalFindAtom (lpbuf)))
        return OLE_ERROR_SYNTAX;

    if (aModifier == aChange)
        return OLE_OK;

    // Is it a save?
    if (aModifier == aSave){
        *lpoptions = OLE_SAVED;
        return  OLE_OK;
    }
    // Is it a Close?
    if (aModifier == aClose){
        *lpoptions = OLE_CLOSED;
        return OLE_OK;
    }

    // unknown modifier
    return OLE_ERROR_SYNTAX;

}

void   INTERNAL   ChangeDocName (lpobj, lpdata)
LPOBJECT_LE     lpobj;
LPSTR           lpdata;
{
    ATOM        aOldTopic;
    OLESTATUS   retVal;

    aOldTopic = lpobj->topic;
    lpobj->topic = GlobalAddAtom (lpdata);
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        return;
        // !!! what should we do in case of error? Currently, we will not
        // change the topic if SetNetName fails.
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);

    // Delete the link data block
    if (lpobj->hLink) {
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }

    ContextCallBack (lpobj, OLE_RENAMED);

}


BOOL INTERNAL CanCallback (lpobj, options)
LPOBJECT_LE lpobj;
int         options;
{
    LPINT    lpCount;

    if (options == OLE_CLOSED) {
        lpobj->bSvrClosing = TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseClose);
    }
    else if (options == OLE_SAVED) {
        if (lpobj->head.ctype == CT_LINK)
            return TRUE;
        lpCount = &(lpobj->pDocEdit->nAdviseSave);
    }
    else {
        // it must be due to request
        if ((lpobj->pDocEdit->awaitAck == AA_REQUEST)
                && lpobj->pDocEdit->bCallLater)
            return FALSE;

        return TRUE;
    }

    switch (*lpCount) {
        case 1:
            break;

        case 2:
            ++(*lpCount);
            return FALSE;

        case 3:
            --(*lpCount);
            break;

        default:
            return FALSE;
    }

    return TRUE;
}


void  FARINTERNAL CallEmbLnkDelete (lpobj)
LPOBJECT_LE lpobj;
{
    InitAsyncCmd (lpobj, OLE_SERVERUNLAUNCH,EMBLNKDELETE);
    EmbLnkDelete (lpobj);

    if (lpobj->head.ctype == CT_EMBEDDED) {
        lpobj->bSvrClosing = TRUE;
        ContextCallBack (lpobj, OLE_CLOSED);
        if (FarCheckObject ((LPOLEOBJECT)lpobj))
            lpobj->bSvrClosing = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\dll.h ===
/****************************** Module Header ******************************\
* Module Name: dll.h
*
* PURPOSE: Private definitions file for ole.c
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*  Raor, Srinik  (../../90,91)  Original
*
\***************************************************************************/

#define  OLE_INTERNAL

#include    "cmacs.h"
#include    "ole.h"

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines, Object methods table and Structures.                           //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


#ifndef HUGE
#define HUGE    huge
#endif

// Different OS version numbers. One of these values will be in the HIWORD
// of the OLE version field

#define OS_WIN16    0x0000
#define OS_MAC      0x0001
#define OS_WIN32    0x0002


// Characteristics Type Field
#define CT_NULL     0L
#define CT_LINK     1L
#define CT_EMBEDDED 2L
#define CT_STATIC   3L
#define CT_OLDLINK  4L
#define CT_PICTURE  5L

#define OLE_NO          0   // for boolean query functions
#define OLE_YES         1   // for boolean query functions

#define MAX_STR         256
#define MAX_NET_NAME    MAX_STR
#define INVALID_INDEX   -1
#define MAX_ATOM        256

#define NUM_RENDER      3

#define PROTOCOL_EDIT       ((LPSTR)"StdFileEditing")
#define PROTOCOL_STATIC     ((LPSTR)"Static")
#define PROTOCOL_EXECUTE    ((LPSTR)"StdExecute")
    
#define READ_ACCESS     0 
#define WRITE_ACCESS    1   

#define POPUP_NETDLG    1

extern  WORD  CheckPointer (LPVOID, int);
WORD FARINTERNAL  FarCheckPointer (LPVOID, int);

#define PROBE_OLDLINK(lpobj){\
        if (lpobj->bOldLink)\
            return OLE_ERROR_OBJECT;\
}


#define PROBE_READ(lp){\
        if (!CheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_WRITE(lp){\
        if (!CheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}


#define FARPROBE_READ(lp){\
        if (!FarCheckPointer(lp, READ_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define FARPROBE_WRITE(lp){\
        if (!FarCheckPointer(lp, WRITE_ACCESS))\
            return OLE_ERROR_ADDRESS;  \
}

#define PROBE_MODE(bProtMode) {\
        if (!bProtMode) \
            return OLE_ERROR_PROTECT_ONLY; \
}

extern  OLECLIPFORMAT   cfBinary;
extern  OLECLIPFORMAT   cfOwnerLink;
extern  OLECLIPFORMAT   cfObjectLink;
extern  OLECLIPFORMAT   cfLink;
extern  OLECLIPFORMAT   cfNative;

extern  ATOM            aStdHostNames;
extern  ATOM            aStdTargetDevice ;
extern  ATOM            aStdDocDimensions;
extern  ATOM            aStdDocName;
extern  ATOM            aStdColorScheme;
extern  ATOM            aNullArg;
extern  ATOM            aSave;
extern  ATOM            aChange;
extern  ATOM            aClose;
extern  ATOM            aPackage;

extern  HANDLE          hInstDLL;
extern  DWORD           dwVerToFile;
extern  DWORD           dwVerFromFile;
extern  WORD            wWinVer;
extern  BOOL            bProtMode;

// Used by QuerySize() API;
extern  DWORD           dwObjSize;

extern  OLESTREAM       dllStream;
extern  BOOL            bWLO;

////////////////////////////////////////////////////////////////////////////
//
// Note: Whenever this table is changed, then we need to update the
// method table in ole.h. Otherwise we are in trouble.
//
////////////////////////////////////////////////////////////////////////////

typedef struct _OLEOBJECTVTBL{
    LPVOID          (FAR PASCAL *QueryProtocol)     (LPVOID, LPSTR);
    OLESTATUS       (FAR PASCAL *Release)           (LPVOID);
    OLESTATUS       (FAR PASCAL *Show)              (LPVOID, BOOL);
    OLESTATUS       (FAR PASCAL *DoVerb)            (LPVOID, WORD, BOOL, BOOL);
    OLESTATUS       (FAR PASCAL *GetData)           (LPVOID, OLECLIPFORMAT, LPHANDLE);
    OLESTATUS       (FAR PASCAL *SetData)           (LPVOID, OLECLIPFORMAT, HANDLE);
    OLESTATUS       (FAR PASCAL *SetTargetDevice)   (LPVOID, HANDLE);
    OLESTATUS       (FAR PASCAL *SetBounds)         (LPVOID, LPRECT);
    OLECLIPFORMAT   (FAR PASCAL *EnumFormats)       (LPVOID, OLECLIPFORMAT);

    OLESTATUS       (FAR PASCAL *SetColorScheme)    (LPVOID, LPLOGPALETTE);
    OLESTATUS       (FAR PASCAL *Delete)            (LPVOID);   
    OLESTATUS       (FAR PASCAL *SetHostNames)      (LPVOID, LPSTR, LPSTR);
    
    OLESTATUS       (FAR PASCAL *SaveToStream)      (LPVOID, LPOLESTREAM);
    OLESTATUS       (FAR PASCAL *Clone)             (LPVOID, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPVOID);
    OLESTATUS       (FAR PASCAL *CopyFromLink)      (LPVOID, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPVOID);
    OLESTATUS       (FAR PASCAL *Equal)             (LPVOID, LPVOID);
    OLESTATUS       (FAR PASCAL *CopyToClipboard)   (LPVOID);
    OLESTATUS       (FAR PASCAL *Draw)              (LPVOID, HDC, LPRECT, LPRECT, HDC);
    OLESTATUS       (FAR PASCAL *Activate)          (LPVOID, WORD, BOOL, BOOL, HWND, LPRECT);
    OLESTATUS       (FAR PASCAL *Execute)           (LPVOID, HANDLE, WORD);
    OLESTATUS       (FAR PASCAL *Close)             (LPVOID);
    OLESTATUS       (FAR PASCAL *Update)            (LPVOID);
    OLESTATUS       (FAR PASCAL *Reconnect)         (LPVOID);

    OLESTATUS       (FAR PASCAL *ObjectConvert)     (LPVOID, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *);

    OLESTATUS       (FAR PASCAL *GetLinkUpdateOptions)      (LPVOID, OLEOPT_UPDATE FAR *);
    OLESTATUS       (FAR PASCAL *SetLinkUpdateOptions)      (LPVOID, OLEOPT_UPDATE);
    OLESTATUS       (FAR PASCAL *Rename)                    (LPVOID, LPSTR);
    OLESTATUS       (FAR PASCAL *QueryName)                 (LPVOID, LPSTR, WORD FAR *);
    OLESTATUS       (FAR PASCAL *QueryType)                 (LPVOID, LPLONG);
    OLESTATUS       (FAR PASCAL *QueryBounds)               (LPVOID, LPRECT);
    OLESTATUS       (FAR PASCAL *QuerySize)                 (LPVOID, DWORD FAR *);    
    OLESTATUS       (FAR PASCAL *QueryOpen)                 (LPVOID);
    OLESTATUS       (FAR PASCAL *QueryOutOfDate)            (LPVOID);
    
    OLESTATUS       (FAR PASCAL *QueryReleaseStatus)        (LPVOID);
    OLESTATUS       (FAR PASCAL *QueryReleaseError)         (LPVOID);
    OLE_RELEASE_METHOD  (FAR PASCAL *QueryReleaseMethod)    (LPVOID);
    
    OLESTATUS       (FAR PASCAL *RequestData)   (LPVOID, OLECLIPFORMAT);
    OLESTATUS       (FAR PASCAL *ObjectLong)    (LPVOID, WORD, LPLONG);
    OLESTATUS       (FAR PASCAL *ChangeData)    (LPVOID, HANDLE, LPOLECLIENT, BOOL);

} OLEOBJECTVTBL;

typedef  OLEOBJECTVTBL  FAR   *LPOLEOBJECTVTBL;


typedef struct _OLEOBJECT { /*object */
    LPOLEOBJECTVTBL lpvtbl;
    char            objId[2];
    HOBJECT         hobj;
    LPOLECLIENT     lpclient;
    LONG            ctype;
    LONG            cx;
    LONG            cy;
    LONG            mm;
    int             iTable;           // Index into the dll table
    ATOM            aObjName;      //** Client
    LHCLIENTDOC     lhclientdoc;   //      Document
    LPOLEOBJECT     lpPrevObj;     //      related
    LPOLEOBJECT     lpNextObj;     //** fileds
    LPOLEOBJECT     lpParent;      // NULL for LE or Static objects.
} OBJECT;



typedef struct _CF_NAME_ATOM {
    char *  cfName;
    ATOM    cfAtom;
} CF_NAME_ATOM;

extern  CF_NAME_ATOM    cfNameAtom[];


typedef struct _METADC {
    int     xMwo;
    int     yMwo;
    int     xMwe;
    int     yMwe;
    int     xre;
    int     yre;
    struct _METADC * pNext;
} METADC, *PMETADC;

typedef struct _METAINFO {
    METADC  headDc;
    int         xwo;
    int         ywo;
    int         xwe;
    int         ywe;
    int         xro;
    int         yro;
} METAINFO, *PMETAINFO;

typedef struct OBJECT_MF { /* object_mf */
    OBJECT          head;
    DWORD           sizeBytes;
    METAFILEPICT    mfp;
    HANDLE          hmfp;
    BOOL            fMetaDC;
    OLESTATUS       error;
    int             nRecord;
    PMETAINFO       pMetaInfo;
    PMETADC         pCurMdc;
} OBJECT_MF;

typedef OBJECT_MF  FAR * LPOBJECT_MF;



typedef struct
{
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;  // width in pixels
    int     ySize;  // height in pixels
    HBITMAP hBitmap;    
} OBJECT_BM;

typedef OBJECT_BM FAR * LPOBJECT_BM;



typedef struct _OBJECT_DIB {
    OBJECT  head;
    DWORD   sizeBytes;
    int     xSize;
    int     ySize;
    HANDLE  hDIB;   
} OBJECT_DIB;

typedef OBJECT_DIB FAR * LPOBJECT_DIB;



typedef struct
{
    OBJECT          head;
    OLECLIPFORMAT   cfFormat;
    ATOM            aClass;
    DWORD           sizeBytes;
    HANDLE          hData;
} OBJECT_GEN;

typedef OBJECT_GEN FAR * LPOBJECT_GEN;



typedef struct  _RENDER_ENTRY { /* dll_entry */
    LPSTR       lpClass;
    ATOM        aClass; 
    OLESTATUS   (FARINTERNAL *Load) (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
} RENDER_ENTRY;


typedef struct _DLL_ENTRY { 
    ATOM        aDll;     /* global atom for dll name with full path */
    HANDLE      hDll;     /* handle to the dll module */
    int         cObj;     /* count of objects, unload dll when this is 0 */
    OLESTATUS   (FAR PASCAL *Load) (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Clip) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

    OLESTATUS   (FAR PASCAL *Link) (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromTemplate) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *Create) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

    OLESTATUS   (FAR PASCAL *CreateLinkFromFile) (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
    OLESTATUS   (FAR PASCAL *CreateInvisible) (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

} DLL_ENTRY;





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

BOOL      INTERNAL      CheckObject(LPOLEOBJECT);
BOOL      FARINTERNAL   FarCheckObject(LPOLEOBJECT);
OLESTATUS INTERNAL      LeQueryCreateFromClip (LPSTR, OLEOPT_RENDER, OLECLIPFORMAT, LONG);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DEFCREAT.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   DefLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   DefCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   DefCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in PBHANDLR.C                                                  //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS FAR PASCAL   PbLoadFromStream (LPOLESTREAM, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS FAR PASCAL   PbCreateLinkFromClip (LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromTemplate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreate (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateLinkFromFile (LPSTR, LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS FAR PASCAL   PbCreateInvisible (LPSTR, LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Defines common for le.c, ledde.c, dde.c, doc.c                          //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


// Constants for chekcing whether the instance is SrvrDLL instance.

#define   WW_LPTR           0       // ptr tosrvr/doc/item
#define   WW_LE             4       // signature
#define   WW_HANDLE         6       // instance handle

#define   WC_LE             0x4c45  // LE chars


// command flags
#define     ACT_SHOW        0x0001      // show the window
#define     ACT_ACTIVATE    0x0002      // activate
#define     ACT_DOVERB      0x0004      // Run the item
#define     ACT_ADVISE      0x0008      // advise for data
#define     ACT_REQUEST     0x0010      // request for data
#define     ACT_CLOSE       0x0020      // request for advise only on close
#define     ACT_UNLAUNCH    0x0040      // unload the server after all the
#define     ACT_TERMSRVR    0x0080      // terminate server
#define     ACT_TERMDOC     0x0100      // terminate document

#define     ACT_NATIVE      0x0200      // only for LNKed objects, if we
                                        // need native data.

#define     ACT_MINIMIZE    0x0400      // launch the app minimized

#define     ACT_NOLAUNCH    0x0800      // don't launch the server

                                            
#define     LN_TEMPLATE     0x0000       // create from template
#define     LN_NEW          0x1000       // create new
#define     LN_EMBACT       0x2000       // activate emb
#define     LN_LNKACT       0x3000       // activate link
#define     LN_MASK         0xf000       // launch mask
#define     LN_SHIFT        12            // shift count for LN_MASK

typedef struct _EDIT_DDE { /* edit_dde */
    HANDLE      hInst;
    int         extraTerm;
    HWND        hClient;
    HWND        hServer;
    BOOL        bTerminating;
    BOOL        bAbort;
    BOOL        bCallLater;     // used in request cases. if this is FALSE
                                // then OLE_CHANGED is sent to client
    int         awaitAck;
    HANDLE      hopt;           // Memory block I may have to free
    int         nAdviseClose;   // count of outstanding advises on closes
    int         nAdviseSave;    // count of outstanding advises on save
    HANDLE      hData;          // Poked data/ temp for holding the
                                // handle in DDE messages

                                // busy parameters
    LONG        lParam;         // lparam value in case we need to
                                // repost the message
    WORD        msg;            // busy repost message

    WORD        wTimer;         // timer id.
} EDIT_DDE;

typedef EDIT_DDE NEAR   *PEDIT_DDE;
typedef EDIT_DDE FAR    *LPEDIT_DDE;

typedef struct _OBJECT_LE { /* object_le */
    OBJECT          head;
    ATOM            app;
    ATOM            topic;
    ATOM            item;
    ATOM            aServer;
    BOOL            bOldLink;           // whether a linked object for old link
    BOOL            bOleServer;         // server which supports the verbs
    WORD            verb;               // verb nuymber;
    WORD            fCmd;               // Command flags;
    OLEOPT_UPDATE   optUpdate;
    OLEOPT_UPDATE   optNew;             // new update options
    LPSTR           lptemplate;         // ptr to the template string, if
                                        // create from template
                                        
    ATOM            aNetName;           // network name on which the doc is
    char            cDrive;             // local drive for that network
    DWORD           dwNetInfo;          // LOW WORD = Net type
                                        // HIGH WORD = Driver version

    LPOLEOBJECT     lpobjPict;

    LONG            lAppData;           // apps data
    LONG            lHandlerData;       // handler data

    HANDLE          hnative;
    HANDLE          hLink;
    HANDLE          hhostNames;         // host name block
    HANDLE          htargetDevice;      // target device info
    HANDLE          hdocDimensions;     // document dimensions
    HANDLE          hextraData;         // reqestdata handle
    WORD            cfExtra;            // extra format data
    HANDLE          hlogpal;          // logiccal palette


    WORD            oldasyncCmd;        // previous asynchronous command
    WORD            asyncCmd;           // asynchronous command
    BOOL            endAsync;           // true if we need to send END_RELEASE.
    BOOL            bAsync;             // true if async command on.
    WORD            mainRtn;            // main async routine
    WORD            subRtn;             // step within the main async routine
    WORD            mainErr;            // failure error
    WORD            subErr;             // step error
    WORD            errHint;            // ;error hint

    BOOL            bSvrClosing;        // TRUE - server in the process of
                                        // closing down
    BOOL            bUnlaunchLater;     // Call EmbLnkDelete from EndAsyncCmd
                                        // if this flag is TRUE
                                            
    HANDLE          hSysEdit;           // handle to system edit.
    PEDIT_DDE       pSysEdit;           // near ptr to system edit.
    HANDLE          hDocEdit;           // handle to doc level channel
    PEDIT_DDE       pDocEdit;           // near ptr to the doc level channel

} OBJECT_LE;
typedef OBJECT_LE  FAR * LPOBJECT_LE;


typedef struct _CLIENTDOC { /* object_le */
    char                    docId[2];
    LPOLEOBJECT             lpHeadObj;
    LPOLEOBJECT             lpTailObj;
    ATOM                    aClass; 
    ATOM                    aDoc;
    HANDLE                  hdoc;
    struct _CLIENTDOC FAR * lpPrevDoc;  
    struct _CLIENTDOC FAR * lpNextDoc;
} CLIENTDOC;
typedef CLIENTDOC  FAR * LPCLIENTDOC;


typedef struct _HOSTNAMES {
    WORD    clientNameOffset;
    WORD    documentNameOffset;
    BYTE    data[];
} HOSTNAMES;

typedef HOSTNAMES FAR * LPHOSTNAMES;

typedef struct _BOUNDSRECT {
    WORD    defaultWidth;
    WORD    defaultHeight;
    WORD    maxWidth;
    WORD    maxHeight;
} BOUNDSRECT;

typedef BOUNDSRECT FAR *LPBOUNDSRECT;


// AwaitAck values
#define AA_REQUEST  1
#define AA_ADVISE   2
#define AA_POKE     3
#define AA_EXECUTE  4
#define AA_UNADVISE 5
#define AA_INITIATE 6

// Bits for Positive WM_DDE_ACK
#define POSITIVE_ACK 0x8000



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LE.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPVOID      FARINTERNAL LeQueryProtocol (LPOBJECT_LE, LPSTR);
OLESTATUS   FARINTERNAL LeRelease (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClone (LPOBJECT_LE, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_LE FAR *);
OLESTATUS   FARINTERNAL LeCopyFromLink (LPOBJECT_LE, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOBJECT_LE FAR *);
OLESTATUS   FARINTERNAL LeEqual (LPOBJECT_LE, LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeCopy (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeQueryBounds (LPOBJECT_LE, LPRECT);
OLESTATUS   FARINTERNAL LeDraw (LPOBJECT_LE, HDC, LPRECT, LPRECT, HDC);
OLECLIPFORMAT   FARINTERNAL LeEnumFormat (LPOBJECT_LE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeGetData (LPOBJECT_LE, OLECLIPFORMAT, HANDLE FAR *);
OLESTATUS   FARINTERNAL LeRequestData (LPOBJECT_LE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeQueryOutOfDate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeObjectConvert (LPOBJECT_LE, LPSTR, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *); 
OLESTATUS   FARINTERNAL LeChangeData (LPOBJECT_LE, HANDLE, LPOLECLIENT, BOOL);
LPOBJECT_LE FARINTERNAL LeCreateBlank(LHCLIENTDOC, LPSTR, LONG);
void        FARINTERNAL SetExtents (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSaveToStream (LPOBJECT_LE, LPOLESTREAM);
OLESTATUS   FARINTERNAL LeLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS   INTERNAL    LeStreamRead (LPOLESTREAM, LPOBJECT_LE);
OLESTATUS   INTERNAL    LeStreamWrite (LPOLESTREAM, LPOBJECT_LE);
int         FARINTERNAL ContextCallBack (LPVOID, OLE_NOTIFICATION);
void        INTERNAL    DeleteObjectAtoms (LPOBJECT_LE);
void        FARINTERNAL DeleteExtraData (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeGetUpdateOptions (LPOBJECT_LE, OLEOPT_UPDATE FAR *);
OLESTATUS   FARINTERNAL LnkPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL EmbPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);
BOOL        INTERNAL    SetLink (LPOBJECT_LE, HANDLE, LPSTR FAR *);
HANDLE      INTERNAL    GetLink (LPOBJECT_LE);
void        FARINTERNAL SetEmbeddedTopic (LPOBJECT_LE);

OLESTATUS   FAR PASCAL  LeQueryReleaseStatus (LPOBJECT_LE);
OLESTATUS   FAR PASCAL  LeQueryReleaseError (LPOBJECT_LE);
OLE_RELEASE_METHOD FAR PASCAL LeQueryReleaseMethod (LPOBJECT_LE);

OLESTATUS   FARINTERNAL LeQueryType (LPOBJECT_LE, LPLONG);
OLESTATUS   FARINTERNAL LeObjectLong (LPOBJECT_LE, WORD, LPLONG);


void SetNetDrive (LPOBJECT_LE);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in LEDDE.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


OLESTATUS   FARINTERNAL LeDoVerb  (LPOBJECT_LE, WORD, BOOL, BOOL);
OLESTATUS   FARINTERNAL LeShow (LPOBJECT_LE, BOOL);
OLESTATUS   FARINTERNAL LeQueryOpen (LPOBJECT_LE);
BOOL        INTERNAL    QueryOpen (LPOBJECT_LE); 
OLESTATUS   FARINTERNAL LeActivate (LPOBJECT_LE, WORD, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LeUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL EmbUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL EmbOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpen (LPOBJECT_LE, BOOL, BOOL, HWND, LPRECT);
OLESTATUS   FARINTERNAL LnkUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LnkOpenUpdate (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeReconnect (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeNativeData (LPOBJECT_LE);
BOOL        INTERNAL    PostMessageToServer (PEDIT_DDE, WORD, LONG);

OLESTATUS   FARINTERNAL LeCreateFromTemplate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreate (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL LeCreateInvisible (LPOLECLIENT, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, BOOL);

OLESTATUS   FARINTERNAL CreateFromClassOrTemplate (LPOLECLIENT, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, WORD, LPSTR, LHCLIENTDOC, LPSTR);

OLESTATUS   FARINTERNAL CreateEmbLnkFromFile (LPOLECLIENT, LPSTR, LPSTR, LPSTR, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);

OLESTATUS   FARINTERNAL LeSetUpdateOptions (LPOBJECT_LE, OLEOPT_UPDATE);

void        INTERNAL    AdvisePict (LPOBJECT_LE, ATOM);
void        INTERNAL    UnAdvisePict (LPOBJECT_LE);
int         INTERNAL    GetPictType (LPOBJECT_LE);
void        INTERNAL    AdviseOn (LPOBJECT_LE, int, ATOM);
void        INTERNAL    UnAdviseOn (LPOBJECT_LE, int);
void        INTERNAL    RequestOn (LPOBJECT_LE, int);
void        INTERNAL    RequestPict (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetHostNames (LPOBJECT_LE, LPSTR, LPSTR);
OLESTATUS   INTERNAL    PokeHostNames (LPOBJECT_LE);
OLESTATUS   INTERNAL    SetHostNamesHandle (LPOBJECT_LE, LPSTR, LPSTR);
void        INTERNAL    FreePokeData (LPOBJECT_LE, PEDIT_DDE);
OLESTATUS   INTERNAL    SendPokeData (LPOBJECT_LE, ATOM, HANDLE, OLECLIPFORMAT);
OLESTATUS   FARINTERNAL LeSetTargetDevice (LPOBJECT_LE, HANDLE);
OLESTATUS   INTERNAL    PokeTargetDeviceInfo (LPOBJECT_LE);
OLESTATUS   INTERNAL    PokeDocDimensions (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetBounds (LPOBJECT_LE, LPRECT);
OLESTATUS   FARINTERNAL LeSetData (LPOBJECT_LE, OLECLIPFORMAT, HANDLE);
BOOL        INTERNAL SendSrvrMainCmd (LPOBJECT_LE, LPSTR);
ATOM        INTERNAL    ExtendAtom (LPOBJECT_LE, ATOM);
BOOL        INTERNAL    CreatePictObject (LHCLIENTDOC, LPSTR, LPOBJECT_LE, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR);
BOOL        INTERNAL    IsSrvrDLLwnd (HWND, HANDLE);
OLESTATUS   INTERNAL    ChangeDocAndItem (LPOBJECT_LE, HANDLE);
BOOL                    QueryUnlaunch (LPOBJECT_LE);
BOOL                    QueryClose (LPOBJECT_LE);
OLESTATUS   FARINTERNAL LeSetColorScheme (LPOBJECT_LE, LPLOGPALETTE);
OLESTATUS   INTERNAL    PokeColorScheme (LPOBJECT_LE);
OLESTATUS   FARINTERNAL ProbeAsync (LPOBJECT_LE);
BOOL        INTERNAL    IsServerValid (LPOBJECT_LE);
BOOL        INTERNAL    IsWindowValid (HWND);
OLESTATUS   FARINTERNAL LeExecute (LPOBJECT_LE, HANDLE, WORD);
void        INTERNAL    FreeGDIdata (HANDLE, OLECLIPFORMAT);
BOOL        INTERNAL    CanPutHandleInPokeBlock (LPOBJECT_LE, OLECLIPFORMAT);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DDE.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


long        FARINTERNAL DocWndProc(HWND, unsigned, WORD, LONG );
long        FARINTERNAL SrvrWndProc(HWND, unsigned, WORD, LONG );
BOOL        INTERNAL    CheckAtomValid (ATOM);
void        INTERNAL    HandleAckInitMsg (PEDIT_DDE, HWND);
BOOL        INTERNAL    HandleAck (LPOBJECT_LE, PEDIT_DDE, DWORD);
void        INTERNAL    HandleDataMsg (LPOBJECT_LE, HANDLE, ATOM);
void        INTERNAL    HandleTermMsg (LPOBJECT_LE, PEDIT_DDE, HWND, BOOL);
void        INTERNAL    HandleTimerMsg (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    SetData (LPOBJECT_LE, HANDLE, int);
BOOL        INTERNAL    DeleteBusyData (LPOBJECT_LE, PEDIT_DDE);
void        INTERNAL    DeleteAbortData (LPOBJECT_LE, PEDIT_DDE);

BOOL        INTERNAL    WaitDDE (HWND, BOOL);
BOOL        INTERNAL    WaitDDEAck (PEDIT_DDE);

BOOL        INTERNAL    InitSrvrConv (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermSrvrConv (LPOBJECT_LE);
void        INTERNAL    DeleteSrvrEdit (LPOBJECT_LE);
BOOL        INTERNAL    SrvrExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    SendStdExit (LPOBJECT_LE);
void        INTERNAL    SendStdClose (LPOBJECT_LE);
void        INTERNAL    SendStdExit  (LPOBJECT_LE);

BOOL        FARINTERNAL InitDocConv (LPOBJECT_LE, BOOL);
BOOL        INTERNAL    DocExecute (LPOBJECT_LE, HANDLE);
void        INTERNAL    TermDocConv (LPOBJECT_LE);
void        INTERNAL    DeleteDocEdit (LPOBJECT_LE);

HANDLE      INTERNAL    LeLaunchApp (LPOBJECT_LE);
HANDLE      INTERNAL    LoadApp (LPSTR, WORD);

int         INTERNAL    ScanItemOptions (ATOM, int FAR *);
void        INTERNAL    ChangeDocName (LPOBJECT_LE, LPSTR);
BOOL        INTERNAL    CanCallback (LPOBJECT_LE, int);

void        FARINTERNAL CallEmbLnkDelete (LPOBJECT_LE);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Picture Object routines used by routines in other modules               //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


LPOBJECT_BM  FARINTERNAL BmCreateBlank (LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL BmLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL BmPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_DIB FARINTERNAL DibCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_DIB FARINTERNAL DibCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPSTR, LONG);
OLESTATUS    FARINTERNAL DibLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL DibPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_MF  FARINTERNAL MfCreateBlank (LHCLIENTDOC, LPSTR, LONG);
LPOBJECT_MF  FARINTERNAL MfCreateObject (HANDLE, LPOLECLIENT, BOOL, LHCLIENTDOC, LPSTR, LONG);

OLESTATUS    FARINTERNAL MfLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);
OLESTATUS    FARINTERNAL MfPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG);


LPOBJECT_GEN FARINTERNAL GenCreateBlank (LHCLIENTDOC, LPSTR, LONG, ATOM);
OLESTATUS    FARINTERNAL GenLoadFromStream (LPOLESTREAM, LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LONG, ATOM, OLECLIPFORMAT);
OLESTATUS    FARINTERNAL GenPaste (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, LPSTR, OLECLIPFORMAT, LONG);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in MAIN.C                                                      //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

void    FARINTERNAL UnloadDll (void);
int     FARINTERNAL LoadDll (LPSTR);
void    FARINTERNAL DecreaseHandlerObjCount (int);

void    FARINTERNAL RemoveLinkStringFromTopic (LPOBJECT_LE);

OLESTATUS FARINTERNAL CreatePictFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LPSTR, LONG);

OLESTATUS FARINTERNAL CreatePackageFromClip (LPOLECLIENT, LHCLIENTDOC, LPSTR, LPOLEOBJECT FAR *, OLEOPT_RENDER, OLECLIPFORMAT, LONG);




/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in UTILS.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        PutStrWithLen (LPOLESTREAM, LPSTR);
BOOL        GetStrWithLen (LPOLESTREAM, LPSTR);
ATOM        GetAtomFromStream (LPOLESTREAM);
BOOL        PutAtomIntoStream (LPOLESTREAM, ATOM);
BOOL        GetBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        PutBytes (LPOLESTREAM, LPSTR, LONG);
BOOL        QueryApp (LPSTR, LPSTR, LPSTR);
HANDLE      MapStrToH (LPSTR);
void        UtilMemClr (PSTR, WORD);
BOOL        QueryHandler (WORD);

OLESTATUS INTERNAL      FileExists (LPOBJECT_LE);
ATOM      FARINTERNAL   GetAppAtom (LPSTR);
HANDLE    FARINTERNAL   DuplicateGlobal (HANDLE, WORD);
HANDLE    FARINTERNAL   CopyData (LPSTR, DWORD);
ATOM      FARINTERNAL   DuplicateAtom (ATOM);
BOOL      FARINTERNAL   UtilQueryProtocol (LPOBJECT_LE, LPSTR);
BOOL      FARINTERNAL   CmpGlobals (HANDLE, HANDLE);
void      FARINTERNAL   ConvertToHimetric(LPPOINT);
BOOL      FARINTERNAL   QueryVerb (LPOBJECT_LE, WORD, LPSTR, LONG);
BOOL      FARINTERNAL   MapExtToClass (LPSTR, LPSTR, int);
int       FARINTERNAL   GlobalGetAtomLen (ATOM);
void      FARINTERNAL   UtilMemCpy (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   UtilMemCmp (LPSTR, LPSTR, DWORD);
BOOL      FARINTERNAL   IsObjectBlank (LPOBJECT_LE);

OLESTATUS FARINTERNAL   ObjQueryName (LPOLEOBJECT, LPSTR, WORD FAR *);
OLESTATUS FARINTERNAL   ObjRename (LPOLEOBJECT, LPSTR);
void      INTERNAL      SetExeAtom (LPOBJECT_LE);


// !!!make a routine and let the macro call the routine
// definitions related to the asynchronous operations.
#define WAIT_FOR_ASYNC_MSG(lpobj) {  \
    lpobj->subRtn++;                 \
    if (lpobj->bAsync){              \
        lpobj->endAsync = TRUE;      \
        return OLE_WAIT_FOR_RELEASE; \
    }                                \
}

#define STEP_NOP(lpobj)     lpobj->subRtn++;

// !!! Assumes all the creates are in order
#define PROBE_CREATE_ASYNC(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEINVISIBLE) {\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;\
    }
        
#define PROBE_OBJECT_BLANK(lpobj)        \
    if (lpobj->asyncCmd >= OLE_CREATE &&  \
            lpobj->asyncCmd <= OLE_CREATEFROMFILE) { \
        if ((ProbeAsync(lpobj) == OLE_BUSY) && IsObjectBlank(lpobj)) \
            return OLE_ERROR_BLANK;\
    }       

#define PROBE_ASYNC(lpobj)\
        if(ProbeAsync(lpobj) == OLE_BUSY)\
            return OLE_BUSY;

#define IS_SVRCLOSING(lpobj)\
        ((lpobj->bUnlaunchLater || lpobj->bSvrClosing) ? TRUE : FALSE) 
            
#define PROBE_SVRCLOSING(lpobj)\
        if (IS_SVRCLOSING(lpobj)) \
            return OLE_ERROR_NOT_OPEN; \
            

#define CLEAR_STEP_ERROR(lpobj) lpobj->subErr = OLE_OK;


#define   SKIP_TO(a, b)    if (a) goto b;
#define   RESETERR(lpobj)  lpobj->mainErr = OLE_OK
#define   SETSTEP(lpobj, no)  lpobj->subRtn = no
#define   SETERRHINT(lpobj, no) lpobj->errHint = no
#define   CLEARASYNCCMD(lpobj)  lpobj->asyncCmd = OLE_NONE

// routines.
BOOL        ProcessErr          (LPOBJECT_LE);
void        InitAsyncCmd        (LPOBJECT_LE, WORD, WORD);
void        NextAsyncCmd        (LPOBJECT_LE, WORD);
void        ScheduleAsyncCmd    (LPOBJECT_LE);
OLESTATUS   EndAsyncCmd         (LPOBJECT_LE);
OLESTATUS   DocShow             (LPOBJECT_LE);
OLESTATUS   DocRun              (LPOBJECT_LE);
void        SendStdShow         (LPOBJECT_LE);
OLESTATUS   EmbLnkClose         (LPOBJECT_LE);
OLESTATUS   LnkSetUpdateOptions (LPOBJECT_LE);
OLESTATUS   EmbSrvrUnlaunch     (LPOBJECT_LE);
OLESTATUS   LnkChangeLnk        (LPOBJECT_LE);
OLESTATUS   RequestData         (LPOBJECT_LE, OLECLIPFORMAT);

OLESTATUS   FARINTERNAL EmbLnkDelete(LPOBJECT_LE);

void FARINTERNAL FarInitAsyncCmd(LPOBJECT_LE, WORD, WORD);

// async command routines.
#define  EMBLNKDELETE           1
#define  LNKOPENUPDATE          2
#define  DOCSHOW                3
#define  EMBOPENUPDATE          4
#define  EMBLNKCLOSE            5
#define  LNKSETUPDATEOPTIONS    6
#define  LNKCHANGELNK           7
#define  REQUESTDATA            8
#define  DOCRUN                 9

/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in DOC.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////


BOOL        FARINTERNAL     CheckClientDoc (LPCLIENTDOC);
void        FARINTERNAL     DocAddObject (LPCLIENTDOC, LPOLEOBJECT, LPSTR);
void        FARINTERNAL     DocDeleteObject (LPOLEOBJECT);
LPOLEOBJECT INTERNAL        DocGetNextObject (LPCLIENTDOC, LPOLEOBJECT);



/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in NET.C                                                       //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

#define     IDD_DRIVE       500
#define     IDD_PASSWORD    501
#define     IDD_PATH        502

#define     IDS_NETERR          600
#define     IDS_NETCONERRMSG    601
#define     IDS_FILENOTFOUNDMSG 602
#define     IDS_BADPATHMSG      603

OLESTATUS   FARINTERNAL SetNetName (LPOBJECT_LE);
BOOL        FARINTERNAL SetNextNetDrive (LPOBJECT_LE, int FAR *, LPSTR);
OLESTATUS   FARINTERNAL CheckNetDrive (LPOBJECT_LE, BOOL);
OLESTATUS   INTERNAL    FixNet (LPOBJECT_LE, LPSTR, BOOL);
OLESTATUS   INTERNAL    ConnectNet (LPOBJECT_LE, LPSTR);
BOOL        FARINTERNAL ChangeTopic (LPOBJECT_LE);
VOID        INTERNAL    FillDrives (HWND);
int         FAR PASCAL  ConnectDlgProc(HWND, WORD, WORD, DWORD);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in OLE.ASM                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

WORD    GetGDIds (DWORD);
WORD    IsMetaDC (HDC, WORD);


/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in ERROR.C                                                     //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL   ObjQueryType (LPOLEOBJECT, LPLONG);
OLESTATUS FARINTERNAL   ObjQuerySize (LPOLEOBJECT, DWORD FAR *);
DWORD     PASCAL FAR    DllPut (LPOLESTREAM, LPSTR, DWORD);
HANDLE    FARINTERNAL   DuplicateGDIdata (HANDLE, OLECLIPFORMAT);





/////////////////////////////////////////////////////////////////////////////
//                                                                         //
// Routines in BM.C                                                        //
//                                                                         //
/////////////////////////////////////////////////////////////////////////////

HBITMAP   FARINTERNAL   BmDuplicate (HBITMAP, DWORD FAR *, LPBITMAP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\draw.c ===
/****************************** Module Header ******************************\
* Module Name: DRAW.C 
*
* PURPOSE: Contains all the drawing related routines
*
* Created: March 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*       (03/21/91) Srinik  Original
*       (03/22/91) Srinik  Added support for drawing metafile in a metafile
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

#define RECORD_COUNT    16

int       INTERNAL    PaletteSize (int);
HANDLE    INTERNAL    DibMakeLogPalette(LPSTR, WORD, LPLOGPALETTE FAR *);
OLESTATUS FARINTERNAL wDibDraw (HANDLE, HDC, LPRECT, LPRECT, HDC, BOOL);
OLESTATUS INTERNAL    wDrawBitmap (LPOBJECT_BM, HDC, HDC, LPRECT);
OLESTATUS INTERNAL    wDrawBitmapUsingDib (LPOBJECT_BM, HDC, HDC, HDC, LPRECT, LPRECT);

void SetPictOrg (LPOBJECT_MF, HDC, int, int, BOOL);
void SetPictExt (LPOBJECT_MF, HDC, int, int);
void ScalePictExt (LPOBJECT_MF, HDC, int, int, int, int);
void ScaleRectExt (LPOBJECT_MF, HDC, int, int, int, int);

void CleanStack(LPOBJECT_MF, HANDLE);
BOOL PopDc (LPOBJECT_MF);
BOOL PushDc (LPOBJECT_MF);

#ifdef META_DEBUG
void PutMetaFuncName (WORD);
#endif      

OLESTATUS  FARINTERNAL BmDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_BM     lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    HDC         hMemDC, hScreenDC;
    int         iScreenDevCaps;
    OLESTATUS   ret = OLE_OK;
    
    if (!lpobj->hBitmap)
        return OLE_ERROR_BLANK;

    hScreenDC = GetDC (NULL);
    
    iScreenDevCaps = GetDeviceCaps (hScreenDC, TECHNOLOGY);
    if (!OleIsDcMeta (hdc) 
            && (iScreenDevCaps != GetDeviceCaps (hdc, TECHNOLOGY))) {
        ret = wDrawBitmapUsingDib (lpobj, hdc, hScreenDC, 
                        hdcTarget, lprc, lpWrc);
    }
    else {
        hMemDC = CreateCompatibleDC (hdc);
        ret = wDrawBitmap (lpobj, hdc, hMemDC, lprc);
        DeleteDC (hMemDC);
    }
    
    ReleaseDC (NULL, hScreenDC);
    return ret;
}


OLESTATUS INTERNAL wDrawBitmap (lpobj, hdc, hMemDC, lprc)
LPOBJECT_BM lpobj;
HDC         hdc;
HDC         hMemDC;
LPRECT      lprc;
{
    HBITMAP     hOldBitmap;
    OLESTATUS   ret = OLE_OK;

    if (!hMemDC)
        return OLE_ERROR_MEMORY;

    if (!(hOldBitmap = SelectObject(hMemDC, lpobj->hBitmap)))
        return OLE_ERROR_DRAW;

    if (!StretchBlt(hdc, 
            lprc->left, lprc->top, 
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            hMemDC, 0, 0, lpobj->xSize, lpobj->ySize, SRCCOPY)) {
        ret = OLE_ERROR_DRAW;
    }
    
    SelectObject (hMemDC, hOldBitmap);
    return ret;
}

        
OLESTATUS INTERNAL wDrawBitmapUsingDib (
LPOBJECT_BM     lpobj,
HDC             hdc,
HDC             hScreenDC,
HDC             hTargetDC,
LPRECT          lprc,
LPRECT          lpWrc)
{
    BITMAP              bm;
    LPBITMAPINFOHEADER  lpBmi;
    HANDLE              hBmi, hDib = NULL;
    WORD                wBmiSize;
    OLESTATUS           retVal = OLE_ERROR_MEMORY;
    
    if (!GetObject(lpobj->hBitmap, sizeof(BITMAP), (LPSTR) &bm))
        return OLE_ERROR_HANDLE;
    
    wBmiSize = sizeof(BITMAPINFOHEADER) 
                    + PaletteSize(bm.bmPlanes * bm.bmBitsPixel);
    
    if (!(hBmi = GlobalAlloc (GMEM_MOVEABLE|GMEM_ZEROINIT, (DWORD) wBmiSize)))
        return OLE_ERROR_MEMORY;
    
    if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hBmi))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }
    
    GlobalUnlock (hBmi);
                
    lpBmi->biSize          = (LONG) sizeof(BITMAPINFOHEADER);
    lpBmi->biWidth         = (LONG) bm.bmWidth;
    lpBmi->biHeight        = (LONG) bm.bmHeight;
    lpBmi->biPlanes        = 1;
    lpBmi->biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
    lpBmi->biCompression   = BI_RGB;
    lpBmi->biSizeImage     = 0L;
    lpBmi->biXPelsPerMeter = 0L;
    lpBmi->biYPelsPerMeter = 0L;
    lpBmi->biClrUsed       = 0L;
    lpBmi->biClrImportant  = 0L;
    
    // Call GetDIBits with a NULL lpBits parm, so that it will calculate 
    // the biSizeImage field for us
    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, bm.bmHeight, NULL, 
            (LPBITMAPINFO)lpBmi, DIB_RGB_COLORS))
        return OLE_ERROR_HANDLE;

    // Realloc the buffer to provide space for the bits
    if (!(hDib = GlobalReAlloc (hBmi, (wBmiSize + lpBmi->biSizeImage),
                        GMEM_MOVEABLE))) {
        GlobalFree (hBmi);
        return OLE_ERROR_MEMORY;
    }
    
    // If reallocation gave a new handle then lock that handle and get the 
    // long pointer to it.
    if (hDib != hBmi) {
        if (!(lpBmi = (LPBITMAPINFOHEADER) GlobalLock (hDib)))
            goto errRtn;
        GlobalUnlock (hDib);
    }
    
    // Call GetDIBits with a NON-NULL lpBits parm, and get the actual bits

    if (!GetDIBits(hScreenDC, lpobj->hBitmap, 0, (WORD) lpBmi->biHeight, 
             ((LPSTR)lpBmi)+wBmiSize,
             (LPBITMAPINFO) lpBmi, 
             DIB_RGB_COLORS)) {
        retVal = OLE_ERROR_HANDLE;       
        goto errRtn;
    }
    
    retVal = wDibDraw (hDib, hdc, lprc, lpWrc, hTargetDC, FALSE);
    
errRtn:
    if (hDib)
        GlobalFree (hDib);
    return retVal;
}
        

OLESTATUS  FARINTERNAL DibDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_DIB    lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    return wDibDraw (lpobj->hDIB, hdc, lprc, lpWrc, hdcTarget, FALSE);
}



OLESTATUS  FARINTERNAL wDibDraw (hData, hdc, lprc, lpWrc, hdcTarget, bPbrushData)
HANDLE  hData;
HDC     hdc;
LPRECT  lprc;
LPRECT  lpWrc;
HDC     hdcTarget;
BOOL    bPbrushData;
{
    // !!! current implementation is not using hdcTarget 
    OLESTATUS       ret = OLE_ERROR_DRAW;
    LPSTR           lpData;
    HANDLE          hPalette = NULL;
    HPALETTE        hLogPalette = NULL, hOldPalette = NULL;
    LPLOGPALETTE    lpLogPalette;
    WORD            wPalSize;
    int             iOffBits;
    
    if (!hData)
        return OLE_ERROR_BLANK;     
            
    if (!(lpData = GlobalLock (hData)))
        return OLE_ERROR_MEMORY;

    if (bPbrushData)
        lpData += sizeof(BITMAPFILEHEADER);
    
    wPalSize = PaletteSize (((LPBITMAPINFOHEADER)lpData)->biBitCount);
    iOffBits  = sizeof(BITMAPINFOHEADER) + wPalSize;

    // if color palette exits do the following 
    if (wPalSize) {
        if (!(hLogPalette = DibMakeLogPalette(lpData+sizeof(BITMAPINFOHEADER),
                                    wPalSize, &lpLogPalette))) {
            ret = OLE_ERROR_MEMORY;
            goto end;
        }
    
        if (!(hPalette = CreatePalette (lpLogPalette)))
            goto end;

        // select as a background palette
        if (!(hOldPalette = SelectPalette (hdc, hPalette, TRUE))) 
            goto end;

        RealizePalette(hdc);
    }
    
    if (!StretchDIBits(hdc, 
            lprc->left, lprc->top, 
            (lprc->right - lprc->left), (lprc->bottom - lprc->top),
            0, 0,
            (WORD) ((LPBITMAPINFOHEADER)lpData)->biWidth,
            (WORD) ((LPBITMAPINFOHEADER)lpData)->biHeight,
            lpData + iOffBits,
            ((LPBITMAPINFO) lpData),
            DIB_RGB_COLORS,
            SRCCOPY)) {    
        ret = OLE_ERROR_DRAW;
    }
    else 
        ret = OLE_OK;
    
end:
    // if color palette exists do the following
    if (wPalSize) {
        hOldPalette = (OleIsDcMeta (hdc) ? GetStockObject(DEFAULT_PALETTE)
                                         : hOldPalette);
        if (hOldPalette) {
            // select as a background palette
            SelectPalette (hdc, hOldPalette, TRUE);
            RealizePalette (hdc);
        }
    
        if (hPalette)
            DeleteObject (hPalette);

        if (hLogPalette)
            GlobalFree (hLogPalette);
    }
    
    GlobalUnlock (hData);
    return ret;
}





HANDLE INTERNAL DibMakeLogPalette (lpColorData, wDataSize, lplpLogPalette)
LPSTR               lpColorData;
WORD                wDataSize;
LPLOGPALETTE FAR *  lplpLogPalette;
{
    HANDLE          hLogPalette=NULL;
    LPLOGPALETTE    lpLogPalette;
    DWORD           dwLogPalSize = wDataSize +  2 * sizeof(WORD);
    LPPALETTEENTRY  lpPE;
    RGBQUAD FAR *   lpQuad;

    if (!(hLogPalette = GlobalAlloc(GMEM_MOVEABLE,dwLogPalSize)))
        return NULL;

    if (!(lpLogPalette = (LPLOGPALETTE) GlobalLock (hLogPalette))) {
        GlobalFree (hLogPalette);
        return NULL;
    }
    
    GlobalUnlock (hLogPalette);
    *lplpLogPalette = lpLogPalette;
    
    lpLogPalette->palVersion = 0x300;
    lpLogPalette->palNumEntries = wDataSize / sizeof(PALETTEENTRY);

    /* now convert RGBQUAD to PALETTEENTRY as we copy color info */
    for (lpQuad = (RGBQUAD far *)lpColorData, 
            lpPE   = (LPPALETTEENTRY)lpLogPalette->palPalEntry,
            wDataSize /= sizeof(RGBQUAD);
            wDataSize--;
            ++lpQuad,++lpPE) {
        lpPE->peFlags=0;
        lpPE->peRed = lpQuad->rgbRed;
        lpPE->peBlue = lpQuad->rgbBlue;
        lpPE->peGreen = lpQuad->rgbGreen;
    }

    return hLogPalette;
}


int INTERNAL PaletteSize (int iBitCount)
{
    switch (iBitCount) {
        case 1:     
            return (2*sizeof(RGBQUAD));
            
        case 4:     
            return (16*sizeof(RGBQUAD));

        case 8:     
            return (256*sizeof(RGBQUAD));
            
        default:   
            return 0;   /* A 24 bitcount DIB has no color table */
    }
}


OLESTATUS  FARINTERNAL GenDraw (lpobj, hdc, lprc, lpWrc, hdcTarget)
LPOBJECT_GEN    lpobj;
HDC             hdc;
LPRECT          lprc;
LPRECT          lpWrc;
HDC             hdcTarget;
{
    return OLE_ERROR_GENERIC;
}







//*** All the following routines are relevant for metafile drawing only


OLESTATUS FARINTERNAL MfDraw (lpobj,  hdc,  lprc, lpWrc, hdcTarget)
LPOBJECT_MF lpobj;
HDC         hdc;
LPRECT      lprc; 
LPRECT      lpWrc; 
HDC         hdcTarget;
{
    HANDLE  hInfo;
    int     iOldDc;
    RECT    rect;
    LPRECT  lpRrc = (LPRECT) &rect;
    
    rect.left   = lprc->left;
    rect.right  = lprc->right;
    rect.top    = lprc->top;
    rect.bottom = lprc->bottom;
    
    if (!lpobj->mfp.hMF)
        return OLE_ERROR_BLANK;

    lpobj->nRecord = RECORD_COUNT;
    lpobj->fMetaDC = OleIsDcMeta (hdc);

    if (!(iOldDc = SaveDC (hdc)))
        return OLE_ERROR_MEMORY;
    
    IntersectClipRect (hdc, lpRrc->left, lpRrc->top,  
        lpRrc->right, lpRrc->bottom);
    
    if (!lpobj->fMetaDC) {
        LPtoDP (hdc, (LPPOINT) lpRrc, 2);
        SetMapMode (hdc, MM_ANISOTROPIC);
        SetViewportOrg (hdc, lpRrc->left, lpRrc->top);
        SetViewportExt (hdc, lpRrc->right - lpRrc->left, 
            lpRrc->bottom - lpRrc->top);
    }
    else {
        
        iOldDc = -1;
        
        if (!lpWrc) {
#ifdef FIREWALLS            
            ASSERT(0, "Pointer to rect is null")
#endif              
            return OLE_ERROR_DRAW;
        }
        
        if (!(hInfo = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, 
                            sizeof(METAINFO))))
            return OLE_ERROR_MEMORY;
        
        if (!(lpobj->pMetaInfo = (PMETAINFO) LocalLock (hInfo))) {
            LocalFree (hInfo);
            return OLE_ERROR_MEMORY;
        }

        LocalUnlock (hInfo);
        
        lpobj->pCurMdc          = (PMETADC) (lpobj->pMetaInfo);
        
        lpobj->pMetaInfo->xwo   = lpWrc->left;
        lpobj->pMetaInfo->ywo   = lpWrc->top;
        lpobj->pMetaInfo->xwe   = lpWrc->right;
        lpobj->pMetaInfo->ywe   = lpWrc->bottom;    

        lpobj->pMetaInfo->xro   = lpRrc->left - lpWrc->left;
        lpobj->pMetaInfo->yro   = lpRrc->top - lpWrc->top;

        lpobj->pCurMdc->xre     = lpRrc->right - lpRrc->left;
        lpobj->pCurMdc->yre     = lpRrc->bottom - lpRrc->top;   
        
    }
    
    lpobj->error = OLE_OK;
    MfInterruptiblePaint(lpobj, hdc);

    if (lpobj->fMetaDC) 
        CleanStack (lpobj, hInfo);
    
    RestoreDC (hdc, iOldDc);
    return lpobj->error;
}


void INTERNAL MfInterruptiblePaint (lpobj, hdc)
LPOBJECT_MF lpobj;
HDC         hdc;
{
    FARPROC     lpCallbackFunc;
    
    if (!(lpCallbackFunc = MakeProcInstance (MfCallbackFunc, hInstDLL)))
        PlayMetaFile (hdc, lpobj->mfp.hMF);
    else {
        EnumMetaFile (hdc,lpobj->mfp.hMF, lpCallbackFunc, (LPARAM) lpobj);
        FreeProcInstance (lpCallbackFunc);
    }
}



int FARINTERNAL MfCallbackFunc (hdc, lpHTable, lpMFR, nObj, lpobj)
HDC             hdc;
LPHANDLETABLE   lpHTable;
LPMETARECORD    lpMFR;
int             nObj;
BYTE FAR *      lpobj;
{
    LPOBJECT_MF lpobjMf;
    
    lpobjMf = (LPOBJECT_MF) lpobj;
    if (!--lpobjMf->nRecord) {
        lpobjMf->nRecord = RECORD_COUNT;
        if (!ContextCallBack ((lpobjMf->head.lpParent 
                                    ? lpobjMf->head.lpParent
                                    : (LPOLEOBJECT) lpobjMf),
                        OLE_QUERY_PAINT)) {
            lpobjMf->error = OLE_ERROR_ABORT;         
            return FALSE;
        }
    }
    
    if (lpobjMf->fMetaDC) {

#ifdef META_DEBUG
        PutMetaFuncName (lpMFR->rdFunction);
#endif      

        switch (lpMFR->rdFunction) {
            case META_SETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1], 
                    lpMFR->rdParm[0], FALSE);
                return TRUE;

            case META_OFFSETWINDOWORG:
                SetPictOrg (lpobjMf, hdc, lpMFR->rdParm[1], 
                    lpMFR->rdParm[0], TRUE);
                return TRUE;
            
            case META_SETWINDOWEXT:
                SetPictExt (lpobjMf, hdc, lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
            
            case META_SCALEWINDOWEXT:
                ScalePictExt (lpobjMf, hdc, 
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
            
            case META_SAVEDC:
                if (!PushDc (lpobjMf))
                    return FALSE;
                break;
                
            case META_RESTOREDC:                
                PopDc (lpobjMf);
                break;

            case META_SCALEVIEWPORTEXT:
                ScaleRectExt (lpobjMf, hdc, 
                    lpMFR->rdParm[3], lpMFR->rdParm[2],
                    lpMFR->rdParm[1], lpMFR->rdParm[0]);
                return TRUE;
                
            case META_OFFSETVIEWPORTORG:
#ifdef FIREWALLS                
                ASSERT(0, "OffsetViewportOrg() in metafile");
#endif              
                return TRUE;
                
            case META_SETVIEWPORTORG:
#ifdef FIREWALLS                                
                ASSERT(0, "SetViewportOrg() in metafile");
#endif          
                return TRUE;
                
            case META_SETVIEWPORTEXT:
#ifdef FIREWALLS                                
                ASSERT(0, "SetViewportExt() in metafile");
#endif          
                return TRUE;
                
            case META_SETMAPMODE:
#ifdef FIREWALLS                                
                ASSERT(lpMFR->rdParm[0] == MM_ANISOTROPIC,
                    "SetmapMode() in metafile with invalid mapping mode");
#endif          
                return TRUE;

            default:
                break;
        }
    }
    else {
        switch (lpMFR->rdFunction) {
            DWORD exts;
            
            case META_SCALEWINDOWEXT:
                exts = GetWindowExt (hdc);
                SetWindowExt (hdc, 
                    MulDiv(LOWORD(exts), lpMFR->rdParm[3], lpMFR->rdParm[2]), 
                    MulDiv(HIWORD(exts), lpMFR->rdParm[1], lpMFR->rdParm[0]));
                return TRUE;
            
            case META_SCALEVIEWPORTEXT:
                exts = GetViewportExt (hdc);
                SetViewportExt (hdc, 
                    MulDiv(LOWORD(exts), lpMFR->rdParm[3], lpMFR->rdParm[2]), 
                    MulDiv(HIWORD(exts), lpMFR->rdParm[1], lpMFR->rdParm[0]));
                return TRUE;
                
            default:
                break;
        }
    }
    
    PlayMetaFileRecord (hdc, lpHTable, lpMFR, nObj);
    return TRUE;
}


void SetPictOrg (lpobj, hdc, xOrg, yOrg, fOffset)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xOrg;
int         yOrg;
BOOL        fOffset;
{
    if (fOffset) {
        // it's OffsetWindowOrg() call
        lpobj->pCurMdc->xMwo += xOrg;
        lpobj->pCurMdc->yMwo += yOrg;
    }
    else {
        // it's SetWindowOrg()
        lpobj->pCurMdc->xMwo = xOrg;
        lpobj->pCurMdc->yMwo = yOrg;
    }

    if (lpobj->pCurMdc->xMwe && lpobj->pCurMdc->yMwe) {
        SetWindowOrg (hdc, 
            (lpobj->pCurMdc->xMwo - MulDiv (lpobj->pMetaInfo->xro, 
                                        lpobj->pCurMdc->xMwe,
                                        lpobj->pCurMdc->xre)),
            (lpobj->pCurMdc->yMwo - MulDiv (lpobj->pMetaInfo->yro, 
                                        lpobj->pCurMdc->yMwe,
                                        lpobj->pCurMdc->yre)));
    }
}


void SetPictExt (lpobj, hdc, xExt, yExt)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xExt;
int         yExt;
{
    lpobj->pCurMdc->xMwe = xExt;
    lpobj->pCurMdc->yMwe = yExt;

    SetWindowExt (hdc, 
        MulDiv (lpobj->pMetaInfo->xwe, xExt, lpobj->pCurMdc->xre),
        MulDiv (lpobj->pMetaInfo->ywe, yExt, lpobj->pCurMdc->yre));

    SetWindowOrg (hdc, 
        (lpobj->pCurMdc->xMwo 
            - MulDiv (lpobj->pMetaInfo->xro, xExt, lpobj->pCurMdc->xre)),
        (lpobj->pCurMdc->yMwo 
            - MulDiv (lpobj->pMetaInfo->yro, yExt, lpobj->pCurMdc->yre)));
}


void ScalePictExt (lpobj, hdc, xNum, xDenom, yNum, yDenom)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xNum;
int         xDenom;
int         yNum;
int         yDenom;
{
    SetPictExt (lpobj, hdc, MulDiv (lpobj->pCurMdc->xMwe, xNum, xDenom),
        MulDiv (lpobj->pCurMdc->yMwe, yNum, yDenom));
}


void ScaleRectExt (lpobj, hdc, xNum, xDenom, yNum, yDenom)
LPOBJECT_MF lpobj;
HDC         hdc;
int         xNum;
int         xDenom;
int         yNum;
int         yDenom;
{
    lpobj->pCurMdc->xre = MulDiv (lpobj->pCurMdc->xre, xNum, xDenom);
    lpobj->pCurMdc->yre = MulDiv (lpobj->pCurMdc->yre, yNum, yDenom);
    
    SetPictExt (lpobj, hdc, lpobj->pCurMdc->xMwe, lpobj->pCurMdc->yMwe); 
}



BOOL PushDc (lpobj)
LPOBJECT_MF lpobj;
{
    HANDLE  hNode = NULL;
    PMETADC pNode = NULL;
        
    if ((hNode = LocalAlloc (LMEM_MOVEABLE, sizeof (METADC)))
            && (pNode = (PMETADC) LocalLock (hNode))) {
        *pNode =  *lpobj->pCurMdc;
        lpobj->pCurMdc->pNext = pNode;
        pNode->pNext = NULL;
        lpobj->pCurMdc = pNode;
        LocalUnlock (hNode);
        return TRUE;
    }
    
    if (pNode)
        LocalFree (hNode);

    lpobj->error = OLE_ERROR_MEMORY;    
    return FALSE;
}


BOOL PopDc (lpobj)
LPOBJECT_MF lpobj;
{
    PMETADC pPrev = (PMETADC) (lpobj->pMetaInfo);
    PMETADC pCur  = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;
        
    if (!pCur)
        // more Pops than Pushes
        return FALSE;
    
    while (pCur->pNext) {
        pPrev = pCur;
        pCur  = pCur->pNext;
    }

    if (hCur = LocalHandle ((WORD) pCur))
        LocalFree (hCur);
    pPrev->pNext    = NULL;
    lpobj->pCurMdc  = pPrev;
}


void CleanStack(lpobj, hMetaInfo)
LPOBJECT_MF lpobj;
HANDLE      hMetaInfo;
{
    PMETADC pCur = ((PMETADC) (lpobj->pMetaInfo))->pNext;
    HANDLE  hCur;
    
    while (pCur) {
        hCur = LocalHandle ((WORD) pCur);
        ((PMETADC) (lpobj->pMetaInfo))->pNext = pCur = pCur->pNext;
        if (hCur)
            LocalFree (hCur);
    }

    LocalFree (hMetaInfo);
    lpobj->fMetaDC      = FALSE;
    lpobj->pCurMdc      = NULL;
    lpobj->pMetaInfo    = NULL;
}

#ifdef META_DEBUG
void PutMetaFuncName (value)
WORD value;
{
    switch (value) {
        case META_SETBKCOLOR:
             OutputDebugString ("SetBkColor ");
             break;
                 
        case META_SETBKMODE:
             OutputDebugString ("SetBkMode ");
             break;
                            
        case META_SETMAPMODE:
             OutputDebugString ("SetMapMode ");
             break;
                        
        case META_SETROP2:
             OutputDebugString ("SetRop2 ");
             break;
                            
        case META_SETRELABS:
             OutputDebugString ("SetRelabs ");
             break;
                            
        case META_SETPOLYFILLMODE:
             OutputDebugString ("SetPolyfillMode ");
             break;
                            
        case META_SETSTRETCHBLTMODE:
             OutputDebugString ("SetStretchBltMode ");
             break;
                            
        case META_SETTEXTCHAREXTRA:
             OutputDebugString ("SetTextCharExtra ");
             break;
                            
        case META_SETTEXTCOLOR:
             OutputDebugString ("SetTextColor ");
             break;
                            
        case META_SETTEXTJUSTIFICATION:
             OutputDebugString ("SetTextJustification ");
             break;
                            
        case META_SETWINDOWORG:
             OutputDebugString ("SetWindowOrg ");
             break;
                            
        case META_SETWINDOWEXT:
             OutputDebugString ("SetWindowExt ");
             break;
                            
        case META_SETVIEWPORTORG:
             OutputDebugString ("SetViewportOrg ");
             break;
                            
        case META_SETVIEWPORTEXT:
             OutputDebugString ("SetViewportExt ");
             break;
                            
        case META_OFFSETWINDOWORG:
             OutputDebugString ("OffsetWindowOrg ");
             break;
                            
        case META_SCALEWINDOWEXT:
             OutputDebugString ("ScaleWindowExt ");
             break;
                            
        case META_OFFSETVIEWPORTORG:
             OutputDebugString ("OffsetViewportOrg ");
             break;
                            
        case META_SCALEVIEWPORTEXT:
             OutputDebugString ("ScaleViewportExt ");
             break;
                            
        case META_LINETO:
             OutputDebugString ("LineTo ");
             break;
                            
        case META_MOVETO:
             OutputDebugString ("MoveTo ");
             break;
                            
        case META_EXCLUDECLIPRECT:
             OutputDebugString ("ExcludeCliprect ");
             break;
                            
        case META_INTERSECTCLIPRECT:
             OutputDebugString ("IntersectCliprect ");
             break;
                            
        case META_ARC:
             OutputDebugString ("Arc ");
             break;
                            
        case META_ELLIPSE:
             OutputDebugString ("Ellipse ");
             break;
                            
        case META_FLOODFILL:
             OutputDebugString ("FloodFill ");
             break;
                            
        case META_PIE:
             OutputDebugString ("Pie ");
             break;
                            
        case META_RECTANGLE:
             OutputDebugString ("Rectangle ");
             break;
                            
        case META_ROUNDRECT:
             OutputDebugString ("RoundRect ");
             break;
                            
        case META_PATBLT:
             OutputDebugString ("PatBlt ");
             break;
                            
        case META_SAVEDC:
             OutputDebugString ("SaveDC ");
             break;
                            
        case META_SETPIXEL:
             OutputDebugString ("SetPixel ");
             break;
                            
        case META_OFFSETCLIPRGN:
             OutputDebugString ("OffsetClipRegion ");
             break;
                            
        case META_TEXTOUT:
             OutputDebugString ("TextOut ");
             break;
                            
        case META_BITBLT:
             OutputDebugString ("BitBlt ");
             break;
                            
        case META_STRETCHBLT:
             OutputDebugString ("StrechBlt ");
             break;
                            
        case META_POLYGON:
             OutputDebugString ("Polygon ");
             break;
                            
        case META_POLYLINE:
             OutputDebugString ("PolyLine ");
             break;
                            
        case META_ESCAPE:
             OutputDebugString ("Escape ");
             break;
                            
        case META_RESTOREDC:
             OutputDebugString ("RestoreDC ");
             break;
                            
        case META_FILLREGION:
             OutputDebugString ("FillRegion ");
             break;
                            
        case META_FRAMEREGION:
             OutputDebugString ("FrameRegion ");
             break;
                            
        case META_INVERTREGION:
             OutputDebugString ("InvertRegion ");
             break;
                            
        case META_PAINTREGION:
             OutputDebugString ("PaintRegion ");
             break;
                            
        case META_SELECTCLIPREGION:
             OutputDebugString ("SelectClipRegion ");
             break;
                            
        case META_SELECTOBJECT:
             OutputDebugString ("SelectObject ");
             break;
                            
        case META_SETTEXTALIGN:
             OutputDebugString ("SetTextAlign ");
             break;
                            
        case META_DRAWTEXT:
             OutputDebugString ("DrawText");
             break;
                            
        case META_CHORD:
             OutputDebugString ("Chord ");
             break;
                            
        case META_SETMAPPERFLAGS:
             OutputDebugString ("SetMapperFlags ");
             break;
                            
        case META_EXTTEXTOUT:
             OutputDebugString ("ExtTextOut ");
             break;
                            
        case META_SETDIBTODEV:
             OutputDebugString ("SetDIBitsToDevice ");
             break;
                            
        case META_SELECTPALETTE:
             OutputDebugString ("SelectPalette ");
             break;
                            
        case META_REALIZEPALETTE:
             OutputDebugString ("RealizePalette ");
             break;
                            
        case META_ANIMATEPALETTE:
             OutputDebugString ("AnimatePalette ");
             break;
                            
        case META_SETPALENTRIES:
             OutputDebugString ("SetPaletteEntries ");
             break;
                            
        case META_POLYPOLYGON:
             OutputDebugString ("PolyPolygon ");
             break;
                            
        case META_RESIZEPALETTE:
             OutputDebugString ("ResizePalette ");
             break;
                            
        case META_DIBBITBLT:
             OutputDebugString ("DibBitBlt ");
             break;
                            
        case META_DIBSTRETCHBLT:
             OutputDebugString ("DibStrechBlt ");
             break;
                            
        case META_DIBCREATEPATTERNBRUSH:
             OutputDebugString ("DibCreatePatternBrush ");
             break;
                            
        case META_STRETCHDIB:
             OutputDebugString ("StretchDIBits ");
             break;
                            
        case META_DELETEOBJECT:
             OutputDebugString ("DeleteObject ");
             break;
                            
        case META_CREATEPALETTE:
             OutputDebugString ("CreatePalette ");
             break;
                            
        case META_CREATEBRUSH:
             OutputDebugString ("CreateBrush ");
             break;
                            
        case META_CREATEPATTERNBRUSH:
             OutputDebugString ("CreatePatternBrush ");
             break;
                            
        case META_CREATEPENINDIRECT:
             OutputDebugString ("CreatePenIndirect ");
             break;
                            
        case META_CREATEFONTINDIRECT:
             OutputDebugString ("CreateFontIndirect ");
             break;
                            
        case META_CREATEBRUSHINDIRECT:
             OutputDebugString ("CreateBrushIndirect ");
             break;
                            
        case META_CREATEBITMAPINDIRECT:
             OutputDebugString ("CreateBitmapIndirect ");
             break;
                            
        case META_CREATEBITMAP:
             OutputDebugString ("CreateBitmap ");
             break;
                            
        case META_CREATEREGION:
             OutputDebugString ("CreateRegion ");
             break;
             
        default:
             OutputDebugString ("Invalid+Function+encountered ");
             break;
                            
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\error.c ===
/****************************** Module Header ******************************\
* Module Name: ERROR.C
*
* PURPOSE:  Contains routines which are commonly used, as method functions, by
*           bm.c, mf.c and dib.c. These routines do nothing more than 
*           returning an error code.
*
* Created: November 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik (11/20/90)   Original
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"
#include "pict.h"

OLESTATUS FARINTERNAL ErrQueryRelease (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrPlay (lpobj, verb, fShow, fAct)
WORD      verb;
LPOLEOBJECT lpobj;
BOOL      fAct;
BOOL      fShow;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrShow (lpobj, fAct)
LPOLEOBJECT lpobj;
BOOL        fAct;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL ErrAbort (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;
}

OLESTATUS FARINTERNAL  ErrCopyFromLink(lpobj, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetHostNames (lpobj, lpclientName, lpdocName)
LPOLEOBJECT lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetTargetDevice (lpobj, hDevInfo)
LPOLEOBJECT lpobj;
HANDLE      hDevInfo;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS   FARINTERNAL  ErrSetColorScheme (lpobj, lplogpal)
LPOLEOBJECT     lpobj;
LPLOGPALETTE    lplogpal;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL  ErrSetBounds(lpobj, lprc)
LPOLEOBJECT lpobj;
LPRECT      lprc;
{
    return OLE_ERROR_MEMORY;
}


OLESTATUS FARINTERNAL  ErrQueryOpen (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrActivate (lpobj, verb, fShow, fAct, hWnd, lprc)
LPOLEOBJECT lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fAct;
HWND        hWnd;
LPRECT      lprc;
{
    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrEdit (lpobj, fShow, hWnd, lprc)
LPOLEOBJECT lpobj;
BOOL        fShow;
HWND        hWnd;
LPRECT      lprc;
{
    return OLE_ERROR_STATIC;      // static object
}

OLESTATUS FARINTERNAL  ErrClose (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrUpdate (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object
}


OLESTATUS FARINTERNAL  ErrReconnect (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_ERROR_STATIC;      // static object

}


OLESTATUS FARINTERNAL ErrSetData (lpobj, cfFormat, hData)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    return OLE_ERROR_MEMORY;
}


OLESTATUS   FARINTERNAL  ErrReadFromStream (lpobj, cfFormat, lpstream)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
LPOLESTREAM     lpstream;
{
    return OLE_ERROR_STREAM;
}



OLESTATUS FARINTERNAL ErrQueryOutOfDate (lpobj)
LPOLEOBJECT lpobj;
{
    return OLE_OK;
}


OLESTATUS FARINTERNAL ErrObjectConvert (lpobj, lpprotocol, lpclient, lhclientdoc, lpobjname, lplpobj)
LPOLEOBJECT         lpobj;
LPSTR               lpprotocol;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
{
    return OLE_ERROR_STATIC;
}


OLESTATUS FARINTERNAL ErrGetUpdateOptions (lpobj, lpoptions)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE  FAR  *lpoptions;
{
    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrSetUpdateOptions (lpobj, options)
LPOLEOBJECT         lpobj;
OLEOPT_UPDATE       options;
{
    return OLE_ERROR_STATIC;

}

LPVOID  FARINTERNAL ErrQueryProtocol (lpobj, lpprotocol)
LPOLEOBJECT lpobj;
LPSTR       lpprotocol;
{
    return NULL;
}

OLESTATUS FARINTERNAL ErrRequestData (lpobj, cfFormat)
LPOLEOBJECT     lpobj;
OLECLIPFORMAT   cfFormat;
{
    return OLE_ERROR_STATIC;

}

OLESTATUS FARINTERNAL ErrExecute (lpobj, hData, wReserved)
LPOLEOBJECT     lpobj;
HANDLE          hData;
WORD            wReserved;
{
    return OLE_ERROR_STATIC;
}



OLESTATUS FARINTERNAL ErrObjectLong (lpobj, wFlags, lplong)
LPOLEOBJECT     lpobj;
WORD            wFlags;
LPLONG          lplong;
{
    return OLE_ERROR_STATIC;
}


HANDLE FARINTERNAL DuplicateGDIdata (hSrcData, cfFormat)
HANDLE          hSrcData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpSrcMfp;
        LPMETAFILEPICT  lpDstMfp = NULL;        
        HANDLE          hMF = NULL;
        HANDLE          hDstMfp = NULL;
        
        if (!(lpSrcMfp = (LPMETAFILEPICT) GlobalLock(hSrcData)))
            return NULL;
        
        GlobalUnlock (hSrcData);
        
        if (!(hMF = CopyMetaFile (lpSrcMfp->hMF, NULL)))
            return NULL;
        
        if (!(hDstMfp = GlobalAlloc (GMEM_MOVEABLE, sizeof(METAFILEPICT))))
            goto errMfp;    

        if (!(lpDstMfp = (LPMETAFILEPICT) GlobalLock (hDstMfp)))
            goto errMfp;
        
        GlobalUnlock (hDstMfp);
        
        *lpDstMfp = *lpSrcMfp;
        lpDstMfp->hMF = hMF;
        return hDstMfp;
errMfp:
        if (hMF)
            DeleteMetaFile (hMF);
        
        if (hDstMfp)
            GlobalFree (hDstMfp);
        
        return NULL;
    }
    
    if (cfFormat == CF_BITMAP) {
        DWORD dwSize;
        
        return BmDuplicate (hSrcData, &dwSize, NULL);
    }
    
    if (cfFormat == CF_DIB) 
        return DuplicateGlobal (hSrcData, GMEM_MOVEABLE);
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\funchead.c ===
//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//   
//  The main library entry point. This routine is called when the library 
//  is loaded.
//   
//  Arguments:
// 
//      hInst       -
//      wDataSeg    -
//      cbHeapSize  -
//      lpszCmdLine -
//
//  Returns:   
//   
//  Effects:     
//   
//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\ledde.c ===
/****************************** Module Header ******************************\
* Module Name: LEDDE.C
*
* Purpose: ?????
*              
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, Srinik   (../../1990,91)  Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dde.h"
#include "dll.h"

#define LN_FUDGE        16      // [],(), 3 * 3 (2 double quotes and comma)
#define RUNITEM

#define OLEVERB_CONNECT     0xFFFF

// Definitions for sending the server sys command.
char *srvrSysCmd[] = {"StdNewFromTemplate",
                      "StdNewDocument",
                      "StdEditDocument",
                      "StdOpenDocument"
                      };

#define EMB_ID_INDEX    11          // index of ones digit in #00
extern  char    embStr[];
extern  BOOL    gbCreateInvisible;
extern  BOOL    gbLaunchServer;

extern  ATOM    aMSDraw;

extern  BOOL (FAR PASCAL *lpfnIsTask) (HANDLE);

// !!! set error hints

OLESTATUS FARINTERNAL LeDoVerb (lpobj, verb, fShow, fActivate)
LPOBJECT_LE lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->verb = verb;
    lpobj->fCmd = ACT_DOVERB;

    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_RUN, DOCSHOW);
    return DocShow (lpobj);
}



OLESTATUS FARINTERNAL LeShow (lpobj, fActivate)
LPOBJECT_LE lpobj;
BOOL        fActivate;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!QueryOpen(lpobj))
        return OLE_OK;

    lpobj->fCmd = ACT_SHOW;
    InitAsyncCmd (lpobj, OLE_SHOW, DOCSHOW);
    return DocShow (lpobj);
}


// DocShow : If the server is connected, show the item
// for editing. For embedded objects us NULL Item.
OLESTATUS DocShow (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case 0:
            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


void SendStdShow (lpobj)
LPOBJECT_LE lpobj;
{

    WORD    len;
    WORD    size;
    LPSTR   lpdata = NULL;
    HANDLE  hdata = NULL;
    BOOL    bShow;

    lpobj->subErr = OLE_OK;
    
    if (lpobj->verb == OLEVERB_CONNECT) {
        lpobj->verb = NULL;
        return;
    }
    
    if (!(lpobj->fCmd & (ACT_SHOW | ACT_DOVERB)))
        return;

    if (bShow = (!lpobj->bOleServer || !(lpobj->fCmd & ACT_DOVERB))) {

        // show is off, do not show the server.
        if (!(lpobj->fCmd & ACT_SHOW))
            return;

        SETERRHINT(lpobj, OLE_ERROR_SHOW);
        //  and 18 "[StdShowItem(\"")for 5 extra for ",FALSE
        len = 18 + 7;
    } else {
        // 19 for the string [StdDoVerbItem(\"") and
        // 18 extra is for ",000,FALSE,FALSE
        SETERRHINT(lpobj, OLE_ERROR_DOVERB);
        len = 19 + 18;
    }

    len += GlobalGetAtomLen (lpobj->item);

    len +=  4;                 // ")]" + NULL

    hdata = GlobalAlloc (GMEM_DDESHARE, size = len);
    if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
        goto errRtn;

    if (bShow)
        lstrcpy (lpdata, "[StdShowItem(\"");
    else
        lstrcpy (lpdata, "[StdDoVerbItem(\"");

    len = lstrlen (lpdata);

    if (lpobj->item)
        GlobalGetAtomName (lpobj->item , lpdata + len, size - len);

    if (!bShow) {

        lstrcat (lpdata, (LPSTR)"\",");
        // assume that the number of verbs are < 10

        len = lstrlen (lpdata);
#ifdef  FIREWALLS
        ASSERT ( (lpobj->verb & 0x000f) < 9 , "Verb value more than 9");
#endif
        lpdata += len;
        *lpdata++ = (char)((lpobj->verb & 0x000f) + '0');
        *lpdata = 0;

        if (lpobj->fCmd & ACT_SHOW)
            lstrcat (lpdata, (LPSTR) ",TRUE");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE");
                // StdVerbItem (item, verb, TRUE
        // add TRUE/FALSE constant for the activate
        if (!(lpobj->fCmd & ACT_ACTIVATE))
            lstrcat (lpdata, (LPSTR) ",TRUE)]");
        else
            lstrcat (lpdata, (LPSTR) ",FALSE)]");
            // [StdDoVerb ("item", verb, FALSE, FALSE)]
    } else
        lstrcat (lpdata, (LPSTR)"\")]");
        // apps like excel and wingraph do not suuport activate at
        // item level.


    GlobalUnlock (hdata);
    DocExecute (lpobj, hdata);
    return;

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);

    lpobj->subErr = OLE_ERROR_MEMORY;
    return;
}



OLESTATUS FARINTERNAL  LeQueryOpen (LPOBJECT_LE lpobj)
{

    if (QueryOpen(lpobj))
       return OLE_OK;
    else
       return OLE_ERROR_NOT_OPEN;

}


BOOL    INTERNAL  QueryOpen (LPOBJECT_LE lpobj)
{

    if (lpobj->pDocEdit &&  lpobj->pDocEdit->hClient) {
        if (IsServerValid (lpobj))
            return TRUE;
        // destroy the windows and pretend as if the server was never
        // connected.

        DestroyWindow (lpobj->pDocEdit->hClient);
        if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
            DestroyWindow (lpobj->pSysEdit->hClient);

    }
    return FALSE;
}



OLESTATUS FARINTERNAL  LeActivate (lpobj, verb, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE lpobj;
WORD        verb;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    lpobj->verb = verb;
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbOpen (lpobj, fShow, fActivate, hWnd, lprc);
    
#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkOpen (lpobj, fShow, fActivate, hWnd, lprc);
    
}


OLESTATUS FARINTERNAL  LeUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    if (lpobj->head.ctype == CT_EMBEDDED)
        return EmbUpdate (lpobj);
    
#ifdef  FIREWALLS
    ASSERT (lpobj->head.ctype == CT_LINK, "unknown object");
#endif
    return LnkUpdate (lpobj);
}



OLESTATUS FARINTERNAL  EmbOpen (lpobj, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE lpobj;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if(QueryOpen (lpobj))
        return LeDoVerb (lpobj, lpobj->verb, fShow, fActivate);

    // show the window
    // advise for data only on close
    // and shut down the conv  after the advises.

    lpobj->fCmd = LN_EMBACT | ACT_DOVERB | ACT_ADVISE | ACT_CLOSE;
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



/***************************** Public  Function ****************************\
* OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
*
* This function updates an EMB object. If the server is connected
* simply send a request for the native as well as the display formats.
* If the server is connected, then tries to start the conversationa and
* get the data. If the conversation fails, then load the server and
* start the conversation. The embeded objects may have links in it.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/


OLESTATUS FARINTERNAL  EmbUpdate (lpobj)
LPOBJECT_LE lpobj;
{

    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    lpobj->fCmd = LN_EMBACT | ACT_REQUEST | (QueryOpen(lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, EMBOPENUPDATE);
    return EmbOpenUpdate (lpobj);

}



OLESTATUS FARINTERNAL  EmbOpenUpdate (lpobj)
LPOBJECT_LE lpobj;
{

    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step6);
            SendSrvrMainCmd  (lpobj, lpobj->lptemplate);
            lpobj->lptemplate = NULL;
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            // Init doc conversation should set the failure error
            if (!InitDocConv (lpobj, !POPUP_NETDLG))
                 goto errRtn;

            // If there is no native data, do not do any poke.
            // creates will not have any poke data to start with

            SKIP_TO (!(lpobj->hnative), step6);
            PokeNativeData (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            if (ProcessErr (lpobj))
                 goto errRtn;
            // Now poke the hostnames etc stuff.
            PokeHostNames (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 3:

            // do not worry about the poke hostname errors
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 4:

            PokeDocDimensions (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 5:

            PokeColorScheme (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 6:

            step6:

            // wingraph does not accept the  doc dimensions
            // after sttedit.
            CLEAR_STEP_ERROR (lpobj);
            SETSTEP (lpobj, 6);
            STEP_NOP (lpobj);
            // step_nop simply increments the step numebr
            // merge the steps later on



        case 7:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step11);
            lpobj->optUpdate = oleupdate_onsave;
            lpobj->pDocEdit->nAdviseSave = 0;
            AdviseOn (lpobj, cfNative, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 8:

            // do not go for errors on /save. Some servers may not support
            // this.

            CLEAR_STEP_ERROR (lpobj);
            AdvisePict (lpobj, aSave);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 9:

            // do not worry about the error case for save. Ignore them

            CLEAR_STEP_ERROR (lpobj);
            lpobj->optUpdate = oleupdate_onclose;
            lpobj->pDocEdit->nAdviseClose = 0;
            AdviseOn (lpobj, cfNative, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 10:
            if (ProcessErr(lpobj))
                goto errRtn;

            AdvisePict (lpobj, aClose);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 11:

            step11:
            SETSTEP (lpobj, 11);
            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step13);
            
            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

            // If request pict fails, then native and pict are
            // not in sync.

        case 12:
            if (ProcessErr(lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 13:

            step13:
            SETSTEP(lpobj, 13);

            if (ProcessErr(lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 14:


            if (ProcessErr(lpobj))
                goto errRtn;

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step15);
            return EndAsyncCmd (lpobj);


        case 15:

errRtn:
            step15:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE) 
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);
                
            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;


      default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}




OLESTATUS FARINTERNAL  LnkOpen (lpobj, fShow, fActivate, hWnd, lprc)
LPOBJECT_LE    lpobj;
BOOL        fShow;
BOOL        fActivate;
HWND        hWnd;
LPRECT      lprc;
{

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if(QueryOpen (lpobj))
        return LeDoVerb (lpobj, lpobj->verb, fShow, fActivate);

    // Just end the system conversation. we are not unloading
    // this instance at all.

    lpobj->fCmd = LN_LNKACT |  ACT_DOVERB;

    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    else if (lpobj->optUpdate == oleupdate_onsave)
        lpobj->fCmd |= ACT_ADVISE;
    
    if (fActivate)
        lpobj->fCmd |= ACT_ACTIVATE;

    if (fShow)
        lpobj->fCmd |= ACT_SHOW;

    InitAsyncCmd (lpobj, OLE_ACTIVATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);

}


OLESTATUS FARINTERNAL  LnkUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    // if we are loading the server, then definitly unload.
    // if the connection is established, then unload if it is
    // to be unloaded, when  all the previous requests are satisfied.


    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | (QueryOpen (lpobj) ? 0 : ACT_UNLAUNCH);
    InitAsyncCmd (lpobj, OLE_UPDATE, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}



OLESTATUS FARINTERNAL  LnkOpenUpdate (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case 0:

            SKIP_TO (QueryOpen(lpobj), step2);
            InitDocConv (lpobj, !POPUP_NETDLG);
            if (QueryOpen(lpobj)) {
                if (lpobj->app == aPackage)
                    RemoveLinkStringFromTopic (lpobj);
                goto step2;
            }
            
            SendSrvrMainCmd (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);


        case 1:

            if (ProcessErr (lpobj))
                 goto errRtn;

            if (lpobj->app == aPackage)
                RemoveLinkStringFromTopic (lpobj);
            
            if (!InitDocConv (lpobj, POPUP_NETDLG)) {
                lpobj->subErr = OLE_ERROR_OPEN;
                goto errRtn;
            }

        case 2:

            step2:

            SETSTEP (lpobj, 2);
            PokeTargetDeviceInfo (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
  
       case 3:

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_ADVISE), step6);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step4);
            AdviseOn (lpobj, cfNative, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 4:
            step4:
            SETSTEP  (lpobj, 4);
            if (ProcessErr (lpobj))
                goto errRtn;

            AdvisePict (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 5:

            if (ProcessErr (lpobj))
                goto errRtn;

            // Now send advise for renaming the documnet.
            AdviseOn (lpobj, cfBinary, aStdDocName);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 6:

            step6:
            // if name advise fails ignore it
            SETSTEP (lpobj, 6);

            CLEAR_STEP_ERROR (lpobj);
            SKIP_TO (!(lpobj->fCmd & ACT_REQUEST), step8);
            SKIP_TO (!(lpobj->fCmd & ACT_NATIVE), step7);
            
            // we don't want to send OLE_CHANGED when we get this data, if we
            // are going to request for picture data also.
            lpobj->pDocEdit->bCallLater = ((lpobj->lpobjPict) ? TRUE: FALSE);
            RequestOn (lpobj, cfNative);
            WAIT_FOR_ASYNC_MSG (lpobj);

       case 7:
            step7:

            SETSTEP (lpobj, 7);
            if (ProcessErr (lpobj))
                goto errRtn;

            lpobj->pDocEdit->bCallLater = FALSE;
            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 8:

            step8:

            SETSTEP     (lpobj, 8);
            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMDOC), step10);
            // terminate the document conversataion.
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
    
      case 9:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteDocEdit (lpobj);

            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step14);
            return EndAsyncCmd (lpobj);

      case 10:

            step10:
            SETSTEP     (lpobj, 10);

            if (ProcessErr (lpobj))
                goto errRtn;

            SKIP_TO (!(lpobj->fCmd & ACT_TERMSRVR), step12);

            // terminate the server conversataion.
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 11:

            if (ProcessErr (lpobj))
                goto errRtn;

            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


      case 12:

            step12:
            SETSTEP     (lpobj, 12);
            if (ProcessErr (lpobj))
                goto errRtn;

            SendStdShow (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

      case 13:

            if (ProcessErr (lpobj))
                goto errRtn;
            SKIP_TO ((lpobj->fCmd & ACT_UNLAUNCH), step14);
            return EndAsyncCmd (lpobj);


      case 14:

            errRtn:
            step14:
            ProcessErr (lpobj);

            if ((lpobj->asyncCmd == OLE_UPDATE) 
                    && (!(lpobj->fCmd & ACT_UNLAUNCH)))
                return EndAsyncCmd (lpobj);
                
            // if we launched and error, unlaunch (send stdexit)
            NextAsyncCmd (lpobj, EMBLNKDELETE);
            lpobj->fCmd |= ACT_UNLAUNCH;
            EmbLnkDelete (lpobj);
            return lpobj->mainErr;

       default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



OLESTATUS EmbLnkClose (lpobj)
LPOBJECT_LE lpobj;
{
    switch (lpobj->subRtn) {

        case    0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);
            return EndAsyncCmd (lpobj);


        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS FARINTERNAL  LeClose (lpobj)
LPOBJECT_LE lpobj;
{
    PROBE_ASYNC (lpobj);
    if (IS_SVRCLOSING(lpobj))
        return OLE_OK;
    
    
    lpobj->fCmd = 0;
    
    if (lpobj->head.ctype == CT_EMBEDDED) {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKDELETE);
        return EmbLnkDelete (lpobj);    
    }
    else {
        InitAsyncCmd (lpobj, OLE_CLOSE, EMBLNKCLOSE);
        return EmbLnkClose (lpobj);
    }
}



OLESTATUS FARINTERNAL  LeReconnect (lpobj)
LPOBJECT_LE    lpobj;
{
    // check for the existing conversation.
    // if the client window is non-null, then
    // connection exits.

    if (lpobj->head.ctype != CT_LINK)
        return OLE_ERROR_NOT_LINK;     // allow only for linked

    PROBE_ASYNC (lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (QueryOpen (lpobj))
        return OLE_OK;

    // start just the conversation. Do not load
    // the app.

    if (!InitDocConv (lpobj, !POPUP_NETDLG))
         return OLE_OK;             // document is not loaded , it is OK.

    lpobj->fCmd = LN_LNKACT;
    if (lpobj->optUpdate == oleupdate_always)
        lpobj->fCmd |= ACT_ADVISE | ACT_REQUEST;
    
    InitAsyncCmd (lpobj, OLE_RECONNECT, LNKOPENUPDATE);
    return LnkOpenUpdate (lpobj);
}




OLESTATUS INTERNAL PokeNativeData (lpobj)
LPOBJECT_LE lpobj;
{
   SETERRHINT(lpobj, OLE_ERROR_POKE_NATIVE);
   return SendPokeData (lpobj,
                    lpobj->item,
                    lpobj->hnative,
                    cfNative);
}




BOOL INTERNAL PostMessageToServer (pedit, msg, lparam)
PEDIT_DDE   pedit;
WORD        msg;
LONG        lparam;
{

#ifdef  FIREWALLS
    ASSERT (pedit, "Dde edit block is NULL");
#endif
    // save the lparam and msg fpr possible reposting incase of error.

    // we are in abort state.  no messages except for terminate.

    if (pedit->bAbort && msg != WM_DDE_TERMINATE)
        return FALSE;

    pedit->lParam = lparam;
    pedit->msg    = msg;

    if (pedit->hClient && pedit->hServer) {
        while (TRUE){
            if (!IsWindowValid (pedit->hServer))
                return FALSE;
            if (PostMessage (pedit->hServer, msg, pedit->hClient, lparam) == FALSE)
                Yield ();
            else
                return TRUE;
        }
    }
    return FALSE;
}


OLESTATUS FARINTERNAL LeCreateFromTemplate (lpclient, lptemplate, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPOLECLIENT         lpclient;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    char            buf[MAX_STR];

    if (!MapExtToClass (lptemplate, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;

    return CreateFromClassOrTemplate (lpclient, (LPSTR) buf, lplpoleobject, 
                        optRender, cfFormat, LN_TEMPLATE, lptemplate, 
                        lhclientdoc, lpobjname);
}


OLESTATUS FARINTERNAL LeCreate (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat)
LPSTR               lpclass;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
{
    if (gbCreateInvisible) {
        // this is in fact a call for invisible create
        return LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, 
                        lplpoleobject, optRender, cfFormat, gbLaunchServer);
    }
    
    return CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject, 
                        optRender, cfFormat, LN_NEW, NULL, 
                        lhclientdoc, lpobjname);
}



OLESTATUS FARINTERNAL CreateFromClassOrTemplate (lpclient, lpclass, lplpoleobject, optRender, cfFormat, lnType, lptemplate, lhclientdoc, lpobjname)
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
WORD                lnType;
LPSTR               lptemplate;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [2];
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }
    
    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    SetEmbeddedTopic (lpobj);
    lpobj->item          = NULL;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    lpobj->aServer       = aServer;

    // launch the app and start the system conversation.
        
    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass))
        goto errRtn;

        
    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = lnType | ACT_SHOW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, lptemplate? OLE_CREATEFROMTEMPLATE : OLE_CREATE, EMBOPENUPDATE);
    *lplpoleobject = (LPOLEOBJECT)lpobj;

    lpobj->lptemplate = lptemplate;
    
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj); 
        *lplpoleobject = NULL;
    }
    
    return retval;
}



OLESTATUS FARINTERNAL CreateEmbLnkFromFile (lpclient, lpclass, lpfile, lpitem, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, objType)
LPOLECLIENT         lpclient;
LPSTR               lpclass;
LPSTR               lpfile;
LPSTR               lpitem;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    OLESTATUS           retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE         lpobj = NULL;
    ATOM                aServer;
    char                buf[MAX_STR];
    OLE_RELEASE_METHOD  releaseMethod;
    WORD                wFlags = NULL;
    char                chVerb[2];

    if (!lpclass && (lpclass = (LPSTR) buf) 
            && !MapExtToClass (lpfile, (LPSTR)buf, MAX_STR))
        return OLE_ERROR_CLASS;
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if (!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_LINK))) {
        GlobalDeleteAtom (aServer);
        goto errFileCreate;
    }
    
    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->topic         = GlobalAddAtom (lpfile);
    lpobj->aServer       = aServer;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    if ((retval = SetNetName (lpobj)) != OLE_OK)
        goto errFileCreate;
    
    if (lpitem)
        lpobj->item = GlobalAddAtom (lpitem);

    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass)) {
        retval = OLE_ERROR_MEMORY;
        goto errFileCreate;
    }
    
    *lplpoleobject = (LPOLEOBJECT) lpobj;
    
    if (objType == CT_EMBEDDED) {
        releaseMethod = OLE_CREATEFROMFILE;
        if ((optRender == olerender_format) && (cfFormat == cfNative))
            wFlags = 0;
        else
            wFlags = ACT_NATIVE;
    }
    else {          
        // caller wants linked object to be created
        
        // if no presentation data is requested and the link is to the whole
        // file, then there is no need to launch the server. 
            
        if ((optRender == olerender_none) && !lpobj->item)
            return FileExists (lpobj);
        
        // we want to establish hot link
        wFlags = ACT_ADVISE; 
        releaseMethod = OLE_CREATELINKFROMFILE;     
    }

    lpobj->fCmd = LN_LNKACT | ACT_REQUEST | ACT_UNLAUNCH | wFlags;      
    InitAsyncCmd (lpobj, releaseMethod , LNKOPENUPDATE);       
    
    if ((retval = LnkOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;
    
    // If there is error afterwards, then the client app should call
    // to delete the object.


errFileCreate:  

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj); 
        *lplpoleobject = NULL;
    }
    
    return retval;
}



//////////////////////////////////////////////////////////////////////////////
//
// OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, bActivate)
//
//  Arguments:
//
//     lpclient -   
//     lpclass  -   
//     lhclientdoc  -   
//     lpobjname    -   
//     lplpoleobject    -   
//     optRender    -   
//     cfFormat -   
//     fActivate    -
//
//  Returns:
//
//      OLE_ERROR_CLASS -   
//      OLE_OK  -   
//      EmbOpenUpdate (lpobj)   -   
//      retval  -   
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

OLESTATUS FARINTERNAL LeCreateInvisible (lpclient, lpclass, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, fActivate)
LPSTR               lpclass;
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpoleobject;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
BOOL                fActivate;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    LPOBJECT_LE     lpobj = NULL;
    ATOM            aServer;
    char            chVerb [2];
    
    if (!(aServer = GetAppAtom (lpclass)))
        return OLE_ERROR_CLASS;
    
    if(!(lpobj = LeCreateBlank (lhclientdoc, lpobjname, CT_EMBEDDED))) {
        GlobalDeleteAtom (aServer);
        goto errRtn;
    }
    
    // Now set the server.

    lpobj->head.lpclient = lpclient;
    lpobj->app           = GlobalAddAtom (lpclass);
    lpobj->item          = NULL;
    lpobj->bOleServer    = QueryVerb (lpobj, 0, (LPSTR)&chVerb, 2);
    lpobj->aServer       = aServer;
    lpobj->lptemplate    = NULL;
    SetEmbeddedTopic (lpobj);
    
    if (!CreatePictObject (lhclientdoc, lpobjname, lpobj, 
                optRender, cfFormat, lpclass))
        goto errRtn;

    *lplpoleobject = (LPOLEOBJECT)lpobj;
    
    if (!fActivate)
        return OLE_OK;

    // show the window. Advise for data and close on receiving data
    lpobj->fCmd = LN_NEW | ACT_ADVISE | ACT_CLOSE;
    InitAsyncCmd (lpobj, OLE_CREATEINVISIBLE, EMBOPENUPDATE);

    // launch the app and start the system conversation.
    if ((retval = EmbOpenUpdate (lpobj)) <= OLE_WAIT_FOR_RELEASE)
        return retval;

    // If there is error afterwards, then the client app should call
    // to delete the object.

errRtn:

    // for error termination OleDelete will terminate any conversation
    // in action.

    if (lpobj) {
        // This oledelete will not result in asynchronous command.
        OleDelete ((LPOLEOBJECT)lpobj);
        *lplpoleobject = NULL;
    }
    
    return retval;
}



// LeSetUpdateOptions: sets the update options. If the server
// is connectd then it unadvises for the current options and
// advises for the new options.

OLESTATUS   FARINTERNAL LeSetUpdateOptions (lpobj, options)
LPOBJECT_LE         lpobj;
OLEOPT_UPDATE       options;
{

    PROBE_OLDLINK (lpobj);
    PROBE_ASYNC (lpobj);
    
    //!!! make sure the options are within range.
    
    if (lpobj->head.ctype != CT_LINK)
        return (OLE_ERROR_OBJECT);

    if (options > oleupdate_oncall)
        return OLE_ERROR_OPTION;

    if (lpobj->optUpdate == options)
        return OLE_OK;

    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
       lpobj->optUpdate = options;
       return OLE_OK;
    }

    lpobj->optNew = options;
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETUPDATEOPTIONS, LNKSETUPDATEOPTIONS);
    return LnkSetUpdateOptions (lpobj);

}

OLESTATUS   LnkSetUpdateOptions (lpobj)
LPOBJECT_LE         lpobj;
{

    switch (lpobj->subRtn) {

        case 0:

            if (lpobj->optUpdate == oleupdate_oncall)
                goto step1;

            // If the server is active then unadvise for old
            // options.

            UnAdvisePict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:
            step1:

            SETSTEP (lpobj, 1);
            ProcessErr (lpobj);

            lpobj->optUpdate = lpobj->optNew;
            if (lpobj->optUpdate == oleupdate_oncall)
                goto step3;

            AdvisePict (lpobj, NULL);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 2:
            SETSTEP (lpobj, 2);
            if (ProcessErr (lpobj))
                goto errRtn;
            
            if (lpobj->optUpdate == oleupdate_onsave)
                goto step3;

            RequestPict (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);
            
        case 3:
            errRtn:
            step3:
            ProcessErr (lpobj);
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}



//AdvisePict: Sends advise for pict data

void    INTERNAL AdvisePict (lpobj, aAdvItem)
LPOBJECT_LE lpobj;
ATOM        aAdvItem;
{
    int         cftype;

    if (cftype = GetPictType (lpobj))
        AdviseOn (lpobj, cftype, aAdvItem);
}


//UnAdvisePict: Sends unadvise for pict data

void   INTERNAL UnAdvisePict (lpobj)
LPOBJECT_LE         lpobj;
{
    int         cftype;
    SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);
    if (cftype = GetPictType (lpobj))
         UnAdviseOn (lpobj, cftype);
}

// GetPictType: Given the object, returns the pict type.

int     INTERNAL GetPictType (lpobj)
LPOBJECT_LE         lpobj;
{
    if (lpobj->lpobjPict)
        return (int)(*lpobj->lpobjPict->lpvtbl->EnumFormats)
                                (lpobj->lpobjPict, NULL);
    return NULL;
}


// AdviseOn : Sends advise for a given picture type
// Send advise only if the advise options is not on call.

void  INTERNAL AdviseOn (lpobj, cftype, advItem)
LPOBJECT_LE lpobj;
int         cftype;
ATOM        advItem;
{
    HANDLE          hopt   = NULL;
    DDEADVISE FAR   *lpopt = NULL;
    ATOM            item   = NULL;
    PEDIT_DDE       pedit;
    OLESTATUS       retval;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_ADVISE_NATIVE);
    else {
        if (cftype == (int)cfBinary)
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_RENAME);
        else
            SETERRHINT (lpobj, OLE_ERROR_ADVISE_PICT);

    }
    
    if (lpobj->optUpdate == oleupdate_oncall)
        return;

    if(!(hopt = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof(DDEADVISE))))
        goto errRtn;

    retval = OLE_ERROR_MEMORY;
    if(!(lpopt = (DDEADVISE FAR *) GlobalLock (hopt)))
        goto errRtn;

    pedit = lpobj->pDocEdit;
    lpopt->fAckReq = TRUE;

    // get data always. Currently there is no way for the
    // deferred updates.

    lpopt->fDeferUpd = 0;
    lpopt->cfFormat = cftype;
    GlobalUnlock (hopt);

    pedit->hopt = hopt;
    
    if (advItem == aStdDocName)
        item = DuplicateAtom (advItem);
    else
        item = ExtendAtom (lpobj, lpobj->item);

    retval = OLE_ERROR_COMM;
    if (!PostMessageToServer(pedit, WM_DDE_ADVISE, MAKELONG (hopt, item)))
        goto errRtn;

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    pedit->awaitAck = AA_ADVISE;
    lpobj->bAsync    = TRUE;
    
    if (advItem == aClose)
       lpobj->pDocEdit->nAdviseClose++;
    else if (advItem == aSave)
       lpobj->pDocEdit->nAdviseSave++;     
   
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);

    if (lpopt)
        GlobalUnlock (hopt);

    if (hopt)
        GlobalFree (hopt);
    lpobj->subErr = retval;

    return ;


}



//UnAdviseOn: Sends unadvise for an item.
void INTERNAL UnAdviseOn (lpobj, cftype)
LPOBJECT_LE lpobj;
int         cftype;
{
    ATOM        item;
    PEDIT_DDE   pedit;

    pedit  =  lpobj->pDocEdit;
    item    = ExtendAtom (lpobj, lpobj->item);

    if (!PostMessageToServer(pedit, WM_DDE_UNADVISE, MAKELONG (NULL, item)))
        lpobj->subErr = OLE_ERROR_COMM;
    else {
#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
        lpobj->bAsync    = TRUE;
        pedit->awaitAck = AA_UNADVISE;
    }
}

// RequestOn: Semd WM_DDE_REQUEST for the item of the
// for a given type;

void INTERNAL RequestOn (lpobj, cftype)
LPOBJECT_LE lpobj;
int         cftype;
{
    ATOM        item = NULL;
    PEDIT_DDE   pedit;
    OLESTATUS   retval = OLE_ERROR_COMM;

    if (cftype == (int)cfNative)
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_NATIVE);
    else
        SETERRHINT (lpobj, OLE_ERROR_REQUEST_PICT);

    pedit = lpobj->pDocEdit;

    item = DuplicateAtom (lpobj->item);
    if (!PostMessageToServer (pedit, WM_DDE_REQUEST, MAKELONG (cftype, item)))
        goto errRtn;

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_REQUEST;
    return;

errRtn:

    if (item)
        GlobalDeleteAtom (item);
    return ;

}


//RequestPict: Sends request for apicture type.
void INTERNAL RequestPict (lpobj)
LPOBJECT_LE         lpobj;
{
    int cftype;
    
    if (cftype = GetPictType (lpobj))
        RequestOn (lpobj, cftype);
}



// LeSetHostNames: Sets the host names. If the server is connected
// send the host names to the server.
OLESTATUS FARINTERNAL  LeSetHostNames (lpobj, lpclientName, lpdocName)
LPOBJECT_LE lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    OLESTATUS   retval = OLE_ERROR_MEMORY;

    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    if ((retval = SetHostNamesHandle (lpobj, lpclientName, lpdocName)) 
            != OLE_OK) 
        return retval;

    
    // If the server is connected poke the hostnames
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeHostNames (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



OLESTATUS   FARINTERNAL  LeSetTargetDevice (lpobj, hdata)
LPOBJECT_LE lpobj;
HANDLE      hdata;
{
    HANDLE      hdup = NULL;
    OLESTATUS   retval;

    PROBE_ASYNC (lpobj);
    
    if (!hdata) {
        // hdata == NULL means we should not make the target device sticky.
        // This will give the flexibility to the client app. Note that this
        // will not be effective till the next activation.
        if (lpobj->htargetDevice) {
            GlobalFree (lpobj->htargetDevice);
            lpobj->htargetDevice = NULL;
        }
        
        return OLE_OK;
    }
    
    if(!(hdup = DuplicateGlobal (hdata, GMEM_MOVEABLE)))
        return OLE_ERROR_MEMORY;

    if (lpobj->htargetDevice)
        GlobalFree (lpobj->htargetDevice);

    lpobj->htargetDevice = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeTargetDeviceInfo (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);
    
    return retval;
}



OLESTATUS FARINTERNAL  LeSetBounds(lpobj, lprcBounds)
LPOBJECT_LE        lpobj;
LPRECT             lprcBounds;
{
    OLESTATUS       retval = OLE_ERROR_MEMORY;
    HANDLE          hdata = NULL;
    LPBOUNDSRECT    lprc  = NULL;

    PROBE_ASYNC (lpobj);
    
    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    if(!(hdata = GlobalAlloc (GMEM_MOVEABLE, (WORD)sizeof (BOUNDSRECT))))
        return OLE_ERROR_MEMORY;

    if (!(lprc = (LPBOUNDSRECT)GlobalLock (hdata)))
        goto errrtn;

    // Now set the data

    lprc->defaultWidth    =  lprcBounds->right  - lprcBounds->left;;
    lprc->defaultHeight   =  -(lprcBounds->bottom - lprcBounds->top);
    lprc->maxWidth        =  lprcBounds->right  - lprcBounds->left;;
    lprc->maxHeight       =  -(lprcBounds->bottom - lprcBounds->top);

    GlobalUnlock (hdata);

    if (lpobj->hdocDimensions)
        GlobalFree (lpobj->hdocDimensions);

    lpobj->hdocDimensions = hdata;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeDocDimensions (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
    
errrtn:
    if (lprc)
        GlobalUnlock (hdata);
    if (hdata)
        GlobalFree (hdata);
    
    return retval;
}


OLESTATUS FARINTERNAL LeSetData (lpobj, cfFormat, hData)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
HANDLE          hData;
{
    OLESTATUS   retVal = OLE_OK;
    BOOL        fKnown = FALSE;
        
    PROBE_ASYNC (lpobj);
    
    if ((cfFormat == cfObjectLink) || (cfFormat == cfOwnerLink))
        return ChangeDocAndItem (lpobj, hData);
    
    if (fKnown = (cfFormat && (cfFormat == ((WORD) GetPictType (lpobj))))) {
        retVal =  (*lpobj->lpobjPict->lpvtbl->ChangeData) (lpobj->lpobjPict,
                                    hData, lpobj->head.lpclient, FALSE);
                                
        (*lpobj->lpobjPict->lpvtbl->GetData) (lpobj->lpobjPict, 
                                cfFormat, &hData);                      
    }
    else if (fKnown = (cfFormat == cfNative)) {
        retVal = LeChangeData (lpobj, hData, lpobj->head.lpclient, FALSE);
        hData = lpobj->hnative;
    }
    
    if (retVal != OLE_OK)
        return retVal;
    
    if (fKnown) 
        ContextCallBack (lpobj, OLE_CHANGED);
    
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj)) {
        if (!fKnown)
            return OLE_ERROR_NOT_OPEN;
        return OLE_OK;
    }

    // except for the following formats all the other data will be copied
    // into DDEPOKE block. So there is no need to duplicate the data of the
    // other formats
    if ((cfFormat == CF_METAFILEPICT) || (cfFormat == CF_BITMAP)
            || (cfFormat == CF_DIB)) {
            
        if (!(hData = DuplicateGDIdata (hData, cfFormat)))
            return OLE_ERROR_MEMORY;
    }
    
    // *** The last parameter must be NULL, don't change it ***
    InitAsyncCmd (lpobj, OLE_SETDATA, NULL);
    if ((retVal = SendPokeData (lpobj, lpobj->item, hData, cfFormat))
            != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);
    
    return retVal;
}



OLESTATUS   FARINTERNAL  LeSetColorScheme (lpobj, lplogpal)
LPOBJECT_LE     lpobj;
LPLOGPALETTE    lplogpal;
{
    HANDLE      hdup = NULL;
    DWORD       cblogpal;
    OLESTATUS   retval;
    LPBYTE      lptemp;
    
    lptemp = (LPBYTE) lplogpal;
    
    if (lpobj->head.ctype != CT_EMBEDDED)
        return OLE_ERROR_OBJECT;

    PROBE_ASYNC (lpobj);
    
    if (!lplogpal) {
        // lplogpal == NULL means we should not make color scheme sticky.
        // This will give the flexibility to the client app. Note that this
        // will not be effective till next activation.
        if (lpobj->hlogpal) {
            GlobalFree (lpobj->hlogpal);
            lpobj->hlogpal = NULL;
        }
        
        return OLE_OK;
    }
    
    
    FARPROBE_READ(lptemp + (cblogpal = 2*sizeof(WORD)));
    cblogpal += ((sizeof(PALETTEENTRY) * lplogpal->palNumEntries) -1);
    if (!FarCheckPointer (lptemp + cblogpal, READ_ACCESS))
        return OLE_ERROR_PALETTE;

    if (!(hdup = CopyData ((LPSTR) lplogpal, cblogpal)))
        return OLE_ERROR_MEMORY;    
    
    if (lpobj->hlogpal)
        GlobalFree (lpobj->hlogpal);

    lpobj->hlogpal = hdup;
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    if ((retval = PokeColorScheme (lpobj)) != OLE_WAIT_FOR_RELEASE)
        CLEARASYNCCMD(lpobj);

    return retval;
}



//PokeHostNames: Pokes hostname data to the server
OLESTATUS INTERNAL PokeHostNames (lpobj)
LPOBJECT_LE lpobj;
{
    OLESTATUS   retVal = OLE_ERROR_MEMORY;

    // if the server is connectd then poke the host names
    if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

    if (!lpobj->hhostNames) 
        return OLE_OK;
    
    aStdHostNames = GlobalAddAtom ("StdHostNames");
    return SendPokeData (lpobj,aStdHostNames,lpobj->hhostNames,cfBinary);
}


OLESTATUS INTERNAL  PokeTargetDeviceInfo (lpobj)
LPOBJECT_LE lpobj;
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->htargetDevice)
        return OLE_OK;

   aStdTargetDevice = GlobalAddAtom ("StdTargetDevice");
   return SendPokeData (lpobj, aStdTargetDevice,
                    lpobj->htargetDevice,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeDocDimensions (lpobj)
LPOBJECT_LE lpobj;
{

   // if the server is connectd then poke the host names
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hdocDimensions)
        return OLE_OK;

   aStdDocDimensions = GlobalAddAtom ("StdDocDimensions");
   return SendPokeData (lpobj, aStdDocDimensions,
                    lpobj->hdocDimensions,
                    cfBinary);
}


OLESTATUS INTERNAL  PokeColorScheme (lpobj)
LPOBJECT_LE lpobj;
{
   // if the server is connected then poke the palette info
   if (!QueryOpen (lpobj) || IS_SVRCLOSING(lpobj))
        return OLE_OK;

   if (!lpobj->hlogpal)
        return OLE_OK;

   aStdColorScheme = GlobalAddAtom ("StdColorScheme"); 
   return SendPokeData (lpobj, aStdColorScheme,
                    lpobj->hlogpal,
                    cfBinary);
}


OLESTATUS INTERNAL SendPokeData (lpobj, aItem, hdata, cfFormat)
LPOBJECT_LE     lpobj;
ATOM            aItem;
HANDLE          hdata;
OLECLIPFORMAT   cfFormat;
{
    HANDLE      hdde = NULL;
    DDEPOKE FAR * lpdde = NULL;
    LPSTR       lpdst = NULL;
    LPSTR       lpsrc = NULL;
    OLESTATUS   retval = OLE_ERROR_MEMORY;
    DWORD       dwSize = NULL;
    PEDIT_DDE   pedit;
    BOOL        bGDIdata = FALSE;

    pedit = lpobj->pDocEdit;

    // If it is GDI data then we can stuff the handle into POKE block. 
    // Otherwise we have to copy the data into DDE data block. There
    // is a special case with old MSDraw, that will be handled by
    // the routine CanPutHandleInPokeBlock()
        
    if (!(bGDIdata = CanPutHandleInPokeBlock (lpobj, cfFormat))) {
        if (!(dwSize = GlobalSize (hdata)))
            return OLE_ERROR_MEMORY;
                
        if (!(lpsrc = (LPSTR) GlobalLock (hdata))) 
            return OLE_ERROR_MEMORY;
        
        GlobalUnlock (hdata);
    }
    
    // Now allocate the DDE data block

    if (!(hdde = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, 
                 (dwSize + sizeof(DDEPOKE) - sizeof(BYTE) + sizeof(HANDLE)))))
        goto errRtn;

    if (!(lpdde = (DDEPOKE FAR *)GlobalLock (hdde)))
        goto errRtn;

    GlobalUnlock (hdde);

    // !!! We may want to set it TRUE, for performance reasons. But it 
    // will require some rework on the server side
    lpdde->fRelease = 0;
    lpdde->cfFormat = cfFormat;

    if (bGDIdata) 
        *(LPHANDLE)lpdde->Value = hdata;
    else {
        lpdst = (LPSTR)lpdde->Value;
        UtilMemCpy (lpdst, lpsrc, dwSize);
        
        // For the CF_METAFILEPICT format, we would come here only if we are
        // dealing with the old version of MSDraw. In that case we want to
        // free the handle to METAFILEPICT strcuture, because we've already
        // copied its contents to DDEPOKE structure.
            
        // Note that that the old MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (cfFormat == CF_METAFILEPICT) {
            GlobalFree (hdata);
            hdata = NULL;
        }
    }

    // *** From here onwards if there is an error call FreePokeData(), don't
    // jump to errRtn
        
    aItem = DuplicateAtom (aItem);

    ASSERT(pedit->hData == NULL, "Poke data is not null");

    pedit->hData = hdde;
    if (!PostMessageToServer (pedit, WM_DDE_POKE, MAKELONG (hdde, aItem))) {
        if (aItem)
            GlobalDeleteAtom (aItem);
        FreePokeData (lpobj, pedit);
        return (lpobj->subErr = OLE_ERROR_COMM);
    }

#ifdef  FIREWALLS
    ASSERT (!pedit->bTerminating, "trying to post while termination")
    ASSERT (pedit->awaitAck == NULL, "Trying to Post msg while waiting for ack")
#endif
    if (lpobj->asyncCmd == OLE_NONE)
        lpobj->asyncCmd = OLE_OTHER;

    lpobj->bAsync    = TRUE;
    pedit->awaitAck = AA_POKE;
    // !!! after poke of the hostnames etc. we are not processing error.,

    // Data is freed after the Poke is acknowledged. OLE_RELEASE will be sent
    // to when ACK comes.
        
    return OLE_WAIT_FOR_RELEASE;

errRtn:
    if (hdata)
        FreeGDIdata (hdata, cfFormat);
    
    if (hdde)
        GlobalFree (hdde);

    pedit->hData = NULL;

    return (lpobj->subErr = retval);
}



// FreePokeData: Frees the poked data.
void  INTERNAL FreePokeData (lpobj, pedit)
LPOBJECT_LE lpobj;
PEDIT_DDE   pedit;
{
    DDEPOKE FAR * lpdde;
    
#ifdef  FIREWALLS
    ASSERT (pedit->hData, "Poke data handle is null");

#endif
    
    if (lpdde = (DDEPOKE FAR *) GlobalLock (pedit->hData)) {
        GlobalUnlock (pedit->hData);
        
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && (lpobj->app == aMSDraw)
                && (lpdde->cfFormat == CF_METAFILEPICT)) {
            DeleteMetaFile (((LPMETAFILEPICT) ((LPSTR) &lpdde->Value))->hMF);
        }
        else { 
            FreeGDIdata (*(LPHANDLE)lpdde->Value, lpdde->cfFormat);
        }
    }
        
    GlobalFree (pedit->hData);
    pedit->hData = NULL;
}



BOOL INTERNAL  SendSrvrMainCmd (lpobj, lptemplate)
LPOBJECT_LE lpobj;
LPSTR       lptemplate;
{
    WORD        size;
    WORD        len;
    OLESTATUS   retval;
    int         cmd;
    HANDLE      hInst = NULL;
    LPSTR       lpdata= NULL;
    HANDLE      hdata = NULL;
    BOOL        bLaunch = TRUE;

    Puts("Launch App and Send Sys command");

#ifdef  FIREWALLS
    ASSERT (lpobj->aServer, "Serevr is NULL");
#endif

    if (!lpobj->aServer) {
        retval = OLE_ERROR_REGISTRATION;
        goto errRtn;
    }
    
    if (!lpobj->bOldLink) {
        bLaunch = !(lpobj->fCmd & ACT_NOLAUNCH);
        cmd = lpobj->fCmd & LN_MASK;
    }
    
    if (cmd == LN_LNKACT) {
        // take care of network based document        
        char    cDrive = lpobj->cDrive;
    
        if ((retval = CheckNetDrive (lpobj, POPUP_NETDLG)) != OLE_OK) {
            lpobj->cDrive = cDrive;
            goto errRtn;
        }
        
        if (cDrive != lpobj->cDrive)
            ContextCallBack (lpobj, OLE_RENAMED);
    }
    
    if (!InitSrvrConv (lpobj, hInst)) {

        if (!bLaunch)
            goto errRtn;
        
        if (!(hInst = LeLaunchApp (lpobj))) {
            // We failed to launch the app. If it is a linked object, see
            // whether the docname is valid for new servers.  We wouldn't
            // have given the doc name on the command line for the old
            // servers. So, there is no point in checking for file existance
            // in that case.
            if (lpobj->bOleServer && (lpobj->bOldLink || (cmd == LN_LNKACT))){
                if ((retval = FileExists (lpobj)) != OLE_OK)
                    goto errRtn;
            }
            
            retval = OLE_ERROR_LAUNCH;
            goto errRtn;
        }
        
        if (lpobj->bOldLink)
            return TRUE;

        if (lpobj->bOleServer && (cmd == LN_LNKACT)) {
            // We are not using any data blocks if the object is old link.
            // we launched with docname, and don't have to establish system
            // level and also we don't have to send exec strings.

            // for non-ole servers like excel, we do want to connect at
            // the system level, so that we can send "StdOpen". We also 
            // have to send "StdExit" for the server to exit in the
            // invisible launch case.

            return TRUE;
        }

        retval = OLE_ERROR_COMM;
        if(!InitSrvrConv (lpobj, hInst))
            goto errRtn;
#ifdef OLD
        if (!lpobj->bOleServer && (cmd == LN_LNKACT))
            return TRUE;
#endif
    }

    if (!lpobj->bOldLink) {
        cmd = lpobj->fCmd & LN_MASK;
        len =  lstrlen (srvrSysCmd[cmd >> LN_SHIFT]);

        // for template and new, add the class name also
        if (cmd == LN_NEW || cmd == LN_TEMPLATE)
            len += GlobalGetAtomLen (lpobj->app);

        // Now add the document length.
        len += GlobalGetAtomLen (lpobj->topic);

        // add the length of the template name
        if (lptemplate)
            len += lstrlen (lptemplate);

        // now add the fudge factor for the Quotes etc.
        len += LN_FUDGE;

        // allocate the buffer and set the command.
        hdata = GlobalAlloc (GMEM_DDESHARE, size = len);

        retval = OLE_ERROR_MEMORY;
        SETERRHINT(lpobj, OLE_ERROR_MEMORY);

        if (hdata == NULL || (lpdata = (LPSTR)GlobalLock (hdata)) == NULL)
            goto errRtn;
    }
    
    lstrcpy (lpdata, (LPSTR)"[");           // [
    lstrcat (lpdata, srvrSysCmd[cmd >> LN_SHIFT]);      // [Std....
    lstrcat (lpdata, "(\"");                // [std...("

    if (cmd == LN_NEW  || cmd == LN_TEMPLATE) {
        len = lstrlen (lpdata);
        GlobalGetAtomName (lpobj->app, (LPSTR)lpdata + len, size - len);
                                            // [std...("class
        lstrcat (lpdata, "\",\"");          // [std...("class", "
    }
    len = lstrlen (lpdata);
    // now get the topic name.
    GlobalGetAtomName (lpobj->topic, lpdata + len, (WORD)size - len);
                                            // [std...("class","doc
    if (lptemplate) {
        lstrcat (lpdata, "\",\"");          // [std...("class","doc","
        lstrcat  (lpdata, lptemplate);      // [std...("class","doc","temp
    }

    lstrcat (lpdata, "\")]");               // [std...("class","doc","temp")]

    GlobalUnlock (hdata);

    // !!!optimize with mapping.
    SETERRHINT(lpobj, (OLE_ERROR_TEMPLATE + (cmd >> LN_SHIFT)));

    return SrvrExecute (lpobj, hdata);

errRtn:
    if (lpdata)
        GlobalUnlock (hdata);

    if (hdata)
        GlobalFree (hdata);
    lpobj->subErr = retval;
    return FALSE;
}




// ExtendAtom: Create a new atom, which is the old one plus extension

ATOM INTERNAL ExtendAtom (lpobj, item)
LPOBJECT_LE lpobj;
ATOM    item;
{
    char    buffer[MAX_ATOM+1];
    LPSTR   lpext;

    Puts("ExtendAtom");

    buffer[0] = 0;
    if (item)
        GlobalGetAtomName (item, buffer, MAX_ATOM);

    switch (lpobj->optUpdate) {


        case oleupdate_always:
            lpext = (LPSTR)"";
            break;

        case oleupdate_onsave:
            lpext = (LPSTR)"/Save";
            break;

        case oleupdate_onclose:
            lpext = (LPSTR)"/Close";
            break;

        default:
            ASSERT (FALSE, "on call options not expected here");
            break;

    }
    
    lstrcat (buffer, lpext);
    if (buffer[0])
        return GlobalAddAtom (buffer);
    else
        return NULL;
}


BOOL INTERNAL CreatePictObject (lhclientdoc, lpobjname, lpobj, optRender, cfFormat, lpclass)
LHCLIENTDOC     lhclientdoc;
LPSTR           lpobjname;
LPOBJECT_LE     lpobj;
OLEOPT_RENDER   optRender;
OLECLIPFORMAT   cfFormat;
LPSTR           lpclass;
{
    LPOLEOBJECT lpPictObj = NULL;
    ATOM        aClass;
    
    lpobj->lpobjPict = NULL;
    if (optRender == olerender_format) {
        switch (cfFormat) {
            case NULL:
                return FALSE;
                
            case CF_METAFILEPICT:
                if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE))) 
                    return FALSE;
                break;

            case CF_DIB:
                if (!(lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE)))
                    return FALSE;
                break;
            
            case CF_BITMAP:
                if (!(lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE))) 
                    return FALSE;
                break;
                
            default:
                aClass = GlobalAddAtom (lpclass);
                if (!(lpPictObj = (LPOLEOBJECT) GenCreateBlank (lhclientdoc, 
                                            lpobjname, CT_PICTURE, aClass)))
                    return FALSE;

                ((LPOBJECT_GEN)lpPictObj)->cfFormat = cfFormat;
                break;
        }
    }
    else if (optRender == olerender_draw) {
          if (!(lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE))) 
                return FALSE;
#ifdef LATER
        if (AdviseOn (lpobj, (cfFormat = CF_METAFILEPICT), NULL))
            lpPictObj = (LPOLEOBJECT) MfCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        // !!! for the time being take assume we need to get metafile.
        else if (AdviseOn (lpobj, (cfFormat = CF_DIB), NULL))
            lpPictObj = (LPOLEOBJECT) DibCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        else if (AdviseOn (lpobj, (cfFormat = CF_BITMAP), NULL))
            lpPictObj = (LPOLEOBJECT) BmCreateBlank (lhclientdoc, 
                                                lpobjname, CT_PICTURE);
        else 
            goto errPict;
#endif
        
    }
    else
        return (optRender == olerender_none);

    if (lpobj->lpobjPict = lpPictObj)
        lpobj->lpobjPict->lpParent = (LPOLEOBJECT) lpobj;
    return TRUE;
}


OLESTATUS LnkChangeLnk (lpobj)
LPOBJECT_LE lpobj;
{

    switch (lpobj->subRtn) {

        case 0:
            TermDocConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case 1:

            // delete the edit block
            DeleteDocEdit (lpobj);
            TermSrvrConv (lpobj);
            WAIT_FOR_ASYNC_MSG (lpobj);

        case    2:

            // Do not set any errors, just delete the object.
            // delete the server edit block
            DeleteSrvrEdit (lpobj);

            // now try to activate the new link.
            SKIP_TO (!InitDocConv (lpobj, !POPUP_NETDLG), step3);
            lpobj->fCmd = LN_LNKACT | ACT_ADVISE | ACT_REQUEST;
            InitAsyncCmd (lpobj, OLE_SETDATA, LNKOPENUPDATE);
            return LnkOpenUpdate (lpobj);

        case    3:
            step3:
            return EndAsyncCmd (lpobj);

        default:
            DEBUG_OUT ("Unexpected subroutine", 0);
            return OLE_ERROR_GENERIC;
    }
}


OLESTATUS INTERNAL ChangeDocAndItem (lpobj, hinfo)
LPOBJECT_LE lpobj;
HANDLE      hinfo;
{
    LPSTR       lpinfo;
    ATOM        aNewTopic, aNewItem = NULL, aOldTopic;
    OLESTATUS   retVal = OLE_ERROR_BLANK;

    PROBE_SVRCLOSING(lpobj);
    
    if (!(lpinfo = GlobalLock (hinfo)))
        return OLE_ERROR_MEMORY;
    
    lpinfo += lstrlen (lpinfo) + 1;
    aNewTopic = GlobalAddAtom (lpinfo);
    lpinfo += lstrlen (lpinfo) + 1;
    if (*lpinfo)
        aNewItem = GlobalAddAtom (lpinfo);

    if (!aNewTopic && (lpobj->head.ctype == CT_LINK)) 
        goto errRtn;

    aOldTopic = lpobj->topic;
    lpobj->topic = aNewTopic;
    if ((retVal = SetNetName (lpobj)) != OLE_OK) {
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = aOldTopic;
        goto errRtn;
    }

    if (aOldTopic)
        GlobalDeleteAtom (aOldTopic);
    
    if (lpobj->item)
        GlobalDeleteAtom (lpobj->item); 
    
    lpobj->item = aNewItem;
    
    // As the atoms have already changed, lpobj->hLink becomes irrelevant. 
    if (lpobj->hLink) {             
        GlobalFree (lpobj->hLink);
        lpobj->hLink = NULL;
    }
    
    GlobalUnlock(hinfo);
    
    // Now disconnect the old link and try to connect to the new one.
    lpobj->fCmd = 0;
    InitAsyncCmd (lpobj, OLE_SETDATA, LNKCHANGELNK);
    return LnkChangeLnk (lpobj);

errRtn:

    if (aNewItem)
        GlobalDeleteAtom (aNewItem);
    
    GlobalUnlock (hinfo);        
    return retVal;
}


BOOL    QueryUnlaunch (lpobj)
LPOBJECT_LE lpobj;
{
    if (!(lpobj->fCmd & ACT_UNLAUNCH))
        return FALSE;
    
    // only if we loaded the app
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient && lpobj->pSysEdit->hInst)
        return TRUE;
    
    return FALSE;
}


BOOL     QueryClose (lpobj)
LPOBJECT_LE lpobj;
{
    if (!((lpobj->fCmd & ACT_UNLAUNCH) ||
            (lpobj->head.ctype == CT_EMBEDDED)))
        return FALSE;

    // only if we loaded the documnet
    if (lpobj->pSysEdit && lpobj->pSysEdit->hClient)
        return TRUE;
    
    return FALSE;
}


OLESTATUS INTERNAL SetHostNamesHandle (lpobj, lpclientName, lpdocName)
LPOBJECT_LE lpobj;
LPSTR       lpclientName;
LPSTR       lpdocName;
{
    WORD        cbClient;
    WORD        size;
    HANDLE      hhostNames      = NULL;
    LPHOSTNAMES lphostNames     = NULL;
    LPSTR       lpdata;
  
    // 4 bytes  is for the two offsets
    size = (cbClient = lstrlen(lpclientName)+1) + (lstrlen(lpdocName)+1) + 4;

    if ((hhostNames = GlobalAlloc (GMEM_MOVEABLE, (DWORD) size))
            == NULL)
        goto errRtn;

    if ((lphostNames = (LPHOSTNAMES)GlobalLock (hhostNames)) == NULL)
        goto errRtn;

    lphostNames->clientNameOffset = 0;
    lphostNames->documentNameOffset = cbClient;

    lpdata = (LPSTR)lphostNames->data;
    lstrcpy (lpdata, lpclientName);
    lstrcpy (lpdata + cbClient, lpdocName);
    if (lpobj->hhostNames)
        GlobalFree ( lpobj->hhostNames);
    GlobalUnlock (hhostNames);
    lpobj->hhostNames = hhostNames;
    return OLE_OK;

errRtn:
    if (lphostNames)
        GlobalUnlock (hhostNames);

    if (hhostNames)
        GlobalFree (hhostNames);

    return  OLE_ERROR_MEMORY;
}


#if 0
OLESTATUS  FARINTERNAL LeAbort (lpobj)
LPOBJECT_LE lpobj;
{


    BOOL        bAbort = FALSE;
    PEDIT_DDE   pedit;


    // check whether the any transaction pending for
    // the document level.

    //  channel open
    //  any transaction pending.
    //  and we are not in terminate mode.


    if ((pedit = lpobj->pDocEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        // delete any data we need to delete. Ricght now
        // we kill only the timer. We can not delete any
        // since the server could potentially look at the data.

        DeleteAbortData (lpobj, pedit);
    }

    if ((pedit = lpobj->pSysEdit)  &&   pedit->hServer &&
        pedit->awaitAck && !pedit->bTerminating) {
        pedit->bAbort = bAbort = TRUE;
        DeleteAbortData (lpobj, pedit);

    }

    if (!bAbort)
        return OLE_OK;

    // Now send the EndAsync
    lpobj->mainErr = OLE_ERROR_ABORT;
    EndAsyncCmd (lpobj);
    return OLE_OK;

}
#endif


OLESTATUS  FARINTERNAL ProbeAsync(lpobj)
LPOBJECT_LE lpobj;
{

    if (lpobj->asyncCmd == OLE_NONE)
        return OLE_OK;

    if (!IsServerValid (lpobj)) {

        // Now send the EndAsync
        lpobj->mainErr = OLE_ERROR_TASK;
        EndAsyncCmd (lpobj);
        return OLE_OK;
    }

    return OLE_BUSY;
}


BOOL    INTERNAL IsWindowValid (hwnd)
HWND    hwnd;
{

#define TASK_OFFSET 0x00FA

    LPSTR   lptask;
    HANDLE  htask;

    if (!IsWindow (hwnd))
        return FALSE;

    if (bWLO)
        return TRUE;
    
    // now get the task handle and find out it is valid.
    htask  = GetWindowTask (hwnd);

    if ((wWinVer == 0x0003) || !lpfnIsTask) {
        lptask = (LPSTR)(MAKELONG (TASK_OFFSET, htask));

        if (!FarCheckPointer(lptask, READ_ACCESS))
            return FALSE;

        // now check for the signature bytes of task block in kernel
        if (*lptask++ == 'T' && *lptask == 'D')
            return TRUE;
    }
    else {
        // From win31 onwards the API IsTask can be used for task validation
        if ((*lpfnIsTask)(htask))
            return TRUE;
    }

    return FALSE;
}



BOOL    INTERNAL IsServerValid (lpobj)
LPOBJECT_LE     lpobj;
{

    MSG msg;
    BOOL    retval = FALSE;


    if (lpobj->pDocEdit && lpobj->pDocEdit->hServer) {

        retval = TRUE;

        if (!IsWindowValid (lpobj->pDocEdit->hServer)) {
            if (!PeekMessage ((LPMSG)&msg, lpobj->pDocEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                            PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;
            }

        }

    }

    if (lpobj->pSysEdit && lpobj->pSysEdit->hServer) {
        retval = TRUE;

        if (!IsWindowValid (lpobj->pSysEdit->hServer)) {

            if (!PeekMessage ((LPMSG)&msg, lpobj->pSysEdit->hClient, WM_DDE_TERMINATE, WM_DDE_TERMINATE,
                                PM_NOREMOVE | PM_NOYIELD)){
#ifdef  FIREWALLS
                ASSERT (FALSE, "Server truely died");
#endif
                return FALSE;

            }


        }
    }

   return retval;
}


OLESTATUS FARINTERNAL LeExecute (lpobj, hCmds, wReserve)
LPOBJECT_LE lpobj;
HANDLE      hCmds;
WORD        wReserve;
{
    // Assumes all the creates are in order
    PROBE_CREATE_ASYNC(lpobj);
    PROBE_SVRCLOSING(lpobj);
    
    if (!(lpobj =  (*lpobj->head.lpvtbl->QueryProtocol) (lpobj, 
                                            PROTOCOL_EXECUTE)))
        return OLE_ERROR_PROTOCOL;

    if (!QueryOpen (lpobj))
        return OLE_ERROR_NOT_OPEN;
    
    if (!(hCmds = DuplicateGlobal (hCmds, GMEM_MOVEABLE|GMEM_DDESHARE)))
        return OLE_ERROR_MEMORY;
        
    InitAsyncCmd (lpobj, OLE_OTHER, NULL);
    SETERRHINT(lpobj, OLE_ERROR_COMMAND);
    if (DocExecute(lpobj, hCmds))
        return OLE_WAIT_FOR_RELEASE;
    else
        return OLE_ERROR_COMMAND;
}


void INTERNAL FreeGDIdata (hData, cfFormat)
HANDLE          hData;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_METAFILEPICT) {
        LPMETAFILEPICT  lpMfp;
        
        if (lpMfp = (LPMETAFILEPICT) GlobalLock (hData)) {
            GlobalUnlock (hData);
            DeleteMetaFile (lpMfp->hMF);
        }

        GlobalFree (hData);
    }
    
    else if (cfFormat == CF_BITMAP) 
        DeleteObject (hData);
    
    else if (cfFormat == CF_DIB)
        GlobalFree (hData);
}


// This routine figures out whether the handle to data block can be copied
// to DDEPOKE block rather than the contents of the handle

BOOL INTERNAL CanPutHandleInPokeBlock (lpobj, cfFormat)
LPOBJECT_LE     lpobj;
OLECLIPFORMAT   cfFormat;
{
    if (cfFormat == CF_BITMAP || cfFormat == CF_DIB)
        return TRUE;

    if (cfFormat == CF_METAFILEPICT) {
        // The old version of MSDraw expects the contents of METAFILEPICT
        // structure to be part of DDEPOKE, rather than the handle to it.

        if (!lpobj->bOleServer && lpobj->app == aMSDraw)
            return FALSE;
        
        return TRUE;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\main.c ===
/****************************** Module Header ******************************\
* Module Name: MAIN.C
*
* PURPOSE: WinMain, WEP and some other misc routines
*
* Created: 1991
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Srinik   (04/01/91)  Pulled some routines, into this, from ole.c.
*
\***************************************************************************/

#include <windows.h>
#include <shellapi.h>

#include "dll.h"

#ifndef WF_WLO
#define WF_WLO  0x8000
#endif

// ordinal number new win31 API IsTask
#define ORD_IsTask  320

#define NUM_DLL     30  /* space for this many DLL_ENTRYs is created on */
                        /* each alloc/realloc */

OLECLIPFORMAT   cfOwnerLink     = 0;     // global variables for clip frmats
OLECLIPFORMAT   cfObjectLink    = 0;
OLECLIPFORMAT   cfLink          = 0;
OLECLIPFORMAT   cfNative        = 0;
OLECLIPFORMAT   cfBinary        = 0;
OLECLIPFORMAT   cfFileName      = 0;
OLECLIPFORMAT   cfNetworkName   = 0;

ATOM            aStdHostNames;
ATOM            aStdTargetDevice ;
ATOM            aStdDocDimensions;
ATOM            aStdDocName;
ATOM            aStdColorScheme;
ATOM            aNullArg = 0;
ATOM            aSave;
ATOM            aChange;
ATOM            aClose;
ATOM            aSystem;
ATOM            aOle;
ATOM            aClipDoc;
ATOM            aPackage;

// Used in work around for MSDraw bug
ATOM            aMSDraw;

extern LPCLIENTDOC  lpHeadDoc;
extern LPCLIENTDOC  lpTailDoc;

extern RENDER_ENTRY stdRender[];

HANDLE          hInstDLL;
BOOL            bProtMode;
BOOL            bWLO = FALSE;

/* HANDLE   hDllTable;          !!! Add this when bug in WEP is fixed */
DLL_ENTRY   lpDllTable[NUM_DLL]; //!!! change this when WEP bug is fixed
DWORD       dllTableSize;
int         iLast = 0;
int         iMax = NUM_DLL -1;
int         iUnloadableDll =  NULL; // index to handler than can be freed up

char        packageClass[] = "Package";

// For QuerySize() API & methods.
extern  OLESTREAMVTBL  dllStreamVtbl;
extern  CLIENTDOC      lockDoc;

#ifdef FIREWALLS
BOOL        bShowed = FALSE;
char        szDebugBuffer[80];
short       ole_flags;

void FARINTERNAL    ShowVersion (void);
void FARINTERNAL    SetOleFlags(void);
#endif

// LOWWORD - BYTE 0 major verision, BYTE1 minor version,
// HIWORD reserved

DWORD  dwOleVer = 0x2001L;  // change this when we want to update dll version
                            // number


DWORD  dwVerToFile = 0x0501L; // This is used while object is being saved to
                              // file. There is no need to change this value
                              // whenever we change ole dll version number



static BOOL  bLibInit = FALSE;


WORD    wWinVer;

HANDLE  hModule;

#define MAX_HIMETRIC    0x7FFF

int     maxPixelsX = MAX_HIMETRIC;
int     maxPixelsY = MAX_HIMETRIC;
void    SetMaxPixel (void);

VOID FAR PASCAL WEP (int);

#pragma alloc_text(WEP_TEXT, WEP)


FARPROC lpfnIsTask = NULL;          // the API IsTask() became available from
                                    // win31 onwards, hence we are trying to
                                    // get it's address through GetProcAddress



//////////////////////////////////////////////////////////////////////////////
//
//  int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
//
//  The main library entry point. This routine is called when the library
//  is loaded.
//
//  Arguments:
//
//      hInst       -   dll's instance handle
//      wDataSeg    -   DS register value
//      cbHeapSize  -   heap size defined def file
//      lpszCmdLine -   command line info
//
//  Returns:
//
//      0   -   failure
//      1   -   success
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


int FAR PASCAL LibMain (hInst, wDataSeg, cbHeapSize, lpszCmdLine)
HANDLE  hInst;
WORD    wDataSeg;
WORD    cbHeapSize;
LPSTR   lpszCmdLine;
{
    WNDCLASS  wc;
    int     i;

    Puts("LibMain");

#ifdef  FIREWALLS
    SetOleFlags();
#endif

    bLibInit  = TRUE;
    hInstDLL  = hInst;
    hModule = GetModuleHandle ("OLECLI");

    bProtMode = (BOOL) (GetWinFlags() & WF_PMODE);
    bWLO      = (BOOL) (GetWinFlags() & WF_WLO);
    wWinVer   = (WORD) GetVersion();

    // REGISTER LINK FORMAT

    cfObjectLink    = RegisterClipboardFormat("ObjectLink");
    cfLink          = RegisterClipboardFormat("Link");
    cfOwnerLink     = RegisterClipboardFormat("OwnerLink");
    cfNative        = RegisterClipboardFormat("Native");
    cfBinary        = RegisterClipboardFormat("Binary");
    cfFileName      = RegisterClipboardFormat("FileName");
    cfNetworkName   = RegisterClipboardFormat("NetworkName");

    if (!(cfObjectLink && cfOwnerLink && cfNative && cfLink))
        return 0;

    // SET UP OLEWNDCLASS
    wc.style        = NULL;
    wc.lpfnWndProc  = DocWndProc;
    wc.cbClsExtra   = 0;
    wc.cbWndExtra   = sizeof(LONG);     //we are storing longs
    wc.hInstance    = hInst;
    wc.hIcon        = NULL;
    wc.hCursor      = NULL;
    wc.hbrBackground= NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName= "OleDocWndClass";
    if (!RegisterClass(&wc))
             return 0;

    wc.lpfnWndProc = SrvrWndProc;
    wc.lpszClassName = "OleSrvrWndClass";

    if (!RegisterClass(&wc))
        return 0;
/*
    // !!! Add this when bug in WEP is fixed.
    // Allocate memory for DLL table
    dllTableSize = NUM_DLL * sizeof(DLL_ENTRY);
    if (!(hDllTable = GlobalAlloc (GMEM_MOVEABLE | GMEM_ZEROINIT,
                            dllTableSize)))
        return 0;

    if (!(lpDllTable = (DLL_ENTRY FAR *) GlobalLock (hDllTable)))
        return 0;
*/

    // !!! remove the following when WEP bug is fixed
    for (i = 0; i < NUM_DLL; i++)
        lpDllTable[i].aDll = 0;

    // !!! BEGIN hack for Pbrush.

    lpDllTable[0].hDll                  = NULL;
    lpDllTable[0].aDll                  = GlobalAddAtom ((LPSTR) "ole");
    lpDllTable[0].Load                  = PbLoadFromStream;
    lpDllTable[0].Clip                  = PbCreateFromClip;
    lpDllTable[0].Link                  = PbCreateLinkFromClip;
    lpDllTable[0].Create                = PbCreate;
    lpDllTable[0].CreateFromTemplate    = PbCreateFromTemplate;
    lpDllTable[0].CreateFromFile        = PbCreateFromFile;
    lpDllTable[0].CreateLinkFromFile    = PbCreateLinkFromFile;
    lpDllTable[0].CreateInvisible       = PbCreateInvisible;


    // !!! END hack for pbrush

    // For ObjectSize API
    dllStream.lpstbl = (LPOLESTREAMVTBL) &dllStreamVtbl;
    dllStream.lpstbl->Put = DllPut;

    // add the atoms required.
    aStdDocName       = GlobalAddAtom ((LPSTR)"StdDocumentName");
    aSave             = GlobalAddAtom ((LPSTR)"Save");
    aChange           = GlobalAddAtom ((LPSTR)"Change");
    aClose            = GlobalAddAtom ((LPSTR)"Close");
    aSystem           = GlobalAddAtom ((LPSTR)"System");
    aOle              = GlobalAddAtom ((LPSTR)"OLEsystem");
    aPackage          = GlobalAddAtom ((LPSTR) packageClass);

    // Used in work around for MSDraw bug
    aMSDraw           = GlobalAddAtom ((LPSTR) "MSDraw");

    // clipboard document name atom
    aClipDoc          = GlobalAddAtom ((LPSTR)"Clipboard");

    stdRender[0].aClass = GlobalAddAtom ("METAFILEPICT");
    stdRender[1].aClass = GlobalAddAtom ("DIB");
    stdRender[2].aClass = GlobalAddAtom ("BITMAP");

    SetMaxPixel();

    if (wWinVer != 0x0003) {
        HANDLE  hModule;

        if (hModule = GetModuleHandle ("KERNEL"))
            lpfnIsTask = GetProcAddress (hModule,
                                (LPSTR) MAKELONG (ORD_IsTask, 0));
    }

    if (cbHeapSize != 0)
        UnlockData(0);

    return 1;
}



//////////////////////////////////////////////////////////////////////////////
//
//  VOID FAR PASCAL WEP (nParameter)
//
//  Called just before the library is being unloaded. Delete all the atoms
//  added by this dll and also frees up all unloaded handler dlls.
//
//  Arguments:
//
//      nParameter  -   Termination code
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////


VOID FAR PASCAL WEP (nParameter)
int nParameter;
{
    int i;


    Puts("LibExit");

    // case when the DLLs are missing
    if (!bLibInit)
        return;

    if (nParameter == WEP_SYSTEM_EXIT)
        DEBUG_OUT ("---L&E DLL EXIT on system exit---",0)
    else if (nParameter == WEP_FREE_DLL)
        DEBUG_OUT ("---L&E DLL EXIT---\n",0)
    else
        return;

    // Delete atoms added by us

    for (i = 0; i < NUM_RENDER; i++) {
        if (stdRender[i].aClass)
            GlobalDeleteAtom (stdRender[i].aClass);
    }

    if (aStdDocName)
        GlobalDeleteAtom (aStdDocName);
    if (aSave)
        GlobalDeleteAtom (aSave);
    if (aChange)
        GlobalDeleteAtom (aChange);
    if (aClose)
        GlobalDeleteAtom (aClose);
    if (aSystem)
        GlobalDeleteAtom (aSystem);
    if (aOle)
        GlobalDeleteAtom (aOle);
    if (aPackage)
        GlobalDeleteAtom (aPackage);
    if (aClipDoc)
        GlobalDeleteAtom (aClipDoc);
    if (aMSDraw)
        GlobalDeleteAtom (aMSDraw);

    // Free handler dlls if there are any still loaded. Entry 0 is used for
    // Pbrush handler which is part of this dll.


    for (i = 0; i <= iLast; i++) {
        if (lpDllTable[i].aDll)
            GlobalDeleteAtom (lpDllTable[i].aDll);

        if (lpDllTable[i].hDll)
            FreeLibrary (lpDllTable[i].hDll);
    }


#ifdef FIREWALLS
    ASSERT(!lpHeadDoc, "Some client doc structures are not deleted");
    ASSERT(!lockDoc.lpHeadObj, "Some servers are left in a locked state");
#endif

/* !!! Add this when bug in WEP is fixed

    if (lpDllTable)
        GlobalUnlock (hDllTable);

    if (hDllTable)
        GlobalFree (hDllTable);
*/
}


//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL SetOleFlags()
//
//  Sets the debug level flags for controlling the level of debug information
//  on the comm terminal. This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//////////////////////////////////////////////////////////////////////////////

#ifdef  FIREWALLS

void FARINTERNAL SetOleFlags()
{

    char    buffer[80];

    if(GetProfileString ("OLE",
        "Puts","", (LPSTR)buffer, 80))
        ole_flags = DEBUG_PUTS;
    else
        ole_flags = 0;


    if(GetProfileString ("OLE",
        "DEBUG_OUT","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_DEBUG_OUT;


    if(GetProfileString ("OLE",
        "MESSAGEBOX","", (LPSTR)buffer, 80))
        ole_flags |= DEBUG_MESSAGEBOX;

}



//////////////////////////////////////////////////////////////////////////////
//
//  void FARINTERNAL ShowVersion (void)
//
//  Displays version, date, time and copyright info in client app's window.
//  Called by all the object create functions after checking the flag bShowed.
//  This will be included only in the debug version.
//
//  Arguments:
//
//      none
//
//  Returns:
//
//      none
//
//  Effects:
//
//      sets bShowed
//
//////////////////////////////////////////////////////////////////////////////

void FARINTERNAL ShowVersion ()
{

    if (!bShowed && (ole_flags & DEBUG_MESSAGEBOX)) {
        MessageBox (NULL, "\
                       VER: 1.09.000\n\
                    TIME: 16:00:00\n\
                   DATE: 01/31/1992\n\
         Copyright (c) 1990, 1991 Microsoft Corp.\n\
                  All Rights Reserved.",
      "Ole Client Library",
      MB_OK | MB_TASKMODAL);
        bShowed = TRUE;
    }
}

#endif




int FARINTERNAL LoadDll (lpClass)
LPSTR   lpClass;
{
    char        str[MAX_STR];
    char        str1[MAX_STR];
    ATOM        aDll = NULL;
    int         index;
    int         iEmpty;
    BOOL        found = FALSE;
    HANDLE      hDll;
    int         refcnt;
    LONG        cb = MAX_STR;

    if (!lstrcmpi (lpClass, "Pbrush"))
        return 0;

    lstrcpy (str, lpClass);
    lstrcat (str, "\\protocol\\StdFileEditing\\handler");
    if (RegQueryValue (HKEY_CLASSES_ROOT, str, str1, &cb))
        return INVALID_INDEX;

    if (aDll = GlobalFindAtom (str1)) {
        for (index = 1; index <= iLast; index++) {
            if (lpDllTable[index].aDll == aDll) { // Dll already loaded
                lpDllTable[index].cObj ++;

                if (index == iUnloadableDll)  {
                    // since the object count is not zero anymore, this
                    // handler can not be freed up.
                    iUnloadableDll = NULL;
                }

                return index;
            }
        }
    }

    aDll = GlobalAddAtom (str1);

    // Look for an empty entry
    for (iEmpty = 1; iEmpty <= iLast; iEmpty++) {
        if (!lpDllTable[iEmpty].aDll) {
            found = TRUE;
            break;
        }
    }

    if (iEmpty > iMax)
        goto errLoad;
/*
    if (!found) {// no empty entry exists create a new one if necessary.
        if (iEmpty > iMax) {
            dllTableSize += (blockSize = NUM_DLL * sizeof(DLL_ENTRY));
            hTable = GlobalReAlloc (hDllTable, dllTableSize,
                                GMEM_MOVEABLE | GMEM_ZEROINIT);
            if (hTable == hDllTable)
                iMax += NUM_DLL;
            else {
                dllTableSize -= blockSize;
                iEmpty = INVALID_INDEX;
            }
        }
    }
*/

    // !!! reference count of OLECLI is increasing by 2 when the handlers are
    // are loaded, looks like windows bug. Following is a temporary fix.

    refcnt = GetModuleUsage (hModule);
    hDll = LoadLibrary ((LPSTR) str1);
    refcnt = (GetModuleUsage (hModule) - refcnt);

    while (refcnt > 1) {
        FreeModule (hModule);
        refcnt--;
    }

    if (hDll < 32)
        goto errLoad;

    if (!(lpDllTable[iEmpty].Load = GetProcAddress (hDll,
                                            "DllLoadFromStream")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Clip = GetProcAddress (hDll,
                                            "DllCreateFromClip")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Link = GetProcAddress (hDll,
                                            "DllCreateLinkFromClip")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromTemplate = GetProcAddress (hDll,
                                            "DllCreateFromTemplate")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].Create = GetProcAddress (hDll, "DllCreate")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateFromFile = GetProcAddress (hDll,
                                                    "DllCreateFromFile")))
        goto errLoad;

    if (!(lpDllTable[iEmpty].CreateLinkFromFile = GetProcAddress (hDll,
                                            "DllCreateLinkFromFile")))
        goto errLoad;

    lpDllTable[iEmpty].CreateInvisible = GetProcAddress (hDll,
                                            "DllCreateInvisible");

    lpDllTable[iEmpty].aDll = aDll;
    lpDllTable[iEmpty].cObj = 1;
    lpDllTable[iEmpty].hDll = hDll;
    if (iEmpty > iLast)
        iLast++;
    return iEmpty;

errLoad:
    if (aDll)
        GlobalDeleteAtom (aDll);
    if (hDll >= 32)
        FreeLibrary (hDll);
    return INVALID_INDEX;
}


// unload the the handler that can be free up (whose object count is NULL)

void FARINTERNAL UnloadDll ()
{
    if (!iUnloadableDll)
        return;

    if (iUnloadableDll == iLast)
        iLast--;

    if (lpDllTable[iUnloadableDll].aDll)
        GlobalDeleteAtom (lpDllTable[iUnloadableDll].aDll);
    lpDllTable[iUnloadableDll].aDll = NULL;
    FreeLibrary (lpDllTable[iUnloadableDll].hDll);
    lpDllTable[iUnloadableDll].hDll = NULL;

    iUnloadableDll = NULL;
}


//
// Reduce the object count of the handler, refered to by the index, by one.
// If the object count becomes NULL, free up the handler that is ready to be
// freed (refered to by index iUnloadableDll), and then make this handler the
// freeable one.
//
// As you can see we are trying to implement a simple mechanism of caching.
//

void FARINTERNAL DecreaseHandlerObjCount (iTable)
int iTable;
{
    if (!iTable)
        return;

    if (iTable != INVALID_INDEX) {
        ASSERT (lpDllTable[iTable].cObj, "Handler Obj count is already NULL");
        if (!--lpDllTable[iTable].cObj) {
            UnloadDll ();
            iUnloadableDll = iTable;
        }
    }
}



/***************************** Public  Function ****************************\
*
* OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpoleobject, optRender, cfFormat, lpClass, ctype)
*
*  CreatePictFromClip: This function creates the LP to an object
*  from the clipboard.  It will try to create a static picture object if
*  it understands any rendering formats on the clipboard. Currently, it
*  understands only bitmaps and metafiles.
*
* Effects:
*
* History:
* Wrote it.
\***************************************************************************/

OLESTATUS FARINTERNAL CreatePictFromClip (lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, lpClass, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LPSTR               lpClass;
LONG                objType;
{
    OLESTATUS   retVal = OLE_ERROR_OPTION;

    *lplpobj = NULL;

    if (optRender == olerender_none)
        return OLE_OK;
    else if (optRender == olerender_format) {
        switch (cfFormat) {
            case NULL:
                return OLE_ERROR_FORMAT;

            case CF_METAFILEPICT:
                return MfPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            case CF_DIB:
                return DibPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            case CF_BITMAP:
                return BmPaste (lpclient, lhclientdoc, lpobjname,
                            lplpobj, objType);

            default:
                return GenPaste (lpclient, lhclientdoc, lpobjname, lplpobj,
                            lpClass, cfFormat, objType);
        }
    }
    else if (optRender == olerender_draw) {
        cfFormat = EnumClipboardFormats (NULL);
        while ((cfFormat) && (retVal > OLE_WAIT_FOR_RELEASE)) {
            switch (cfFormat) {
                case CF_METAFILEPICT:
                    retVal = MfPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;

                case CF_DIB:
                    retVal = DibPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;

                case CF_BITMAP:
                    retVal = BmPaste (lpclient, lhclientdoc,
                                lpobjname, lplpobj, objType);
                    break;
            }

            cfFormat = EnumClipboardFormats (cfFormat);
        }
    }

    return retVal;
}



OLESTATUS FARINTERNAL CreatePackageFromClip (lpclient, lhclientdoc, lpobjname, lplpobj, optRender, cfFormat, objType)
LPOLECLIENT         lpclient;
LHCLIENTDOC         lhclientdoc;
LPSTR               lpobjname;
LPOLEOBJECT FAR *   lplpobj;
OLEOPT_RENDER       optRender;
OLECLIPFORMAT       cfFormat;
LONG                objType;
{
    char    file[MAX_STR+6];
    HANDLE  hData;
    LPSTR   lpFileName;

    if (!(hData = GetClipboardData (cfFileName))
            || !(lpFileName = GlobalLock (hData)))
        return OLE_ERROR_CLIPBOARD;


    if (objType == OT_LINK) {
        lstrcpy (file, lpFileName);
        lstrcat (file, "/Link");
        lpFileName = (LPSTR) file;
    }

    GlobalUnlock (hData);

    return  CreateEmbLnkFromFile (lpclient, packageClass, lpFileName,
                        NULL, lhclientdoc, lpobjname, lplpobj,
                        optRender, cfFormat, OT_EMBEDDED);
}



void FARINTERNAL RemoveLinkStringFromTopic (lpobj)
LPOBJECT_LE lpobj;
{
    char    buf[MAX_STR+6];
    int     i = 0;

    if (GlobalGetAtomName (lpobj->topic, buf, sizeof(buf))) {
        // scan the topic for "/Link"
        while (buf[i] != '/') {
            if (!buf[i])
                return;
            i++;
        }

        buf[i] = '\0';
        if (lpobj->topic)
            GlobalDeleteAtom (lpobj->topic);
        lpobj->topic = GlobalAddAtom (buf);
    }
}

void SetMaxPixel ()
{
    HDC hdc;
    // find out the pixel equivalent of MAX_HIMETRIC in X and Y directions

    if (hdc = GetDC (NULL)) {
        maxPixelsX = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSX),
                        2540);
        maxPixelsY = MulDiv (MAX_HIMETRIC, GetDeviceCaps(hdc, LOGPIXELSY),
                        2540);
        ReleaseDC (NULL, hdc);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\mvdm\wow16\ole\client\le.c ===
/****************************** Module Header ******************************\
* Module Name: le.c
*
* Purpose: Handles all API routines for the dde L&E sub-dll of the ole dll.
*
* Created: 1990
*
* Copyright (c) 1990, 1991  Microsoft Corporation
*
* History:
*   Raor, srinik (../../1990,91)    Designed and coded
*
\***************************************************************************/

#include <windows.h>
#include "dll.h"

#define EMB_ID_INDEX    3          // index of ones digit in #000
char    embStr[]        = "#000";

extern  HANDLE          hInfo;
extern  OLECLIPFORMAT   cfNetworkName;

HANDLE  GetNetNameHandle (LPOBJECT_LE);
BOOL    AreTopicsEqual (LPOBJECT_LE, LPOBJECT_LE);

ATOM FARINTERNAL wAtomCat (ATOM, ATOM);

#pragma alloc_text(_RARETEXT, LeObjectLong, LeQueryProtocol, LeEqual, AreTopicsEqual, LeObjectConvert, wAtomCat)

#pragma alloc_text(_DDETEXT, LeRequestData, RequestData, LeChangeData, ContextCallBack, DeleteExtraData, NextAsyncCmd, InitAsyncCmd, FarInitAsyncCmd, EndAsyncCmd, ProcessErr, ScheduleAsyncCmd, LeQueryReleaseStatus, EmbLnkDelete, LeRelease, DeleteObjectAtoms, QueryClose, SendStdClose, TermDocConv, DeleteDocEdit, QueryUnlaunch, SendStdExit, QueryOpen, GetPictType, RequestOn, DocShow, EmbLnkClose, LnkSetUpdateOptions, LnkChangeLnk, TermSrvrConv, DeleteSrvrEdit, LeCopyFromLink)

OLEOBJECTVTBL    vtblLE  = {
        
        LeQueryProtocol,   // check whether the speced protocol is supported
            
        LeRelease,         // release           
        LeShow,            // Show
        LeDoVerb,          // run
        LeGetData,
        LeSetData,
        LeSetTargetDevice, //

        LeSetBounds,       // set viewport bounds
        LeEnumFormat,      // returns format
        LeSetColorScheme,  // set color scheme
        LeRelease,         // delete
        LeSetHostNames,    //
        LeSaveToStream,    // write to file
        LeClone,           // clone object
        LeCopyFromLink,    // Create embedded from Link

        LeEqual,           // test whether the object data is similar

        LeCopy,            // copy to clip

        LeDraw,            // draw the object
            
        LeActivate,        // activate
        LeExecute,         // excute the given commands
        LeClose,           // stop
        LeUpdate,          // Update
        LeReconnect,       // Reconnect
            
        LeObjectConvert,        // convert object to specified type

        LeGetUpdateOptions,     // Get Link Update options
        LeSetUpdateOptions,     // Set Link Update options

        ObjRename,              // Change Object name
        ObjQueryName,           // Get current object name

        LeQueryType,            // object Type
        LeQueryBounds,          // QueryBounds
        ObjQuerySize,           // Find the size of the 