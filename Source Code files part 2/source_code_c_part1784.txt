ill tell the stub NP to reload MSLOCUSR again.
 */
void SignalStubNP(BOOL fLoad)
{
    HWND hwnd = FindWindow("WndClass_NPSTUBMonitor", NULL);
    if (hwnd != NULL) {
        SendMessage(hwnd, fLoad ? WM_USER : (WM_USER+1), 0, 0);
    }
}


extern "C" {

STDAPI DllRegisterServer(void)
{
	HKEY hkeyCLSID;
	HKEY hkeyOurs;
	HKEY hkeyInproc;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
		err = ::RegCreateKey(hkeyCLSID, ::szOurCLSID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegCreateKey(hkeyOurs, ::szINPROCSERVER32, &hkeyInproc);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyInproc, NULL, 0, REG_EXPAND_SZ,
									  (LPBYTE)::szDLLNAME, ::strlenf(::szDLLNAME));
				if (err == ERROR_SUCCESS) {
					err = ::RegSetValueEx(hkeyInproc, ::szTHREADINGMODEL, 0,
										  REG_SZ, (LPBYTE)::szAPARTMENT,
										  ::strlenf(::szAPARTMENT));
				}
				::RegCloseKey(hkeyInproc);
			}

			::RegCloseKey(hkeyOurs);
		}

		::RegCloseKey(hkeyCLSID);
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}


STDAPI DllUnregisterServer(void)
{
	HKEY hkeyCLSID;
	HKEY hkeyOurs;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
		err = ::RegOpenKey(hkeyCLSID, ::szOurCLSID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegDeleteKey(hkeyOurs, ::szINPROCSERVER32);

			::RegCloseKey(hkeyOurs);

			if (err == ERROR_SUCCESS)
				err = ::RegDeleteKey(hkeyCLSID, ::szOurCLSID);
		}

		::RegCloseKey(hkeyCLSID);
	}

    DeinstallLogonDialog();

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}


STDAPI DllInstall(BOOL fInstall, LPCSTR psz)
{
    SignalStubNP(fInstall);
    return S_OK;
}


STDAPI DllCanUnloadNow(void)
{
	SCODE sc;

	sc = (0 == g_cRefThisDll && 0 == g_cLocks) ? S_OK : S_FALSE;
	return ResultFromScode(sc);
}


STDAPI DllGetClassObject(
	REFCLSID rclsid,
	REFIID riid,
	LPVOID FAR *ppv)
{
	if (!IsEqualCLSID(rclsid, CLSID_LocalUsers)) {
		return ResultFromScode(E_FAIL);
	}

	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IClassFactory)) {
		return ResultFromScode(E_NOINTERFACE);
	}

	static CLUClassFactory cf;

	*ppv = (LPVOID)&cf;

	cf.AddRef();

	return NOERROR;
}

};	/* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluglob.h ===
#if !defined (EXTERN)
#define EXTERN extern
#endif

#if !defined (ASSIGN)
#define ASSIGN(value)
#endif

/* the 'extern' must be forced for constant arrays, because 'const'
 * in C++ implies 'static' otherwise.
 */
#define EXTTEXT(n) extern const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) ASSIGN(text)

TEXTCONST(szProfileList,REGSTR_PATH_SETUP "\\ProfileList");
TEXTCONST(szSupervisor,"Supervisor");
TEXTCONST(szProfileImagePath,"ProfileImagePath");
TEXTCONST(szDefaultUserName,".Default");
TEXTCONST(szRATINGS,        "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings");
TEXTCONST(szRatingsSupervisorKeyName,"Key");
TEXTCONST(szUsersSupervisorKeyName,"Key2");
TEXTCONST(szLogonKey,"Network\\Logon");
TEXTCONST(szUserProfiles,"UserProfiles");
TEXTCONST(szUsername,"Username");
TEXTCONST(szSupervisorPWLKey,"MSLOCUSR!SuperPW");

TEXTCONST(szProfilePrefix,"PRO");	/* for generating temp. profile file names */
TEXTCONST(szProfiles,"Profiles");
#define szProfilesDirectory	szProfiles	/* name appended to windows dir */
#define szProfileListRootKey szProfileList
TEXTCONST(szStdNormalProfile,"USER.DAT");

TEXTCONST(szReconcileRoot,"Software\\Microsoft\\Windows\\CurrentVersion");
TEXTCONST(szReconcilePrimary,"ProfileReconciliation");
TEXTCONST(szReconcileSecondary,"SecondaryProfileReconciliation");
TEXTCONST(szLocalFile,"LocalFile");
TEXTCONST(szDefaultDir,"DefaultDir");
TEXTCONST(szReconcileName,"Name");
TEXTCONST(szWindirAlias,"*windir");
TEXTCONST(szReconcileRegKey,"RegKey");
TEXTCONST(szReconcileRegValue,"RegValue");
TEXTCONST(szUseProfiles,"UserProfiles");
TEXTCONST(szDisplayProfileErrors,"DisplayProfileErrors");

TEXTCONST(szNULL, "");

TEXTCONST(szOurCLSID, "{95D0F020-451D-11CF-8DAB-00AA006C1A01}");
TEXTCONST(szCLSID,			"CLSID");
TEXTCONST(szINPROCSERVER32,	"InProcServer32");
TEXTCONST(szDLLNAME,		"%SystemRoot%\\system32\\mslocusr.dll");
TEXTCONST(szTHREADINGMODEL,	"ThreadingModel");
TEXTCONST(szAPARTMENT,		"Apartment");

TEXTCONST(szHelpFile,       "users.hlp");
TEXTCONST(szRatingsHelpFile,"ratings.hlp");

EXTERN CHAR abSupervisorKey[16] ASSIGN({0});		/* supervisor password hash */
EXTERN CHAR fSupervisorKeyInit ASSIGN(FALSE);		/* whether abSupervisorKey has been initialized */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluinst.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include "resource.h"

/* InstallLogonDialog - check if there is a primary logon provider already on
 * the system, and if not, install MSLOCUSR as a net provider and make it the
 * primary logon.  Returns TRUE if the NP was installed.
 *
 * This chunk of hideous registry code exists because NETDI.DLL (the win95
 * network setup engine) (a) has no programmatic interface, it just assumes
 * it's being driven by NETCPL.CPL;  (b) is 16-bit code, so even if it had
 * a programmatic interface, we'd have to thunk;  and (c) if everything's
 * not consistent in his database of what network components are installed
 * and which are bound to which, then the next time the user brings up the
 * network CPL, any components which don't make sense just get silently
 * deinstalled.
 *
 * The set of registry keys and values which need to be added, changed, or
 * updated was gleaned from a registry diff done after using the real network
 * CPL to install this logon provider from an INF.  A similar registry diff
 * and similar code could be created to programmatically install a transport.
 * Don't ask me to do it for you, though...
 *
 * Note that in case of registry errors, we just bail out.  It would require
 * a huge amount of extra code to keep track of everything that had been done
 * up to that point and undo it.  The worst that happens if we do strange
 * things to the net component database is that NETDI will deinstall our
 * component the next time the user brings up the network control panel.  It
 * shouldn't actually cause any crashes or anything like that.
 */

BOOL InstallLogonDialog(void)
{
    HKEY hkey;          /* used for various work */
    LONG err;
    TCHAR szBuf[MAX_PATH];
    DWORD dwType;
    DWORD cbData;
    DWORD dwTemp;
    DWORD dwDisp;

    NLS_STR nlsNPName(MAX_RES_STR_LEN);
    if (nlsNPName.LoadString(IDS_NP_NAME) != ERROR_SUCCESS)
        return FALSE;

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon", 0,
                       KEY_QUERY_VALUE | KEY_SET_VALUE, &hkey);
    if (err != ERROR_SUCCESS)
        return FALSE;           /* big problems if we can't get this guy */

    /* Get the PrimaryProvider value, which is the name of the net provider
     * that's handling the main logon dialog.  If it's there and not blank,
     * then presumably the user's on a LAN or something, so we don't want
     * to replace the logon dialog.
     */
    cbData = sizeof(szBuf);
    err = RegQueryValueEx(hkey, "PrimaryProvider", NULL, &dwType,
                          (LPBYTE)szBuf, &cbData);
    if (err == ERROR_SUCCESS && szBuf[0] != '\0') {
        RegCloseKey(hkey);
        return FALSE;
    }

    /* Make us the primary logon provider, as far as MPR and the logon code
     * are concerned.
     */
    err = RegSetValueEx(hkey, "PrimaryProvider", 0, REG_SZ,
                        (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
    RegCloseKey(hkey);
    if (err != ERROR_SUCCESS)
        return FALSE;

    /* Under HKLM\SW\MS\W\CV\Network\Real Mode Net, preferredredir=null string,
     * since we will now be the primary network in all respects.  NETDI needs
     * this to avoid getting confused.
     */
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Network\\Real Mode Net",
                       0, KEY_QUERY_VALUE, &hkey);
    if (err == ERROR_SUCCESS) {
        err = RegSetValueEx(hkey, "preferredredir", 0, REG_SZ, (LPBYTE)TEXT(""), sizeof(TCHAR));
        RegCloseKey(hkey);
    }

    /* Add new keys under HKLM\System\CurrentControlSet which will actually
     * make MPR load our DLL as a net provider.
     */
    HKEY hkeyFamilyClient;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "Name", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "ProviderPath", 0, REG_SZ,
                      (LPBYTE)TEXT("ienpstub.dll"), 11 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "RealDLL", 0, REG_SZ,
                      (LPBYTE)TEXT("mslocusr.dll"), 13 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "Description", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);

        dwTemp = WNNC_NET_MSNET;
        RegSetValueEx(hkeyFamilyClient, "NetID", 0, REG_DWORD,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));
        dwTemp = 0x40000000;
        RegSetValueEx(hkeyFamilyClient, "CallOrder", 0, REG_DWORD,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));

        RegCloseKey(hkeyFamilyClient);
    }

    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\NetworkProvider\\Order", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        cbData = sizeof(szBuf);
        if (RegQueryValueEx(hkeyFamilyClient, "NPSTUB", NULL, &dwType, 
                            (LPBYTE)szBuf, &cbData) == ERROR_SUCCESS) {
            /* Our provider is already installed!  Better not do anything
             * more than just making it default, which we've already done.
             */
            RegCloseKey(hkeyFamilyClient);
            return FALSE;
        }
        RegSetValueEx(hkeyFamilyClient, "NPSTUB", 0, REG_SZ,
                      (LPBYTE)TEXT(""), sizeof(TCHAR));
        RegCloseKey(hkeyFamilyClient);
    }

    /* We've now installed our NP in the registry, and to see it appear we
     * need a reboot.  So from here on, if we bail out, we return TRUE.
     */

    /* First big chunk of network component database management.  Under
     * HKLM\System\CurrentControlSet\Services\Class\NetClient there is a
     * four-digit numeric subkey (e.g., "0000") for each network client.
     * One of them will be the default network client as far as NETDI's
     * database is concerned;  this is indicated by the existence of the
     * "Ndi\Default" subkey under the number key.  If we find one of those
     * guys, we save away the DeviceID value from the Ndi subkey so we can
     * tweak some configuration flags later in another part of the database.
     *
     * While enumerating the keys, we keep track of the highest number we've
     * seen so far.  When we're done, we add 1 to that and use that as the
     * subkey name for our client.  The number is kept separate from the
     * RegEnumKey index because the numbers are not necessarily packed (nor
     * will RegEnumKey necessarily return them in numeric order!).
     */

    HKEY hkeyNetClient;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\Class\\NetClient",
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                         NULL, &hkeyNetClient, &dwDisp);
    if (err != ERROR_SUCCESS)
        return TRUE;

    UINT nFamilyNum;
    TCHAR szFamilyNumString[5]; /* four digits plus null */
    TCHAR szDefaultDeviceID[MAX_PATH] = "";

    if (dwDisp == REG_OPENED_EXISTING_KEY) {
        NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
        DWORD iSubKey = 0;
        UINT maxSubKey = 0;

        for (;;) {
            err = RegEnumKey(hkeyNetClient, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
            nlsSubKey.DonePartying();
            if (err != ERROR_SUCCESS)
                break;

            NLS_STR nls2(nlsSubKey.strlen() + 12);
            if (nls2.QueryError() == ERROR_SUCCESS) {
                nls2 = nlsSubKey;
                nls2.strcat("\\Ndi\\Default");
                cbData = sizeof(szBuf);
                err = RegQueryValue(hkeyNetClient, nls2.QueryPch(), szBuf, (PLONG)&cbData);
                if (err == ERROR_SUCCESS) {
                    if (!lstrcmpi(szBuf, "True")) {
                        HKEY hkeyNdi;

                        NLS_STR nls3(nlsSubKey.strlen() + 5);
                        if (nls3.QueryError() == ERROR_SUCCESS) {
                            nls3 = nlsSubKey;
                            nls3.strcat("\\Ndi");

                            err = RegOpenKeyEx(hkeyNetClient, nls3.QueryPch(), 0, KEY_QUERY_VALUE, &hkeyNdi);
                            if (err == ERROR_SUCCESS) {
                                cbData = sizeof(szDefaultDeviceID);
                                RegQueryValueEx(hkeyNdi, "DeviceID", NULL, &dwType,
                                                (LPBYTE)szDefaultDeviceID, &cbData);
                                RegCloseKey(hkeyNdi);
                            }
                        }
                    }
                    RegDeleteKey(hkeyNetClient, nls2.QueryPch());
                }
            }

            UINT nSubKey = nlsSubKey.atoi();
            if (nSubKey > maxSubKey)
                maxSubKey = nSubKey;

            iSubKey++;
        }
        nFamilyNum = maxSubKey+1;
    }
    else
        nFamilyNum = 0;

    wsprintf(szFamilyNumString, "%04d", nFamilyNum);
    err = RegCreateKeyEx(hkeyNetClient, szFamilyNumString, 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "DriverDesc", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "InfPath", 0, REG_SZ,
                      (LPBYTE)TEXT("NETFAM.INF"), 11 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "DriverDate", 0, REG_SZ,
                      (LPBYTE)TEXT(" 5-21-1997"), 11 * sizeof(TCHAR));
        err = RegCreateKeyEx(hkeyFamilyClient, "Ndi", 
                             0, "", REG_OPTION_NON_VOLATILE,
                             KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                             NULL, &hkey, &dwDisp);
        if (err == ERROR_SUCCESS) {
            RegSetValueEx(hkey, "DeviceID", 0, REG_SZ,
                          (LPBYTE)TEXT("FAMILY"), 7 * sizeof(TCHAR));
            RegSetValueEx(hkey, "NetworkProvider", 0, REG_SZ,
                          (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
            RegSetValueEx(hkey, "InstallInf", 0, REG_SZ,
                          (LPBYTE)TEXT(""), sizeof(TCHAR));
            RegSetValueEx(hkey, "InfSection", 0, REG_SZ,
                          (LPBYTE)TEXT("FAMILY.ndi"), 11 * sizeof(TCHAR));

            {
                NLS_STR nlsHelpText(MAX_RES_STR_LEN);
                if (nlsHelpText.LoadString(IDS_NETFAM_HELP_TEXT) == ERROR_SUCCESS) {
                    RegSetValueEx(hkey, "HelpText", 0, REG_SZ,
                                  (LPBYTE)nlsHelpText.QueryPch(), nlsHelpText.strlen() + 1);
                }
            }

            HKEY hkeyInterfaces;
            err = RegCreateKeyEx(hkey, "Interfaces", 
                                 0, "", REG_OPTION_NON_VOLATILE,
                                 KEY_CREATE_SUB_KEY | KEY_SET_VALUE,
                                 NULL, &hkeyInterfaces, &dwDisp);
            if (err == ERROR_SUCCESS) {
                RegSetValueEx(hkeyInterfaces, "DefLower", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "LowerRange", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "Lower", 0, REG_SZ,
                              (LPBYTE)TEXT("netbios,ipxDHost"), 13 * sizeof(TCHAR));
                RegSetValueEx(hkeyInterfaces, "Upper", 0, REG_SZ,
                              (LPBYTE)TEXT(""), sizeof(TCHAR));
                RegCloseKey(hkeyInterfaces);
            }
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Install", REG_SZ, "FAMILY.Install", 14);
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Remove", REG_SZ, "FAMILY.Remove", 13);
            if (err == ERROR_SUCCESS)
                err = RegSetValue(hkey, "Default", REG_SZ, "True", 5);

            RegCloseKey(hkey);
        }
        RegCloseKey(hkeyFamilyClient);
    }
    RegCloseKey(hkeyNetClient);

    if (err != ERROR_SUCCESS)
        return TRUE;

    /* Now the other half of the database, under HKLM\Enum\Network.  This has
     * a subkey (named by DeviceID, as seen above) for each network component.
     * Under each such subkey, there's a numbered subkey for each instance.
     * We have three tasks here:  First of all, for each instance of the client
     * that used to be the default, we have to mask out bit 0x00000010 from
     * the ConfigFlags value, to make it no longer the default client.  Then
     * we have to create a new branch for our own client, which mainly points
     * back to the other section of the database which we just finished with.
     * Finally, we must find MSTCP and add a binding between it and our client,
     * because NETDI assumes that a client that's not bound to any transports
     * must be messed up, so it deletes it.
     */

    HKEY hkeyEnum;
    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                         NULL, &hkeyEnum, &dwDisp);
    if (err != ERROR_SUCCESS)
        return TRUE;

    /* Un-default the default client. */
    if (szDefaultDeviceID[0] != '\0') {
        HKEY hkeyDefaultDevice;
        err = RegOpenKeyEx(hkeyEnum, szDefaultDeviceID, 0,
                           KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                           &hkeyDefaultDevice);
        if (err == ERROR_SUCCESS) {
            NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
            DWORD iSubKey = 0;

            for (;;) {
                err = RegEnumKey(hkeyDefaultDevice, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
                nlsSubKey.DonePartying();
                if (err != ERROR_SUCCESS)
                    break;

                HKEY hkeyInstance;
                err = RegOpenKeyEx(hkeyDefaultDevice, nlsSubKey.QueryPch(),
                                   0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
                if (err == ERROR_SUCCESS) {
                    DWORD dwConfigFlags;
                    cbData = sizeof(dwConfigFlags);
                    err = RegQueryValueEx(hkeyInstance, "ConfigFlags", NULL,
                                          &dwType, (LPBYTE)&dwConfigFlags,
                                          &cbData);
                    if (err == ERROR_SUCCESS &&
                        (dwType == REG_DWORD || dwType == REG_BINARY) &&
                        (dwConfigFlags & 0x10)) {
                        dwConfigFlags &= ~0x10;
                        RegSetValueEx(hkeyInstance, "ConfigFlags", 0, dwType,
                                      (LPBYTE)&dwConfigFlags, cbData);
                    }
                    RegCloseKey(hkeyInstance);
                }

                iSubKey++;
            }
            RegCloseKey(hkeyDefaultDevice);
        }
    }

    /* Now create a new branch for our client. */

    err = RegCreateKeyEx(hkeyEnum, "FAMILY\\0000", 
                         0, "", REG_OPTION_NON_VOLATILE,
                         KEY_SET_VALUE,
                         NULL, &hkeyFamilyClient, &dwDisp);
    if (err == ERROR_SUCCESS) {
        RegSetValueEx(hkeyFamilyClient, "Class", 0, REG_SZ,
                      (LPBYTE)TEXT("NetClient"), 10 * sizeof(TCHAR));
        lstrcpy(szBuf, "NetClient\\");
        lstrcat(szBuf, szFamilyNumString);
        RegSetValueEx(hkeyFamilyClient, "Driver", 0, REG_SZ, (LPBYTE)szBuf, lstrlen(szBuf)+1);
        RegSetValueEx(hkeyFamilyClient, "MasterCopy", 0, REG_SZ,
                      (LPBYTE)TEXT("Enum\\Network\\FAMILY\\0000"), 25 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "DeviceDesc", 0, REG_SZ,
                      (LPBYTE)nlsNPName.QueryPch(), nlsNPName.strlen()+1);
        RegSetValueEx(hkeyFamilyClient, "CompatibleIDs", 0, REG_SZ,
                      (LPBYTE)TEXT("FAMILY"), 7 * sizeof(TCHAR));
        RegSetValueEx(hkeyFamilyClient, "Mfg", 0, REG_SZ,
                      (LPBYTE)TEXT("Microsoft"), 10 * sizeof(TCHAR));
        dwTemp = 0x00000010;
        RegSetValueEx(hkeyFamilyClient, "ConfigFlags", 0, REG_BINARY,
                      (LPBYTE)&dwTemp, sizeof(dwTemp));

        /* A "Bindings" subkey needs to exist here, with no values in it
         * (since our "client" isn't bound to any higher level components
         * like servers).
         */
        err = RegCreateKeyEx(hkeyFamilyClient, "Bindings", 
                             0, "", REG_OPTION_NON_VOLATILE,
                             KEY_SET_VALUE,
                             NULL, &hkey, &dwDisp);
        if (err == ERROR_SUCCESS)
            RegCloseKey(hkey);

        RegCloseKey(hkeyFamilyClient);
    }

    /* Get MSTCP's enum key, get the first instance, and from it we can find
     * the "master" instance.  We can then add a binding to ourselves there.
     * Can't just assume "0000" as the first one, unfortunately.
     */
    err = RegOpenKeyEx(hkeyEnum, "MSTCP", 0,
                       KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
                       &hkey);
    if (err == ERROR_SUCCESS) {
        NLS_STR nlsSubKey(20);       /* enough for four digits, plus some just in case */
        DWORD iSubKey = 0;

        for (;;) {
            err = RegEnumKey(hkey, iSubKey, nlsSubKey.Party(), nlsSubKey.QueryAllocSize());
            nlsSubKey.DonePartying();
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyInstance;
            err = RegOpenKeyEx(hkey, nlsSubKey.QueryPch(),
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
            if (err == ERROR_SUCCESS) {
                cbData = sizeof(szBuf);
                err = RegQueryValueEx(hkeyInstance, "MasterCopy", NULL,
                                      &dwType, (LPBYTE)szBuf,
                                      &cbData);
                RegCloseKey(hkeyInstance);

                /* The MasterCopy value is actually a path to a registry key
                 * from HKEY_LOCAL_MACHINE.  We want to deal with its Bindings
                 * subkey.
                 */
                if (err == ERROR_SUCCESS) {
                    HKEY hkeyBindings;
                    lstrcat(szBuf, "\\Bindings");
                    err = RegCreateKeyEx(HKEY_LOCAL_MACHINE, szBuf,
                                         0, "", REG_OPTION_NON_VOLATILE,
                                         KEY_SET_VALUE,
                                         NULL, &hkeyBindings, &dwDisp);
                    if (err == ERROR_SUCCESS) {
                        RegSetValueEx(hkeyBindings, "FAMILY\\0000", 0, REG_SZ,
                                      (LPBYTE)TEXT(""), sizeof(TCHAR));
                        RegCloseKey(hkeyBindings);
                    }
                    break;      /* abandon enum loop */
                }

                iSubKey++;
            }
        }
        RegCloseKey(hkey);
    }

    RegCloseKey(hkeyEnum);

    return TRUE;
}


/*
Purpose: Recursively delete the key, including all child values
         and keys.  Mimics what RegDeleteKey does in Win95.

         Snarfed from shlwapi so we don't end up loading him at
         boot time.

Returns: 
Cond:    --
*/
DWORD
DeleteKeyRecursively(
    IN HKEY   hkey, 
    IN LPCSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                DeleteKeyRecursively(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}


void DeinstallLogonDialog(void)
{
    RegDeleteKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider");
    RegDeleteKey(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB");

    HKEY hkey;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Control\\NetworkProvider\\Order",
                     0, KEY_WRITE, &hkey) == ERROR_SUCCESS) {
        RegDeleteValue(hkey, "NPSTUB");
        RegCloseKey(hkey);
    }

    char szBuf[MAX_PATH];

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
                     0, KEY_WRITE, &hkey) == ERROR_SUCCESS) {
        DWORD cbData = sizeof(szBuf);
        DWORD dwType;
        LONG err = RegQueryValueEx(hkey, "PrimaryProvider", NULL, &dwType,
                                   (LPBYTE)szBuf, &cbData);
        if (err == ERROR_SUCCESS && szBuf[0] != '\0') {
            NLS_STR nlsNPName(MAX_RES_STR_LEN);
            if (nlsNPName.LoadString(IDS_NP_NAME) == ERROR_SUCCESS) {
                if (!::strcmpf(nlsNPName.QueryPch(), szBuf)) {
                    RegDeleteValue(hkey, "PrimaryProvider");
                }
            }
        }

        RegCloseKey(hkey);
    }

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network\\FAMILY", 0,
                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        UINT i=0;

        /* For each instance of us under the Enum branch, fetch the
         * corresponding key name under the other half of the database
         * and delete it.
         */
        for (;;) {
            DWORD err = RegEnumKey(hkey, i, szBuf, sizeof(szBuf));
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyInstance;
            err = RegOpenKeyEx(hkey, szBuf,
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
            if (err == ERROR_SUCCESS) {
                strcpyf(szBuf, "System\\CurrentControlSet\\Services\\Class\\");

                DWORD dwType;
                DWORD cbData = sizeof(szBuf) - 40;  /* - length of above string */
                if (RegQueryValueEx(hkeyInstance, "Driver", NULL, &dwType,
                                    (LPBYTE)szBuf + 40, &cbData) == ERROR_SUCCESS) {
                    /* szBuf now equals the other branch we need to kill */
                    DeleteKeyRecursively(HKEY_LOCAL_MACHINE, szBuf);
                }
                RegCloseKey(hkeyInstance);
            }
            i++;
        }

        RegCloseKey(hkey);

        DeleteKeyRecursively(HKEY_LOCAL_MACHINE, "Enum\\Network\\FAMILY");
    }

    /* Now clean up bindings to our client, otherwise PNP will try to install
     * us as a new (unknown) device.  This involves enumerating components
     * under HKLM\Enum\Network;  for each one, enumerate the instances;  for
     * each instance's Bindings key, enumerate the values, and delete all
     * values that begin with FAMILY\.
     */

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Enum\\Network", 0,
                     KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_WRITE,
                     &hkey) == ERROR_SUCCESS) {
        UINT iComponent = 0;

        for (;;) {
            DWORD err = RegEnumKey(hkey, iComponent, szBuf, sizeof(szBuf));
            if (err != ERROR_SUCCESS)
                break;

            HKEY hkeyComponent;
            err = RegOpenKeyEx(hkey, szBuf,
                               0, KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS, &hkeyComponent);
            if (err == ERROR_SUCCESS) {

                /* Opened a component's key.  Enumerate its instances, opening
                 * each one's Bindings subkey.
                 */
                TCHAR szInstance[16];       /* actually only needs to be "nnnn\Bindings" plus null char */

                UINT iInstance = 0;

                for (;;) {
                    err = RegEnumKey(hkeyComponent, iInstance, szInstance, sizeof(szInstance));
                    if (err != ERROR_SUCCESS)
                        break;

                    if (strlenf(szInstance)*sizeof(TCHAR) <= sizeof(szInstance) - sizeof("\\Bindings"))
                        strcatf(szInstance, "\\Bindings");
                    HKEY hkeyInstance;
                    err = RegOpenKeyEx(hkeyComponent, szInstance,
                               0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyInstance);
                    if (err == ERROR_SUCCESS) {

                        /* Opened a Bindings subkey.  For each value under this
                         * key, the value name indicates the instance being
                         * bound to, and the value data is empty.  So we can
                         * enum values, ignoring the value data and type and
                         * just concentrating on the name.
                         */

                        TCHAR szValueName[64];      /* usually "COMPONENT\nnnn" */
                        UINT iValue = 0;
                        for (;;) {
                            DWORD cchValue = ARRAYSIZE(szValueName);
                            err = RegEnumValue(hkeyInstance, iValue, szValueName, 
                                               &cchValue, NULL, NULL, NULL, NULL);
                            if (err != ERROR_SUCCESS)
                                break;

                            /* If this is a binding to our client, delete the
                             * binding and reset (deleting values while enuming
                             * can be unpredictable).
                             */
                            if (!strnicmpf(szValueName, "FAMILY\\", 7)) {
                                RegDeleteValue(hkeyInstance, szValueName);
                                iValue = 0;
                                continue;
                            }

                            iValue++;
                        }

                        RegCloseKey(hkeyInstance);
                    }

                    iInstance++;
                }


                RegCloseKey(hkeyComponent);
            }
            iComponent++;
        }

        RegCloseKey(hkey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluwiz.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include <regentry.h>
#include "profiles.h"
#include <npmsg.h>

extern "C" void SHFlushSFCache(void);

void ReportUserError(HWND hwndParent, HRESULT hres)
{
    if (SUCCEEDED(hres))
        return;

    UINT idMsg;
    NLS_STR nlsSub(16);     /* long enough for any 32-bit number, any format */

    if ((((DWORD)hres) >> 16) == (FACILITY_WIN32 | 0x8000)) {
        UINT err = (hres & 0xffff);

        switch (err) {
        case ERROR_ACCESS_DENIED:       idMsg = IDS_E_ACCESSDENIED; break;
        case ERROR_NOT_AUTHENTICATED:   idMsg = IDS_ERROR_NOT_AUTHENTICATED; break;
        case ERROR_NO_SUCH_USER:        idMsg = IDS_ERROR_NO_SUCH_USER; break;
        case ERROR_USER_EXISTS:         idMsg = IDS_ERROR_USER_EXISTS; break;
        case ERROR_NOT_ENOUGH_MEMORY:   idMsg = IDS_ERROR_OUT_OF_MEMORY; break;
        case ERROR_BUSY:                idMsg = IDS_ERROR_BUSY; break;
        case ERROR_PATH_NOT_FOUND:      idMsg = IDS_ERROR_PATH_NOT_FOUND; break;
        case ERROR_BUFFER_OVERFLOW:     idMsg = IDS_ERROR_BUFFER_OVERFLOW; break;
        case IERR_CachingDisabled:      idMsg = IDS_IERR_CachingDisabled; break;
        case IERR_BadSig:               idMsg = IDS_IERR_BadSig; break;
        case IERR_CacheReadOnly :       idMsg = IDS_IERR_CacheReadOnly; break;
        case IERR_IncorrectUsername:    idMsg = IDS_IERR_IncorrectUsername; break;
        case IERR_CacheCorrupt:         idMsg = IDS_IERR_CacheCorrupt; break;
        case IERR_UsernameNotFound:     idMsg = IDS_IERR_UsernameNotFound; break;
        case IERR_CacheFull:            idMsg = IDS_IERR_CacheFull; break;
        case IERR_CacheAlreadyOpen:     idMsg = IDS_IERR_CacheAlreadyOpen; break;

        default:
            idMsg = IDS_UNKNOWN_ERROR;
            wsprintf(nlsSub.Party(), "%d", err);
            nlsSub.DonePartying();
            break;
        }
    }
    else {
        switch(hres) {
        case E_OUTOFMEMORY:             idMsg = IDS_ERROR_OUT_OF_MEMORY; break;
//        case E_ACCESSDENIED:            idMsg = IDS_E_ACCESSDENIED; break;

        default:
            idMsg = IDS_UNKNOWN_ERROR;
            wsprintf(nlsSub.Party(), "0x%x", hres);
            nlsSub.DonePartying();
            break;
        }
    }

    const NLS_STR *apnls[] = { &nlsSub, NULL };

    MsgBox(hwndParent, idMsg, MB_OK | MB_ICONSTOP, apnls);
}


const UINT MAX_WIZ_PAGES = 8;

#if 0   /* now in mslocusr.h */
class CWizData : public IUserProfileInit
{
public:
    HRESULT m_hresRatings;          /* result of VerifySupervisorPassword("") */
    BOOL m_fGoMultiWizard;          /* TRUE if this is the big go-multiuser wizard */
    NLS_STR m_nlsSupervisorPassword;
    NLS_STR m_nlsUsername;
    NLS_STR m_nlsUserPassword;
    IUserDatabase *m_pDB;
    IUser *m_pUserToClone;
    int m_idPrevPage;               /* ID of page before Finish */
    UINT m_cRef;
    DWORD m_fdwOriginalPerUserFolders;
    DWORD m_fdwNewPerUserFolders;
    DWORD m_fdwCloneFromDefault;
    BOOL m_fCreatingProfile;

    CWizData();
    ~CWizData();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
    STDMETHODIMP PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir);
};
#endif


CWizData::CWizData()
    : m_nlsSupervisorPassword(),
      m_nlsUsername(),
      m_nlsUserPassword(),
      m_cRef(0),
      m_fdwOriginalPerUserFolders(0),
      m_fdwNewPerUserFolders(0),
      m_fdwCloneFromDefault(0),
      m_fCreatingProfile(FALSE)
{

}


CWizData::~CWizData()
{
    if (m_pUserToClone != NULL)
        m_pUserToClone->Release();
}


STDMETHODIMP CWizData::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IUserProfileInit)) {
        *ppvObj = NULL;
        return ResultFromScode(E_NOINTERFACE);
    }

    *ppvObj = this;
    AddRef();
    return NOERROR;
}


STDMETHODIMP_(ULONG) CWizData::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CWizData::Release(void)
{
    ULONG cRef;

    cRef = --m_cRef;

    if (0L == m_cRef) {
        delete this;
    }

    return cRef;
}


void LimitCredentialLength(HWND hDlg, UINT idCtrl)
{
    SendDlgItemMessage(hDlg, idCtrl, EM_LIMITTEXT, (WPARAM)cchMaxUsername, 0);
}


void AddPage(LPPROPSHEETHEADER ppsh, UINT id, DLGPROC pfn, LPVOID pwd)
{
    if (ppsh->nPages < MAX_WIZ_PAGES)
    {
        PROPSHEETPAGE psp;

        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = ::hInstance;
        psp.pszTemplate = MAKEINTRESOURCE(id);
        psp.pfnDlgProc  = pfn;
        psp.lParam      = (LPARAM)pwd;

        ppsh->phpage[ppsh->nPages] = CreatePropertySheetPage(&psp);
        if (ppsh->phpage[ppsh->nPages])
            ppsh->nPages++;
    }
}  // AddPage


INT_PTR CALLBACK IntroDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                break;
            }

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void GoToPage(HWND hDlg, int idPage)
{
    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, idPage);
}


inline void FailChangePage(HWND hDlg)
{
    GoToPage(hDlg, -1);
}


void InitWizDataPtr(HWND hDlg, LPARAM lParam)
{
    CWizData *pwd = (CWizData *)(((LPPROPSHEETPAGE)lParam)->lParam);
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pwd);
}


void InsertControlText(HWND hDlg, UINT idCtrl, const NLS_STR *pnlsInsert)
{
    int cchText = GetWindowTextLength(GetDlgItem(hDlg, IDC_MAIN_CAPTION)) + pnlsInsert->strlen() + 1;
    NLS_STR nlsTemp(MAX_RES_STR_LEN);
    if (nlsTemp.QueryError() == ERROR_SUCCESS) {
        GetDlgItemText(hDlg, idCtrl, nlsTemp.Party(), nlsTemp.QueryAllocSize());
        nlsTemp.DonePartying();
        const NLS_STR *apnls[] = { pnlsInsert, NULL };
        nlsTemp.InsertParams(apnls);
        if (nlsTemp.QueryError() == ERROR_SUCCESS)
            SetDlgItemText(hDlg, idCtrl, nlsTemp.QueryPch());
    }
}


HRESULT GetControlText(HWND hDlg, UINT idCtrl, NLS_STR *pnls)
{
    HWND hCtrl = GetDlgItem(hDlg, idCtrl);
    if (pnls->realloc(GetWindowTextLength(hCtrl) + 1)) {
        GetWindowText(hCtrl, pnls->Party(), pnls->QueryAllocSize());
        pnls->DonePartying();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}


INT_PTR CALLBACK EnterCAPWDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                if (SUCCEEDED(GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsSupervisorPassword))) {
                    if (VerifySupervisorPassword(pwd->m_nlsSupervisorPassword.QueryPch()) == S_FALSE) {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_PASSWORD);
                        FailChangePage(hDlg);
                    }
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        InitWizDataPtr(hDlg, lParam);
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK EnterUserPWDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                if (SUCCEEDED(GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsUserPassword))) {
                    HANDLE hPWL = NULL;
                    if (FAILED(::GetUserPasswordCache(pwd->m_nlsUsername.QueryPch(),
                                                      pwd->m_nlsUserPassword.QueryPch(),
                                                      &hPWL, TRUE))) {
                        MsgBox(hDlg, IDS_BADPASSWORD, MB_OK | MB_ICONSTOP);
                        SetErrorFocus(hDlg, IDC_PASSWORD);
                        FailChangePage(hDlg);
                    }
                    else {
                        if (FAILED(pwd->m_hresRatings))
                            pwd->m_nlsSupervisorPassword = pwd->m_nlsUserPassword;
                        pwd->m_idPrevPage = IDD_EnterUserPassword;
                        ::ClosePasswordCache(hPWL, TRUE);
                        int idNextPage;
                        if (pwd->m_fCreatingProfile)
                            idNextPage = IDD_ChooseFoldersWiz;
                        else
                            idNextPage = (pwd->m_fGoMultiWizard) ? IDD_FinishGoMulti : IDD_FinishAddUser;
                        GoToPage(hDlg, idNextPage);
                    }
                }
            }
            break;

        case PSN_WIZBACK:
            GoToPage(hDlg, IDD_EnterUsername);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
            InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);

            LimitCredentialLength(hDlg, IDC_PASSWORD);

            if (FAILED(pwd->m_hresRatings)) {
                NLS_STR nlsTemp(MAX_RES_STR_LEN);
                if (nlsTemp.QueryError() == ERROR_SUCCESS) {
                    nlsTemp.LoadString(IDS_RATINGS_PW_COMMENT);
                    if (nlsTemp.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_RATINGS_PW_COMMENT, nlsTemp.QueryPch());
                }
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK EnterUsernameDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                int cchUsername = GetWindowTextLength(GetDlgItem(hDlg, IDC_USERNAME));
                if (!cchUsername) {
                    MsgBox(hDlg, IDS_BLANK_USERNAME, MB_OK | MB_ICONSTOP);
                    SetErrorFocus(hDlg, IDC_USERNAME, FALSE);
                    FailChangePage(hDlg);
                }
                else {
                    CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                    if (SUCCEEDED(GetControlText(hDlg, IDC_USERNAME, &pwd->m_nlsUsername))) {
                        /* If we're in the add-user wizard, fail if the user
                         * already exists.  In the go-multiuser wizard, we
                         * just use the info to determine whether to offer
                         * the folder-personalization page.
                         */
                        IUser *pUser = NULL;
                        if (SUCCEEDED(pwd->m_pDB->GetUser(pwd->m_nlsUsername.QueryPch(), &pUser))) {
                            pUser->Release();
                            if (!pwd->m_fGoMultiWizard) {
                                const NLS_STR *apnls[] = { &pwd->m_nlsUsername, NULL };
                                if (MsgBox(hDlg, IDS_USER_EXISTS, MB_OKCANCEL | MB_ICONSTOP, apnls) == IDCANCEL) {
                                    PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                                    break;
                                }
                                SetErrorFocus(hDlg, IDC_USERNAME, FALSE);
                                FailChangePage(hDlg);
                                break;
                            }
                            else {
                                pwd->m_fCreatingProfile = FALSE;
                            }
                        }
                        else {
                            pwd->m_fCreatingProfile = TRUE;
                        }

                        /* See if the user already has a PWL.  If not, next
                         * page is to enter and confirm a password.  If there
                         * is a PWL and its password is non-blank, next page
                         * is simply to enter the password.  If there's a PWL
                         * and its password is blank, next page is Finish.
                         */
                        int idNextPage;
                        HANDLE hPWL = NULL;
                        HRESULT hres = ::GetUserPasswordCache(pwd->m_nlsUsername.QueryPch(),
                                                              szNULL, &hPWL, FALSE);
                        if (SUCCEEDED(hres)) {
                            ::ClosePasswordCache(hPWL, TRUE);
                            pwd->m_idPrevPage = IDD_EnterUsername;
                            if (pwd->m_fCreatingProfile)
                                idNextPage = IDD_ChooseFoldersWiz;
                            else
                                idNextPage = (pwd->m_fGoMultiWizard) ? IDD_FinishGoMulti : IDD_FinishAddUser;
                        }
                        else if (hres == HRESULT_FROM_WIN32(IERR_IncorrectUsername)) {
                            idNextPage = IDD_EnterUserPassword;
                        }
                        else {
                            idNextPage = IDD_NewUserPassword;
                        }
                        GoToPage(hDlg, idNextPage);
                    }
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            LimitCredentialLength(hDlg, IDC_USERNAME);

            if (pwd->m_fGoMultiWizard) {
                NLS_STR nlsText(MAX_RES_STR_LEN);
                if (nlsText.QueryError() == ERROR_SUCCESS) {
                    nlsText.LoadString(IDS_ENTER_FIRST_USERNAME);
                    if (nlsText.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsText.QueryPch());
                }
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void PickUserSelected(HWND hwndLB, int iItem)
{
    HWND hDlg = GetParent(hwndLB);

    if (iItem == LB_ERR) {
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK);
    }
    else {
        PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
    }
}


INT_PTR CALLBACK PickUserDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                PickUserSelected((HWND)lParam, iItem);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
                if (iItem != LB_ERR) {
                    if (pwd->m_pUserToClone != NULL)
                        pwd->m_pUserToClone->Release();
                    pwd->m_pUserToClone = (IUser *)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETITEMDATA, iItem, 0);
                    if (pwd->m_pUserToClone != NULL)
                        pwd->m_pUserToClone->AddRef();
                }
                else {
                    MsgBox(hDlg, IDS_PICK_USERNAME, MB_OK | MB_ICONSTOP);
                    FailChangePage(hDlg);
                }
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)(((LPPROPSHEETPAGE)lParam)->lParam);
            FillUserList(GetDlgItem(hDlg, IDC_USERNAME), pwd->m_pDB, NULL,
                         TRUE, PickUserSelected);
        }
        break;

    case WM_DESTROY:
        DestroyUserList(GetDlgItem(hDlg, IDC_USERNAME));
        break;

    case WM_COMMAND:
        if (LOWORD(wParam) == IDC_USERNAME && HIWORD(wParam) == LBN_SELCHANGE) {
            int iItem = (int)::SendDlgItemMessage(hDlg, IDC_USERNAME, LB_GETCURSEL, 0, 0);
            PickUserSelected((HWND)lParam, iItem);
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


INT_PTR CALLBACK NewPasswordDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);
            }
            break;

        case PSN_WIZNEXT:
            {
                int cchPassword = GetWindowTextLength(GetDlgItem(hDlg, IDC_PASSWORD));

                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GetControlText(hDlg, IDC_PASSWORD, &pwd->m_nlsUserPassword);

                BOOL fConfirmedOK = FALSE;
                int cchConfirm = GetWindowTextLength(GetDlgItem(hDlg, IDC_CONFIRM_PASSWORD));
                if (cchConfirm == cchPassword) {
                    NLS_STR nlsConfirm(cchConfirm+1);
                    if (SUCCEEDED(GetControlText(hDlg, IDC_CONFIRM_PASSWORD, &nlsConfirm))) {
                        if (!nlsConfirm.strcmp(pwd->m_nlsUserPassword))
                            fConfirmedOK = TRUE;
                    }
                }

                if (!fConfirmedOK) {
                    MsgBox(hDlg, IDS_NO_MATCH, MB_OK | MB_ICONSTOP);
                    SetDlgItemText(hDlg, IDC_PASSWORD, szNULL);
                    SetDlgItemText(hDlg, IDC_CONFIRM_PASSWORD, szNULL);
                    SetErrorFocus(hDlg, IDC_PASSWORD);
                    FailChangePage(hDlg);
                }
                else {
                    pwd->m_idPrevPage = IDD_NewUserPassword;
                    UINT idNextPage;
                    if (pwd->m_fCreatingProfile)
                        idNextPage = IDD_ChooseFoldersWiz;
                    else
                        idNextPage = pwd->m_fGoMultiWizard ? IDD_FinishGoMulti : IDD_FinishAddUser;
                    GoToPage(hDlg, idNextPage);
                }
            }
            break;

        case PSN_WIZBACK:
            GoToPage(hDlg, IDD_EnterUsername);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            LimitCredentialLength(hDlg, IDC_PASSWORD);
            LimitCredentialLength(hDlg, IDC_CONFIRM_PASSWORD);

            if (pwd->m_fGoMultiWizard) {
                NLS_STR nlsText(MAX_RES_STR_LEN);
                if (nlsText.QueryError() == ERROR_SUCCESS) {
                    nlsText.LoadString(IDS_YOURNEWPASSWORD);
                    if (nlsText.QueryError() == ERROR_SUCCESS)
                        SetDlgItemText(hDlg, IDC_MAIN_CAPTION, nlsText.QueryPch());
                    if (FAILED(pwd->m_hresRatings)) {
                        nlsText.LoadString(IDS_RATINGS_PW_COMMENT);
                        if (nlsText.QueryError() == ERROR_SUCCESS)
                            SetDlgItemText(hDlg, IDC_RATINGS_PW_COMMENT, nlsText.QueryPch());
                    }
                }
            }
            else {
                InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


const TCHAR c_szExplorerUSFKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders");
const TCHAR c_szExplorerSFKey[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const struct FolderDescriptor {
    UINT idsDirName;        /* Resource ID for directory name */
    LPCTSTR pszRegValue;    /* Name of reg value to set path in */
    LPCTSTR pszStaticName;  /* Static name for ProfileReconciliation subkey */
    LPCTSTR pszFiles;       /* Spec for which files should roam */
    DWORD dwAttribs;        /* Desired attributes */
    BOOL fSecondary : 1;    /* TRUE if subsidiary to the Start Menu */
    BOOL fDefaultInRoot : 1;/* TRUE if default is root of drive, not windir */
} aFolders[] = {

    /* NOTE: Keep the entries in the following table in the same order as the
     * corresponding FOLDER_XXXXXX bitflags in mslocusr.h.
     */

    { IDS_CSIDL_DESKTOP_L,  "Desktop",   "Desktop",   "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_NETHOOD_L,  "NetHood",   "NetHood",   "*.*", FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, 0, 0 },
    { IDS_CSIDL_RECENT_L,   "Recent",    "Recent",    "*.*", FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_HIDDEN, 0, 0 },
    { IDS_CSIDL_STARTMENU_L,"Start Menu","Start Menu","*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_PROGRAMS_L, "Programs",  "Programs",  "*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 1, 0 },
    { IDS_CSIDL_STARTUP_L,  "Startup",   "Startup",   "*.lnk,*.pif,*.url", FILE_ATTRIBUTE_DIRECTORY, 1, 0 },
    { IDS_CSIDL_FAVORITES_L,"Favorites", "Favorites", "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 },
    { IDS_CSIDL_CACHE_L,    "Cache",     "Cache",     "",    FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_SYSTEM, 0, 0 },
    { IDS_CSIDL_PERSONAL_L, "Personal",  "Personal",  "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 1 },
};

const struct FolderDescriptor fdChannels =
    { IDS_CSIDL_CHANNELS_L, NULL, "Channel Preservation Key", "*.*", FILE_ATTRIBUTE_DIRECTORY, 0, 0 };

void InitFolderCheckboxes(HWND hDlg, CWizData *pwd)
{
    IUser *pUserToClone;

    pwd->m_fdwOriginalPerUserFolders = 0;

    if (pwd->m_pUserToClone != NULL) {
        pUserToClone = pwd->m_pUserToClone;
        pUserToClone->AddRef();
    }
    else {
        pwd->m_pDB->GetSpecialUser(GSU_DEFAULT, &pUserToClone);
    }

    HKEY hkeyUser;
    if (pUserToClone != NULL && SUCCEEDED(pUserToClone->LoadProfile(&hkeyUser))) {
        HKEY hkeyProfRec, hkeyProfRec2;
        if (RegOpenKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                         0, KEY_READ, &hkeyProfRec) != ERROR_SUCCESS)
            hkeyProfRec = NULL;
        if (RegOpenKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                         0, KEY_READ, &hkeyProfRec2) != ERROR_SUCCESS)
            hkeyProfRec2 = NULL;

        for (UINT iFolder = 0; iFolder < ARRAYSIZE(aFolders); iFolder++) {
            HKEY hkeyTemp;
            HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

            if (hkeyParent != NULL &&
                RegOpenKeyEx(hkeyParent,
                             aFolders[iFolder].pszStaticName,
                             0, KEY_READ, &hkeyTemp) == ERROR_SUCCESS) {
                RegCloseKey(hkeyTemp);
                pwd->m_fdwOriginalPerUserFolders |= 1 << iFolder;
            }
            /* else bit is already clear */
        }

        if (hkeyProfRec != NULL)
            RegCloseKey(hkeyProfRec);
        if (hkeyProfRec2 != NULL)
            RegCloseKey(hkeyProfRec2);

        pUserToClone->UnloadProfile(hkeyUser);
    }

    if (pUserToClone != NULL)
        pUserToClone->Release();

    CheckDlgButton(hDlg, IDC_CHECK_DESKTOP,
                   (pwd->m_fdwOriginalPerUserFolders & 
                    (FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT)) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_STARTMENU,
                   (pwd->m_fdwOriginalPerUserFolders & 
                    (FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP)) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_FAVORITES,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_FAVORITES) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_CACHE,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_CACHE) ? 1 : 0);
    CheckDlgButton(hDlg, IDC_CHECK_MYDOCS,
                   (pwd->m_fdwOriginalPerUserFolders & FOLDER_MYDOCS) ? 1 : 0);
}


INT_PTR CALLBACK ChooseFoldersDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_NEXT);

                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                InitFolderCheckboxes(hDlg, pwd);
            }
            break;

        case PSN_WIZNEXT:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

                pwd->m_fdwCloneFromDefault = IsDlgButtonChecked(hDlg, IDC_RADIO_EMPTY) ? 0 : 0xffffffff;
                pwd->m_fdwNewPerUserFolders = 0;
                if (IsDlgButtonChecked(hDlg, IDC_CHECK_DESKTOP))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_DESKTOP | FOLDER_NETHOOD | FOLDER_RECENT);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_STARTMENU))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_STARTMENU | FOLDER_PROGRAMS | FOLDER_STARTUP);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_FAVORITES))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_FAVORITES;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_FAVORITES);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_CACHE))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_CACHE;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_CACHE);

                if (IsDlgButtonChecked(hDlg, IDC_CHECK_MYDOCS))
                    pwd->m_fdwNewPerUserFolders |= FOLDER_MYDOCS;
                else
                    pwd->m_fdwNewPerUserFolders &= ~(FOLDER_MYDOCS);

                pwd->m_idPrevPage = IDD_ChooseFoldersWiz;
                GoToPage(hDlg, pwd->m_fGoMultiWizard ? IDD_FinishGoMulti : IDD_FinishAddUser);
            }
            break;

        case PSN_WIZBACK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GoToPage(hDlg, pwd->m_idPrevPage);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);

            CheckRadioButton(hDlg, IDC_RADIO_COPY, IDC_RADIO_EMPTY, IDC_RADIO_COPY);
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


void GetWindowsRootPath(LPSTR pszBuffer, UINT cchBuffer)
{
    GetWindowsDirectory(pszBuffer, cchBuffer);

    LPSTR pszEnd = NULL;
    if (*pszBuffer == '\\' && *(pszBuffer+1) == '\\') {
        pszEnd = ::strchrf(pszBuffer+2, '\\');
        if (pszEnd != NULL) {
            pszEnd = ::strchrf(pszEnd+1, '\\');
            if (pszEnd != NULL)
                pszEnd++;
        }
    }
    else {
        LPSTR pszNext = CharNext(pszBuffer);
        if (*pszNext == ':' && *(pszNext+1) == '\\')
            pszEnd = pszNext + 2;
    }
    if (pszEnd != NULL)
        *pszEnd = '\0';
    else
        AddBackslash(pszBuffer);
}


void AddProfRecKey(HKEY hkeyUser, HKEY hkeyProfRec, const FolderDescriptor *pFolder,
                   BOOL fCloneFromDefault, LPCSTR pszProfileDir)
{
    TCHAR szDefaultPath[MAX_PATH];

    if (pFolder->fDefaultInRoot)
        GetWindowsRootPath(szDefaultPath, ARRAYSIZE(szDefaultPath));
    else
        ::strcpyf(szDefaultPath, TEXT("*windir\\"));

    LPTSTR pszEnd = szDefaultPath + ::strlenf(szDefaultPath);
    LoadString(::hInstance, pFolder->idsDirName,
               pszEnd, ARRAYSIZE(szDefaultPath) - (int)(pszEnd - szDefaultPath));
    LPTSTR pszLastComponent = ::strrchrf(pszEnd, '\\');
    if (pszLastComponent == NULL)
        pszLastComponent = pszEnd;
    else
        pszLastComponent++;

    HKEY hSubKey;

    LONG err = RegCreateKeyEx(hkeyProfRec, pFolder->pszStaticName, 0, NULL, REG_OPTION_NON_VOLATILE, 
                              KEY_WRITE, NULL, &hSubKey, NULL);
    if (err == ERROR_SUCCESS) {
        err = RegSetValueEx(hSubKey, "CentralFile", 0, REG_SZ,
                            (LPBYTE)pszLastComponent, ::strlenf(pszLastComponent)+1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "LocalFile", 0, REG_SZ, (LPBYTE)pszEnd,
                                ::strlenf(pszEnd)+1);
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "Name", 0, REG_SZ, (LPBYTE)pFolder->pszFiles,
                                ::strlenf(pFolder->pszFiles) + 1);

        if (fCloneFromDefault && err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "DefaultDir", 0, REG_SZ, (LPBYTE)szDefaultPath,
                                ::strlenf(szDefaultPath) + 1);

        DWORD dwOne = 1;
        if (err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "MustBeRelative", 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));
        if (fCloneFromDefault && err == ERROR_SUCCESS)
            err = RegSetValueEx(hSubKey, "Default", 0, REG_DWORD, (LPBYTE)&dwOne,
                                sizeof(dwOne));

        if (pFolder->pszRegValue != NULL) {
            if (err == ERROR_SUCCESS)
                err = RegSetValueEx(hSubKey, "RegKey", 0, REG_SZ, (LPBYTE)c_szExplorerUSFKey,
                                    ::strlenf(c_szExplorerUSFKey) + 1);
            if (err == ERROR_SUCCESS)
                err = RegSetValueEx(hSubKey, "RegValue", 0, REG_SZ, (LPBYTE)pFolder->pszRegValue,
                                    ::strlenf(pFolder->pszRegValue) + 1);
        }

        if (err == ERROR_SUCCESS && pFolder->fSecondary) {
            err = RegSetValueEx(hSubKey, "ParentKey", 0, REG_SZ, (LPBYTE)"Start Menu", 11);
        }

        RegCloseKey(hSubKey);
    }

    /* And if we're not adding a clone-from-default profrec key, we know that
     * no profile code is going to create the directory, so we'd better do it
     * ourselves, and set the path in the registry.
     */

    if (!fCloneFromDefault) {
        NLS_STR nlsTemp(MAX_PATH);
        if (nlsTemp.QueryError() == ERROR_SUCCESS) {
            nlsTemp = pszProfileDir;
            AddBackslash(nlsTemp);
            nlsTemp.strcat(pszEnd);

            HKEY hkeyExplorer;
            if (RegOpenKeyEx(hkeyUser, c_szExplorerSFKey, 0,
                             KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                RegSetValueEx(hkeyExplorer, pFolder->pszRegValue,
                              0, REG_SZ, (LPBYTE)nlsTemp.QueryPch(),
                              nlsTemp.strlen()+1);
                RegCloseKey(hkeyExplorer);
            }
            if (RegOpenKeyEx(hkeyUser, c_szExplorerUSFKey, 0,
                             KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                RegSetValueEx(hkeyExplorer, pFolder->pszRegValue,
                              0, REG_SZ, (LPBYTE)nlsTemp.QueryPch(),
                              nlsTemp.strlen()+1);
                RegCloseKey(hkeyExplorer);
            }
            CreateDirectoryPath(nlsTemp.QueryPch());
        }
    }
}


/* CWizData::PreInitProfile is called back by IUserDatabase::Install or
 * ::AddUser after the new user's profile has been created but before
 * directory reconciliation takes place.  This is our chance to add
 * roaming keys for any folders that we want to be per-user and initialized
 * from the defaults, and remove roaming keys for other folders we know about.
 */
STDMETHODIMP CWizData::PreInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
{
    HKEY hkeyProfRec, hkeyProfRec2;
    DWORD dwDisp;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec = NULL;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec2, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec2 = NULL;

    m_fChannelHack = FALSE;

    DWORD fdwFlag = 1;

    for (UINT iFolder = 0;
         iFolder < ARRAYSIZE(aFolders);
         iFolder++, fdwFlag <<= 1) {

        BOOL fWasPerUser = (m_fdwOriginalPerUserFolders & fdwFlag);
        BOOL fMakePerUser = (m_fdwNewPerUserFolders & fdwFlag);
        BOOL fCloneFromDefault = (m_fdwCloneFromDefault & fdwFlag);

        /* If the folder was shared and is staying that way, do nothing. */
        if (!fWasPerUser && !fMakePerUser)
            continue;

        /* If the folder was per-user and is staying that way, do nothing,
         * UNLESS we're creating a new profile and the user chose the start-
         * out-empty option.  In that case we want to make sure to kill the
         * profrec keys until PostInitProfile.
         */
        if (fWasPerUser && fMakePerUser && (!m_fCreatingProfile || fCloneFromDefault))
            continue;

        HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

        /* If the user is making a folder per-user when it wasn't, and they
         * want this folder cloned from the default, add a profrec key now.
         */
        if (fMakePerUser && fCloneFromDefault) {
            AddProfRecKey(hkeyUser, hkeyParent, &aFolders[iFolder], TRUE, pszProfileDir);
        }

        /* If the user is making a folder shared, or they want this per-user
         * folder to start out empty, delete the profrec key now.  In the
         * latter case, we will add it for roaming purposes during
         * PostInitProfile.
         */
        if (!fMakePerUser || !fCloneFromDefault) {

            RegDeleteKey(hkeyParent, aFolders[iFolder].pszStaticName);

            /* If we're making a folder shared and we're not cloning the
             * default profile, then the profile has a per-user directory
             * path in it which we need to clear out.
             *
             * We know that we need to delete the value from User Shell Folders,
             * and set the default path under Shell Folders.
             */

            if (!fMakePerUser && m_pUserToClone != NULL) {

                TCHAR szDefaultPath[MAX_PATH+1];

                if (aFolders[iFolder].fDefaultInRoot) {
                    GetWindowsRootPath(szDefaultPath, ARRAYSIZE(szDefaultPath));
                }
                else {
                    GetWindowsDirectory(szDefaultPath, ARRAYSIZE(szDefaultPath));
                    AddBackslash(szDefaultPath);
                }
                LPTSTR pszEnd = szDefaultPath + ::strlenf(szDefaultPath);

                LoadString(::hInstance, aFolders[iFolder].idsDirName,
                           pszEnd, ARRAYSIZE(szDefaultPath) - (int)(pszEnd - szDefaultPath));

                HKEY hkeyExplorer;

                if (RegOpenKeyEx(hkeyUser, c_szExplorerUSFKey, 0,
                                 KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                    if (aFolders[iFolder].fDefaultInRoot) {
                        RegSetValueEx(hkeyExplorer, aFolders[iFolder].pszRegValue,
                                      0, REG_SZ, (LPBYTE)szDefaultPath,
                                      ::strlenf(szDefaultPath)+1);
                    }
                    else {
                        RegDeleteValue(hkeyExplorer, aFolders[iFolder].pszRegValue);
                    }
                    RegCloseKey(hkeyExplorer);
                }

                if (RegOpenKeyEx(hkeyUser, c_szExplorerSFKey, 0,
                                 KEY_READ | KEY_WRITE, &hkeyExplorer) == ERROR_SUCCESS) {
                    RegSetValueEx(hkeyExplorer, aFolders[iFolder].pszRegValue,
                                  0, REG_SZ, (LPBYTE)szDefaultPath,
                                  ::strlenf(szDefaultPath)+1);
                    RegCloseKey(hkeyExplorer);
                }
            }
        }

        /* Special code for start-out-empty folders:  Some of them need to
         * start out with certain crucial files, not totally empty.
         */

        if (fMakePerUser &&
            (!fWasPerUser || m_fCreatingProfile) &&
            !fCloneFromDefault) {

            /* Special hack for channels: If the user wants Favorites to be per-user,
             * but chooses to start it out empty, they get no channels either, because
             * Channels is a subdirectory of Favorites.  So, for that case only,
             * we force in a clone-from-default profrec key for Channels, which we'll
             * delete in PostInit.
             */

            if (fdwFlag == FOLDER_FAVORITES) {
                AddProfRecKey(hkeyUser, hkeyProfRec, &fdChannels, TRUE, pszProfileDir);
                m_fChannelHack = TRUE;
            }
        }
    }

    if (hkeyProfRec != NULL)
        RegCloseKey(hkeyProfRec);
    if (hkeyProfRec2 != NULL)
        RegCloseKey(hkeyProfRec2);

    return S_OK;
}


/* CWizData::PostInitProfile is called by IUserDatabase::Install or ::AddUser
 * after the user's folders have all been created and initialized.  Here we
 * add profrec keys for any folders which we want to be per-user but don't
 * want initialized from the default.
 */
STDMETHODIMP CWizData::PostInitProfile(HKEY hkeyUser, LPCSTR pszProfileDir)
{
    HKEY hkeyProfRec, hkeyProfRec2;
    DWORD dwDisp;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec = NULL;
    if (RegCreateKeyEx(hkeyUser, "Software\\Microsoft\\Windows\\CurrentVersion\\SecondaryProfileReconciliation",
                       0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkeyProfRec2, &dwDisp) != ERROR_SUCCESS)
        hkeyProfRec2 = NULL;

    DWORD fdwFlag = 1;
    for (UINT iFolder = 0;
         iFolder < ARRAYSIZE(aFolders);
         iFolder++, fdwFlag <<= 1) {

        HKEY hkeyParent = aFolders[iFolder].fSecondary ? hkeyProfRec2 : hkeyProfRec;

        if (m_fdwNewPerUserFolders & fdwFlag) {
            /* If the user is making a folder per-user when it wasn't or making a
             * folder per-user in a new profile, and they want this folder to start 
             * out empty, add a profrec key now.
             */
            if ((!(m_fdwOriginalPerUserFolders & fdwFlag) || m_fCreatingProfile) &&
                !(m_fdwCloneFromDefault & fdwFlag)) {
                AddProfRecKey(hkeyUser, hkeyParent, &aFolders[iFolder], FALSE, pszProfileDir);
            }

            /* If the folder is per-user and is supposed to have special
             * attributes, make sure it has them.
             */
            if (aFolders[iFolder].dwAttribs != FILE_ATTRIBUTE_DIRECTORY) {
                RegEntry re(aFolders[iFolder].pszStaticName, hkeyParent);
                NLS_STR nlsTemp(MAX_PATH);
                if (re.GetError() == ERROR_SUCCESS && nlsTemp.QueryError() == ERROR_SUCCESS) {
                    GetSetRegistryPath(hkeyUser, re, &nlsTemp, FALSE);
                    if (nlsTemp.strlen()) {
                        ::SetFileAttributes(nlsTemp.QueryPch(), aFolders[iFolder].dwAttribs);
                    }
                }
            }
        }
    }

    /* If we added a hack for channels, undo that hack now that we're done
     * initializing the profile.
     */
    if (m_fChannelHack)
        RegDeleteKey(hkeyProfRec, fdChannels.pszStaticName);

    if (hkeyProfRec != NULL)
        RegCloseKey(hkeyProfRec);
    if (hkeyProfRec2 != NULL)
        RegCloseKey(hkeyProfRec2);

    return S_OK;
}


/* Following is actually for the CPL version of the choose-folders dialog */
HRESULT ChooseFoldersProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;
    HKEY hkeyUser;

    if (pwd->m_pUserToClone != NULL &&
        SUCCEEDED(pwd->m_pUserToClone->LoadProfile(&hkeyUser))) {

        TCHAR szProfileDir[MAX_PATH];
        DWORD cbBuffer = sizeof(szProfileDir);
        pwd->m_pUserToClone->GetProfileDirectory(szProfileDir, &cbBuffer);

        pwd->PreInitProfile(hkeyUser, szProfileDir);

        NLS_STR nlsPath(szProfileDir);
        AddBackslash(nlsPath);

        DWORD fdwFlag = 1;
        for (UINT iFolder = 0;
             iFolder < ARRAYSIZE(aFolders);
             iFolder++, fdwFlag <<= 1) {

            /* Do reconciliation if we want to per-user-ize a folder that 
             * wasn't per-user before and we want to clone it from default.
             */
            if (!(pwd->m_fdwOriginalPerUserFolders & fdwFlag) &&
                (pwd->m_fdwNewPerUserFolders & fdwFlag) &&
                (pwd->m_fdwCloneFromDefault & fdwFlag)) {
                DefaultReconcileKey(hkeyUser, nlsPath,
                                    aFolders[iFolder].pszStaticName,
                                    aFolders[iFolder].fSecondary);
            }
        }

        /* Process the initialization hack for Channels, if it exists. */
        if (pwd->m_fChannelHack)
            DefaultReconcileKey(hkeyUser, nlsPath, fdChannels.pszStaticName,
                                fdChannels.fSecondary);

        pwd->PostInitProfile(hkeyUser, szProfileDir);

        pwd->m_pUserToClone->UnloadProfile(hkeyUser);

        SHFlushSFCache();

        return S_OK;
    }
    return E_FAIL;
}


void FinishChooseFolders(HWND hDlg, CWizData *pwd)
{
    if (SUCCEEDED(CallWithinProgressDialog(hDlg, IDD_CreateProgress,    
                                           ChooseFoldersProgressFunc, (LPARAM)pwd)))
        EndDialog(hDlg, TRUE);
}


HRESULT InstallProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;

    return pwd->m_pDB->Install(pwd->m_nlsUsername.QueryPch(),
                               pwd->m_nlsUserPassword.QueryPch(),
                               pwd->m_nlsSupervisorPassword.QueryPch(),
                               pwd);
}


BOOL FinishGoMulti(HWND hDlg, CWizData *pwd)
{
    DWORD dwExitCode = 0xffffffff;  /* not a valid EWX_ value */

    /* If user profiles aren't enabled, enable them.  Using them requires
     * logging off.
     */
    if (!UseUserProfiles()) {
        dwExitCode = EWX_LOGOFF;
        EnableProfiles();
    }

    /* If there is no primary logon provider, install our logon dialog as
     * the primary.  Using this requires rebooting the system.
     */
    if (InstallLogonDialog()) {
        dwExitCode = EWX_REBOOT;
    }

    pwd->m_nlsUserPassword.strupr();
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_CreateProgress,
                                            InstallProgressFunc, (LPARAM)pwd);
    if (SUCCEEDED(hres)) {
        /* Set the new username as the default one to log on as. */
        HKEY hkeyLogon;
        if (OpenLogonKey(&hkeyLogon) == ERROR_SUCCESS) {
            pwd->m_nlsUsername.ToOEM();
            RegSetValueEx(hkeyLogon, ::szUsername, 0, REG_SZ,
                          (LPBYTE)pwd->m_nlsUsername.QueryPch(),
                          pwd->m_nlsUsername.strlen() + 1);
            pwd->m_nlsUsername.ToAnsi();
            RegCloseKey(hkeyLogon);
        }
        if ((dwExitCode != 0xffffffff) &&
            MsgBox(hDlg, IDS_GO_MULTI_RESTART, MB_YESNO | MB_ICONQUESTION) == IDYES) {
            ::ExitWindowsEx(dwExitCode, 0);
            ::ExitProcess(0);
        }
        return TRUE;
    }

    ReportUserError(hDlg, hres);
    return FALSE;
}


HRESULT AddUserProgressFunc(LPARAM lParam)
{
    CWizData *pwd = (CWizData *)lParam;

    return pwd->m_pDB->AddUser(pwd->m_nlsUsername.QueryPch(),
                               pwd->m_pUserToClone, pwd, &pwd->m_pNewUser);
}


BOOL FinishAddUser(HWND hDlg, CWizData *pwd)
{
    pwd->m_nlsUserPassword.strupr();

    pwd->m_pNewUser = NULL;
    HRESULT hres = CallWithinProgressDialog(hDlg, IDD_CreateProgress,
                                            AddUserProgressFunc, (LPARAM)pwd);
    if (SUCCEEDED(hres)) {
        hres = pwd->m_pNewUser->ChangePassword(szNULL, pwd->m_nlsUserPassword.QueryPch());
        pwd->m_pNewUser->Release();
        pwd->m_pNewUser = NULL;
    }
    else {
        ReportUserError(hDlg, hres);
    }

    return SUCCEEDED(hres);
}


INT_PTR CALLBACK FinishDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    NMHDR FAR *lpnm;

    switch(message)
    {
    case WM_NOTIFY:
        lpnm = (NMHDR FAR *)lParam;
        switch(lpnm->code)
        {
        case PSN_SETACTIVE:
            {
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_BACK | PSWIZB_FINISH);
            }
            break;

        case PSN_WIZFINISH:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                BOOL fOK = pwd->m_fGoMultiWizard ? FinishGoMulti(hDlg, pwd) : FinishAddUser(hDlg, pwd);
                if (!fOK)
                    FailChangePage(hDlg);
                else
                    return FALSE;       /* destroy wizard */
            }
            break;

        case PSN_WIZBACK:
            {
                CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
                GoToPage(hDlg, pwd->m_idPrevPage);
            }
            break;

        default:
            return FALSE;
        }
        break;

    case WM_INITDIALOG:
        {
            InitWizDataPtr(hDlg, lParam);
            CWizData *pwd = (CWizData *)GetWindowLongPtr(hDlg, DWLP_USER);
            if (!pwd->m_fGoMultiWizard) {
                InsertControlText(hDlg, IDC_MAIN_CAPTION, &pwd->m_nlsUsername);
                InsertControlText(hDlg, IDC_MAIN_CAPTION2, &pwd->m_nlsUsername);
            }
        }
        break;

    default:
        return FALSE;

    } // end of switch on message
    return TRUE;
}


STDMETHODIMP CLUDatabase::InstallWizard(HWND hwndParent)
{
#if 0
    if (UseUserProfiles()) {
        MsgBox(hwndParent, IDS_PROFILES_ALREADY_ENABLED, MB_OK | MB_ICONINFORMATION);
        return E_FAIL;
    }
#endif

    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    CWizData wd;
    wd.m_hresRatings = VerifySupervisorPassword(szNULL);
    wd.m_fGoMultiWizard = TRUE;
    wd.m_pDB = this;
    AddRef();           /* just in case */
    wd.m_pUserToClone = NULL;

    LPPROPSHEETHEADER ppsh;

    // Allocate the property sheet header
    //
    if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                (MAX_WIZ_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
    {
        ppsh->dwSize     = sizeof(*ppsh);
        ppsh->dwFlags    = PSH_WIZARD;
        ppsh->hwndParent = hwndParent;
        ppsh->hInstance  = ::hInstance;
        ppsh->pszCaption = NULL;
        ppsh->nPages     = 0;
        ppsh->nStartPage = 0;
        ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

        /* Add the pages for the wizard.  Note that we have two pages to
         * prompt for the user's account password -- one to enter, the other
         * to enter and confirm.  The code in EnterUsernameDlgProc jumps to
         * the right password page depending on whether the user has a PWL.
         * The code in NewPasswordDlgProc knows to jump ahead to the finish
         * page.
         *
         * If you add more pages here, be sure to update the code as necessary
         * so the sequence is correct.
         */
        AddPage(ppsh, IDD_EnableProfilesIntro, IntroDlgProc, &wd);
        if (wd.m_hresRatings == S_FALSE)
            AddPage(ppsh, IDD_EnterCAPassword, EnterCAPWDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUsername, EnterUsernameDlgProc, &wd);
        AddPage(ppsh, IDD_NewUserPassword, NewPasswordDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUserPassword, EnterUserPWDlgProc, &wd);
        AddPage(ppsh, IDD_ChooseFoldersWiz, ChooseFoldersDlgProc, &wd);
        AddPage(ppsh, IDD_FinishGoMulti, FinishDlgProc, &wd);

        PropertySheet(ppsh);

        LocalFree((HLOCAL)ppsh);
    }

    Release();  /* undo above AddRef() */

    return S_OK;
}


HRESULT DoAddUserWizard(HWND hwndParent, IUserDatabase *pDB,
                        BOOL fPickUserPage, IUser *pUserToClone)
{
    CWizData wd;
    wd.m_hresRatings = VerifySupervisorPassword(szNULL);
    wd.m_fGoMultiWizard = FALSE;
    wd.m_pDB = pDB;
    pDB->AddRef();      /* just in case */
    wd.m_pUserToClone = pUserToClone;
    if (wd.m_pUserToClone != NULL)
        wd.m_pUserToClone->AddRef();

    LPPROPSHEETHEADER ppsh;

    // Allocate the property sheet header
    //
    if ((ppsh = (LPPROPSHEETHEADER)LocalAlloc(LMEM_FIXED, sizeof(PROPSHEETHEADER)+
                (MAX_WIZ_PAGES * sizeof(HPROPSHEETPAGE)))) != NULL)
    {
        ppsh->dwSize     = sizeof(*ppsh);
        ppsh->dwFlags    = PSH_WIZARD;
        ppsh->hwndParent = hwndParent;
        ppsh->hInstance  = ::hInstance;
        ppsh->pszCaption = NULL;
        ppsh->nPages     = 0;
        ppsh->nStartPage = 0;
        ppsh->phpage     = (HPROPSHEETPAGE *)(ppsh+1);

        AddPage(ppsh, IDD_AddUserIntro, IntroDlgProc, &wd);

        if (IsCurrentUserSupervisor(pDB) != S_OK)
        {
            AddPage(ppsh, IDD_EnterCAPassword, EnterCAPWDlgProc, &wd);
        }

        if (fPickUserPage)
            AddPage(ppsh, IDD_PickUser, PickUserDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUsername, EnterUsernameDlgProc, &wd);
        AddPage(ppsh, IDD_NewUserPassword, NewPasswordDlgProc, &wd);
        AddPage(ppsh, IDD_EnterUserPassword, EnterUserPWDlgProc, &wd);
        AddPage(ppsh, IDD_ChooseFoldersWiz, ChooseFoldersDlgProc, &wd);
        AddPage(ppsh, IDD_FinishAddUser, FinishDlgProc, &wd);

        PropertySheet(ppsh);

        LocalFree((HLOCAL)ppsh);
    }

    pDB->Release(); /* undo above AddRef() */

    return S_OK;
}


STDMETHODIMP CLUDatabase::AddUserWizard(HWND hwndParent)
{
    if (ProfileUIRestricted()) {
        ReportRestrictionError(hwndParent);
        return E_ACCESSDENIED;
    }

    return DoAddUserWizard(hwndParent, this, TRUE, NULL);
}


extern "C" void InstallWizard(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    IUserDatabase *pDB;
    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        pDB->InstallWizard(hwndParent);
        pDB->Release();
    }
}


extern "C" void AddUserWizard(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow)
{
    IUserDatabase *pDB;
    if (SUCCEEDED(::CreateUserDatabase(IID_IUserDatabase, (void **)&pDB))) {
        pDB->AddUserWizard(hwndParent);
        pDB->Release();
    }
}


struct ProgressDlgData
{
    PFNPROGRESS pfn;
    LPARAM lParam;
    HRESULT hres;
};


void CallProgressFunc(HWND hDlg)
{
    ProgressDlgData *ppdd = (ProgressDlgData *)GetWindowLongPtr(hDlg, DWLP_USER);

    ppdd->hres = ppdd->pfn(ppdd->lParam);

    EndDialog(hDlg, FALSE);
}


const UINT WM_CALL_FUNC = WM_USER + 100;

INT_PTR CALLBACK ProgressDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch(message)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            /* Defer function call to a posted message so the dialog manager
             * will show our dialog.
             *
             * If PostMessage fails, at least still call the function anyway.
             */
            if (!PostMessage(hDlg, WM_CALL_FUNC, 0, 0)) {
                CallProgressFunc(hDlg);
            }
        }

        return TRUE;        /* we didn't set the focus */

    case WM_CALL_FUNC:
        CallProgressFunc(hDlg);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


HRESULT CallWithinProgressDialog(HWND hwndOwner, UINT idResource, PFNPROGRESS pfn,
                                 LPARAM lParam)
{
    ProgressDlgData pdd = { pfn, lParam, E_FAIL };

    DialogBoxParam(::hInstance, MAKEINTRESOURCE(idResource), hwndOwner,
                   ProgressDlgProc, (LPARAM)&pdd);

    return pdd.hres;
}


BOOL ProfileUIRestricted(void)
{
    RegEntry rePolicy("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System");

    if (rePolicy.GetError() == ERROR_SUCCESS) {
        if (rePolicy.GetNumber("NoProfilePage") != 0)
            return TRUE;
    }
    return FALSE;
}


void ReportRestrictionError(HWND hwndOwner)
{
    MsgBox(hwndOwner, IDS_PROFILE_POLICY, MB_OK | MB_ICONSTOP);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\pcerr.h ===
/*****************************************************************/
/**				   Microsoft Windows for Workgroups				**/
/**				Copyright (C) Microsoft Corp., 1991-1992		**/
/*****************************************************************/

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif	/* __cplusplus */

/*
	Password cache error codes.
*/

#define IERR_PCACHE_BASE		7200
#define IERR_CachingDisabled	(IERR_PCACHE_BASE + 0)
#define IERR_BadSig				(IERR_PCACHE_BASE + 1)
#define IERR_VersionChanged		(IERR_PCACHE_BASE + 2)
#define IERR_CacheNotLoaded		(IERR_PCACHE_BASE + 3)
#define IERR_CacheEntryNotFound	(IERR_PCACHE_BASE + 4)
#define IERR_CacheReadOnly		(IERR_PCACHE_BASE + 5)
#define IERR_IncorrectUsername	(IERR_PCACHE_BASE + 6)
#define IERR_CacheCorrupt		(IERR_PCACHE_BASE + 7)
#define IERR_EntryTooLarge		(IERR_PCACHE_BASE + 8)
#define IERR_CacheEnumCancelled	(IERR_PCACHE_BASE + 9)
#define IERR_UsernameNotFound	(IERR_PCACHE_BASE + 10)
#define IERR_CacheFull			(IERR_PCACHE_BASE + 11)	/* only if cache would exceed 64K */
#define IERR_CacheAlreadyOpen	(IERR_PCACHE_BASE + 12)
#define IERR_CantCreateUniqueFile	(IERR_PCACHE_BASE + 13)
#define IERR_InvalidParameter	(IERR_PCACHE_BASE + 14)

#ifdef __cplusplus
}
#endif	/* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\msluuser.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include <buffer.h>
#include <regentry.h>
#include "profiles.h"

extern "C" {
#include "netmpr.h"
};

#include <ole2.h>

CLUUser::CLUUser(CLUDatabase *pDB)
	: m_cRef(1),
	  m_hkeyDB(NULL),
	  m_hkeyUser(NULL),
	  m_fUserExists(FALSE),
	  m_fAppearsSupervisor(FALSE),
      m_fLoadedProfile(FALSE),
	  m_nlsUsername(),
	  m_nlsDir(MAX_PATH),
	  m_nlsPassword(),
	  m_fAuthenticated(FALSE),
	  m_pDB(pDB)
{
	/* We have a reference to the database so we can get back to its idea
	 * of the current user.  We handle circular refcount problems specifically
	 * in CLUDatabase::Release;  the database only has one reference to an
	 * IUser, so if his refcount gets down to 1, he releases his cached
	 * current-user object.
	 */
	m_pDB->AddRef();

    RefThisDLL(TRUE);
}


CLUUser::~CLUUser(void)
{
	if (m_hkeyDB != NULL)
		RegCloseKey(m_hkeyDB);

	if (m_hkeyUser != NULL)
		RegCloseKey(m_hkeyUser);

	if (m_pDB != NULL)
		m_pDB->Release();

    RefThisDLL(FALSE);
}


HRESULT CLUUser::Init(LPCSTR pszUsername)
{
	m_nlsUsername = pszUsername;

	UINT err = m_nlsUsername.QueryError();
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	err = m_nlsDir.QueryError();
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	err = (UINT)RegOpenKey(HKEY_LOCAL_MACHINE, ::szProfileList, &m_hkeyDB);
	if (err != ERROR_SUCCESS)
		return HRESULT_FROM_WIN32(err);

	if (!::strcmpf(pszUsername, ::szDefaultUserName)) {
		m_fUserExists = TRUE;
		m_fAppearsSupervisor = FALSE;
	}
	else {
		err = (UINT)RegOpenKey(m_hkeyDB, pszUsername, &m_hkeyUser);
		if (err != ERROR_SUCCESS) {
			m_hkeyUser = NULL;
			m_fUserExists = FALSE;
		}
		else {
			DWORD cb = sizeof(m_fAppearsSupervisor);
			if (RegQueryValueEx(m_hkeyUser, ::szSupervisor, NULL, NULL,
								(LPBYTE)&m_fAppearsSupervisor, &cb) != ERROR_SUCCESS) {
				m_fAppearsSupervisor = FALSE;
			}
			DWORD cbDir = m_nlsDir.QueryAllocSize();
			LPBYTE pbDir = (LPBYTE)m_nlsDir.Party();
			err = RegQueryValueEx(m_hkeyUser, ::szProfileImagePath, NULL, NULL,
								  pbDir, &cbDir);
			if (err != ERROR_SUCCESS)
				*pbDir = '\0';
			m_nlsDir.DonePartying();
            m_fUserExists = (err == ERROR_SUCCESS);
		}
	}

	return NOERROR;
}


STDMETHODIMP CLUUser::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUser)) {
        *ppvObj = NULL;
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CLUUser::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CLUUser::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CLUUser::GetName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsUsername.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	UINT err = NPSCopyNLS(&m_nlsUsername, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUUser::GetProfileDirectory(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsDir.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	if (!m_nlsDir.strlen())
		return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);

	UINT err = NPSCopyNLS(&m_nlsDir, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


BOOL CLUUser::IsSystemCurrentUser(void)
{
    NLS_STR nlsSystemUsername(MAX_PATH);
    if (nlsSystemUsername.QueryError() == ERROR_SUCCESS) {
        if (SUCCEEDED(GetSystemCurrentUser(&nlsSystemUsername)) &&
            !m_nlsUsername.stricmp(nlsSystemUsername)) {
            return TRUE;
        }
    }
    return FALSE;
}


HRESULT CLUUser::GetSupervisorPassword(BUFFER *pbufOut)
{
	LPSTR pBuffer = (LPSTR)pbufOut->QueryPtr();

	if (!m_fAuthenticated) {
        if (IsSystemCurrentUser()) {
            WORD cbBuffer = (WORD)pbufOut->QuerySize();
            APIERR err = WNetGetCachedPassword((LPSTR)::szSupervisorPWLKey,
                                               (WORD)::strlenf(::szSupervisorPWLKey),
            								   pBuffer,
            								   &cbBuffer,
            								   PCE_MISC);
            if (err == ERROR_SUCCESS)
                return S_OK;
            if (err == WN_CANCEL)
                return S_FALSE;
            return HRESULT_FROM_WIN32(err);
        }
		return HRESULT_FROM_WIN32(ERROR_NOT_AUTHENTICATED);
    }

	HPWL hPWL;
	HRESULT hres = GetPasswordCache(m_nlsPassword.QueryPch(), &hPWL);
	if (FAILED(hres))
		return hres;

	APIERR err = FindCacheResource(hPWL, ::szSupervisorPWLKey,
								   (WORD)::strlenf(::szSupervisorPWLKey),
								   pBuffer,
								   (WORD)pbufOut->QuerySize(),
								   PCE_MISC);
	::ClosePasswordCache(hPWL, TRUE);

	if (err == IERR_CacheEntryNotFound)
		return S_FALSE;
	else if (err != NOERROR)
		return HRESULT_FROM_WIN32(err);

	CACHE_ENTRY_INFO *pcei = (CACHE_ENTRY_INFO *)pBuffer;
	::memmovef(pBuffer, pBuffer + pcei->dchPassword, pcei->cbPassword);

	return NOERROR;
}


STDMETHODIMP CLUUser::IsSupervisor(void)
{
    /* If the supervisor password is blank, then everybody's a supervisor */
    if (::VerifySupervisorPassword(::szNULL) == S_OK)
        return S_OK;

    /* If temporary supervisor privilege has been granted to this user object,
     * honor it.
     */

    if (m_fTempSupervisor)
        return S_OK;

	BUFFER bufPCE(MAX_ENTRY_SIZE+2);
	if (bufPCE.QueryPtr() == NULL)
		return E_OUTOFMEMORY;

	HRESULT hres = GetSupervisorPassword(&bufPCE);

	if (hres != S_OK)
		return hres;

	return ::VerifySupervisorPassword((LPCSTR)bufPCE.QueryPtr());
}


APIERR MakeSupervisor(HPWL hPWL, LPCSTR pszSupervisorPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	return ::AddCacheResource(hPWL,
							  ::szSupervisorPWLKey,
							  ::strlenf(::szSupervisorPWLKey),
							  pszSupervisorPassword,
							  ::strlenf(pszSupervisorPassword)+1,
							  PCE_MISC, 0);
#else
    return ERROR_SUCCESS;
#endif
}


STDMETHODIMP CLUUser::SetSupervisorPrivilege(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
{
	if (m_pDB == NULL)
		return E_UNEXPECTED;

#ifndef MSLOCUSR_USE_SUPERVISOR_PASSWORD

    /* Don't write stuff to the user's password cache if we're not doing any
     * supervisor password stuff.
     */
    m_fAppearsSupervisor = fMakeSupervisor;
    return S_OK;

#else

	BUFFER bufPCE(MAX_ENTRY_SIZE+2);
	if (bufPCE.QueryPtr() == NULL)
		return E_OUTOFMEMORY;

    HRESULT hres = S_OK;

    /* If supervisor password is provided by the caller, use that, otherwise
     * inspect the current user's password cache.
     */
    if (pszSupervisorPassword == NULL) {
    	IUser *pCurrentUser;
	    if (FAILED(m_pDB->GetCurrentUser(&pCurrentUser)))
		    return E_ACCESSDENIED;

    	hres = ((CLUUser *)pCurrentUser)->GetSupervisorPassword(&bufPCE);
        pCurrentUser->Release();
        pszSupervisorPassword = (LPCSTR)bufPCE.QueryPtr();
    }

	if (SUCCEEDED(hres)) {
		hres = ::VerifySupervisorPassword(pszSupervisorPassword);
		if (hres == S_OK) {		/* not SUCCEEDED because S_FALSE means wrong PW */
			HPWL hpwlThisUser;
			hres = GetPasswordCache(m_nlsPassword.QueryPch(), &hpwlThisUser);
			if (SUCCEEDED(hres)) {
				APIERR err;
				if (fMakeSupervisor)
				{
					err = ::MakeSupervisor(hpwlThisUser, pszSupervisorPassword);
				}
				else {
					err = ::DeleteCacheResource(hpwlThisUser,
												::szSupervisorPWLKey,
												::strlenf(::szSupervisorPWLKey),
												PCE_MISC);
				}
				::ClosePasswordCache(hpwlThisUser, TRUE);

				hres = HRESULT_FROM_WIN32(err);
			}
            else if (!m_fAuthenticated && IsSystemCurrentUser()) {
                APIERR err;
                if (fMakeSupervisor) {
                    err = ::WNetCachePassword(
							  (LPSTR)::szSupervisorPWLKey,
							  ::strlenf(::szSupervisorPWLKey),
							  (LPSTR)pszSupervisorPassword,
							  ::strlenf(pszSupervisorPassword)+1,
							  PCE_MISC, 0);
                }
                else {
					err = ::WNetRemoveCachedPassword(
												(LPSTR)::szSupervisorPWLKey,
												::strlenf(::szSupervisorPWLKey),
												PCE_MISC);
                }
				hres = HRESULT_FROM_WIN32(err);
            }

			if (SUCCEEDED(hres)) {
				m_fAppearsSupervisor = fMakeSupervisor;
				if (m_hkeyUser != NULL)
					RegSetValueEx(m_hkeyUser, ::szSupervisor, NULL,
								  REG_DWORD, (LPBYTE)&m_fAppearsSupervisor,
								  sizeof(m_fAppearsSupervisor));
			}
		}
	}

	return hres;

#endif
}


STDMETHODIMP CLUUser::MakeTempSupervisor(BOOL fMakeSupervisor, LPCSTR pszSupervisorPassword)
{
    if (!fMakeSupervisor)
        m_fTempSupervisor = FALSE;
    else {
        HRESULT hres = ::VerifySupervisorPassword(pszSupervisorPassword);
        if (hres == S_FALSE)
            hres = E_ACCESSDENIED;
        if (FAILED(hres))
            return hres;

        m_fTempSupervisor = TRUE;
    }

    return S_OK;
}


STDMETHODIMP CLUUser::AppearsSupervisor(void)
{
    if (m_fTempSupervisor)
        return S_OK;

	return m_fAppearsSupervisor ? S_OK : S_FALSE;
}


STDMETHODIMP CLUUser::Authenticate(LPCSTR pszPassword)
{
	HPWL hPWL = NULL;

	HRESULT hres = GetPasswordCache(pszPassword, &hPWL);
	if (FAILED(hres))
		return hres;

	::ClosePasswordCache(hPWL, TRUE);

	return NOERROR;
}


STDMETHODIMP CLUUser::ChangePassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
	//  if current user is supervisor, allow null pszOldPassword

    NLS_STR nlsNewPassword(pszNewPassword);
    if (nlsNewPassword.QueryError())
        return HRESULT_FROM_WIN32(nlsNewPassword.QueryError());
    nlsNewPassword.strupr();
    nlsNewPassword.ToOEM();

	HPWL hPWL;

	HRESULT hres = GetPasswordCache(pszOldPassword, &hPWL);

	if (FAILED(hres))
		return hres;

	hres = HRESULT_FROM_WIN32(::SetCachePassword(hPWL, nlsNewPassword.QueryPch()));

	if (SUCCEEDED(hres)) {
		m_nlsPassword = pszNewPassword;	/* FEATURE - obfuscate me */
		m_fAuthenticated = TRUE;
	}

	::ClosePasswordCache(hPWL, TRUE);

	return hres;
}


HRESULT GetUserPasswordCache(LPCSTR pszUsername, LPCSTR pszPassword, LPHANDLE phOut, BOOL fCreate)
{
	NLS_STR nlsUsername(pszUsername);
	if (nlsUsername.QueryError())
		return HRESULT_FROM_WIN32(nlsUsername.QueryError());

	nlsUsername.strupr();
	nlsUsername.ToOEM();

	NLS_STR nlsPassword(pszPassword);
	if (nlsPassword.QueryError())
		return HRESULT_FROM_WIN32(nlsPassword.QueryError());

	nlsPassword.ToOEM();

	*phOut = NULL;
	UINT err = ::OpenPasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch(), TRUE);

    if (fCreate &&
        (err == IERR_UsernameNotFound || err == ERROR_FILE_NOT_FOUND ||
         err == ERROR_PATH_NOT_FOUND)) {
   		err = ::CreatePasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch());
    }

	if (err == IERR_IncorrectUsername) {
		nlsPassword.ToAnsi();			/* must convert to OEM to uppercase properly */
		nlsPassword.strupr();
		nlsPassword.ToOEM();
		err = ::OpenPasswordCache(phOut, nlsUsername.QueryPch(), nlsPassword.QueryPch(), TRUE);
	}

	if (err)
		return HRESULT_FROM_WIN32(err);

    return S_OK;
}


STDMETHODIMP CLUUser::GetPasswordCache(LPCSTR pszPassword, LPHANDLE phOut)
{
    HRESULT hres = ::GetUserPasswordCache(m_nlsUsername.QueryPch(), pszPassword,
                                          phOut, TRUE);
    if (FAILED(hres))
        return hres;

	m_nlsPassword = pszPassword;	/* FEATURE - obfuscate me */
	m_fAuthenticated = TRUE;

	return NOERROR;
}


STDMETHODIMP CLUUser::LoadProfile(HKEY *phkeyUser)
{
    if (IsSystemCurrentUser() ||
        !::strcmpf(m_nlsUsername.QueryPch(), ::szDefaultUserName)) {
        /* If he's the current or default user, his profile should be loaded
         * under HKEY_USERS.  If it is, we can return that key.  Otherwise,
         * we'll need to load it.
         */
        if (RegOpenKeyEx(HKEY_USERS, m_nlsUsername.QueryPch(), 0,
                         KEY_READ | KEY_WRITE, phkeyUser) == ERROR_SUCCESS) {
            m_fLoadedProfile = FALSE;
            return S_OK;
        }
    }
    else {
        if (IsCurrentUserSupervisor(m_pDB) != S_OK)
	    	return E_ACCESSDENIED;
    }

    RegEntry reRoot(::szProfileList, HKEY_LOCAL_MACHINE);
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    reRoot.MoveToSubKey(m_nlsUsername.QueryPch());
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    NLS_STR nlsProfilePath(MAX_PATH);
    if (nlsProfilePath.QueryError() != ERROR_SUCCESS)
        return E_OUTOFMEMORY;

    reRoot.GetValue(::szProfileImagePath, &nlsProfilePath);
    if (reRoot.GetError() != ERROR_SUCCESS)
        return HRESULT_FROM_WIN32(reRoot.GetError());

    AddBackslash(nlsProfilePath);
    nlsProfilePath.strcat(::szStdNormalProfile);
    if (!FileExists(nlsProfilePath.QueryPch()))
        return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

    LONG err = ::MyRegLoadKey(HKEY_USERS, m_nlsUsername.QueryPch(), nlsProfilePath.QueryPch());
    if (err == ERROR_SUCCESS) {
        HKEY hkeyNewProfile;
        err = ::RegOpenKey(HKEY_USERS, m_nlsUsername.QueryPch(), phkeyUser);
        if (err != ERROR_SUCCESS) {
            ::RegUnLoadKey(HKEY_USERS, m_nlsUsername.QueryPch());
        }
        else {
            m_fLoadedProfile = TRUE;
        }
    }

    return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CLUUser::UnloadProfile(HKEY hkeyUser)
{
    RegFlushKey(hkeyUser);
    RegCloseKey(hkeyUser);

    if (m_fLoadedProfile) {
        RegUnLoadKey(HKEY_USERS, m_nlsUsername.QueryPch());
        m_fLoadedProfile = FALSE;
    }
    return S_OK;
}


STDMETHODIMP CLUUser::GetComponentSettings(REFCLSID clsidComponent,
										   LPCSTR pszName, IUnknown **ppOut,
										   DWORD fdwAccess)
{
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP CLUUser::EnumerateComponentSettings(IEnumUnknown **ppOut,
											     DWORD fdwAccess)
{
	return ResultFromScode(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\pch.cpp ===
#include "mslocusr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\netspi.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1995          **/
/*****************************************************************/

/* NETSPI.H -- Network service provider interface definitions.
 */

#ifndef _INC_NETSPI
#define _INC_NETSPI

#ifndef _WINNETWK_
#include <winnetwk.h>
#endif

#ifndef _INC_NETMPR_
#include <netmpr.h>
#endif

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

//
// Capability masks and values.
//

#define WNNC_SPEC_VERSION   0x01
#define     WNNC_SPEC_VERSION51 0x00050001

#define WNNC_NET_TYPE       0x02
// Net types defined in Winnetwk.h

#define WNNC_DRIVER_VERSION 0x03

#define WNNC_USER           0x04
#define     WNNC_USR_GETUSER    0x01

#define WNNC_CONNECTION     0x06
#define     WNNC_CON_ADDCONNECTION      0x01
#define     WNNC_CON_CANCELCONNECTION   0x02
#define     WNNC_CON_GETCONNECTIONS     0x04
#define     WNNC_CON_GETPERFORMANCE     0x08
#define     WNNC_CON_GETUNIVERSALNAME   0x10
#define     WNNC_CON_FORMATCONNECTION   0x20

#define WNNC_DIALOG         0x08
#define     WNNC_DLG_FORMATNETWORKNAME  0x080
#define     WNNC_DLG_GETRESOURCEPARENT  0x100
#define     WNNC_DLG_GETRESOURCEINFORMATION  0x800

#define WNNC_ERROR          0x0A
#define  WNNC_ERR_GETERROR              0x01
#define  WNNC_ERR_GETERRORTEXT          0x02

#define WNNC_ENUMERATION    0x0B
#define     WNNC_ENUM_GLOBAL    0x01
#define     WNNC_ENUM_LOCAL     0x02
#define     WNNC_ENUM_CONTEXT   0x04

#define WNNC_START          0x0C
#define     WNNC_START_WONT     0x00
#define     WNNC_START_UNKNOWN  0xFFFFFFFF
#define     WNNC_START_DONE     0x01
#define     WNNC_START_INACTIVE 0xFFFFFFFE

#define WNNC_RESOURCE       0x0D
#define     WNNC_RES_VALIDLOCALDEVICE   0x80

#define WNNC_AUTHENTICATION 0x0E
#define     WNNC_AUTH_LOGON             0x02
#define     WNNC_AUTH_LOGOFF            0x04
#define		WNNC_AUTH_GETHOMEDIRECTORY	0x10
#define		WNNC_AUTH_GETPOLICYPATH		0x20

#define WNNC_MAXCAPNO WNNC_AUTHENTICATION

//
// Profile strings.
//
#define NPProvider      "NPProvider"
#define NPName          "NPName"
#define NPDescription   "NPDescription"
#define NPID            "NPID"

//
// Various defines.
//
//Spec version
#define WNNC_DRIVER_MAJOR1  1  
#define WNNC_DRIVER_MINOR1  1
#define WNNC_DRIVER(major,minor) (major*0x00010000 + minor)

//
// NP SPI Definitions.
//

#define SPIENTRY DWORD WINAPI

typedef SPIENTRY F_NPGetCaps(
    DWORD nIndex
    );

F_NPGetCaps NPGetCaps;
typedef F_NPGetCaps FAR *PF_NPGetCaps;

typedef SPIENTRY F_NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    );

F_NPGetUniversalName NPGetUniversalName;
typedef F_NPGetUniversalName FAR *PF_NPGetUniversalName;

typedef SPIENTRY F_NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    );

F_NPGetUser NPGetUser;
typedef F_NPGetUser FAR *PF_NPGetUser;

typedef SPIENTRY F_NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    );

F_NPValidLocalDevice NPValidLocalDevice;
typedef F_NPValidLocalDevice FAR *PF_NPValidLocalDevice;

typedef SPIENTRY F_NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    );

F_NPAddConnection NPAddConnection;
typedef F_NPAddConnection FAR *PF_NPAddConnection;

typedef SPIENTRY F_NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    );

F_NPCancelConnection NPCancelConnection;
typedef F_NPCancelConnection FAR *PF_NPCancelConnection;

typedef SPIENTRY F_NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    );

F_NPGetConnection NPGetConnection;
typedef F_NPGetConnection FAR *PF_NPGetConnection;

typedef SPIENTRY F_NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );

F_NPGetConnectionPerformance NPGetConnectionPerformance;
typedef F_NPGetConnectionPerformance FAR *PF_NPGetConnectionPerformance;

typedef SPIENTRY F_NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    );

F_NPFormatNetworkName NPFormatNetworkName;
typedef F_NPFormatNetworkName FAR *PF_NPFormatNetworkName;

typedef DWORD (FAR PASCAL *NPDISPLAYCALLBACK)(
    LPVOID  lpUserData,
    DWORD   dwDisplayType,
    LPTSTR  lpszHeaders
    );

typedef SPIENTRY F_NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    );

F_NPOpenEnum NPOpenEnum;
typedef F_NPOpenEnum FAR *PF_NPOpenEnum;

typedef SPIENTRY F_NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    );

F_NPEnumResource NPEnumResource;
typedef F_NPEnumResource FAR *PF_NPEnumResource;

typedef SPIENTRY F_NPCloseEnum(
    HANDLE hEnum
    );

F_NPCloseEnum NPCloseEnum;
typedef F_NPCloseEnum FAR *PF_NPCloseEnum;

typedef SPIENTRY F_NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    );

F_NPGetResourceParent NPGetResourceParent;
typedef F_NPGetResourceParent FAR *PF_NPGetResourceParent;

typedef SPIENTRY F_NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    );

F_NPGetResourceInformation NPGetResourceInformation;
typedef F_NPGetResourceInformation FAR *PF_NPGetResourceInformation;

typedef struct _LOGONINFO {
    LPTSTR lpUsername;
    LPTSTR lpPassword;
	DWORD cbUsername;
	DWORD cbPassword;
} LOGONINFO, FAR *LPLOGONINFO;

typedef SPIENTRY F_NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    );

F_NPLogon NPLogon;
typedef F_NPLogon FAR *PF_NPLogon;

typedef SPIENTRY F_NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    );

F_NPLogoff NPLogoff;
typedef F_NPLogoff FAR *PF_NPLogoff;

typedef SPIENTRY F_NPChangePassword(
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
	DWORD		dwAction
	);

F_NPChangePassword NPChangePassword;
typedef F_NPChangePassword FAR *PF_NPChangePassword;

typedef SPIENTRY F_NPChangePasswordHwnd(
	HWND hwndOwner
	);

F_NPChangePasswordHwnd NPChangePasswordHwnd;
typedef F_NPChangePasswordHwnd FAR *PF_NPChangePasswordHwnd;


typedef SPIENTRY F_NPGetPasswordStatus(
	DWORD		nIndex
	);

F_NPGetPasswordStatus NPGetPasswordStatus;
typedef F_NPGetPasswordStatus FAR *PF_NPGetPasswordStatus;


typedef SPIENTRY F_NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    );

F_NPGetHomeDirectory NPGetHomeDirectory;
typedef F_NPGetHomeDirectory FAR *PF_NPGetHomeDirectory;

typedef SPIENTRY F_NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    );

// flags for NPGetPolicyPath
#define GPP_LOADBALANCE	0x0001

F_NPGetPolicyPath NPGetPolicyPath;
typedef F_NPGetPolicyPath FAR *PF_NPGetPolicyPath;

//
// MPR Services.
//

#define NPSGetProviderHandle NPSGetProviderHandleA
#define NPSGetProviderName NPSGetProviderNameA
#define NPSGetSectionName NPSGetSectionNameA
#define NPSSetExtendedError NPSSetExtendedErrorA
#define NPSSetCustomText NPSSetCustomTextA
#define NPSCopyString NPSCopyStringA
#define NPSDeviceGetNumber NPSDeviceGetNumberA
#define NPSDeviceGetString NPSDeviceGetStringA
#define NPSNotifyRegister NPSNotifyRegisterA
#define NPSNotifyGetContext NPSNotifyGetContextA
#define NPSAuthenticationDialog NPSAuthenticationDialogA

#define NPSERVICE	WINAPI
#define HPROVIDER   LPVOID
typedef HPROVIDER FAR * PHPROVIDER;

typedef struct {
    DWORD  cbStructure;       /* size of this structure in bytes */
    HWND   hwndOwner;         /* owner window for the authentication dialog */
    LPCSTR lpResource;        /* remote name of resource being accessed */
    LPSTR  lpUsername;        /* default username to show, NULL to hide field */
    DWORD  cbUsername;        /* size of lpUsername buffer, set to length copied on exit */
    LPSTR  lpPassword;        /* default password to show */
    DWORD  cbPassword;        /* size of lpPassword buffer, set to length copied on exit */
    LPSTR  lpOrgUnit;         /* default org unit to show, NULL to hide field */
    DWORD  cbOrgUnit;         /* size of lpOrgUnit buffer, set to length copied on exit */
    LPCSTR lpOUTitle;         /* title of org unit field, NULL for default title */
    LPCSTR lpExplainText;     /* explanatory text at top, NULL for default text */
    LPCSTR lpDefaultUserName; /* explanatory text at top, NULL for default text */
    DWORD  dwFlags;           /* flags (see below) */
} AUTHDLGSTRUCTA, FAR *LPAUTHDLGSTRUCTA;
#define AUTHDLGSTRUCT AUTHDLGSTRUCTA
#define LPAUTHDLGSTRUCT LPAUTHDLGSTRUCTA

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

#define AUTHDLG_ENABLECACHE       0x00000001  /* enable and show PW cache checkbox */
#define AUTHDLG_CHECKCACHE        0x00000002  /* check PW cache checkbox by default */
#define AUTHDLG_CACHEINVALID      0x00000004  /* cached PW was invalid (special text) */
#define AUTHDLG_USE_DEFAULT_NAME  0x00000008  /* enable and show use "guest" box */
#define AUTHDLG_CHECKDEFAULT_NAME 0x00000010  /* check "guest" box               */
#define AUTHDLG_LOGON             0x00000020  /* include Windows logo bitmap */

DWORD
NPSERVICE
NPSAuthenticationDialog(
    LPAUTHDLGSTRUCT lpAuthDlgStruct
    );

DWORD
NPSERVICE
NPSGetProviderHandle( 
	PHPROVIDER phProvider
	);

DWORD
NPSERVICE
NPSGetProviderName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszProviderName
	);

DWORD
NPSERVICE
NPSGetSectionName(
	HPROVIDER hProvider,
	LPCSTR FAR * lpszSectionName
	);

DWORD
NPSERVICE NPSSetExtendedError (
	DWORD NetSpecificError,
	LPSTR lpExtendedErrorText 
    );

VOID
NPSERVICE NPSSetCustomText (
	LPSTR lpCustomErrorText 
    );

DWORD
NPSERVICE
NPSCopyString (
    LPCTSTR lpString,
    LPVOID  lpBuffer,
    LPDWORD lpdwBufferSize
    );

DWORD
NPSERVICE
NPSDeviceGetNumber (
    LPTSTR  lpLocalName,
    LPDWORD lpdwNumber,
    LPDWORD lpdwType
    );

DWORD
NPSERVICE
NPSDeviceGetString (
    DWORD   dwNumber,
    DWORD   dwType,
    LPTSTR  lpLocalName,
    LPDWORD lpdwBufferSize
    );

// Notification Service.

enum NOTIFYTYPE { NotifyAddConnection, 
                  NotifyCancelConnection, 
                  NotifyGetConnectionPerformance };

#define NOTIFY_PRE              0x00
#define NOTIFY_POST             0x01

typedef struct _NOTIFYINFO {
    DWORD cbStructure;          /* size of NOTIFYINFO */
    DWORD  dwNotifyStatus;      /* Pre/post notification status */
    DWORD  dwOperationStatus;   /* Status of operation */
    LPVOID lpNPContext;         /* NP context */
} NOTIFYINFO, FAR *LPNOTIFYINFO;

typedef struct _NOTIFYADD {
    DWORD cbStructure;          /* size of NOTIFYADD */
    HWND hwndOwner;             /* hWnd for UI */
    NETRESOURCE NetResource;    /* Resource to add */
    DWORD dwAddFlags;           /* Add flags */
    LPTSTR lpAccessName;        /* System name for connection */
    LPDWORD lpBufferSize;       /* Size of AccessName buffer */
    DWORD dwResult;             /* Info about connection */
    DWORD dwAddContext;         /* Context of add connection */
} NOTIFYADD, FAR *LPNOTIFYADD;

#define CONNECT_CTXT_RESTORE        0x00000001
#define CONNECT_CTXT_GLOBAL         0x00000002
#define CONNECT_CTXT_PROVIDER       0x00000004
#define CONNECT_CTXT_SINGLE         0x00000008

typedef struct _NOTIFYCANCEL {
    DWORD cbStructure;          /* size of NOTIFYCANCEL */
    LPTSTR lpName;              /* Local device name or remote name of resource */
    LPTSTR lpProvider;          /* Provider name of resource cancelled */
    DWORD dwFlags;              /* Cancel flags */
    BOOL fForce;                /* Cancel force */
} NOTIFYCANCEL, FAR *LPNOTIFYCANCEL;

typedef struct _NOTIFYPERFORMANCE {
	DWORD cbStructure;          /* size of NOTIFYPERFORMANCE */
	LPTSTR lpRemoteName;        /* network resource name */
	LPTSTR lpProviderName;      /* provider to try/provider that responded */
	LPNETCONNECTINFOSTRUCT lpNetConnectInfo; /* performance information requested/returned */
} NOTIFYPERFORMANCE, FAR *LPNOTIFYPERFORMANCE;

typedef DWORD (FAR PASCAL *NOTIFYCALLBACK)( LPNOTIFYINFO lpNotifyInfo, LPVOID lpOperationInfo );

DWORD
NPSERVICE
NPSNotifyRegister(
    enum NOTIFYTYPE NotifyType,
    NOTIFYCALLBACK P_FNotifyCallBack
    );

LPVOID
NPSERVICE
NPSNotifyGetContext (
    NOTIFYCALLBACK P_FNotifyCallBack
    );

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NETSPI */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\profiles.h ===
void AddBackslash(LPSTR lpPath);
void AddBackslash(NLS_STR& nlsPath);
BOOL FileExists(LPCSTR pszPath);
BOOL DirExists(LPCSTR pszPath);
UINT SafeCopy(LPCSTR pszSrc, LPCSTR pszDest, DWORD dwAttrs);
HRESULT GiveUserDefaultProfile(LPCSTR pszPath);
HRESULT CopyProfile(LPCSTR pszSrcPath, LPCSTR pszDestPath);
LONG MyRegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFile);
HRESULT ReconcileFiles(HKEY hkeyProfile, NLS_STR& nlsProfilePath, NLS_STR& nlsOtherProfilePath);
HRESULT DefaultReconcileKey(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                            LPCSTR pszKeyName, BOOL fSecondary);
void ComputeLocalProfileName(LPCSTR pszUsername, NLS_STR *pnlsLocalProfile);
HRESULT DeleteProfile(LPCSTR pszName);
BOOL UseUserProfiles(void);
void EnableProfiles(void);
LONG OpenLogonKey(HKEY *phkey);
BOOL CreateDirectoryPath(LPCSTR pszPath);

#ifdef REGENTRY_INC
void GetSetRegistryPath(HKEY hkeyProfile, RegEntry& re, NLS_STR *pnlsPath, BOOL fSet);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\pwlapi.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**			  Copyright (C) Microsoft Corp., 1991-1992			**/
/*****************************************************************/

/*
	pcache.h
	Definitions for password cache code

	FILE HISTORY:
		gregj	06/25/92	Created
		gregj	07/13/92	Finishing up lots more stuff, incl. classes
		gregj	04/23/93	Ported to Chicago environment
		gregj	09/16/93	Added memory-only entry support for Chicago
		gregj	11/30/95	Support for new file format
		gregj	08/13/96	Removed everything but MSPWL32 API definitions
*/

#ifndef _PWLAPI_H_
#define _PWLAPI_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef unsigned char UCHAR;
typedef UINT APIERR;

#include <pcerr.h>

#ifndef _SIZE_T_DEFINED
# include <stddef.h>
#endif

#ifndef PCE_STRUCT_DEFINED

#define PCE_STRUCT_DEFINED		/* for benefit of pcache.h */

struct PASSWORD_CACHE_ENTRY {
	USHORT cbEntry;				/* size of this entry in bytes, incl. pad */
								/* high bit marks end of bucket */
	USHORT cbResource;			/* size of resource name in bytes */
	USHORT cbPassword;			/* size of password in bytes */
	UCHAR iEntry;				/* index number of this entry, for MRU */
	UCHAR nType;				/* type of entry (see below) */
	CHAR abResource[1];			/* resource name (may not be ASCIIZ at all) */
//	CHAR abPassword[cbPassword]; /* password (also may not be ASCIIZ) */
//	CHAR abPad[];				/* WORD padding */
};

typedef BOOL (*CACHECALLBACK)( struct PASSWORD_CACHE_ENTRY *pce, DWORD dwRefData );

#endif	/* PCE_STRUCT_DEFINED */


/*
    the following nType values are only for the purposes of enumerating
    entries from the cache.  note that PCE_ALL is reserved and should not
    be the nType value for any entry.
*/

// NOTE BENE!  All of the following MUST be synchronized with
//             \\flipper\wb\src\common\h\pcache.hxx!

#define PCE_DOMAIN		0x01	/* entry is for a domain */
#define PCE_SERVER		0x02	/* entry is for a server */
#define PCE_UNC			0x03	/* entry is for a server/share combo */
#define PCE_MAIL		0x04	/* entry is a mail password */
#define PCE_SECURITY	0x05	/* entry is a security entry */
#define PCE_MISC		0x06	/* entry is for some other resource */
#define PCE_NDDE_WFW	0x10	/* entry is WFW DDE password */
#define PCE_NDDE_NT		0x11	/* entry is NT DDE password */
#define PCE_NW_SERVER	0x12	/* entry is Netware server*/
#define PCE_PCONN		0x81	/* persistent connection */
#define PCE_DISKSHARE	0x82	/* persistent disk share */
#define PCE_PRINTSHARE	0x83	/* persistent print share */
#define PCE_DOSPRINTSHARE	0x84	/* persistent DOS print share */
#define	PCE_NW_PSERVER	0x85	/* for NetWare Print Server login (MSPSRV.EXE) */

#define PCE_NOTMRU	0x80		/* bit set if entry is exempt from MRU aging */
#define PCE_ALL		0xff		/* retrieve all entries */

#define MAX_ENTRY_SIZE	250	/* so total file size < 64K */

struct CACHE_ENTRY_INFO {
	USHORT cbResource;		/* size of resource name in bytes */
	USHORT cbPassword;		/* size of password in bytes */
	UCHAR iEntry;			/* index number of entry */
	UCHAR nType;			/* type of entry (see below) */
	USHORT dchResource;		/* offset in buffer to resource name */
	USHORT dchPassword;		/* offset in buffer to password */
};


/*
	Externally exposed API-like things.
*/

typedef LPVOID HPWL;
typedef HPWL *LPHPWL;

APIERR OpenPasswordCache(
	LPHPWL lphCache,
	const CHAR *pszUsername,
	const CHAR *pszPassword,
	BOOL fWritable );
APIERR ClosePasswordCache( HPWL hCache, BOOL fDiscardMemory );
APIERR CreatePasswordCache(
	LPHPWL lphCache,
	const CHAR *pszUsername,
	const CHAR *pszPassword );
APIERR DeletePasswordCache(const CHAR *pszUsername);
APIERR CheckCacheVersion( HPWL hCache, ULONG ulVersion );
APIERR LoadCacheImage( HPWL hCache );
APIERR MakeCacheDirty( HPWL hCache );
APIERR FindCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	CHAR *pbBuffer,
	WORD cbBuffer,
	UCHAR nType );
APIERR DeleteCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	UCHAR nType );
APIERR AddCacheResource(
	HPWL hCache,
	const CHAR *pbResource,
	WORD cbResource,
	const CHAR *pbPassword,
	WORD cbPassword,
	UCHAR nType,
	UINT fnFlags );
#define PCE_MEMORYONLY		0x01

APIERR EnumCacheResources(
	HPWL hCache,
	const CHAR *pbPrefix,
	WORD cbPrefix,
	UCHAR nType,
	CACHECALLBACK pfnCallback,
	DWORD dwRefData );
APIERR UpdateCacheMRU(
	HPWL hCache,
	const struct CACHE_ENTRY_INFO *pce );
APIERR SetCachePassword(
	HPWL hCache,
	const CHAR *pszNewPassword );
APIERR GetCacheFileName(
	const CHAR *pszUsername,
	CHAR *pszFilename,
	UINT cbFilename );

#ifdef __cplusplus
}	/* extern "C" */
#endif


#endif	/* _PWLAPI_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\profiles.cpp ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* PROFILES.CPP -- Code for user profile management.
 *
 * History:
 *  01/04/94    gregj   Created
 *	06/28/94	gregj	Use sync engine for desktop, programs reconciliation
 *	09/05/96	gregj	Snarfed from MPR for use by IE4 family logon.
 */

#include "mslocusr.h"
#include "msluglob.h"

#include "resource.h"

#include <npmsg.h>
#include <regentry.h>
#include <buffer.h>
#include <shellapi.h>

HMODULE g_hmodShell = NULL;
typedef int (*PFNSHFILEOPERATIONA)(LPSHFILEOPSTRUCTA lpFileOp);
PFNSHFILEOPERATIONA g_pfnSHFileOperationA = NULL;


HRESULT LoadShellEntrypoint(void)
{
    if (g_pfnSHFileOperationA != NULL)
        return S_OK;

    HRESULT hres;
    ENTERCRITICAL
    {
        if (g_hmodShell == NULL) {
            g_hmodShell = ::LoadLibrary("SHELL32.DLL");
        }
        if (g_hmodShell != NULL) {
            g_pfnSHFileOperationA = (PFNSHFILEOPERATIONA)::GetProcAddress(g_hmodShell, "SHFileOperationA");
        }
        if (g_pfnSHFileOperationA == NULL)
            hres = HRESULT_FROM_WIN32(::GetLastError());
        else
            hres = S_OK;
    }
    LEAVECRITICAL

    return hres;
}


void UnloadShellEntrypoint(void)
{
    ENTERCRITICAL
    {
        if (g_hmodShell != NULL) {
            ::FreeLibrary(g_hmodShell);
            g_hmodShell = NULL;
            g_pfnSHFileOperationA = NULL;
        }
    }
    LEAVECRITICAL
}


const DWORD attrLocalProfile = FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY;

extern "C" {
extern LONG __stdcall RegRemapPreDefKey(HKEY hkeyNew, HKEY hkeyPredef);
};

#ifdef DEBUG

extern "C" {
BOOL fNoisyReg = FALSE;
};

#endif

LONG MyRegLoadKey(HKEY hKey, LPCSTR lpszSubKey, LPCSTR lpszFile)
{
#ifdef DEBUG
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegLoadKey(\"%s\", \"%s\")\r\n", lpszSubKey, lpszFile);
		::OutputDebugString(buf);
	}
#endif

	/* Since the registry doesn't support long filenames, get the short
	 * alias for the path.  If that succeeds, we use that path, otherwise
	 * we just use the original one and hope it works.
	 */
	CHAR szShortPath[MAX_PATH+1];
	if (GetShortPathName(lpszFile, szShortPath, sizeof(szShortPath)))
		lpszFile = szShortPath;

	return ::RegLoadKey(hKey, lpszSubKey, lpszFile);
}


#ifdef DEBUG
LONG MyRegUnLoadKey(HKEY hKey, LPCSTR lpszSubKey)
{
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegUnLoadKey(\"%s\")\r\n", lpszSubKey);
		::OutputDebugString(buf);
	}
	return ::RegUnLoadKey(hKey, lpszSubKey);
}
#endif


LONG MyRegSaveKey(HKEY hKey, LPCSTR lpszFile, LPSECURITY_ATTRIBUTES lpsa)
{
#ifdef DEBUG
	if (fNoisyReg) {
		char buf[300];
		::wsprintf(buf, "MyRegSaveKey(\"%s\")\r\n", lpszFile);
		::OutputDebugString(buf);
	}
#endif

	/* Since the registry doesn't support long filenames, get the short
	 * alias for the path.  If that succeeds, we use that path, otherwise
	 * we just use the original one and hope it works.
	 *
	 * GetShortPathName only works if the file exists, so we have to
	 * create a dummy copy first.
	 */

	HANDLE hTemp = ::CreateFile(lpszFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
								FILE_ATTRIBUTE_NORMAL, NULL);
	if (hTemp == INVALID_HANDLE_VALUE)
		return ::GetLastError();
	::CloseHandle(hTemp);

	CHAR szShortPath[MAX_PATH+1];
	if (::GetShortPathName(lpszFile, szShortPath, sizeof(szShortPath)))
		lpszFile = szShortPath;

	return ::RegSaveKey(hKey, lpszFile, lpsa);
}

#ifndef DEBUG
#define MyRegUnLoadKey	RegUnLoadKey
#endif

LONG OpenLogonKey(HKEY *phKey)
{
	return ::RegOpenKey(HKEY_LOCAL_MACHINE, szLogonKey, phKey);
}


void AddBackslash(LPSTR lpPath)
{
	LPCSTR lpBackslash = ::strrchrf(lpPath, '\\');
	if (lpBackslash == NULL || *(lpBackslash+1) != '\0')
		::strcatf(lpPath, "\\");
}


void AddBackslash(NLS_STR& nlsPath)
{
	ISTR istrBackslash(nlsPath);
	if (!nlsPath.strrchr(&istrBackslash, '\\') ||
		*nlsPath.QueryPch(++istrBackslash) != '\0')
		nlsPath += '\\';
}


void GetDirFromPath(NLS_STR& nlsTempDir, LPCSTR pszPath)
{
	nlsTempDir = pszPath;

	ISTR istrBackslash(nlsTempDir);
	if (nlsTempDir.strrchr(&istrBackslash, '\\'))
		nlsTempDir.DelSubStr(istrBackslash);
}


BOOL FileExists(LPCSTR pszPath)
{
	DWORD dwAttrs = ::GetFileAttributes(pszPath);

	if (dwAttrs != 0xffffffff && !(dwAttrs & FILE_ATTRIBUTE_DIRECTORY))
		return TRUE;
	else
		return FALSE;
}


BOOL DirExists(LPCSTR pszPath)
{
	if (*pszPath == '\0')
		return FALSE;

	DWORD dwAttrs = ::GetFileAttributes(pszPath);

	if (dwAttrs != 0xffffffff && (dwAttrs & FILE_ATTRIBUTE_DIRECTORY))
		return TRUE;
	else
		return FALSE;
}


/* CreateDirectoryPath attempts to create the specified directory;  if the
 * create attempt fails, it tries to create each element of the path in case
 * any intermediate directories also don't exist.
 */
BOOL CreateDirectoryPath(LPCSTR pszPath)
{
    BOOL fRet = ::CreateDirectory(pszPath, NULL);

    if (fRet || (::GetLastError() != ERROR_PATH_NOT_FOUND))
        return fRet;

    NLS_STR nlsTemp(pszPath);
    if (nlsTemp.QueryError() != ERROR_SUCCESS)
        return FALSE;

    LPSTR pszTemp = nlsTemp.Party();
    LPSTR pszNext = pszTemp;

    /* If it's a drive-based path (which it should be), skip the drive
     * and first backslash -- we don't need to attempt to create the
     * root directory.
     */
    if (::strchrf(pszTemp, ':') != NULL) {
        pszNext = ::strchrf(pszTemp, '\\');
        if (pszNext != NULL)
            pszNext++;
    }

    /* Now walk through the path creating one directory at a time. */

    for (;;) {
        pszNext = ::strchrf(pszNext, '\\');
        if (pszNext != NULL) {
            *pszNext = '\0';
        }
        else {
            break;          /* no more intermediate directories to create */
        }

        /* Create the intermediate directory.  No error checking because we're
         * not extremely performance-critical, and we can get errors if the
         * directory already exists, etc.  With security and other things,
         * the set of benign error codes we'd have to check for could be
         * large.
         */
        fRet = ::CreateDirectory(pszTemp, NULL);

        *pszNext = '\\';
        pszNext++;
        if (!*pszNext)      /* ended with trailing slash? */
            return fRet;    /* return last result */
    }

    /* We should have created all the intermediate directories by now.
     * Create the final path.
     */

    return ::CreateDirectory(pszPath, NULL);
}


UINT SafeCopy(LPCSTR pszSrc, LPCSTR pszDest, DWORD dwAttrs)
{
	NLS_STR nlsTempDir(MAX_PATH);
	NLS_STR nlsTempFile(MAX_PATH);
	if (!nlsTempDir || !nlsTempFile)
		return ERROR_NOT_ENOUGH_MEMORY;

	GetDirFromPath(nlsTempDir, pszDest);

	if (!::GetTempFileName(nlsTempDir.QueryPch(), ::szProfilePrefix, 0,
						   nlsTempFile.Party()))
		return ::GetLastError();

	nlsTempFile.DonePartying();

	if (!::CopyFile(pszSrc, nlsTempFile.QueryPch(), FALSE)) {
		UINT err = ::GetLastError();
		::DeleteFile(nlsTempFile.QueryPch());
		return err;
	}

	::SetFileAttributes(pszDest, FILE_ATTRIBUTE_NORMAL);

	::DeleteFile(pszDest);

	// At this point, the temp file has the same attributes as the original
	// (usually read-only, hidden, system).  Some servers, such as NetWare
	// servers, won't allow us to rename a read-only file.  So we have to
	// take the attributes off, rename the file, then put back whatever the
	// caller wants.
	::SetFileAttributes(nlsTempFile.QueryPch(), FILE_ATTRIBUTE_NORMAL);

	if (!::MoveFile(nlsTempFile.QueryPch(), pszDest))
		return ::GetLastError();

	::SetFileAttributes(pszDest, dwAttrs);

	return ERROR_SUCCESS;
}


#ifdef LOAD_PROFILES

void SetProfileTime(LPCSTR pszLocalPath, LPCSTR pszCentralPath)
{
	HANDLE hFile = ::CreateFile(pszCentralPath,
								GENERIC_READ | GENERIC_WRITE,
								FILE_SHARE_READ, NULL,
								OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE) {
		FILETIME ft;

		::GetFileTime(hFile, NULL, NULL, &ft);
		::CloseHandle(hFile);

		DWORD dwAttrs = ::GetFileAttributes(pszLocalPath);
		if (dwAttrs & FILE_ATTRIBUTE_READONLY) {
			::SetFileAttributes(pszLocalPath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);
		}
		hFile = ::CreateFile(pszLocalPath, GENERIC_READ | GENERIC_WRITE,
							 FILE_SHARE_READ, NULL, OPEN_EXISTING,
							 FILE_ATTRIBUTE_NORMAL, NULL);
		if (hFile != INVALID_HANDLE_VALUE) {
			::SetFileTime(hFile, NULL, NULL, &ft);
			::CloseHandle(hFile);
		}
		if (dwAttrs & FILE_ATTRIBUTE_READONLY) {
			::SetFileAttributes(pszLocalPath, dwAttrs & ~FILE_ATTRIBUTE_READONLY);
		}
	}
}


UINT DefaultReconcile(LPCSTR pszCentralPath, LPCSTR pszLocalPath, DWORD dwFlags)
{
	UINT err;

	if (dwFlags & RP_LOGON) {
		if (dwFlags & RP_INIFILE)
			return SafeCopy(pszCentralPath, pszLocalPath, FILE_ATTRIBUTE_NORMAL);

		HANDLE hFile = ::CreateFile(pszCentralPath, GENERIC_READ, FILE_SHARE_READ,
									NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		FILETIME ftCentral;
		if (hFile != INVALID_HANDLE_VALUE) {
			::GetFileTime(hFile, NULL, NULL, &ftCentral);
			::CloseHandle(hFile);
		}
		else {
			ftCentral.dwLowDateTime = 0;	/* can't open, pretend it's really old */
			ftCentral.dwHighDateTime = 0;
		}

		hFile = ::CreateFile(pszLocalPath, GENERIC_READ, FILE_SHARE_READ,
							 NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		FILETIME ftLocal;
		if (hFile != INVALID_HANDLE_VALUE) {
			::GetFileTime(hFile, NULL, NULL, &ftLocal);
			::CloseHandle(hFile);
		}
		else {
			ftLocal.dwLowDateTime = 0;	/* can't open, pretend it's really old */
			ftLocal.dwHighDateTime = 0;
		}

		LPCSTR pszSrc, pszDest;

		/*
		 * Find out which file is newer, and make that the source
		 * for the copy.
		 */

		LONG lCompare = ::CompareFileTime(&ftCentral, &ftLocal);
		if (!lCompare) {
			::dwProfileFlags |= PROF_CENTRALWINS;
			return WN_SUCCESS;		/* timestamps match, no copy to do */
		}
		else if (lCompare > 0) {
			pszSrc = pszCentralPath;
			pszDest = pszLocalPath;
			::dwProfileFlags |= PROF_CENTRALWINS;
		}
		else {
			pszSrc = pszLocalPath;
			pszDest = pszCentralPath;
			::dwProfileFlags &= ~PROF_CENTRALWINS;
		}

		err = SafeCopy(pszSrc, pszDest,
					   pszDest == pszCentralPath ? FILE_ATTRIBUTE_NORMAL
					   : attrLocalProfile);
	}
	else {
		err = SafeCopy(pszLocalPath, pszCentralPath, FILE_ATTRIBUTE_NORMAL);
		if (err == WN_SUCCESS) {	/* copied back successfully */

#ifdef EXTENDED_PROFILES	/* chicago doesn't special-case resident profiles */
			if (dwFlags & PROF_RESIDENT) {
				DeleteProfile(pszLocalPath);	/* delete temp file */
			}
#endif

			SetProfileTime(pszLocalPath, pszCentralPath);
		}
	}

	return err;
}


#endif	/* LOAD_PROFILES */


void GetLocalProfileDirectory(NLS_STR& nlsPath)
{
	::GetWindowsDirectory(nlsPath.Party(), nlsPath.QueryAllocSize());
	nlsPath.DonePartying();

	AddBackslash(nlsPath);

	nlsPath.strcat(::szProfilesDirectory);

	::CreateDirectory(nlsPath.QueryPch(), NULL);
}


HRESULT GiveUserDefaultProfile(LPCSTR lpszPath)
{
	HKEY hkeyDefaultUser;
	LONG err = ::RegOpenKey(HKEY_USERS, ::szDefaultUserName, &hkeyDefaultUser);
	if (err == ERROR_SUCCESS) {
		err = ::MyRegSaveKey(hkeyDefaultUser, lpszPath, NULL);
		::RegCloseKey(hkeyDefaultUser);
	}
	return HRESULT_FROM_WIN32(err);
}


void ComputeLocalProfileName(LPCSTR pszUsername, NLS_STR *pnlsLocalProfile)
{
	GetLocalProfileDirectory(*pnlsLocalProfile);

	UINT cbPath = pnlsLocalProfile->strlen();
	LPSTR lpPath = pnlsLocalProfile->Party();
	LPSTR lpFilename = lpPath + cbPath;

	*(lpFilename++) = '\\';
	::strcpyf(lpFilename, pszUsername);		/* start with whole username */

	LPSTR lpFNStart = lpFilename;

	UINT iFile = 0;
	while (!::CreateDirectory(lpPath, NULL)) {
		if (!DirExists(lpPath))
			break;

		/* Couldn't use whole username, start with 5 bytes of username + numbers. */
		if (iFile == 0) {
			::strncpyf(lpFilename, pszUsername, 5);	/* copy at most 5 bytes of username */
			*(lpFilename+5) = '\0';					/* force null term, just in case */
			lpFilename += ::strlenf(lpFilename);
		}
		else if (iFile >= 4095) {	/* max number expressible in 3 hex digits */
			lpFilename = lpFNStart;	/* start using big numbers with no uname prefix */
			if ((int)iFile < 0)	/* if we run out of numbers, abort */
				break;
		}

		::wsprintf(lpFilename, "%03lx", iFile);

		iFile++;
	}

	pnlsLocalProfile->DonePartying();
}


HRESULT CopyProfile(LPCSTR pszSrcPath, LPCSTR pszDestPath)
{
	UINT err = SafeCopy(pszSrcPath, pszDestPath, attrLocalProfile);

	return HRESULT_FROM_WIN32(err);
}


BOOL UseUserProfiles(void)
{
	HKEY hkeyLogon;

	LONG err = OpenLogonKey(&hkeyLogon);
	if (err == ERROR_SUCCESS) {
		DWORD fUseProfiles = 0;
		DWORD cbData = sizeof(fUseProfiles);
		err = ::RegQueryValueEx(hkeyLogon, (LPSTR)::szUseProfiles, NULL, NULL,
								(LPBYTE)&fUseProfiles, &cbData);
		::RegCloseKey(hkeyLogon);
		return (err == ERROR_SUCCESS) && fUseProfiles;
	}

	return FALSE;
}


void EnableProfiles(void)
{
	HKEY hkeyLogon;

	LONG err = OpenLogonKey(&hkeyLogon);
	if (err == ERROR_SUCCESS) {
		DWORD fUseProfiles = 1;
		::RegSetValueEx(hkeyLogon, (LPSTR)::szUseProfiles, 0, REG_DWORD,
						(LPBYTE)&fUseProfiles, sizeof(fUseProfiles));
		::RegCloseKey(hkeyLogon);
	}
}


struct SYNCSTATE
{
    HKEY hkeyProfile;
    NLS_STR *pnlsProfilePath;
    NLS_STR *pnlsOtherProfilePath;
    HKEY hkeyPrimary;
};


/*
 * PrefixMatch determines whether a given path is equal to or a descendant
 * of a given base path.
 */
BOOL PrefixMatch(LPCSTR pszPath, LPCSTR pszBasePath)
{
	UINT cchBasePath = ::strlenf(pszBasePath);
	if (!::strnicmpf(pszPath, pszBasePath, cchBasePath)) {
		/* make sure that the base path matches the whole last component */
		if ((pszPath[cchBasePath] == '\\' || pszPath[cchBasePath] == '\0'))
			return TRUE;
		/* check to see if the base path is a root path;  if so, match */
		LPCSTR pszBackslash = ::strrchrf(pszBasePath, '\\');
		if (pszBackslash != NULL && *(pszBackslash+1) == '\0')
			return TRUE;
		else
			return FALSE;
	}
	else
		return FALSE;
}


#if 0
void ReportReconcileError(SYNCSTATE *pSyncState, TWINRESULT tr, PRECITEM pri,
						  PRECNODE prnSrc, PRECNODE prnDest, BOOL fSrcCentral)
{
	/* If we're copying the file the "wrong" way, swap our idea of the
	 * source and destination.  For the purposes of other profile code,
	 * source and destination refer to the entire profile copy direction.
	 * For this particular error message, they refer to the direction
	 * that this particular file was being copied.
	 */
	if (prnSrc->rnaction == RNA_COPY_TO_ME) {
		PRECNODE prnTemp = prnSrc;
		prnSrc = prnDest;
		prnDest = prnTemp;
		fSrcCentral = !fSrcCentral;
	}

	/* Set the error status on this key to be the destination of the copy,
	 * which is the copy that's now out of date because of the error and
	 * needs to be guarded from harm next time.
	 */
	pSyncState->uiRecError |= fSrcCentral ? RECERROR_LOCAL : RECERROR_CENTRAL;

	pSyncState->dwFlags |= SYNCSTATE_ERROR;

	if (pSyncState->dwFlags & SYNCSTATE_ERRORMSG)
		return;			/* error already reported */

	pSyncState->dwFlags |= SYNCSTATE_ERRORMSG;

	RegEntry re(::szReconcileRoot, pSyncState->hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS && !re.GetNumber(::szDisplayProfileErrors, TRUE))
		return;		/* user doesn't want to see this error message */

	PCSTR pszFile;
	UINT uiMainMsg;

	switch (tr) {
	case TR_DEST_OPEN_FAILED:
	case TR_DEST_WRITE_FAILED:
		uiMainMsg = IERR_ProfRecWriteDest;
		pszFile = prnDest->pcszFolder;
		break;
	case TR_SRC_OPEN_FAILED:
	case TR_SRC_READ_FAILED:
		uiMainMsg = IERR_ProfRecOpenSrc;
		pszFile = prnSrc->pcszFolder;
		break;
	default:
		uiMainMsg = IERR_ProfRecCopy;
		pszFile = pri->pcszName;
		break;
	}

	if (DisplayGenericError(NULL, uiMainMsg, tr, pszFile, ::szNULL,
							MB_YESNO | MB_ICONEXCLAMATION, IDS_TRMsgBase) == IDNO) {
		re.SetValue(::szDisplayProfileErrors, (ULONG)FALSE);
	}
}


#ifdef DEBUG
char szOutbuf[200];
#endif


/*
 * MyReconcile is a wrapper around ReconcileItem.  It needs to detect merge
 * type operations and transform them into copies in the appropriate direction,
 * and recognize when the sync engine wants to replace a file that the user
 * really wants deleted.
 */
void MyReconcile(PRECITEM pri, SYNCSTATE *pSyncState)
{
	if (pri->riaction == RIA_NOTHING)
		return;

	/* Because we don't have a persistent briefcase, we can't recognize when
	 * the user has deleted an item;  the briefcase will want to replace it
	 * with the other version, which is not what the user wants.  So we use
	 * the direction of the profile's copy, and if the sync engine wants to
	 * copy a file from the "destination" of the profile's copy to the "source"
	 * because the "source" doesn't exist, we recognize that as the source
	 * having been deleted and synchronize manually by deleting the dest.
	 *
	 * prnSrc points to the recnode for the item that's coming from the same
	 * side of the transaction that the more recent profile was on;  prnDest
	 * points to the recnode for the other side.
	 *
	 * The test is complicated because we first have to figure out which of
	 * the two directories (nlsDir1, the local dir; or nlsDir2, the central
	 * dir) is the source and which the destination.  Then we have to figure
	 * out which of the two RECNODEs we got matches which directory.
	 */
	PRECNODE prnSrc;
	PRECNODE prnDest;
	LPCSTR pszSrcBasePath;
	BOOL fSrcCentral;
	if (pSyncState->IsMandatory() || (pSyncState->dwFlags & PROF_CENTRALWINS)) {
		pszSrcBasePath = pSyncState->nlsDir2.QueryPch();
		fSrcCentral = TRUE;
	}
	else {
		pszSrcBasePath = pSyncState->nlsDir1.QueryPch();
		fSrcCentral = FALSE;
	}

	if (PrefixMatch(pri->prnFirst->pcszFolder, pszSrcBasePath)) {
		prnSrc = pri->prnFirst;
		prnDest = prnSrc->prnNext;
	}
	else {
		prnDest = pri->prnFirst;
		prnSrc = prnDest->prnNext;
	}

	/*
	 * If files of the same name exist in both places, the sync engine thinks
     * they need to be merged (since we have no persistent briefcase database,
     * it doesn't know that they were originally the same).  The sync engine
     * sets the file stamp of a copied destination file to the file stamp of
     * the source file after copying.  If the file stamps of two files to be
     * merged are the same, we assume that the files are already up-to-date,
     * and we take no reconciliation action.  If the file stamps of two files
     * to be merged are different, we really just want a copy, so we figure out
     * which one is supposed to be definitive and transform the RECITEM and
     * RECNODEs to indicate a copy instead of a merge.
	 *
	 * The definitive copy is the source for mandatory or logoff cases,
	 * otherwise it's the newer file.
	 */
	if (pri->riaction == RIA_MERGE || pri->riaction == RIA_BROKEN_MERGE) {
		BOOL fCopyFromSrc;
        COMPARISONRESULT cr;

		if (pSyncState->IsMandatory())
			fCopyFromSrc = TRUE;
        else {
	        fCopyFromSrc = ! pSyncState->IsLogon();  

            if (pSyncState->CompareFileStamps(&prnSrc->fsCurrent, &prnDest->fsCurrent, &cr) == TR_SUCCESS) {
                if (cr == CR_EQUAL) {
#ifdef MAXDEBUG
			       ::OutputDebugString("Matching file stamps, no action taken\r\n");  
#endif
                   return;
                }
                else if (cr==CR_FIRST_LARGER)       
			       fCopyFromSrc = TRUE;
            }
        }

#ifdef MAXDEBUG
		if (fCopyFromSrc)
			::OutputDebugString("Broken merge, copying from src\r\n");
		else
			::OutputDebugString("Broken merge, copying from dest\r\n");
#endif

		prnSrc->rnaction = fCopyFromSrc ? RNA_COPY_FROM_ME : RNA_COPY_TO_ME;
		prnDest->rnaction = fCopyFromSrc ? RNA_COPY_TO_ME : RNA_COPY_FROM_ME;
		pri->riaction = RIA_COPY;
	}

	/*
	 * If the preferred source file doesn't exist, the sync engine is trying
	 * to create a file to make the two trees the same, when the user/admin
	 * really wanted to delete it (the sync engine doesn't like deleting
	 * files).  So we detect that case here and delete the "destination"
	 * to make the two trees match that way.
	 *
	 * If the last reconciliation had an error, we don't do the deletion
	 * if the site of the error is the current source (i.e., if we're
	 * about to delete the file we couldn't copy before).  Instead we'll
	 * try the operation that the sync engine wants, since that'll be the
	 * copy that failed before.
	 */
	if (prnSrc->rnstate == RNS_DOES_NOT_EXIST &&
		prnSrc->rnaction == RNA_COPY_TO_ME &&
		!((pSyncState->uiRecError & RECERROR_CENTRAL) && fSrcCentral) &&
		!((pSyncState->uiRecError & RECERROR_LOCAL) && !fSrcCentral)) {
		if (IS_EMPTY_STRING(pri->pcszName)) {
			::RemoveDirectory(prnDest->pcszFolder);
		}
		else {
			NLS_STR nlsTemp(prnDest->pcszFolder);
			AddBackslash(nlsTemp);
			nlsTemp.strcat(pri->pcszName);
			if (!nlsTemp.QueryError()) {
#ifdef MAXDEBUG
				if (pSyncState->IsMandatory())
					::OutputDebugString("Mandatory copy wrong way\r\n");

				wsprintf(::szOutbuf, "Deleting 'destination' file %s\r\n", nlsTemp.QueryPch());
				::OutputDebugString(::szOutbuf);
#endif
				::DeleteFile(nlsTemp.QueryPch());
			}
		}
		return;
	}

#ifdef MAXDEBUG
	::OutputDebugString("Calling ReconcileItem.\r\n");
#endif

	TWINRESULT tr;
	if ((tr=pSyncState->ReconcileItem(pri, NULL, 0, 0, NULL, NULL)) != TR_SUCCESS) {
		ReportReconcileError(pSyncState, tr, pri, prnSrc, prnDest, fSrcCentral);
#ifdef MAXDEBUG
		::wsprintf(::szOutbuf, "Error %d from ReconcileItem.\r\n", tr);
		::OutputDebugString(::szOutbuf);
#endif
	}
	else if (!IS_EMPTY_STRING(pri->pcszName))
		pSyncState->dwFlags |= SYNCSTATE_SOMESUCCESS;
}


/*
 * MakePathAbsolute examines a path to see whether it is absolute or relative.
 * If it is relative, it is prepended with the given base path.
 *
 * If the fMustBeRelative parameter is TRUE, then an error is returned if the
 * path was (a) absolute and (b) not a subdirectory of the old profile directory.
 */
BOOL MakePathAbsolute(NLS_STR& nlsDir, LPCSTR lpszBasePath,
					  NLS_STR& nlsOldProfileDir, BOOL fMustBeRelative)
{
	/* If the path starts with a special keyword, replace it. */

	if (*nlsDir.QueryPch() == '*') {
		return ReplaceCommonPath(nlsDir);
	}

	/* If the path is absolute and is relative to whatever the old profile
	 * directory was, transform it to a relative path.  We will then make
	 * it absolute again, using the new base path.
	 */
	if (PrefixMatch(nlsDir, nlsOldProfileDir)) {
		UINT cchDir = nlsDir.strlen();
		LPSTR lpStart = nlsDir.Party();
		::memmovef(lpStart, lpStart + nlsOldProfileDir.strlen(), cchDir - nlsOldProfileDir.strlen() + 1);
		nlsDir.DonePartying();
	}
	else if (::strchrf(nlsDir.QueryPch(), ':') != NULL || *nlsDir.QueryPch() == '\\')
		return !fMustBeRelative;

	if (*lpszBasePath == '\0') {
		nlsDir = lpszBasePath;
		return TRUE;
	}

	NLS_STR nlsBasePath(lpszBasePath);
	if (nlsBasePath.QueryError())
		return FALSE;
	AddBackslash(nlsBasePath);

	ISTR istrStart(nlsDir);
	nlsDir.InsertStr(nlsBasePath, istrStart);
	return !nlsDir.QueryError();
}
#endif  /**** 0 ****/


/*
 * ReplaceCommonPath takes a relative path beginning with a special keyword
 * and replaces the keyword with the corresponding real path.  Currently the
 * keyword supported is:
 *
 * *windir - replaced with the Windows (user) directory
 */
BOOL ReplaceCommonPath(NLS_STR& nlsDir)
{
	NLS_STR *pnlsTemp;
	ISTR istrStart(nlsDir);
	ISTR istrEnd(nlsDir);

	nlsDir.strchr(&istrEnd, '\\');
	pnlsTemp = nlsDir.QuerySubStr(istrStart, istrEnd);
	if (pnlsTemp == NULL)
		return FALSE;				/* out of memory, can't do anything */

	BOOL fSuccess = TRUE;
	if (!::stricmpf(pnlsTemp->QueryPch(), ::szWindirAlias)) {
		UINT cbBuffer = pnlsTemp->QueryAllocSize();
		LPSTR lpBuffer = pnlsTemp->Party();
		UINT cchWindir = ::GetWindowsDirectory(lpBuffer, cbBuffer);
		if (cchWindir >= cbBuffer)
			*lpBuffer = '\0';
		pnlsTemp->DonePartying();
		if (cchWindir >= cbBuffer) {
			pnlsTemp->realloc(cchWindir+1);
			if (!pnlsTemp->QueryError()) {
				::GetWindowsDirectory(pnlsTemp->Party(), cchWindir+1);
				pnlsTemp->DonePartying();
			}
			else
				fSuccess = FALSE;
		}
		if (fSuccess) {
			nlsDir.ReplSubStr(*pnlsTemp, istrStart, istrEnd);
			fSuccess = !nlsDir.QueryError();
		}
	}
	delete pnlsTemp;
	return fSuccess;
}


/*
 * GetSetRegistryPath goes to the registry key and value specified by
 * the current reconciliations's RegKey and RegValue settings, and
 * retrieves or sets a path there.
 */
void GetSetRegistryPath(HKEY hkeyProfile, RegEntry& re, NLS_STR *pnlsPath, BOOL fSet)
{
	NLS_STR nlsKey;

	re.GetValue(::szReconcileRegKey, &nlsKey);
	if (nlsKey.strlen() > 0) {
		NLS_STR nlsValue;
		re.GetValue(::szReconcileRegValue, &nlsValue);
		RegEntry re2(nlsKey, hkeyProfile);
		if (fSet) {
			re2.SetValue(nlsValue, pnlsPath->QueryPch());
            if (!nlsKey.stricmp("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders")) {
                nlsKey = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";
                RegEntry reShell(nlsKey, hkeyProfile);
                reShell.SetValue(nlsValue, pnlsPath->QueryPch());
            }
        }
		else
			re2.GetValue(nlsValue, pnlsPath);
	}
}


/* CopyFolder calls the shell's copy engine to copy files.  The source is a
 * double-null-terminated list;  the destination is a folder.
 */
void CopyFolder(LPBYTE pbSource, LPCSTR pszDest)
{
    CHAR szDest[MAX_PATH];

    ::strcpyf(szDest, pszDest);
    szDest[::strlenf(szDest) + 1] = '\0';

    SHFILEOPSTRUCT fos;

    fos.hwnd = NULL;
    fos.wFunc = FO_COPY;
    fos.pFrom = (LPCSTR)pbSource;
    fos.pTo = szDest;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    g_pfnSHFileOperationA(&fos);
}


/*
 * ReconcileKey performs reconciliation for a particular key in the
 * ProfileReconciliation branch of the registry.  It reads the config
 * parameters for the reconciliation, sets up an appropriate twin in
 * the temporary briefcase, and performs the reconciliation.
 */
BOOL ReconcileKey(HKEY hkeySection, LPCSTR lpszSubKey, SYNCSTATE *pSyncState)
{
#ifdef DEBUG
	DWORD dwStart = ::GetTickCount();
#endif

	BOOL fShouldDelete = FALSE;

	RegEntry re(lpszSubKey, hkeySection);
	if (re.GetError() == ERROR_SUCCESS) {
        BUFFER bufSrcStrings(MAX_PATH);
        NLS_STR nlsSrcPath(MAX_PATH);
        NLS_STR nlsDestPath(MAX_PATH);
        NLS_STR nlsName(MAX_PATH);
        if (bufSrcStrings.QueryPtr() != NULL &&
            nlsSrcPath.QueryError() == ERROR_SUCCESS &&
            nlsDestPath.QueryError() == ERROR_SUCCESS &&
            nlsName.QueryError() == ERROR_SUCCESS) {

            /* Get the source path to copy.  Usually it's in the profile,
             * left over from the profile we cloned.  If not, we take the
             * default local name from the ProfileReconciliation key.  If
             * the path already in the registry is not relative to the cloned
             * profile directory, then it's probably set by system policies
             * or something, and we shouldn't touch it.
             */
            if (pSyncState->pnlsOtherProfilePath != NULL) {
        		GetSetRegistryPath(pSyncState->hkeyProfile, re, &nlsSrcPath, FALSE);
                if (nlsSrcPath.strlen() && 
                    !PrefixMatch(nlsSrcPath.QueryPch(), pSyncState->pnlsOtherProfilePath->QueryPch())) {
                    return FALSE;   /* not profile-relative, nothing to do */
                }
            }
            if (!nlsSrcPath.strlen()) {
				re.GetValue(::szDefaultDir, &nlsSrcPath);
            	if (*nlsSrcPath.QueryPch() == '*') {
            		ReplaceCommonPath(nlsSrcPath);
            	}
            }

            /* Get the set of files to copy.  Like NT and unlike win95, we
             * want to clone the entire contents, not necessarily just the
             * files listed (for example, the desktop -- we want all the
             * files and subfolders, not just links).  So, unless the string
             * is empty, which means don't copy any content, just set the reg
             * path, we change any pattern containing wildcards to *.*.
             */
            re.GetValue(::szReconcileName, &nlsName);
            if (nlsName.strlen()) {
                if (::strchrf(nlsName.QueryPch(), '*') != NULL ||
                    ::strchrf(nlsName.QueryPch(), '?') != NULL) {
                    nlsName = "*.*";
                }
            }

            /* Get the destination path.  This is generated from the new
             * profile directory and the LocalFile entry in the registry.
             *
             * Should always do this, even if we're not going to call the
             * copy engine, because we're going to write this path out to
             * the registry.
             */
            re.GetValue(::szLocalFile, &nlsDestPath);
            ISTR istr(nlsDestPath);
            nlsDestPath.InsertStr(*(pSyncState->pnlsProfilePath), istr);

            /* Always create the destination path, even if we don't copy
             * any files into it because the source directory doesn't exist.
             */
            CreateDirectoryPath(nlsDestPath.QueryPch());

            /* Make sure the source directory exists so we won't get useless
             * error messages from the shell copy engine.
             */
            DWORD dwAttr = GetFileAttributes(nlsSrcPath.QueryPch());
            if (dwAttr != 0xffffffff && (dwAttr & FILE_ATTRIBUTE_DIRECTORY) &&
                nlsName.strlen()) {

                AddBackslash(nlsSrcPath);

                /* Build up the double-null-terminated list of file specs to copy. */

                UINT cbUsed = 0;

		    	LPSTR lpName = nlsName.Party();
			    do {
				    LPSTR lpNext = ::strchrf(lpName, ',');
    				if (lpNext != NULL) {
	    				*(lpNext++) = '\0';
		    		}

                    UINT cbNeeded = nlsSrcPath.strlen() + ::strlenf(lpName) + 1;
                    if (bufSrcStrings.QuerySize() - cbUsed < cbNeeded) {
                        if (!bufSrcStrings.Resize(bufSrcStrings.QuerySize() + MAX_PATH))
                            return FALSE;
                    }
                    LPSTR lpDest = ((LPSTR)bufSrcStrings.QueryPtr()) + cbUsed;
                    ::strcpyf(lpDest, nlsSrcPath.QueryPch());
                    lpDest += nlsSrcPath.strlen();
                    ::strcpyf(lpDest, lpName);
                    cbUsed += cbNeeded;

    				lpName = lpNext;
	    		} while (lpName != NULL);

                *((LPSTR)bufSrcStrings.QueryPtr() + cbUsed) = '\0';    /* double null terminate */
	    		nlsName.DonePartying();

                CopyFolder((LPBYTE)bufSrcStrings.QueryPtr(), nlsDestPath.QueryPch());
            }

    		/*
		     * Set a registry key to point to the new local path to this directory.
	    	 */
    		GetSetRegistryPath(pSyncState->hkeyProfile, re, &nlsDestPath, TRUE);
		}
    }

#ifdef MAXDEBUG
	::wsprintf(::szOutbuf, "ReconcileKey duration %d ms.\r\n", ::GetTickCount() - dwStart);
	::OutputDebugString(::szOutbuf);
#endif

	return fShouldDelete;
}


/*
 * GetMaxSubkeyLength just calls RegQueryInfoKey to get the length of the
 * longest named subkey of the given key.  The return value is the size
 * of buffer needed to hold the longest key name, including the null
 * terminator.
 */
DWORD GetMaxSubkeyLength(HKEY hKey)
{
	DWORD cchClass = 0;
	DWORD cSubKeys;
	DWORD cchMaxSubkey;
	DWORD cchMaxClass;
	DWORD cValues;
	DWORD cchMaxValueName;
	DWORD cbMaxValueData;
	DWORD cbSecurityDescriptor;
	FILETIME ftLastWriteTime;

	RegQueryInfoKey(hKey, NULL, &cchClass, NULL, &cSubKeys, &cchMaxSubkey,
					&cchMaxClass, &cValues, &cchMaxValueName, &cbMaxValueData,
					&cbSecurityDescriptor, &ftLastWriteTime);
	return cchMaxSubkey + 1;
}


/*
 * ReconcileSection walks through the ProfileReconciliation key and performs
 * reconciliation for each subkey.  One-time keys are deleted after they are
 * processed.
 */
void ReconcileSection(HKEY hkeyRoot, SYNCSTATE *pSyncState)
{
	NLS_STR nlsKeyName(GetMaxSubkeyLength(hkeyRoot));
	if (!nlsKeyName.QueryError()) {
		DWORD iKey = 0;

		for (;;) {
			DWORD cchKey = nlsKeyName.QueryAllocSize();

			UINT err = ::RegEnumKey(hkeyRoot, iKey, nlsKeyName.Party(), cchKey);
			if (err != ERROR_SUCCESS)
				break;

			nlsKeyName.DonePartying();
			if (ReconcileKey(hkeyRoot, nlsKeyName, pSyncState)) {
				::RegDeleteKey(hkeyRoot, nlsKeyName.QueryPch());
			}
			else
				iKey++;
		}
	}
}


/*
 * ReconcileFiles is called just after the user's profile and policies are
 * loaded at logon, and just before the profile is unloaded at logoff.  It
 * performs all file type reconciliation for the user's profile, excluding
 * the profile itself, of course.
 *
 * nlsOtherProfilePath is the path to the profile which is being cloned,
 * or an empty string if the default profile is being cloned.
 */
HRESULT ReconcileFiles(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                    NLS_STR& nlsOtherProfilePath)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

    if (nlsOtherProfilePath.strlen())
    {
    	ISTR istrBackslash(nlsOtherProfilePath);
	    if (nlsOtherProfilePath.strrchr(&istrBackslash, '\\')) {
            ++istrBackslash;
		    nlsOtherProfilePath.DelSubStr(istrBackslash);
        }
    }

	RegEntry re(::szReconcileRoot, hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS) {
        SYNCSTATE s;
        s.hkeyProfile = hkeyProfile;
        s.pnlsProfilePath = &nlsProfilePath;
        s.pnlsOtherProfilePath = (nlsOtherProfilePath.strlen() != 0) ? &nlsOtherProfilePath : NULL;
        s.hkeyPrimary = NULL;

		RegEntry rePrimary(::szReconcilePrimary, re.GetKey());
		RegEntry reSecondary(::szReconcileSecondary, re.GetKey());
		if (rePrimary.GetError() == ERROR_SUCCESS) {
			ReconcileSection(rePrimary.GetKey(), &s);

			if (reSecondary.GetError() == ERROR_SUCCESS) {
                s.hkeyPrimary = rePrimary.GetKey();
				ReconcileSection(reSecondary.GetKey(), &s);
			}
		}
	}

	return ERROR_SUCCESS;
}


HRESULT DefaultReconcileKey(HKEY hkeyProfile, NLS_STR& nlsProfilePath,
                            LPCSTR pszKeyName, BOOL fSecondary)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

	RegEntry re(::szReconcileRoot, hkeyProfile);
	if (re.GetError() == ERROR_SUCCESS) {
        SYNCSTATE s;
        s.hkeyProfile = hkeyProfile;
        s.pnlsProfilePath = &nlsProfilePath;
        s.pnlsOtherProfilePath = NULL;
        s.hkeyPrimary = NULL;

		RegEntry rePrimary(::szReconcilePrimary, re.GetKey());
		if (rePrimary.GetError() == ERROR_SUCCESS) {
            if (fSecondary) {
        		RegEntry reSecondary(::szReconcileSecondary, re.GetKey());
                s.hkeyPrimary = rePrimary.GetKey();
    			ReconcileKey(reSecondary.GetKey(), pszKeyName, &s);
            }
            else
    			ReconcileKey(rePrimary.GetKey(), pszKeyName, &s);
		}
	}

	return ERROR_SUCCESS;
}


HRESULT DeleteProfileFiles(LPCSTR pszPath)
{
    HRESULT hres = LoadShellEntrypoint();
    if (FAILED(hres))
        return hres;

    SHFILEOPSTRUCT fos;
    TCHAR szFrom[MAX_PATH];

    lstrcpy(szFrom, pszPath);

    /* Before we build the complete source filespec, check to see if the
     * directory exists.  In the case of lesser-used folders such as
     * "Application Data", the default may not have ever been created.
     * In that case, we have no contents to copy.
     */
    DWORD dwAttr = GetFileAttributes(szFrom);
    if (dwAttr == 0xffffffff || !(dwAttr & FILE_ATTRIBUTE_DIRECTORY))
        return S_OK;

    AddBackslash(szFrom);
    lstrcat(szFrom, TEXT("*.*"));
    szFrom[lstrlen(szFrom)+1] = '\0';   /* double null terminate from string */

    fos.hwnd = NULL;
    fos.wFunc = FO_DELETE;
    fos.pFrom = szFrom;
    fos.pTo = NULL;
    fos.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOERRORUI;
    fos.fAnyOperationsAborted = FALSE;
    fos.hNameMappings = NULL;
    fos.lpszProgressTitle = NULL;

    g_pfnSHFileOperationA(&fos);

    ::RemoveDirectory(pszPath);

	return NOERROR;
}


HRESULT DeleteProfile(LPCSTR pszName)
{
	RegEntry re(::szProfileList, HKEY_LOCAL_MACHINE);

	HRESULT hres;

	if (re.GetError() == ERROR_SUCCESS) {
		{	/* extra scope for next RegEntry */
			RegEntry reUser(pszName, re.GetKey());
			if (reUser.GetError() == ERROR_SUCCESS) {
				NLS_STR nlsPath(MAX_PATH);
				if (nlsPath.QueryError() == ERROR_SUCCESS) {
					reUser.GetValue(::szProfileImagePath, &nlsPath);
					if (reUser.GetError() == ERROR_SUCCESS) {
						hres = DeleteProfileFiles(nlsPath.QueryPch());
					}
					else
						hres = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);

				}
				else
					hres = HRESULT_FROM_WIN32(nlsPath.QueryError());
			}
			else
				hres = HRESULT_FROM_WIN32(ERROR_NO_SUCH_USER);
		}
		if (SUCCEEDED(hres)) {
		    ::RegDeleteKey(re.GetKey(), pszName);
            NLS_STR nlsOEMName(pszName);
			if (nlsOEMName.QueryError() == ERROR_SUCCESS) {
			    nlsOEMName.strupr();
			    nlsOEMName.ToOEM();
    			::DeletePasswordCache(nlsOEMName.QueryPch());
            }
		}
	}
	else
		hres = E_UNEXPECTED;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "windows.h"       // Don't use precompiled header here
#include "commctrl.h"       // Don't use precompiled header here
#include "prsht.h"
#include "shlwapi.h"

PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst)
{
    PROPSHEETPAGE* ppsPage = LocalAlloc(LPTR, sizeof(PROPSHEETPAGE));
    if (ppsPage)
    {
        ppsPage->dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        ppsPage->hInstance = hinst;
        ppsPage->dwFlags = PSP_DEFAULT;
    }

    return ppsPage;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\settings.cpp ===
#include "mslocusr.h"
#include "msluglob.h"

#include <ole2.h>

CUserSettings::CUserSettings(void)
	: m_cRef(1),
	  m_clsid(GUID_NULL),
	  m_nlsName(NULL),
	  m_hkey(NULL)
{
	// nothing else
}


CUserSettings::~CUserSettings(void)
{
	if (m_hkey != NULL) {
		::RegCloseKey(m_hkey);
#ifdef DEBUG
		m_hkey = NULL;
#endif
	}
}


STDMETHODIMP CUserSettings::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
	if (!IsEqualIID(riid, IID_IUnknown) &&
		!IsEqualIID(riid, IID_IUserSettings)) {
		return ResultFromScode(E_NOINTERFACE);
	}

	*ppvObj = this;
	AddRef();
	return NOERROR;
}


STDMETHODIMP_(ULONG) CUserSettings::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CUserSettings::Release(void)
{
	ULONG cRef;

	cRef = --m_cRef;

	if (0L == m_cRef) {
		delete this;
	}

	return cRef;
}


STDMETHODIMP CUserSettings::GetCLSID(CLSID *pclsidOut)
{
	return E_NOTIMPL;
}


STDMETHODIMP CUserSettings::GetName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	if (m_nlsName.QueryError())
		return ResultFromScode(E_OUTOFMEMORY);

	UINT err = NPSCopyNLS(&m_nlsName, pbBuffer, pcbBuffer);

	return HRESULT_FROM_WIN32(err);
}


STDMETHODIMP CUserSettings::GetDisplayName(LPSTR pbBuffer, LPDWORD pcbBuffer)
{
	return E_NOTIMPL;
}


STDMETHODIMP CUserSettings::QueryKey(HKEY *phkeyOut)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by logonui.rc
//
#define IDS_LOGONTITLE                  10
#define IDS_BADPASSWORD                 11
#define IDS_YOURNEWPASSWORD             12
#define IDS_RATINGS_PW_COMMENT          13
#define IDS_PROFILES_ALREADY_ENABLED    14
#define IDS_ENTER_FIRST_USERNAME        15
#define IDS_BLANK_USERNAME              16
#define IDS_NO_MATCH                    17
#define IDS_GO_MULTI_RESTART            18
#define IDS_CLONE_USER_MESSAGE          19
#define IDS_GUEST_USERNAME              20
#define IDS_PICK_USERNAME               21
#define IDS_USER_EXISTS                 22
#define IDS_SELECTED_USER               23
#define IDS_SETTINGS_FOR                24
#define IDS_CONFIRM_DELETE_USER         25
#define IDS_PASSWORD_CHANGED            26
#define IDS_NP_NAME                     27
#define IDS_CACHE_PASSWORD              28
#define IDS_NETFAM_HELP_TEXT            29
#define IDS_PROFILE_POLICY              30

#define IDC_STATIC                      -1
#define IDC_STATIC1                     100
#define IDD_Users                       101
#define IDB_BITMAP1                     101
#define IDC_STATIC2                     101
#define IDD_AddUserIntro                102
#define IDC_STATIC3                     102
#define IDD_PickUser                    103
#define IDD_EnterUsername               104
#define IDD_NewUserPassword             105
#define IDD_LOGON                       106
#define IDD_EnableProfilesIntro         107
#define IDD_EnterCAPassword             108
#define IDD_FinishGoMulti               109
#define IDD_FinishAddUser               110
#define IDD_EnterUserPassword           111
#define IDD_CHANGE_PASSWORD             112
#define IDD_PASSWORD                    113
#define IDD_ChooseFolders               114
#define IDD_ChooseFoldersWiz            115
#define IDD_CreateProgress              116
#define IDD_DeleteProgress              117
#define IDC_MAIN_CAPTION                120
#define IDC_MAIN_CAPTION2               122
#define IDC_PASSWORD_LABEL              124
#define IDC_PASSWORD                    125
#define IDC_CONFIRM_PASSWORD            126
#define IDC_OLD_PASSWORD                132
#define IDC_CHECK_DESKTOP               80
#define IDC_CHECK_STARTMENU             81
#define IDC_CHECK_FAVORITES             82
#define IDC_CHECK_CACHE                 83
#define IDC_CHECK_MYDOCS                84
#define IDC_RADIO_COPY                  85
#define IDC_RADIO_EMPTY                 86
#define IDC_USERNAME                    152
#define IDC_LIST1                       1000
#define IDC_Add                         1002
#define IDC_Delete                      1003
#define IDC_SetPassword                 1004
#define IDC_OpenProfileFolder           1005
#define IDC_Clone                       1006
#define IDC_RATINGS_PW_COMMENT          1007
#define IDC_CACHE_PASSWORD              1008

/* Note: Code knows that IDB_IMAGE_XXXX_LOGON + 1 == IDB_STATIC_XXXX_LOGON */
#define IDB_IMAGE_LOGON                 106
#define IDB_STATIC_LOGON                107

#define IDB_IMAGE_WIN98_LOGON           108
#define IDB_STATIC_WIN98_LOGON          109

#define IDS_UNKNOWN_ERROR               2000

#define IDS_ERROR_NOT_AUTHENTICATED     2001
#define IDS_ERROR_NO_SUCH_USER          2002
#define IDS_ERROR_USER_EXISTS           2003
#define IDS_ERROR_OUT_OF_MEMORY         2004
#define IDS_ERROR_BUSY                  2005
#define IDS_ERROR_PATH_NOT_FOUND        2006
#define IDS_ERROR_BUFFER_OVERFLOW       2007

#define IDS_IERR_CachingDisabled	    2010
#define IDS_IERR_BadSig			        2011
#define IDS_IERR_CacheReadOnly		    2012
#define IDS_IERR_IncorrectUsername	    2013
#define IDS_IERR_CacheCorrupt		    2014
#define IDS_IERR_UsernameNotFound	    2015
#define IDS_IERR_CacheFull			    2016
#define IDS_IERR_CacheAlreadyOpen	    2017

#define IDS_E_ACCESSDENIED              2030

#define IDS_CSIDL_PERSONAL_L            2040
#define IDS_CSIDL_FAVORITES_L           2041
#define IDS_CSIDL_APPDATA_L             2042
#define IDS_CSIDL_CACHE_L               2043
#define IDS_CSIDL_DESKTOP_L             2046
#define IDS_CSIDL_RECENT_L              2047
#define IDS_CSIDL_NETHOOD_L             2048
#define IDS_CSIDL_STARTMENU_L           2049
#define IDS_CSIDL_PROGRAMS_L            2050
#define IDS_CSIDL_STARTUP_L             2051

#define IDS_CSIDL_CHANNELS_L            2052

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\superpw.cpp ===
#include "mslocusr.h"
#include "msluglob.h"
#include <md5.h>

HRESULT VerifySupervisorPassword(LPCSTR pszPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	if (!::fSupervisorKeyInit) {
		HKEY hkeyRating;
		LONG err;

		err = RegOpenKey(HKEY_LOCAL_MACHINE, ::szRATINGS, &hkeyRating);
		if (hkeyRating !=  NULL) {
			DWORD cbData = sizeof(::abSupervisorKey);
			DWORD dwType;
			err = ::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
									&dwType, (LPBYTE)::abSupervisorKey, &cbData);
            if (err != ERROR_SUCCESS)
    			err = ::RegQueryValueEx(hkeyRating, ::szUsersSupervisorKeyName, NULL,
	    								&dwType, (LPBYTE)::abSupervisorKey, &cbData);
			::RegCloseKey(hkeyRating);
			if (err == ERROR_SUCCESS) {
				if (dwType != REG_BINARY || cbData != sizeof(::abSupervisorKey)) {
					return E_UNEXPECTED;
				}
				::fSupervisorKeyInit = TRUE;
			}
		}
		else
			err = ERROR_FILE_NOT_FOUND;

		if (err != ERROR_SUCCESS) {
			return HRESULT_FROM_WIN32(err);
		}
	}

	if (pszPassword == NULL)
		return ResultFromScode(S_FALSE);

	MD5_CTX ctx;

	MD5Init(&ctx);
	MD5Update(&ctx, (const BYTE *)pszPassword, ::strlenf(pszPassword)+1);
	MD5Final(&ctx);

	return ResultFromScode(::memcmpf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey)) ? S_FALSE : S_OK);

#else

    return S_OK;        /* everybody's a supervisor */

#endif
}


HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
#ifdef MSLOCUSR_USE_SUPERVISOR_PASSWORD
	HRESULT hres;

	hres = ::VerifySupervisorPassword(pszOldPassword);
	if (hres == S_FALSE) {
		return E_ACCESSDENIED;
	}

	MD5_CTX ctx;

	MD5Init(&ctx);
	MD5Update(&ctx, (const BYTE *)pszNewPassword, ::strlenf(pszNewPassword)+1);
	MD5Final(&ctx);

	::memcpyf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey));
	::fSupervisorKeyInit = TRUE;

	HKEY hkeyRating;

	LONG err = RegOpenKey(HKEY_LOCAL_MACHINE, ::szRATINGS, &hkeyRating);
	if (err == ERROR_SUCCESS) {
        char abTemp[sizeof(::abSupervisorKey)];
        LPCSTR pszValueToSet;
        DWORD dwType;
        DWORD cbData = sizeof(abTemp);
        if (::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
							  &dwType, (LPBYTE)abTemp, &cbData) == ERROR_SUCCESS)
            pszValueToSet = ::szRatingsSupervisorKeyName;
        else
            pszValueToSet = ::szUsersSupervisorKeyName;

		::RegSetValueEx(hkeyRating, pszValueToSet, NULL,
						REG_BINARY, (const BYTE *)::abSupervisorKey, sizeof(::abSupervisorKey));
		::RegCloseKey(hkeyRating);
	}
#endif

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c

INCLUDES        = $(INCLUDES);$(INETCORE_INC_PATH);$(DS_INC_PATH);


# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\inetcplp.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\advdlg.cpp ===
/****************************************************************************\
 *
 *   advdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Advanced Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"
#include "picsrule.h"
#include "advdlg.h"         // CAdvancedDialog
// #include "custfile.h"       // CCustomFileDialog
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

// $KLUDGE begins -- These should not be a global set outside the class!!
extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;
// $KLUDGE ends -- These should not be a global set outside the class!!

DWORD CAdvancedDialog::aIds[] = {
    IDC_TEXT1,              IDH_RATINGS_BUREAU,
    IDC_TEXT2,              IDH_RATINGS_BUREAU,
    IDC_TEXT3,              IDH_RATINGS_BUREAU,
    IDC_3RD_COMBO,          IDH_RATINGS_BUREAU,
    IDC_STATIC_PICSRULES,   IDH_IGNORE,
    IDC_STATIC_PICSRULES2,  IDH_IGNORE,
    IDC_PICSRULESOPEN,      IDH_PICSRULES_OPEN,
    IDC_PICSRULESEDIT,      IDH_PICSRULES_EDIT,
    IDC_PICSRULES_UP,       IDH_ADVANCED_TAB_UP_ARROW_BUTTON,
    IDC_PICSRULES_DOWN,     IDH_ADVANCED_TAB_DOWN_ARROW_BUTTON,
    IDC_STATIC1,            IDH_IGNORE,
    IDC_PICSRULES_LIST,     IDH_PICS_RULES_LIST,
    0,0
};

CAdvancedDialog::CAdvancedDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CAdvancedDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HWND hDlg = m_hWnd;

    HICON   hIcon, hOldIcon;

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_UP),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    hOldIcon=(HICON) SendDlgItemMessage(IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    if(hOldIcon!=NULL)
    {
        DeleteObject(hOldIcon);
    }

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

    hOldIcon=(HICON) SendDlgItemMessage(IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    if(hOldIcon!=NULL)
    {
        DeleteObject(hOldIcon);
    }

    return 0L;
}

LRESULT CAdvancedDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HICON   hIcon;
    int     iCounter;

    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::OnInitDialog() - pPRSD is NULL!" );
        return 0L;
    }

    FillBureauList( pPRSD->pPRSI);

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_UP),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    SendDlgItemMessage(IDC_PICSRULES_UP,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    hIcon = (HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_PICSRULES_DOWN),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    
    SendDlgItemMessage(IDC_PICSRULES_DOWN,BM_SETIMAGE,(WPARAM) IMAGE_ICON,(LPARAM) hIcon);

    g_arrpPICSRulesPRRSPreApply.DeleteAll();

    if(g_lGlobalCounterValue!=SHGlobalCounterGetValue(g_HandleGlobalCounter))
    {
        HRESULT               hRes;
        DWORD                 dwNumSystems;
        PICSRulesRatingSystem * pPRRS=NULL;

        g_arrpPRRS.DeleteAll();

        //someone modified our settings, so we'd better reload them.
        hRes=PICSRulesGetNumSystems(&dwNumSystems);

        if(SUCCEEDED(hRes))
        {
            DWORD dwCounter;

            for(dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
                dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
                dwCounter++)
            {
                hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

                if(FAILED(hRes))
                {
                    //we couldn't read in the systems, so don't inforce PICSRules,
                    //and notify the user
        
                    g_arrpPRRS.DeleteAll();

                    MyMessageBox(m_hWnd, IDS_PICSRULES_TAMPEREDREADMSG, IDS_PICSRULES_TAMPEREDREADTITLE, MB_OK|MB_ICONERROR );
                    break;
                }
                else
                {
                    g_arrpPRRS.Append(pPRRS);

                    pPRRS=NULL;
                }
            }
        }

        g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);
    }

    CopyArrayPRRSStructures(&g_arrpPICSRulesPRRSPreApply,&g_arrpPRRS);

    //fill in the listbox with installed PICSRules systems
    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSPreApply.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToList;
        char                  * lpszName=NULL;

        pPRRSToList=g_arrpPICSRulesPRRSPreApply[iCounter];

        if((pPRRSToList->m_pPRName)!=NULL)
        {
            lpszName=pPRRSToList->m_pPRName->m_etstrRuleName.Get();
        }

        if(lpszName==NULL)
        {
            lpszName=pPRRSToList->m_etstrFile.Get();
        }

        // We should have a name in lpszName by now, but just in case, check for it.
        if (lpszName)
        {
            SendDlgItemMessage(IDC_PICSRULES_LIST,LB_ADDSTRING,(WPARAM) 0,(LPARAM) lpszName);
        }
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,LB_SETCURSEL,(WPARAM) -1,(LPARAM) 0);
    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),FALSE);

    if(SendDlgItemMessage( IDC_PICSRULES_LIST, LB_GETCOUNT, 0, 0) < 2)
    {
        // less than 2 elements in box - disable up and down buttons
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), FALSE);
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), FALSE);
    }

    PostMessage(WM_USER,(WPARAM) 0,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CAdvancedDialog::OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (gPRSI->lpszFileName!=NULL)
    {
        ::SetFocus(GetDlgItem(IDC_PICSRULESOPEN));

        SendMessage(WM_COMMAND,(WPARAM) IDC_PICSRULESOPEN,(LPARAM) 0);

        gPRSI->lpszFileName=NULL;
    }

    return 0L;
}

LRESULT CAdvancedDialog::OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MarkChanged();
    return 1L;
}

LRESULT CAdvancedDialog::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),TRUE);
    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iSelected;
    PICSRulesRatingSystem * pPRRSToMove;
    char                  * lpszName=NULL;

    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    if(iSelected==0)
    {
        //already at the top

        return 1L;
    }

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    g_arrpPICSRulesPRRSPreApply[iSelected]=
        g_arrpPICSRulesPRRSPreApply[iSelected-1];

    g_arrpPICSRulesPRRSPreApply[iSelected-1]=pPRRSToMove;

    //update the listbox
    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected-1,
                       (LPARAM) 0);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected-1];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected-1,
                       (LPARAM) lpszName);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected,
                       (LPARAM) lpszName);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_SETCURSEL,
                       (WPARAM) iSelected-1,
                       (LPARAM) 0);

    MarkChanged();

    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iSelected, iNumItems;
    PICSRulesRatingSystem * pPRRSToMove;
    char                  * lpszName=NULL;

    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    iNumItems= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCOUNT,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iNumItems==LB_ERR)
    {
        return 1L;
    }

    if(iSelected==(iNumItems-1))
    {
        //already at the bottom

        return 1L;
    }

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    g_arrpPICSRulesPRRSPreApply[iSelected]=
        g_arrpPICSRulesPRRSPreApply[iSelected+1];

    g_arrpPICSRulesPRRSPreApply[iSelected+1]=pPRRSToMove;

    //update the listbox
    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected+1,
                       (LPARAM) 0);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected,
                       (LPARAM) lpszName);

    pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iSelected+1];

    if((pPRRSToMove->m_pPRName)!=NULL)
    {
        lpszName=pPRRSToMove->m_pPRName->m_etstrRuleName.Get();
    }

    if(lpszName==NULL)
    {
        lpszName=pPRRSToMove->m_etstrFile.Get();
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_INSERTSTRING,
                       (WPARAM) iSelected+1,
                       (LPARAM) lpszName);

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_SETCURSEL,
                       (WPARAM) iSelected+1,
                       (LPARAM) 0);

    MarkChanged();

    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int     iSelected, iCounter;
    array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSNew;


    iSelected= (int) SendDlgItemMessage(IDC_PICSRULES_LIST,
                                        LB_GETCURSEL,
                                        (WPARAM) 0,
                                        (LPARAM) 0);

    if(iSelected==LB_ERR)
    {
        return 1L;
    }

    SendDlgItemMessage(IDC_PICSRULES_LIST,
                       LB_DELETESTRING,
                       (WPARAM) iSelected,
                       (LPARAM) 0);

    // If there's less than two left, turn off up and down buttons
    if(SendDlgItemMessage( IDC_PICSRULES_LIST, LB_GETCOUNT, 0, 0) < 2)
    {
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), FALSE);
        ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), FALSE);
    }

    delete (g_arrpPICSRulesPRRSPreApply[iSelected]);

    g_arrpPICSRulesPRRSPreApply[iSelected]=NULL;

    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSPreApply.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToMove;

        pPRRSToMove=g_arrpPICSRulesPRRSPreApply[iCounter];

        if(pPRRSToMove!=NULL)
        {
            g_arrpPICSRulesPRRSNew.Append(pPRRSToMove);
        }
    }

    g_arrpPICSRulesPRRSPreApply.ClearAll();

    for(iCounter=0;iCounter<g_arrpPICSRulesPRRSNew.Length();iCounter++)
    {
        PICSRulesRatingSystem * pPRRSToMove;

        pPRRSToMove=g_arrpPICSRulesPRRSNew[iCounter];

        g_arrpPICSRulesPRRSPreApply.Append(pPRRSToMove);
    }

    g_arrpPICSRulesPRRSNew.ClearAll();

    ::EnableWindow(GetDlgItem(IDC_PICSRULESEDIT),FALSE);
    MarkChanged();
    ::SetFocus(GetDlgItem(IDC_PICSRULESOPEN));

    SendDlgItemMessage(IDC_PICSRULESOPEN,
                       BM_SETSTYLE,
                       (WPARAM) BS_DEFPUSHBUTTON,
                       (LPARAM) MAKELPARAM(TRUE,0));

    SendDlgItemMessage(IDC_PICSRULESEDIT,
                       BM_SETSTYLE,
                       (WPARAM) BS_PUSHBUTTON,
                       (LPARAM) MAKELPARAM(TRUE,0));
    return 1L;
}

LRESULT CAdvancedDialog::OnPicsRulesOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    TCHAR szFile[MAX_PATH];

    szFile[0] = '\0';

    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fHaveFile=FALSE;
    PICSRulesRatingSystem   *pPRRS;

    PRSD *      pPRSD = m_pPRSD;

    if(!pPRSD)
    {
        MyMessageBox(m_hWnd, IDS_PICSRULES_SYSTEMERROR, IDS_ERROR, MB_OK|MB_ICONERROR);

        return 1L;
    }

    if (gPRSI->lpszFileName)
    {
        fHaveFile=TRUE;
        lstrcpy(szFile,gPRSI->lpszFileName);
    }
    else
    {
        TCHAR szDlgTitle[MAX_PATH];
        TCHAR szDlgFilter[MAX_PATH];

        LPTSTR pszDlgFilterPtr;

        memset( szDlgFilter, 0, sizeof( szDlgFilter ) );

        MLLoadString(IDS_OPENDIALOGFILTER,(LPTSTR) szDlgFilter,ARRAYSIZE(szDlgFilter));
        MLLoadString(IDS_OPENDIALOGTITLE,(LPTSTR) szDlgTitle,ARRAYSIZE(szDlgTitle));

        pszDlgFilterPtr = &szDlgFilter[lstrlen(szDlgFilter)+1];
        lstrcpy(pszDlgFilterPtr, TEXT("*.prf"));

        OPENFILENAME OpenFileName;

        memset( &OpenFileName, 0, sizeof(OpenFileName) );

        OpenFileName.lStructSize       =sizeof(OPENFILENAME); 
        OpenFileName.hwndOwner         =m_hWnd; 
        OpenFileName.hInstance         =NULL; 
        OpenFileName.lpstrFilter       =szDlgFilter; 
        OpenFileName.lpstrCustomFilter =(LPTSTR) NULL; 
        OpenFileName.nMaxCustFilter    =0L; 
        OpenFileName.nFilterIndex      =1L; 
        OpenFileName.lpstrFile         =szFile; 
        OpenFileName.nMaxFile          =ARRAYSIZE(szFile); 
        OpenFileName.lpstrInitialDir   =NULL; 
        OpenFileName.lpstrTitle        =szDlgTitle; 
        OpenFileName.nFileOffset       =0; 
        OpenFileName.nFileExtension    =0; 
        OpenFileName.lpstrDefExt       =NULL; 
        OpenFileName.lCustData         =0; 
        OpenFileName.Flags             =OFN_FILEMUSTEXIST
                                        | OFN_PATHMUSTEXIST
                                        | OFN_HIDEREADONLY;

        fHaveFile = ::GetOpenFileName( &OpenFileName );

#ifdef NEVER
        DWORD           dwFlags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NONETWORKBUTTON
                            | OFN_HIDEREADONLY;

        CCustomFileDialog           cfd( TRUE,          // Local Files Only
                                         TRUE,          // Open File
                                         NULL,          // Default Extension
                                         NULL,          // Initial Filename
                                         dwFlags,       // Open File Flags
                                         szDlgFilter,   // Filter
                                         m_hWnd );      // Parent

        if ( cfd.DoModal( m_hWnd ) )
        {
            fHaveFile = TRUE;
            lstrcpy( szFile, cfd.m_szFileName );
        }
#endif

    }    

    if (fHaveFile) 
    {
        HRESULT hRes;

        //create PICSRulesRatingSystem class, and pass to the
        //import procedure with file name

        hRes=PICSRulesImport(szFile,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            LPSTR   lpszPICSRulesSystemName = NULL,lpszNewSystemName = NULL;
            DWORD   dwSystemToSave,dwNumSystemsInstalled,dwCounter;
            BOOL    fPromptToOverwrite=FALSE;

            if((pPRRS->m_pPRName)!=NULL)
            {
                lpszNewSystemName=pPRRS->m_pPRName->m_etstrRuleName.Get();
            }

            if(lpszNewSystemName==NULL)
            {
                lpszNewSystemName=pPRRS->m_etstrFile.Get();
            }

            dwNumSystemsInstalled=g_arrpPICSRulesPRRSPreApply.Length();

            //Systems below PICSRULES_FIRSTSYSTEMINDEX are
            //reserved for the Approved Sites Rules, and
            //future expansion.
            for(dwCounter=0;dwCounter<dwNumSystemsInstalled;dwCounter++)
            {
                //check to see if the system we just processed
                //is already installed
                if ((g_arrpPICSRulesPRRSPreApply[dwCounter])->m_pPRName != NULL)
                {
                    lpszPICSRulesSystemName=(g_arrpPICSRulesPRRSPreApply[dwCounter])->m_pPRName->m_etstrRuleName.Get();
                }

                if (lpszPICSRulesSystemName == NULL)
                {
                    lpszPICSRulesSystemName=(g_arrpPICSRulesPRRSPreApply[dwCounter])->m_etstrFile.Get();
                }

                if(lstrcmp(lpszPICSRulesSystemName,lpszNewSystemName)==0)
                {
                    //We've found an identical system, so set dwSystemToSave
                    //to dwCounter and set fPromptToOverwrite to TRUE
                    fPromptToOverwrite=TRUE;

                    return 1L;
                }
            }

            dwSystemToSave=dwCounter+PICSRULES_FIRSTSYSTEMINDEX;

            if(fPromptToOverwrite)
            {
                if (IDNO == MyMessageBox(m_hWnd, IDS_PICSRULES_EXISTSMESSAGE, IDS_PICSRULES_EXISTSTITLE, MB_YESNO|MB_ICONERROR))
                {
                    delete pPRRS;

                    pPRRS=NULL;
                    g_pPRRS=NULL;

                    return 1L;
                }
            }

            if((dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX)<(DWORD) (g_arrpPICSRulesPRRSPreApply.Length()))
            {
                char * lpszName=NULL;

                delete g_arrpPICSRulesPRRSPreApply[dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX];
                g_arrpPICSRulesPRRSPreApply[dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX]=pPRRS;

                //update the listbox
                if((pPRRS->m_pPRName)!=NULL)
                {
                    lpszName=pPRRS->m_pPRName->m_etstrRuleName.Get();
                }

                if(lpszName==NULL)
                {
                    lpszName=pPRRS->m_etstrFile.Get();
                }

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_DELETESTRING,
                                   (WPARAM) dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX,
                                   (LPARAM) 0);

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_INSERTSTRING,
                                   (WPARAM) dwSystemToSave-PICSRULES_FIRSTSYSTEMINDEX,
                                   (LPARAM) lpszName);
            }
            else
            {
                char * lpszName=NULL;

                g_arrpPICSRulesPRRSPreApply.Append(pPRRS);

                //update the listbox
                if((pPRRS->m_pPRName)!=NULL)
                {
                    lpszName=pPRRS->m_pPRName->m_etstrRuleName.Get();
                }

                if(lpszName==NULL)
                {
                    lpszName=pPRRS->m_etstrFile.Get();
                }

                SendDlgItemMessage(IDC_PICSRULES_LIST,
                                   LB_ADDSTRING,
                                   (WPARAM) 0,
                                   (LPARAM) lpszName);

                // if there's now more than one element,
                // turn on up and down buttons
                if(SendDlgItemMessage( IDC_PICSRULES_LIST,
                                    LB_GETCOUNT, 0, 0) > 1)
                {
                    ::EnableWindow(GetDlgItem( IDC_PICSRULES_UP), TRUE);
                    ::EnableWindow(GetDlgItem( IDC_PICSRULES_DOWN), TRUE);
                }
            }

            fPICSRulesSaved=TRUE;

            MarkChanged();
        }
        else
        {
            pPRRS->ReportError(hRes);

            delete pPRRS;
            pPRRS=NULL;
        }

        if (!fPICSRulesSaved)
        {
            if (pPRRS)
            {
                //we successfully processed the PICSRules, but couldn't
                //save them

                MyMessageBox(m_hWnd, IDS_PICSRULES_ERRORSAVINGMSG, IDS_PICSRULES_ERRORSAVINGTITLE, MB_OK|MB_ICONERROR);

                delete pPRRS;
                pPRRS=NULL;
            }
        }
        else
        {
            //Success!  Notify the user.

            MyMessageBox(m_hWnd, IDS_PICSRULES_SUCCESSMESSAGE, IDS_PICSRULES_SUCCESSTITLE, MB_OK);
        }
    }

    g_pPRRS=NULL; //done processing the current system, so make sure it
                  //doesn't point to anything

    return 1L;
}

LRESULT CAdvancedDialog::OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::OnSetActive() - pPRSD is NULL!" );
        return 0L;
    }

    if(pPRSD->fNewProviders==TRUE)
    {
        FillBureauList( pPRSD->pPRSI);
    }

    bHandled = FALSE;
    return 0L;
}

LRESULT CAdvancedDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/
    PRSD *      pPRSD = m_pPRSD;

    DWORD dwNumExistingSystems,dwCounter;

    /*do apply stuff*/

    /* Get the text from the rating bureau combo box. */
    /* Default for etstrRatingBureau (the URL) will be this text. */
    NLS_STR nlsURL;

    int i;
    const char *p;

    if (nlsURL.realloc( ::GetWindowTextLength(GetDlgItem( IDC_3RD_COMBO)) + 1)) {
        GetDlgItemText( IDC_3RD_COMBO, nlsURL.Party(), nlsURL.QueryAllocSize());
        nlsURL.DonePartying();
        p = (char *)nlsURL.QueryPch();

        INT_PTR temp = SendDlgItemMessage( IDC_3RD_COMBO, CB_GETCURSEL, 0, 0L);
        if (temp != CB_ERR) {
            /* Get the text of the selected item in the list. */
            UINT cbName = (UINT)SendDlgItemMessage( IDC_3RD_COMBO, CB_GETLBTEXTLEN, temp, 0);
            NLS_STR nlsName(cbName+1);
            if (nlsName.QueryError())
                p = NULL;
            else {
                /* If the text of the selected item in the list
                 * is what's in the edit field, then the user
                 * has selected one of those rating system names.
                 * The itemdata for the item is the URL.
                 */
                SendDlgItemMessage( IDC_3RD_COMBO, CB_GETLBTEXT, temp, (LPARAM)(LPSTR)nlsName.Party());
                nlsName.DonePartying();
                if (nlsName == nlsURL)
                    p = (char *)SendDlgItemMessage( IDC_3RD_COMBO, CB_GETITEMDATA, temp, 0L);
            }
        }
    }
    else
    {
        p = NULL;
    }

    if (pPRSD->pPRSI->etstrRatingBureau.fIsInit() && (!p ||
        strcmpf(pPRSD->pPRSI->etstrRatingBureau.Get(),p)))
    {
        // check if old bureau is required
        for (i = 0; i <pPRSD->pPRSI->arrpPRS.Length(); ++i)
        {
            if (pPRSD->pPRSI->arrpPRS[i]->etstrRatingBureau.fIsInit() &&
                (!strcmpf(pPRSD->pPRSI->etstrRatingBureau.Get(),
                          pPRSD->pPRSI->arrpPRS[i]->etstrRatingBureau.Get())))
            {
                if (!(pPRSD->pPRSI->arrpPRS[i]->etbBureauRequired.Get()))
                {
                    break; // Not required.  We're done.
                }      
                      
                //We're removing a bureau that's required.  Warn user.
                char pszBuf[MAXPATHLEN];
                char szTemp[MAXPATHLEN];

                MLLoadStringA(IDS_NEEDBUREAU, pszBuf, sizeof(pszBuf));
                wsprintf(szTemp, pszBuf, pPRSD->pPRSI->arrpPRS[i]->etstrName.Get());
                if (MessageBox(szTemp, NULL, MB_YESNO) == IDNO)
                {
                    return PSNRET_INVALID_NOCHANGEPAGE;
                }
                else
                {
                    break;
                }
            }
        }
    }

    if (!p || !*p)
    {
        pPRSD->pPRSI->etstrRatingBureau.Set(NULL);
        DeinstallRatingBureauHelper();
    }
    else
    {
        pPRSD->pPRSI->etstrRatingBureau.Set((LPSTR)p);
        InstallRatingBureauHelper();
    }    

    /* Update the rating helper list to include or not include
     * the rating bureau helper.
     */
    CleanupRatingHelpers();
    InitRatingHelpers();

    //process PICSRules

    PICSRulesGetNumSystems(&dwNumExistingSystems);

    for(dwCounter=0;dwCounter<dwNumExistingSystems;dwCounter++)
    {
        //delete all existing systems from the registry
        PICSRulesDeleteSystem(dwCounter+PICSRULES_FIRSTSYSTEMINDEX);
    }

    g_arrpPRRS.DeleteAll();

    CopyArrayPRRSStructures(&g_arrpPRRS,&g_arrpPICSRulesPRRSPreApply);

    for(dwCounter=0;dwCounter<(DWORD) (g_arrpPRRS.Length());dwCounter++)
    {
        g_pPRRS=g_arrpPRRS[dwCounter];

        PICSRulesSaveToRegistry(dwCounter+PICSRULES_FIRSTSYSTEMINDEX,&g_arrpPRRS[dwCounter]);
    }

    PICSRulesSetNumSystems(g_arrpPICSRulesPRRSPreApply.Length());

    SHGlobalCounterIncrement(g_HandleGlobalCounter);

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Return 1L for OK or Cancel
    return PSNRET_NOERROR;
}

LRESULT CAdvancedDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return 0L;
}

LRESULT CAdvancedDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CAdvancedDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CAdvancedDialog::InstallRatingBureauHelper( void )
{
    HKEY                hkey;

    hkey = CreateRegKeyNT( ::szRATINGHELPERS );

    if ( hkey != NULL )
    {
        CRegKey             key;

        key.Attach( hkey );

        key.SetValue( szRORSGUID, szNULL );
    }
    else
    {
        TraceMsg( TF_ERROR, "CAdvancedDialog::InstallRatingBureauHelper() - Failed to create key szRATINGHELPERS='%s'!", szRATINGHELPERS );
    }
}

void CAdvancedDialog::DeinstallRatingBureauHelper( void )
{
    CRegKey         key;

    if ( key.Open( HKEY_LOCAL_MACHINE, szRATINGHELPERS ) == ERROR_SUCCESS )
    {
        key.DeleteValue( szRORSGUID );
    }
}

UINT CAdvancedDialog::FillBureauList( PicsRatingSystemInfo *pPRSI )
{
    int i;
    INT_PTR z;
    BOOL fHaveBureau = pPRSI->etstrRatingBureau.fIsInit();
    BOOL fSelectedOne = FALSE;

    HWND hwndCombo = GetDlgItem( IDC_3RD_COMBO);
    LPCSTR pszCurrentBureau;
    BOOL fListBureau = FALSE;

    NLS_STR nlsURL;

    /* Save current selection if at all possible.  If an item in the listbox
     * is selected, get its item data, which is the rating bureau string.
     *
     * We remember if it was an item from the list that was selected before;
     * that indicates that the bureau belongs to a rating system, and if we
     * don't find it in the list after reinitializing, we know that rating
     * system has been removed and the bureau is probably useless now.
     */
    z = SendMessage(hwndCombo, CB_GETCURSEL, 0, 0);
    if (z != CB_ERR)
    {
        pszCurrentBureau = (LPCSTR)SendMessage(hwndCombo, CB_GETITEMDATA, z, 0);
        fListBureau = TRUE;
    }
    else
    {
        /* No item selected.  If there is text in the edit control, preserve
         * it;  otherwise, try to select the current rating bureau if any.
         */
        UINT cch = ::GetWindowTextLength(hwndCombo);
        if (cch > 0 && nlsURL.realloc(cch + 1)) {
            ::GetWindowText(hwndCombo, nlsURL.Party(), nlsURL.QueryAllocSize());
            nlsURL.DonePartying();
            pszCurrentBureau = nlsURL.QueryPch();
        }
        else
        {
            pszCurrentBureau = fHaveBureau ? pPRSI->etstrRatingBureau.Get() : szNULL;
        }
    }

    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);
   
    for (i = 0; i < pPRSI->arrpPRS.Length(); ++i)
    {
        PicsRatingSystem *prs = pPRSI->arrpPRS[i];
        if (prs->etstrRatingBureau.fIsInit())
        {
            z = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)prs->etstrName.Get());
            SendMessage(hwndCombo, CB_SETITEMDATA, z,
                        (LPARAM)prs->etstrRatingBureau.Get());

            if (!fSelectedOne)
            {
                if (!strcmpf(pszCurrentBureau, prs->etstrRatingBureau.Get())) 
                {
                    SendMessage(hwndCombo, CB_SETCURSEL, z,0);
                    fSelectedOne = TRUE;
                }           
            }
        }
    }

    NLS_STR nlsNone(MAX_RES_STR_LEN);
    if (nlsNone.LoadString(IDS_NO_BUREAU) != ERROR_SUCCESS)
        nlsNone = NULL;

    z = SendMessage(hwndCombo, CB_ADDSTRING, 0, (LPARAM)nlsNone.QueryPch());

    SendMessage(hwndCombo, CB_SETITEMDATA, z, 0L);
       
    if (!fSelectedOne)
    {
        if (!fListBureau && *pszCurrentBureau != '\0')
            ::SetWindowText(hwndCombo, pszCurrentBureau);
        else
            SendMessage(hwndCombo, CB_SETCURSEL, z, 0L);
    }

    return 0;
}

HRESULT CAdvancedDialog::CopySubPolicyExpression(PICSRulesPolicyExpression * pPRSubPolicyExpression,
                                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy,
                                PICSRulesRatingSystem * pPRRSLocal,
                                PICSRulesPolicy * pPRPolicy)
{
    BOOL fFlag;
    
    fFlag=pPRSubPolicyExpressionToCopy->m_prYesNoUseEmbedded.GetYesNo();
    pPRSubPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

    pPRSubPolicyExpression->m_etstrServiceName.Set(pPRSubPolicyExpressionToCopy->m_etstrServiceName.Get());
    pPRSubPolicyExpression->m_etstrCategoryName.Set(pPRSubPolicyExpressionToCopy->m_etstrCategoryName.Get());
    pPRSubPolicyExpression->m_etstrFullServiceName.Set(pPRSubPolicyExpressionToCopy->m_etstrFullServiceName.Get());
    pPRSubPolicyExpression->m_etnValue.Set(pPRSubPolicyExpressionToCopy->m_etnValue.Get());

    pPRSubPolicyExpression->m_PROPolicyOperator=pPRSubPolicyExpressionToCopy->m_PROPolicyOperator;
    pPRSubPolicyExpression->m_PRPEPolicyEmbedded=pPRSubPolicyExpressionToCopy->m_PRPEPolicyEmbedded;

    if(pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionLeft!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpression2,* pPRSubPolicyExpressionToCopy2;

        pPRSubPolicyExpression2=new PICSRulesPolicyExpression;

        if(pPRSubPolicyExpression2==NULL)
        {
            PICSRulesOutOfMemory();

            delete pPRRSLocal;
            pPRRSLocal = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpressionToCopy2=pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionLeft;

        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression2,pPRSubPolicyExpressionToCopy2,pPRRSLocal,pPRPolicy)))
        {
            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpression->m_pPRPolicyExpressionLeft=pPRSubPolicyExpression2;
    }

    if(pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionRight!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpression2,* pPRSubPolicyExpressionToCopy2;

        pPRSubPolicyExpression2=new PICSRulesPolicyExpression;

        if(pPRSubPolicyExpression2==NULL)
        {
            PICSRulesOutOfMemory();

            delete pPRRSLocal;
            pPRRSLocal = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpressionToCopy2=pPRSubPolicyExpressionToCopy->m_pPRPolicyExpressionRight;

        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression2,pPRSubPolicyExpressionToCopy2,pPRRSLocal,pPRPolicy)))
        {
            return(E_OUTOFMEMORY);
        }

        pPRSubPolicyExpression->m_pPRPolicyExpressionRight=pPRSubPolicyExpression2;
    }

    return(NOERROR);
}

HRESULT CAdvancedDialog::CopyArrayPRRSStructures(array<PICSRulesRatingSystem*> * parrpPRRSDest,array<PICSRulesRatingSystem*> * parrpPRRSSource)
{
    DWORD                       dwCounter;
    PICSRulesRatingSystem       * pPRRSLocal,* pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicy,* pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpression,* pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfo,* pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtension,* pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtension,* pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRName,* pPRNameBeingCopied;
    PICSRulesSource             * pPRSource,* pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

    if(parrpPRRSDest->Length()>0)
    {
        parrpPRRSDest->DeleteAll();
    }

    for(dwCounter=0;dwCounter<(DWORD) (parrpPRRSSource->Length());dwCounter++)
    {
        pPRRSLocal=new PICSRulesRatingSystem;

        if(pPRRSLocal==NULL)
        {
            PICSRulesOutOfMemory();

            return(E_OUTOFMEMORY);
        }

        pPRRSBeingCopied=(*parrpPRRSSource)[dwCounter];

        pPRRSLocal->m_etstrFile.Set(pPRRSBeingCopied->m_etstrFile.Get());
        pPRRSLocal->m_etnPRVerMajor.Set(pPRRSBeingCopied->m_etnPRVerMajor.Get());
        pPRRSLocal->m_etnPRVerMinor.Set(pPRRSBeingCopied->m_etnPRVerMinor.Get());
        pPRRSLocal->m_dwFlags=pPRRSBeingCopied->m_dwFlags;
        pPRRSLocal->m_nErrLine=pPRRSBeingCopied->m_nErrLine;

        if((pPRRSBeingCopied->m_pPRName)!=NULL)
        {
            pPRName=new PICSRulesName;

            if(pPRName==NULL)
            {
                PICSRulesOutOfMemory();

                delete pPRRSLocal;
                pPRRSLocal = NULL;

                return(E_OUTOFMEMORY);
            }

            pPRNameBeingCopied=pPRRSBeingCopied->m_pPRName;

            pPRName->m_etstrRuleName.Set(pPRNameBeingCopied->m_etstrRuleName.Get());
            pPRName->m_etstrDescription.Set(pPRNameBeingCopied->m_etstrDescription.Get());
        
            pPRRSLocal->m_pPRName=pPRName;          
        }
        else
        {
            pPRRSLocal->m_pPRName=NULL;
        }

        if((pPRRSBeingCopied->m_pPRSource)!=NULL)
        {
            pPRSource=new PICSRulesSource;

            if(pPRSource==NULL)
            {
                PICSRulesOutOfMemory();

                delete pPRRSLocal;
                pPRRSLocal = NULL;

                return(E_OUTOFMEMORY);
            }

            pPRSourceBeingCopied=pPRRSBeingCopied->m_pPRSource;

            pPRSource->m_prURLSourceURL.Set(pPRSourceBeingCopied->m_prURLSourceURL.Get());
            pPRSource->m_etstrCreationTool.Set(pPRSourceBeingCopied->m_etstrCreationTool.Get());
            pPRSource->m_prEmailAuthor.Set(pPRSourceBeingCopied->m_prEmailAuthor.Get());
            pPRSource->m_prDateLastModified.Set(pPRSourceBeingCopied->m_prDateLastModified.Get());

            pPRRSLocal->m_pPRSource=pPRSource;
        }
        else
        {
            pPRRSLocal->m_pPRSource=NULL;
        }

        if(pPRRSBeingCopied->m_arrpPRPolicy.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRPolicy.Length());dwSubCounter++)
            {
                DWORD dwPolicyExpressionSubCounter;

                pPRPolicy=new PICSRulesPolicy;

                pPRPolicyBeingCopied=pPRRSBeingCopied->m_arrpPRPolicy[dwSubCounter];

                if(pPRPolicy==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRPolicy->m_etstrExplanation.Set(pPRPolicyBeingCopied->m_etstrExplanation.Get());
                pPRPolicy->m_PRPolicyAttribute=pPRPolicyBeingCopied->m_PRPolicyAttribute;

                pPRByURLToCopy=NULL;
                pPRPolicyExpressionBeingCopied=NULL;

                switch(pPRPolicy->m_PRPolicyAttribute)
                {
                    case PR_POLICY_ACCEPTBYURL:
                    {
                        pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRAcceptByURL;
                    
                        pPRByURL=new PICSRulesByURL;
                
                        if(pPRByURL==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptByURL=pPRByURL;

                        break;
                    }
                    case PR_POLICY_REJECTBYURL:
                    {
                        pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRRejectByURL;

                        pPRByURL=new PICSRulesByURL;
                
                        if(pPRByURL==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectByURL=pPRByURL;

                        break;
                    }
                    case PR_POLICY_REJECTIF:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectIf;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectIf=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_ACCEPTIF:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptIf;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptIf=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_REJECTUNLESS:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectUnless;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRRejectUnless=pPRPolicyExpression;

                        break;
                    }
                    case PR_POLICY_ACCEPTUNLESS:
                    {
                        pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptUnless;

                        pPRPolicyExpression=new PICSRulesPolicyExpression;
                
                        if(pPRPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;
                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicy->m_pPRAcceptUnless=pPRPolicyExpression;

                        break;
                    }
                }

                if(pPRByURLToCopy!=NULL)
                {
                    for(dwPolicyExpressionSubCounter=0;
                        dwPolicyExpressionSubCounter<(DWORD) (pPRByURLToCopy->m_arrpPRByURL.Length());
                        dwPolicyExpressionSubCounter++)
                    {
                        pPRByURLExpression=new PICSRulesByURLExpression;

                        if(pPRByURLExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[dwPolicyExpressionSubCounter];

                        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
                        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
                        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
                        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
                        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
                        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
                        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
                        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
                        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

                        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);
                    }

                    pPRRSLocal->m_arrpPRPolicy.Append(pPRPolicy);
                }

                if(pPRPolicyExpressionBeingCopied!=NULL)
                {
                    BOOL fFlag;
                    
                    fFlag=pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo();
                    pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

                    pPRPolicyExpression->m_etstrServiceName.Set(pPRPolicyExpressionBeingCopied->m_etstrServiceName.Get());
                    pPRPolicyExpression->m_etstrCategoryName.Set(pPRPolicyExpressionBeingCopied->m_etstrCategoryName.Get());
                    pPRPolicyExpression->m_etstrFullServiceName.Set(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName.Get());
                    pPRPolicyExpression->m_etnValue.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());

                    pPRPolicyExpression->m_PROPolicyOperator=pPRPolicyExpressionBeingCopied->m_PROPolicyOperator;
                    pPRPolicyExpression->m_PRPEPolicyEmbedded=pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded;

                    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
                    {
                        PICSRulesPolicyExpression * pPRSubPolicyExpression,* pPRSubPolicyExpressionToCopy;

                        pPRSubPolicyExpression=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

                        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression,pPRSubPolicyExpressionToCopy,pPRRSLocal,pPRPolicy)))
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRSubPolicyExpression;
                    }

                    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
                    {
                        PICSRulesPolicyExpression * pPRSubPolicyExpression,* pPRSubPolicyExpressionToCopy;

                        pPRSubPolicyExpression=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpression==NULL)
                        {
                            PICSRulesOutOfMemory();

                            delete pPRRSLocal;
                            pPRRSLocal = NULL;

                            delete pPRPolicy;
                            pPRPolicy = NULL;

                            return(E_OUTOFMEMORY);
                        }

                        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

                        if(FAILED(CopySubPolicyExpression(pPRSubPolicyExpression,pPRSubPolicyExpressionToCopy,pPRRSLocal,pPRPolicy)))
                        {
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRSubPolicyExpression;
                    }

                    pPRRSLocal->m_arrpPRPolicy.Append(pPRPolicy);
                }
            }
        }

        if(pPRRSBeingCopied->m_arrpPRServiceInfo.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRServiceInfo.Length());dwSubCounter++)
            {
                BOOL fFlag;

                pPRServiceInfo=new PICSRulesServiceInfo;

                if(pPRServiceInfo==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRServiceInfoBeingCopied=pPRRSBeingCopied->m_arrpPRServiceInfo[dwSubCounter];

                pPRServiceInfo->m_prURLName.Set(pPRServiceInfoBeingCopied->m_prURLName.Get());
                pPRServiceInfo->m_prURLBureauURL.Set(pPRServiceInfoBeingCopied->m_prURLBureauURL.Get());
                pPRServiceInfo->m_etstrShortName.Set(pPRServiceInfoBeingCopied->m_etstrShortName.Get());
                pPRServiceInfo->m_etstrRatfile.Set(pPRServiceInfoBeingCopied->m_etstrRatfile.Get());

                fFlag=pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.GetYesNo();
                pPRServiceInfo->m_prYesNoUseEmbedded.Set(&fFlag);

                fFlag=pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.GetPassFail();
                pPRServiceInfo->m_prPassFailBureauUnavailable.Set(&fFlag);

                pPRRSLocal->m_arrpPRServiceInfo.Append(pPRServiceInfo);
            }
        }

        if(pPRRSBeingCopied->m_arrpPROptExtension.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
            {
                pPROptExtension=new PICSRulesOptExtension;

                if(pPROptExtension==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPROptExtensionBeingCopied=pPRRSBeingCopied->m_arrpPROptExtension[dwSubCounter];

                pPROptExtension->m_prURLExtensionName.Set(pPROptExtensionBeingCopied->m_prURLExtensionName.Get());
                pPROptExtension->m_etstrShortName.Set(pPROptExtensionBeingCopied->m_etstrShortName.Get());

                pPRRSLocal->m_arrpPROptExtension.Append(pPROptExtension);
            }
        }

        if(pPRRSBeingCopied->m_arrpPRReqExtension.Length()>0)
        {
            DWORD dwSubCounter;

            for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
            {
                pPRReqExtension=new PICSRulesReqExtension;

                if(pPRReqExtension==NULL)
                {
                    PICSRulesOutOfMemory();

                    delete pPRRSLocal;
                    pPRRSLocal = NULL;

                    return(E_OUTOFMEMORY);
                }

                pPRReqExtensionBeingCopied=pPRRSBeingCopied->m_arrpPRReqExtension[dwSubCounter];

                pPRReqExtension->m_prURLExtensionName.Set(pPRReqExtensionBeingCopied->m_prURLExtensionName.Get());
                pPRReqExtension->m_etstrShortName.Set(pPRReqExtensionBeingCopied->m_etstrShortName.Get());

                pPRRSLocal->m_arrpPRReqExtension.Append(pPRReqExtension);
            }
        }
    
        parrpPRRSDest->Append(pPRRSLocal);
    }

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\mslocusr\winnetwk.h ===
/*++

Copyright (c) 1991-1995  Microsoft Corporation

Module Name:

    winnetwk.h

Abstract:

    Standard WINNET Header File for WIN32

Environment:

    User Mode -Win32

Notes:

    optional-notes

Revision History:

    08-Oct-1991     danl
        created from winnet 3.10.05 version.

    10-Dec-1991     Johnl
        Updated to conform to Win32 Net API Spec. vers 0.4

    01-Apr-1992     JohnL
        Changed CONNECTION_REMEMBERED flag to CONNECT_UPDATE_PROFILE
        Updated WNetCancelConnection2 to match spec.

    23-Apr-1992     Johnl
        Added error code mappings.  Changed byte counts to character counts.

    27-May-1992     ChuckC
        Made into .x file.

    12-22-93        Danl
        Added WNetAddConnection3

    18-Aug-1993     LenS
        Added Windows 95 Extensions

--*/

#ifndef _WINNETWK_
#define _WINNETWK_

#ifdef __cplusplus
extern "C" {
#endif

//
// Network types
//

#define     WNNC_NET_MSNET      0x00010000
#define     WNNC_NET_LANMAN     0x00020000
#define     WNNC_NET_NETWARE    0x00030000
#define     WNNC_NET_VINES      0x00040000
#define     WNNC_NET_10NET      0x00050000
#define     WNNC_NET_LOCUS      0x00060000
#define     WNNC_NET_SUN_PC_NFS 0x00070000
#define     WNNC_NET_LANSTEP    0x00080000
#define     WNNC_NET_9TILES     0x00090000
#define     WNNC_NET_LANTASTIC  0x000A0000
#define     WNNC_NET_AS400      0x000B0000
#define     WNNC_NET_FTP_NFS    0x000C0000
#define     WNNC_NET_PATHWORKS  0x000D0000
#define     WNNC_NET_LIFENET    0x000E0000
#define     WNNC_NET_POWERLAN   0x000F0000
#define     WNNC_NET_BWNFS      0x00100000
#define     WNNC_NET_COGENT     0x00110000
#define     WNNC_NET_FARALLON	0x00120000
#define     WNNC_NET_APPLETALK	0x00130000
#define     WNNC_NET_INTERGRAPH	0x00140000
#define     WNNC_NET_SYMFONET   0x00150000

//
//  Network Resources.
//

#define RESOURCE_CONNECTED      0x00000001
#define RESOURCE_GLOBALNET      0x00000002
#define RESOURCE_REMEMBERED     0x00000003
#if(WINVER >= 0x0400)
#define RESOURCE_RECENT         0x00000004
#define RESOURCE_CONTEXT        0x00000005
#endif /* WINVER >= 0x0400 */

#define RESOURCETYPE_ANY        0x00000000
#define RESOURCETYPE_DISK       0x00000001
#define RESOURCETYPE_PRINT      0x00000002
#if(WINVER >= 0x0400)
#define RESOURCETYPE_RESERVED   0x00000008
#endif /* WINVER >= 0x0400 */
#define RESOURCETYPE_UNKNOWN    0xFFFFFFFF

#define RESOURCEUSAGE_CONNECTABLE   0x00000001
#define RESOURCEUSAGE_CONTAINER     0x00000002
#if(WINVER >= 0x0400)
#define RESOURCEUSAGE_NOLOCALDEVICE 0x00000004
#define RESOURCEUSAGE_SIBLING       0x00000008
#define RESOURCEUSAGE_ALL           (RESOURCEUSAGE_CONNECTABLE | RESOURCEUSAGE_CONTAINER)
#endif /* WINVER >= 0x0400 */
#define RESOURCEUSAGE_RESERVED      0x80000000

#define RESOURCEDISPLAYTYPE_GENERIC        0x00000000
#define RESOURCEDISPLAYTYPE_DOMAIN         0x00000001
#define RESOURCEDISPLAYTYPE_SERVER         0x00000002
#define RESOURCEDISPLAYTYPE_SHARE          0x00000003
#define RESOURCEDISPLAYTYPE_FILE           0x00000004
#define RESOURCEDISPLAYTYPE_GROUP          0x00000005
#if(WINVER >= 0x0400)
#define RESOURCEDISPLAYTYPE_NETWORK        0x00000006
#define RESOURCEDISPLAYTYPE_ROOT           0x00000007
#define RESOURCEDISPLAYTYPE_SHAREADMIN     0x00000008
#define RESOURCEDISPLAYTYPE_DIRECTORY      0x00000009
#endif /* WINVER >= 0x0400 */
#define RESOURCEDISPLAYTYPE_TREE           0x0000000A

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;
#ifdef UNICODE
typedef NETRESOURCEW NETRESOURCE;
typedef LPNETRESOURCEW LPNETRESOURCE;
#else
typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#endif // UNICODE

//
//  Network Connections.
// 

#define NETPROPERTY_PERSISTENT       1

#define CONNECT_UPDATE_PROFILE      0x00000001
#define CONNECT_UPDATE_RECENT       0x00000002
#define CONNECT_TEMPORARY           0x00000004
#define CONNECT_INTERACTIVE         0x00000008
#define CONNECT_PROMPT              0x00000010
#define CONNECT_NEED_DRIVE          0x00000020
#if(WINVER >= 0x0400)
#define CONNECT_REFCOUNT            0x00000040
#define CONNECT_REDIRECT            0x00000080
#define CONNECT_LOCALDRIVE          0x00000100
#define CONNECT_CURRENT_MEDIA       0x00000200
#endif /* WINVER >= 0x0400 */

DWORD APIENTRY
WNetAddConnectionA(
     LPCSTR   lpRemoteName,
     LPCSTR   lpPassword,
     LPCSTR   lpLocalName
    );
DWORD APIENTRY
WNetAddConnectionW(
     LPCWSTR   lpRemoteName,
     LPCWSTR   lpPassword,
     LPCWSTR   lpLocalName
    );
#ifdef UNICODE
#define WNetAddConnection  WNetAddConnectionW
#else
#define WNetAddConnection  WNetAddConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection2A(
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection2W(
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection2  WNetAddConnection2W
#else
#define WNetAddConnection2  WNetAddConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetAddConnection3A(
     HWND           hwndOwner,
     LPNETRESOURCEA lpNetResource,
     LPCSTR       lpPassword,
     LPCSTR       lpUserName,
     DWORD          dwFlags
    );
DWORD APIENTRY
WNetAddConnection3W(
     HWND           hwndOwner,
     LPNETRESOURCEW lpNetResource,
     LPCWSTR       lpPassword,
     LPCWSTR       lpUserName,
     DWORD          dwFlags
    );
#ifdef UNICODE
#define WNetAddConnection3  WNetAddConnection3W
#else
#define WNetAddConnection3  WNetAddConnection3A
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnectionA(
     LPCSTR lpName,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnectionW(
     LPCWSTR lpName,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection  WNetCancelConnectionW
#else
#define WNetCancelConnection  WNetCancelConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetCancelConnection2A(
     LPCSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
DWORD APIENTRY
WNetCancelConnection2W(
     LPCWSTR lpName,
     DWORD    dwFlags,
     BOOL     fForce
    );
#ifdef UNICODE
#define WNetCancelConnection2  WNetCancelConnection2W
#else
#define WNetCancelConnection2  WNetCancelConnection2A
#endif // !UNICODE

DWORD APIENTRY
WNetGetConnectionA(
     LPCSTR lpLocalName,
     LPSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
DWORD APIENTRY
WNetGetConnectionW(
     LPCWSTR lpLocalName,
     LPWSTR  lpRemoteName,
     LPDWORD  lpnLength
    );
#ifdef UNICODE
#define WNetGetConnection  WNetGetConnectionW
#else
#define WNetGetConnection  WNetGetConnectionA
#endif // !UNICODE

#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetUseConnectionA(
    HWND            hwndOwner,
    LPNETRESOURCEA  lpNetResource,
    LPCSTR        lpUserID,
    LPCSTR        lpPassword,
    DWORD           dwFlags,
    LPSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
DWORD APIENTRY
WNetUseConnectionW(
    HWND            hwndOwner,
    LPNETRESOURCEW  lpNetResource,
    LPCWSTR        lpUserID,
    LPCWSTR        lpPassword,
    DWORD           dwFlags,
    LPWSTR         lpAccessName,
    LPDWORD         lpBufferSize,
    LPDWORD         lpResult
    );
#ifdef UNICODE
#define WNetUseConnection  WNetUseConnectionW
#else
#define WNetUseConnection  WNetUseConnectionA
#endif // !UNICODE

DWORD APIENTRY
WNetSetConnectionA(
    LPCSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
DWORD APIENTRY
WNetSetConnectionW(
    LPCWSTR    lpName,
    DWORD       dwProperties,
    LPVOID      pvValues
    );
#ifdef UNICODE
#define WNetSetConnection  WNetSetConnectionW
#else
#define WNetSetConnection  WNetSetConnectionA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

//
//  Network Connection Dialogs.
// 

DWORD APIENTRY
WNetConnectionDialog(
    HWND  hwnd,
    DWORD dwType
    );

DWORD APIENTRY
WNetDisconnectDialog(
    HWND  hwnd,
    DWORD dwType
    );

#if(WINVER >= 0x0400)
typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEA lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTA, FAR *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       /* size of this structure in bytes */
    HWND hwndOwner;          /* owner window for the dialog */
    LPNETRESOURCEW lpConnRes;/* Requested Resource info    */
    DWORD dwFlags;           /* flags (see below) */
    DWORD dwDevNum;          /* number of devices connected to */
} CONNECTDLGSTRUCTW, FAR *LPCONNECTDLGSTRUCTW;
#ifdef UNICODE
typedef CONNECTDLGSTRUCTW CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTW LPCONNECTDLGSTRUCT;
#else
typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#endif // UNICODE

#define CONNDLG_RO_PATH     0x00000001 /* Resource path should be read-only    */
#define CONNDLG_CONN_POINT  0x00000002 /* Netware -style movable connection point enabled */
#define CONNDLG_USE_MRU     0x00000004 /* Use MRU combobox  */
#define CONNDLG_HIDE_BOX    0x00000008 /* Hide persistent connect checkbox  */

/*
 * NOTE:  Set at most ONE of the below flags.  If neither flag is set,
 *        then the persistence is set to whatever the user chose during
 *        a previous connection
 */
#define CONNDLG_PERSIST     0x00000010 /* Force persistent connection */
#define CONNDLG_NOT_PERSIST 0x00000020 /* Force connection NOT persistent */

DWORD APIENTRY
WNetConnectionDialog1A(
    LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetConnectionDialog1W(
    LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetConnectionDialog1  WNetConnectionDialog1W
#else
#define WNetConnectionDialog1  WNetConnectionDialog1A
#endif // !UNICODE

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPSTR           lpLocalName;      /* local device name */
    LPSTR           lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTA, FAR *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      /* size of this structure in bytes */
    HWND            hwndOwner;        /* owner window for the dialog */
    LPWSTR          lpLocalName;      /* local device name */
    LPWSTR          lpRemoteName;     /* network resource name */
    DWORD           dwFlags;          /* flags */
} DISCDLGSTRUCTW, FAR *LPDISCDLGSTRUCTW;
#ifdef UNICODE
typedef DISCDLGSTRUCTW DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTW LPDISCDLGSTRUCT;
#else
typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#endif // UNICODE

#define DISC_UPDATE_PROFILE         0x00000001
#define DISC_NO_FORCE               0x00000040

DWORD APIENTRY
WNetDisconnectDialog1A(
    LPDISCDLGSTRUCTA lpConnDlgStruct
    );
DWORD APIENTRY
WNetDisconnectDialog1W(
    LPDISCDLGSTRUCTW lpConnDlgStruct
    );
#ifdef UNICODE
#define WNetDisconnectDialog1  WNetDisconnectDialog1W
#else
#define WNetDisconnectDialog1  WNetDisconnectDialog1A
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

//
//  Network Browsing.
//

DWORD APIENTRY
WNetOpenEnumA(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEA lpNetResource,
     LPHANDLE       lphEnum
    );
DWORD APIENTRY
WNetOpenEnumW(
     DWORD          dwScope,
     DWORD          dwType,
     DWORD          dwUsage,
     LPNETRESOURCEW lpNetResource,
     LPHANDLE       lphEnum
    );
#ifdef UNICODE
#define WNetOpenEnum  WNetOpenEnumW
#else
#define WNetOpenEnum  WNetOpenEnumA
#endif // !UNICODE

DWORD APIENTRY
WNetEnumResourceA(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetEnumResourceW(
     HANDLE  hEnum,
     LPDWORD lpcCount,
     LPVOID  lpBuffer,
     LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetEnumResource  WNetEnumResourceW
#else
#define WNetEnumResource  WNetEnumResourceA
#endif // !UNICODE

DWORD APIENTRY
WNetCloseEnum(
    HANDLE   hEnum
    );

//
//  Universal Naming.
//

#define UNIVERSAL_NAME_INFO_LEVEL   0x00000001
#define REMOTE_NAME_INFO_LEVEL      0x00000002

typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;
#ifdef UNICODE
typedef UNIVERSAL_NAME_INFOW UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOW LPUNIVERSAL_NAME_INFO;
#else
typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#endif // UNICODE

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;
#ifdef UNICODE
typedef REMOTE_NAME_INFOW REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOW LPREMOTE_NAME_INFO;
#else
typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#endif // UNICODE

DWORD APIENTRY
WNetGetUniversalNameA(
     LPCSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
DWORD APIENTRY
WNetGetUniversalNameW(
     LPCWSTR lpLocalPath,
     DWORD    dwInfoLevel,
     LPVOID   lpBuffer,
     LPDWORD  lpBufferSize
     );
#ifdef UNICODE
#define WNetGetUniversalName  WNetGetUniversalNameW
#else
#define WNetGetUniversalName  WNetGetUniversalNameA
#endif // !UNICODE

//
//  Authentication and Logon/Logoff.
//

DWORD APIENTRY
WNetGetUserA(
     LPCSTR  lpName,
     LPSTR   lpUserName,
     LPDWORD   lpnLength
    );
DWORD APIENTRY
WNetGetUserW(
     LPCWSTR  lpName,
     LPWSTR   lpUserName,
     LPDWORD   lpnLength
    );
#ifdef UNICODE
#define WNetGetUser  WNetGetUserW
#else
#define WNetGetUser  WNetGetUserA
#endif // !UNICODE

//
// Other.
//

#if(WINVER >= 0x0400)
#define WNFMT_MULTILINE         0x01
#define WNFMT_ABBREVIATED       0x02
#define WNFMT_INENUM            0x10
#define WNFMT_CONNECTION        0x20
#endif /* WINVER >= 0x0400 */

#if(WINVER >= 0x0400)
DWORD APIENTRY
WNetGetProviderNameA(
    DWORD   dwNetType,
    LPSTR lpProviderName,
    LPDWORD lpBufferSize
    );
DWORD APIENTRY
WNetGetProviderNameW(
    DWORD   dwNetType,
    LPWSTR lpProviderName,
    LPDWORD lpBufferSize
    );
#ifdef UNICODE
#define WNetGetProviderName  WNetGetProviderNameW
#else
#define WNetGetProviderName  WNetGetProviderNameA
#endif // !UNICODE

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    DWORD dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT, FAR *LPNETINFOSTRUCT;

#define NETINFO_DLL16       0x00000001  /* Provider running as 16 bit Winnet Driver */
#define NETINFO_DISKRED     0x00000004  /* Provider requires disk redirections to connect */
#define NETINFO_PRINTERRED  0x00000008  /* Provider requires printer redirections to connect */

DWORD APIENTRY
WNetGetNetworkInformationA(
    LPCSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
DWORD APIENTRY
WNetGetNetworkInformationW(
    LPCWSTR          lpProvider,
    LPNETINFOSTRUCT   lpNetInfoStruct
    );
#ifdef UNICODE
#define WNetGetNetworkInformation  WNetGetNetworkInformationW
#else
#define WNetGetNetworkInformation  WNetGetNetworkInformationA
#endif // !UNICODE

//
//  User Profiles.
//

typedef UINT (FAR PASCAL *PFNGETPROFILEPATHA) (
    LPCSTR    pszUsername,
    LPSTR     pszBuffer,
    UINT        cbBuffer
    );
typedef UINT (FAR PASCAL *PFNGETPROFILEPATHW) (
    LPCWSTR    pszUsername,
    LPWSTR     pszBuffer,
    UINT        cbBuffer
    );
#ifdef UNICODE
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHW
#else
#define PFNGETPROFILEPATH  PFNGETPROFILEPATHA
#endif // !UNICODE

typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEA) (
    LPCSTR    pszCentralFile,
    LPCSTR    pszLocalFile,
    DWORD       dwFlags
    );
typedef UINT (FAR PASCAL *PFNRECONCILEPROFILEW) (
    LPCWSTR    pszCentralFile,
    LPCWSTR    pszLocalFile,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEW
#else
#define PFNRECONCILEPROFILE  PFNRECONCILEPROFILEA
#endif // !UNICODE

#define RP_LOGON    0x01        /* if set, do for logon, else for logoff */
#define RP_INIFILE  0x02        /* if set, reconcile .INI file, else reg. hive */

//
//  Policies.
//

typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESA) (
    HWND        hwnd,
    LPCSTR    pszPath,
    LPCSTR    pszUsername,
    LPCSTR    pszComputerName,
    DWORD       dwFlags
    );
typedef BOOL (FAR PASCAL *PFNPROCESSPOLICIESW) (
    HWND        hwnd,
    LPCWSTR    pszPath,
    LPCWSTR    pszUsername,
    LPCWSTR    pszComputerName,
    DWORD       dwFlags
    );
#ifdef UNICODE
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESW
#else
#define PFNPROCESSPOLICIES  PFNPROCESSPOLICIESA
#endif // !UNICODE

#define PP_DISPLAYERRORS    0x01    /* if set, display error messages, else fail silently if error */
#endif /* WINVER >= 0x0400 */

//
//  Error handling.
// 

DWORD APIENTRY
WNetGetLastErrorA(
     LPDWORD    lpError,
     LPSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
DWORD APIENTRY
WNetGetLastErrorW(
     LPDWORD    lpError,
     LPWSTR    lpErrorBuf,
     DWORD      nErrorBufSize,
     LPWSTR    lpNameBuf,
     DWORD      nNameBufSize
    );
#ifdef UNICODE
#define WNetGetLastError  WNetGetLastErrorW
#else
#define WNetGetLastError  WNetGetLastErrorA
#endif // !UNICODE

//
//  STATUS CODES
//

// General   

#define WN_SUCCESS                      NO_ERROR
#define WN_NO_ERROR                     NO_ERROR
#define WN_NOT_SUPPORTED                ERROR_NOT_SUPPORTED
#define WN_CANCEL                       ERROR_CANCELLED
#define WN_RETRY                        ERROR_RETRY
#define WN_NET_ERROR                    ERROR_UNEXP_NET_ERR
#define WN_MORE_DATA                    ERROR_MORE_DATA
#define WN_BAD_POINTER                  ERROR_INVALID_ADDRESS
#define WN_BAD_VALUE                    ERROR_INVALID_PARAMETER
#define WN_BAD_USER                     ERROR_BAD_USERNAME
#define WN_BAD_PASSWORD                 ERROR_INVALID_PASSWORD
#define WN_ACCESS_DENIED                ERROR_ACCESS_DENIED
#define WN_FUNCTION_BUSY                ERROR_BUSY
#define WN_WINDOWS_ERROR                ERROR_UNEXP_NET_ERR
#define WN_OUT_OF_MEMORY                ERROR_NOT_ENOUGH_MEMORY
#define WN_NO_NETWORK                   ERROR_NO_NETWORK
#define WN_EXTENDED_ERROR               ERROR_EXTENDED_ERROR
#define WN_BAD_LEVEL                    ERROR_INVALID_LEVEL
#define WN_BAD_HANDLE                   ERROR_INVALID_HANDLE
#if(WINVER >= 0x0400)
#define WN_NOT_INITIALIZING             ERROR_ALREADY_INITIALIZED
#define WN_NO_MORE_DEVICES              ERROR_NO_MORE_DEVICES
#endif /* WINVER >= 0x0400 */

// Connection

#define WN_NOT_CONNECTED                ERROR_NOT_CONNECTED
#define WN_OPEN_FILES                   ERROR_OPEN_FILES
#define WN_DEVICE_IN_USE                ERROR_DEVICE_IN_USE
#define WN_BAD_NETNAME                  ERROR_BAD_NET_NAME
#define WN_BAD_LOCALNAME                ERROR_BAD_DEVICE
#define WN_ALREADY_CONNECTED            ERROR_ALREADY_ASSIGNED
#define WN_DEVICE_ERROR                 ERROR_GEN_FAILURE
#define WN_CONNECTION_CLOSED            ERROR_CONNECTION_UNAVAIL
#define WN_NO_NET_OR_BAD_PATH           ERROR_NO_NET_OR_BAD_PATH
#define WN_BAD_PROVIDER                 ERROR_BAD_PROVIDER
#define WN_CANNOT_OPEN_PROFILE          ERROR_CANNOT_OPEN_PROFILE
#define WN_BAD_PROFILE                  ERROR_BAD_PROFILE
#define WN_BAD_DEV_TYPE                 ERROR_BAD_DEV_TYPE
#define WN_DEVICE_ALREADY_REMEMBERED    ERROR_DEVICE_ALREADY_REMEMBERED

// Enumeration

#define WN_NO_MORE_ENTRIES              ERROR_NO_MORE_ITEMS
#define WN_NOT_CONTAINER                ERROR_NOT_CONTAINER

#if(WINVER >= 0x0400)
// Authentication

#define WN_NOT_AUTHENTICATED            ERROR_NOT_AUTHENTICATED
#define WN_NOT_LOGGED_ON                ERROR_NOT_LOGGED_ON
#define WN_NOT_VALIDATED                ERROR_NO_LOGON_SERVERS
#endif /* WINVER >= 0x0400 */

//
//  For Shell
//

#if(WINVER >= 0x0400)
typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;

#define WNCON_FORNETCARD        0x00000001
#define WNCON_NOTROUTED         0x00000002
#define WNCON_SLOWLINK          0x00000004
#define WNCON_DYNAMIC           0x00000008

DWORD APIENTRY
MultinetGetConnectionPerformanceA(
        LPNETRESOURCEA lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
DWORD APIENTRY
MultinetGetConnectionPerformanceW(
        LPNETRESOURCEW lpNetResource,
        LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
        );
#ifdef UNICODE
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceW
#else
#define MultinetGetConnectionPerformance  MultinetGetConnectionPerformanceA
#endif // !UNICODE
#endif /* WINVER >= 0x0400 */

#ifdef __cplusplus
}
#endif

#endif  // _WINNETWK_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_
EXTERN_C PROPSHEETPAGE* Whistler_CreatePropSheetPageStruct(HINSTANCE hinst);

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\advdlg.h ===
/****************************************************************************\
 *
 *   advdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Advanced Property Page
 *
\****************************************************************************/

#ifndef ADVANCED_DIALOG_H
#define ADVANCED_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CAdvancedDialog : public CBasePropertyPage<IDD_ADVANCED>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CAdvancedDialog( PRSD * p_pPRSD );

public:
    typedef CAdvancedDialog thisClass;
    typedef CBasePropertyPage<IDD_ADVANCED> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_USER, OnUser)

        COMMAND_HANDLER(IDC_3RD_COMBO, CBN_EDITCHANGE, OnMarkChanged)
        COMMAND_HANDLER(IDC_3RD_COMBO, CBN_SELENDOK, OnMarkChanged)
        COMMAND_HANDLER(IDC_PICSRULES_LIST, LBN_SELCHANGE, OnSelChange)

        COMMAND_ID_HANDLER(IDC_PICSRULES_UP, OnPicsRulesUp)
        COMMAND_ID_HANDLER(IDC_PICSRULES_DOWN, OnPicsRulesDown)
        COMMAND_ID_HANDLER(IDC_PICSRULESEDIT, OnPicsRulesEdit)
        COMMAND_ID_HANDLER(IDC_PICSRULESOPEN, OnPicsRulesOpen)

        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPicsRulesUp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesDown(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesOpen(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    InstallRatingBureauHelper( void );
    void    DeinstallRatingBureauHelper( void );
    UINT    FillBureauList( PicsRatingSystemInfo *pPRSI );

    HRESULT CopySubPolicyExpression(PICSRulesPolicyExpression * pPRSubPolicyExpression,
                                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy,
                                PICSRulesRatingSystem * pPRRSLocal,
                                PICSRulesPolicy * pPRPolicy);
    HRESULT CopyArrayPRRSStructures(array<PICSRulesRatingSystem*> * parrpPRRSDest,
                                array<PICSRulesRatingSystem*> * parrpPRRSSource);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\apprdlg.h ===
/****************************************************************************\
 *
 *   apprdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Approved Sites Property Page
 *
\****************************************************************************/

#ifndef APPROVED_SITES_DIALOG_H
#define APPROVED_SITES_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CApprovedSitesDialog : public CBasePropertyPage<IDD_APPROVEDSITES>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CApprovedSitesDialog( PRSD * p_pPRSD );

public:
    typedef CApprovedSitesDialog thisClass;
    typedef CBasePropertyPage<IDD_APPROVEDSITES> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_HANDLER(IDC_PICSRULESAPPROVEDEDIT, EN_UPDATE, OnPicsRulesEditUpdate)

        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDNEVER, OnPicsRulesApprovedNever)
        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDALWAYS, OnPicsRulesApprovedAlways)
        COMMAND_ID_HANDLER(IDC_PICSRULESAPPROVEDREMOVE, OnPicsRulesApprovedRemove)

        NOTIFY_HANDLER(IDC_PICSRULESAPPROVEDLIST, LVN_ITEMCHANGED, OnPicsRulesListChanged)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    void    SetListImages( HIMAGELIST hImageList );
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnPicsRulesEditUpdate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedNever(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedAlways(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPicsRulesApprovedRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPicsRulesListChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    ShowBadUrl( void );
    HRESULT PICSRulesApprovedSites( BOOL fAlwaysNever );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\basedlg.h ===
/****************************************************************************\
 *
 *   basedlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Base Property Page
 *
\****************************************************************************/

#ifndef BASE_DIALOG_H
#define BASE_DIALOG_H

#include "apithk.h"

class CCommonDialogRoutines
{
public:
    void ShowHideWindow( HWND hwndDlg, int iCtrl, BOOL fEnable )
    {
        HWND            hCtrl = ::GetDlgItem( hwndDlg, iCtrl );

        ASSERT( hCtrl );

        if ( hCtrl )
        {
            ::EnableWindow( hCtrl, fEnable );
            ::ShowWindow( hCtrl, fEnable ? SW_SHOW : SW_HIDE );
        }
    }

    void SetErrorFocus( HWND hwndDlg, int iCtrl )
    {
        HWND            hCtrl = ::GetDlgItem( hwndDlg, iCtrl );

        ASSERT( hCtrl );

        if ( hCtrl )
        {
            ::SetFocus( hCtrl );
            ::SendMessage( hCtrl, EM_SETSEL, 0, -1 );
        }
    }
};

template <WORD t_wDlgTemplateID>
class CBasePropertyPage : public CPropertyPage<t_wDlgTemplateID>
{
private:
    PROPSHEETPAGE   * m_ppsPage;

public:
    typedef CBasePropertyPage<t_wDlgTemplateID> thisClass;
    typedef CPropertyPage<t_wDlgTemplateID> baseClass;

    BEGIN_MSG_MAP(thisClass)
        CHAIN_MSG_MAP_ALT(baseClass, 0)
    END_MSG_MAP()

    CBasePropertyPage(_U_STRINGorID title = (LPCTSTR)NULL) : CPropertyPage<t_wDlgTemplateID>(title)
    {
        m_ppsPage = NULL;
    }

    ~CBasePropertyPage()
    {
        if ( m_ppsPage )
        {
            LocalFree( m_ppsPage );
            m_ppsPage = NULL;
        }
    }

    operator PROPSHEETPAGE*() { return m_ppsPage; }

    // Override to insure Luna works!
    HPROPSHEETPAGE Create()
    {
        HINSTANCE           hinst = _Module.GetResourceInstance();

        ASSERT( hinst );

        ASSERT( ! m_ppsPage );

        m_ppsPage = Whistler_CreatePropSheetPageStruct( hinst );

        if ( ! m_ppsPage )
        {
            TraceMsg( TF_ERROR, "CBasePropertyPage::Create() - m_ppsPage could not be created!" );
            return 0;
        }

        m_ppsPage->dwFlags = PSP_USECALLBACK;
        m_ppsPage->hInstance = hinst;
        baseClass * pT = static_cast<baseClass *>(this);
        pT;	// avoid level 4 warning
        m_ppsPage->pszTemplate = MAKEINTRESOURCE(pT->IDD);
        m_ppsPage->pfnDlgProc = (DLGPROC)baseClass::StartDialogProc;
        m_ppsPage->pfnCallback = baseClass::PropPageCallback;
        m_ppsPage->lParam = (LPARAM)this;

        return ::CreatePropertySheetPage( m_ppsPage );
    }

protected:
    void MarkChanged()
    {
        SendMessage( GetParent(), PSM_CHANGED, (WPARAM) m_hWnd, 0 );
    }

    void ShowHideControl( int iCtrl, BOOL fEnable )
    {
        CCommonDialogRoutines       cdr;

        cdr.ShowHideWindow( m_hWnd, iCtrl, fEnable );
    }
};

template <class TDerived>
class CBaseDialog : public CDialogImpl<TDerived>
{
public:
    typedef CBaseDialog<TDerived> thisClass;
    typedef CDialogImpl<TDerived> baseClass;

    BEGIN_MSG_MAP(thisClass)
//      CHAIN_MSG_MAP_ALT(baseClass, 0)
    END_MSG_MAP()

protected:
    void ShowHideControl( int iCtrl, BOOL fEnable )
    {
        CCommonDialogRoutines       cdr;

        cdr.ShowHideWindow( m_hWnd, iCtrl, fEnable );
    }

    void SetErrorControl( int iCtrl )
    {
        CCommonDialogRoutines       cdr;

        cdr.SetErrorFocus( m_hWnd, iCtrl );
    }

    void ReduceDialogHeight( int iCtrl )
    {
        RECT            rectControlBox;

        ASSERT( GetDlgItem( iCtrl ) );

        ::GetWindowRect( GetDlgItem( iCtrl ), &rectControlBox );

        RECT            rectWindow;

        GetWindowRect( &rectWindow );

        int nNewHeight = ( rectControlBox.bottom - rectWindow.top ) + 8;

        RECT            rectSize;

        GetClientRect( &rectSize );

        rectSize.bottom = nNewHeight;

        SetWindowPos( NULL, &rectSize, SWP_NOMOVE | SWP_NOZORDER );
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\chngdlg.h ===
/****************************************************************************\
 *
 *   chngdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Change Password Dialog
 *
\****************************************************************************/

#ifndef CHANGE_PASSWORD_DIALOG_H
#define CHANGE_PASSWORD_DIALOG_H

#include "basedlg.h"        // CBaseDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

static DWORD aIdsChangePassword[] = {
    IDC_STATIC5,            IDH_IGNORE,
    IDC_STATIC1,            IDH_RATINGS_CHANGE_PASSWORD_OLD,
    IDC_OLD_PASSWORD,       IDH_RATINGS_CHANGE_PASSWORD_OLD,
    IDC_STATIC2,            IDH_RATINGS_CHANGE_PASSWORD_NEW,
    IDC_PASSWORD,           IDH_RATINGS_CHANGE_PASSWORD_NEW,
    IDC_STATIC4,            IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD,
    IDC_CREATE_PASSWORD,    IDH_RATINGS_SUPERVISOR_CREATE_PASSWORD,
    IDC_STATIC3,            IDH_RATINGS_CHANGE_PASSWORD_CONFIRM,
    IDC_CONFIRM_PASSWORD,   IDH_RATINGS_CHANGE_PASSWORD_CONFIRM,
    IDC_OLD_HINT_LABEL,     IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,      IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_HINT_TEXT,          IDH_IGNORE,
    IDC_HINT_LABEL,         IDH_RATINGS_ENTER_PW_HINT,
    IDC_HINT_EDIT,          IDH_RATINGS_ENTER_PW_HINT,
    0,0
};

template <WORD t_wDlgTemplateID>
class CChangePasswordDialog: public CBaseDialog<CChangePasswordDialog>
{
public:
    enum { IDD = t_wDlgTemplateID };

public:
    CChangePasswordDialog()     { /* Add Construction Here */ }

public:
    typedef CChangePasswordDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOK)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if(GetDlgItem(IDC_OLD_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_OLD_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_CONFIRM_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_CONFIRM_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }
        if(GetDlgItem(IDC_CREATE_PASSWORD)!=NULL)
        {
            SendDlgItemMessage(IDC_CREATE_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }

        // Display previously created hint (if one exists).
        {
            CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

            oldHint.DisplayHint();
        }

        // Set the length of the new hint.
        {
            CHint       newHint( m_hWnd, IDC_HINT_EDIT );

            newHint.InitHint();
        }

        bHandled = FALSE;
        return 1L;  // Let the system set the focus
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(FALSE);
        return 0L;
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        CHAR pszPassword[MAXPATHLEN];
        CHAR pszTempPassword[MAXPATHLEN];
        CHAR *p = NULL;
        HRESULT hRet;
        HWND hwndPassword;
        int iPasswordCtrl;
        HWND hDlg = m_hWnd;

        iPasswordCtrl = IDC_PASSWORD;
        hwndPassword = ::GetDlgItem( hDlg, iPasswordCtrl );

        if (hwndPassword == NULL)
        {
            iPasswordCtrl = IDC_CREATE_PASSWORD;
            hwndPassword = ::GetDlgItem( hDlg, iPasswordCtrl );
        }

        ASSERT( hwndPassword );

        ::GetWindowText(hwndPassword, pszPassword, sizeof(pszPassword));
        GetDlgItemText(IDC_CONFIRM_PASSWORD, pszTempPassword, sizeof(pszTempPassword));

        /* if they've typed just the first password but not the
         * second, let Enter take them to the second field
         */
        if (*pszPassword && !*pszTempPassword && GetFocus() == hwndPassword)
        {
            SetErrorControl( IDC_CONFIRM_PASSWORD );
            return 0L;
        }

        if (strcmpf(pszPassword, pszTempPassword))
        {
            MyMessageBox(hDlg, IDS_NO_MATCH, IDS_GENERIC, MB_OK);
            SetErrorControl( IDC_CONFIRM_PASSWORD );
            return 0L;
        }

        if (*pszPassword=='\0')
        {
            MyMessageBox(hDlg, IDS_NO_NULL_PASSWORD, IDS_GENERIC, MB_OK);
            SetErrorControl( iPasswordCtrl );
            return 0L;
        }

        if ( SUCCEEDED( VerifySupervisorPassword() ) )
        {
            GetDlgItemText(IDC_OLD_PASSWORD, pszTempPassword, sizeof(pszTempPassword));
            p = pszTempPassword;
        }

        // Verify the Newly Added Hint.
        CHint       newHint( hDlg, IDC_HINT_EDIT );

        if ( ! newHint.VerifyHint() )
        {
            TraceMsg( TF_ALWAYS, "CChangePasswordDialog::OnOK() - User requested to fill in hint." );
            return 0L;
        }

        hRet = ChangeSupervisorPassword(p, pszPassword);
    
        if (SUCCEEDED(hRet))
        {
            // Save the Newly Added Hint.
            newHint.SaveHint();

            EndDialog(TRUE);
        }
        else
        {
            MyMessageBox(hDlg, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);
            SetErrorControl( IDC_OLD_PASSWORD );
        }

        return 0L;
    }

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIdsChangePassword);

        return 0L;
    }

    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
                (DWORD_PTR)(LPVOID)aIdsChangePassword);

        return 0L;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\comobj.cpp ===
#include "msrating.h"
#include "ratings.h"
#include "rors.h"

#include "msluglob.h"
#include "mslubase.h"

#include <advpub.h>
#include <atlmisc.h>        // CString

STDMETHODIMP CLUClassFactory::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CLUClassFactory::AddRef(void)
{
    RefThisDLL(TRUE);

    return 1;
}


STDMETHODIMP_(ULONG) CLUClassFactory::Release(void)
{
    RefThisDLL(FALSE);

    return 1;
}


STDMETHODIMP CLUClassFactory::CreateInstance(
    /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    if (NULL != pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    CRORemoteSite *pObj = new CRORemoteSite;

    if (NULL == pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    HRESULT hr = pObj->QueryInterface(riid, ppvObject);

    if (FAILED(hr)) {
        delete pObj;
        pObj = NULL;
    }

    return hr;
}

        
STDMETHODIMP CLUClassFactory::LockServer( 
    /* [in] */ BOOL fLock)
{
    LockThisDLL(fLock);

    return NOERROR;
}

HRESULT CallRegInstall(LPSTR pszSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szIEPath[MAX_PATH];
            STRENTRY seReg[] = {
                { "MSIEXPLORE", szIEPath },

                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            lstrcpy(szIEPath,"iexplore.exe");

            if ( RunningOnNT() ) //are we on NT?
            {
                // If on NT, we want custom action for %25% %11%
                // so that it uses %SystemRoot% in writing the
                // path to the registry.
                stReg.cEntries += 2;
            }

            hr = pfnri(g_hInstance, pszSection, &stReg);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

extern "C" {

STDAPI DllRegisterServer(void)
{
    HKEY hkeyCLSID;
    HKEY hkeyOurs;
    HKEY hkeyInproc;
    LONG err;

    err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
    if (err == ERROR_SUCCESS)
    {
        err = ::RegCreateKey(hkeyCLSID, ::szRORSGUID, &hkeyOurs);
        if (err == ERROR_SUCCESS)
        {
            err = ::RegCreateKey(hkeyOurs, ::szINPROCSERVER32, &hkeyInproc);
            if (err == ERROR_SUCCESS)
            {
                DWORD           dwType;
                CString         strDLL;
                int             cchNull;

                if ( RunningOnNT() )
                {
                    dwType = REG_EXPAND_SZ;
                    strDLL = CString( ::szNTRootDir ) + CString( ::szDLLNAME );
                    cchNull = 0;
                }
                else
                {
                    dwType = REG_SZ;

                    strDLL = CString( ::sz9XRootDir ) + CString( ::szDLLNAME );

                    TCHAR           tchDLL[ MAX_PATH + 1 ];
                    int             cchDLL;

                    tchDLL[0] = '\0';

                    cchDLL = ::ExpandEnvironmentStrings( strDLL, tchDLL, MAX_PATH + 1 );

                    if ( cchDLL == 0 || cchDLL > MAX_PATH || strDLL == tchDLL )
                    {
                        strDLL = ::szDLLNAME;
                    }
                    else
                    {
                        strDLL = tchDLL;
                    }

                    cchNull = 1;
                }

                err = ::RegSetValueEx(hkeyInproc, NULL, 0, dwType,
                                      (LPBYTE) (LPCTSTR) strDLL, strDLL.GetLength() + cchNull );
                if (err == ERROR_SUCCESS)
                {
                    err = ::RegSetValueEx(hkeyInproc, ::szTHREADINGMODEL, 0,
                                          REG_SZ, (LPBYTE)::szAPARTMENT,
                                          ::strlenf(::szAPARTMENT) + cchNull );
                }

                ::RegCloseKey(hkeyInproc);
            }

            ::RegCloseKey(hkeyOurs);
        }

        ::RegCloseKey(hkeyCLSID);
    }

    CallRegInstall("InstallAssociations");

    if (err == ERROR_SUCCESS)
        return S_OK;
    else
        return HRESULT_FROM_WIN32(err);
}


STDAPI DllUnregisterServer(void)
{
    HKEY hkeyCLSID;
    HKEY hkeyOurs;
    LONG err;

    err = ::RegOpenKey(HKEY_CLASSES_ROOT, ::szCLSID, &hkeyCLSID);
    if (err == ERROR_SUCCESS)
    {
        err = ::RegOpenKey(hkeyCLSID, ::szRORSGUID, &hkeyOurs);
        if (err == ERROR_SUCCESS)
        {
            err = ::RegDeleteKey(hkeyOurs, ::szINPROCSERVER32);

            ::RegCloseKey(hkeyOurs);

            if (err == ERROR_SUCCESS)
            {
                err = ::RegDeleteKey(hkeyCLSID, ::szRORSGUID);
            }
        }

        ::RegCloseKey(hkeyCLSID);
    }

    CallRegInstall("UnInstallAssociations");

    if (err == ERROR_SUCCESS)
        return S_OK;
    else
        return HRESULT_FROM_WIN32(err);
}


STDAPI DllCanUnloadNow(void)
{
    SCODE sc;

    sc = (0 == g_cRefThisDll && 0 == g_cLocks) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}


STDAPI DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR *ppv)
{
    if (!IsEqualCLSID(rclsid, CLSID_RemoteSite)) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    static CLUClassFactory cf;

    *ppv = (LPVOID)&cf;

    cf.AddRef();

    return NOERROR;
}

};  /* extern "C" */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\array.h ===
/****************************************************************************\
 *
 *   ARRAY.H ---Class declaration for the array structure
 *     
\****************************************************************************/

#ifndef _ARRAY_H
#define _ARRAY_H

/*Interface-------------------------------------------------------------------*/
template <class T>
class array {
    private:
        int nLen, nMax;
        T   *pData;
        void Destruct();
    public:
        array();
        ~array();

        BOOL Append(T v);
        int  Length() const;
        void ClearAll();
        void DeleteAll();

        T& operator[](int index);
};

/*definitions of everything*/

#ifndef ARRAY_CXX
#define ARRAY_CXX

/*Implementation------------------------------------------------------------*/
template <class T>
array<T>::array(){
    nLen  = nMax = 0;
    pData = NULL;
}

template <class T>
inline array<T>::~array() {
    if (pData) ::MemFree(pData);
    pData = NULL;
    nMax  = nLen = 0;
}

template <class T>
inline int array<T>::Length() const{
    return nLen;
}

template <class T>
inline T& array<T>::operator[](int index){
    ASSERT(index<Length());
    ASSERT(index>=0);
    ASSERT(pData);
    return pData[index];
}

template <class T>
BOOL array<T>::Append(T v) {
    if (nLen == nMax){
        nMax  = nMax + 8;            /* grow by bigger chunks */
        T* pNew = (T*)::MemReAlloc(pData, sizeof(T)*nMax);
        if (pNew == NULL)
            return FALSE;
        pData = pNew;
    }
    ASSERT(pData);
    ASSERT(nMax);
    pData[nLen++] = v;
    return TRUE;
}

template <class T>
void array<T>::Destruct(){
    while (nLen){
        delete pData[--nLen];
    }
}

template <class T>
inline void array<T>::ClearAll() {
    nLen = 0;
}

template <class T>
inline void array<T>::DeleteAll() {
    Destruct();
}

#endif 
/* ARRAY_CXX */


#endif 
/* _ARRAY_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\apprdlg.cpp ===
/****************************************************************************\
 *
 *   apprdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Approved Sites Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "apprdlg.h"        // CApprovedSitesDialog
#include "debug.h"          // TraceMsg()
#include "parselbl.h"
#include "picsrule.h"
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()
#include <wininet.h>
#include <comctrlp.h>


// $BUG - These should not be global variables but within CApprovedSitesDialog
int                                     g_iAllowAlways,g_iAllowNever;

// $KLUDGE begins -- These should not be a global set outside the class!!
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

extern HMODULE                          g_hURLMON,g_hWININET;
// $KLUDGE ends -- These should not be a global set outside the class!!

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

// useful macro for getting rid of leaks.
#define SAFEDELETE(ptr)             \
            if(ptr)                 \
            {                       \
                delete ptr;         \
                ptr = NULL;         \
            }                       

DWORD CApprovedSitesDialog::aIds[] = {
    IDC_STATIC1,                    IDH_IGNORE,
    IDC_STATIC2,                    IDH_IGNORE,
    IDC_STATIC_ALLOW,               IDH_PICSRULES_APPROVEDEDIT,
    IDC_PICSRULESAPPROVEDEDIT,      IDH_PICSRULES_APPROVEDEDIT,
    IDC_PICSRULESAPPROVEDALWAYS,    IDH_PICSRULES_APPROVEDALWAYS,
    IDC_PICSRULESAPPROVEDNEVER,     IDH_PICSRULES_APPROVEDNEVER,
    IDC_STATIC_LIST,                IDH_PICSRULES_APPROVEDLIST,
    IDC_PICSRULESAPPROVEDLIST,      IDH_PICSRULES_APPROVEDLIST,
    IDC_PICSRULESAPPROVEDREMOVE,    IDH_PICSRULES_APPROVEDREMOVE,
    0,0
};

CApprovedSitesDialog::CApprovedSitesDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

void CApprovedSitesDialog::SetListImages( HIMAGELIST hImageList )
{
    HIMAGELIST hOldImageList;

    hOldImageList = ListView_SetImageList( GetDlgItem(IDC_PICSRULESAPPROVEDLIST), hImageList, LVSIL_SMALL );

    if ( hOldImageList != NULL )
    {
        ImageList_Destroy( hOldImageList );
    }
}

LRESULT CApprovedSitesDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    HICON      hIcon;
    HIMAGELIST  hImageList;
    UINT flags = 0;
    HWND hDlg = m_hWnd;

    ListView_SetBkColor(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                        GetSysColor(COLOR_WINDOW));
    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }

    hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON),
                                  flags,
                                  2,
                                  0);

    hIcon=(HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

    g_iAllowAlways=ImageList_AddIcon( hImageList, hIcon ); 
    DestroyIcon(hIcon); 

    hIcon=(HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_ACCEPTNEVER),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_iAllowNever=ImageList_AddIcon( hImageList, hIcon );
    DestroyIcon(hIcon); 

    SetListImages( hImageList );

    return 0L;
}

LRESULT CApprovedSitesDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    RECT        Rect;
    HDC         hDC;
    LV_COLUMN   lvColumn;
    TEXTMETRIC  tm;
    HICON       hIcon;
    HIMAGELIST  hImageList;
    int         iCounter;
    UINT flags = 0;
    HWND hDlg = m_hWnd;

//  if (m_pPRSD && m_pPRSD->pPU != NULL) {
        //set defaults for controls
//  }

    ::GetWindowRect(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),&Rect);

    tm.tmAveCharWidth=0;
    if(hDC=GetDC())
    {
        GetTextMetrics(hDC,&tm);
        ReleaseDC(hDC);
    }

    lvColumn.mask=LVCF_FMT|LVCF_WIDTH;
    lvColumn.fmt=LVCFMT_LEFT;
    lvColumn.cx=Rect.right-Rect.left
                -GetSystemMetrics(SM_CXVSCROLL)
                -GetSystemMetrics(SM_CXSMICON)
                -tm.tmAveCharWidth;

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                       LVM_INSERTCOLUMN,
                       (WPARAM) 0,
                       (LPARAM) &lvColumn);

    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }

    hImageList = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
                                  GetSystemMetrics(SM_CYSMICON),
                                  flags,
                                  2,
                                  0);

    hIcon=(HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_ACCEPTALWAYS),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);

    g_iAllowAlways = ImageList_AddIcon( hImageList, hIcon );
    DestroyIcon(hIcon); 

    hIcon=(HICON) LoadImage(g_hInstance,
                            MAKEINTRESOURCE(IDI_ACCEPTNEVER),
                            IMAGE_ICON,
                            16,
                            16,
                            LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_iAllowNever = ImageList_AddIcon( hImageList, hIcon );
    DestroyIcon(hIcon); 

    SetListImages( hImageList );

    //disable the remove button until someone selects something
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDREMOVE),FALSE);
    
    //disable the always and never buttons until someone types something
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),FALSE);
    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),FALSE);

    if(g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;

        g_pApprovedPRRSPreApply=NULL;
    }

    if(g_lApprovedSitesGlobalCounterValue!=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter))
    {
        PICSRulesRatingSystem * pPRRS=NULL;
        HRESULT               hRes;

        hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            if(g_pApprovedPRRS!=NULL)
            {
                delete g_pApprovedPRRS;
            }

            g_pApprovedPRRS=pPRRS;
        }

        g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);
    }

    if(g_pApprovedPRRS==NULL)
    {
        //nothing to do
        return 1L;
    }

    //copy master list to the PreApply list
    if(g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;
    }

    g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;

    if (g_pApprovedPRRSPreApply==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return 1L;
    }

    for(iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
        PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
        PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

        pPRPolicy=new PICSRulesPolicy;
        
        if(pPRPolicy==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        pPRPolicyToCopy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];
        
        pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

        pPRByURL=new PICSRulesByURL;
        
        if(pPRByURL==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            
            pPRPolicy->m_pPRAcceptByURL=pPRByURL;
        }
        else
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;

            pPRPolicy->m_pPRRejectByURL=pPRByURL;
        }

        pPRByURLExpression=new PICSRulesByURLExpression;

        if(pPRByURLExpression==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return 1L;
        }

        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

        if(pPRByURLExpressionToCopy==NULL)
        {
            //we shouldn't ever get here

            MyMessageBox(m_hWnd, IDS_PICSRULES_NOAPPROVEDSAVE, IDS_ERROR, MB_OK|MB_ICONERROR);

            delete pPRPolicy;
            pPRPolicy = NULL;

            return 1L;
        }

        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

        
        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

        g_pApprovedPRRSPreApply->m_arrpPRPolicy.Append(pPRPolicy);
    }

    //fill in the listview with known items
    for(iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
    {
        BOOL                        fAcceptReject;
        PICSRulesPolicy             * pPRPolicy;
        PICSRulesByURLExpression    * pPRByURLExpression;
        LV_ITEM                     lvItem;

        pPRPolicy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            fAcceptReject=PICSRULES_ALWAYS;

            pPRByURLExpression=pPRPolicy->m_pPRAcceptByURL->m_arrpPRByURL[0];
        }
        else
        {
            fAcceptReject=PICSRULES_NEVER;

            pPRByURLExpression=pPRPolicy->m_pPRRejectByURL->m_arrpPRByURL[0];
        }

        ZeroMemory(&lvItem,sizeof(lvItem));

        lvItem.mask=LVIF_TEXT|LVIF_IMAGE;
        lvItem.pszText=pPRByURLExpression->m_etstrURL.Get();

        if(fAcceptReject==PICSRULES_NEVER)
        {
            lvItem.iImage=g_iAllowNever;
        }
        else
        {
            lvItem.iImage=g_iAllowAlways;
        }

        if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                              LVM_INSERTITEM,
                              (WPARAM) 0,
                              (LPARAM) &lvItem)==-1)
        {
            return 1L;
        }

    }

    // Set the column width to satisfy longest element
    ListView_SetColumnWidth(
                    GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                    0,
                    LVSCW_AUTOSIZE);

    // set focus to first item in list
    ListView_SetItemState(
                    GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                    0,
                    LVIS_FOCUSED,
                    LVIS_FOCUSED);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CApprovedSitesDialog::OnPicsRulesEditUpdate(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    INT_PTR iCount;

    iCount=SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                              WM_GETTEXTLENGTH,
                              (WPARAM) 0,
                              (LPARAM) 0);

    if(iCount>0)
    {
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),TRUE);
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),TRUE);
    }
    else
    {
        ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                           EM_SETSEL,
                           (WPARAM) 0,
                           (LPARAM) -1);

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDNEVER,
                           BM_SETSTYLE,
                           (WPARAM) BS_PUSHBUTTON,
                           (LPARAM) MAKELPARAM(TRUE,0));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDALWAYS,
                           BM_SETSTYLE,
                           (WPARAM) BS_PUSHBUTTON,
                           (LPARAM) MAKELPARAM(TRUE,0));

        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDNEVER),FALSE);
        ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDALWAYS),FALSE);
    }

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedNever(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hRes;

    hRes=PICSRulesApprovedSites(PICSRULES_NEVER);

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedAlways(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HRESULT hRes;

    hRes=PICSRulesApprovedSites(PICSRULES_ALWAYS);

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesApprovedRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int                     iNumApproved,iCounter,iNumSelected,
                            iSubCounter,iItem=-1;
    LPTSTR                  lpszRemoveURL;
    LV_ITEM                 lvItem;
    PICSRulesRatingSystem   * pNewApprovedPRRS;

    if(g_pApprovedPRRSPreApply==NULL)
    {
        //nothing to do
        return 1L;
    }

    iNumApproved=g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();

    iNumSelected=ListView_GetSelectedCount(GetDlgItem(IDC_PICSRULESAPPROVEDLIST));

    if(iNumSelected==0)
    {
        //nothing to do
        return 1L;
    }

    lpszRemoveURL=new char[INTERNET_MAX_URL_LENGTH+1];

    if(lpszRemoveURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    for(iCounter=0;iCounter<iNumSelected;iCounter++)
    {
        ZeroMemory(&lvItem,sizeof(lvItem));

        iItem=ListView_GetNextItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),iItem,LVNI_SELECTED);
        
        lvItem.iItem=iItem;
        lvItem.pszText=lpszRemoveURL;
        lvItem.cchTextMax=INTERNET_MAX_URL_LENGTH;

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,LVM_GETITEMTEXT,(WPARAM) iItem,(LPARAM) &lvItem);

        for(iSubCounter=0;iSubCounter<iNumApproved;iSubCounter++)
        {
            PICSRulesPolicy *pPRPolicy;
            PICSRulesByURLExpression * pPRByURLExpression;

            pPRPolicy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iSubCounter];

            if(pPRPolicy==NULL)
            {
                continue;
            }

            if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_REJECTBYURL)
            {
                if(pPRPolicy->m_pPRRejectByURL==NULL)
                {
                    continue;
                }

                pPRByURLExpression=pPRPolicy->m_pPRRejectByURL->m_arrpPRByURL[0];
            }
            else
            {
                if(pPRPolicy->m_pPRAcceptByURL==NULL)
                {
                    continue;
                }

                pPRByURLExpression=pPRPolicy->m_pPRAcceptByURL->m_arrpPRByURL[0];
            }

            if(pPRByURLExpression==NULL)
            {
                continue;
            }
            
            if(pPRByURLExpression->m_etstrURL.Get()==NULL)
            {
                continue;
            }

            if(lstrcmp(pPRByURLExpression->m_etstrURL.Get(),lpszRemoveURL)==0)
            {
                //we found one to delete
                if(pPRPolicy!=NULL)
                {
                    delete pPRPolicy;
                    pPRPolicy = NULL;
                }

                g_pApprovedPRRSPreApply->m_arrpPRPolicy[iSubCounter]=0;
            }
        }
    }

    //delete them from the list view
    for(iCounter=0;iCounter<iNumSelected;iCounter++)
    {
        iItem=ListView_GetNextItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),-1,LVNI_SELECTED);
    
        ListView_DeleteItem(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),iItem);
    }

    //rebuild the approved PICSRules structure
    pNewApprovedPRRS=new PICSRulesRatingSystem;
    
    for(iCounter=0;iCounter<iNumApproved;iCounter++)
    {
        if(g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter]!=NULL)
        {
            pNewApprovedPRRS->m_arrpPRPolicy.Append(g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter]);
        }
    }

    g_pApprovedPRRSPreApply->m_arrpPRPolicy.ClearAll();

    delete g_pApprovedPRRSPreApply;

    g_pApprovedPRRSPreApply=pNewApprovedPRRS;

    MarkChanged();

    ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       EM_SETSEL,
                       (WPARAM) 0,
                       (LPARAM) -1);

    delete lpszRemoveURL;
    lpszRemoveURL = NULL;

    return 1L;
}

LRESULT CApprovedSitesDialog::OnPicsRulesListChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
//  NMLISTVIEW *pNMListView=(NMLISTVIEW *)pnmh;

    BOOL    fEnable = FALSE;

    if(ListView_GetSelectedCount(GetDlgItem(IDC_PICSRULESAPPROVEDLIST)) > 0)
    {
        fEnable = TRUE;
    }

    ::EnableWindow(GetDlgItem(IDC_PICSRULESAPPROVEDREMOVE),fEnable);

    return 0L;
}

LRESULT CApprovedSitesDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    int iCounter,iLoopCounter;

    if(g_pApprovedPRRSPreApply==NULL)
    {
        //we don't have anything to set
        return PSNRET_NOERROR;
    }

    //make the Approved Sites Global
    if(g_pApprovedPRRS!=NULL)
    {
        delete g_pApprovedPRRS;
    }

    g_pApprovedPRRS=new PICSRulesRatingSystem;

    if(g_pApprovedPRRS==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return PSNRET_INVALID_NOCHANGEPAGE;
    }

    for(iLoopCounter=0;iLoopCounter<2;iLoopCounter++)
    {
        for(iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
            PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
            PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

            pPRPolicyToCopy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

            if(pPRPolicyToCopy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            }
            else
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;
            }

            pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

            if (!pPRByURLExpressionToCopy)
            {
                //we shouldn't ever get here

                MyMessageBox(m_hWnd, IDS_PICSRULES_NOAPPROVEDSAVE, IDS_ERROR, MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            //we want to put all of the non-sitewide approved sites first
            //so that a user can specify, allow all of xyz.com except for
            //xyz.com/foo.htm
            switch(iLoopCounter)
            {
                case 0:
                {
                    if((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                case 1:
                {
                    if(!((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH))
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            pPRPolicy=new PICSRulesPolicy;
    
            if(pPRPolicy==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }
   
            pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

            pPRByURL=new PICSRulesByURL;
    
            if(pPRByURL==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {                       
                pPRPolicy->m_pPRAcceptByURL=pPRByURL;
            }
            else
            {
                pPRPolicy->m_pPRRejectByURL=pPRByURL;
            }

            pPRByURLExpression=new PICSRulesByURLExpression;

            if(pPRByURLExpression==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return PSNRET_INVALID_NOCHANGEPAGE;
            }

            pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
            pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
            pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
            pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
            pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
            pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
            pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
            pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
            pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

    
            pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

            g_pApprovedPRRS->m_arrpPRPolicy.Append(pPRPolicy);
        }           
    }

    PICSRulesDeleteSystem(PICSRULES_APPROVEDSITES);
    PICSRulesSaveToRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    SHGlobalCounterIncrement(g_ApprovedSitesHandleGlobalCounter);

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Do this if hit OK or Cancel, not Apply
    OnReset( idCtrl, pnmh, bHandled );

    return PSNRET_NOERROR;
}

LRESULT CApprovedSitesDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    // Do this if hit OK or Cancel, not Apply
    SendMessage( m_hWnd, WM_SETREDRAW, FALSE, 0L );
    SetListImages( NULL );
    SendMessage( m_hWnd, WM_SETREDRAW, TRUE, 0L );

    return 0L;
}

LRESULT CApprovedSitesDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CApprovedSitesDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

//
// ShowBadUrl
//
// Show some ui telling user URL is bad when adding an approved site
//
void CApprovedSitesDialog::ShowBadUrl( void )
{
    MyMessageBox(m_hWnd, IDS_PICSRULES_BADURLMSG, IDS_PICSRULES_BADURLTITLE, MB_OK|MB_ICONERROR);

    // set focus back to edit box and select all of it
    ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));
    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                    EM_SETSEL,
                    (WPARAM) 0,
                    (LPARAM) -1);
}

//Processes adding sites to the Approved Sites list.
//note, users will type in URLs _NOT_ in the form required
//in the PICSRules spec.  Thus, we will use InternetCrackURL
//and fill in the appropriate fields for them.
HRESULT CApprovedSitesDialog::PICSRulesApprovedSites(BOOL fAlwaysNever)
{
    PICSRulesPolicy             * pPRPolicy;
    PICSRulesByURL              * pPRByURL;
    PICSRulesByURLExpression    * pPRByURLExpression;
    LPSTR                       lpszSiteURL;
    HRESULT                     hr = NOERROR;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme = NULL;
    LPSTR                       lpszHostName = NULL;
    LPSTR                       lpszUserName = NULL;
    LPSTR                       lpszPassword = NULL;
    LPSTR                       lpszUrlPath = NULL;
    LPSTR                       lpszExtraInfo = NULL;
    BOOL                        fAddedScheme=FALSE;
    LV_ITEM                     lvItem;
    LV_FINDINFO                 lvFindInfo;

    lpszSiteURL=new char[INTERNET_MAX_URL_LENGTH+1];
    if(lpszSiteURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    //have we already processed it?
    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_GETTEXT,
                       (WPARAM) INTERNET_MAX_URL_LENGTH,
                       (LPARAM) lpszSiteURL);

    if(*lpszSiteURL=='\0')
    {
        //nothing to do
        delete lpszSiteURL;
        lpszSiteURL = NULL;

        return(E_INVALIDARG);
    }

    ZeroMemory(&lvFindInfo,sizeof(lvFindInfo));

    lvFindInfo.flags=LVFI_STRING;
    lvFindInfo.psz=lpszSiteURL;

    if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                          LVM_FINDITEM,
                          (WPARAM) -1,
                          (LPARAM) &lvFindInfo)!=-1)
    {
        //we already have settings for this URL
        MyMessageBox(m_hWnd, IDS_PICSRULES_DUPLICATEMSG, IDS_PICSRULES_DUPLICATETITLE, MB_OK|MB_ICONERROR);

        delete lpszSiteURL;
        lpszSiteURL = NULL;

        ::SetFocus(GetDlgItem(IDC_PICSRULESAPPROVEDEDIT));

        SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                           EM_SETSEL,
                           (WPARAM) 0,
                           (LPARAM) -1);

        return(E_INVALIDARG);
    }


    //
    // Add a scheme if user didn't type one
    //
    LPSTR lpszTemp = new char[INTERNET_MAX_URL_LENGTH+1];
    DWORD cbBuffer = INTERNET_MAX_URL_LENGTH;
    hr = UrlApplySchemeA(lpszSiteURL, lpszTemp, &cbBuffer, 0);
    if(S_OK == hr)
    {
        // actually added a scheme - switch to new buffer
        delete lpszSiteURL;
        lpszSiteURL = lpszTemp;
        fAddedScheme = TRUE;
    }
    else
    {
        // delete temp buffer
        delete lpszTemp;
        lpszTemp = NULL;
    }


    //
    // Allocate all the pics rules structures we need
    //
    if(g_pApprovedPRRSPreApply==NULL)
    {
        g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;
        if(g_pApprovedPRRSPreApply==NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pPRPolicy=new PICSRulesPolicy;
    if(pPRPolicy==NULL)
    {
        return(E_OUTOFMEMORY);
    }
    pPRByURL=new PICSRulesByURL;
    if(pPRByURL==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }
    pPRByURLExpression=new PICSRulesByURLExpression;
    if(pPRByURLExpression==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }

    //
    // Crack the URL
    //
    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if(lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        hr = E_OUTOFMEMORY;
        goto clean;
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if(pfnInternetCrackUrl==NULL)
    {
        hr = E_UNEXPECTED;
        goto clean;
    }

    if(FALSE == pfnInternetCrackUrl(lpszSiteURL,0,ICU_DECODE,&URLComponents))
    {
        // failed to crack url
        ShowBadUrl();
        hr = E_INVALIDARG;
        goto clean;
    }


    //
    // Set up linkages of pics rules structures
    //
    hr=g_pApprovedPRRSPreApply->AddItem(PROID_POLICY,pPRPolicy);
    if(FAILED(hr))
    {
        goto clean;
    }

    if(fAlwaysNever==PICSRULES_NEVER)
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;
        pPRPolicy->AddItem(PROID_REJECTBYURL,pPRByURL);
    }
    else
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;
        pPRPolicy->AddItem(PROID_ACCEPTBYURL,pPRByURL);
    }

    pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);


    //
    // Use cracked URL components to fill in pics structs
    //
    pPRByURLExpression->m_fInternetPattern=TRUE;

    if((*lpszScheme!=NULL)&&(fAddedScheme==FALSE))
    {
        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.SetTo(lpszScheme);   
    }
    else
    {
        delete lpszScheme;
        lpszScheme = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;

    if(*lpszUserName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_USER;           
        pPRByURLExpression->m_etstrUser.SetTo(lpszUserName);
    }
    else
    {
        delete lpszUserName;
        lpszUserName = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_USER;

    if(*lpszHostName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;           
        pPRByURLExpression->m_etstrHost.SetTo(lpszHostName);
    }
    else
    {
        delete lpszHostName;
        lpszHostName = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if(*lpszUrlPath!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_PATH;           
        pPRByURLExpression->m_etstrPath.SetTo(lpszUrlPath);
    }
    else
    {
        delete lpszUrlPath;
        lpszUrlPath = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_PATH;

    if(URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
    {
        LPSTR lpszTemp;

        lpszTemp=new char[sizeof("65536")];

        wsprintf(lpszTemp,"%d",URLComponents.nPort);

        pPRByURLExpression->m_bNonWild|=BYURL_PORT;           
        pPRByURLExpression->m_etstrPort.SetTo(lpszTemp);
    }
    pPRByURLExpression->m_bSpecified|=BYURL_PORT;

    //
    // need to make sure we echo exactly what they typed in
    //

    // just UI stuff left so assume success - we don't want to delete pics
    // structs now that they're linked into other pics structs
    hr = NOERROR;

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_GETTEXT,
                       (WPARAM) INTERNET_MAX_URL_LENGTH,
                       (LPARAM) lpszSiteURL);

    ZeroMemory(&lvItem,sizeof(lvItem));

    lvItem.mask=LVIF_TEXT|LVIF_IMAGE;
    lvItem.pszText=lpszSiteURL;

    if(fAlwaysNever==PICSRULES_NEVER)
    {
        lvItem.iImage=g_iAllowNever;
    }
    else
    {
        lvItem.iImage=g_iAllowAlways;
    }

    if(SendDlgItemMessage(IDC_PICSRULESAPPROVEDLIST,
                          LVM_INSERTITEM,
                          (WPARAM) 0,
                          (LPARAM) &lvItem)==-1)
    {
        goto clean;
    }

    ListView_SetColumnWidth(GetDlgItem(IDC_PICSRULESAPPROVEDLIST),
                            0,
                            LVSCW_AUTOSIZE);

    SendDlgItemMessage(IDC_PICSRULESAPPROVEDEDIT,
                       WM_SETTEXT,
                       (WPARAM) 0,
                       (LPARAM) 0);

    MarkChanged();

    pPRByURLExpression->m_etstrURL.SetTo(lpszSiteURL);

clean:
    SAFEDELETE(lpszPassword);
    SAFEDELETE(lpszExtraInfo);

    if(FAILED(hr))
    {
        // failed means we didn't get chance to save or delete these
        SAFEDELETE(lpszScheme);
        SAFEDELETE(lpszHostName);
        SAFEDELETE(lpszUserName);
        SAFEDELETE(lpszUrlPath);

        // a failed hr means we didn't link these guys together so they need
        // to be deleted
        SAFEDELETE(lpszSiteURL);
        SAFEDELETE(pPRPolicy);
        SAFEDELETE(pPRByURL);
        SAFEDELETE(pPRByURLExpression);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\debug.cpp ===
#include "msrating.h"
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "msrating"
#define SZ_MODULE           "MSRATING"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\custfile.h ===
/****************************************************************************\
 *
 *   custfile.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Custom File Dialog
 *
\****************************************************************************/

#ifndef CUSTOM_FILE_H
#define CUSTOM_FILE_H

class CCustomFileDialog : public CFileDialog
{
private:
    BOOL    m_bLocalFileCheck;

public:
	CCustomFileDialog(
        BOOL bLocalFileCheck,
        BOOL bOpenFileDialog, // TRUE for FileOpen, FALSE for FileSaveAs
		LPCTSTR lpszDefExt = NULL,
		LPCTSTR lpszFileName = NULL,
		DWORD dwFlags = OFN_HIDEREADONLY|OFN_OVERWRITEPROMPT| OFN_PATHMUSTEXIST,
		LPCTSTR lpszFilter = NULL,
		HWND hWndParent = NULL)
		: CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName, dwFlags, lpszFilter, hWndParent),
        m_bLocalFileCheck( bLocalFileCheck )
	{ }

	BEGIN_MSG_MAP(CCustomFileDialog)
	    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
		NOTIFY_CODE_HANDLER(CDN_FILEOK, OnFileOk)
	END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
	LRESULT OnFileOk(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled);

public:
	int		DoModal(HWND hWndParent = ::GetActiveWindow( ));
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\custfile.cpp ===
/****************************************************************************\
 *
 *   custfile.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Custom File Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "custfile.h"       // CCustomFileDialog
#include <atlmisc.h>        // CString

// The reason this file is not currently added is the Ansi version of GetOpenFileName()
//      currently displays the Old version of the Open File Dialog when a Hook is required.

// If the msrating.dll is converted to Unicode, the CCustomFileDialog should be included
//      and should properly display the New version of the Open File Dialog.

// If this file is added to the Build the following needs to be added as a Resource:
//      IDS_LOCAL_FILE_REQUIRED "The file selected must be a local file for correct Content Advisor functionality.\r\n\r\n%s"

LRESULT CCustomFileDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = FALSE;
    return 1L;
}

// Insures the File is a Local File
LRESULT CCustomFileDialog::OnFileOk(int /*idCtrl*/, LPNMHDR pnmh, BOOL& bHandled)
{
	if ( m_bLocalFileCheck )
    {
        CString             strFile( m_szFileName );
        CString             strDrive = strFile.Left( 3 );
        UINT                uiDriveType;

        uiDriveType = ::GetDriveType( strDrive );

        if ( uiDriveType != DRIVE_FIXED )
        {
            CString             strMessage;

            strMessage.Format( IDS_LOCAL_FILE_REQUIRED, strFile );

            MyMessageBox( m_hWnd, strMessage, IDS_GENERIC, MB_OK | MB_ICONWARNING );

            return -1;
        }
    }

    bHandled = FALSE;
    return 0L;
}

// Insures if Open File Flags are changed the Dialog will be Properly Derived
int	CCustomFileDialog::DoModal(HWND hWndParent)
{
	m_ofn.Flags |= OFN_ENABLEHOOK | OFN_EXPLORER; // Please don't remove these flags

    return CFileDialog::DoModal(hWndParent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\filedlg.h ===
/****************************************************************************\
 *
 *   provdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Ratings Provider Dialog
 *
\****************************************************************************/

#ifndef FILE_DIALOG_H
#define FILE_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

struct ProviderData
{
    PicsRatingSystem *pPRS;
    PicsRatingSystem *pprsNew;
    UINT nAction;
};

const UINT PROVIDER_KEEP = 0;
const UINT PROVIDER_ADD = 1;
const UINT PROVIDER_DEL = 2;

class CProviderDialog: public CBaseDialog<CProviderDialog>
{
private:
    static DWORD aIds[];
    PicsRatingSystemInfo * m_pPRSI;
    array<ProviderData> m_aPD;

public:
    enum { IDD = IDD_PROVIDERS };

public:
    CProviderDialog( PicsRatingSystemInfo * p_pPRSI );

public:
    typedef CProviderDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_HANDLER(IDC_PROVIDERLIST, LBN_SELCHANGE, OnSelChange)

        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_CLOSEPROVIDER, OnCloseProvider)
        COMMAND_ID_HANDLER(IDC_OPENPROVIDER, OnOpenProvider)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnCloseProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOpenProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    BOOL    OpenTemplateDlg( CHAR * szFilename,UINT cbFilename );
    void    SetHorizontalExtent(HWND hwndLB, LPCSTR pszString);
    void    AddProviderToList(UINT idx, LPCSTR pszFilename);
    BOOL    InitProviderDlg( void );
    void    EndProviderDlg(BOOL fRet);
    void    CommitProviderDlg( void );
    void    RemoveProvider( void );
    int     CompareProviderNames(PicsRatingSystem *pprsOld, PicsRatingSystem *pprsNew);
    void    AddProvider( PSTR szAddFileName=NULL );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\filedlg.cpp ===
/****************************************************************************\
 *
 *   FILEDLG.CPP - Code to manage the Rating Systems dialog.
 *
 *     gregj    06/27/96    Moved code here from msludlg.cpp and largely rewrote.
 *     
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include "mslubase.h"
#include "commctrl.h"
#include "commdlg.h"
#include "buffer.h"
#include "filedlg.h"        // CProviderDialog
// #include "custfile.h"       // CCustomFileDialog
#include "debug.h"
#include <shellapi.h>

#include <contxids.h>

#include <mluisupp.h>

typedef BOOL (APIENTRY *PFNGETOPENFILENAME)(LPOPENFILENAME);

DWORD CProviderDialog::aIds[] = {
    IDC_STATIC1,            IDH_RATINGS_SYSTEM_RATSYS_LIST,
    IDC_PROVIDERLIST,       IDH_RATINGS_SYSTEM_RATSYS_LIST,
    IDC_OPENPROVIDER,       IDH_RATINGS_SYSTEM_RATSYS_ADD,
    IDC_CLOSEPROVIDER,      IDH_RATINGS_SYSTEM_RATSYS_REMOVE,
    IDC_STATIC2,            IDH_IGNORE,
    0,0
};

CProviderDialog::CProviderDialog( PicsRatingSystemInfo * p_pPRSI )
{
    m_pPRSI = p_pPRSI;
}

BOOL CProviderDialog::OpenTemplateDlg( CHAR * szFilename,UINT cbFilename )
{
    CHAR szFilter[MAXPATHLEN];
    CHAR szOpenInfTitle[MAXPATHLEN];
    CHAR szInitialDir[MAXPATHLEN];

    GetSystemDirectory(szInitialDir, sizeof(szInitialDir));
    strcpyf(szFilename,szNULL);
    MLLoadStringA(IDS_RAT_OPENFILE, szOpenInfTitle,sizeof(szOpenInfTitle));

    // have to load the openfile filter in 2 stages, because the string
    // contains a terminating character and MLLoadString won't load the
    // whole thing in one go
    memset(szFilter,0,sizeof(szFilter));
    MLLoadStringA(IDS_RAT_FILTER_DESC,szFilter,sizeof(szFilter) - 10); // save some room for the filespec
    MLLoadStringA(IDS_RAT_FILTER,szFilter+strlenf(szFilter)+1,sizeof(szFilter)-
        (strlenf(szFilter)+1));

    OPENFILENAME ofn;

    memset(&ofn,0,sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = m_hWnd;
    ofn.hInstance = NULL;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile =    szFilename;
    ofn.nMaxFile = cbFilename;
    ofn.lpstrTitle = szOpenInfTitle;
    ofn.lpstrInitialDir = szInitialDir;
    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST
                        | OFN_SHAREAWARE | OFN_HIDEREADONLY;

    BOOL fRet = ::GetOpenFileName( &ofn );

#ifdef NEVER
    DWORD           dwFlags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_NONETWORKBUTTON
                        | OFN_SHAREAWARE | OFN_HIDEREADONLY;

    BOOL fRet = FALSE;

    CCustomFileDialog           cfd( TRUE,          // Local Files Only
                                     TRUE,          // Open File
                                     NULL,          // Default Extension
                                     NULL,          // Initial Filename
                                     dwFlags,       // Open File Flags
                                     szFilter,      // Filter
                                     m_hWnd );      // Parent

    if ( cfd.DoModal( m_hWnd ) == IDOK )
    {
        fRet = TRUE;
        lstrcpy( szFilename, cfd.m_szFileName );
    }
#endif

    return fRet;
}


void CProviderDialog::SetHorizontalExtent(HWND hwndLB, LPCSTR pszString)
{
    HDC hDC = ::GetDC(hwndLB);
    HFONT hFont = (HFONT)::SendMessage(hwndLB, WM_GETFONT, 0, 0);
    HFONT hfontOld = (HFONT)::SelectObject(hDC, hFont);

    UINT cxSlop = ::GetSystemMetrics(SM_CXBORDER) * 4;    /* 2 for LB border, 2 for margin inside border */

    UINT cxNewMaxExtent = 0;
    SIZE s;
    if (pszString != NULL) {
        ::GetTextExtentPoint(hDC, pszString, ::strlenf(pszString), &s);
        UINT cxCurExtent = (UINT)::SendMessage(hwndLB, LB_GETHORIZONTALEXTENT, 0, 0);
        if ((UINT)s.cx > cxCurExtent)
            cxNewMaxExtent = s.cx + cxSlop;
    }
    else {
        UINT cItems = (UINT)::SendMessage(hwndLB, LB_GETCOUNT, 0, 0);
        for (UINT i=0; i<cItems; i++) {
            char szItem[MAXPATHLEN];    /* we know we have pathnames in the list */
            ::SendMessage(hwndLB, LB_GETTEXT, i, (LPARAM)(LPSTR)szItem);
            ::GetTextExtentPoint(hDC, szItem, ::strlenf(szItem), &s);
            if ((UINT)s.cx > cxNewMaxExtent)
                cxNewMaxExtent = s.cx;
        }
        cxNewMaxExtent += cxSlop;
    }

    if (cxNewMaxExtent > 0)
        ::SendMessage(hwndLB, LB_SETHORIZONTALEXTENT, (WPARAM)cxNewMaxExtent, 0);

    ::SelectObject(hDC, hfontOld);
    ::ReleaseDC(hwndLB, hDC);
}

void CProviderDialog::AddProviderToList(UINT idx, LPCSTR pszFilename)
{
    UINT_PTR iItem = SendDlgItemMessage(IDC_PROVIDERLIST, LB_ADDSTRING, 0,
                                        (LPARAM)pszFilename);
    if (iItem != LB_ERR)
    {
        SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETITEMDATA, iItem, (LPARAM)idx);
    }
}


BOOL CProviderDialog::InitProviderDlg( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::InitProviderDlg() - m_pPRSI is NULL!" );
        return FALSE;
    }

    for (UINT i = 0; i < (UINT)m_pPRSI->arrpPRS.Length(); ++i)
    {
        PicsRatingSystem *pPRS = m_pPRSI->arrpPRS[i];
        ProviderData pd;
        pd.pPRS = pPRS;
        pd.pprsNew = NULL;
        pd.nAction = PROVIDER_KEEP;
        if (!m_aPD.Append(pd))
            return FALSE;

        if(pPRS->etstrName.Get())
        {
            // add provider using name
            AddProviderToList(i, pPRS->etstrName.Get());
        }
        else if(pPRS->etstrFile.Get())
        {
            // no name - possibly missing file, use filespec instead
            AddProviderToList(i, pPRS->etstrFile.Get());
        }
    }

    SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), NULL);
            
    ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), FALSE);
    ::EnableWindow(GetDlgItem(IDC_OPENPROVIDER), TRUE);

    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETCURSEL, 0, 0) != LB_ERR)
    {
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), TRUE);
    }

    return TRUE;
}


void CProviderDialog::EndProviderDlg(BOOL fRet)
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::EndProviderDlg() - m_pPRSI is NULL!" );
        return;
    }

    /* Go through our auxiliary array and delete any provider structures which
     * we added in this dialog.  Note that if the user previously hit OK, the
     * providers which were added will be marked as KEEP when they're put back
     * in the main data structure, so we won't delete them here.
     */
    UINT cProviders = m_aPD.Length();
    for (UINT i=0; i<cProviders; i++)
    {
        if (m_aPD[i].nAction == PROVIDER_ADD)
        {
            delete m_aPD[i].pPRS;
            m_aPD[i].pPRS = NULL;
        }

        if (m_aPD[i].pprsNew != NULL)
        {
            delete m_aPD[i].pprsNew;
            m_aPD[i].pprsNew = NULL;
        }
    }

    EndDialog(fRet);
}


void CProviderDialog::CommitProviderDlg( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::CommitProviderDlg() - m_pPRSI is NULL!" );
        return;
    }

    /* We check twice to see if there are any rating systems installed.
     * Up front, we see if there's anything in the list, before we commit
     * any changes;  this lets the user change their mind, cancel the dialog,
     * and not lose any settings.
     *
     * The second check is down at the end, seeing if there are any valid
     * rating systems left after we're done committing changes.  Note that
     * the results of that check could be different than this first one if
     * any rating systems fail to load for some reason.
     *
     * If we prompt the user the first time and he says he really doesn't
     * want any rating systems (i.e., wants to disable ratings completely),
     * we don't bother prompting the second time since he's already said no.
     * Hence the fPrompted flag.
     */
    BOOL fPrompted = FALSE;

    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_GETCOUNT, 0, 0) == 0) {
        MyMessageBox(m_hWnd, IDS_NO_PROVIDERS, IDS_GENERIC, MB_OK);
        return;
    }

    /* Go through the list and add the new ones.
     * Note that this does NOT destruct the pPRS objects themselves, it just
     * empties the array.  We have saved copies of all of them in our auxiliary
     * array.
     */

    m_pPRSI->arrpPRS.ClearAll();

    UINT cItems = m_aPD.Length();

    for (UINT i=0; i<cItems; i++) {
        switch (m_aPD[i].nAction) {
        case PROVIDER_DEL:
            DeleteUserSettings(m_aPD[i].pPRS);
            delete m_aPD[i].pPRS;
            m_aPD[i].pPRS = NULL;
            delete m_aPD[i].pprsNew;
            m_aPD[i].pprsNew = NULL;
            break;

        case PROVIDER_KEEP:
            if (m_aPD[i].pprsNew != NULL) {
                CheckUserSettings(m_aPD[i].pprsNew);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pprsNew);
                delete m_aPD[i].pPRS;
                m_aPD[i].pPRS = NULL;
                m_aPD[i].pprsNew = NULL;    /* protect from cleanup code */
            }
            else if (!(m_aPD[i].pPRS->dwFlags & PRS_ISVALID)) {
                delete m_aPD[i].pPRS;
                m_aPD[i].pPRS = NULL;
            }
            else {
                CheckUserSettings(m_aPD[i].pPRS);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pPRS);
            }
            break;

        case PROVIDER_ADD:
            if (m_aPD[i].pPRS != NULL) {
                CheckUserSettings(m_aPD[i].pPRS);
                m_pPRSI->arrpPRS.Append(m_aPD[i].pPRS);
                m_aPD[i].nAction = PROVIDER_KEEP;        /* keep this one now */
            }
            break;

        default:
            ASSERT(FALSE);
        }
    }

    if (m_pPRSI->arrpPRS.Length() == 0) {
        if (!fPrompted &&
            MyMessageBox(m_hWnd, IDS_NO_PROVIDERS, IDS_GENERIC, MB_YESNO) == IDYES)
        {
            return;
        }
        m_pPRSI->fRatingInstalled = FALSE;
    }
    else {
        m_pPRSI->fRatingInstalled = TRUE;
    }

    EndProviderDlg(TRUE);
}


void CProviderDialog::RemoveProvider( void )
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::AddProvider() - m_pPRSI is NULL!" );
        return;
    }

    UINT_PTR i = SendDlgItemMessage( IDC_PROVIDERLIST, LB_GETCURSEL,0,0);

    if (i != LB_ERR)
    {
        UINT idx = (UINT)SendDlgItemMessage( IDC_PROVIDERLIST,
                                            LB_GETITEMDATA, i, 0);
        if (idx < (UINT)m_aPD.Length()) {
            /* If the user added the provider in this dialog session, just
             * delete it from the array.  The null pPRS pointer will be
             * detected later, so it's OK to leave the array element itself.
             * (Yes, if the user adds and removes an item over and over, we
             * consume 12 bytes of memory each time. Oh well.)
             *
             * If the item was there before the user launched the dialog,
             * then just mark it for deletion on OK.
             */
            if (m_aPD[idx].nAction == PROVIDER_ADD) {
                delete m_aPD[idx].pPRS;
                m_aPD[idx].pPRS = NULL;
            }
            else
                m_aPD[idx].nAction = PROVIDER_DEL;
        }

        SendDlgItemMessage(IDC_PROVIDERLIST, LB_DELETESTRING, i, 0);
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), FALSE);
        SendDlgItemMessage(IDC_PROVIDERLIST, LB_SETCURSEL,0,0);
        ::SetFocus(GetDlgItem(IDOK));
        SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), NULL);
    }
}


/* Returns zero if the two PicsRatingSystems have the same RAT-filename,
 * non-zero otherwise.  Handles the '*' marker on the end for failed
 * loads.  It is assumed that only pprsOld may have that marker.
 */
int CProviderDialog::CompareProviderNames(PicsRatingSystem *pprsOld, PicsRatingSystem *pprsNew)
{
    if (!pprsOld->etstrFile.fIsInit())
        return 1;

    UINT cbNewName = ::strlenf(pprsNew->etstrFile.Get());

    LPSTR pszOld = pprsOld->etstrFile.Get();
    int nCmp = ::strnicmpf(pprsNew->etstrFile.Get(), pszOld, cbNewName);
    if (nCmp != 0)
        return nCmp;

    pszOld += cbNewName;
    if (*pszOld == '\0' || (*pszOld == '*' && *(pszOld+1) == '\0'))
        return 0;

    return 1;
}


void CProviderDialog::AddProvider( PSTR szAddFileName )
{
    BOOL fAdd=FALSE;
    char szFileName[MAXPATHLEN+1];

    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::AddProvider() - m_pPRSI is NULL!" );
        return;
    }

    if (szAddFileName!=NULL)
    {
        lstrcpy(szFileName,szAddFileName);
        fAdd=TRUE;
    }
    else
    {
        fAdd=OpenTemplateDlg(szFileName, sizeof(szFileName));
    }
    
    if (fAdd==TRUE)
    {
        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(szFileName, &pPRS);

        if (FAILED(hres)) {
            if (pPRS != NULL) {
                pPRS->ReportError(hres);
                delete pPRS;
                pPRS = NULL;
            }
        }
        else {
            /* Check to see if this guy is already in the list.  If he is,
             * the user might have said to delete him;  in that case, put
             * him back.  Otherwise, the system is already installed, so
             * tell the user he doesn't have to install it again.
             */
            for (UINT i=0; i<(UINT)m_aPD.Length(); i++) {
                ProviderData *ppd = &m_aPD[i];
                if (ppd->pPRS==NULL) {
                    //This system was added and then removed during
                    //this dialog session.  It will be detected later,
                    //so just skip it and keep appending entries.
                    continue;
                }
                if (!CompareProviderNames(ppd->pPRS, pPRS)) {

                    if (!(ppd->pPRS->dwFlags & PRS_ISVALID) &&
                        (ppd->pprsNew == NULL))
                        ppd->pprsNew = pPRS;
                    else
                    {
                        delete pPRS;    /* don't need copy */
                        pPRS = NULL;
                    }

                    if (ppd->nAction == PROVIDER_DEL) {
                        ppd->nAction = PROVIDER_KEEP;
                        AddProviderToList(i, ppd->pPRS->etstrName.Get());
                    }
                    else {
                        MyMessageBox(m_hWnd, IDS_ALREADY_INSTALLED, IDS_GENERIC, MB_OK);
                    }
                    return;
                }
            }

            /* This guy isn't already in the list.  Add him to the listbox
             * and to the array.
             */
            ProviderData pd;
            pd.nAction = PROVIDER_ADD;
            pd.pPRS = pPRS;
            pd.pprsNew = NULL;

            if (!m_aPD.Append(pd)) {
                MyMessageBox(m_hWnd, IDS_LOADRAT_MEMORY, IDS_GENERIC, MB_OK | MB_ICONWARNING);
                delete pPRS;
                pPRS = NULL;
                return;
            }
            AddProviderToList(m_aPD.Length() - 1, pPRS->etstrName.Get());

            ::SetFocus(GetDlgItem(IDOK));
            SetHorizontalExtent(GetDlgItem(IDC_PROVIDERLIST), szFileName);
        }
    }
}


LRESULT CProviderDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT( m_pPRSI );

    if ( ! m_pPRSI )
    {
        TraceMsg( TF_ERROR, "CProviderDialog::OnInitDialog() - m_pPRSI is NULL!" );
        return 0L;
    }

    if ( ! InitProviderDlg() )
    {
        MyMessageBox(m_hWnd, IDS_LOADRAT_MEMORY, IDS_GENERIC, MB_OK | MB_ICONSTOP);
        EndProviderDlg(FALSE);
    }

    if ( m_pPRSI->lpszFileName != NULL )
    {
        AddProvider( m_pPRSI->lpszFileName );
    }

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CProviderDialog::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if (SendDlgItemMessage(IDC_PROVIDERLIST, LB_GETCURSEL, 0,0) >= 0)
    {
        ::EnableWindow(GetDlgItem(IDC_CLOSEPROVIDER), TRUE);
        bHandled = TRUE;
    }

    return 0L;
}

LRESULT CProviderDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    CommitProviderDlg();
    return 0L;
}

LRESULT CProviderDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndProviderDlg(FALSE);
    return 0L;
}

LRESULT CProviderDialog::OnCloseProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    RemoveProvider();

    return 0L;
}

LRESULT CProviderDialog::OnOpenProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    AddProvider();

    return 0L;

}

LRESULT CProviderDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CProviderDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

INT_PTR DoProviderDialog(HWND hDlg, PicsRatingSystemInfo *pPRSI)
{
    CProviderDialog         provDialog( pPRSI );

    return provDialog.DoModal( hDlg );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\hint.cpp ===
/****************************************************************************\
 *
 *   hint.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Hint Handling Class
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "hint.h"           // CHint
#include "basedlg.h"        // CCommonDialogRoutines
#include "debug.h"          // TraceMsg()

const int cchHintLength_c = 127;
const TCHAR tchAmpersand_c[] = "&";
const TCHAR tchAmpersandReplacement_c[] = "&&";

// Default CHint Constructor
CHint::CHint()
{
    CHint( NULL, 0 );
}

// CHint Constructor with Dialog Window Handle and Hint Control Id.
CHint::CHint( HWND p_hWnd, int p_iId )
{
    m_hWnd = p_hWnd;
    m_iId = p_iId;
}

// Display the Hint Text on the Dialog Control.
void CHint::DisplayHint( void )
{
    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    if ( hwndControl != NULL )
    {
        CString         strHint;

        RetrieveHint( strHint );

        // Avoid display of "_" (accelerator) by replacing single "&" with "&&".
        strHint.Replace( tchAmpersand_c, tchAmpersandReplacement_c );

        ::SetWindowText( hwndControl, strHint );
    }
}

// Initialize the Hint Dialog Control by limiting the Number of Hint Characters.
void CHint::InitHint( void )
{
    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    if ( hwndControl != NULL )
    {
        ::SendMessage( hwndControl, EM_SETLIMITTEXT, (WPARAM) cchHintLength_c, (LPARAM) 0);
    }
}

// Check for a Blank Hint entered on the Dialog Control.
// Also, give the user the option to enter a non-blank hint.
bool CHint::VerifyHint( void )
{
    bool        fVerified = true;      // Default to true so we don't halt user if hint save fails.
    CString     strHint;

    GetHint( strHint );

    if ( strHint.IsEmpty() )
    {
        CString         strHintRecommended;
        CString         strCaption;

        strHintRecommended.LoadString( IDS_HINT_RECOMMENDED );
        strCaption.LoadString( IDS_GENERIC );

        if ( ::MessageBox( m_hWnd, strHintRecommended, strCaption, MB_YESNO | MB_DEFBUTTON1 ) == IDYES )
        {
            CCommonDialogRoutines       cdr;

            cdr.SetErrorFocus( m_hWnd, m_iId );

            fVerified = false;
        }
    }

    return fVerified;
}

// Save the Dialog Hint Text to the Registry (or Remove the Hint from the Registry if blank).
void CHint::SaveHint( void )
{
    CString     strHint;

    GetHint( strHint );

    if ( strHint.IsEmpty() )
    {
        RemoveHint();
    }
    else
    {
        StoreHint( strHint );
    }
}

// Remove the Hint from the Registry.
void CHint::RemoveHint( void )
{
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS ) == ERROR_SUCCESS )
    {
        if ( regKey.DeleteValue( szHINTVALUENAME ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::RemoveHint() - Failed to delete the hint registry value." );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::RemoveHint() - Failed to open the ratings registry key." );
    }
}

// Get the Hint Text from the Dialog's Control (remove leading and trailing blanks).
void CHint::GetHint( CString & p_rstrHint )
{
    p_rstrHint.Empty();

    HWND        hwndControl = ::GetDlgItem( m_hWnd, m_iId );

    // We shouldn't be attempting to save a hint if the edit control does not exist.
    ASSERT( hwndControl );

    if ( hwndControl != NULL )
    {
        ::GetWindowText( hwndControl, (LPTSTR) (LPCTSTR) p_rstrHint.GetBufferSetLength( cchHintLength_c + 1 ), cchHintLength_c );
        p_rstrHint.ReleaseBuffer();
    }
}

// Retrieve a previous Hint from the Registry.
void CHint::RetrieveHint( CString & p_rstrHint )
{
    CRegKey         regKey;
    DWORD           dwCount;

    p_rstrHint.Empty();

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS, KEY_READ ) == ERROR_SUCCESS )
    {
        dwCount = cchHintLength_c;

        if ( regKey.QueryValue( (LPTSTR) (LPCTSTR) p_rstrHint.GetBufferSetLength( cchHintLength_c + 1 ),
                szHINTVALUENAME, &dwCount ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::RetrieveHint() - Failed to query the hint registry value." );
        }

        p_rstrHint.ReleaseBuffer();
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::RetrieveHint() - Failed to open the ratings registry key." );
    }

    if ( p_rstrHint.IsEmpty() )
    {
        p_rstrHint.LoadString( IDS_NO_HINT );
    }
}

// Store Hint Text into the Registry.
void CHint::StoreHint( CString & p_rstrHint )
{
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS ) == ERROR_SUCCESS )
    {
        if ( regKey.SetValue( (LPTSTR) (LPCTSTR) p_rstrHint, szHINTVALUENAME ) != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CHint::StoreHint() - Failed to save the hint registry value." );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CHint::StoreHint() - Failed to create the ratings registry key." );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\gendlg.h ===
/****************************************************************************\
 *
 *   gendlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings General Property Page
 *
\****************************************************************************/

#ifndef GENERAL_DIALOG_H
#define GENERAL_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

typedef HINSTANCE (APIENTRY *PFNSHELLEXECUTE)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);

class CGeneralDialog : public CBasePropertyPage<IDD_GENERAL>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CGeneralDialog( PRSD * p_pPRSD );

public:
    typedef CGeneralDialog thisClass;
    typedef CBasePropertyPage<IDD_GENERAL> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_USER, OnUser)

        COMMAND_ID_HANDLER(IDC_PROVIDER, OnProvider)
        COMMAND_ID_HANDLER(IDC_FINDRATINGS, OnFindRatings)

        COMMAND_ID_HANDLER(IDC_PLEASE_MOMMY, OnMarkChanged)
        COMMAND_ID_HANDLER(IDC_UNRATED, OnMarkChanged)

        COMMAND_ID_HANDLER(IDC_CHANGE_PASSWORD, OnChangePassword)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnFindRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnChangePassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    SetButtonText( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\gendlg.cpp ===
/****************************************************************************\
 *
 *   gendlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings General Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "gendlg.h"         // CGeneralDialog
#include "debug.h"          // TraceMsg()
#include "chngdlg.h"        // CChangePasswordDialog
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

DWORD CGeneralDialog::aIds[] = {
    IDC_STATIC7,            IDH_IGNORE,
    IDC_STATIC1,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_STATIC2,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_STATIC3,            IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    IDC_FINDRATINGS,        IDH_FIND_RATING_SYSTEM_BUTTON,
    IDC_PROVIDER,           IDH_RATINGS_RATING_SYSTEM_BUTTON,
    IDC_UNRATED,            IDH_RATINGS_UNRATED_CHECKBOX,
    IDC_PLEASE_MOMMY,       IDH_RATINGS_OVERRIDE_CHECKBOX,
    IDC_STATIC4,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_STATIC5,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_STATIC6,            IDH_RATINGS_RATING_SYSTEM_TEXT,
    IDC_CHANGE_PASSWORD,    IDH_RATINGS_CHANGE_PASSWORD_BUTTON,
    0,0
};

CGeneralDialog::CGeneralDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CGeneralDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CApprovedSitesDialog::OnInitDialog() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->pPU != NULL)
    {
        CheckDlgButton( IDC_UNRATED, pPRSD->pPU->fAllowUnknowns?BST_CHECKED:BST_UNCHECKED);
        CheckDlgButton( IDC_PLEASE_MOMMY, pPRSD->pPU->fPleaseMom?BST_CHECKED:BST_UNCHECKED);
    }

    SetButtonText();

    PostMessage( WM_USER,(WPARAM) 0,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CGeneralDialog::OnUser(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (gPRSI->lpszFileName!=NULL)
    {
        ::SetFocus(GetDlgItem(IDC_PROVIDER));

        DoProviderDialog( m_hWnd,gPRSI );
        gPRSI->lpszFileName=NULL;
    }

    return 0L;
}

LRESULT CGeneralDialog::OnProvider(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CGeneralDialog::OnProvider() - pPRSD is NULL!" );
        return 0L;
    }

    if ( DoProviderDialog( m_hWnd, pPRSD->pPRSI ) )
    {            
        pPRSD->fNewProviders = TRUE;
        MarkChanged();

        // $BUG - $BUG - The Bureau List is on the Advanced Dialog so this seems incorrect!!
//        FillBureauList(hDlg, pPRSD->pPRSI);
    }    

    return 1L;
}

LRESULT CGeneralDialog::OnFindRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    BOOL fSuccess=FALSE;

    HINSTANCE hShell32=::LoadLibrary(::szShell32);

    if(hShell32!=NULL)
    {
        PFNSHELLEXECUTE pfnShellExecute=(PFNSHELLEXECUTE)::GetProcAddress(hShell32,::szShellExecute);
    
        if(pfnShellExecute!=NULL)
        {
            fSuccess=(*pfnShellExecute)(m_hWnd,NULL,(char *) &szFINDSYSTEM,NULL,NULL,SW_SHOW)!=NULL;
        }
        ::FreeLibrary(hShell32);
    }
    if (!fSuccess)
    {
        NLS_STR nlsMessage(MAX_RES_STR_LEN);
        //Check for NULL; Otherwise, nlsMessage.QueryPch() will fault later.
        if(nlsMessage)
        {
            NLS_STR nlsTemp(STR_OWNERALLOC,(char *) &szFINDSYSTEM);
            const NLS_STR *apnls[] = { &nlsTemp, NULL };
            if ( WN_SUCCESS == (nlsMessage.LoadString(IDS_CANT_LAUNCH, apnls)) )
            {
                MyMessageBox(m_hWnd,nlsMessage.QueryPch(),IDS_GENERIC,MB_OK|MB_ICONSTOP);
            }
        }
    }

    return 1L;
}

LRESULT CGeneralDialog::OnMarkChanged(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    MarkChanged();
    return 1L;
}

LRESULT CGeneralDialog::OnChangePassword(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    int         idsMessage = 0;

    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        CChangePasswordDialog<IDD_CHANGE_PASSWORD>       changePasswordDlg;

        if ( changePasswordDlg.DoModal( m_hWnd ) )
        {
            idsMessage = IDS_PASSWORD_CHANGED;
        }
    }
    else
    {
        CChangePasswordDialog<IDD_CREATE_PASSWORD>   createPassDlg;

        if ( createPassDlg.DoModal( m_hWnd ) )
        {
            SetButtonText();

            idsMessage = IDS_PASSWORD_CREATED;
        }
    }

    if ( idsMessage )
    {
        MyMessageBox( m_hWnd, idsMessage, IDS_GENERIC, MB_OK | MB_ICONINFORMATION);
        MarkChanged();
    }

    return 1L;
}

LRESULT CGeneralDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/
    PRSD *      pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CGeneralDialog::OnApply() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->pPU != NULL)
    {
        pPRSD->pPU->fAllowUnknowns = (IsDlgButtonChecked(IDC_UNRATED) & BST_CHECKED) ? TRUE: FALSE;
        pPRSD->pPU->fPleaseMom = (IsDlgButtonChecked(IDC_PLEASE_MOMMY) & BST_CHECKED) ? TRUE: FALSE;
    }

    return PSNRET_NOERROR;
}

LRESULT CGeneralDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    return 0L;
}

LRESULT CGeneralDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CGeneralDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CGeneralDialog::SetButtonText( void )
{
    int         idsButton;

    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        idsButton = IDS_CHANGE_PASSWORD;
    }
    else
    {
        idsButton = IDS_CREATE_PASSWORD;
    }

    HWND        hwndControl = GetDlgItem( IDC_CHANGE_PASSWORD );

    ASSERT( hwndControl );

    if ( hwndControl != NULL )
    {
        CString             strButtonText;

        strButtonText.LoadString( idsButton );

        ::SetWindowText( hwndControl, strButtonText );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\hint.h ===
/****************************************************************************\
 *
 *   hint.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Hint Handling Class
 *
\****************************************************************************/

#ifndef HINT_CLASS_H
#define HINT_CLASS_H

#include <atlmisc.h>        // CString

class CHint
{
private:
    HWND        m_hWnd;
    int         m_iId;

public:
    CHint();
    CHint( HWND p_hWnd, int p_iId );

    void    DisplayHint( void );
    void    InitHint( void );
    bool    VerifyHint( void );
    void    SaveHint( void );
    void    RemoveHint( void );

protected:
    void    GetHint( CString & p_rstrHint );
    void    RetrieveHint( CString & p_rstrHint );
    void    StoreHint( CString & p_rstrHint );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\introdlg.h ===
/****************************************************************************\
 *
 *   introdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Introduction Property Page
 *
\****************************************************************************/

#ifndef INTRO_DIALOG_H
#define INTRO_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

class CIntroDialog : public CBasePropertyPage<IDD_INTRO>
{
private:
    static DWORD aIds[];

public:
    CIntroDialog();

public:
    typedef CIntroDialog thisClass;
    typedef CBasePropertyPage<IDD_INTRO> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDC_SET_RATINGS, OnSetRatings)
        COMMAND_ID_HANDLER(IDC_TURN_ONOFF, OnTurnOnOff)

        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnSetRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnTurnOnOff(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    EnableDlgItems( void );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\introdlg.cpp ===
/****************************************************************************\
 *
 *   introdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Introduction Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"
#include "picsrule.h"
#include "introdlg.h"       // CIntroDialog
#include "toffdlg.h"        // CTurnOffDialog
#include "hint.h"           // CHint
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

extern INT_PTR DoPasswordConfirm(HWND hDlg);
extern BOOL PicsOptionsDialog( HWND hwnd, PicsRatingSystemInfo * pPRSI, PicsUser * pPU );

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

DWORD CIntroDialog::aIds[] = {
    IDC_SET_RATINGS,    IDH_RATINGS_SET_RATINGS_BUTTON,
    IDC_STATIC1,        IDH_IGNORE,
    IDC_TURN_ONOFF,     IDH_RATINGS_TURNON_BUTTON,
    IDC_INTRO_TEXT,     IDH_IGNORE,
    0,0
};

CIntroDialog::CIntroDialog()
{
    // Add Construction Here...
}

LRESULT CIntroDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CheckGlobalInfoRev();
    EnableDlgItems();

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CIntroDialog::OnSetRatings(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND        hDlg = m_hWnd;

    UINT_PTR passConfirm = DoPasswordConfirm(hDlg);
    if (passConfirm == PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "CIntroDialog::OnSetRatings() - DoPasswordConfirm() failed." );
        return 0L;
    }

    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        if ( ! PicsOptionsDialog( hDlg, gPRSI, GetUserObject() ) )
        {
            if (passConfirm == PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }
        MarkChanged();
    }
    else
    {
        if ( PicsOptionsDialog( hDlg, gPRSI, GetUserObject() ) )
        {
            MarkChanged();
        }
    }

    EnableDlgItems();

    return 1L;
}

LRESULT CIntroDialog::OnTurnOnOff(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    HWND        hDlg = m_hWnd;

    if ( DoPasswordConfirm( hDlg ) )
    {
        PicsUser *pUser = ::GetUserObject();
        if (pUser != NULL)
        {
            pUser->fEnabled = !pUser->fEnabled;
            if (pUser->fEnabled)
            {
                MyMessageBox(hDlg, IDS_NOW_ON, IDS_ENABLE_WARNING,
                             IDS_GENERIC, MB_OK);
            }
            else
            {
                CRegKey             keyRatings;

                if ( keyRatings.Open( HKEY_LOCAL_MACHINE, szRATINGS ) == ERROR_SUCCESS )
                {
                    DWORD         dwFlag;

                    // $REVIEW - Should we call RemoveSupervisorPassword() or not delete the Key at all?

                    // Delete the supervisor key so that we don't load
                    // ratings by other components and we "quick" know it is off.

                    keyRatings.DeleteValue( szRatingsSupervisorKeyName );

                    if ( keyRatings.QueryValue( dwFlag, szTURNOFF ) == ERROR_SUCCESS )
                    {
                        if ( dwFlag != 1 )
                        {
                            CTurnOffDialog          turnOffDialog;

                            turnOffDialog.DoModal( hDlg );
                        }
                    }
                    else
                    {
                        CTurnOffDialog          turnOffDialog;

                        turnOffDialog.DoModal( hDlg );
                    }
                }
            }

            EnableDlgItems();
        }
    }

    return 1L;
}

LRESULT CIntroDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    ASSERT( gPRSI );

    if ( gPRSI )
    {
        gPRSI->fSettingsValid = TRUE;
        gPRSI->SaveRatingSystemInfo();
    }

    return PSNRET_NOERROR;
}

LRESULT CIntroDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CIntroDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

void CIntroDialog::EnableDlgItems( void )
{
    CHAR pszBuf[MAXPATHLEN];
    PicsUser *pUser = ::GetUserObject();

    if (!gPRSI->fRatingInstalled)
    {
        MLLoadStringA(IDS_RATING_NEW, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_ONOFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), FALSE);
    }
    else if (pUser && pUser->fEnabled)
    {
        MLLoadStringA(IDS_RATING_ON, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_OFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), TRUE);
    }
    else
    {
        MLLoadStringA(IDS_RATING_OFF, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_INTRO_TEXT, pszBuf);

        MLLoadStringA(IDS_TURN_ON, pszBuf, sizeof(pszBuf));
        SetDlgItemText( IDC_TURN_ONOFF, pszBuf);
        ::EnableWindow(GetDlgItem( IDC_TURN_ONOFF), TRUE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\mslubase.cpp ===
/****************************************************************************\
 *
 *   MSLUBASE.C --Structures for holding pics information
 *
 *     Created:      Jason Thomas
 *     Updated:    Ann McCurdy
 *     
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "reghive.h"        // CRegistryHive
#include "debug.h"

#include <buffer.h>
#include <regentry.h>

#include <mluisupp.h>

/*Helpers-------------------------------------------------------------------*/
char PicsDelimChar='/';

int MyMessageBox(HWND hwnd, LPCSTR pszText, UINT uTitle, UINT uType)
{
    CHAR szTitle[MAXPATHLEN];
    
    MLLoadStringA(uTitle, szTitle, sizeof(szTitle));

    return MessageBox(hwnd, pszText, szTitle, uType);
}

int MyMessageBox(HWND hwnd, UINT uText, UINT uTitle, UINT uType)
{
    CHAR szText[MAXPATHLEN];
    
    MLLoadStringA(uText, szText, sizeof(szText));

    return MyMessageBox(hwnd, szText, uTitle, uType);
}

/* Variant for long messages: uText2 message will be concatenated onto the end
 * of uText before display. Message text should contain \r\n or other desired
 * separators, this function won't add them.
 */
int MyMessageBox(HWND hwnd, UINT uText, UINT uText2, UINT uTitle, UINT uType)
{
    CHAR szText[MAXPATHLEN*2] = { 0 };

    MLLoadStringA(uText, szText, sizeof(szText));

    /* Using lstrlen in case MLLoadString really returns a count of CHARACTERS,
     * on a DBCS system...
     */
    UINT cbFirst = lstrlen(szText);
    MLLoadStringA(uText2, szText + cbFirst, sizeof(szText) - cbFirst);

    return MyMessageBox(hwnd, szText, uTitle, uType);
}

/*******************************************************************

    NAME:        MyRegDeleteKey

********************************************************************/
LONG MyRegDeleteKey(HKEY hkey,LPCSTR pszSubkey)
{
    DWORD           dwError;

    TraceMsg( TF_ALWAYS, "MyRegDeleteKey() - Deleting Subkey='%s'...", pszSubkey );

    dwError = SHDeleteKey( hkey, pszSubkey );

    if ( dwError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "MyRegDeleteKey() - Failed to Delete Subkey='%s' dwError=%d!", pszSubkey, dwError );
    }

    return dwError;
}


BOOL MyAtoi(char *pIn, int *pi)
{
    char *pc;
    ASSERT(pIn);
   
    *pi = 0;

    pc = NonWhite(pIn);
    if (!pc)
        return FALSE;
     
    if (*pc < '0' || *pc > '9')
        return FALSE;

    int accum = 0;

    while (*pc >= '0' && *pc <= '9')
    {
        accum = accum * 10 + (*pc - '0');
        pc++;
    }

    *pi = accum;
    return TRUE;
}


/*Simple types--------------------------------------------------------------*/

/* ETN */
#ifdef DEBUG
void  ETN::Set(int rIn){
    Init();
    r = rIn;
}
int ETN::Get(){
    return r;
}
#endif

ETN* ETN::Duplicate(){
    ETN *pETN=new ETN;
    if (fIsInit()) pETN->Set(Get());
    return pETN;
}


/* ETB */
#ifdef DEBUG
BOOL ETB::Get()
{
    ASSERT(fIsInit());
    return m_nFlags & ETB_VALUE;
}

void ETB::Set(BOOL b)
{
    m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0);
}
#endif

ETB* ETB::Duplicate()
{
    ASSERT(fIsInit());

    ETB *pETB = new ETB;
    if (pETB != NULL)
        pETB->m_nFlags = m_nFlags;
    return pETB;
}

/* ETS */

ETS::~ETS()
{
    if (pc != NULL) {
        delete pc;
        pc = NULL;
    }
}

#ifdef DEBUG
char* ETS::Get()
{
//    ASSERT(fIsInit()); 
    return pc;
}
#endif

void ETS::Set(const char *pIn)
{
    if (pc != NULL)
        delete pc;

    if (pIn != NULL) {
        pc = new char[strlenf(pIn) + 1];
        if (pc != NULL) {
            strcpyf(pc, pIn);
        }
    }
    else {
        pc = NULL;
    }
}


void ETS::SetTo(char *pIn)
{
    if (pc != NULL)
        delete pc;

    pc = pIn;
}


ETS* ETS::Duplicate()
{
    ETS *pETS=new ETS;
    if (pETS != NULL)
        pETS->Set(Get());
    return pETS;
}


UINT EtBoolRegRead(ETB &etb, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtBoolRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize, dwValue, dwType;
    UINT uErr;

    etb.Set(FALSE);
    
    dwSize = sizeof(dwValue);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, &dwType, 
                            (LPBYTE)&dwValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
       if ((dwType == REG_DWORD) && (dwValue != 0))
           etb.Set(TRUE);
    }
    else
    {
        TraceMsg( TF_WARNING, "EtBoolRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtBoolRegWrite(ETB &etb, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtBoolRegWrite() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    UINT uErr;
    DWORD dwNum = (etb.fIsInit() && etb.Get());

    uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_DWORD, (LPBYTE)&dwNum, sizeof(dwNum));

    if ( uErr != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "EtBoolRegWrite() - Failed to set pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}


UINT EtStringRegRead(ETS &ets, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtStringRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize;
    UINT uErr;
    char szTemp[80];        /* default size */

    dwSize = sizeof(szTemp);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, NULL, 
                            (LPBYTE)szTemp, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        ets.Set(szTemp);
    }
    else if (uErr == ERROR_MORE_DATA)
    {
        char *pszTemp = new char[dwSize];
        if (pszTemp == NULL)
        {
            TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to allocate dwSize=%d memory!", dwSize );
            uErr = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            uErr = RegQueryValueEx(hKey, pKeyWord, NULL, NULL, (LPBYTE)pszTemp,
                                   &dwSize);
            if (uErr == ERROR_SUCCESS)
            {
                ets.SetTo(pszTemp);
                /* ets now owns pszTemp memory, don't delete it here */
            }
            else
            {
                TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to read (dwSize %d) pKeyWord='%s'!", dwSize, pKeyWord );
                delete pszTemp;
                pszTemp = NULL;
            }
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "EtStringRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtStringRegWrite(ETS &ets, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtStringRegWrite() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    UINT uErr = ERROR_SUCCESS;

    if (ets.fIsInit())
    {
        uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_SZ, (LPBYTE)ets.Get(), strlenf(ets.Get())+1);

        if ( uErr != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "EtStringRegWrite() - Failed to set pKeyWord='%s' with ets='%s'!", pKeyWord, ets.Get() );
        }
    }
    else
    {
        TraceMsg( TF_ERROR, "EtStringRegWrite() - ETS is not initialized!" );
    }

    return uErr;
}
                     

UINT EtNumRegRead(ETN &etn, HKEY hKey, char *pKeyWord)
{
    ASSERT(pKeyWord);

    if ( ! pKeyWord )
    {
        TraceMsg( TF_ERROR, "EtNumRegRead() - pKeyWord is NULL!" );
        return ERROR_INVALID_PARAMETER;
    }

    DWORD dwSize, dwType;
    int nValue;
    UINT uErr;

    dwSize = sizeof(nValue);

    uErr = RegQueryValueEx(hKey, pKeyWord, NULL, &dwType, 
                            (LPBYTE)&nValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        etn.Set(nValue);
    }
    else
    {
        TraceMsg( TF_WARNING, "EtNumRegRead() - Failed to read pKeyWord='%s'!", pKeyWord );
    }

    return uErr;
}

UINT EtNumRegWrite(ETN &etn, HKEY hKey, char *pKeyWord)
{
    UINT uErr = ERROR_SUCCESS;

    if (etn.fIsInit())
    {
        int nTemp;
        nTemp = etn.Get();
        uErr = RegSetValueEx(hKey, pKeyWord, 0, REG_DWORD, (LPBYTE)&nTemp, sizeof(nTemp));

        if ( uErr != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "EtNumRegWrite() - Failed to set pKeyWord='%s' with nTemp=%d!", pKeyWord, nTemp );
        }
    }
    else
    {
        TraceMsg( TF_ERROR, "EtNumRegWrite() - ETS is not initialized!" );
    }

    return uErr;
}


/*PicsDefault---------------------------------------------------------------*/

PicsDefault::PicsDefault()
{
    /* nothing to do but construct members */
}

PicsDefault::~PicsDefault()
{
    /* nothing to do but destruct members */
}

/*PicsEnum------------------------------------------------------------------*/

PicsEnum::PicsEnum()
{
    /* nothing to do but construct members */
}

PicsEnum::~PicsEnum()
{
    /* nothing to do but destruct members */
}

/*PicsCategory--------------------------------------------------------------*/

PicsCategory::PicsCategory()
{
    /* nothing to do but construct members */
}

PicsCategory::~PicsCategory()
{
    arrpPC.DeleteAll();
    arrpPE.DeleteAll();
}


/*PicsRatingSystem----------------------------------------------------------*/

PicsRatingSystem::PicsRatingSystem()
    : m_pDefaultOptions(NULL),
      dwFlags(0),
      nErrLine(0)
{
    /* nothing to do but construct members */
}

PicsRatingSystem::~PicsRatingSystem()
{
    arrpPC.DeleteAll();
    if (m_pDefaultOptions != NULL)
    {
        delete m_pDefaultOptions;
        m_pDefaultOptions = NULL;
    }
}

void PicsRatingSystem::ReportError(HRESULT hres)
{
    NLS_STR nls1(etstrFile.Get());
    if (!nls1.QueryError())
    {
        ISTR istrMarker(nls1);
        if (nls1.strchr(&istrMarker, '*'))
        {
            nls1.DelSubStr(istrMarker);
        }
    }
    else
    {
        nls1 = szNULL;
    }

    UINT idMsg, idTemplate;

    NLS_STR nlsBaseMessage(MAX_RES_STR_LEN);
    char szNumber[16];            /* big enough for a 32-bit (hex) number */

    if (hres == E_OUTOFMEMORY || (hres > RAT_E_BASE && hres <= RAT_E_BASE + 0xffff)) {
        idTemplate = IDS_LOADRAT_SYNTAX_TEMPLATE;    /* default is ratfile content error */
        switch (hres)
        {
        case E_OUTOFMEMORY:
            idMsg = IDS_LOADRAT_MEMORY;
            idTemplate = IDS_LOADRAT_GENERIC_TEMPLATE;
            break;
        case RAT_E_EXPECTEDLEFT:
            idMsg = IDS_LOADRAT_EXPECTEDLEFT;
            break;
        case RAT_E_EXPECTEDRIGHT:
            idMsg = IDS_LOADRAT_EXPECTEDRIGHT;
            break;
        case RAT_E_EXPECTEDTOKEN:
            idMsg = IDS_LOADRAT_EXPECTEDTOKEN;
            break;
        case RAT_E_EXPECTEDSTRING:
            idMsg = IDS_LOADRAT_EXPECTEDSTRING;
            break;
        case RAT_E_EXPECTEDNUMBER:
            idMsg = IDS_LOADRAT_EXPECTEDNUMBER;
            break;
        case RAT_E_EXPECTEDBOOL:
            idMsg = IDS_LOADRAT_EXPECTEDBOOL;
            break;
        case RAT_E_DUPLICATEITEM:
            idMsg = IDS_LOADRAT_DUPLICATEITEM;
            break;
        case RAT_E_MISSINGITEM:
            idMsg = IDS_LOADRAT_MISSINGITEM;
            break;
        case RAT_E_UNKNOWNITEM:
            idMsg = IDS_LOADRAT_UNKNOWNITEM;
            break;
        case RAT_E_UNKNOWNMANDATORY:
            idMsg = IDS_LOADRAT_UNKNOWNMANDATORY;
            break;
        case RAT_E_EXPECTEDEND:
            idMsg = IDS_LOADRAT_EXPECTEDEND;
            break;
        default:
            ASSERT(FALSE);        /* there aren't any other RAT_E_ errors  */
            idMsg = IDS_LOADRAT_UNKNOWNERROR;
            break;
        }

        wsprintf(szNumber, "%d", nErrLine);
        NLS_STR nlsNumber(STR_OWNERALLOC, szNumber);

        const NLS_STR *apnls[] = { &nlsNumber, NULL };
        nlsBaseMessage.LoadString((USHORT)idMsg, apnls);
    }
    else
    {
        idTemplate = IDS_LOADRAT_GENERIC_TEMPLATE;
        if (HRESULT_FACILITY(hres) == FACILITY_WIN32)
        {
            wsprintf(szNumber, "%d", HRESULT_CODE(hres));
            idMsg = IDS_LOADRAT_WINERROR;
        }
        else
        {
            wsprintf(szNumber, "0x%x", hres);
            idMsg = IDS_LOADRAT_MISCERROR;
        }
        NLS_STR nls1(STR_OWNERALLOC, szNumber);
        const NLS_STR *apnls[] = { &nls1, NULL };
        nlsBaseMessage.LoadString((USHORT)idMsg, apnls);
    }

    NLS_STR nlsMessage(MAX_RES_STR_LEN);
    const NLS_STR *apnls[] = { &nls1, &nlsBaseMessage, NULL };
    nlsMessage.LoadString((USHORT)idTemplate, apnls);
    if (!nlsMessage.QueryError())
    {
        MyMessageBox(NULL, nlsMessage.QueryPch(), IDS_GENERIC, MB_OK | MB_ICONWARNING);
    }
}


/*Rating Information--------------------------------------------------------*/
BOOL PicsRatingSystemInfo::LoadProviderFiles(HKEY hKey)
{
    char szFileName[8 + 7 + 1];    /* "Filename" + big number plus null byte */
    ETS  etstrFileName;
    int  index = 0;
   
    EtStringRegRead(etstrRatingBureau, hKey, (char *)szRATINGBUREAU);
   
    wsprintf(szFileName, szFilenameTemplate, index);
    while (EtStringRegRead(etstrFileName, hKey, szFileName) == ERROR_SUCCESS) 
    {
        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(etstrFileName.Get(), &pPRS);
        if (pPRS != NULL)
        {
            arrpPRS.Append(pPRS);

            /* If the thing has a pathname, write it back out to the policy
             * file, in case loading the rating system marked it as invalid
             * (or it had been marked as invalid, but the user fixed things
             * and it's OK now).
             */
            if (pPRS->etstrFile.fIsInit())
            {
                /* If the rating system is not valid and was not previously
                 * marked invalid, then report the error to the user.
                 * LoadRatingSystem will have already marked the filename
                 * as invalid for us.
                 */
                if ((pPRS->dwFlags & (PRS_ISVALID | PRS_WASINVALID)) == 0)
                {
                    pPRS->ReportError(hres);    /* report error to user */
                }
                EtStringRegWrite(pPRS->etstrFile, hKey, szFileName);
            }
        }

        index++;
        wsprintf(szFileName, szFilenameTemplate, index);
    }

    return arrpPRS.Length() != 0;
}


BOOL RunningOnNT()
{
    return !(::GetVersion() & 0x80000000);
}


// Verify the Registry Key for the Ratings can be opened with full access.
// This is only useful if the Ratings registry key has been previously created.
bool IsRegistryModifiable( HWND p_hwndParent )
{
    bool            fReturn = false;
    CRegKey         regKey;

    if ( regKey.Open( HKEY_LOCAL_MACHINE, ::szRATINGS, KEY_ALL_ACCESS ) == ERROR_SUCCESS )
    {
        fReturn = true;
    }
    else
    {
        TraceMsg( TF_WARNING, "IsRegistryModifiable() - Failed to Create Registry Key Ratings for Full Access!" );

        MyMessageBox( p_hwndParent, IDS_REGISTRY_NOT_MODIFIABLE, IDS_GENERIC, MB_OK|MB_ICONERROR);
    }

    return fReturn;
}

SID_IDENTIFIER_AUTHORITY siaNTAuthority = SECURITY_NT_AUTHORITY;
SID_IDENTIFIER_AUTHORITY siaWorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

class CSecurityAttributes
{
private:
    SECURITY_ATTRIBUTES m_sa;
    LPSECURITY_ATTRIBUTES m_lpsa;
    PSECURITY_DESCRIPTOR m_psd;
    PACL m_pACL;
    PSID m_psidAdmins;
    PSID m_psidWorld;
    UINT m_cbACL;                /* default ACL size */

public:
    CSecurityAttributes()
    {
        m_lpsa = NULL;
        m_psd = NULL;
        m_pACL = NULL;
        m_psidAdmins = NULL;
        m_psidWorld = NULL;
        m_cbACL = 1024;
    }

    ~CSecurityAttributes()
    {
        if ( m_psidAdmins != NULL )
        {
            FreeSid(m_psidAdmins);
            m_psidAdmins = NULL;
        }

        if ( m_psidWorld )
        {
            FreeSid(m_psidWorld);
            m_psidWorld = NULL;
        }

        if ( m_psd )
        {
            MemFree(m_psd);
            m_psd = NULL;
        }

        if ( m_pACL )
        {
            MemFree(m_pACL);
            m_pACL = NULL;
        }
    }

    LPSECURITY_ATTRIBUTES GetSecurityAttributes( void )
    {
        return m_lpsa;
    }

    bool AllocateSecurityAttributes( void )
    {
        m_psd = (PSECURITY_DESCRIPTOR)MemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (m_psd == NULL ||
            !InitializeSecurityDescriptor(m_psd, SECURITY_DESCRIPTOR_REVISION))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Security Descriptor Allocation!" );
            return false;
        }

        m_pACL = (PACL)MemAlloc(m_cbACL);
        if (m_pACL == NULL || !InitializeAcl(m_pACL, m_cbACL, ACL_REVISION2))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed ACL Initialization!" );
            return false;
        }

        if (!AllocateAndInitializeSid(&siaNTAuthority,
                2,                                /* number of subauthorities */
                SECURITY_BUILTIN_DOMAIN_RID,    /* first subauthority: this domain */
                DOMAIN_ALIAS_RID_ADMINS,        /* second: admins local group */
                0, 0, 0, 0, 0, 0,                /* unused subauthorities */
                &m_psidAdmins))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed NT Authority Initialization!" );
            return false;
        }

        if (!AllocateAndInitializeSid(&siaWorldAuthority,
                1,                                /* number of subauthorities */
                SECURITY_WORLD_RID,                /* first subauthority: all users */
                0, 0, 0, 0, 0, 0, 0,            /* unused subauthorities */
                &m_psidWorld))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed World Authority Initialization!" );
            return false;
        }

        if (!AddAccessAllowedAce(m_pACL, ACL_REVISION2, KEY_ALL_ACCESS, m_psidAdmins) ||
            !AddAccessAllowedAce(m_pACL, ACL_REVISION2, KEY_READ, m_psidWorld))
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Admins or World Access!" );
            return false;
        }

        ACE_HEADER *pAce;

        /* Make both ACEs inherited by subkeys created later */
        if (GetAce(m_pACL, 0, (LPVOID *)&pAce))
        {
            pAce->AceFlags |= CONTAINER_INHERIT_ACE;
        }

        if (GetAce(m_pACL, 1, (LPVOID *)&pAce))
        {
            pAce->AceFlags |= CONTAINER_INHERIT_ACE;
        }

        if (!SetSecurityDescriptorDacl(m_psd,
            TRUE,            /* fDaclPresent */
            m_pACL,
            FALSE))            /* not a default discretionary ACL */
        {
            TraceMsg( TF_ERROR, "CSecurityAttributes::AllocateSecurityAttributes() - Failed Set of Security Descriptor!" );
            return false;
        }

        m_sa.nLength = sizeof(m_sa);
        m_sa.lpSecurityDescriptor = m_psd;
        m_sa.bInheritHandle = FALSE;

        m_lpsa = &m_sa;

        return true;
    }
};

// The following first attempts to open an existing registry key.
// If the key cannot be opened, the key is created.
// Under NT, the key is created with Admin read-write access and World read-only access.
// Under 9x, the key is created with no special security attributes.
HKEY CreateRegKeyNT(LPCSTR pszKey)
{
    HKEY hKey = NULL;
    LONG err = RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hKey);
    if (err == ERROR_SUCCESS)
    {
        TraceMsg( TF_ALWAYS, "CreateRegKeyNT() - Successfully Opened Ratings Registry Key." );
        return hKey;
    }

    CSecurityAttributes         sa;

    if (RunningOnNT())
    {
        if ( ! sa.AllocateSecurityAttributes() )
        {
            TraceMsg( TF_ERROR, "CreateRegKeyNT() - Failed to allocate security attributes()!" );
            return NULL;
        }
    }

    DWORD dwDisp;
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, pszKey, NULL, "",
                       REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, sa.GetSecurityAttributes(),
                       &hKey, &dwDisp) != ERROR_SUCCESS)
    {
        TraceMsg( TF_ERROR, "CreateRegKeyNT() - Failed Registry Key Creation with %s Security Attributes!", sa.GetSecurityAttributes() ? "<sa>" : "<NULL>" );
        hKey = NULL;
    }

    return hKey;
}

HKEY PicsRatingSystemInfo::GetUserProfileKey( void )
{
    HKEY            hkeyUser = NULL;

    // HKLM\System\CurrentControlSet\Control\Update
    RegEntry re(szPOLICYKEY, HKEY_LOCAL_MACHINE);

    // UpdateMode
    if (re.GetNumber(szPOLICYVALUE) != 0)
    {
        // HKLM\Network\Logon
        RegEntry reLogon(szLogonKey, HKEY_LOCAL_MACHINE);

        // UserProfiles
        if (reLogon.GetNumber(szUserProfiles) != 0)
        {
            /* The ratings key has the supervisor password and maybe other
             * settings.  To see if there are other settings here, try to
             * find the user subkey (".Default").  If it's not there, we'll
             * try a policy file.
             */

            // HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Ratings
            if (RegOpenKey(HKEY_LOCAL_MACHINE, szRATINGS, &hkeyUser) == ERROR_SUCCESS)
            {
                HKEY hkeyTemp;

                // .Default
                if (RegOpenKey(hkeyUser, szDefaultUserName, &hkeyTemp) == ERROR_SUCCESS)
                {
                    RegCloseKey(hkeyTemp);
                    hkeyTemp = NULL;
                }
                else
                {
                    TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - Failed to Open key szDefaultUserName='%s'!", szDefaultUserName );
                    RegCloseKey(hkeyUser);
                    hkeyUser = NULL;
                }
            }
            else
            {
                TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - Failed to Open key szRATINGS='%s'!", szRATINGS );
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - No key szLogonKey='%s' szUserProfiles='%s'!", szLogonKey, szUserProfiles );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::GetUserProfileKey() - No key szPOLICYKEY='%s' szPOLICYVALUE='%s'!", szPOLICYKEY, szPOLICYVALUE );
    }

    return hkeyUser;
}

BOOL PicsRatingSystemInfo::Init( void )
{
    PicsUser    *pPU = NULL;

    BOOL        fRet = TRUE;
    BOOL        fIsNT;
    HKEY        hkeyUser = NULL;
    CRegistryHive   rh;

    fRatingInstalled = FALSE;
    pUserObject = NULL;

    fIsNT = RunningOnNT();

    if (fIsNT)
    {
        hkeyUser = CreateRegKeyNT(::szRATINGS);
        fStoreInRegistry = TRUE;
    }
    else
    {
        hkeyUser = GetUserProfileKey();

        if (hkeyUser != NULL)
        {
            fStoreInRegistry = TRUE;
        }
        else
        {
            fStoreInRegistry = FALSE;

            if ( rh.OpenHiveFile( false ) )
            {
                hkeyUser = rh.GetHiveKey();
            }
        }
    }

    // read information from whatever key we opened
    if (hkeyUser != NULL)
    {
        //First load the rating files, then load the user names.
        fRatingInstalled = LoadProviderFiles(hkeyUser);

        if ( fRatingInstalled )
        {
            TraceMsg( TF_ALWAYS, "PicsRatingSystemInfo::Init() - Ratings Installed!" );
        }
        else
        {
            TraceMsg( TF_ALWAYS, "PicsRatingSystemInfo::Init() - Ratings Not Installed!" );
        }

        pPU = new PicsUser;
        if (pPU != NULL)
        {
            pPU->ReadFromRegistry(hkeyUser, (char *)szDefaultUserName);
            pUserObject = pPU;
        }
        else
        {
            fRet = FALSE;
        }

        RegCloseKey(hkeyUser);
        hkeyUser = NULL;

        /* Make sure the user settings have defaults for all installed
         * rating systems.
         */
        for (int i=0; i<arrpPRS.Length(); i++)
        {
            CheckUserSettings(arrpPRS[i]);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::Init() - hkeyUser is NULL!" );
    }

    rh.UnloadHive();

    /* Check to see if there is a supervisor password set.  If there is,
     * but we have no settings, then someone's been tampering.
     */
    if ( SUCCEEDED( VerifySupervisorPassword() ) && ! fRatingInstalled )
    {
        MyMessageBox(NULL, IDS_NO_SETTINGS, IDS_GENERIC, MB_OK | MB_ICONSTOP);

        // Clear out the password to allow the user to modify the ratings.
        RemoveSupervisorPassword();

        fSettingsValid = FALSE;
    }
    else
    {
        fSettingsValid = TRUE;
    }

    return fRet;
}

BOOL PicsRatingSystemInfo::FreshInstall()
{
    PicsUser    *pPU = NULL;

    pPU = new PicsUser;
    if (pPU != NULL)
    {
        pPU->NewInstall();

        pUserObject = pPU;

        fRatingInstalled = TRUE;    // we have settings now
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

extern HANDLE g_hsemStateCounter;   // created at process attatch time

long GetStateCounter()
{
    long count;

    if (ReleaseSemaphore(g_hsemStateCounter, 1, &count))    // poll and bump the count
    {
        WaitForSingleObject(g_hsemStateCounter, 0);         // reduce the count
    }
    else
    {
        count = -1;
    }

    return count;
}

void BumpStateCounter()
{
    ReleaseSemaphore(g_hsemStateCounter, 1, NULL);      // bump the count
}

// check the global semaphore count to see if we need to reconstruct our
// state. 

void CheckGlobalInfoRev(void)
{
    ENTERCRITICAL;

    if (gPRSI != NULL && !g_fIsRunningUnderCustom)
    { // do not reinit if under Custom

        if (gPRSI->nInfoRev != GetStateCounter())
        {
            delete gPRSI;
            gPRSI = new PicsRatingSystemInfo;
            if (gPRSI != NULL)
            {
                gPRSI->Init();
            }
            CleanupRatingHelpers();
            InitRatingHelpers();
        }
    }

    LEAVECRITICAL;
}

void PicsRatingSystemInfo::SaveRatingSystemInfo()
{
    int z;
    HKEY hkeyUser = NULL;
    CRegistryHive       rh;
    char szFileName[MAXPATHLEN];

    if (!fSettingsValid || !fRatingInstalled)
    {
        TraceMsg( TF_WARNING, "PicsRatingSystemInfo::SaveRatingSystemInfo() - Ratings are not installed!" );
        return;                /* ratings aren't installed, nothing to save */
    }

    // load the hive file
    if (fStoreInRegistry)
    {
        hkeyUser = CreateRegKeyNT(::szRATINGS);
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            hkeyUser = rh.GetHiveKey();
        }
    }

    // read information from local registry
    if (hkeyUser != NULL)
    {
        if (etstrRatingBureau.fIsInit())
        {
            EtStringRegWrite(etstrRatingBureau, hkeyUser, (char *)szRATINGBUREAU);
        }
        else
        {
            RegDeleteValue(hkeyUser, szRATINGBUREAU);
        }    

        for (z = 0; z < arrpPRS.Length(); ++z)
        {
            wsprintf(szFileName, szFilenameTemplate, z);
            EtStringRegWrite(arrpPRS[z]->etstrFile, hkeyUser, szFileName);
        }

        // Delete the next one, as a safety precaution
        wsprintf(szFileName, szFilenameTemplate, z);
        RegDeleteValue(hkeyUser, szFileName);

        pUserObject->WriteToRegistry(hkeyUser);

        RegCloseKey(hkeyUser);
        hkeyUser = NULL;
    }
    else
    {
        TraceMsg( TF_ERROR, "PicsRatingSystemInfo::SaveRatingSystemInfo() - hkeyUser is NULL!" );
    }

    BumpStateCounter();
    nInfoRev = GetStateCounter();
}


HRESULT LoadRatingSystem(LPCSTR pszFilename, PicsRatingSystem **pprsOut)
{
    TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Loading Rating System '%s'...", pszFilename );

    PicsRatingSystem *pPRS = new PicsRatingSystem;

    *pprsOut = pPRS;
    if (pPRS == NULL)
    {
        TraceMsg( TF_ERROR, "LoadRatingSystem() - pPRS is NULL!" );
        return E_OUTOFMEMORY;
    }

    UINT cbFilename = strlenf(pszFilename) + 1 + 1;    /* room for marker character */
    LPSTR pszNameCopy = new char[cbFilename];
    if (pszNameCopy == NULL)
    {
        TraceMsg( TF_ERROR, "LoadRatingSystem() - pszNameCopy is NULL!" );
        return E_OUTOFMEMORY;
    }

    strcpyf(pszNameCopy, pszFilename);
    pPRS->etstrFile.SetTo(pszNameCopy);

    LPSTR pszMarker = strchrf(pszNameCopy, '*');
    if (pszMarker != NULL) {                /* ended in marker character... */
        ASSERT(*(pszMarker+1) == '\0');
        pPRS->dwFlags |= PRS_WASINVALID;    /* means it failed last time */
        *pszMarker = '\0';                    /* strip marker for loading */
    }

    HRESULT hres;

    HANDLE hFile = CreateFile(pszNameCopy, GENERIC_READ,
                              FILE_SHARE_READ, NULL, OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbFile = ::GetFileSize(hFile, NULL);
        BUFFER bufData(cbFile + 1);
        if (bufData.QueryPtr() != NULL)
        {
            LPSTR pszData = (LPSTR)bufData.QueryPtr();
            DWORD cbRead;
            if (ReadFile(hFile, pszData, cbFile, &cbRead, NULL))
            {
                pszData[cbRead] = '\0';        /* null terminate whole file */

                hres = pPRS->Parse(pszFilename, pszData);
                if (SUCCEEDED(hres))
                {
                    pPRS->dwFlags |= PRS_ISVALID;
                }
                else
                {
                    TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed Parse with hres=0x%x!", hres );
                }
            }
            else
            {
                hres = HRESULT_FROM_WIN32(::GetLastError());
                TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed ReadFile() with hres=0x%x!", hres );
            }

            CloseHandle(hFile);
        }
        else
        {
            hres = E_OUTOFMEMORY;
            TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed Buffer Allocation with cbFile=%d!", cbFile );
        }
    }
    else
    {
        hres = HRESULT_FROM_WIN32(::GetLastError());
        TraceMsg( TF_WARNING, "LoadRatingSystem() - Failed CreateFile() with hres=0x%x!", hres );
    }

    if (!(pPRS->dwFlags & PRS_ISVALID))
    {
        TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Failed Loaded Rating System '%s' (hres=0x%x)!", pszFilename, hres );

        strcatf(pszNameCopy, "*");            /* mark filename as invalid */
    }
    else
    {
        TraceMsg( TF_ALWAYS, "LoadRatingSystem() - Successfully Loaded Rating System '%s'.", pszFilename );
    }

    return hres;
}

// constructor for CustomRatingHelper

CustomRatingHelper::CustomRatingHelper()
{
    hLibrary = NULL;
    pNextHelper = NULL;
    dwSort = 0;
}

CustomRatingHelper::~CustomRatingHelper()
{
    if (hLibrary)
    {
        FreeLibrary(hLibrary);
        hLibrary = NULL;
    }

    pNextHelper = NULL;
}


// a little function to convert from ANSI to Unicode

HRESULT Ansi2Unicode(LPWSTR *pdest, LPCSTR src)
{
    UINT cbSize;

    cbSize = MultiByteToWideChar(CP_ACP, 0, src, -1, NULL, 0);
    if (cbSize > 0)
    {
        *pdest = new WCHAR[cbSize+1];
        cbSize = MultiByteToWideChar(CP_ACP, 0, src, -1, *pdest, cbSize+1);
    }
    return cbSize > 0 ? S_OK : E_FAIL;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\mslubase.h ===
/****************************************************************************\
 *
 *   PICS.H --Structures for holding pics information
 *
 *   Created:   Jason Thomas
 *   Updated:   Ann McCurdy
 *   
\****************************************************************************/

#ifndef _PICS_H_
#define _PICS_H_

/*Includes---------------------------------------------------------*/
#include <npassert.h>
#include "array.h"
#include "resource.h"
#include "msluglob.h"
#include <ratings.h>

extern HKEY CreateRegKeyNT(LPCSTR pszKey);
extern BOOL RunningOnNT(void);

extern char PicsDelimChar;

#define PICS_FILE_BUF_LEN   20000
#define PICS_STRING_BUF_LEN  1000

#define P_INFINITY           9999
#define N_INFINITY          -9999

/*Simple PICS types------------------------------------------------*/

class ETN
{
    private:
        int r;
        BOOL m_fInit;
    public:
        ETN() { m_fInit = FALSE; }

        void Init() { m_fInit = TRUE; }
        void UnInit() { m_fInit = FALSE; }
        BOOL fIsInit() { return m_fInit; }

#ifdef DEBUG
        void  Set(int rIn);
        int Get();
#else
        void  Set(int rIn) { Init(); r = rIn; }
        int Get() { return r; }
#endif

        ETN*  Duplicate();
};

const UINT ETB_VALUE = 0x01;
const UINT ETB_ISINIT = 0x02;
class ETB
{
    private:
        UINT m_nFlags;
    public:
        ETB() { m_nFlags = 0; }

#ifdef DEBUG
        BOOL Get();
        void Set(BOOL b);
#else
        BOOL Get() { return m_nFlags & ETB_VALUE; }
        void Set(BOOL b) { m_nFlags = ETB_ISINIT | (b ? ETB_VALUE : 0); }
#endif

        ETB   *Duplicate();
        BOOL fIsInit() { return m_nFlags & ETB_ISINIT; }
};

class ETS
{
    private:
        char *pc;
    public:
        ETS() { pc = NULL; }
        ~ETS();
#ifdef DEBUG
        char* Get();
#else
        char *Get() { return pc; }
#endif
        void  Set(const char *pIn);
        ETS*  Duplicate();
        void  SetTo(char *pIn);

        BOOL fIsInit() { return pc != NULL; }
};

extern UINT EtBoolRegRead(ETB &etb, HKEY hKey, char *pKeyWord);
extern UINT EtBoolRegWrite(ETB &etb, HKEY hKey, char *pKeyWord);
extern UINT EtStringRegRead(ETS &ets, HKEY hKey, char *pKeyWord);
extern UINT EtStringRegWrite(ETS &ets, HKEY hKey, char *pKeyWord);
extern UINT EtNumRegRead(ETN &etn, HKEY hKey, char *pKeyWord);
extern UINT EtNumRegWrite(ETN &etn, HKEY hKey, char *pKeyWord);


/*Complex PICS types-----------------------------------------------*/


enum RatObjectID
{
    ROID_INVALID,           /* dummy entry for terminating arrays */
    ROID_PICSDOCUMENT,      /* value representing the entire document (i.e., no token) */
    ROID_PICSVERSION,
    ROID_RATINGSYSTEM,
    ROID_RATINGSERVICE,
    ROID_RATINGBUREAU,
    ROID_BUREAUREQUIRED,
    ROID_CATEGORY,
    ROID_TRANSMITAS,
    ROID_LABEL,
    ROID_VALUE,
    ROID_DEFAULT,
    ROID_DESCRIPTION,
    ROID_EXTENSION,
    ROID_MANDATORY,
    ROID_OPTIONAL,
    ROID_ICON,
    ROID_INTEGER,
    ROID_LABELONLY,
    ROID_MAX,
    ROID_MIN,
    ROID_MULTIVALUE,
    ROID_NAME,
    ROID_UNORDERED
};

enum PICSRulesObjectID
{
    PROID_INVALID,                  /* dummy entry for terminating arrays */
    PROID_PICSVERSION,              /* for holding the PICSRules version ID */
    
    PROID_POLICY,                   /* for the Policy class */
        PROID_EXPLANATION,
        PROID_REJECTBYURL,
        PROID_ACCEPTBYURL,
        PROID_REJECTIF,
        PROID_ACCEPTIF,
        PROID_ACCEPTUNLESS,
        PROID_REJECTUNLESS,
    PROID_NAME,                     /* for the name class */
        PROID_RULENAME,
        PROID_DESCRIPTION,
    PROID_SOURCE,                   /* for the source class */
        PROID_SOURCEURL,
        PROID_CREATIONTOOL,
        PROID_AUTHOR,
        PROID_LASTMODIFIED,
    PROID_SERVICEINFO,              /* for the serviceinfo class */
        PROID_SINAME,
        PROID_SHORTNAME,
        PROID_BUREAUURL,
        PROID_USEEMBEDDED,
        PROID_RATFILE,
        PROID_BUREAUUNAVAILABLE,
    PROID_OPTEXTENSION,             /* for the optextension class */
        PROID_EXTENSIONNAME,
      //PROID_SHORTNAME,
    PROID_REQEXTENSION,
      //PROID_EXTENSIONNAME,
      //PROID_SHORTNAME,
    PROID_EXTENSION,

    PROID_POLICYDEFAULT,
    PROID_NAMEDEFAULT,
    PROID_SOURCEDEFAULT,
    PROID_SERVICEINFODEFAULT,
    PROID_OPTEXTENSIONDEFAULT,
    PROID_REQEXTENSIONDEFAULT
};

/* define some error codes */
const HRESULT RAT_E_BASE = 0x80050000;                  /* just a guess at a free area for internal use */
const HRESULT RAT_E_EXPECTEDLEFT    = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT RAT_E_EXPECTEDRIGHT   = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT RAT_E_EXPECTEDTOKEN   = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT RAT_E_EXPECTEDSTRING  = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT RAT_E_EXPECTEDNUMBER  = RAT_E_BASE + 5;   /* expected number */
const HRESULT RAT_E_EXPECTEDBOOL    = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT RAT_E_DUPLICATEITEM   = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT RAT_E_MISSINGITEM     = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT RAT_E_UNKNOWNITEM     = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT RAT_E_UNKNOWNMANDATORY= RAT_E_BASE + 10;  /* unrecognized mandatory extension */
const HRESULT RAT_E_EXPECTEDEND     = RAT_E_BASE + 11;  /* expected end of file */

/* echo for PICSRules with different names for clarity */
const HRESULT PICSRULES_E_BASE              = 0x80050000;       /* just a guess at a free area for internal use */
const HRESULT PICSRULES_E_EXPECTEDLEFT      = RAT_E_BASE + 1;   /* expected left paren */
const HRESULT PICSRULES_E_EXPECTEDRIGHT     = RAT_E_BASE + 2;   /* expected right paren */
const HRESULT PICSRULES_E_EXPECTEDTOKEN     = RAT_E_BASE + 3;   /* expected unquoted token */
const HRESULT PICSRULES_E_EXPECTEDSTRING    = RAT_E_BASE + 4;   /* expected quoted string */
const HRESULT PICSRULES_E_EXPECTEDNUMBER    = RAT_E_BASE + 5;   /* expected number */
const HRESULT PICSRULES_E_EXPECTEDBOOL      = RAT_E_BASE + 6;   /* expected boolean */
const HRESULT PICSRULES_E_DUPLICATEITEM     = RAT_E_BASE + 7;   /* AO_SINGLE item appeared twice */
const HRESULT PICSRULES_E_MISSINGITEM       = RAT_E_BASE + 8;   /* AO_MANDATORY item not found */
const HRESULT PICSRULES_E_UNKNOWNITEM       = RAT_E_BASE + 9;   /* unrecognized token */
const HRESULT PICSRULES_E_UNKNOWNMANDATORY  = RAT_E_BASE + 10;  /* unrecognized mandatory extension */
const HRESULT PICSRULES_E_EXPECTEDEND       = RAT_E_BASE + 11;  /* expected end of file */
const HRESULT PICSRULES_E_SERVICEUNDEFINED  = RAT_E_BASE + 12;  /* a service referenced is undefined */
const HRESULT PICSRULES_E_REQEXTENSIONUSED  = RAT_E_BASE + 13;  /* an unknown required extension was used */
const HRESULT PICSRULES_E_VERSION           = RAT_E_BASE + 14;  /* a non-support version was presented */

/* A RatObjectHandler parses the contents of a parenthesized object and
 * spits out a binary representation of that data, suitable for passing
 * to an object's AddItem function.  It does not consume the ')' which
 * closes the object.
 */
class RatFileParser;
typedef HRESULT (*RatObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser);

class PICSRulesFileParser;
typedef HRESULT (*PICSRulesObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);

class PicsCategory;

class PicsObjectBase
{
public:
    virtual HRESULT AddItem(RatObjectID roid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults(PicsCategory *pCategory) = 0;
};

class PICSRulesObjectBase
{
public:
    virtual HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData) = 0;
    virtual HRESULT InitializeMyDefaults() = 0;
};

const DWORD AO_SINGLE = 0x01;
const DWORD AO_SEEN = 0x02;
const DWORD AO_MANDATORY = 0x04;

struct AllowableOption
{
    RatObjectID roid;
    DWORD fdwOptions;
};

struct PICSRulesAllowableOption
{
    PICSRulesObjectID roid;
    DWORD fdwOptions;
};

class PicsEnum : public PicsObjectBase
{
    private:
    public:
        ETS etstrName, etstrIcon, etstrDesc;
        ETN etnValue;

        PicsEnum();
        ~PicsEnum();
//        char* Parse(char *pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};

class PicsRatingSystem;

class PicsCategory : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        array<PicsEnum*>     arrpPE;
        ETS   etstrTransmitAs, etstrName, etstrIcon, etstrDesc;
        ETN   etnMin,   etnMax;
        ETB   etfMulti, etfInteger, etfLabelled, etfUnordered;
        PicsRatingSystem *pPRS;

        PicsCategory();
        ~PicsCategory();
//        char* Parse(char *pStreamIn, char *pBaseName, PicsCategory *pPCparent);
        void FixupLimits();
        void SetParents(PicsRatingSystem *pOwner);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsDefault : public PicsObjectBase
{
public:
    ETB etfInteger, etfLabelled, etfMulti, etfUnordered;
    ETN etnMax, etnMin;

    PicsDefault();
    ~PicsDefault();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsExtension : public PicsObjectBase
{
public:
    LPSTR m_pszRatingBureau;

    PicsExtension();
    ~PicsExtension();

    HRESULT AddItem(RatObjectID roid, LPVOID pData);
    HRESULT InitializeMyDefaults(PicsCategory *pCategory);
};


class PicsRatingSystem : public PicsObjectBase
{
    private:
    public:
        array<PicsCategory*> arrpPC;
        ETS                  etstrFile, etstrName, etstrIcon, etstrDesc, 
                             etstrRatingService, etstrRatingSystem, etstrRatingBureau;
        ETN                  etnPicsVersion;
        ETB                  etbBureauRequired;
        PicsDefault *        m_pDefaultOptions;
        DWORD                dwFlags;
        UINT                 nErrLine;

        PicsRatingSystem();
        ~PicsRatingSystem();
        HRESULT Parse(LPCSTR pszFile, LPSTR pStreamIn);

        HRESULT AddItem(RatObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults(PicsCategory *pCategory);
        void ReportError(HRESULT hres);
};

/* bit values for PicsRatingSystem::dwFlags */
const DWORD PRS_ISVALID = 0x01;         /* this rating system was loaded successfully */
const DWORD PRS_WASINVALID = 0x02;      /* was invalid last time we tried to load it */

/* echo for PICSRules with different names for clarity */
#define PRRS_ISVALID        PRS_ISVALID;
#define PRRS_WASINVALID     PRS_WASINVALID;

class UserRating : public NLS_STR
{
public:
    INT m_nValue;
    UserRating *m_pNext;
    PicsCategory *m_pPC;

    UserRating();
    UserRating(UserRating *pCopyFrom);
    ~UserRating();

    UserRating *Duplicate(void);
    void SetName(LPCSTR pszName) { *(NLS_STR *)this = pszName; }
};


class UserRatingSystem : public NLS_STR
{
public:
    UserRating *m_pRatingList;
    UserRatingSystem *m_pNext;
    PicsRatingSystem *m_pPRS;

    UserRatingSystem();
    UserRatingSystem(UserRatingSystem *pCopyFrom);
    ~UserRatingSystem();

    UserRating *FindRating(LPCSTR pszTransmitName);
    UINT AddRating(UserRating *pRating);
    UINT ReadFromRegistry(HKEY hkeyProvider);
    UINT WriteToRegistry(HKEY hkey);

    UserRatingSystem *Duplicate(void);
    void SetName(LPCSTR pszName) { *(NLS_STR *)this = pszName; }
};


UserRatingSystem *DuplicateRatingSystemList(UserRatingSystem *pOld);
void DestroyRatingSystemList(UserRatingSystem *pList);
UserRatingSystem *FindRatingSystem(UserRatingSystem *pList, LPCSTR pszName);


class PicsUser{
private:
public:
    NLS_STR nlsUsername; 
    BOOL fAllowUnknowns, fPleaseMom, fEnabled;
    UserRatingSystem *m_pRatingSystems;

    PicsUser();
    ~PicsUser();

    UserRatingSystem *FindRatingSystem(LPCSTR pszSystemName) { return ::FindRatingSystem(m_pRatingSystems, pszSystemName); }
    UINT AddRatingSystem(UserRatingSystem *pRatingSystem);
    BOOL NewInstall();
    UINT ReadFromRegistry(HKEY hkey, char *pszUserName);
    UINT WriteToRegistry(HKEY hkey);
};


PicsUser *GetUserObject(LPCSTR pszUsername=NULL);


extern long GetStateCounter();

class PicsRatingSystemInfo
{
    public:
        array<PicsRatingSystem*> arrpPRS;
        PicsUser *               pUserObject;
        BOOL                     fRatingInstalled;
        ETS                      etstrRatingBureau;
        long                     nInfoRev;
        BOOL                     fStoreInRegistry;
        BOOL                     fSettingsValid;
        PSTR                     lpszFileName;

        PicsRatingSystemInfo() { lpszFileName=NULL; nInfoRev = ::GetStateCounter(); };
        ~PicsRatingSystemInfo();

        BOOL Init();
        BOOL FreshInstall();
        void SaveRatingSystemInfo();
        BOOL LoadProviderFiles(HKEY hKey);

    protected:
        HKEY    GetUserProfileKey( void );
};

extern PicsRatingSystemInfo *gPRSI;

void CheckGlobalInfoRev(void);


char* EtStringParse(ETS &ets, char *pIn, const char *pKeyWord, BOOL fParen);
char* EtLabelParse(char *pIn, const char *pszLongName, const char *pszShortName);
char* EtRatingParse(ETN &etn, ETS &ets, char *pInStream);

int  MyMessageBox(HWND hwnd, UINT uText, UINT uTitle, UINT uType);
int  MyMessageBox(HWND hwnd, UINT uText, UINT uText2, UINT uTitle, UINT uType);
int  MyMessageBox(HWND hwnd, LPCSTR pszText, UINT uTitle, UINT uType);
char *NonWhite(char *pIn);
BOOL MyAtoi(char *pIn, int *i);
LONG MyRegDeleteKey(HKEY hkey,LPCSTR pszSubkey);
HRESULT LoadRatingSystem(LPCSTR pszFilename, PicsRatingSystem **pprsOut);
INT_PTR DoProviderDialog(HWND hDlg, PicsRatingSystemInfo *pPRSI);

void DeleteUserSettings(PicsRatingSystem *pPRS);
void CheckUserSettings(PicsRatingSystem *pPRS);

//
// Declarations for Custom
//
extern g_fIsRunningUnderCustom;

struct CustomRatingHelper
{
    CustomRatingHelper();
    ~CustomRatingHelper();

    HMODULE hLibrary;
    CLSID clsid;
    CustomRatingHelper* pNextHelper;
    DWORD dwSort;
};

/*Pics Tree Dialog Stuff------------------------------------------------------*/
struct PRSD
{
    PicsRatingSystemInfo *pPRSI;
    PicsUser             *pPU;
    UserRatingSystem     *pTempRatings;
    HWND                  hwndBitmapCategory;
    HWND                  hwndBitmapLabel;
    BOOL                  fNewProviders;
};

enum TreeNodeEnum{tneGeneral, tneAccessList, tneRatingSystemRoot, tneRatingSystemInfo, tneRatingSystemNode, tneNone};

struct TreeNode{
    TreeNodeEnum  tne;
    void         *pData;

    TreeNode(){}
    TreeNode(TreeNodeEnum tneInit, void* pDataInit){tne=tneInit;pData=pDataInit;}
};

PicsRatingSystem *FindInstalledRatingSystem(LPCSTR pszRatingService);
PicsCategory *FindInstalledCategory(array<PicsCategory *>&arrpPC, LPCSTR pszName);

HRESULT Ansi2Unicode(LPWSTR *pdest, LPCSTR src);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msludlg.cpp ===
/****************************************************************************\
 *
 *   MSLUDLG.C
 *
 *   Updated:   Ann McCurdy
 *   Updated:   Mark Hammond (t-markh) 8/98
 *   
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include "mslubase.h"
#include "msluprop.h"
#include "commctrl.h"
#include "commdlg.h"
#include "debug.h"
#include "buffer.h"
#include "picsrule.h"
#include "picsdlg.h"    // CPicsDialog
#include "apprdlg.h"    // CApprovedSitesDialog
#include "gendlg.h"     // CGeneralDialog
#include "advdlg.h"     // CAdvancedDialog
#include "introdlg.h"   // CIntroDialog
#include "passdlg.h"    // CPasswordDialog
#include "chngdlg.h"    // CChangePasswordDialog
#include "toffdlg.h"    // CTurnOffDialog
#include <shlwapip.h>
#include <shellapi.h>
#include <wininet.h>
#include <contxids.h>

#include <mluisupp.h>

extern array<PICSRulesRatingSystem*>    g_arrpPRRS;
extern PICSRulesRatingSystem *          g_pPRRS;
extern PICSRulesRatingSystem *          g_pApprovedPRRS;

extern HMODULE                          g_hURLMON,g_hWININET;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern bool IsRegistryModifiable( HWND p_hwndParent );

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

#define NUM_PAGES 4

// Initialize the Specialized Common Controls (tree controls, etc.)
void InitializeCommonControls( void )
{
    INITCOMMONCONTROLSEX ex;

    ex.dwSize = sizeof(ex);
    ex.dwICC = ICC_NATIVEFNTCTL_CLASS;

    InitCommonControlsEx(&ex);
}

BOOL PicsOptionsDialog( HWND hwnd, PicsRatingSystemInfo * pPRSI, PicsUser * pPU )
{
    PropSheet            ps;
    PRSD                 *pPRSD;
    char                 pszBuf[MAXPATHLEN];
    BOOL                 fRet = FALSE;

    InitializeCommonControls();

    MLLoadStringA(IDS_GENERIC, pszBuf, sizeof(pszBuf));

    ps.Init( hwnd, NUM_PAGES, pszBuf, TRUE );

    pPRSD = new PRSD;
    if (!pPRSD) return FALSE;

    pPRSD->pPU                = pPU;
    pPRSD->pTempRatings       = NULL;
    pPRSD->hwndBitmapCategory = NULL;
    pPRSD->hwndBitmapLabel    = NULL;
    pPRSD->pPRSI              = pPRSI;
    pPRSD->fNewProviders      = FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        fRet = ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    return fRet;
}

INT_PTR DoPasswordConfirm(HWND hDlg)
{
    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        CPasswordDialog         passDlg( IDS_PASSWORD_LABEL );

        return passDlg.DoModal( hDlg );
    }
    else
    {
        CChangePasswordDialog<IDD_CREATE_PASSWORD>   createPassDlg;

        return createPassDlg.DoModal( hDlg ) ? PASSCONFIRM_NEW : PASSCONFIRM_FAIL;
    }
}

#define NO_EXISTING_PASSWORD PASSCONFIRM_NEW

UINT_PTR DoExistingPasswordConfirm(HWND hDlg,BOOL * fExistingPassword)
{
    if ( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        *fExistingPassword=TRUE;

        CPasswordDialog         passDlg( IDS_PASSWORD_LABEL );

        return passDlg.DoModal( hDlg );
    }
    else
    {
        *fExistingPassword=FALSE;

        return(NO_EXISTING_PASSWORD);
    }
}

STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername)
{
    BOOL fExistingPassword;

    UINT_PTR passConfirm = DoExistingPasswordConfirm(hDlg,&fExistingPassword);

    if (passConfirm == PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "RatingSetupUI() - Failed Existing Password Confirmation!" );
        return E_ACCESSDENIED;
    }

    HRESULT hres = NOERROR;

    BOOL fFreshInstall = FALSE;
    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall = TRUE;
    }

    if ( ! PicsOptionsDialog( hDlg, gPRSI, GetUserObject(pszUsername) ) )
    {
        /* If we have no saved settings and they cancelled the settings UI, and
         * they just entered a new supervisor password, then we need to remove
         * the supervisor password too, otherwise it looks like there's been
         * tampering.  The other option would be to actually commit the
         * settings in that case but disable enforcement, but the case we're
         * looking to treat here is the casual exploring user who goes past
         * entering the password but decides he doesn't want ratings after all.
         * If we leave the password and ratings settings there, then he's not
         * going to remember what the password was when he decides he does want
         * ratings a year from now.  Best to just remove the password and let
         * him enter and confirm a new one next time.
         */
        if (fFreshInstall)
        {
            if (passConfirm == PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        TraceMsg( TF_WARNING, "RatingSetupUI() - PicsOptionsDialog() Failed!" );
        return E_FAIL;
    }

    if ( ! IsRegistryModifiable( hDlg ) )
    {
        TraceMsg( TF_WARNING, "RatingSetupUI() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm = DoPasswordConfirm(hDlg);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            TraceMsg( TF_WARNING, "RatingSetupUI() - PicsOptionsDialog() Failed Password Confirmation!" );
            gPRSI->fRatingInstalled = FALSE;
            return E_FAIL;
        }
    }

    gPRSI->fSettingsValid = TRUE;
    gPRSI->SaveRatingSystemInfo();

    return NOERROR;
}

CIntroDialog        g_introDialog;

STDAPI RatingAddPropertyPages(LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lparam, DWORD dwPageFlags)
{
    HRESULT hr = NOERROR;

    ASSERT( pfnAddPage );

    if ( ! pfnAddPage )
    {
        TraceMsg( TF_ERROR, "RatingAddPropertyPages() - pfnAddPage is NULL!" );
        return E_INVALIDARG;
    }

    // Initialize the Property Page DLL Instance
    g_introDialog.m_psp.hInstance = MLGetHinst();

    HPROPSHEETPAGE      hPage;

    hPage = g_introDialog.Create();

    if ( hPage )
    {
        if ( ! pfnAddPage( hPage, lparam ) )
        {
            DestroyPropertySheetPage( hPage );

            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDAPI RatingEnable(HWND hwndParent, LPCSTR pszUsername, BOOL fEnable)
{
    // Display the Ratings UI if the Ratings are not fully installed or settings are not valid.
    if (!gPRSI || !gPRSI->fRatingInstalled || !gPRSI->fSettingsValid)
    {
        if (!fEnable)
        {
            TraceMsg( TF_WARNING, "RatingEnable() - Ratings are disabled by not being installed!" );
            return NOERROR;         /* ratings are disabled by not being installed */
        }

        HRESULT hres = RatingSetupUI(hwndParent, pszUsername);

        /* User clicked "Turn On" but we installed and let him choose his
         * settings, so give him friendly confirmation that we set things
         * up for him and he can click Settings later to change things
         * (therefore implying that he doesn't need to click Settings now).
         */
        if (SUCCEEDED(hres))
        {
            MyMessageBox(hwndParent, IDS_NOWENABLED, IDS_ENABLE_WARNING,
                         IDS_GENERIC, MB_ICONINFORMATION | MB_OK);
        }

        return hres;
    }

    if ( ! IsRegistryModifiable( hwndParent ) )
    {
        TraceMsg( TF_WARNING, "RatingEnable() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    PicsUser *pUser = ::GetUserObject(pszUsername);
    if (pUser == NULL)
    {
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    /* !a == !b to normalize non-zero values */
    if (!fEnable == !pUser->fEnabled)
    {
        return NOERROR;             /* already in state caller wants */
    }

    if (DoPasswordConfirm(hwndParent))
    {
        PicsUser *pUser = ::GetUserObject();
        if (pUser != NULL)
        {
            pUser->fEnabled = !pUser->fEnabled;
            gPRSI->SaveRatingSystemInfo();
            if (pUser->fEnabled)
            {
                MyMessageBox(hwndParent, IDS_NOW_ON, IDS_ENABLE_WARNING,
                             IDS_GENERIC, MB_OK);
            }
            else
            {
                CRegKey         keyRatings;

                if ( keyRatings.Open( HKEY_LOCAL_MACHINE, szRATINGS ) == ERROR_SUCCESS )
                {
                    DWORD         dwFlag;

                    if ( keyRatings.QueryValue( dwFlag, szTURNOFF ) == ERROR_SUCCESS )
                    {
                        if ( dwFlag != 1 )
                        {
                                CTurnOffDialog          turnOffDialog;

                                turnOffDialog.DoModal( hwndParent );
                        }
                    }
                    else
                    {
                        CTurnOffDialog          turnOffDialog;

                        turnOffDialog.DoModal( hwndParent );
                    }
                }
            }
        }
        return NOERROR;
    }
    else
    {
        return E_ACCESSDENIED;
    }
}

STDAPI_(int) ClickedOnPRF(HWND hWndOwner,HINSTANCE p_hInstance,PSTR lpszFileName,int nShow)
{
    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fExistingPassword;
    int                     iReplaceInstalled=IDYES;
    char                    szTitle[MAX_PATH],szMessage[MAX_PATH];
    PropSheet               ps;
    PRSD                    *pPRSD;
    char                    pszBuf[MAXPATHLEN];
    BOOL                    fRet=FALSE;
    UINT_PTR                passConfirm;

    if ( ! IsRegistryModifiable( hWndOwner ) )
    {
        TraceMsg( TF_WARNING, "ClickedOnPRF() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    InitializeCommonControls();

    //Make sure the user wants to do this
    if( SUCCEEDED( VerifySupervisorPassword() ) )
    {
        fExistingPassword=TRUE;

        CPasswordDialog         passDlg( IDS_PICS_RULES_LABEL, true );

        passConfirm = passDlg.DoModal( hWndOwner );
    }
    else
    {
        fExistingPassword=FALSE;

        CPasswordDialog         passDlg( IDS_PICS_RULES_LABEL, false );

        passConfirm = passDlg.DoModal( hWndOwner );
    }

    if(passConfirm==PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "ClickedOnPRF() - Password Confirmation Failed!" );
        return E_ACCESSDENIED;
    }

    if(fExistingPassword==FALSE)
    {
        passConfirm=NO_EXISTING_PASSWORD;
    }

    BOOL fFreshInstall=FALSE;

    if(!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall=TRUE;
    }

    gPRSI->lpszFileName=lpszFileName;

    MLLoadStringA(IDS_GENERIC,pszBuf,sizeof(pszBuf));

    ps.Init( hWndOwner, NUM_PAGES, pszBuf, TRUE );

    pPRSD=new PRSD;
    if (!pPRSD)
    {
        TraceMsg( TF_ERROR, "ClickedOnPRF() - Failed PRSD Creation!" );
        return FALSE;
    }

    pPRSD->pPU                =GetUserObject((LPCTSTR) NULL);
    pPRSD->pTempRatings       =NULL;
    pPRSD->hwndBitmapCategory =NULL;
    pPRSD->hwndBitmapLabel    =NULL;
    pPRSD->pPRSI              =gPRSI;
    pPRSD->fNewProviders      =FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        if(fExistingPassword==FALSE)
        {
            picsDialog.InstallDefaultProvider();
            picsDialog.PicsDlgSave();
        }

        ps.SetStartPage( ps.PropPageCount() - 1 );
        fRet=ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    if(!fRet)
    {
        // If we have no saved settings and they cancelled the settings UI, and
        // they just entered a new supervisor password, then we need to remove
        // the supervisor password too, otherwise it looks like there's been
        // tampering.  The other option would be to actually commit the
        // settings in that case but disable enforcement, but the case we're
        // looking to treat here is the casual exploring user who goes past
        // entering the password but decides he doesn't want ratings after all.
        // If we leave the password and ratings settings there, then he's not
        // going to remember what the password was when he decides he does want
        // ratings a year from now.  Best to just remove the password and let
        // him enter and confirm a new one next time.

        if(fFreshInstall)
        {
            if(passConfirm==PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        return(FALSE);
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm=DoPasswordConfirm(hWndOwner);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            gPRSI->fRatingInstalled=FALSE;
            return(FALSE);
        }
    }

    gPRSI->fSettingsValid=TRUE;
    gPRSI->SaveRatingSystemInfo();

    MLLoadString(IDS_PICSRULES_CLICKIMPORTTITLE,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_CLICKFINISHED,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(hWndOwner,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK);

    return(TRUE);
}

STDAPI_(int) ClickedOnRAT(HWND hWndOwner,HINSTANCE p_hInstance,PSTR lpszFileName,int nShow)
{
    BOOL                    bExists=FALSE,fPICSRulesSaved=FALSE,fExistingPassword;
    int                     iReplaceInstalled=IDYES;
    char                    szTitle[MAX_PATH],szMessage[MAX_PATH],szNewFile[MAX_PATH];
    char                    *lpszFile,*lpszTemp;
    PropSheet               ps;
    PRSD                    *pPRSD;
    char                    pszBuf[MAXPATHLEN];
    BOOL                    fRet=FALSE;
    UINT_PTR                passConfirm;

    if ( ! IsRegistryModifiable( hWndOwner ) )
    {
        TraceMsg( TF_WARNING, "ClickedOnRAT() - Registry is Not Modifiable!" );
        return E_ACCESSDENIED;
    }

    InitializeCommonControls();

    //Make sure the user wants to do this
    if ( SUCCEEDED ( VerifySupervisorPassword() ) )
    {
        fExistingPassword=TRUE;
    
        CPasswordDialog         passDlg( IDS_RATING_SYSTEM_LABEL, true );

        passConfirm = passDlg.DoModal( hWndOwner );
    }
    else
    {
        fExistingPassword=FALSE;

        CPasswordDialog         passDlg( IDS_RATING_SYSTEM_LABEL, false );

        passConfirm = passDlg.DoModal( hWndOwner );
    }

    if(passConfirm==PASSCONFIRM_FAIL)
    {
        TraceMsg( TF_WARNING, "ClickedOnRAT() - Password Confirmation Failed!" );
        return E_ACCESSDENIED;
    }

    if(fExistingPassword==FALSE)
    {
        passConfirm=NO_EXISTING_PASSWORD;
    }

    //Copy the file to the windows system directory
    GetSystemDirectory(szNewFile,MAX_PATH);
    
    lpszTemp=lpszFileName;

    do{
        lpszFile=lpszTemp;
    }
    while((lpszTemp=strchrf(lpszTemp+1,'\\'))!=NULL);
    
    lstrcat(szNewFile,lpszFile);
    
    CopyFile(lpszFileName,szNewFile,FALSE);

    BOOL fFreshInstall = FALSE;
    if (!gPRSI->fRatingInstalled)
    {
        gPRSI->FreshInstall();
        fFreshInstall = TRUE;
    }

    gPRSI->lpszFileName=szNewFile;

    MLLoadStringA(IDS_GENERIC,pszBuf,sizeof(pszBuf));

    ps.Init( hWndOwner, NUM_PAGES, pszBuf, TRUE );

    pPRSD=new PRSD;
    if (!pPRSD)
    {
        TraceMsg( TF_ERROR, "ClickedOnRAT() - Failed PRSD Creation!" );
        return FALSE;
    }

    pPRSD->pPU                =GetUserObject((LPCTSTR) NULL);
    pPRSD->pTempRatings       =NULL;
    pPRSD->hwndBitmapCategory =NULL;
    pPRSD->hwndBitmapLabel    =NULL;
    pPRSD->pPRSI              =gPRSI;
    pPRSD->fNewProviders      =FALSE;

    HPROPSHEETPAGE          hPage;

    CPicsDialog             picsDialog( pPRSD );
    hPage = picsDialog.Create();
    ps.MakePropPage( hPage );

    CApprovedSitesDialog    approvedSitesDialog( pPRSD );
    hPage = approvedSitesDialog.Create();
    ps.MakePropPage( hPage );

    CGeneralDialog          generalDialog( pPRSD );
    hPage = generalDialog.Create();
    ps.MakePropPage( hPage );

    CAdvancedDialog         advancedDialog( pPRSD );
    hPage = advancedDialog.Create();
    ps.MakePropPage( hPage );

    if ( ps.PropPageCount() == NUM_PAGES )
    {
        if(fExistingPassword==FALSE)
        {
            picsDialog.InstallDefaultProvider();
            picsDialog.PicsDlgSave();
        }

        ps.SetStartPage( ps.PropPageCount() - 2 );
        fRet=ps.Run();
    }

    delete pPRSD;
    pPRSD = NULL;

    if(!fRet)
    {
        // If we have no saved settings and they cancelled the settings UI, and
        // they just entered a new supervisor password, then we need to remove
        // the supervisor password too, otherwise it looks like there's been
        // tampering.  The other option would be to actually commit the
        // settings in that case but disable enforcement, but the case we're
        // looking to treat here is the casual exploring user who goes past
        // entering the password but decides he doesn't want ratings after all.
        // If we leave the password and ratings settings there, then he's not
        // going to remember what the password was when he decides he does want
        // ratings a year from now.  Best to just remove the password and let
        // him enter and confirm a new one next time.

        if(fFreshInstall)
        {
            if(passConfirm==PASSCONFIRM_NEW)
            {
                RemoveSupervisorPassword();
            }
        }

        return(FALSE);
    }

    if ( FAILED( VerifySupervisorPassword() ) )
    {
        passConfirm=DoPasswordConfirm(hWndOwner);

        if(passConfirm==PASSCONFIRM_FAIL)
        {
            gPRSI->fRatingInstalled=FALSE;
            return(FALSE);
        }
    }

    gPRSI->fSettingsValid=TRUE;
    gPRSI->SaveRatingSystemInfo();

    MLLoadString(IDS_PICSRULES_CLICKIMPORTTITLE,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_CLICKFINISHED,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(hWndOwner,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msluprop.cpp ===
/****************************************************************************\
 *
 *   MSLUPROP.CPP
 *
 *   Created:   William Taylor (wtaylor) 12/14/00
 *
 *   MS Ratings Property Sheet Class
 *   
\****************************************************************************/

/*INCLUDES--------------------------------------------------------------------*/
#include "msrating.h"
#include "msluprop.h"
#include "debug.h"
#include "apithk.h"
#include <mluisupp.h>

/*Property Sheet Class--------------------------------------------------------*/
PropSheet::PropSheet()
{
    memset(&psHeader, 0,sizeof(psHeader));
    psHeader.dwSize = sizeof(psHeader);
}

PropSheet::~PropSheet()
{
    if ( psHeader.pszCaption )
    {
        delete (LPSTR)psHeader.pszCaption;
        psHeader.pszCaption = NULL;
    }

    if ( psHeader.phpage )
    {
        delete psHeader.phpage;
        psHeader.phpage = NULL;
    }
}

BOOL PropSheet::Init(HWND hwnd, int nPages, char *szCaption, BOOL fApplyNow)
{
    HINSTANCE           hinst = _Module.GetResourceInstance();

    char *p;

    psHeader.hwndParent = hwnd;
    psHeader.hInstance  = hinst;
    p = new char [strlenf(szCaption)+1];
    if (p == NULL)
        return FALSE;
    strcpyf(p, szCaption);
    psHeader.pszCaption = p;
    
    psHeader.phpage = new HPROPSHEETPAGE [nPages];
    if (psHeader.phpage == NULL)
    {
        delete p;
        p = NULL;
        psHeader.pszCaption = NULL;
        return FALSE;
    }

    if ( ! fApplyNow )
    {
        psHeader.dwFlags |= PSH_NOAPPLYNOW;
    }

    return (psHeader.pszCaption != NULL);
}

// We can safely cast down to (int) because we don't use modeless
// property sheets.
int PropSheet::Run()
{
    return (int)::PropertySheet(&psHeader);
}

void PropSheet::MakePropPage( HPROPSHEETPAGE hPage )
{
    ASSERT( hPage );

    if ( ! hPage )
    {
        TraceMsg( TF_ERROR, "PropSheet::MakePropPage() - hPage is NULL!" );
        return;
    }

    // Add newly created page handle to list of pages in Header.
    if ( psHeader.phpage )
    {
        psHeader.phpage[psHeader.nPages] = hPage;

        if ( hPage )
        {
            psHeader.nPages++;
        }
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msluprop.h ===
/****************************************************************************\
 *
 *   MSLUPROP.H
 *
 *   Created:   William Taylor (wtaylor) 12/14/00
 *
 *   MS Ratings Property Sheet Class
 *   
\****************************************************************************/

#ifndef MSLU_PROPSHEET_H
#define MSLU_PROPSHEET_H

struct PRSD;        // Forward Declaration

class PropSheet{
    private:
        PROPSHEETHEADER psHeader;

    public:
        PropSheet();
        ~PropSheet();

        BOOL Init(HWND hwnd, int nPages, char *szCaption, BOOL fApplyNow);
        int Run();

        void    MakePropPage( HPROPSHEETPAGE hPage );

        int     PropPageCount( void )               { return psHeader.nPages; }
        void    SetStartPage( int m_nStartPage )    { psHeader.nStartPage = m_nStartPage; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msrating.cpp ===
#include "msrating.h"

/* the following defs will make msluglob.h actually define globals */
#define EXTERN
#define ASSIGN(value) = value
#include "msluglob.h"

#include "ratings.h"

#define DECL_CRTFREE
#include <crtfree.h>

HANDLE g_hmtxShell = 0;             // for critical sections
HANDLE g_hsemStateCounter = 0;      // 

#ifdef DEBUG
BOOL g_fCritical=FALSE;
#endif

HINSTANCE g_hInstance = NULL;

long g_cRefThisDll = 0;        // Reference count of this DLL.
long g_cLocks = 0;            // Number of locks on this server.

BOOL g_bMirroredOS = FALSE;

CComModule _Module;

// #define CLSID_MSRating szRORSGUID

// BEGIN_OBJECT_MAP(ObjectMap)
// OBJECT_ENTRY(CLSID_MSRating, CMSRating)
// END_OBJECT_MAP()

void LockThisDLL(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLocks);
    else
        InterlockedDecrement(&g_cLocks);
}


void RefThisDLL(BOOL fRef)
{
    if (fRef)
        InterlockedIncrement(&g_cRefThisDll);
    else
        InterlockedDecrement(&g_cRefThisDll);
}


void Netlib_EnterCriticalSection(void)
{
    WaitForSingleObject(g_hmtxShell, INFINITE);
#ifdef DEBUG
    g_fCritical=TRUE;
#endif
}

void Netlib_LeaveCriticalSection(void)
{
#ifdef DEBUG
    g_fCritical=FALSE;
#endif
    ReleaseMutex(g_hmtxShell);
}


#include <shlwapip.h>
#include <mluisupp.h>

void _ProcessAttach()
{
    ::DisableThreadLibraryCalls(::g_hInstance);

    MLLoadResources(::g_hInstance, TEXT("msratelc.dll"));

    InitMUILanguage( MLGetUILanguage() );

    // Override the Module Resources Handle.
    _Module.m_hInstResource = MLGetHinst();

    g_hmtxShell = CreateMutex(NULL, FALSE, TEXT("MSRatingMutex"));  // per-instance
    g_hsemStateCounter = CreateSemaphore(NULL, 0, 0x7FFFFFFF, "MSRatingCounter");
    g_bMirroredOS = IS_MIRRORING_ENABLED();
    
    ::InitStringLibrary();

    RatingInit();
}

void _ProcessDetach()
{
    MLFreeResources(::g_hInstance);

    // Clear the Module Resources Handle.
    _Module.m_hInstResource = NULL;

    RatingTerm();

    CleanupWinINet();

    CleanupRatingHelpers();        /* important, must do this before CleanupOLE() */

    CleanupOLE();

    CloseHandle(g_hmtxShell);
    CloseHandle(g_hsemStateCounter);
}

STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
       _Module.Init( NULL, hInstDll );
        SHFusionInitializeFromModule(hInstDll);
        g_hInstance = hInstDll;
        _ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        _ProcessDetach();
        SHFusionUninitialize();
        _Module.Term();
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msluglob.h ===
#if !defined (EXTERN)
#define EXTERN extern
#endif

#if !defined (ASSIGN)
#define ASSIGN(value)
#endif

/* the 'extern' must be forced for constant arrays, because 'const'
 * in C++ implies 'static' otherwise.
 */
#define EXTTEXT(n) extern const CHAR n[]
#define TEXTCONST(name,text) EXTTEXT(name) ASSIGN(text)

TEXTCONST(szHelpFile,"ratings.hlp");
/*  TEXTCONST(szProfileList,REGSTR_PATH_SETUP "\\ProfileList"); */
/* TEXTCONST(szSupervisor,"Supervisor"); */
TEXTCONST(szDefaultUserName,".Default");
TEXTCONST(szRatingsSupervisorKeyName,"Key");
TEXTCONST(szLogonKey,"Network\\Logon");
TEXTCONST(szUserProfiles,"UserProfiles");
TEXTCONST(szPOLICYKEY,      "System\\CurrentControlSet\\Control\\Update");
TEXTCONST(szPOLICYVALUE,    "UpdateMode");

TEXTCONST(szComDlg32,"comdlg32.dll");
TEXTCONST(szShell32,"shell32.dll");
TEXTCONST(szGetOpenFileName,"GetOpenFileNameA");    // we're ANSI, even on NT
TEXTCONST(szShellExecute,"ShellExecuteA");

TEXTCONST(VAL_UNKNOWNS,"Allow_Unknowns");
TEXTCONST(VAL_PLEASEMOM,"PleaseMom");
TEXTCONST(VAL_ENABLED,"Enabled");

TEXTCONST(szPOLUSER,        "PolicyData\\Users");
TEXTCONST(szTMPDATA,        "PolicyData");
TEXTCONST(szUSERS,          "Users");
TEXTCONST(szRATINGS,        "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings");
TEXTCONST(szRATINGHELPERS,  "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers");
TEXTCONST(szRORSGUID,       "{20EDB660-7CDD-11CF-8DAB-00AA006C1A01}");
TEXTCONST(szCLSID,          "CLSID");
TEXTCONST(szINPROCSERVER32, "InProcServer32");
TEXTCONST(szDLLNAME,        "msrating.dll");
TEXTCONST(szNTRootDir,      "%SystemRoot%\\system32\\");
TEXTCONST(sz9XRootDir,      "%WinDir%\\system\\");
TEXTCONST(szTHREADINGMODEL, "ThreadingModel");
TEXTCONST(szAPARTMENT,      "Apartment");

TEXTCONST(szPOLFILE,        "ratings.pol");
TEXTCONST(szBACKSLASH,      "\\");
TEXTCONST(szDEFAULTRATFILE, "RSACi.rat");
TEXTCONST(szFilenameTemplate, "FileName%d");        /* note, mslubase.cpp knows the length of this string is 8 + number length */
TEXTCONST(szNULL,           "");
TEXTCONST(szRATINGBUREAU,   "Bureau");

/* t-markh 8/98 - Text strings used in parsing PICSRules */

TEXTCONST(szPRShortYes,"y");
TEXTCONST(szPRYes,"yes");
TEXTCONST(szPRShortNo,"n");
TEXTCONST(szPRNo,"no");
TEXTCONST(szPRPass,"pass");
TEXTCONST(szPRFail,"fail");

//t-markh, These are not in the official spec, but we should handle them anyway
TEXTCONST(szPRShortPass,"p");
TEXTCONST(szPRShortFail,"f");


/* Text strings used in parsing rating labels. */

TEXTCONST(szDoubleCRLF,"\r\n\r\n");
TEXTCONST(szPicsOpening,"(PICS-");
TEXTCONST(szWhitespace," \t\r\n");
TEXTCONST(szExtendedAlphaNum,"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+-.,;:&=?!*~@#/");
TEXTCONST(szSingleCharTokens,"()\"");
TEXTCONST(szLeftParen,"(");
TEXTCONST(szRightParen,")");
TEXTCONST(szOptional,"optional");
TEXTCONST(szMandatory,"mandatory");
TEXTCONST(szAtOption,"at");
TEXTCONST(szByOption,"by");
TEXTCONST(szCommentOption,"comment");
TEXTCONST(szCompleteLabelOption,"complete-label");
TEXTCONST(szFullOption,"full");
TEXTCONST(szExtensionOption,"extension");
TEXTCONST(szGenericOption,"generic");
TEXTCONST(szShortGenericOption,"gen");
TEXTCONST(szForOption,"for");
TEXTCONST(szMICOption,"MIC-md5");
TEXTCONST(szMD5Option,"md5");
TEXTCONST(szOnOption,"on");
TEXTCONST(szSigOption,"signature-PKCS");
TEXTCONST(szUntilOption,"until");
TEXTCONST(szExpOption,"exp");
TEXTCONST(szRatings,"ratings");
/* TEXTCONST(szShortRatings,"r"); */
TEXTCONST(szError,"error");
TEXTCONST(szNoRatings,"no-ratings");
TEXTCONST(szLabelWord,"labels");
/* TEXTCONST(szShortLabelWord,"l"); */
TEXTCONST(szShortTrue,"t");
TEXTCONST(szTrue,"true");
TEXTCONST(szShortFalse,"f");
TEXTCONST(szFalse,"false");

/* TEXTCONST(szNegInf,"-INF"); */
/* TEXTCONST(szPosInf,"+INF"); */
TEXTCONST(szLabel,"label");
TEXTCONST(szName,"name");
TEXTCONST(szValue,"value");
TEXTCONST(szIcon,"icon");
TEXTCONST(szDescription, "description");
TEXTCONST(szCategory, "category");
TEXTCONST(szTransmitAs, "transmit-as");
TEXTCONST(szMin,"min");
TEXTCONST(szMax,"max");
/* TEXTCONST(szMultivalue,"multivalue"); */
TEXTCONST(szInteger,"integer");
TEXTCONST(szLabelOnly, "label-only");
TEXTCONST(szPicsVersion,"PICS-version");
TEXTCONST(szRatingSystem,"rating-system");
TEXTCONST(szRatingService,"rating-service");
TEXTCONST(szRatingBureau,"rating-bureau");
TEXTCONST(szBureauRequired,"bureau-required");
TEXTCONST(szDefault,"default");
TEXTCONST(szMultiValue,"multivalue");
TEXTCONST(szUnordered,"unordered");
TEXTCONST(szRatingBureauExtension,"www.w3.org/PICS/service-extensions/label-bureau");

EXTERN CHAR abSupervisorKey[16] ASSIGN({0});        /* supervisor password hash */
EXTERN CHAR fSupervisorKeyInit ASSIGN(FALSE);       /* whether abSupervisorKey has been initialized */

//t-markh 8/98
//The following TEXTCONST's are for PICSRules support.
//Dereferenced in picsrule.cpp
TEXTCONST(szPICSRulesVersion,"PicsRule");
TEXTCONST(szPICSRulesPolicy,"Policy");
TEXTCONST(szPICSRulesExplanation,"Explanation");
TEXTCONST(szPICSRulesRejectByURL,"RejectByURL");
TEXTCONST(szPICSRulesAcceptByURL,"AcceptByURL");
TEXTCONST(szPICSRulesRejectIf,"RejectIf");
TEXTCONST(szPICSRulesAcceptIf,"AcceptIf");
TEXTCONST(szPICSRulesAcceptUnless,"AcceptUnless");
TEXTCONST(szPICSRulesRejectUnless,"RejectUnless");
TEXTCONST(szPICSRulesName,"name");
TEXTCONST(szPICSRulesRuleName,"Rulename");
TEXTCONST(szPICSRulesDescription,"Description");
TEXTCONST(szPICSRulesSource,"source");
TEXTCONST(szPICSRulesSourceURL,"SourceURL");
TEXTCONST(szPICSRulesCreationTool,"CreationTool");
TEXTCONST(szPICSRulesAuthor,"author");
TEXTCONST(szPICSRulesLastModified,"LastModified");
TEXTCONST(szPICSRulesServiceInfo,"serviceinfo");
TEXTCONST(szPICSRulesSIName,"Name");
TEXTCONST(szPICSRulesShortName,"shortname");
TEXTCONST(szPICSRulesBureauURL,"BureauURL");
TEXTCONST(szPICSRulesUseEmbedded,"UseEmbedded");
TEXTCONST(szPICSRulesRATFile,"Ratfile");
TEXTCONST(szPICSRulesBureauUnavailable,"BureauUnavailable");
TEXTCONST(szPICSRulesOptExtension,"optextension");
TEXTCONST(szPICSRulesExtensionName,"extension-name");
TEXTCONST(szPICSRulesReqExtension,"reqextension");
TEXTCONST(szPICSRulesExtension,"Extension");
TEXTCONST(szPICSRulesOptionDefault,"OptionDefault");
TEXTCONST(szPICSRulesDegenerateExpression,"otherwise");
TEXTCONST(szPICSRulesOr,"or");
TEXTCONST(szPICSRulesAnd,"and");
TEXTCONST(szPICSRulesHTTP,"http");
TEXTCONST(szPICSRulesFTP,"ftp");
TEXTCONST(szPICSRulesGOPHER,"gopher");
TEXTCONST(szPICSRulesNNTP,"nntp");
TEXTCONST(szPICSRulesIRC,"irc");
TEXTCONST(szPICSRulesPROSPERO,"perospero");
TEXTCONST(szPICSRulesTELNET,"telnet");
TEXTCONST(szFINDSYSTEM,"http://www.microsoft.com/isapi/redir.dll?prd=ie&ar=ratings&pver=6");
TEXTCONST(szTURNOFF,"WarnOnOff");
TEXTCONST(szHINTVALUENAME, "Hint" );

//These TEXTCONSTS are purposly obfucated to discourage those who would
//from tampering with our settings in the registry
//t-markh - BUGBUG - need to obfuscate names after debugging
TEXTCONST(szPICSRULESSYSTEMNAME,"Name");
TEXTCONST(szPICSRULESFILENAME,"FileName");
TEXTCONST(szPICSRULESSYSTEMS,"Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Ratings\\PICSRules");
TEXTCONST(szPICSRULESNUMSYS,"NumSys");
TEXTCONST(szPICSRULESVERMAJOR,"MajorVer");
TEXTCONST(szPICSRULESVERMINOR,"MinorVer");
TEXTCONST(szPICSRULESDWFLAGS,"dwFlags");
TEXTCONST(szPICSRULESERRLINE,"errLine");
TEXTCONST(szPICSRULESPRNAME,"PRName");
TEXTCONST(szPICSRULESRULENAME,"RULEName");
TEXTCONST(szPICSRULESDESCRIPTION,"Description");
TEXTCONST(szPICSRULESPRSOURCE,"PRSource");
TEXTCONST(szPICSRULESSOURCEURL,"SourceURL");
TEXTCONST(szPICSRULESEXPRESSIONEMBEDDED,"PREEmbedded");
TEXTCONST(szPICSRULESEXPRESSIONSERVICENAME,"PREServiceName");
TEXTCONST(szPICSRULESEXPRESSIONCATEGORYNAME,"PRECategoryName");
TEXTCONST(szPICSRULESEXPRESSIONFULLSERVICENAME,"PREFullServiceName");
TEXTCONST(szPICSRULESEXPRESSIONVALUE,"PREValue");
TEXTCONST(szPICSRULESEXPRESSIONPOLICYOPERATOR,"PREOperator");
TEXTCONST(szPICSRULESEXPRESSIONOPPOLICYEMBEDDED,"PREPolEmbedded");
TEXTCONST(szPICSRULESEXPRESSIONLEFT,"PREEmbeddedLeft");
TEXTCONST(szPICSRULESEXPRESSIONRIGHT,"PREEmbeddedRight");
TEXTCONST(szPICSRULESCREATIONTOOL,"PRCreationTool");
TEXTCONST(szPICSRULESEMAILAUTHOR,"PREmailAuthor");
TEXTCONST(szPICSRULESLASTMODIFIED,"PRLastModified");
TEXTCONST(szPICSRULESPRPOLICY,"PRPolicy");
TEXTCONST(szPICSRULESNUMPOLICYS,"PRNumPolicy");
TEXTCONST(szPICSRULESPOLICYEXPLANATION,"PRPExplanation");
TEXTCONST(szPICSRULESPOLICYATTRIBUTE,"PRPPolicyAttribute");
TEXTCONST(szPICSRULESPOLICYSUB,"PRPPolicySub");
TEXTCONST(szPICSRULESBYURLINTERNETPATTERN,"PRBUInternetPattern");
TEXTCONST(szPICSRULESBYURLNONWILD,"PRBUNonWild");
TEXTCONST(szPICSRULESBYURLSPECIFIED,"PRBUSpecified");
TEXTCONST(szPICSRULESBYURLSCHEME,"PRBUScheme");
TEXTCONST(szPICSRULESBYURLUSER,"PRBUUser");
TEXTCONST(szPICSRULESBYURLHOST,"PRBUHost");
TEXTCONST(szPICSRULESBYURLPORT,"PRBUPort");
TEXTCONST(szPICSRULESBYURLPATH,"PRBUPath");
TEXTCONST(szPICSRULESBYURLURL,"PRBUUrl");
TEXTCONST(szPICSRULESSERVICEINFO,"PRServiceInfo");
TEXTCONST(szPICSRULESNUMSERVICEINFO,"PRNumSI");
TEXTCONST(szPICSRULESSIURLNAME,"PRSIURLName");
TEXTCONST(szPICSRULESSIBUREAUURL,"PRSIBureauURL");
TEXTCONST(szPICSRULESSISHORTNAME,"PRSIShortName");
TEXTCONST(szPICSRULESSIRATFILE,"PRSIRatFile");
TEXTCONST(szPICSRULESSIUSEEMBEDDED,"PRSIUseEmbedded");
TEXTCONST(szPICSRULESSIBUREAUUNAVAILABLE,"PRSIBureauUnavailable");
TEXTCONST(szPICSRULESNUMOPTEXTENSIONS,"PRNumOptExt");
TEXTCONST(szPICSRULESOPTEXTNAME,"PROEName");
TEXTCONST(szPICSRULESOPTEXTSHORTNAME,"PROEShortName");
TEXTCONST(szPICSRULESNUMREQEXTENSIONS,"PRNumReqExt");
TEXTCONST(szPICSRULESREQEXTNAME,"PRREName");
TEXTCONST(szPICSRULESREQEXTSHORTNAME,"PRREShortName");
TEXTCONST(szPICSRULESOPTEXTENSION,"PROptExt");
TEXTCONST(szPICSRULESREQEXTENSION,"PRReqExt");
TEXTCONST(szPICSRULESNUMBYURL,"PRNumURLExpressions");
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\msrating.h ===
//#define DBCS

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <regstr.h>

#include <string.h>
#include <netlib.h>

#ifdef DEBUG
#define SAVE_DEBUG
#undef DEBUG
#endif

#include <npstring.h>
#include <npdefs.h>

#ifdef SAVE_DEBUG
#define DEBUG
#endif

#if DBG
#define DEBUG 1
#endif

#include <ole2.h>
#include "ratguid.h"
#include <ccstock.h>
#ifdef ENTERCRITICAL
#undef ENTERCRITICAL
#endif // ENTERCRITICAL
#ifdef LEAVECRITICAL
#undef LEAVECRITICAL
#endif // LEAVECRITICAL
#ifdef ASSERTCRITICAL
#undef ASSERTCRITICAL
#endif // ASSERTCRITICAL

#ifndef MAXPATHLEN
#define MAXPATHLEN MAX_PATH
#endif

void Netlib_EnterCriticalSection(void);
void Netlib_LeaveCriticalSection(void);
#ifdef DEBUG
extern BOOL g_fCritical;
#endif
#define ENTERCRITICAL   Netlib_EnterCriticalSection();
#define LEAVECRITICAL   Netlib_LeaveCriticalSection();
#define ASSERTCRITICAL  ASSERT(g_fCritical);

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT        DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

extern HINSTANCE g_hInstance;

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

extern "C" {
HRESULT VerifySupervisorPassword(LPCSTR pszPassword = NULL);
HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword);
HRESULT RemoveSupervisorPassword(void);
};

#define RATINGS_MAX_PASSWORD_LENGTH 256
const UINT cchMaxUsername = 128;

extern long g_cRefThisDll;
extern long g_cLocks;
extern void LockThisDLL(BOOL fLock);
extern void RefThisDLL(BOOL fRef);

extern void CleanupWinINet(void);
extern void CleanupOLE(void);
extern void InitRatingHelpers();
extern void CleanupRatingHelpers();

class CLUClassFactory : public IClassFactory
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance( 
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
    STDMETHODIMP LockServer( 
            /* [in] */ BOOL fLock);
};

#include <commctrl.h>
#include <shfusion.h>

// ATL
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;

#include <atlcom.h>

// WTL
#include <atlapp.h>
#include <atlwin.h>
#include <atldlgs.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\passdlg.cpp ===
/****************************************************************************\
 *
 *   passdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Password Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "passdlg.h"        // CPasswordDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

DWORD CPasswordDialog::aIds[] = {
    IDC_STATIC3,            IDH_IGNORE,
    IDC_STATIC2,            IDH_IGNORE,
    IDC_OLD_HINT_LABEL,     IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,      IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_STATIC1,            IDH_RATINGS_SUPERVISOR_PASSWORD,
    IDC_PASSWORD,           IDH_RATINGS_SUPERVISOR_PASSWORD,
    0,0
};

CPasswordDialog::CPasswordDialog( int p_idsLabel, bool p_fCheckPassword )
{
    m_idsLabel = p_idsLabel;
    m_fCheckPassword = p_fCheckPassword;
}

LRESULT CPasswordDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Show or Hide the Hint and Password label/edit controls
    ShowHideControl( IDC_OLD_HINT_LABEL, m_fCheckPassword );
    ShowHideControl( IDC_OLD_HINT_TEXT, m_fCheckPassword );
    ShowHideControl( IDC_STATIC1, m_fCheckPassword );
    ShowHideControl( IDC_PASSWORD, m_fCheckPassword );

    // Reduce the height of the dialog.
    if ( ! m_fCheckPassword )
    {
        ReduceDialogHeight( IDC_STATIC2 );
    }

    // Set the text label displayed.
    if ( GetDlgItem( IDC_STATIC2 ) != NULL )
    {
        NLS_STR nlsLabel(MAX_RES_STR_LEN);

        if ( nlsLabel.LoadString( static_cast<USHORT>(m_idsLabel) ) == ERROR_SUCCESS )
        {
            ::SetWindowText( GetDlgItem(IDC_STATIC2), nlsLabel.QueryPch() );
        }
    }

    if ( GetDlgItem( IDC_PASSWORD ) != NULL )
    {
        SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
    }

    // Display previously created hint (if one exists).
    {
        CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

        oldHint.DisplayHint();
    }

    ::SetFocus(GetDlgItem(IDC_PASSWORD));

    bHandled = FALSE;
    return 0L;  // Let the system set the focus
}

LRESULT CPasswordDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndDialog(PASSCONFIRM_FAIL);
    return 0L;
}

LRESULT CPasswordDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if ( m_fCheckPassword )
    {
        CHAR pszPassword[MAXPATHLEN];
        HRESULT hRet;

        pszPassword[0] = '\0';

        ASSERT( GetDlgItem( IDC_PASSWORD ) != NULL );

        GetDlgItemText( IDC_PASSWORD, pszPassword, sizeof(pszPassword) );

        hRet = VerifySupervisorPassword(pszPassword);

        if (hRet == (NOERROR))
        {
            EndDialog(PASSCONFIRM_OK);
        }
        else
        {
            HWND            hDlg = m_hWnd;
            MyMessageBox(hDlg, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);    
            SetErrorControl( IDC_PASSWORD );
        }
    }
    else
    {
        EndDialog( PASSCONFIRM_NEW );
    }

    return 0L;
}

LRESULT CPasswordDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPasswordDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\parselbl.h ===
#ifndef PARSE_LABEL_H
#define PARSE_LABEL_H

#include "ratings.h"

//t-markh 8/98
//extends GetBool() to true/false, yes/no, pass/fail for
//PICSRules support
enum PICSRulesBooleanSwitch
{
    PR_BOOLEAN_TRUEFALSE,
    PR_BOOLEAN_PASSFAIL,
    PR_BOOLEAN_YESNO
};

//t-markh 8/98
//Definitions used by GetBool for PICSRules types
#define PR_YESNO_YES    1
#define PR_YESNO_NO     0

#define PR_PASSFAIL_PASS    1
#define PR_PASSFAIL_FAIL    0

void SkipWhitespace(LPSTR *ppsz);
BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch);
LPSTR FindTokenEnd(LPSTR pszStart);
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch=PR_BOOLEAN_TRUEFALSE);
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut, BOOL fPICSRules=FALSE);
HRESULT ParseTime(LPSTR pszTime, DWORD *pOut, BOOL fPICSRules=FALSE);

class COptionsBase
{
protected:
    COptionsBase();
    UINT m_cRef;

public:
    void AddRef();
    void Release();
    virtual void Delete();

    DWORD m_timeUntil;          /* 'until' time, in UTC net format (secs since 1/1/1970) */

    DWORD m_fdwFlags;           /* see LBLOPT_XXX below */

    LPSTR m_pszInvalidString;   /* ptr to invalid or unrecognized string */
    LPSTR m_pszURL;             /* value of "for" option, may be NULL */

    BOOL CheckUntil(DWORD timeCurrent); /* returns TRUE if 'until' option checks out */
    BOOL CheckURL(LPCSTR pszURL);       /* returns TRUE if 'for' option checks out */
};

const DWORD LBLOPT_GENERIC = 0x01;
const DWORD LBLOPT_INVALID = 0x02;
const DWORD LBLOPT_EXPIRED = 0x04;
const DWORD LBLOPT_WRONGURL = 0x08;
const DWORD LBLOPT_URLCHECKED = 0x10;


class CStaticOptions : public COptionsBase
{
public:
    CStaticOptions() { }
};


class CDynamicOptions : public COptionsBase
{
public:
    CDynamicOptions *m_pNext;

    CDynamicOptions() { m_pNext = NULL; }
    virtual void Delete();
};


class CParsedRating
{
public:
    LPSTR pszTransmitName;
    INT nValue;
    COptionsBase *pOptions;
    BOOL fFound;                /* TRUE if matches a rating in the installed system */
    BOOL fFailed;               /* TRUE if exceeded user's limit */
};


class CParsedServiceInfo
{
private:
    CParsedServiceInfo *m_pNext;
    COptionsBase *m_poptCurrent;
    CDynamicOptions *m_poptList;
    LPSTR m_pszCurrent;             /* for parsing routines */
    void SkipWhitespace() { ::SkipWhitespace(&m_pszCurrent); }

public:
    LPCSTR m_pszServiceName;        /* service name URL, may be NULL if not reported */
    LPCSTR m_pszErrorString;        /* points to error string if error reported by site */
    LPCSTR m_pszInvalidString;      /* pointer to invalid or unrecognized string found */
    BOOL m_fInstalled;              /* TRUE if this rating system is installed on this machine */
    CStaticOptions m_opt;
    array<CParsedRating> aRatings;

    CParsedServiceInfo();
    ~CParsedServiceInfo();

    CParsedServiceInfo *Next() { return m_pNext; }
    void Append(CParsedServiceInfo *pNew);
    HRESULT Parse(LPSTR *ppszServiceInfo);
    HRESULT ParseServiceError();
    HRESULT ParseOptions(LPSTR pszTokenEnd, COptionsBase *pOpt,
                     CDynamicOptions **ppOptOut, LPCSTR pszOptionEndToken);
    HRESULT ParseExtension(COptionsBase *pOpt);
    HRESULT ParseExtensionData(COptionsBase *pOpt);
    HRESULT ParseRating();
    HRESULT ParseSingleLabel();
    HRESULT ParseLabels();
};


class CParsedLabelList
{
private:
    LPSTR m_pszList;
    LPSTR m_pszCurrent;
    HRESULT ParseServiceInfo();
    void SkipWhitespace() { ::SkipWhitespace(&m_pszCurrent); }

public:
    CParsedServiceInfo m_ServiceInfo;
    LPCSTR m_pszInvalidString;      /* pointer to invalid or unrecognized string found */
    LPSTR m_pszURL;                 /* copy of URL we were originally given */
    LPSTR m_pszOriginalLabel;      /* copy of original, raw rating label */

    BOOL m_fRated;                      /* TRUE if site is considered rated */

    BOOL m_fDenied;                 /* TRUE if site is denied by a helper */
    BOOL m_fIsHelper;               /* TRUE if site is judged by a helper */
    BOOL m_fNoRating;               /* TRUE if site contains no ratings */
    
    BOOL m_fIsCustomHelper;
    LPSTR m_pszRatingName;
    LPSTR m_pszRatingReason;

    CParsedLabelList();
    ~CParsedLabelList();

    HRESULT Parse(LPSTR pszCopy);
};


extern "C" {
HRESULT ParseLabelList(LPCSTR pszList, CParsedLabelList **ppParsed);
void FreeParsedLabelList(CParsedLabelList *pList);
};  /* extern "C" */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\parselbl.cpp ===
#include "msrating.h"
#include <npassert.h>
#include "array.h"
#include "msluglob.h"
#include "parselbl.h"
#include "debug.h"
#include <convtime.h>
#include <wininet.h>

extern BOOL LoadWinINet();


COptionsBase::COptionsBase()
{
    m_cRef = 1;
    m_timeUntil = 0xffffffff;   /* as far in the future as possible */
    m_fdwFlags = 0;
    m_pszInvalidString = NULL;
    m_pszURL = NULL;
}


void COptionsBase::AddRef()
{
    m_cRef++;
}


void COptionsBase::Release()
{
    if (!--m_cRef)
        Delete();
}


void COptionsBase::Delete()
{
    /* default does nothing when deleting reference */
}


BOOL COptionsBase::CheckUntil(DWORD timeUntil)
{
    if (m_timeUntil <= timeUntil)
    {
        m_fdwFlags |= LBLOPT_EXPIRED;
        return FALSE;
    }
    return TRUE;
}


/* AppendSlash forces pszString to end in a single slash if it doesn't
 * already.  This may produce a technically invalid URL (for example,
 * "http://gregj/default.htm/", but we're only using the result for
 * comparisons against other paths similarly mangled.
 */
void AppendSlash(LPSTR pszString)
{
    LPSTR pszSlash = ::strrchrf(pszString, '/');

    if (pszSlash == NULL || *(pszSlash + 1) != '\0')
        ::strcatf(pszString, "/");
}


extern BOOL (WINAPI *pfnInternetCrackUrl)(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );
extern BOOL (WINAPI *pfnInternetCanonicalizeUrl)(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


BOOL DoURLsMatch(LPCSTR pszBaseURL, LPCSTR pszCheckURL, BOOL fGeneric)
{
    /* Buffers to canonicalize URLs into */
    LPSTR pszBaseCanon = new char[INTERNET_MAX_URL_LENGTH + 1];
    LPSTR pszCheckCanon = new char[INTERNET_MAX_URL_LENGTH + 1];

    if (pszBaseCanon != NULL && pszCheckCanon != NULL)
    {
        BOOL fCanonOK = FALSE;
        DWORD cbBuffer = INTERNET_MAX_URL_LENGTH + 1;
        if (pfnInternetCanonicalizeUrl(pszBaseURL, pszBaseCanon, &cbBuffer, ICU_ENCODE_SPACES_ONLY))
        {
            cbBuffer = INTERNET_MAX_URL_LENGTH + 1;
            if (pfnInternetCanonicalizeUrl(pszCheckURL, pszCheckCanon, &cbBuffer, ICU_ENCODE_SPACES_ONLY))
            {
                fCanonOK = TRUE;
            }
        }
        if (!fCanonOK)
        {
            delete pszBaseCanon;
            pszBaseCanon = NULL;
            delete pszCheckCanon;
            pszCheckCanon = NULL;
            return FALSE;
        }
    }

    UINT cbBaseURL = strlenf(pszBaseCanon) + 1;

    LPSTR pszBaseUrlPath = new char[cbBaseURL];
    LPSTR pszBaseExtra = new char[cbBaseURL];

    CHAR szBaseHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR szBaseUrlScheme[20];   // reasonable limit

    UINT cbCheckURL = strlenf(pszCheckCanon) + 1;

    LPSTR pszCheckUrlPath = new char[cbCheckURL];
    LPSTR pszCheckExtra = new char[cbCheckURL];

    CHAR szCheckHostName[INTERNET_MAX_HOST_NAME_LENGTH];
    CHAR szCheckUrlScheme[20];   // reasonable limit

    BOOL fOK = FALSE;

    if (pszBaseUrlPath != NULL &&
        pszBaseExtra != NULL &&
        pszCheckUrlPath != NULL &&
        pszCheckExtra != NULL)
    {

        URL_COMPONENTS ucBase, ucCheck;

        memset(&ucBase, 0, sizeof(ucBase));
        ucBase.dwStructSize      = sizeof(ucBase);
        ucBase.lpszScheme        = szBaseUrlScheme;
        ucBase.dwSchemeLength    = sizeof(szBaseUrlScheme);
        ucBase.lpszHostName      = szBaseHostName;
        ucBase.dwHostNameLength  = sizeof(szBaseHostName);
        ucBase.lpszUrlPath       = pszBaseUrlPath;
        ucBase.dwUrlPathLength   = cbBaseURL;
        ucBase.lpszExtraInfo     = pszBaseExtra;
        ucBase.dwExtraInfoLength = cbBaseURL;

        memset(&ucCheck, 0, sizeof(ucCheck));
        ucCheck.dwStructSize      = sizeof(ucCheck);
        ucCheck.lpszScheme        = szCheckUrlScheme;
        ucCheck.dwSchemeLength    = sizeof(szCheckUrlScheme);
        ucCheck.lpszHostName      = szCheckHostName;
        ucCheck.dwHostNameLength  = sizeof(szCheckHostName);
        ucCheck.lpszUrlPath       = pszCheckUrlPath;
        ucCheck.dwUrlPathLength   = cbCheckURL;
        ucCheck.lpszExtraInfo     = pszCheckExtra;
        ucCheck.dwExtraInfoLength = cbCheckURL;

        if (pfnInternetCrackUrl(pszBaseCanon, 0, 0, &ucBase) &&
            pfnInternetCrackUrl(pszCheckCanon, 0, 0, &ucCheck))
        {
            /* Scheme and host name must always match */
            if (!stricmpf(ucBase.lpszScheme, ucCheck.lpszScheme) &&
                !stricmpf(ucBase.lpszHostName, ucCheck.lpszHostName))
            {
                /* For extra info, just has to match exactly, even for a generic URL. */
                if (!*ucBase.lpszExtraInfo ||
                    !stricmpf(ucBase.lpszExtraInfo, ucCheck.lpszExtraInfo))
                {
                    AppendSlash(ucBase.lpszUrlPath);
                    AppendSlash(ucCheck.lpszUrlPath);

                    /* If not a generic label, path must match exactly too */
                    if (!fGeneric)
                    {
                        if (!stricmpf(ucBase.lpszUrlPath, ucCheck.lpszUrlPath))
                        {
                            fOK = TRUE;
                        }
                    }
                    else
                    {
                        UINT cbBasePath = strlenf(ucBase.lpszUrlPath);
                        if (!strnicmpf(ucBase.lpszUrlPath, ucCheck.lpszUrlPath, cbBasePath))
                        {
                            fOK = TRUE;
                        }
                    }
                }
            }
        }
    }

    delete pszBaseUrlPath;
    pszBaseUrlPath = NULL;
    delete pszBaseExtra;
    pszBaseExtra = NULL;

    delete pszCheckUrlPath;
    pszCheckUrlPath = NULL;
    delete pszCheckExtra;
    pszCheckExtra = NULL;

    delete pszBaseCanon;
    pszBaseCanon = NULL;
    delete pszCheckCanon;
    pszCheckCanon = NULL;

    return fOK;
}


BOOL COptionsBase::CheckURL(LPCSTR pszURL)
{
    if (!(m_fdwFlags & LBLOPT_URLCHECKED))
    {
        m_fdwFlags |= LBLOPT_URLCHECKED;

        BOOL fInvalid = FALSE;

        if (pszURL != NULL && m_pszURL != NULL)
        {
            if (LoadWinINet())
            {
                fInvalid = !DoURLsMatch(m_pszURL, pszURL, m_fdwFlags & LBLOPT_GENERIC);
            }
        }

        if (fInvalid)
        {
            m_fdwFlags |= LBLOPT_WRONGURL;
        }
    }

    return !(m_fdwFlags & LBLOPT_WRONGURL);
}


void CDynamicOptions::Delete()
{
    delete this;
}


CParsedServiceInfo::CParsedServiceInfo()
{
    m_pNext = NULL;
    m_poptCurrent = &m_opt;
    m_poptList = NULL;
    m_pszServiceName = NULL;
    m_pszErrorString = NULL;
    m_fInstalled = TRUE;        /* assume the best */
    m_pszInvalidString = NULL;
    m_pszCurrent = NULL;
}


void FreeOptionsList(CDynamicOptions *pList)
{
    while (pList != NULL)
    {
        CDynamicOptions *pNext = pList->m_pNext;
        delete pList;
        pList = pNext;
    }
}


CParsedServiceInfo::~CParsedServiceInfo()
{
    FreeOptionsList(m_poptList);
}


void CParsedServiceInfo::Append(CParsedServiceInfo *pNew)
{
    CParsedServiceInfo **ppNext = &m_pNext;

    while (*ppNext != NULL)
    {
        ppNext = &((*ppNext)->m_pNext);
    }

    *ppNext = pNew;
    pNew->m_pNext = NULL;
}


CParsedLabelList::CParsedLabelList()
{
    m_pszList = NULL;
    m_fRated = FALSE;
    m_pszInvalidString = NULL;
    m_pszURL = NULL;
    m_pszOriginalLabel = NULL;
    m_fDenied = FALSE;
    m_fIsHelper = FALSE;
    m_fNoRating = FALSE;
    m_fIsCustomHelper = FALSE;
    m_pszRatingName = NULL;
    m_pszRatingReason = NULL;
}


CParsedLabelList::~CParsedLabelList()
{
    delete m_pszList;
    m_pszList = NULL;

    CParsedServiceInfo *pInfo = m_ServiceInfo.Next();

    while (pInfo != NULL)
    {
        CParsedServiceInfo *pNext = pInfo->Next();
        delete pInfo;
        pInfo = pNext;
    }

    delete m_pszURL;
    m_pszURL = NULL;
    delete m_pszOriginalLabel;
    m_pszOriginalLabel = NULL;

    delete [] m_pszRatingName;
    m_pszRatingName = NULL;
    delete [] m_pszRatingReason;
    m_pszRatingReason = NULL;
}


/* SkipWhitespace(&pszString)
 *
 * advances pszString past whitespace characters
 */
void SkipWhitespace(LPSTR *ppsz)
{
    UINT cchWhitespace = ::strspnf(*ppsz, szWhitespace);

    *ppsz += cchWhitespace;
}


/* FindTokenEnd(pszStart)
 *
 * Returns a pointer to the end of a contiguous range of similarly-typed
 * characters (whitespace, quote mark, punctuation, or alphanumerics).
 */
LPSTR FindTokenEnd(LPSTR pszStart)
{
    LPSTR pszEnd = pszStart;

    if (*pszEnd == '\0')
    {
        return pszEnd;
    }
    else if (strchrf(szSingleCharTokens, *pszEnd))
    {
        return ++pszEnd;
    }

    UINT cch;
    cch = ::strspnf(pszEnd, szWhitespace);
    if (cch > 0)
    {
        return pszEnd + cch;
    }

    cch = ::strspnf(pszEnd, szExtendedAlphaNum);
    if (cch > 0)
    {
        return pszEnd + cch;
    }

    return pszEnd;              /* unrecognized characters */
}


/* GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch)
 *
 * t-markh 8/98 (
 * added default parameter PRBoolSwitch=PR_BOOLEAN_TRUEFALSE
 * this allows for no modification of existing code, and extension
 * of the GetBool function from true/false to include pass/fail and
 * yes/no.  The enumerated type PICSRulesBooleanSwitch is defined
 * in picsrule.h)
 *
 * Parses a boolean value at the given token and returns its value in *pfOut.
 * Legal values are 't', 'f', 'true', and 'false'.  If success, *ppszToken
 * is advanced past the boolean token and any following whitespace.  If failure,
 * *ppszToken is not modified.
 *
 * pfOut may be NULL if the caller just wants to eat the token and doesn't
 * care about its value.
 */
HRESULT GetBool(LPSTR *ppszToken, BOOL *pfOut, PICSRulesBooleanSwitch PRBoolSwitch)
{
    BOOL bValue;

    LPSTR pszTokenEnd = FindTokenEnd(*ppszToken);

    switch(PRBoolSwitch)
    {
        case PR_BOOLEAN_TRUEFALSE:
        {
            if (IsEqualToken(*ppszToken, pszTokenEnd, szShortTrue) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szTrue))
            {
                bValue = TRUE;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szShortFalse) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szFalse))
            {
                bValue = FALSE;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed True/False Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        case PR_BOOLEAN_PASSFAIL:
        {
            //szPRShortPass and szPRShortfail are not supported in the
            //official PICSRules spec, but we'll catch them anyway

            if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortPass) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRPass))
            {
                bValue = PR_PASSFAIL_PASS;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortFail) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRFail))
            {
                bValue = PR_PASSFAIL_FAIL;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed Pass/Fail Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        case PR_BOOLEAN_YESNO:
        {
            if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortYes) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRYes))
            {
                bValue = PR_YESNO_YES;
            }
            else if (IsEqualToken(*ppszToken, pszTokenEnd, szPRShortNo) ||
                IsEqualToken(*ppszToken, pszTokenEnd, szPRNo))
            {
                bValue = PR_YESNO_NO;
            }
            else
            {
                TraceMsg( TF_WARNING, "GetBool() - Failed Yes/No Token Parse at '%s'!", *ppszToken );
                return ResultFromScode(MK_E_SYNTAX);
            }

            break;
        }

        default:
        {
            return(MK_E_UNAVAILABLE);
        }
    }

    if (pfOut != NULL)
    {
        *pfOut = bValue;
    }

    *ppszToken = pszTokenEnd;
    SkipWhitespace(ppszToken);

    return NOERROR;
}


/* GetQuotedToken(&pszThisToken, &pszQuotedToken)
 *
 * Sets pszQuotedToken to point to the contents of the doublequotes.
 * pszQuotedToken may be NULL if the caller just wants to eat the token.
 * Sets pszThisToken to point to the first character after the closing
 *   doublequote.
 * Fails if pszThisToken doesn't start with a doublequote or doesn't
 *   contain a closing doublequote.
 * The closing doublequote is replaced with a null terminator, iff the
 *   function does not fail.
 */
HRESULT GetQuotedToken(LPSTR *ppszThisToken, LPSTR *ppszQuotedToken)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);

    LPSTR pszStart = *ppszThisToken;
    if (*pszStart != '\"')
    {
        TraceMsg( TF_WARNING, "GetQuotedToken() - Failed to Find Start Quote at '%s'!", pszStart );
        return hres;
    }

    pszStart++;
    LPSTR pszEndQuote = strchrf(pszStart, '\"');
    if (pszEndQuote == NULL)
    {
        TraceMsg( TF_WARNING, "GetQuotedToken() - Failed to Find End Quote at '%s'!", pszStart );
        return hres;
    }

    *pszEndQuote = '\0';
    if (ppszQuotedToken != NULL)
    {
        *ppszQuotedToken = pszStart;
    }

    *ppszThisToken = pszEndQuote+1;

    return NOERROR;
}


BOOL IsEqualToken(LPCSTR pszTokenStart, LPCSTR pszTokenEnd, LPCSTR pszTokenToMatch)
{
    UINT cbToken = strlenf(pszTokenToMatch);

    if (cbToken != (UINT)(pszTokenEnd - pszTokenStart) || strnicmpf(pszTokenStart, pszTokenToMatch, cbToken))
    {
        return FALSE;
    }

    return TRUE;
}


/* ParseLiteralToken(ppsz, pszToken) tries to match *ppsz against pszToken.
 * If they don't match, an error is returned.  If they do match, then *ppsz
 * is advanced past the token and any following whitespace.
 *
 * If ppszInvalid is NULL, then the function is non-destructive in the error
 * path, so it's OK to call ParseLiteralToken just to see if a possible literal
 * token is what's next; if the token isn't found, whatever was there didn't
 * get eaten or anything.
 *
 * If ppszInvalid is not NULL, then if the token doesn't match, *ppszInvalid
 * will be set to *ppsz.
 */
HRESULT ParseLiteralToken(LPSTR *ppsz, LPCSTR pszToken, LPCSTR *ppszInvalid)
{
    LPSTR pszTokenEnd = FindTokenEnd(*ppsz);

    if (!IsEqualToken(*ppsz, pszTokenEnd, pszToken))
    {
        if (ppszInvalid != NULL)
        {
            *ppszInvalid = *ppsz;
        }

//      TraceMsg( TF_WARNING, "ParseLiteralToken() - Token '%s' Not Found at '%s'!", pszToken, *ppsz );

        return ResultFromScode(MK_E_SYNTAX);
    }

    *ppsz = pszTokenEnd;

    SkipWhitespace(ppsz);

    return NOERROR;
}


/* ParseServiceError parses a service-error construct, once it's been
 * determined that such is the case.  m_pszCurrent has been advanced past
 * the 'error' keyword that indicates a service-error.
 *
 * We're pretty flexible about the contents of this stuff.  We basically
 * accept anything of the form:
 *
 * 'error' '(' <error string> [quoted explanations] ')'     - or -
 * 'error' <error string>
 *
 * without caring too much about what the error string actually is.
 *
 * A format with quoted explanations but without the parens would not be
 * legal, we wouldn't be able to distinguish the explanations from the
 * serviceID of the next service-info.
 */
HRESULT CParsedServiceInfo::ParseServiceError()
{
    BOOL fParen = FALSE;
    HRESULT hres = NOERROR;

    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        fParen = TRUE;
    }

    LPSTR pszErrorEnd = FindTokenEnd(m_pszCurrent);     /* find end of error string */

    m_pszErrorString = m_pszCurrent;                /* remember start of error string */
    if (fParen)
    {                           /* need to eat explanations */
        m_pszCurrent = pszErrorEnd;         /* skip error string to get to explanations */
        SkipWhitespace();
        while (SUCCEEDED(hres))
        {
            hres = GetQuotedToken(&m_pszCurrent, NULL);
            SkipWhitespace();
        }
    }

    if (fParen)
    {
        hres = ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }
    else
    {
        hres = NOERROR;
    }

    if (SUCCEEDED(hres))
    {
        *pszErrorEnd = '\0';            /* null-terminate the error string */
    }

    return hres;
}


/* ParseNumber parses a numeric token at the specified position.  If the
 * number makes sense, the pointer is advanced to the end of the number
 * and past any following whitespace, and the numeric value is returned
 * in *pnOut.  Any non-numeric characters are considered to terminate the
 * number without error;  it is assumed that higher-level parsing code
 * will eventually reject such characters if they're not supposed to be
 * there.
 *
 * pnOut may be NULL if the caller doesn't care about the number being
 * returned and just wants to eat it.
 *
 * Floating point numbers of the form nnn.nnn are rounded to the next
 * higher integer and returned as such.
 */
//t-markh 8/98 - added fPICSRules for line counting support in PICSRules
HRESULT ParseNumber(LPSTR *ppszNumber, INT *pnOut,BOOL fPICSRules)
{
    HRESULT hres = ResultFromScode(MK_E_SYNTAX);
    BOOL fNegative = FALSE;
    INT nAccum = 0;
    BOOL fNonZeroDecimal = FALSE;
    BOOL fInDecimal = FALSE;
    BOOL fFoundDigits = FALSE;

    LPSTR pszCurrent = *ppszNumber;

    /* Handle one sign character. */
    if (*pszCurrent == '+')
    {
        pszCurrent++;
    }
    else if (*pszCurrent == '-')
    {
        pszCurrent++;
        fNegative = TRUE;
    }

    for (;;)
    {
        if (*pszCurrent == '.')
        {
            fInDecimal = TRUE;
        }
        else if (*pszCurrent >= '0' && *pszCurrent <= '9')
        {
            fFoundDigits = TRUE;
            if (fInDecimal)
            {
                if (*pszCurrent > '0')
                {
                    fNonZeroDecimal = TRUE;
                }
            }
            else
            {
                nAccum = nAccum * 10 + (*pszCurrent - '0');
            }
        }
        else
        {
            break;
        }

        pszCurrent++;
    }

    if (fFoundDigits)
    {
        hres = NOERROR;
        if (fNonZeroDecimal)
        {
            nAccum++;           /* round away from zero if decimal present */
        }

        if (fNegative)
        {
            nAccum = -nAccum;
        }
    }

    if (SUCCEEDED(hres))
    {
        if (pnOut != NULL)
        {
            *pnOut = nAccum;
        }

        *ppszNumber = pszCurrent;
        if ( fPICSRules == FALSE )
        {
            SkipWhitespace(ppszNumber);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "ParseNumber() - Failed with hres=0x%x at '%s'!", hres, pszCurrent );
    }

    return hres;
}


/* ParseExtensionData just needs to get past whatever data was supplied
 * for an extension.  The PICS spec implies that it can be recursive, which
 * complicates matters a bit:
 *
 * data :: quoted-ISO-date | quotedURL | number | quotedname | '(' data* ')'
 *
 * Use of recursion here is probably OK, we don't really expect complicated
 * nested extensions all that often, and this function doesn't use a lot of
 * stack or other resources...
 */
HRESULT CParsedServiceInfo::ParseExtensionData(COptionsBase *pOpt)
{
    HRESULT hres;

    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        hres = ParseExtensionData(pOpt);
        if (FAILED(hres))
        {
            return hres;
        }

        return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }

    if (SUCCEEDED(GetQuotedToken(&m_pszCurrent, NULL)))
    {
        SkipWhitespace();
        return NOERROR;
    }

    hres = ParseNumber(&m_pszCurrent, NULL);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
    }

    return hres;
}


/* ParseExtension parses an extension option.  Syntax is:
 *
 * extension ( mandatory|optional "identifyingURL" data )
 *
 * Currently all extensions are parsed but ignored, although a mandatory
 * extension causes the entire options structure and anything dependent
 * on it to be invalidated.
 */
HRESULT CParsedServiceInfo::ParseExtension(COptionsBase *pOpt)
{
    HRESULT hres;

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing '(' at '%s'!", m_pszInvalidString );
        return hres;
    }

    hres = ParseLiteralToken(&m_pszCurrent, szOptional, &m_pszInvalidString);
    if (FAILED(hres))
    {
        hres = ParseLiteralToken(&m_pszCurrent, szMandatory, &m_pszInvalidString);
        if (SUCCEEDED(hres))
        {
            pOpt->m_fdwFlags |= LBLOPT_INVALID;
        }
    }

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Failed ParseLiteralToken() with hres=0x%x at '%s'!", hres, m_pszInvalidString );
        return hres;            /* this causes us to lose our place -- OK? */
    }

    hres = GetQuotedToken(&m_pszCurrent, NULL);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing Quote at '%s'!", m_pszInvalidString );
        return hres;
    }

    SkipWhitespace();

    while (*m_pszCurrent != ')' && *m_pszCurrent != '\0')
    {
        hres = ParseExtensionData(pOpt);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Failed ParseExtensionData() with hres=0x%x!", hres );
            return hres;
        }
    }

    if (*m_pszCurrent != ')')
    {
        m_pszInvalidString = m_pszCurrent;
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseExtension() - Missing ')' at '%s'!", m_pszInvalidString );
        return ResultFromScode(MK_E_SYNTAX);
    }

    m_pszCurrent++;
    SkipWhitespace();

    return NOERROR;
}


/* ParseTime parses a "quoted-ISO-date" as found in a label.  This is required
 * to have the following form, as quoted from the PICS spec:
 *
 * quoted-ISO-date :: YYYY'.'MM'.'DD'T'hh':'mmStz
 *  YYYY :: four-digit year
 *  MM :: two-digit month (01=January, etc.)
 *  DD :: two-digit day of month (01-31)
 *  hh :: two digits of hour (00-23)
 *  mm :: two digits of minute (00-59)
 *  S :: sign of time zone offset from UTC (+ or -)
 *  tz :: four digit amount of offset from UTC (e.g., 1512 means 15 hours 12 minutes)
 *
 * Example: "1994.11.05T08:15-0500" means Nov. 5, 1994, 8:15am, US EST.
 *
 * Time is parsed into NET format -- seconds since 1970 (easiest to adjust for
 * time zones, and compare with).  Returns an error if string is invalid.
 */

/* Template describing the string format.  'n' means a digit, '+' means a
 * plus or minus sign, any other character must match that literal character.
 */
const char szTimeTemplate[] = "nnnn.nn.nnTnn:nn+nnnn";
const char szPICSRulesTimeTemplate[] = "nnnn-nn-nnTnn:nn+nnnn";

HRESULT ParseTime(LPSTR pszTime, DWORD *pOut, BOOL fPICSRules)
{
    /* Copy the time string into a temporary buffer, since we're going to
     * stomp on some separators.  We preserve the original in case it turns
     * out to be invalid and we have to show it to the user later.
     */
    LPCSTR pszCurrTemplate;
    
    char szTemp[sizeof(szTimeTemplate)];

    if (::strlenf(pszTime) >= sizeof(szTemp))
    {
        TraceMsg( TF_WARNING, "ParseTime() - Time String Too Long (pszTime='%s', %d chars expected)!", pszTime, sizeof(szTemp) );
        return ResultFromScode(MK_E_SYNTAX);
    }

    strcpyf(szTemp, pszTime);

    LPSTR pszCurrent = szTemp;

    if(fPICSRules)
    {
        pszCurrTemplate = szPICSRulesTimeTemplate;
    }
    else
    {
        pszCurrTemplate = szTimeTemplate;
    }

    /* First validate the format against the template.  If that succeeds, then
     * we get to make all sorts of assumptions later.
     *
     * We stomp all separators except the +/- for the timezone with spaces
     * so that ParseNumber will (a) skip them for us, and (b) not interpret
     * the '.' separators as decimal points.
     */
    BOOL fOK = TRUE;
    while (*pszCurrent && *pszCurrTemplate && fOK)
    {
        char chCurrent = *pszCurrent;

        switch (*pszCurrTemplate)
        {
        case 'n':
            if (chCurrent < '0' || chCurrent > '9')
            {
                fOK = FALSE;
            }

            break;

        case '+':
            if (chCurrent != '+' && chCurrent != '-')
            {
                fOK = FALSE;
            }

            break;

        default:
            if (chCurrent != *pszCurrTemplate)
            {
                fOK = FALSE;
            }
            else
            {
                *pszCurrent = ' ';
            }
            break;
        }

        pszCurrent++;
        pszCurrTemplate++;
    }

    /* If invalid character, or didn't reach the ends of both strings
     * simultaneously, fail.
     */
    if (!fOK || *pszCurrent || *pszCurrTemplate)
    {
        TraceMsg( TF_WARNING, "ParseTime() - Invalid Character or Strings Mismatch (fOK=%d, pszCurrent='%s', pszCurrTemplate='%s')!", fOK, pszCurrent, pszCurrTemplate );
        return ResultFromScode(MK_E_SYNTAX);
    }

    HRESULT hres;
    int n;
    SYSTEMTIME st;

    /* We parse into SYSTEMTIME structure because it has separate fields for
     * the different components.  We then convert to net time (seconds since
     * Jan 1 1970) to easily add the timezone bias and compare with other
     * times.
     *
     * The sense of the bias sign is inverted because it indicates the direction
     * of the bias FROM UTC.  We want to use it to convert the specified time
     * back TO UTC.
     */

    int nBiasSign = -1;
    int nBiasNumber;
    pszCurrent = szTemp;
    hres = ParseNumber(&pszCurrent, &n);
    if (SUCCEEDED(hres) && n >= 1980)
    {
        st.wYear = (WORD)n;
        hres = ParseNumber(&pszCurrent, &n);
        if (SUCCEEDED(hres) && n <= 12)
        {
            st.wMonth = (WORD)n;
            hres = ParseNumber(&pszCurrent, &n);
            if (SUCCEEDED(hres) && n < 32)
            {
                st.wDay = (WORD)n;
                hres = ParseNumber(&pszCurrent, &n);
                if (SUCCEEDED(hres) && n <= 23)
                {
                    st.wHour = (WORD)n;
                    hres = ParseNumber(&pszCurrent, &n);
                    if (SUCCEEDED(hres) && n <= 59)
                    {
                        st.wMinute = (WORD)n;
                        if (*(pszCurrent++) == '-')
                        {
                            nBiasSign = 1;
                        }

                        hres = ParseNumber(&pszCurrent, &nBiasNumber);
                    }
                }
            }
        }
    }

    /* Seconds are used by the time converter, but are not specified in
     * the label.
     */
    st.wSecond = 0;

    /* Other fields (wDayOfWeek, wMilliseconds) are ignored when converting
     * to net time.
     */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "ParseTime() - Failed to Parse Time where hres=0x%x!", hres );
        return hres;
    }

    DWORD dwTime = SystemToNetDate(&st);

    /* The bias number is 4 digits, but hours and minutes.  Convert to
     * a number of seconds.
     */
    nBiasNumber = (((nBiasNumber / 100) * 60) + (nBiasNumber % 100)) * 60;

    /* Adjust the time by the timezone bias, and return to the caller. */
    *pOut = dwTime + (nBiasNumber * nBiasSign);

    return hres;
}


/* ParseOptions parses through any label options that may be present at
 * m_pszCurrent.  pszTokenEnd initially points to the end of the token at
 * m_pszCurrent, a small perf win since the caller has already calculated
 * it.  If ParseOptions is filling in the static options structure embedded
 * in the serviceinfo, pOpt points to it and ppOptOut will be NULL.  If pOpt
 * is NULL, then ParseOptions will construct a new CDynamicOptions object
 * and return it in *ppOptOut, iff any new options are found at the current
 * token.  pszOptionEndToken indicates the token which ends the list of
 * options -- either "labels" or "ratings".  A token consisting of just the
 * first character of pszOptionEndToken will also terminate the list.
 *
 * ParseOptions fails iff it finds an option it doesn't recognize, or a
 * syntax error in an option it does recognize.  It succeeds if all options
 * are syntactically correct or if there are no options to parse.
 *
 * The token which terminates the list of options is also consumed.
 *
 * FEATURE - how should we flag mandatory extensions, 'until' options that
 * give an expired date, etc.?  set a flag in the CParsedServiceInfo and
 * keep parsing?
 */

enum OptionID {
    OID_AT,
    OID_BY,
    OID_COMMENT,
    OID_FULL,
    OID_EXTENSION,
    OID_GENERIC,
    OID_FOR,
    OID_MIC,
    OID_ON,
    OID_SIG,
    OID_UNTIL
};

enum OptionContents {
    OC_QUOTED,
    OC_BOOL,
    OC_SPECIAL
};

const struct {
    LPCSTR pszToken;
    OptionID oid;
    OptionContents oc;
} aKnownOptions[] = {
    { szAtOption, OID_AT, OC_QUOTED },
    { szByOption, OID_BY, OC_QUOTED },
    { szCommentOption, OID_COMMENT, OC_QUOTED },
    { szCompleteLabelOption, OID_FULL, OC_QUOTED },
    { szFullOption, OID_FULL, OC_QUOTED },
    { szExtensionOption, OID_EXTENSION, OC_SPECIAL },
    { szGenericOption, OID_GENERIC, OC_BOOL },
    { szShortGenericOption, OID_GENERIC, OC_BOOL },
    { szForOption, OID_FOR, OC_QUOTED },
    { szMICOption, OID_MIC, OC_QUOTED },
    { szMD5Option, OID_MIC, OC_QUOTED },
    { szOnOption, OID_ON, OC_QUOTED },
    { szSigOption, OID_SIG, OC_QUOTED },
    { szUntilOption, OID_UNTIL, OC_QUOTED },
    { szExpOption, OID_UNTIL, OC_QUOTED }
};

const UINT cKnownOptions = sizeof(aKnownOptions) / sizeof(aKnownOptions[0]);
    

HRESULT CParsedServiceInfo::ParseOptions(LPSTR pszTokenEnd, COptionsBase *pOpt,
                             CDynamicOptions **ppOptOut, LPCSTR pszOptionEndToken)
{
    HRESULT hres = NOERROR;
    char szShortOptionEndToken[2];

    szShortOptionEndToken[0] = *pszOptionEndToken;
    szShortOptionEndToken[1] = '\0';

    if (pszTokenEnd == NULL)
    {
        pszTokenEnd = FindTokenEnd(m_pszCurrent);
    }

    do
    {
        /* Have we hit the token that signals the end of the options? */
        if (IsEqualToken(m_pszCurrent, pszTokenEnd, pszOptionEndToken) ||
            IsEqualToken(m_pszCurrent, pszTokenEnd, szShortOptionEndToken))
        {
            m_pszCurrent = pszTokenEnd;
            SkipWhitespace();
            return NOERROR;
        }

        for (UINT i=0; i<cKnownOptions; i++)
        {
            if (IsEqualToken(m_pszCurrent, pszTokenEnd, aKnownOptions[i].pszToken))
            {
                break;
            }
        }

        if (i == cKnownOptions)
        {
            m_pszInvalidString = m_pszCurrent;

            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Unknown Token Encountered at '%s'!", m_pszInvalidString );

            return ResultFromScode(MK_E_SYNTAX);    /* unrecognized option */
        }

        m_pszCurrent = pszTokenEnd;
        SkipWhitespace();

        /* Now parse the stuff that comes after the option token. */
        LPSTR pszQuotedString = NULL;
        BOOL fBoolOpt = FALSE;
        switch (aKnownOptions[i].oc)
        {
        case OC_QUOTED:
            hres = GetQuotedToken(&m_pszCurrent, &pszQuotedString);
            break;

        case OC_BOOL:
            hres = GetBool(&m_pszCurrent, &fBoolOpt);
            break;

        case OC_SPECIAL:
            break;          /* we'll handle this specially */
        }

        if (FAILED(hres))
        { /* incorrect stuff after the option token */
            m_pszInvalidString = m_pszCurrent;

            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed Option Contents Parse at '%s'!", m_pszInvalidString );

            return hres;
        }

        if (pOpt == NULL)
        {     /* need to allocate a new options structure */
            CDynamicOptions *pNew = new CDynamicOptions;
            if (pNew == NULL)
            {
                TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed to Create CDynamicOptions Object!" );
                return ResultFromScode(E_OUTOFMEMORY);
            }

            pOpt = pNew;
            *ppOptOut = pNew;   /* return new structure to caller */
        }

        /* Now actually do useful stuff based on which option it is. */
        switch (aKnownOptions[i].oid)
        {
        case OID_UNTIL:
            hres = ParseTime(pszQuotedString, &pOpt->m_timeUntil);
            if (FAILED(hres))
            {
                m_pszInvalidString = pszQuotedString;
            }

            break;

        case OID_FOR:
            pOpt->m_pszURL = pszQuotedString;
            break;

        case OID_GENERIC:
            if (fBoolOpt)
            {
                pOpt->m_fdwFlags |= LBLOPT_GENERIC;
            }
            else
            {
                pOpt->m_fdwFlags &= ~LBLOPT_GENERIC;
            }
            break;

        case OID_EXTENSION:
            hres = ParseExtension(pOpt);
            break;
        }

        if ( FAILED(hres) )
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseOptions() - Failed Option ID Parse at '%s'!", m_pszCurrent );
        }

        SkipWhitespace();

        pszTokenEnd = FindTokenEnd(m_pszCurrent);
    } while (SUCCEEDED(hres));

    return hres;
}


/* CParsedServiceInfo::ParseRating parses a single rating -- a transmit-name
 * followed by either a number or a parenthesized list of multi-values.  The
 * corresponding rating is stored in the current list of ratings.
 */
HRESULT CParsedServiceInfo::ParseRating()
{
    LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);
    if (*m_pszCurrent == '\0')
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseRating() - Empty String after FindTokenEnd()!" );
        return ResultFromScode(MK_E_SYNTAX);
    }

    *(pszTokenEnd++) = '\0';

    CParsedRating r;

    r.pszTransmitName = m_pszCurrent;
    m_pszCurrent = pszTokenEnd;
    SkipWhitespace();

    HRESULT hres = ParseNumber(&m_pszCurrent, &r.nValue);
    if (FAILED(hres))
    {
        m_pszInvalidString = m_pszCurrent;
        return hres;
    }

    r.pOptions = m_poptCurrent;
    r.fFound = FALSE;
    r.fFailed = FALSE;

    return (aRatings.Append(r) ? NOERROR : ResultFromScode(E_OUTOFMEMORY));
}


/* CParsedServiceInfo::ParseSingleLabel starts parsing where a single-label
 * should occur.  A single-label may contain options (in which case a new
 * options structure will be allocated), following by the keyword 'ratings'
 * (or 'r') and a parenthesized list of ratings.
 */
HRESULT CParsedServiceInfo::ParseSingleLabel()
{
    HRESULT hres;
    CDynamicOptions *pOpt = NULL;

    hres = ParseOptions(NULL, NULL, &pOpt, szRatings);
    if (FAILED(hres))
    {
        if (pOpt != NULL)
        {
            pOpt->Release();
        }

        return hres;
    }
    if (pOpt != NULL)
    {
        pOpt->m_pNext = m_poptList;
        m_poptList = pOpt;
        m_poptCurrent = pOpt;
    }

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseSingleLabel() - ParseLiteralToken() Failed with hres=0x%x!", hres );
        return hres;
    }

    do
    {
        hres = ParseRating();
    } while (SUCCEEDED(hres) && *m_pszCurrent != ')' && *m_pszCurrent != '\0');

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseSingleLabel() - ParseRating() Failed with hres=0x%x!", hres );
        return hres;
    }

    return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
}


/* CParsedServiceInfo::ParseLabels starts parsing just past the keyword
 * 'labels' (or 'l').  It needs to handle a label-error, a single-label,
 * or a parenthesized list of single-labels.
 */
HRESULT CParsedServiceInfo::ParseLabels()
{
    HRESULT hres;

    /* First deal with a label-error.  It begins with the keyword 'error'. */
    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szError, NULL)))
    {
        hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - ParseLiteralToken() Failed with hres=0x%x!", hres );
            return hres;
        }

        LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);
        m_pszErrorString = m_pszCurrent;
        m_pszCurrent = pszTokenEnd;
        SkipWhitespace();

        while (*m_pszCurrent != ')')
        {
            hres = GetQuotedToken(&m_pszCurrent, NULL);
            if (FAILED(hres))
            {
                m_pszInvalidString = m_pszCurrent;
                TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - GetQuotedToken() Failed with hres=0x%x!", hres );
                return hres;
            }
        }

        return NOERROR;
    }

    BOOL fParenthesized = FALSE;

    /* If we see a left paren, it's a parenthesized list of single-labels,
     * which basically means we'll have to eat an extra parenthesis later.
     */
    if (SUCCEEDED(ParseLiteralToken(&m_pszCurrent, szLeftParen, NULL)))
    {
        fParenthesized = TRUE;
    }

    for (;;)
    {
        /* Things which signify the end of the label list:
         * - the close parenthesis checked for above
         * - a quoted string, indicating the next service-info
         * - the end of the string
         * - a service-info saying "error (no-ratings <explanation>)"
         *
         * Check the easy ones first.
         */
        if (*m_pszCurrent == ')' || *m_pszCurrent == '\"' || *m_pszCurrent == '\0')
        {
            break;
        }

        /* Now look for that tricky error-state service-info. */
        LPSTR pszTemp = m_pszCurrent;
        if (SUCCEEDED(ParseLiteralToken(&pszTemp, szError, NULL)) &&
            SUCCEEDED(ParseLiteralToken(&pszTemp, szLeftParen, NULL)) &&
            SUCCEEDED(ParseLiteralToken(&pszTemp, szNoRatings, NULL)))
        {
            break;
        }

        hres = ParseSingleLabel();
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedServiceInfo::ParseLabels() - ParseSingleLabel() Failed with hres=0x%x!", hres );
            return hres;
        }
    }

    if (fParenthesized)
    {
        return ParseLiteralToken(&m_pszCurrent, szRightParen, &m_pszInvalidString);
    }

    return NOERROR;
}


/* Parse is passed a pointer to a pointer to something which should
 * be a service-info string (i.e., not the close paren for the labellist, and
 * not the end of the string).  The caller's string pointer is advanced to the
 * end of the service-info string.
 */
HRESULT CParsedServiceInfo::Parse(LPSTR *ppszServiceInfo)
{
    /* NOTE: Do not return out of this function without copying m_pszCurrent
     * back into *ppszServiceInfo!  Always store your return code in hres and
     * exit out the bottom of the function.
     */
    HRESULT hres;

    m_pszCurrent = *ppszServiceInfo;

    hres = ParseLiteralToken(&m_pszCurrent, szError, NULL);
    if (SUCCEEDED(hres))
    {
        /* Keyword is 'error'.  Better be followed by '(', 'no-ratings',
         * explanations, and a close-paren.
         */
        hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
        if (SUCCEEDED(hres))
        {
            hres = ParseLiteralToken(&m_pszCurrent, szNoRatings, &m_pszInvalidString);
        }

        if (SUCCEEDED(hres))
        {
            m_pszErrorString = szNoRatings;

            while (*m_pszCurrent != ')' && *m_pszCurrent != '\0') 
            {
                hres = GetQuotedToken(&m_pszCurrent, NULL);
                if (FAILED(hres))
                {
                    m_pszInvalidString = m_pszCurrent;
                    break;
                }

                SkipWhitespace();
            }

            if (*m_pszCurrent == ')')
            {
                m_pszCurrent++;
                SkipWhitespace();
            }
        }
    }
    else
    {
        /* Keyword is not 'error'.  Better start with a serviceID --
         * a quoted URL.
         */
        LPSTR pszServiceID;
        hres = GetQuotedToken(&m_pszCurrent, &pszServiceID);
        if (SUCCEEDED(hres))
        {
            m_pszServiceName = pszServiceID;

            SkipWhitespace();

            /* Past the serviceID.  Next either 'error' indicating a service-error,
             * or we start options and then a labelword.
             */

            LPSTR pszTokenEnd = FindTokenEnd(m_pszCurrent);

            if (IsEqualToken(m_pszCurrent, pszTokenEnd, szError))
            {
                m_pszCurrent = pszTokenEnd;
                SkipWhitespace();
                hres = ParseServiceError();
            }
            else
            {
                hres = ParseOptions(pszTokenEnd, &m_opt, NULL, ::szLabelWord);
                if (SUCCEEDED(hres))
                {
                    hres = ParseLabels();
                }
            }
        }
        else
        {
            m_pszInvalidString = m_pszCurrent;
        }
    }

    *ppszServiceInfo = m_pszCurrent;
    return hres;
}


const char szPicsVersionLabel[] = "PICS-";
const UINT cchLabel = (sizeof(szPicsVersionLabel)-1) / sizeof(szPicsVersionLabel[0]);

HRESULT CParsedLabelList::Parse(LPSTR pszCopy)
{
    m_pszList = pszCopy;                /* we own the label list string now */

    /* Make another copy, which we won't carve up during parsing, so that the
     * access-denied dialog can compare literal labels.
     */
    m_pszOriginalLabel = new char[::strlenf(pszCopy)+1];
    if (m_pszOriginalLabel != NULL)
    {
        ::strcpyf(m_pszOriginalLabel, pszCopy);
    }

    m_pszCurrent = m_pszList;

    SkipWhitespace();

    HRESULT hres;

    hres = ParseLiteralToken(&m_pszCurrent, szLeftParen, &m_pszInvalidString);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - ParseLiteralToken() Failed with hres=0x%x!", hres );
        return hres;
    }

    if (strnicmpf(m_pszCurrent, szPicsVersionLabel, cchLabel))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - Pics Version Label Comparison Failed at '%s'!", m_pszCurrent );
        return ResultFromScode(MK_E_SYNTAX);
    }

    m_pszCurrent += cchLabel;
    INT nVersion;
    hres = ParseNumber(&m_pszCurrent, &nVersion);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - ParseNumber() Failed with hres=0x%x!", hres );
        return hres;
    }

    CParsedServiceInfo *psi = &m_ServiceInfo;

    do
    {
        hres = psi->Parse(&m_pszCurrent);
        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - psi->Parse() Failed with hres=0x%x!", hres );
            return hres;
        }

        if (*m_pszCurrent != ')' && *m_pszCurrent != '\0')
        {
            CParsedServiceInfo *pNew = new CParsedServiceInfo;
            if (pNew == NULL)
            {
                TraceMsg( TF_WARNING, "CParsedLabelList::Parse() - Failed to Create CParsedServiceInfo!" );
                return ResultFromScode(E_OUTOFMEMORY);
            }

            psi->Append(pNew);
            psi = pNew;
        }
    } while (*m_pszCurrent != ')' && *m_pszCurrent != '\0');

    return NOERROR;
}


HRESULT ParseLabelList(LPCSTR pszList, CParsedLabelList **ppParsed)
{
    LPSTR pszCopy = new char[strlenf(pszList)+1];
    if (pszCopy == NULL)
    {
        TraceMsg( TF_WARNING, "ParseLabelList() - Failed to Create pszCopy!" );
        return ResultFromScode(E_OUTOFMEMORY);
    }

    ::strcpyf(pszCopy, pszList);

    *ppParsed = new CParsedLabelList;
    if (*ppParsed == NULL)
    {
        TraceMsg( TF_WARNING, "ParseLabelList() - Failed to Create CParsedLabelList!" );
        delete pszCopy;
        pszCopy = NULL;
        return ResultFromScode(E_OUTOFMEMORY);
    }

    return (*ppParsed)->Parse(pszCopy);
}


void FreeParsedLabelList(CParsedLabelList *pList)
{
    delete pList;
    pList = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\pch.cpp ===
#include "msrating.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\passdlg.h ===
/****************************************************************************\
 *
 *   passdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Password Dialog
 *
\****************************************************************************/

#ifndef PASSWORD_DIALOG_H
#define PASSWORD_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT PASSCONFIRM_FAIL = 0;
const UINT PASSCONFIRM_OK = 1;
const UINT PASSCONFIRM_NEW = 2;

class CPasswordDialog: public CBaseDialog<CPasswordDialog>
{
private:
    static DWORD aIds[];
    int m_idsLabel;
    bool m_fCheckPassword;

public:
    enum { IDD = IDD_PASSWORD };

public:
    CPasswordDialog( int p_idsLabel, bool p_fCheckPassword = true );

public:
    typedef CPasswordDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        COMMAND_ID_HANDLER(IDOK, OnOK)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\parserat.cpp ===
/****************************************************************************\
 *
 *   PARSERAT.C -- Code to parse .RAT files
 *
 *   Created:   Greg Jones
 *   
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "parselbl.h"       /* we use a couple of this guy's subroutines */
#include "msluglob.h"
#include "debug.h"

// Sundown: pointer to boolean conversion
#pragma warning (disable: 4800)

/****************************************************************************
Some design notes on how this parser works:

A ParenThing is:

'(' identifier [stuff] ')'

where [stuff] could be:
    a quoted string
    a number
    a boolean
    a series of ParenThings
    in the case of extensions:
        a quoted string, followed by
        one or more quoted strings and/or ParenThings

The entire .RAT file is a ParenThing, except that it has no identifier, just
a list of ParenThings inside it.


**********************************************************************
We pass the parser a schema for what things it expects -- we have
a big array listing identifiers for each different possible keyword, and
each parser call receives a smaller array containing only those indices
that are valid to occur within that object.

We make PicsRatingSystem, PicsCategory, and PicsEnum derive from a common
base class which supports a virtual function AddItem(ID,data).  So at the
top level, we construct an (empty) PicsRatingSystem.  We call the parser,
giving it a pointer to that guy, and a structure describing what to parse --
the ParenObject's token is a null string (since the global structure is the
one that doesn't start with a token before its first embedded ParenThing),
and we give a list saying the allowable things in a PicsRatingSystem are
PICS-version, rating-system, rating-service, default, description, extension,
icon, name, category.  There is a global table indicating a handler function
for every type of ParenThing, which knows how to create a data structure
completely describing that ParenThing.  (That data structure could be as
simple as a number or as complex as allocating and parsing a complete
PicsCategory object.)

The parser walks along, and for each ParenThing he finds, he identifies it
by looking up its token in the list provided by the caller. Each entry in
that list should include a field which indicates whether multiple things
of that identity are allowed (e.g., 'category') or not (e.g., rating-system).
If only one is allowed, then when the parser finds one he marks it as having
been found.

When the parser identifies the ParenThing, he calls its handler function to
completely parse the data in the ParenThing and return that object into an
LPVOID provided by the parser.  If that is successful, the parser then calls
its object's AddItem(ID,data) virtual function to add the specified item to
the object, relying on the object itself to know what type "data" points to --
a number, a pointer to a heap string which can be given to ETS::SetTo, a
pointer to a PicsCategory object which can be appended to an array, etc.

The RatFileParser class exists solely to provide a line number shared by
all the parsing routines.  This line number is updated as the parser walks
through the file, and is frozen as soon as an error is found.  This line
number can later be reported to the user to help localize errors in RAT files.

*****************************************************************************/

class RatFileParser
{
public:
    UINT m_nLine;

    RatFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn);
    HRESULT ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                           AllowableOption **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    /* where we are in the text stream */
        AllowableOption aao[],          /* allowable things inside this object */
        PicsObjectBase *pObject         /* object to set parameters into */
    );
    char* FindNonWhite(char *pc);
};



/* White returns a pointer to the first whitespace character starting at pc.
 */
char* White(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc == '\0' ||
            *pc ==' ' ||
            *pc == '\t' ||
            *pc == '\r' ||
            *pc == '\n')
        {
            return pc;
        }
        pc++;
    }
}


/* NonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* NonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        pc++;
    }
}


/* FindNonWhite returns a pointer to the first non-whitespace character starting
 * at pc.
 */
char* RatFileParser::FindNonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')
            m_nLine++;
        pc++;
    }
}


/* Returns a pointer to the closing doublequote of a quoted string, counting
 * linefeeds as we go.  Returns NULL if no closing doublequote found.
 */
LPSTR RatFileParser::EatQuotedString(LPSTR pIn)
{
    LPSTR pszQuote = strchrf(pIn, '\"');
    if (pszQuote == NULL)
    {
        TraceMsg( TF_WARNING, "RatFileParser::EatQuotedString() - No closing doublequote found!" );
        return NULL;
    }

    pIn = strchrf(pIn, '\n');
    while (pIn != NULL && pIn < pszQuote)
    {
        m_nLine++;
        pIn = strchrf(pIn+1, '\n');
    }

    return pszQuote;
}



/***************************************************************************
    Worker functions for inheriting category properties and other
    miscellaneous category stuff.
***************************************************************************/

HRESULT PicsCategory::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsRatingSystem::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (m_pDefaultOptions != NULL)
        return m_pDefaultOptions->InitializeMyDefaults(pCategory);

    return NOERROR;             /* no defaults to initialize */
}


HRESULT PicsDefault::InitializeMyDefaults(PicsCategory *pCategory)
{
    if (!pCategory->etnMin.fIsInit()      && etnMin.fIsInit())
        pCategory->etnMin.Set(etnMin.Get());

    if (!pCategory->etnMax.fIsInit()      && etnMax.fIsInit())
        pCategory->etnMax.Set(etnMax.Get());

    if (!pCategory->etfMulti.fIsInit()    && etfMulti.fIsInit())
        pCategory->etfMulti.Set(etfMulti.Get());

    if (!pCategory->etfInteger.fIsInit()  && etfInteger.fIsInit())
        pCategory->etfInteger.Set(etfInteger.Get());

    if (!pCategory->etfLabelled.fIsInit() && etfLabelled.fIsInit())
        pCategory->etfLabelled.Set(etfLabelled.Get());

    if (!pCategory->etfUnordered.fIsInit() && etfUnordered.fIsInit())
        pCategory->etfUnordered.Set(etfUnordered.Get());

    return NOERROR;
}


HRESULT PicsEnum::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an enum */
}


PicsExtension::PicsExtension()
    : m_pszRatingBureau(NULL)
{
    /* nothing else */
}


PicsExtension::~PicsExtension()
{
    delete m_pszRatingBureau;
    m_pszRatingBureau = NULL;
}


HRESULT PicsExtension::InitializeMyDefaults(PicsCategory *pCategory)
{
    return E_NOTIMPL;       /* should never have a category inherit from an extension */
}


void PicsCategory::FixupLimits()
{
    BOOL fLabelled = (etfLabelled.fIsInit() && etfLabelled.Get());
    
    /*fix up max and min values*/
    if (fLabelled ||
        (arrpPE.Length()>0 && (!etnMax.fIsInit() || !etnMax.fIsInit())))
    {                
        if (arrpPE.Length() > 0)
        {
            if (!etnMax.fIsInit())
                etnMax.Set(N_INFINITY);
            if (!etnMin.fIsInit())
                etnMin.Set(P_INFINITY);
            for (int z=0;z<arrpPE.Length();++z)
            {
                if (arrpPE[z]->etnValue.Get() > etnMax.Get()) etnMax.Set(arrpPE[z]->etnValue.Get());
                if (arrpPE[z]->etnValue.Get() < etnMin.Get()) etnMin.Set(arrpPE[z]->etnValue.Get());
            }
        }
        else
        {
            etfLabelled.Set(FALSE); /* no enum labels?  better not have labelled flag then */
            fLabelled = FALSE;
        }
    }

    /*sort labels by value*/
    if (fLabelled)
    {
        int x,y;
        PicsEnum *pPE;
        for (x=0;x<arrpPE.Length()-1;++x)
        {
            for (y=x+1;y<arrpPE.Length();++y)
            {
                if (arrpPE[y]->etnValue.Get() < arrpPE[x]->etnValue.Get())
                {
                    pPE = arrpPE[x];
                    arrpPE[x] = arrpPE[y];
                    arrpPE[y] = pPE;
                }
            }
        }
    }
}


void PicsCategory::SetParents(PicsRatingSystem *pOwner)
{
    pPRS = pOwner;
    UINT cSubCategories = arrpPC.Length();
    for (UINT i = 0; i < cSubCategories; i++)
    {
        InitializeMyDefaults(arrpPC[i]);    /* subcategory inherits our defaults */
        arrpPC[i]->SetParents(pOwner);      /* process all subcategories */
    }
    FixupLimits();      /* inheritance is done, make sure limits make sense */
}


/***************************************************************************
    Handler functions which know how to parse the various kinds of content
    which can occur within a parenthesized object.
***************************************************************************/

HRESULT RatParseString(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    *ppOut = NULL;

    LPSTR pszCurrent = *ppszIn;

    if (*pszCurrent != '\"')
    {
        TraceMsg( TF_WARNING, "RatParseString() - Start string expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    pszCurrent++;

    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszEnd == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseString() - End string expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    UINT cbString = (unsigned int) (pszEnd-pszCurrent);
    LPSTR pszNew = new char[cbString + 1];
    if (pszNew == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseString() - pszNew is NULL!" );
        return E_OUTOFMEMORY;
    }

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString] = '\0';

    *ppOut = (LPVOID)pszNew;
    *ppszIn = pParser->FindNonWhite(pszEnd + 1);

    return NOERROR;
}


HRESULT RatParseNumber(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    int n;

    LPSTR pszCurrent = *ppszIn;
    HRESULT hres = ::ParseNumber(&pszCurrent, &n);

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseNumber() - Number Expected!" );
        return RAT_E_EXPECTEDNUMBER;
    }

    *(int *)ppOut = n;

    LPSTR pszNewline = strchrf(*ppszIn, '\n');
    while (pszNewline != NULL && pszNewline < pszCurrent)
    {
        pParser->m_nLine++;
        pszNewline = strchrf(pszNewline+1, '\n');
    }
    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseBool(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    BOOL b;

    /* PICS spec allows a terse way of specifying a TRUE boolean -- leaving
     * out the value entirely.  In a .RAT file, the result looks like
     *
     * (unordered)
     * (multivalue)
     *
     * and so on.  Called has pointed us at non-whitespace, so if we see
     * a closing paren, we know the .RAT file author used this syntax.
     */
    if (**ppszIn == ')')
    {
        b = TRUE;
    }
    else
    {
        LPSTR pszCurrent = *ppszIn;
        HRESULT hres = ::GetBool(&pszCurrent, &b);

        if (FAILED(hres))
        {
            TraceMsg( TF_WARNING, "RatParseBool() - Boolean Expected!" );
            return RAT_E_EXPECTEDBOOL;
        }

        LPSTR pszNewline = strchrf(*ppszIn, '\n');
        while (pszNewline != NULL && pszNewline < pszCurrent)
        {
            pParser->m_nLine++;
            pszNewline = strchrf(pszNewline+1, '\n');
        }
        *ppszIn = pszCurrent;
    }

    *(LPBOOL)ppOut = b;

    return NOERROR;
}


AllowableOption aaoPicsCategory[] = {
    { ROID_TRANSMITAS, AO_SINGLE | AO_MANDATORY },
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_ICON, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_LABEL, 0 },
    { ROID_CATEGORY, 0 },
    { ROID_INVALID, 0 }
};
const UINT caoPicsCategory = sizeof(aaoPicsCategory) / sizeof(aaoPicsCategory[0]);

HRESULT RatParseCategory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsCategory];

    ::memcpyf(aao, ::aaoPicsCategory, sizeof(aao));

    PicsCategory *pCategory = new PicsCategory;
    if (pCategory == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - pCategory is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pCategory);             /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pCategory;
        pCategory = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pCategory;
    return NOERROR;
}


AllowableOption aaoPicsEnum[] = {
    { ROID_NAME, AO_SINGLE },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_VALUE, AO_SINGLE | AO_MANDATORY },
    { ROID_ICON, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsEnum = sizeof(aaoPicsEnum) / sizeof(aaoPicsEnum[0]);

HRESULT RatParseLabel(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsEnum];

    ::memcpyf(aao, ::aaoPicsEnum, sizeof(aao));

    PicsEnum *pEnum = new PicsEnum;
    if (pEnum == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseCategory() - pEnum is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pEnum);                 /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseLabel() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pEnum;
        pEnum = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pEnum;
    return NOERROR;
}


AllowableOption aaoPicsDefault[] = {
    { ROID_EXTENSION, 0 },
    { ROID_INTEGER, AO_SINGLE },
    { ROID_LABELONLY, AO_SINGLE },
    { ROID_MAX, AO_SINGLE },
    { ROID_MIN, AO_SINGLE },
    { ROID_MULTIVALUE, AO_SINGLE },
    { ROID_UNORDERED, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsDefault = sizeof(aaoPicsDefault) / sizeof(aaoPicsDefault[0]);

HRESULT RatParseDefault(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsDefault];

    ::memcpyf(aao, ::aaoPicsDefault, sizeof(aao));

    PicsDefault *pDefault = new PicsDefault;
    if (pDefault == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseDefault() - pDefault is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pDefault);              /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseDefault() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pDefault;
        pDefault = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pDefault;
    return NOERROR;
}


AllowableOption aaoPicsExtension[] = {
    { ROID_MANDATORY, AO_SINGLE },
    { ROID_OPTIONAL, AO_SINGLE },
    { ROID_INVALID, 0 }
};
const UINT caoPicsExtension = sizeof(aaoPicsExtension) / sizeof(aaoPicsExtension[0]);

HRESULT RatParseExtension(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    /* We must make a copy of the allowable options array because the
     * parser will fiddle with the flags in the entries -- specifically,
     * setting AO_SEEN.  It wouldn't be thread-safe to do this to a
     * static array.
     */
    AllowableOption aao[caoPicsExtension];

    ::memcpyf(aao, ::aaoPicsExtension, sizeof(aao));

    PicsExtension *pExtension = new PicsExtension;
    if (pExtension == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseExtension() - pExtension is NULL!" );
        return E_OUTOFMEMORY;
    }

    HRESULT hres = pParser->ParseParenthesizedObject(
                        ppszIn,                 /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        pExtension);            /* object to add items back to */

    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseExtension() - ParseParenthesizedObject() Failed with hres=0x%x!", hres );
        delete pExtension;
        pExtension = NULL;
        return hres;
    }

    *ppOut = (LPVOID)pExtension;
    return NOERROR;
}


/* Since the only extension we support right now is the one for a label
 * bureau, we just return the first quoted string we find if the caller
 * wants it.  If ppOut is NULL, then it's some other extension and the
 * caller doesn't care about the data, he just wants it eaten.
 */
HRESULT ParseRatExtensionData(LPSTR *ppszIn, RatFileParser *pParser, LPSTR *ppOut)
{
    HRESULT hres = NOERROR;

    LPSTR pszCurrent = *ppszIn;

    /* Must look for closing ')' ourselves to terminate */
    while (*pszCurrent != ')')
    {
        if (*pszCurrent == '(')
        {
            pszCurrent = pParser->FindNonWhite(pszCurrent+1);       /* skip paren and whitespace */
            hres = ParseRatExtensionData(&pszCurrent, pParser, ppOut);  /* parentheses contain data */
            if (FAILED(hres))
            {
                TraceMsg( TF_WARNING, "ParseRatExtensionData() - ParseRatExtensionData() Failed with hres=0x%x!", hres );
                return hres;
            }

            if (*pszCurrent != ')')
            {
                TraceMsg( TF_WARNING, "ParseRatExtensionData() - Right Parenthesis Expected!" );
                return RAT_E_EXPECTEDRIGHT;
            }

            pszCurrent = pParser->FindNonWhite(pszCurrent+1);   /* skip close ) and whitespace */
        }
        else if (*pszCurrent == '\"')
        {             /* should be just a quoted string */
            if (ppOut != NULL && *ppOut == NULL)
            {
                hres = RatParseString(&pszCurrent, (LPVOID *)ppOut, pParser);

                // $REVIEW - Should we return for FAILED(hres)?
            }
            else
            {
                ++pszCurrent;
                LPSTR pszEndQuote = pParser->EatQuotedString(pszCurrent);
                if (pszEndQuote == NULL)
                {
                    TraceMsg( TF_WARNING, "ParseRatExtensionData() - String Expected!" );
                    return RAT_E_EXPECTEDSTRING;
                }
                pszCurrent = pParser->FindNonWhite(pszEndQuote+1);  /* skip close " and whitespace */
            }
        }
        else
        {
            TraceMsg( TF_WARNING, "ParseRatExtensionData() - General Bad Syntax!" );
            return RAT_E_UNKNOWNITEM;               /* general bad syntax */
        }
    }

    /* Caller will skip over final ')' for us. */

    *ppszIn = pszCurrent;

    return NOERROR;
}


HRESULT RatParseMandatory(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    LPSTR pszCurrent = *ppszIn;

    /* First thing better be a quoted URL identifying the extension. */
    if (*pszCurrent != '\"')
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - Start String Expected!" );
        return RAT_E_EXPECTEDSTRING;
    }

    pszCurrent++;
    LPSTR pszEnd = pParser->EatQuotedString(pszCurrent);
    if (pszCurrent == NULL)
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - End String Expected!" );
        return RAT_E_EXPECTEDSTRING;            /* missing closing " */
    }

    /* See if it's the extension for a label bureau. */

    LPSTR pszBureau = NULL;
    LPSTR *ppData = NULL;
    if (IsEqualToken(pszCurrent, pszEnd, ::szRatingBureauExtension))
    {
        ppData = &pszBureau;
    }

    pszCurrent = pParser->FindNonWhite(pszEnd+1);       /* skip closing " and whitespace */

    HRESULT hres = ParseRatExtensionData(&pszCurrent, pParser, ppData);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "RatParseMandatory() - ParseRatExtensionData() Failed with hres=0x%x!", hres );
        return hres;
    }

    *ppOut = pszBureau;     /* return label bureau string if that's what we found */
    *ppszIn = pszCurrent;

    if (ppData == NULL)
        return RAT_E_UNKNOWNMANDATORY;      /* we didn't recognize it */
    else
        return NOERROR;
}


/* RatParseOptional uses the code in RatParseMandatory to parse the extension
 * data, in case an extension that should be optional comes in as mandatory.
 * We then detect RatParseMandatory rejecting the thing as unrecognized and
 * allow it through, since here it's optional.
 */
HRESULT RatParseOptional(LPSTR *ppszIn, LPVOID *ppOut, RatFileParser *pParser)
{
    HRESULT hres = RatParseMandatory(ppszIn, ppOut, pParser);
    if (hres == RAT_E_UNKNOWNMANDATORY)
        hres = S_OK;

    return hres;
}


/***************************************************************************
    Code to identify the opening keyword of a parenthesized object and
    associate it with content.
***************************************************************************/

/* The following array is indexed by RatObjectID values. */
struct {
    LPCSTR pszToken;            /* token by which we identify it */
    RatObjectHandler pHandler;  /* function which parses the object's contents */
} aObjectDescriptions[] = {
    { szNULL, NULL },
    { NULL, NULL },             /* placeholder for comparing against no token */
    { szPicsVersion, RatParseNumber },
    { szRatingSystem, RatParseString },
    { szRatingService, RatParseString },
    { szRatingBureau, RatParseString },
    { szBureauRequired, RatParseBool },
    { szCategory, RatParseCategory },
    { szTransmitAs, RatParseString },
    { szLabel, RatParseLabel },
    { szValue, RatParseNumber },
    { szDefault, RatParseDefault },
    { szDescription, RatParseString },
    { szExtensionOption, RatParseExtension },
    { szMandatory, RatParseMandatory },
    { szOptional, RatParseOptional },
    { szIcon, RatParseString },
    { szInteger, RatParseBool },
    { szLabelOnly, RatParseBool },
    { szMax, RatParseNumber },
    { szMin, RatParseNumber },
    { szMultiValue, RatParseBool },
    { szName, RatParseString },
    { szUnordered, RatParseBool }
};


/* ParseToOpening eats the opening '(' of a parenthesized object, and
 * verifies that the token just inside it is one of the expected ones.
 * If so, *ppIn is advanced past that token to the next non-whitespace
 * character;  otherwise, an error is returned.
 *
 * For example, if *ppIn is pointing at "(PICS-version 1.1)", and
 * ROID_PICSVERSION is in the allowable option table supplied, then
 * NOERROR is returned and *ppIn will point at "1.1)".
 *
 * If the function is successful, *ppFound is set to point to the element
 * in the allowable-options table which matches the type of thing this
 * object actually is.
 */
HRESULT RatFileParser::ParseToOpening(LPSTR *ppIn, AllowableOption *paoExpected,
                                      AllowableOption **ppFound)
{
    LPSTR pszCurrent = *ppIn;

    pszCurrent = FindNonWhite(pszCurrent);
    if (*pszCurrent != '(')
    {
        TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Left Parenthesis Expected!" );
        return RAT_E_EXPECTEDLEFT;
    }

    pszCurrent = FindNonWhite(pszCurrent+1);    /* skip '(' and whitespace */
    LPSTR pszTokenEnd = FindTokenEnd(pszCurrent);

    for (; paoExpected->roid != ROID_INVALID; paoExpected++)
    {
        LPCSTR pszThisToken = aObjectDescriptions[paoExpected->roid].pszToken;

        /* Special case for beginning of RAT file structure: no token at all. */
        if (pszThisToken == NULL)
        {
            if (*pszCurrent == '(')
            {
                *ppIn = pszCurrent;
                *ppFound = paoExpected;
                return NOERROR;
            }
            else
            {
                TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Token Left Parenthesis Expected!" );
                return RAT_E_EXPECTEDLEFT;
            }
        }
        else if (IsEqualToken(pszCurrent, pszTokenEnd, pszThisToken))
            break;

    }

    if (paoExpected->roid != ROID_INVALID)
    {
        *ppIn = FindNonWhite(pszTokenEnd);  /* skip token and whitespace */
        *ppFound = paoExpected;
        return NOERROR;
    }
    else
    {
        TraceMsg( TF_WARNING, "RatFileParser::ParseToOpening() - Unknown Rat Object!" );
        return RAT_E_UNKNOWNITEM;
    }
}


/***************************************************************************
    The top-level entrypoint for parsing out a whole rating system.
***************************************************************************/

AllowableOption aaoPicsRatingSystem[] = {
    { ROID_PICSVERSION, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSYSTEM, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGSERVICE, AO_SINGLE | AO_MANDATORY },
    { ROID_RATINGBUREAU, AO_SINGLE },
    { ROID_BUREAUREQUIRED, AO_SINGLE },
    { ROID_DEFAULT, 0 },
    { ROID_DESCRIPTION, AO_SINGLE },
    { ROID_EXTENSION, 0 },
    { ROID_ICON, AO_SINGLE },
    { ROID_NAME, AO_SINGLE },
    { ROID_CATEGORY, AO_MANDATORY },
    { ROID_INVALID, 0 }
};
const UINT caoPicsRatingSystem = sizeof(aaoPicsRatingSystem) / sizeof(aaoPicsRatingSystem[0]);

HRESULT PicsRatingSystem::Parse(LPCSTR pszFilename, LPSTR pIn)
{
    /* This guy is small enough to just init directly on the stack */
    AllowableOption aaoRoot[] = { { ROID_PICSDOCUMENT, 0 }, { ROID_INVALID, 0 } };
    AllowableOption aao[caoPicsRatingSystem];

    ::memcpyf(aao, ::aaoPicsRatingSystem, sizeof(aao));

    AllowableOption *pFound;

    RatFileParser parser;

    HRESULT hres = parser.ParseToOpening(&pIn, aaoRoot, &pFound);
    if (FAILED(hres))
    {
        TraceMsg( TF_WARNING, "PicsRatingSystem::Parse() - Failed ParseToOpening() with hres=0x%x!", hres );
        return hres;                        /* some error early on */
    }

    hres = parser.ParseParenthesizedObject(
                        &pIn,                   /* var containing current ptr */
                        aao,                    /* what's legal in this object */
                        this);                  /* object to add items back to */

    if(SUCCEEDED(hres))
    {
        if(*pIn!=')') //check for a closing parenthesis
        {
            hres=RAT_E_EXPECTEDRIGHT;
        }
        else
        {
            LPTSTR lpszEnd=NonWhite(pIn+1);

            if(*lpszEnd!='\0') // make sure we're at the end of the file
            {
                hres=RAT_E_EXPECTEDEND;
            }
        }
    }

    if(FAILED(hres))
    {
        nErrLine=parser.m_nLine;
        TraceMsg( TF_WARNING, "PicsRatingSystem::Parse() - Failed ParseParenthesizedObject() at nErrLine=%d with hres=0x%x!", nErrLine, hres );
    }

    return hres;
}


/***************************************************************************
    Callbacks into the various class objects to add parsed properties.
***************************************************************************/

HRESULT PicsRatingSystem::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_PICSVERSION:
        etnPicsVersion.Set(PtrToLong(pData));
        break;

    case ROID_RATINGSYSTEM:
        etstrRatingSystem.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGSERVICE:
        etstrRatingService.SetTo((LPSTR)pData);
        break;

    case ROID_RATINGBUREAU:
        etstrRatingBureau.SetTo((LPSTR)pData);
        break;

    case ROID_BUREAUREQUIRED:
        etbBureauRequired.Set((bool)pData);
        break;

    case ROID_DEFAULT:
        m_pDefaultOptions = (PicsDefault *)pData;
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {
            /* just eat extensions for now */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                /* If this is a rating bureau extension, take his bureau
                 * string and store it in this PicsRatingSystem.  We now
                 * own the memory, so NULL out the extension's pointer to
                 * it so he won't delete it.
                 */
                if (pExtension->m_pszRatingBureau != NULL)
                {
                    etstrRatingBureau.SetTo(pExtension->m_pszRatingBureau);
                    pExtension->m_pszRatingBureau = NULL;
                }
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;
            hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
            {
                delete pCategory;
                pCategory = NULL;
            }
            else
            {
                InitializeMyDefaults(pCategory);    /* category inherits default settings */
                pCategory->SetParents(this);    /* set pPRS fields in whole tree */
            }
        }
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsCategory::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_TRANSMITAS:
        etstrTransmitAs.SetTo((LPSTR)pData);
        break;

    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((bool) pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((bool) pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((bool)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((bool)pData);
        break;

    case ROID_MIN:
        etnMin.Set(PtrToLong(pData));
        break;

    case ROID_MAX:
        etnMax.Set(PtrToLong(pData));
        break;

    case ROID_LABEL:
        {
            PicsEnum *pEnum = (PicsEnum *)pData;
            hres = arrpPE.Append(pEnum) ? S_OK : E_OUTOFMEMORY;
            if (FAILED(hres))
            {
                delete pEnum;
                pEnum = NULL;
            }
        }
        break;

    case ROID_CATEGORY:
        {
            PicsCategory *pCategory = (PicsCategory *)pData;

            /* For a nested category, synthesize the transmit-name from
             * ours and the child's (e.g., parent category 'color' plus
             * child category 'hue' becomes 'color/hue'.
             *
             * Note that the memory we allocate for the new name will be
             * owned by pCategory->etstrTransmitAs.  There is no memory
             * leak there.
             */
            UINT cbCombined = strlenf(etstrTransmitAs.Get()) +
                              strlenf(pCategory->etstrTransmitAs.Get()) +
                              2;        /* for PicsDelimChar + null */
            LPSTR pszTemp = new char[cbCombined];
            if (pszTemp == NULL)
                hres = E_OUTOFMEMORY;
            else {
                wsprintf(pszTemp, "%s%c%s", etstrTransmitAs.Get(),
                         PicsDelimChar, pCategory->etstrTransmitAs.Get());
                pCategory->etstrTransmitAs.SetTo(pszTemp);
                hres = arrpPC.Append(pCategory) ? S_OK : E_OUTOFMEMORY;
            }

            if (FAILED(hres))
            {
                delete pCategory;
                pCategory = NULL;
            }
        }
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsEnum::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_NAME:
        etstrName.SetTo((LPSTR)pData);
        break;

    case ROID_DESCRIPTION:
        etstrDesc.SetTo((LPSTR)pData);
        break;

    case ROID_ICON:
        etstrIcon.SetTo((LPSTR)pData);
        break;

    case ROID_VALUE:
        etnValue.Set(PtrToLong(pData));
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsDefault::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
    case ROID_EXTENSION:
        {           /* we support no extensions below the rating system level */
            PicsExtension *pExtension = (PicsExtension *)pData;
            if (pExtension != NULL)
            {
                delete pExtension;
                pExtension = NULL;
            }
        }
        break;

    case ROID_INTEGER:
        etfInteger.Set((bool)pData);
        break;

    case ROID_LABELONLY:
        etfLabelled.Set((bool)pData);
        break;

    case ROID_MULTIVALUE:
        etfMulti.Set((bool)pData);
        break;

    case ROID_UNORDERED:
        etfUnordered.Set((bool)pData);
        break;

    case ROID_MIN:
        etnMin.Set(PtrToLong(pData));
        break;

    case ROID_MAX:
        etnMax.Set(PtrToLong(pData));
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


HRESULT PicsExtension::AddItem(RatObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid) {
    case ROID_OPTIONAL:
    case ROID_MANDATORY:
        /* Only data we should get is a label bureau string. */
        if (pData != NULL)
            m_pszRatingBureau = (LPSTR)pData;
        break;

    default:
        ASSERT(FALSE);  /* shouldn't have been given a ROID that wasn't in
                         * the table we passed to the parser! */
        hres = E_UNEXPECTED;
        break;
    }

    return hres;
}


/***************************************************************************
    The main loop of the parser.
***************************************************************************/

/* ParseParenthesizedObjectContents is called with a text pointer pointing at
 * the first non-whitespace thing following the token identifying the type of
 * object.  It parses the rest of the contents of the object, up to and
 * including the ')' which closes it.  The array of AllowableOption structures
 * specifies which understood options are allowed to occur within this object.
 */
HRESULT RatFileParser::ParseParenthesizedObject(
    LPSTR *ppIn,                    /* where we are in the text stream */
    AllowableOption aao[],          /* allowable things inside this object */
    PicsObjectBase *pObject         /* object to set parameters into */
)
{
    HRESULT hres = S_OK;

    LPSTR pszCurrent = *ppIn;
    AllowableOption *pFound;

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++)
    {
        pFound->fdwOptions &= ~AO_SEEN;
    }

    pFound = NULL;

    while (*pszCurrent != ')' && *pszCurrent != '\0' && SUCCEEDED(hres))
    {
        hres = ParseToOpening(&pszCurrent, aao, &pFound);
        if (SUCCEEDED(hres))
        {
            LPVOID pData;
            hres = (*(aObjectDescriptions[pFound->roid].pHandler))(&pszCurrent, &pData, this);
            if (SUCCEEDED(hres))
            {
                if ((pFound->fdwOptions & (AO_SINGLE | AO_SEEN)) == (AO_SINGLE | AO_SEEN))
                {
                    hres = RAT_E_DUPLICATEITEM;
                }
                else
                {
                    pFound->fdwOptions |= AO_SEEN;
                    hres = pObject->AddItem(pFound->roid, pData);
                    if (SUCCEEDED(hres))
                    {
                        if (*pszCurrent != ')')
                            hres = RAT_E_EXPECTEDRIGHT;
                        else
                            pszCurrent = FindNonWhite(pszCurrent+1);
                    }
                }
            }
        }
    }

    if (FAILED(hres))
    {
        return hres;
    }

    for (pFound = aao; pFound->roid != ROID_INVALID; pFound++)
    {
        if ((pFound->fdwOptions & (AO_MANDATORY | AO_SEEN)) == AO_MANDATORY)
        {
            return RAT_E_MISSINGITEM;       /* mandatory item not found */
        }
    }

    *ppIn = pszCurrent;

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\picsdlg.cpp ===
/****************************************************************************\
 *
 *   picsdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Pics Ratings Property Page
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "picsdlg.h"        // CPicsDialog
#include "debug.h"          // TraceMsg()
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()

/*Helpers---------------------------------------------------------------------*/
int     g_nKeys, g_nLock; //         indexes of the images 

DWORD CPicsDialog::aIds[] = {
    IDC_STATIC1,        IDH_RATINGS_CATEGORY_LABEL,
    IDC_PT_TREE,        IDH_RATINGS_CATEGORY_LIST,
    IDC_RATING_LABEL,   IDH_RATINGS_RATING_LABEL,
    IDC_PT_TB_SELECT,   IDH_RATINGS_RATING_LABEL,
    IDC_PT_T_RSN_SDESC, IDH_RATINGS_RATING_TEXT,
    IDC_STATIC2,        IDH_RATINGS_DESCRIPTION_LABEL,
    IDC_PT_T_RSN_LDESC, IDH_RATINGS_DESCRIPTION_TEXT,
    IDC_STATIC3,        IDH_RATINGS_VIEW_PROVIDER_PAGE,
    IDC_DETAILSBUTTON,  IDH_RATINGS_VIEW_PROVIDER_PAGE,
    0,0
};

CPicsDialog::CPicsDialog( PRSD * p_pPRSD )
{
    ASSERT( p_pPRSD );
    m_pPRSD = p_pPRSD;
}

LRESULT CPicsDialog::OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    TV_ITEM  tvm;
    TreeNode *pTN;

    InitTreeViewImageLists(GetDlgItem(IDC_PT_TREE));

    //force the trackbar to redraw its background with the new color
    PRSD *          pPRSD = m_pPRSD;

    ZeroMemory(&tvm,sizeof(tvm));

    tvm.hItem=TreeView_GetSelection(GetDlgItem(IDC_PT_TREE));
    tvm.mask=TVIF_PARAM;

    TreeView_GetItem(GetDlgItem(IDC_PT_TREE),&tvm);

    pTN=(TreeNode *) tvm.lParam;

    ASSERT( pTN );

    if ( ! pTN )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnSysColorChange() - pTN is NULL!" );
        return 0L;
    }

    ControlsShow( pTN->tne );
    
    switch(pTN->tne)
    {
        case tneRatingSystemInfo:
        {
            SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            break;
        }
        case tneRatingSystemNode:
        {
            SelectRatingSystemNode( (PicsCategory*) pTN->pData );
            break;
        }
    }

    return 0L;
}

LRESULT CPicsDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    PicsDlgInit();

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CPicsDialog::OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    switch (LOWORD(wParam)){
        case TB_THUMBTRACK:
        case TB_BOTTOM:
        case TB_ENDTRACK:
        case TB_LINEDOWN:
        case TB_LINEUP:
        case TB_PAGEDOWN:
        case TB_PAGEUP:
        case TB_THUMBPOSITION:
        case TB_TOP:
            NewTrackbarPosition();
            MarkChanged();
            break;
    }

    return 0L;
}

LRESULT CPicsDialog::OnDetails(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    LaunchRatingSystemSite();
    return 0L;
}

LRESULT CPicsDialog::OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnSetActive() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->fNewProviders)
    {
        //Means that user changed list of provider files
        HWND  hwndTree;
        hwndTree = GetDlgItem(IDC_PT_TREE);
        KillTree(hwndTree , TreeView_GetRoot(hwndTree));
        pPRSD->fNewProviders = FALSE;
        PicsDlgInit();
    }

    bHandled = FALSE;
    return 0L;
}

LRESULT CPicsDialog::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPPSHNOTIFY lpPSHNotify = (LPPSHNOTIFY) pnmh;

    /*do apply stuff*/

    PicsDlgSave();

    if ( ! lpPSHNotify->lParam )
    {
        // Apply 
        return PSNRET_NOERROR;
    }

    // Do this if hit OK or Cancel, not Apply
    OnReset( idCtrl, pnmh, bHandled );

    return PSNRET_NOERROR;
}

LRESULT CPicsDialog::OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    // Do this if hit OK or Cancel, not Apply
    HWND hDlg = m_hWnd;
    ASSERT( hDlg );

    SendMessage(hDlg,WM_SETREDRAW, FALSE,0L);
    PicsDlgUninit();
    SendMessage(hDlg,WM_SETREDRAW, TRUE,0L);

    return 0L;
}

LRESULT CPicsDialog::OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pNMTreeView = (LPNMTREEVIEW)pnmh;

    if ( ! pNMTreeView )
    {
        return 0L;
    }

    if (pNMTreeView->action == TVE_COLLAPSE)
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, TRUE);
        return 1L; //Suppress expanding tree.
    }

    return 0L;
}

LRESULT CPicsDialog::OnTreeSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    LPNMTREEVIEW pNMTreeView = (LPNMTREEVIEW)pnmh;
    TreeNode    *pTN = pNMTreeView ? ((TreeNode*) pNMTreeView->itemNew.lParam) : NULL;

    if ( ! pTN )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnTreeSelChanged() - pTN is NULL!" );
        return 0L;
    }

    PRSD *      pPRSD = m_pPRSD;

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::OnTreeSelChanged() - pPRSD is NULL!" );
        return 0L;
    }

    if (pPRSD->fNewProviders)
    {
        return 1L;    /* tree is being cleaned up, ignore sel changes */
    }

    ControlsShow( pTN->tne );

    switch(pTN->tne)
    {
        case tneRatingSystemInfo:
            SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            break;
        case tneRatingSystemNode:
            SelectRatingSystemNode( (PicsCategory*) pTN->pData );
            break;
    }

    return 1L;
}

LRESULT CPicsDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPicsDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

// InitTreeViewImageLists - creates an image list, adds three bitmaps to 
// it, and associates the image list with a tree-view control. 
// Returns TRUE if successful or FALSE otherwise. 
// hwndTV - handle of the tree-view control 
//
#define NUM_BITMAPS  2
#define CX_BITMAP   16
#define CY_BITMAP   16

void CPicsDialog::SetTreeImages( HWND hwndTV, HIMAGELIST himl )
{
    HIMAGELIST oldHiml;  // handle of image list

    // Associate the image list with the tree-view control.
    oldHiml = TreeView_SetImageList( hwndTV, himl, TVSIL_NORMAL );

    if ( oldHiml != NULL )
    {
        ImageList_Destroy( oldHiml );
    }
}

BOOL CPicsDialog::InitTreeViewImageLists(HWND hwndTV) 
{ 
    HIMAGELIST himl;  // handle of image list 
    HBITMAP hbmp;     // handle of bitmap 

    // Create the image list. 
    if ((himl = ImageList_Create(CX_BITMAP, CY_BITMAP, 
            FALSE, NUM_BITMAPS, 0)) == NULL)
    {
        TraceMsg( TF_WARNING, "CPicsDialog::InitTreeViewImageLists() - himl Image List Creation Failed!" );
        return FALSE;
    }

    // Add the open file, closed file, and document bitmaps. 
    hbmp=(HBITMAP) LoadImage(g_hInstance,
                             MAKEINTRESOURCE(IDB_KEYS),
                             IMAGE_BITMAP,
                             0,
                             0,
                             LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_nKeys = ImageList_Add(himl, hbmp, (HBITMAP) NULL); 
    DeleteObject(hbmp); 

    hbmp=(HBITMAP) LoadImage(g_hInstance,
                             MAKEINTRESOURCE(IDB_LOCK),
                             IMAGE_BITMAP,
                             0,
                             0,
                             LR_LOADTRANSPARENT|LR_DEFAULTCOLOR|LR_CREATEDIBSECTION);
    g_nLock = ImageList_Add(himl, hbmp, (HBITMAP) NULL);
    DeleteObject(hbmp);

    // Fail if not all of the images were added. 
    if (ImageList_GetImageCount(himl) < NUM_BITMAPS)
    {
        TraceMsg( TF_WARNING, "CPicsDialog::InitTreeViewImageLists() - Not all images were added!" );
        return FALSE;
    }

    // Associate the image list with the tree-view control. 
    SetTreeImages( hwndTV, himl );

    return TRUE; 
} 

void CPicsDialog::LaunchRatingSystemSite( void )
{
    HWND        hDlg = m_hWnd;

    TreeNode *pTN = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
    if (pTN == NULL)
        return;

    PicsRatingSystem *pPRS = NULL;

    if (pTN->tne == tneRatingSystemInfo)
        pPRS = (PicsRatingSystem *)pTN->pData;
    else if (pTN->tne == tneRatingSystemNode) {
        if ((PicsCategory *)pTN->pData != NULL)
            pPRS = ((PicsCategory *)pTN->pData)->pPRS;
    }

    if (pPRS != NULL) {
        BOOL fSuccess = FALSE;
        HINSTANCE hShell32 = ::LoadLibrary(::szShell32);
        if (hShell32 != NULL) {
            PFNSHELLEXECUTE pfnShellExecute = (PFNSHELLEXECUTE)::GetProcAddress(hShell32, ::szShellExecute);
            if (pfnShellExecute != NULL) {
                fSuccess = (*pfnShellExecute)(hDlg, NULL, pPRS->etstrRatingService.Get(),
                                              NULL, NULL, SW_SHOW) != NULL;
            }
            ::FreeLibrary(hShell32);
        }
        if (!fSuccess) {
            NLS_STR nlsMessage(MAX_RES_STR_LEN);
            if(nlsMessage)
            {
                NLS_STR nlsTemp(STR_OWNERALLOC, pPRS->etstrRatingSystem.Get());
                const NLS_STR *apnls[] = { &nlsTemp, NULL };
                if ( WN_SUCCESS == (nlsMessage.LoadString(IDS_CANT_LAUNCH, apnls)) )
                {
                    MyMessageBox(hDlg, nlsMessage.QueryPch(), IDS_GENERIC, MB_OK | MB_ICONSTOP);
                }
            }
        }
    }
}

void CPicsDialog::PicsDlgInit( void )
{
    HTREEITEM  hTree;
    TreeNode  *pTN;
    HWND       hwndTree;
    int        x,z;

    HWND hDlg = m_hWnd;

    ASSERT( hDlg );

    if ( ! hDlg )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgInit() - hDlg is NULL!" );
        return;
    }

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgInit() - pPRSD is NULL!" );
        return;
    }

    hwndTree = GetDlgItem(IDC_PT_TREE);

    /* Note, if there are installed providers but they all failed, there
     * will be dummy entries for them in the array.  So we will not attempt
     * to install RSACi automatically unless there really are no providers
     * installed at all.
     */
    if (!pPRSD->pPRSI->arrpPRS.Length())
    {
        // There are no providers.
        if ( ! InstallDefaultProvider() )
        {
            MyMessageBox(hDlg, IDS_INSTALL_INFO, IDS_GENERIC, MB_OK);
            ControlsShow( tneNone );
            return;
        }
    }
    /*make the tree listing*/
    /*Individual Rating Systems*/
    InitTreeViewImageLists(hwndTree);

    BOOL fAnyInvalid = FALSE;
    BOOL fAnyValid = FALSE;
    for (z = 0; z < pPRSD->pPRSI->arrpPRS.Length(); ++z)
    {
        PicsRatingSystem *pPRS = pPRSD->pPRSI->arrpPRS[z];

        if (!(pPRS->dwFlags & PRS_ISVALID))
        {
            fAnyInvalid = TRUE;
            continue;
        }
        fAnyValid = TRUE;

        pTN  = new TreeNode(tneRatingSystemInfo, pPRS);
        ASSERT(pTN);    
        hTree = AddOneItem(hwndTree, NULL, (char*) pPRS->etstrName.Get(), TVI_SORT, (LPARAM) pTN, g_nLock);
        for (x = 0; x < pPRS->arrpPC.Length(); ++x)
        {
            AddCategory(pPRS->arrpPC[x], hwndTree, hTree);
        }
        TreeView_Expand(hwndTree, hTree, TVE_EXPAND);
    }

    if (fAnyInvalid)
    {
        MyMessageBox(hDlg, IDS_INVALID_PROVIDERS, IDS_GENERIC, MB_OK | MB_ICONWARNING);
    }

    if (fAnyValid)
    {
        HTREEITEM hTreeItem;

        hTreeItem=TreeView_GetNextItem(hwndTree, TreeView_GetRoot(hwndTree),TVGN_CHILD);

        if(hTreeItem!=NULL)
        {
            TreeView_SelectItem(hwndTree, hTreeItem);       
            pTN   = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
            if (pTN)
            {
                ControlsShow( pTN->tne );

                switch(pTN->tne)
                {
                    case tneRatingSystemInfo:
                        SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
                        break;
                    case tneRatingSystemNode:
                        SelectRatingSystemNode( (PicsCategory*) pTN->pData );
                        break;
                }
            }
        }
        else
        {
            TreeView_SelectItem(hwndTree, TreeView_GetRoot(hwndTree));

            pTN   = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));

            ControlsShow( tneRatingSystemInfo );

            if ( pTN )
            {
                SelectRatingSystemInfo( (PicsRatingSystem*) pTN->pData );
            }
        }
    }
    else
    {
        ControlsShow( tneNone );
    }
}


void CPicsDialog::KillTree(HWND hwndTree, HTREEITEM hTree)
{
    ASSERT( hwndTree );

    while (hTree != NULL)
    {
        /* If this node has any items under it, delete them as well. */
        HTREEITEM hChild = TreeView_GetChild( hwndTree, hTree );
        if (hChild != NULL)
        {
            KillTree( hwndTree, hChild );
        }

        HTREEITEM hNext = TreeView_GetNextSibling( hwndTree, hTree );

        TreeView_SelectItem( hwndTree, hTree );
        delete TreeView_GetSelectionLParam( hwndTree );
        TreeView_DeleteItem( hwndTree, hTree );
        hTree = hNext;
    }
}


void CPicsDialog::PicsDlgUninit( void )
{
    HWND hwndTree;

    hwndTree = GetDlgItem(IDC_PT_TREE);
    KillTree( hwndTree, TreeView_GetRoot(hwndTree) );

    // Remove the image list from the tree-view control. 
    SetTreeImages( hwndTree, NULL );

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    /* If we have a temporary copy of the user's ratings list, destroy it. */
    if ( pPRSD && pPRSD->pTempRatings != NULL )
    {
        DestroyRatingSystemList(pPRSD->pTempRatings);
        pPRSD->pTempRatings = NULL;
    }

    ControlsShow( tneNone );
}


void CPicsDialog::PicsDlgSave( void )
{
    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::PicsDlgSave() - pPRSD is NULL!" );
        return;
    }

    /* To save changes, throw away the user's ratings list and steal the
     * temporary copy we're using in the dialog.  As an optimization, we
     * don't copy it here, because in the case of OK, we'd just be destroying
     * the original immediately after this.  If the user hit Apply, we'll
     * re-clone a new temp ratings list for the dialog's purpose the next
     * time we need one.
     *
     * If there is no temporary copy, then PicsDlgSave is a nop.
     */
    if (pPRSD->pTempRatings != NULL)
    {
        DestroyRatingSystemList(pPRSD->pPU->m_pRatingSystems);
        pPRSD->pPU->m_pRatingSystems = pPRSD->pTempRatings;
        pPRSD->pTempRatings = NULL;
    }
}

#ifdef RATING_LOAD_GRAPHICS /* loading icon out of msrating.dll?  completely bogus. */
POINT CPicsDialog::BitmapWindowCoord( int nID )
{
    POINT pt;
    RECT  rD, rI;

    pt.x = ::GetWindowRect(GetDlgItem(nID), &rI);
    pt.y = GetWindowRect(&rD);
    pt.x = rI.left - rD.left;
    pt.y = rI.top  - rD.top;
    return pt;
}

void CPicsDialog::LoadGraphic( char *pIcon, POINT pt )
{
    HICON hIcon;
    int i;

    MyAtoi(pIcon, &i);

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::LoadGraphic() - pPRSD is NULL!" );
        return;
    }

    // No need to pull from msratelc.dll for non-localized icons.
    hIcon = pIcon ? LoadIcon( g_hInstance, MAKEINTRESOURCE(i) ) : NULL;
    if (hIcon)
    {
        HWND            hwndBitmapCategory;

        HWND hDlg = m_hWnd;

        ASSERT( hDlg );

        if ( ! hDlg )
        {
            TraceMsg( TF_ERROR, "CPicsDialog::LoadGraphic() - hDlg is NULL!" );
            return;
        }

        hwndBitmapCategory = CreateWindow("Static",NULL,SS_ICON|WS_CHILD, pt.x, pt.y,0,0,hDlg, NULL,NULL,0);
        ::ShowWindow( hwndBitmapCategory, SW_SHOW );
        DeleteObject( (HGDIOBJ) SendMessage( hwndBitmapCategory, STM_SETIMAGE, IMAGE_ICON, (LPARAM) hIcon) );

        pPRSD->hwndBitmapCategory = hwndBitmapCategory;
    }
}
#endif  /* RATING_LOAD_GRAPHICS */

PicsEnum* CPicsDialog::PosToEnum(PicsCategory *pPC, LPARAM lPos)
{
    int z, diff=-1, temp;
    PicsEnum *pPE=NULL;

    for (z=0;z<pPC->arrpPE.Length();++z){
        temp = (int) (lPos-pPC->arrpPE[z]->etnValue.Get());
        if (temp>=0){
            if (temp<diff || diff==-1){
                diff = temp;
                pPE  = pPC->arrpPE[z];
            }
        }
    }

    return pPE;
}

void CPicsDialog::NewTrackbarPosition( void )
{
    signed long   lPos;
    TreeNode     *pTN;
    PicsEnum     *pPE;
    PicsCategory *pPC;

    PRSD *          pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::NewTrackbarPosition() - pPRSD is NULL!" );
        return;
    }

    DeleteBitmapWindow( pPRSD->hwndBitmapLabel );

    pTN = TreeView_GetSelectionLParam(GetDlgItem(IDC_PT_TREE));
    if (pTN == NULL)
        return;

    pPC = (PicsCategory*) pTN->pData;
    BOOL fLabelled = pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get();

    lPos = (long) SendMessage(GetDlgItem(IDC_PT_TB_SELECT), TBM_GETPOS, 0, 0);
    pPE  = PosToEnum(pPC, fLabelled ? (LPARAM) pPC->arrpPE[lPos]->etnValue.Get() : lPos);
    if (pPE)
    {
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_SDESC), pPE->etstrName.Get());
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC), 
                      pPE->etstrDesc.fIsInit() ? pPE->etstrDesc.Get() : szNULL);

    }
    else
    {
        char pszBuf[MAXPATHLEN];
        char rgBuf[sizeof(pszBuf) + 12];    // big enough to insert a number

        MLLoadStringA(IDS_VALUE, pszBuf, sizeof(pszBuf));
        
        wsprintf(rgBuf, pszBuf, lPos);
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_SDESC), rgBuf);    
        ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC),
                      pPC->etstrDesc.fIsInit() ? pPC->etstrDesc.Get() : szNULL);
    }

    /* save the selected value into the temporary ratings list */
    UserRating *pRating = GetTempRating( pPC );
    if (pRating != NULL)
    {
        pRating->m_nValue = (int) (fLabelled ? pPC->arrpPE[lPos]->etnValue.Get() : lPos);
    }
}

void CPicsDialog::SelectRatingSystemNode( PicsCategory *pPC )
{
    HWND      hwnd;
    BOOL      fLabelOnly;
    LPARAM    lValue;
    int       z;

    ASSERT( pPC );

    if ( ! pPC )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::SelectRatingSystemNode() - pPC is NULL!" );
        return;
    }

#ifdef RATING_LOAD_GRAPHICS
    /*Category Icon*/
    if (pPC->etstrIcon.fIsInit())
    {
        // Load Graphic to m_pPRSD->hwndBitmapCategory
        LoadGraphic( pPC->etstrIcon.Get(), BitmapWindowCoord( IDC_PT_T_BITMAP_LABEL ) );
    }
#endif

    /*Setup Trackbar*/
    if ((pPC->etnMax.fIsInit() && P_INFINITY==pPC->etnMax.Get())
        ||
        (pPC->etnMin.fIsInit() && N_INFINITY==pPC->etnMin.Get())
        ||
        (!(pPC->etnMin.fIsInit() && pPC->etnMax.fIsInit()))
    )
    {
        ShowHideControl( IDC_PT_T_RSN_SDESC, FALSE );
        ShowHideControl( IDC_PT_T_RSN_LDESC, FALSE );
        ShowHideControl( IDC_PT_TB_SELECT,   FALSE );
    }
    else
    {
        hwnd = GetDlgItem(IDC_PT_TB_SELECT);
        SendMessage(hwnd, TBM_CLEARTICS, TRUE, 0);

        fLabelOnly = pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get();            
        /*Ranges*/
        if (pPC->etnMax.fIsInit())
        {
            lValue = (LPARAM) ( fLabelOnly ? pPC->arrpPE.Length()-1 : pPC->etnMax.Get() );
            SendMessage(hwnd, TBM_SETRANGEMAX, TRUE, lValue);
            ASSERT(lValue == SendMessage(hwnd, TBM_GETRANGEMAX, 0,0));
        }
        if (pPC->etnMin.fIsInit())
        {
            lValue = (LPARAM) ( fLabelOnly ? 0 : pPC->etnMin.Get() );
            SendMessage(hwnd, TBM_SETRANGEMIN, TRUE, lValue);
            ASSERT(lValue == SendMessage(hwnd, TBM_GETRANGEMIN, 0,0));
        }

        /*Ticks*/
        for (z=0;z<pPC->arrpPE.Length();++z)
        {
            lValue = (LPARAM) ( fLabelOnly ? z : pPC->arrpPE[z]->etnValue.Get());
            SendMessage(hwnd, TBM_SETTIC, 0, lValue);
        }

        /*Initial Position of trackbar*/
        UserRating *pRating = GetTempRating( pPC );

        if (pRating != NULL)
        {
            if (fLabelOnly)
            {
                for (z=0;z<pPC->arrpPE.Length();++z)
                {
                    if (pPC->arrpPE[z]->etnValue.Get() == pRating->m_nValue)
                    {
                        lValue=z;
                        break;
                    }
                }
            }
            else
            {
                lValue = (LPARAM) pRating->m_nValue;
            }
        }
        else
        {
            lValue = (LPARAM) ( fLabelOnly ? 0 : pPC->etnMin.Get());
        }

        SendMessage(hwnd, TBM_SETPOS, TRUE, lValue);

        // On dialog close, setting the trackbar position fails.
//      ASSERT(lValue == SendMessage(hwnd, TBM_GETPOS, 0,0));

        NewTrackbarPosition();
    }
}

void CPicsDialog::SelectRatingSystemInfo( PicsRatingSystem *pPRS )
{
    ASSERT( pPRS );

    if ( ! pPRS )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::SelectRatingSystemInfo() - pPRS is NULL!" );
        return;
    }

    ::SetWindowText(GetDlgItem(IDC_PT_T_RSN_LDESC), pPRS->etstrDesc.Get());

#ifdef RATING_LOAD_GRAPHICS
    if (pPRS->etstrIcon.fIsInit())
    {
        // Load Graphic to m_pPRSD->hwndBitmapCategory
        LoadGraphic( pPRS->etstrIcon.Get(), BitmapWindowCoord( IDC_PT_T_BITMAP_LABEL ) );
    }
#endif
}

void CPicsDialog::DeleteBitmapWindow( HWND & p_rhwnd )
{
    if (p_rhwnd)
    {
        DeleteObject( (HGDIOBJ) SendMessage(p_rhwnd, STM_GETIMAGE, IMAGE_BITMAP, 0));
        ::DestroyWindow(p_rhwnd);
        p_rhwnd = 0;
    }
}


void CPicsDialog::ControlsShow( TreeNodeEnum tne )
{
    BOOL fEnable;

    /*Bitmap placeholders never need to be seen*/
    ShowHideControl( IDC_PT_T_BITMAP_CATEGORY, FALSE );
    ShowHideControl( IDC_PT_T_BITMAP_LABEL,    FALSE );

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    /*Kill old graphic windows*/
    if ( pPRSD )
    {
        DeleteBitmapWindow( pPRSD->hwndBitmapCategory );
        DeleteBitmapWindow( pPRSD->hwndBitmapLabel );
    }

    /*RatingSystemNode Controls*/
    fEnable = (tne == tneRatingSystemNode);

    ShowHideControl( IDC_PT_T_RSN_SDESC, fEnable );
    ShowHideControl( IDC_PT_TB_SELECT,   fEnable );
    ShowHideControl( IDC_RATING_LABEL,   fEnable );

    /*RatingSystemInfo Controls*/
    fEnable = (tne==tneRatingSystemInfo || tne==tneRatingSystemNode);

    ShowHideControl( IDC_PT_T_RSN_LDESC, fEnable);
    ShowHideControl( IDC_DETAILSBUTTON,  fEnable);
}

TreeNode* CPicsDialog::TreeView_GetSelectionLParam(HWND hwndTree){
    TV_ITEM tv;

    tv.mask  = TVIF_HANDLE | TVIF_PARAM;
    tv.hItem = TreeView_GetSelection(hwndTree);
    if (SendMessage(hwndTree, TVM_GETITEM, 0, (LPARAM) &tv)) return (TreeNode*) tv.lParam;
    else return 0;
}

HTREEITEM CPicsDialog::AddOneItem(HWND hwndTree, HTREEITEM hParent, LPSTR szText, HTREEITEM hInsAfter, LPARAM lpData, int iImage){
    HTREEITEM hItem;
    TV_ITEM tvI;
    TV_INSERTSTRUCT tvIns;

    // The .pszText is filled in.
    tvI.mask = TVIF_TEXT | TVIF_PARAM | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    tvI.iSelectedImage = iImage;
    tvI.iImage = iImage;
    tvI.pszText = szText;
    tvI.cchTextMax = strlenf(szText);
    tvI.lParam = lpData;

    tvIns.item = tvI;
    tvIns.hInsertAfter = hInsAfter;
    tvIns.hParent = hParent;

    // Insert the item into the tree.
    hItem = (HTREEITEM)SendMessage(hwndTree, TVM_INSERTITEM, 0, (LPARAM)(LPTV_INSERTSTRUCT)&tvIns);

    return (hItem);
}

void CPicsDialog::AddCategory(PicsCategory *pPC, HWND hwndTree, HTREEITEM hParent){
    int        z;
    char      *pc;
    TreeNode  *pTN;

    /*if we have a real name, us it, else use transmission name*/
    if (pPC->etstrName.fIsInit())
    {
        pc = pPC->etstrName.Get();
    }
    else if (pPC->etstrDesc.fIsInit())
    {
        pc = pPC->etstrDesc.Get();
    }
    else
    {
        pc = (char*) pPC->etstrTransmitAs.Get();
    }

    /*Category Tab*/
    pTN  = new TreeNode(tneRatingSystemNode, pPC);
    ASSERT(pTN);    

    /*insert self*/
    hParent = AddOneItem(hwndTree, hParent, pc, TVI_SORT, (LPARAM) pTN, g_nKeys);

    /*insert children*/
    int cChildren = pPC->arrpPC.Length();

    if (cChildren > 0) {
        for (z = 0; z < cChildren; ++z)
            AddCategory(pPC->arrpPC[z], hwndTree, hParent);
        TreeView_Expand(hwndTree, hParent, TVE_EXPAND);
    }
}


BOOL CPicsDialog::InstallDefaultProvider( void )
{
    NLS_STR nlsFilename(MAXPATHLEN);
    BOOL fRet = FALSE;

    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::InstallDefaultProvider() - pPRSD is NULL!" );
        return fRet;
    }

    if (nlsFilename.QueryError() != ERROR_SUCCESS)
    {
        TraceMsg( TF_ERROR, "CPicsDialog::InstallDefaultProvider() - nlsFilename Allocation Failed!" );
        return fRet;
    }

    CHAR * pszFileName = nlsFilename.Party();

    if (pszFileName)
    {
        GetSystemDirectory(pszFileName, nlsFilename.QueryAllocSize());
        nlsFilename.DonePartying();
        LPSTR pszBackslash = ::strrchrf(nlsFilename.QueryPch(), '\\');
        if (pszBackslash == NULL || *(pszBackslash+1) != '\0')
            nlsFilename.strcat(szBACKSLASH);
        nlsFilename.strcat(szDEFAULTRATFILE);

        PicsRatingSystem *pPRS;
        HRESULT hres = LoadRatingSystem(nlsFilename.QueryPch(), &pPRS);
        if (pPRS != NULL)
        {
            pPRSD->pPRSI->arrpPRS.Append(pPRS);
            fRet = TRUE;
        }

        pPRSD->pPRSI->fRatingInstalled = fRet;

        CheckUserSettings(pPRS);    /* give user default settings for all categories */
    }
    else
    {
        nlsFilename.DonePartying();
    }

    return fRet;
}

/* GetTempRatingList returns the dialog's temporary copy of the user's rating
 * system list.  If we don't have any such temporary copy yet, we make one.
 */
UserRatingSystem * CPicsDialog::GetTempRatingList( void )
{
    PRSD * pPRSD = m_pPRSD;

    ASSERT( pPRSD );

    if ( ! pPRSD )
    {
        TraceMsg( TF_ERROR, "CPicsDialog::GetTempRatingList() - pPRSD is NULL!" );
        return NULL;
    }

    if (pPRSD->pTempRatings == NULL)
    {
        pPRSD->pTempRatings = DuplicateRatingSystemList(pPRSD->pPU->m_pRatingSystems);
    }

    return pPRSD->pTempRatings;
}


UserRating * CPicsDialog::GetTempRating( PicsCategory *pPC )
{
    UserRating *pRating = NULL;

    /* save the selected value into the temporary ratings list */
    UserRatingSystem *pURS = GetTempRatingList();
    LPSTR pszRatingService = pPC->pPRS->etstrRatingService.Get();
    if (pURS != NULL)
    {
        pURS = FindRatingSystem(pURS, pszRatingService);
    }

    if (pURS == NULL)
    {
        pURS = new UserRatingSystem;
        if (pURS == NULL)
        {
            TraceMsg( TF_ERROR, "CPicsDialog::GetTempRating() - pURS is NULL!" );
            return NULL;
        }

        PRSD * pPRSD = m_pPRSD;

        ASSERT( pPRSD );

        pURS->SetName(pszRatingService);
        pURS->m_pNext = pPRSD ? pPRSD->pTempRatings : NULL;
        pURS->m_pPRS = pPC->pPRS;
        if ( pPRSD )
        {
            pPRSD->pTempRatings = pURS;
        }
    }

    LPSTR pszRatingName = pPC->etstrTransmitAs.Get();

    pRating = pURS->FindRating(pszRatingName);
    if (pRating == NULL)
    {
        pRating = new UserRating;
        if (pRating == NULL)
        {
            TraceMsg( TF_ERROR, "CPicsDialog::GetTempRating() - pRating is NULL!" );
            return NULL;
        }

        pRating->SetName(pszRatingName);
        pRating->m_pPC = pPC;
        if (!pPC->etnMin.fIsInit() || (pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get()))
        {
            pRating->m_nValue = 0;
        }
        else
        {
            pRating->m_nValue = pPC->etnMin.Get();
        }

        pURS->AddRating(pRating);
    }

    return pRating;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\ratguid.cpp ===
#include "msrating.h"

// declaring the GUIDs inline avoids having to use INITGUID
// avoiding unneeded GUIDs being pulled in. these will eventually
// need to go in a public header/lib so other people can implement
// these interfaces and use our COM object

// 20EDB660-7CDD-11CF-8DAB-00AA006C1A01
const GUID CLSID_RemoteSite = {0x20EDB660L, 0x7CDD, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
// 19427BA0-826C-11CF-8DAB-00AA006C1A01
const GUID IID_IObtainRating = {0x19427BA0L, 0x826C, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\ratguid.h ===
// 20EDB660-7CDD-11CF-8DAB-00AA006C1A01
extern const GUID CLSID_RemoteSite;

// 19427BA0-826C-11CF-8DAB-00AA006C1A01
extern const GUID IID_IObtainRating;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\pleasdlg.h ===
/****************************************************************************\
 *
 *   pleasdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Access Denied Dialog
 *
\****************************************************************************/

#ifndef PLEASE_DIALOG_H
#define PLEASE_DIALOG_H

#include "basedlg.h"        // CBaseDialog

const UINT MAX_CACHED_LABELS = 16;
const UINT WM_NEWDIALOG = WM_USER + 1000;

const DWORD PDD_DONE = 0x1;
const DWORD PDD_ALLOW = 0x2;

// $BUG - This should be placed in pleasdlg.cpp.
const char szRatingsProp[] = "RatingsDialogHandleProp";
const char szRatingsValue[] = "RatingsDialogHandleValue";

struct PleaseDlgData
{
    LPCSTR pszUsername;
    LPCSTR pszContentDescription;
    PicsUser *pPU;
    CParsedLabelList *pLabelList;
    HWND hwndDlg;
    HWND hwndOwner;
    DWORD dwFlags;
    HWND hwndEC;
    UINT cLabels;
    LPSTR apLabelStrings[MAX_CACHED_LABELS];
};

class CPleaseDialog: public CBaseDialog<CPleaseDialog>
{
private:
    static DWORD aIds[];
    static DWORD aPleaseIds[];
    PleaseDlgData * m_ppdd;

public:
    enum { IDD = IDD_PLEASE };

public:
    CPleaseDialog( PleaseDlgData * p_ppdd );

public:
    typedef CPleaseDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOK)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        MESSAGE_HANDLER(WM_NEWDIALOG, OnNewDialog)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNewDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void    AppendString(HWND hwndEC, LPCSTR pszString);
    void    AddSeparator(HWND hwndEC, BOOL fAppendToEnd);
    void    InitPleaseDialog( PleaseDlgData * pdd );
    void    EndPleaseDialog( BOOL fRet);
    HRESULT AddToApprovedSites( BOOL fAlwaysNever, BOOL fSitePage );

protected:
    BOOL    IsPleaseDialog( void )      { ASSERT( m_ppdd ); return ( m_ppdd ? m_ppdd->pPU->fPleaseMom : TRUE ); }
    BOOL    IsDenyDialog( void )        { return ! IsPleaseDialog(); }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\picsdlg.h ===
/****************************************************************************\
 *
 *   picsdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Pics Ratings Property Page
 *
\****************************************************************************/

#ifndef PICS_DIALOG_H
#define PICS_DIALOG_H

#include "basedlg.h"        // CBasePropertyPage

// #define RATING_LOAD_GRAPHICS

typedef HINSTANCE (APIENTRY *PFNSHELLEXECUTE)(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);

class CPicsDialog : public CBasePropertyPage<IDD_RATINGS>
{
private:
    static DWORD aIds[];
    PRSD *      m_pPRSD;

public:
    CPicsDialog( PRSD * p_pPRSD );

    void        PicsDlgSave( void );
    BOOL        InstallDefaultProvider( void );

public:
    typedef CPicsDialog thisClass;
    typedef CBasePropertyPage<IDD_RATINGS> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_SYSCOLORCHANGE, OnSysColorChange)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
        MESSAGE_HANDLER(WM_VSCROLL, OnScroll)

        COMMAND_ID_HANDLER(IDC_DETAILSBUTTON, OnDetails)

        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnSetActive)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnReset)
        NOTIFY_CODE_HANDLER(TVN_ITEMEXPANDING, OnTreeItemExpanding)
        NOTIFY_CODE_HANDLER(TVN_SELCHANGED, OnTreeSelChanged)

        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnSysColorChange(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnDetails(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnSetActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnReset(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnTreeItemExpanding(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnTreeSelChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    void        SetTreeImages( HWND hwndTV, HIMAGELIST himl );
    BOOL        InitTreeViewImageLists(HWND hwndTV);
    void        LaunchRatingSystemSite( void );
    void        PicsDlgInit( void );
    void        KillTree(HWND hwndTree, HTREEITEM hTree);
    void        PicsDlgUninit( void );

#ifdef RATING_LOAD_GRAPHICS
    POINT       BitmapWindowCoord( int nID );
    void        LoadGraphic( char *pIcon, POINT pt );
#endif

    PicsEnum *  PosToEnum(PicsCategory *pPC, LPARAM lPos);
    void        NewTrackbarPosition( void );
    void        SelectRatingSystemNode( PicsCategory *pPC );
    void        SelectRatingSystemInfo( PicsRatingSystem *pPRS );
    void        DeleteBitmapWindow( HWND & p_rhwnd );
    void        ControlsShow( TreeNodeEnum tne );
    TreeNode*   TreeView_GetSelectionLParam(HWND hwndTree);
    HTREEITEM   AddOneItem(HWND hwndTree, HTREEITEM hParent, LPSTR szText, HTREEITEM hInsAfter, LPARAM lpData, int iImage);
    void        AddCategory(PicsCategory *pPC, HWND hwndTree, HTREEITEM hParent);
    UserRatingSystem *  GetTempRatingList( void );
    UserRating *    GetTempRating( PicsCategory *pPC );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\pleasdlg.cpp ===
/****************************************************************************\
 *
 *   pleasdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Access Denied Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include "parselbl.h"
#include "picsrule.h"
#include "pleasdlg.h"       // CPleaseDialog
#include "hint.h"           // CHint
#include <contxids.h>       // Help Context ID's
#include <mluisupp.h>       // SHWinHelpOnDemandWrap() and MLLoadStringA()
#include <wininet.h>        // URL_COMPONENTS

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

// $KLUDGE begins -- These should not be a global set outside the class!!
extern BOOL  g_fInvalid;
extern DWORD g_dwDataSource;

extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern BOOL g_fPICSRulesEnforced,g_fApprovedSitesEnforced;
extern HMODULE g_hURLMON,g_hWININET;
extern char g_szLastURL[INTERNET_MAX_URL_LENGTH];
// $KLUDGE ends -- These should not be a global set outside the class!!

DWORD CPleaseDialog::aIds[] = {
    IDC_STATIC2,                IDH_IGNORE,
    IDC_CONTENTLABEL,           IDH_IGNORE,
    IDC_CONTENTERROR,           IDH_RATINGS_DESCRIBE_RESTRICTED,
    IDC_CONTENTDESCRIPTION,     IDH_RATINGS_DESCRIBE_RESTRICTED,
    IDC_STATIC4,                IDH_IGNORE,
    IDC_STATIC5,                IDH_IGNORE,
    IDC_STATIC3,                IDH_IGNORE,
    IDC_BLOCKING_SITE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_BLOCKING_PAGE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_BLOCKING_ONCE,          IDH_RATINGS_VIEW_RESTRICTED,
    IDC_OLD_HINT_LABEL,         IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_OLD_HINT_TEXT,          IDH_RATINGS_DISPLAY_PW_HINT,
    IDC_STATIC1,                IDH_RATINGS_SUPERVISOR_PASSWORD,
    IDC_PASSWORD,               IDH_RATINGS_SUPERVISOR_PASSWORD,
    0,0
};

// Array of Dialog Ids which are displayed for Please dialog and not for Deny dialog.
DWORD CPleaseDialog::aPleaseIds[] = {
    IDC_STATIC4,
    IDC_STATIC3,
    IDC_STATIC5,
    IDC_BLOCKING_SITE,
    IDC_BLOCKING_PAGE,
    IDC_BLOCKING_ONCE,
    IDC_OLD_HINT_LABEL,
    IDC_OLD_HINT_TEXT,
    IDC_STATIC1,
    IDC_PASSWORD
};

CPleaseDialog::CPleaseDialog( PleaseDlgData * p_ppdd )
{
    ASSERT( p_ppdd );

    m_ppdd = p_ppdd;
}

LRESULT CPleaseDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ASSERT( m_ppdd );

    if ( m_ppdd )
    {
        ASSERT( m_ppdd->hwndDlg == NULL );

        if ( m_ppdd->hwndDlg == NULL )
        {
            m_ppdd->hwndDlg = m_hWnd;

            /* Attach our data structure to the dialog so we can find it when the
             * dialog is dismissed, and on the owner window passed to the API so
             * we can find it on subsequent API calls.
             */

            SetProp( m_ppdd->hwndOwner, szRatingsProp, (HANDLE)m_ppdd );
        }
    }

    // Display the Please dialog controls or hide them all.
    for ( int iIndex=0; iIndex<sizeof(aPleaseIds)/sizeof(DWORD); iIndex++ )
    {
        ShowHideControl( aPleaseIds[iIndex], IsPleaseDialog() );
    }

    // Reduce the height of the dialog.
    if ( IsDenyDialog() )
    {
        ReduceDialogHeight( IDC_CONTENTDESCRIPTION );
    }

    InitPleaseDialog( m_ppdd );

    if ( IsPleaseDialog() )
    {
        if ( GetDlgItem(IDC_PASSWORD) != NULL )
        {
            SendDlgItemMessage(IDC_PASSWORD,EM_SETLIMITTEXT,(WPARAM) RATINGS_MAX_PASSWORD_LENGTH,(LPARAM) 0);
        }

        // Display previously created hint (if one exists).
        {
            CHint       oldHint( m_hWnd, IDC_OLD_HINT_TEXT );

            oldHint.DisplayHint();
        }

        // set focus to password field
        ::SetFocus( GetDlgItem(IDC_PASSWORD) );
    }

    bHandled = FALSE;
    return 0L;      // The focus was set to the password field.
}

LRESULT CPleaseDialog::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    EndPleaseDialog(FALSE);
    return 0L;
}

LRESULT CPleaseDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    // For Deny dialog there is no password so the code below checks for a non-existance password?
    if ( IsDenyDialog() )
    {
        EndPleaseDialog(FALSE);
        return 0L;
    }

    char    szPassword[MAXPATHLEN];
    HRESULT hRet;

    szPassword[0] = '\0';

    ASSERT( GetDlgItem( IDC_PASSWORD ) != NULL );

    GetDlgItemText(IDC_PASSWORD, szPassword, sizeof(szPassword));

    hRet = VerifySupervisorPassword(szPassword);

    if (hRet == ResultFromScode(S_OK))
    {
        if (SendDlgItemMessage(IDC_BLOCKING_PAGE,
                              BM_GETCHECK,
                              (WPARAM) 0,
                              (LPARAM) 0)==BST_CHECKED)
        {
            HRESULT hRes;

            hRes=AddToApprovedSites(PICSRULES_ALWAYS,PICSRULES_PAGE);

            if (FAILED(hRes))
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_APPROVED_CANTSAVE,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        }
        else if (SendDlgItemMessage(IDC_BLOCKING_SITE,
                                   BM_GETCHECK,
                                   (WPARAM) 0,
                                   (LPARAM) 0)==BST_CHECKED)
        {
            HRESULT hRes;

            hRes=AddToApprovedSites(PICSRULES_ALWAYS,PICSRULES_SITE);

            if (FAILED(hRes))
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_APPROVED_CANTSAVE,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        }

        EndPleaseDialog(TRUE);
    }
    else
    {
        MyMessageBox(m_hWnd, IDS_BADPASSWORD, IDS_GENERIC, MB_OK|MB_ICONERROR);
        ::SetFocus(GetDlgItem(IDC_PASSWORD));
        SetDlgItemText(IDC_PASSWORD, szNULL);
    }

    return 0L;
}

LRESULT CPleaseDialog::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)((LPHELPINFO)lParam)->hItemHandle, ::szHelpFile,
            HELP_WM_HELP, (DWORD_PTR)(LPSTR)aIds);

    return 0L;
}

LRESULT CPleaseDialog::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SHWinHelpOnDemandWrap((HWND)wParam, ::szHelpFile, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPVOID)aIds);

    return 0L;
}

LRESULT CPleaseDialog::OnNewDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    InitPleaseDialog( (PleaseDlgData *) lParam );

    return 0L;
}

void CPleaseDialog::AppendString(HWND hwndEC, LPCSTR pszString)
{
    int cchEdit = ::GetWindowTextLength(hwndEC);
    ::SendMessage(hwndEC, EM_SETSEL, (WPARAM)cchEdit, (LPARAM)cchEdit);
    ::SendMessage(hwndEC, EM_REPLACESEL, 0, (LPARAM)pszString);
}

void CPleaseDialog::AddSeparator(HWND hwndEC, BOOL fAppendToEnd)
{
    NLS_STR nlsTemp(MAX_RES_STR_LEN);
    if (nlsTemp.QueryError() != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PleaseDialog::AddSeparator() - Failed to allocate nlsTemp!" );
        return;
    }

    if (fAppendToEnd)
    {
        nlsTemp.LoadString(IDS_DESCRIPTION_SEPARATOR);
        AppendString(hwndEC, nlsTemp.QueryPch());
    }

    nlsTemp.LoadString(IDS_FRAME);
    if (fAppendToEnd)
    {
        AppendString(hwndEC, nlsTemp.QueryPch());
    }
    else
    {
        ::SendMessage(hwndEC, EM_SETSEL, 0, 0);
        ::SendMessage(hwndEC, EM_REPLACESEL, 0, (LPARAM)(LPCSTR)nlsTemp.QueryPch());
    }
}

void CPleaseDialog::InitPleaseDialog( PleaseDlgData * pdd )
{
    CComAutoCriticalSection         critSec;

/****
    rated:
        for each URS with m_fInstalled = TRUE:
            for each UR with m_fFailed = TRUE:
                add line to EC
        
    not rated:
        no label list? --> report not rated
        invalid string in label list? --> report invalid rating
        any URS's with invalid strings? --> report invalid rating
        any URS's with error strings? --> report label error
        no URS's marked installed? --> report unknown rating system
        for installed URS's:
            for each UR:
                options has invalid string? --> report invalid rating
                options expired? --> report expired
                not fFound? --> report unknown rating
****/
    ASSERT( pdd );

    if ( ! pdd )
    {
        TraceMsg( TF_ERROR, "CPleaseDialog::InitPleaseDialog() - pdd is NULL!" );
        return;
    }

    ASSERT( pdd == m_ppdd );

    CParsedLabelList *pLabelList = pdd->pLabelList;

    for (UINT i=0; i<pdd->cLabels && i<ARRAYSIZE(pdd->apLabelStrings); i++)
    {
        if (pdd->apLabelStrings[i] == NULL)
        {
            if (pLabelList == NULL || pLabelList->m_pszOriginalLabel == NULL)
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - pLabelList is NULL or m_pszOriginalLabel is NULL!" );
                return;
            }
        }
        else
        {
            if (pLabelList != NULL &&
                pLabelList->m_pszOriginalLabel != NULL &&
                ! ::strcmpf( pdd->apLabelStrings[i], pLabelList->m_pszOriginalLabel ) )
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - apLabelStrings[%d]='%s' does not match m_pszOriginalLabel='%s'!", i, pdd->apLabelStrings[i], pLabelList->m_pszOriginalLabel );
                return;
            }
        }
    }

    if (pdd->cLabels < ARRAYSIZE(pdd->apLabelStrings))
    {
        if (pLabelList == NULL || pLabelList->m_pszOriginalLabel == NULL)
        {
            pdd->apLabelStrings[pdd->cLabels] = NULL;
        }
        else
        {
            pdd->apLabelStrings[pdd->cLabels] = new char[::strlenf(pLabelList->m_pszOriginalLabel)+1];

            if (pdd->apLabelStrings[pdd->cLabels] != NULL)
            {
                ::strcpyf(pdd->apLabelStrings[pdd->cLabels], pLabelList->m_pszOriginalLabel);
            }
        }
    }

    CString             strTitle;

    if ( pLabelList && pLabelList->m_pszURL && pLabelList->m_pszURL[0] != '\0' )
    {
        strTitle.Format( IDS_CONTENT_ADVISOR_HTTP_TITLE, pLabelList->m_pszURL );
    }
    else
    {
        strTitle.LoadString( IDS_CONTENT_ADVISOR_TITLE );
    }

    SetWindowText( strTitle );

    HWND hwndDescription = GetDlgItem(IDC_CONTENTDESCRIPTION);
    HWND hwndError = GetDlgItem(IDC_CONTENTERROR);
    HWND hwndPrevEC = pdd->hwndEC;

    /* There are two edit controls in the dialog.  One, the "description"
     * control, has a horizontal scrollbar, because we don't want word wrap
     * for the category names (cleaner presentation).  The other EC has no
     * scrollbar so that the lengthy error strings will wordwrap.
     *
     * If we've been using the description control and we add error-type
     * information, we need to copy the text out of the description control
     * into the error control and show it.
     */
    BOOL fRatedPage = ( pLabelList != NULL && pLabelList->m_fRated );
    if ( ! fRatedPage && pdd->hwndEC == hwndDescription )
    {
        NLS_STR nlsTemp(::GetWindowTextLength(hwndDescription));
        if (nlsTemp.QueryError() == ERROR_SUCCESS)
        {
            CHAR * tempStr = nlsTemp.Party();
            if (tempStr)
            {
                ::GetWindowText(hwndDescription, tempStr, nlsTemp.QueryAllocSize());
                nlsTemp.DonePartying();
                ::SetWindowText(hwndError, nlsTemp.QueryPch());
            }
            else
            {
                nlsTemp.DonePartying();
            }
        }

        pdd->hwndEC = hwndError;
    }
    else if (pdd->hwndEC == NULL)
    {
        pdd->hwndEC = fRatedPage ? hwndDescription : hwndError;
    }

    if (pdd->hwndEC != hwndPrevEC)
    {
        BOOL fShowErrorCtl = (pdd->hwndEC == hwndError);
        if (::GetFocus() == hwndPrevEC)
        {
            ::SetFocus(pdd->hwndEC);
        }

        ShowHideControl( IDC_CONTENTERROR, fShowErrorCtl );
        ShowHideControl( IDC_CONTENTDESCRIPTION, ! fShowErrorCtl );
    }

    /* If there's already just one label in the list, prefix it with a
     * label "Frame:" since there will now be two.
     */
    if (pdd->cLabels == 1)
    {
        AddSeparator(pdd->hwndEC, FALSE);
    }

    /* If this is not the first label we're adding, we need a full separator
     * appended before we add new descriptive text.
     */
    if (pdd->cLabels > 0)
    {
        AddSeparator(pdd->hwndEC, TRUE);
    }

    if (g_fInvalid)
    {
        char szSourceMessage[MAX_PATH];

        MLLoadString(IDS_TAMPEREDRATING1,(char *) szSourceMessage,MAX_PATH);

        AppendString(pdd->hwndEC, szSourceMessage);
        AppendString(pdd->hwndEC, "\x0D\x0A");

        MLLoadString(IDS_TAMPEREDRATING2,(char *) szSourceMessage,MAX_PATH);
        AppendString(pdd->hwndEC, szSourceMessage);
    }
    else if (fRatedPage)
    {
        NLS_STR nlsTemplate(MAX_RES_STR_LEN);
        nlsTemplate.LoadString(IDS_RATINGTEMPLATE);
        NLS_STR nlsTmp;
        if (nlsTemplate.QueryError() || nlsTmp.QueryError())
        {
            TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - fRatedPage => nlsTemplate or nlsTmp Error!" );
            return;
        }

        for (CParsedServiceInfo *ppsi = &pLabelList->m_ServiceInfo;
             ppsi != NULL;
             ppsi = ppsi->Next())
        {
            if (!ppsi->m_fInstalled)
                continue;

            UserRatingSystem *pURS = pdd->pPU->FindRatingSystem(ppsi->m_pszServiceName);
            if (pURS == NULL || pURS->m_pPRS == NULL)
                continue;

            NLS_STR nlsSystemName(STR_OWNERALLOC, pURS->m_pPRS->etstrName.Get());
            UINT cRatings = ppsi->aRatings.Length();
            for (UINT i=0; i<cRatings; i++)
            {
                CParsedRating *pRating = &ppsi->aRatings[i];
                if (pRating->fFailed)
                {
                    nlsTmp = nlsTemplate;
                    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
                    if (pUR == NULL)
                        continue;

                    PicsCategory *pPC = pUR->m_pPC;
                    if (pPC == NULL)
                        continue;

                    LPCSTR pszCategory;
                    if (pPC->etstrName.fIsInit())
                    {
                        pszCategory = pPC->etstrName.Get();
                    }
                    else if (pPC->etstrDesc.fIsInit())
                    {
                        pszCategory = pPC->etstrDesc.Get();
                    }
                    else
                    {
                        pszCategory = pRating->pszTransmitName;
                    }

                    NLS_STR nlsCategoryName(STR_OWNERALLOC, (LPSTR)pszCategory);
                    UINT cValues = pPC->arrpPE.Length();
                    PicsEnum *pPE;
                    for (UINT iValue=0; iValue<cValues; iValue++)
                    {
                        pPE = pPC->arrpPE[iValue];
                        if (pPE->etnValue.Get() == pRating->nValue)
                            break;
                    }

                    LPCSTR pszValue = szNULL;
                    char szNumBuf[20];
                    if (iValue < cValues)
                    {
                        if (pPE->etstrName.fIsInit())
                        {
                            pszValue = pPE->etstrName.Get();
                        }
                        else if (pPE->etstrDesc.fIsInit())
                        {
                            pszValue = pPE->etstrDesc.Get();
                        }
                        else
                        {
                            wsprintf(szNumBuf, "%d", pRating->nValue);
                            pszValue = szNumBuf;
                        }
                    }

                    NLS_STR nlsValueName(STR_OWNERALLOC, (LPSTR)pszValue);
                    const NLS_STR *apnls[] = { &nlsSystemName, &nlsCategoryName, &nlsValueName, NULL };
                    nlsTmp.InsertParams(apnls);
                    if (!nlsTmp.QueryError())
                    {
                        AppendString(pdd->hwndEC, nlsTmp.QueryPch());
                    }
                }
            }
        }

        if ((g_fPICSRulesEnforced!=TRUE)&&(g_fApprovedSitesEnforced!=TRUE))
        {
            UINT idSourceMsg;
            char szSourceMessage[MAX_PATH];

            switch(g_dwDataSource)
            {
                case PICS_LABEL_FROM_HEADER:
                {
                    idSourceMsg=IDS_SOURCE_SERVER;
                    break;
                }
                case PICS_LABEL_FROM_PAGE:
                {
                    idSourceMsg=IDS_SOURCE_EMBEDDED;
                    break;
                }
                case PICS_LABEL_FROM_BUREAU:
                {
                    idSourceMsg=IDS_SOURCE_BUREAU;
                    break;
                }
            }

            MLLoadString(idSourceMsg,(char *) szSourceMessage,MAX_PATH);

            AppendString(pdd->hwndEC, "\x0D\x0A");
            AppendString(pdd->hwndEC, szSourceMessage);
        }
    }
    else
    {
        UINT idMsg = 0;
        LPCSTR psz1=szNULL, psz2=szNULL;
        if ( pLabelList == NULL || pLabelList->m_fNoRating )
        {
            idMsg = IDS_UNRATED;
        }
        else if (pLabelList->m_pszInvalidString)
        {
            idMsg = IDS_INVALIDRATING;
            psz1 = pLabelList->m_pszInvalidString;
        }
        else
        {
            BOOL fErrorFound = FALSE;
            BOOL fAnyInstalled = FALSE;
            CParsedServiceInfo *ppsi = &pLabelList->m_ServiceInfo;
            while (ppsi != NULL)
            {
                if (ppsi->m_pszInvalidString)
                {
                    idMsg = IDS_INVALIDRATING;
                    psz1 = ppsi->m_pszInvalidString;
                    fErrorFound = TRUE;
                }
                else if (ppsi->m_pszErrorString)
                {
                    idMsg = IDS_LABELERROR;
                    psz1 = ppsi->m_pszErrorString;
                    fErrorFound = TRUE;
                }
                else if (ppsi->m_fInstalled)
                {
                    fAnyInstalled = TRUE;
                }

                ppsi = ppsi->Next();
            }
            if (!fErrorFound)
            {
                if (!fAnyInstalled)
                {
                    idMsg = IDS_UNKNOWNSYSTEM;
                    psz1 = pLabelList->m_ServiceInfo.m_pszServiceName;
                }
                else
                {
                    for (ppsi = &pLabelList->m_ServiceInfo;
                         ppsi != NULL;
                         ppsi = ppsi->Next())
                    {
                        if ( ! ppsi->m_fInstalled )
                            continue;

                        UINT cRatings = ppsi->aRatings.Length();
                        for (UINT i=0; i<cRatings; i++)
                        {
                            CParsedRating *ppr = &ppsi->aRatings[i];
                            COptionsBase *pOpt = ppr->pOptions;
                            if (pOpt->m_pszInvalidString)
                            {
                                idMsg = IDS_INVALIDRATING;
                                psz1 = pOpt->m_pszInvalidString;
                                break;
                            }
                            else if (pOpt->m_fdwFlags & LBLOPT_WRONGURL)
                            {
                                idMsg = IDS_WRONGURL;
                                psz1 = pLabelList->m_pszURL;
                                psz2 = pOpt->m_pszURL;
                            }
                            else if (pOpt->m_fdwFlags & LBLOPT_EXPIRED)
                            {
                                idMsg = IDS_EXPIRED;
                                break;
                            }
                            else if (!ppr->fFound)
                            {
                                idMsg = IDS_UNKNOWNRATING;
                                psz1 = ppr->pszTransmitName;
                                UserRatingSystem *pURS = pdd->pPU->FindRatingSystem(ppsi->m_pszServiceName);
                                if (pURS != NULL && pURS->m_pPRS != NULL)
                                {
                                    if (pURS->m_pPRS->etstrName.fIsInit())
                                    {
                                        psz2 = pURS->m_pPRS->etstrName.Get();
                                    }
                                }
                                break;
                            }
                        }
                        if (idMsg != 0)
                            break;
                    }
                }
            }
        }

        if (g_fPICSRulesEnforced==TRUE)
        {
            idMsg=IDS_PICSRULES_ENFORCED;
        }
        else if (g_fApprovedSitesEnforced==TRUE)
        {
            idMsg=IDS_APPROVEDSITES_ENFORCED;
        }

        /* It's theoretically possible that we got through all that and
         * didn't find anything explicitly wrong, yet the site was considered
         * unrated (perhaps it was a valid label with no actual ratings in it).
         * So if we didn't decide what error to display, just don't stick
         * anything in the edit control, and the dialog will just say "Sorry"
         * at the top.
         */
        if (idMsg != 0)
        {
            NLS_STR nls1(STR_OWNERALLOC, (LPSTR)psz1);
            NLS_STR nls2(STR_OWNERALLOC, (LPSTR)psz2);
            const NLS_STR *apnls[] = { &nls1, &nls2, NULL };
            NLS_STR nlsMessage(MAX_RES_STR_LEN);
            nlsMessage.LoadString((USHORT)idMsg, apnls);
            AppendString(pdd->hwndEC, nlsMessage.QueryPch());
        }

        if (idMsg == IDS_UNKNOWNSYSTEM)
        {
            NLS_STR nlsTemplate(MAX_RES_STR_LEN);
            nlsTemplate.LoadString(IDS_UNKNOWNRATINGTEMPLATE);
            NLS_STR nlsTmp;
            if (nlsTemplate.QueryError() || nlsTmp.QueryError())
            {
                TraceMsg( TF_WARNING, "CPleaseDialog::InitPleaseDialog() - IDS_UNKNOWNSYSTEM => nlsTemplate or nlsTmp Error!" );
                return;
            }
            
            UINT cRatings = pLabelList->m_ServiceInfo.aRatings.Length();
            for (UINT i=0; i<cRatings; i++)
            {
                CParsedRating *ppr = &pLabelList->m_ServiceInfo.aRatings[i];

                char szNumBuf[20];
                wsprintf(szNumBuf, "%d", ppr->nValue);

                NLS_STR nlsCategoryName(STR_OWNERALLOC, ppr->pszTransmitName);
                NLS_STR nlsValueName(STR_OWNERALLOC, szNumBuf);
                const NLS_STR *apnls[] = { &nlsCategoryName, &nlsValueName, NULL };
                nlsTmp = nlsTemplate;
                nlsTmp.InsertParams(apnls);
                if (!nlsTmp.QueryError())
                {
                    AppendString(pdd->hwndEC, nlsTmp.QueryPch());
                }
            }
        }
    }

    if ( IsPleaseDialog() )
    {
        SendDlgItemMessage(IDC_BLOCKING_ONCE,
                           BM_SETCHECK,
                           (WPARAM) BST_CHECKED,
                           (LPARAM) 0);

        SendDlgItemMessage(IDC_BLOCKING_PAGE,
                           BM_SETCHECK,
                           (WPARAM) BST_UNCHECKED,
                           (LPARAM) 0);

        SendDlgItemMessage(IDC_BLOCKING_SITE,
                           BM_SETCHECK,
                           (WPARAM) BST_UNCHECKED,
                           (LPARAM) 0);
    }

    pdd->cLabels++;       /* now one more label description in the box */
}

void CPleaseDialog::EndPleaseDialog( BOOL fRet)
{
    PleaseDlgData *ppdd = m_ppdd;

    ASSERT( m_ppdd );

    if (ppdd != NULL)
    {
        ppdd->dwFlags = PDD_DONE | (fRet ? PDD_ALLOW : 0);
        ppdd->hwndDlg = NULL;

        SetProp( m_ppdd->hwndOwner, szRatingsValue, UlongToPtr( ppdd->dwFlags ) );
        RemoveProp(ppdd->hwndOwner, szRatingsProp);
    }

    EndDialog(fRet);
}

HRESULT CPleaseDialog::AddToApprovedSites(BOOL fAlwaysNever,BOOL fSitePage)
{
    PICSRulesPolicy             * pPRPolicy;
    PICSRulesByURL              * pPRByURL;
    PICSRulesByURLExpression    * pPRByURLExpression;
    char                        * lpszSiteURL;
    HRESULT                     hRes;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme,lpszHostName,lpszUserName,
                                lpszPassword,lpszUrlPath,lpszExtraInfo;
    BOOL                        fAddedScheme=FALSE;
    int                         iCounter,iLoopCounter;

    lpszSiteURL=new char[INTERNET_MAX_URL_LENGTH];

    if (lpszSiteURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    strcpy(lpszSiteURL,g_szLastURL);

    if (g_pApprovedPRRS==NULL)
    {
        g_pApprovedPRRS=new PICSRulesRatingSystem;

        if (g_pApprovedPRRS==NULL)
        {
            return(E_OUTOFMEMORY);
        }
    }

    pPRPolicy=new PICSRulesPolicy;

    if (pPRPolicy==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRByURL=new PICSRulesByURL;

    if (pPRByURL==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    if (fAlwaysNever==PICSRULES_NEVER)
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;
        pPRPolicy->AddItem(PROID_REJECTBYURL,pPRByURL);
    }
    else
    {
        pPRPolicy->m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;
        pPRPolicy->AddItem(PROID_ACCEPTBYURL,pPRByURL);
    }

    pPRByURLExpression=new PICSRulesByURLExpression;
    
    if (pPRByURLExpression==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

    //if we made it through all that, then we have a
    //PICSRulesByURLExpression to fill out, and need
    //to update the list box.

    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if (lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if (pfnInternetCrackUrl==NULL)
    {
        return(E_UNEXPECTED);
    }

    pfnInternetCrackUrl(lpszSiteURL,0,ICU_DECODE,&URLComponents);

    delete lpszExtraInfo; //we don't do anything with this for now
    lpszExtraInfo = NULL;

    delete lpszPassword; //not supported by PICSRules
    lpszPassword = NULL;

    if (g_fApprovedSitesEnforced==TRUE)
    {
        int             iCounter;
        PICSRulesPolicy * pPRFindPolicy;
        BOOL            fFound=FALSE,fDeleted=FALSE;
        
        //we've already got an Approved Sites setting enforcing this
        //so check for an exact match, and if it exists, change it
        //instead of adding another
        
        for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesByURLExpression * pPRFindByURLExpression;
            PICSRulesByURL           * pPRFindByURL;
            char                     * lpszTest;

            pPRFindPolicy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];

            switch(pPRFindPolicy->m_PRPolicyAttribute)
            {
                case PR_POLICY_REJECTBYURL:
                {
                    pPRFindByURL=pPRFindPolicy->m_pPRRejectByURL;

                    break;
                }
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRFindByURL=pPRFindPolicy->m_pPRAcceptByURL;

                    break;
                }
            }

            pPRFindByURLExpression=pPRFindByURL->m_arrpPRByURL[0];

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_SCHEME)
            {
                if (lpszScheme==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrScheme.Get();

                if (lstrcmpi(lpszScheme,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_USER)
            {
                if (lpszUserName==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrUser.Get();

                if (lstrcmpi(lpszUserName,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if ((pPRFindByURLExpression->m_bNonWild)&BYURL_HOST)
            {
                if (lpszHostName==NULL)
                {
                    fFound=FALSE;

                    continue;
                }

                lpszTest=pPRFindByURLExpression->m_etstrHost.Get();

                if (lstrcmp(lpszHostName,lpszTest)==0)
                {
                    fFound=TRUE;
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }
            else
            {
                fFound=TRUE;
            }

            if (fSitePage!=PICSRULES_SITE)
            {
                if ((pPRFindByURLExpression->m_bNonWild)&BYURL_PATH)
                {
                    int iLen;

                    if (lpszUrlPath==NULL)
                    {
                        fFound=FALSE;

                        continue;
                    }

                    lpszTest=pPRFindByURLExpression->m_etstrPath.Get();

                    //kill trailing slashes
                    iLen=lstrlen(lpszTest);

                    if (lpszTest[iLen-1]=='/')
                    {
                        lpszTest[iLen-1]='\0';
                    }

                    iLen=lstrlen(lpszUrlPath);

                    if (lpszUrlPath[iLen-1]=='/')
                    {
                        lpszUrlPath[iLen-1]='\0';
                    }
                    
                    if (lstrcmp(lpszUrlPath,lpszTest)==0)
                    {
                        fFound=TRUE;
                    }
                    else
                    {
                        fFound=FALSE;

                        continue;
                    }
                }
                else
                {
                    fFound=FALSE;

                    continue;
                }
            }

            if (fFound==TRUE)
            {
                if (fSitePage==PICSRULES_PAGE)
                {
                    break;
                }
                else
                {
                    delete pPRFindPolicy;
                    pPRFindPolicy = NULL;

                    g_pApprovedPRRS->m_arrpPRPolicy[iCounter]=NULL;

                    fDeleted=TRUE;
                }
            }
        }

        if (fDeleted==TRUE)
        {
            PICSRulesRatingSystem * pPRRSNew;

            pPRRSNew=new PICSRulesRatingSystem;

            if (pPRRSNew==NULL)
            {
                return(E_OUTOFMEMORY);
            }

            for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
            {
                if ((g_pApprovedPRRS->m_arrpPRPolicy[iCounter])!=NULL)
                {
                    pPRRSNew->m_arrpPRPolicy.Append((g_pApprovedPRRS->m_arrpPRPolicy[iCounter]));
                }
            }

            g_pApprovedPRRS->m_arrpPRPolicy.ClearAll();

            delete g_pApprovedPRRS;

            g_pApprovedPRRS=pPRRSNew;

            fFound=FALSE;
        }

        if (fFound==TRUE)
        {
            delete pPRFindPolicy;
            pPRFindPolicy= NULL;

            g_pApprovedPRRS->m_arrpPRPolicy[iCounter]=pPRPolicy;
        }
        else
        {
            hRes=g_pApprovedPRRS->AddItem(PROID_POLICY,pPRPolicy);

            if (FAILED(hRes))
            {
                return(hRes);
            }
        }
    }
    else
    {
        hRes=g_pApprovedPRRS->AddItem(PROID_POLICY,pPRPolicy);

        if (FAILED(hRes))
        {
            return(hRes);
        }
    }

    pPRByURLExpression->m_fInternetPattern=TRUE;

    if ((*lpszScheme!=NULL)&&(fAddedScheme==FALSE))
    {
        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.SetTo(lpszScheme);   
    }
    else
    {
        delete lpszScheme;
        lpszScheme = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;

    if (*lpszUserName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_USER;           
        pPRByURLExpression->m_etstrUser.SetTo(lpszUserName);
    }
    else
    {
        delete lpszUserName;
        lpszUserName = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_USER;

    if (*lpszHostName!=NULL)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;           
        pPRByURLExpression->m_etstrHost.SetTo(lpszHostName);
    }
    else
    {
        delete lpszHostName;
        lpszHostName = NULL;
    }
    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if (*lpszUrlPath!=NULL)
    {
        if (lstrcmp(lpszUrlPath,"/")!=0)
        {
            if (fSitePage==PICSRULES_PAGE)
            {
                pPRByURLExpression->m_bNonWild|=BYURL_PATH;           
                pPRByURLExpression->m_etstrPath.SetTo(lpszUrlPath);
            }
        }
    }
    else
    {
        delete lpszUrlPath;
        lpszUrlPath = NULL;
    }

    pPRByURLExpression->m_bSpecified|=BYURL_PATH;

    if (URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
    {
        LPSTR lpszTemp;

        lpszTemp=new char[MAX_PATH];

            if (lpszTemp==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
        wsprintf(lpszTemp,"%d",URLComponents.nPort);

        pPRByURLExpression->m_bNonWild|=BYURL_PORT;           
        pPRByURLExpression->m_etstrPort.SetTo(lpszTemp);
    }
    pPRByURLExpression->m_bSpecified|=BYURL_PORT;

    if (fSitePage==PICSRULES_PAGE)
    {
        pPRByURLExpression->m_etstrURL.SetTo(lpszSiteURL);
    }
    else
    {
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpression->m_etstrHost.Get());
    }

    //copy master list to the PreApply list so we can reorder the entries
    //to obtain the appropriate logic.

    if (g_pApprovedPRRSPreApply!=NULL)
    {
        delete g_pApprovedPRRSPreApply;
    }

    g_pApprovedPRRSPreApply=new PICSRulesRatingSystem;

    if (g_pApprovedPRRSPreApply==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return(E_OUTOFMEMORY);
    }

    for (iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
        PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
        PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

        pPRPolicy=new PICSRulesPolicy;
        
        if (pPRPolicy==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        pPRPolicyToCopy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];
        
        pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

        pPRByURL=new PICSRulesByURL;
        
        if (pPRByURL==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        if (pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            
            pPRPolicy->m_pPRAcceptByURL=pPRByURL;
        }
        else
        {
            pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;

            pPRPolicy->m_pPRRejectByURL=pPRByURL;
        }

        pPRByURLExpression=new PICSRulesByURLExpression;

        if (pPRByURLExpression==NULL)
        {
            char    szTitle[MAX_PATH],szMessage[MAX_PATH];

            //out of memory, so we init on the stack

            MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

            MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

            return(E_OUTOFMEMORY);
        }

        pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

        if (pPRByURLExpressionToCopy==NULL)
        {
            char    *lpszTitle,*lpszMessage;

            //we shouldn't ever get here

            lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
            lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

            MLLoadString(IDS_ERROR,(LPTSTR) lpszTitle,MAX_PATH);
            MLLoadString(IDS_PICSRULES_NOAPPROVEDSAVE,(LPTSTR) lpszMessage,MAX_PATH);

            MessageBox((LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

            GlobalFree(lpszTitle);
            lpszTitle = NULL;
            GlobalFree(lpszMessage);
            lpszMessage = NULL;

            delete pPRPolicy;
            pPRPolicy = NULL;

            return(E_UNEXPECTED);
        }

        pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
        pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
        pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
        pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
        pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
        pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
        pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
        pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
        pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

        
        pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

        g_pApprovedPRRSPreApply->m_arrpPRPolicy.Append(pPRPolicy);
    }

    if (g_pApprovedPRRS!=NULL)
    {
        delete g_pApprovedPRRS;
    }

    g_pApprovedPRRS=new PICSRulesRatingSystem;

    if (g_pApprovedPRRS==NULL)
    {
        char    szTitle[MAX_PATH],szMessage[MAX_PATH];

        //out of memory, so we init on the stack

        MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
        MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

        MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

        return(E_OUTOFMEMORY);
    }

    for (iLoopCounter=0;iLoopCounter<2;iLoopCounter++)
    {
        for (iCounter=0;iCounter<g_pApprovedPRRSPreApply->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy             * pPRPolicy,* pPRPolicyToCopy;
            PICSRulesByURL              * pPRByURL,* pPRByURLToCopy;
            PICSRulesByURLExpression    * pPRByURLExpression,* pPRByURLExpressionToCopy;

            pPRPolicyToCopy=g_pApprovedPRRSPreApply->m_arrpPRPolicy[iCounter];

            if (pPRPolicyToCopy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRAcceptByURL;
            }
            else
            {
                pPRByURLToCopy=pPRPolicyToCopy->m_pPRRejectByURL;
            }

            pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[0];

            if (pPRByURLExpressionToCopy==NULL)
            {
                char    *lpszTitle,*lpszMessage;

                //we shouldn't ever get here

                lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                MLLoadString(IDS_ERROR,(LPTSTR) lpszTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_NOAPPROVEDSAVE,(LPTSTR) lpszMessage,MAX_PATH);

                MessageBox((LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                GlobalFree(lpszTitle);
                lpszTitle = NULL;
                GlobalFree(lpszMessage);
                lpszMessage = NULL;

                return(E_UNEXPECTED);
            }

            //we want to put all of the non-sitewide approved sites first
            //so that a user can specify, allow all of xyz.com except for
            //xyz.com/foo.htm
            switch(iLoopCounter)
            {
                case 0:
                {
                    if ((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                case 1:
                {
                    if (!((pPRByURLExpressionToCopy->m_bNonWild)&BYURL_PATH))
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
            }

            pPRPolicy=new PICSRulesPolicy;
    
            if (pPRPolicy==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }
   
            pPRPolicy->m_PRPolicyAttribute=pPRPolicyToCopy->m_PRPolicyAttribute;

            pPRByURL=new PICSRulesByURL;
    
            if (pPRByURL==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }

            if (pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
            {                       
                pPRPolicy->m_pPRAcceptByURL=pPRByURL;
            }
            else
            {
                pPRPolicy->m_pPRRejectByURL=pPRByURL;
            }

            pPRByURLExpression=new PICSRulesByURLExpression;

            if (pPRByURLExpression==NULL)
            {
                char    szTitle[MAX_PATH],szMessage[MAX_PATH];

                //out of memory, so we init on the stack

                MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

                MessageBox((LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);

                return(E_OUTOFMEMORY);
            }

            pPRByURLExpression->m_fInternetPattern=pPRByURLExpressionToCopy->m_fInternetPattern;
            pPRByURLExpression->m_bNonWild=pPRByURLExpressionToCopy->m_bNonWild;
            pPRByURLExpression->m_bSpecified=pPRByURLExpressionToCopy->m_bSpecified;
            pPRByURLExpression->m_etstrScheme.Set(pPRByURLExpressionToCopy->m_etstrScheme.Get());
            pPRByURLExpression->m_etstrUser.Set(pPRByURLExpressionToCopy->m_etstrUser.Get());
            pPRByURLExpression->m_etstrHost.Set(pPRByURLExpressionToCopy->m_etstrHost.Get());
            pPRByURLExpression->m_etstrPort.Set(pPRByURLExpressionToCopy->m_etstrPort.Get());
            pPRByURLExpression->m_etstrPath.Set(pPRByURLExpressionToCopy->m_etstrPath.Get());
            pPRByURLExpression->m_etstrURL.Set(pPRByURLExpressionToCopy->m_etstrURL.Get());

    
            pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression);

            g_pApprovedPRRS->m_arrpPRPolicy.Append(pPRPolicy);
        }           
    }

    PICSRulesDeleteSystem(PICSRULES_APPROVEDSITES);
    PICSRulesSaveToRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    return(NOERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\picsuser.cpp ===
/****************************************************************************\
 *
 *   PICSUSER.C -- Structure for holding user information
 *
 *     Created:      02/29/96 gregj
 *                from original sources by t-jasont
 *     
\****************************************************************************/

/*Includes------------------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"

BOOL GetRegBool(HKEY hKey, LPCSTR pszValueName, BOOL fDefault)
{
    BOOL fRet = fDefault;
    DWORD dwSize, dwValue, dwType;
    UINT uErr;

    dwSize = sizeof(dwValue);

    uErr = RegQueryValueEx(hKey, pszValueName, NULL, &dwType, 
                            (LPBYTE)&dwValue, &dwSize);

    if (uErr == ERROR_SUCCESS)
    {
        if ((dwType == REG_DWORD) || (dwType == REG_BINARY && dwSize >= sizeof(fRet)))
            fRet = dwValue;
    }

    return fRet;
}


void SetRegBool(HKEY hkey, LPCSTR pszValueName, BOOL fValue)
{
    RegSetValueEx(hkey, pszValueName, 0, REG_DWORD, (LPBYTE)&fValue, sizeof(fValue));
}


PicsRatingSystem *FindInstalledRatingSystem(LPCSTR pszRatingService)
{
    UINT cServices = gPRSI->arrpPRS.Length();

    for (UINT i=0; i<cServices; i++) {
        PicsRatingSystem *pPRS = gPRSI->arrpPRS[i];
        if (!(pPRS->dwFlags & PRS_ISVALID) || !pPRS->etstrRatingService.fIsInit())
            continue;
        if (!::strcmpf(pPRS->etstrRatingService.Get(), pszRatingService))
            return pPRS;
    }
    return NULL;
}


PicsCategory *FindInstalledCategory(array<PicsCategory *>&arrpPC, LPCSTR pszName)
{
    UINT cCategories = arrpPC.Length();

    for (UINT i=0; i<cCategories; i++) {
        LPSTR pszThisName = arrpPC[i]->etstrTransmitAs.Get();
        if (!::strcmpf(pszThisName, pszName))
            return arrpPC[i];
        if (!::strncmpf(pszThisName, pszName, strlenf(pszThisName)) &&
            arrpPC[i]->arrpPC.Length() > 0) {
            PicsCategory *pCategory = FindInstalledCategory(arrpPC[i]->arrpPC, pszName);
            if (pCategory != NULL)
                return pCategory;
        }
    }
    return NULL;
}


UserRating::UserRating()
    : NLS_STR(NULL),
      m_nValue(0),
      m_pNext(NULL),
      m_pPC(NULL)
{
}


UserRating::UserRating(UserRating *pCopyFrom)
    : NLS_STR(*pCopyFrom),
      m_nValue(pCopyFrom->m_nValue),
      m_pNext(NULL),
      m_pPC(pCopyFrom->m_pPC)
{
}


UserRating::~UserRating()
{
    // needed to destruct name string
}


UserRating *UserRating::Duplicate(void)
{
    UserRating *pNew = new UserRating(this);
    return pNew;
}


UserRatingSystem::UserRatingSystem()
    : NLS_STR(NULL),
      m_pRatingList(NULL),
      m_pNext(NULL),
      m_pPRS(NULL)
{

}


UserRatingSystem::UserRatingSystem(UserRatingSystem *pCopyFrom)
    : NLS_STR(*pCopyFrom),
      m_pRatingList(NULL),
      m_pNext(NULL),
      m_pPRS(pCopyFrom->m_pPRS)
{

}


UserRatingSystem *UserRatingSystem::Duplicate(void)
{
    UserRatingSystem *pNew = new UserRatingSystem(this);
    if (pNew != NULL) {
        UserRating *pRating;

        for (pRating = m_pRatingList; pRating != NULL; pRating = pRating->m_pNext) {
            UserRating *pNewRating = pRating->Duplicate();
            if (pNewRating != NULL) {
                if (pNew->AddRating(pNewRating) != ERROR_SUCCESS) {
                    delete pNewRating;
                    pNewRating = NULL;
                }
            }

            if (pNewRating == NULL)
                break;
        }
    }

    return pNew;
}


UserRatingSystem *DuplicateRatingSystemList(UserRatingSystem *pOld)
{
    UserRatingSystem *pNewList = NULL;

    while (pOld != NULL) {
        UserRatingSystem *pNewEntry = pOld->Duplicate();
        if (pNewEntry == NULL)
            break;

        pNewEntry->m_pNext = pNewList;
        pNewList = pNewEntry;

        pOld = pOld->m_pNext;
    }

    return pNewList;
}


UserRatingSystem::~UserRatingSystem()
{
    UserRating *pRating, *pNext;

    for (pRating = m_pRatingList; pRating != NULL; )
    {
        pNext = pRating->m_pNext;
        delete pRating;
        pRating = pNext;
    }

#ifdef DEBUG
    m_pRatingList = NULL;
#endif
}


UserRating *UserRatingSystem::FindRating(LPCSTR pszTransmitName)
{
    UserRating *p;

    for (p = m_pRatingList; p != NULL; p = p->m_pNext)
    {
        if (!::stricmpf(p->QueryPch(), pszTransmitName))
            break;
    }

    return p;
}


UINT UserRatingSystem::AddRating(UserRating *pRating)
{
    pRating->m_pNext = m_pRatingList;
    m_pRatingList = pRating;
    return ERROR_SUCCESS;
}


UINT UserRatingSystem::ReadFromRegistry(HKEY hkeyProvider)
{
    UINT err;
    DWORD iValue = 0;
    char szValueName[MAXPATHLEN];
    DWORD cchValue;
    DWORD dwValue;
    DWORD cbData;

    do {
        cchValue = sizeof(szValueName);
        cbData = sizeof(dwValue);
        err = RegEnumValue(hkeyProvider, iValue, szValueName, &cchValue,
                           NULL, NULL, (LPBYTE)&dwValue, &cbData);
        if (err == ERROR_SUCCESS && cbData >= sizeof(dwValue)) {
            UserRating *pRating = new UserRating;
            if (pRating != NULL) {
                if (pRating->QueryError()) {
                    err = pRating->QueryError();
                }
                else {
                    pRating->SetName(szValueName);
                    pRating->m_nValue = (INT)dwValue;
                    if (m_pPRS != NULL)
                        pRating->m_pPC = FindInstalledCategory(m_pPRS->arrpPC, szValueName);
                    err = AddRating(pRating);
                }
                if (err != ERROR_SUCCESS)
                {
                    delete pRating;
                    pRating = NULL;
                }
            }
            else
                err = ERROR_NOT_ENOUGH_MEMORY;
        }
        iValue++;
    } while (err == ERROR_SUCCESS);

    if (err == ERROR_NO_MORE_ITEMS)
        err = ERROR_SUCCESS;

    return err;
}


UINT UserRatingSystem::WriteToRegistry(HKEY hkeyRatings)
{
    UserRating *pRating;
    UINT err = ERROR_SUCCESS;
    CRegKey         key;

    err = key.Create( hkeyRatings, QueryPch() );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "UserRatingSystem::WriteToRegistry() - Failed to create Ratings Key QueryPch()='%s'!", QueryPch() );
        return err;
    }

    for (pRating = m_pRatingList; pRating != NULL; pRating = pRating->m_pNext)
    {
        err = key.SetValue( pRating->m_nValue, pRating->QueryPch() );
        if (err != ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "UserRatingSystem::WriteToRegistry() - Failed to set Ratings Value pRating->QueryPch()='%s'!", pRating->QueryPch() );
            break;
        }
    }

    return err;
}


PicsUser::PicsUser()
    : nlsUsername(NULL),
      fAllowUnknowns(FALSE),
      fPleaseMom(TRUE),
      fEnabled(TRUE),
      m_pRatingSystems(NULL)
{
}


PicsRatingSystemInfo::~PicsRatingSystemInfo()
{
    arrpPRS.DeleteAll();

    if ( pUserObject )
    {
        delete pUserObject;
        pUserObject = NULL;
    }
}


void DestroyRatingSystemList(UserRatingSystem *pList)
{
    UserRatingSystem *pSystem, *pNext;

    for (pSystem = pList; pSystem != NULL; )
    {
        pNext = pSystem->m_pNext;
        delete pSystem;
        pSystem = pNext;
    }
}


PicsUser::~PicsUser()
{
    DestroyRatingSystemList(m_pRatingSystems);
#ifdef DEBUG
    m_pRatingSystems = NULL;
#endif
}


UserRatingSystem *FindRatingSystem(UserRatingSystem *pList, LPCSTR pszSystemName)
{
    UserRatingSystem *p;

    for (p = pList; p != NULL; p = p->m_pNext)
    {
        if (!::strcmpf(p->QueryPch(), pszSystemName))
            break;
    }

    return p;
}


UINT PicsUser::AddRatingSystem(UserRatingSystem *pRatingSystem)
{
    pRatingSystem->m_pNext = m_pRatingSystems;
    m_pRatingSystems = pRatingSystem;
    return ERROR_SUCCESS;
}


UINT PicsUser::ReadFromRegistry(HKEY hkey, char *pszUserName)
{
    CRegKey             keyUser;

    nlsUsername = pszUserName;

    UINT err = keyUser.Open( hkey, pszUserName, KEY_READ );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PicsUser::ReadFromRegistry() - Failed keyUser Open to pszUserName='%s'!", pszUserName );
        return err;
    }

    fAllowUnknowns = GetRegBool( keyUser.m_hKey, VAL_UNKNOWNS, FALSE);
    fPleaseMom = GetRegBool( keyUser.m_hKey, VAL_PLEASEMOM, TRUE);
    fEnabled = GetRegBool( keyUser.m_hKey, VAL_ENABLED, TRUE);

    {
        char szKeyName[MAXPATHLEN];
        int j = 0;
        // enumerate the subkeys, which are rating systems
        while ( ( err = RegEnumKey( keyUser.m_hKey, j, szKeyName, sizeof(szKeyName) ) ) == ERROR_SUCCESS )
        {
            CRegKey             keyProvider;

            if ( ( err = keyProvider.Open( keyUser.m_hKey, szKeyName, KEY_READ ) != ERROR_SUCCESS ) )
            {
                TraceMsg( TF_WARNING, "PicsUser::ReadFromRegistry() - Failed keyProvider Open to szKeyName='%s'!", szKeyName );
                break;
            }

            UserRatingSystem *pRatingSystem = new UserRatingSystem;
            if (pRatingSystem == NULL)
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            if (pRatingSystem->QueryError())
            {
                err = pRatingSystem->QueryError();
            }
            else
            {
                pRatingSystem->SetName(szKeyName);
                pRatingSystem->m_pPRS = FindInstalledRatingSystem(szKeyName);
                err = pRatingSystem->ReadFromRegistry( keyProvider.m_hKey );
                if (err == ERROR_SUCCESS)
                {
                    err = AddRatingSystem(pRatingSystem);
                }
            }

            if (err != ERROR_SUCCESS)
            {
                delete pRatingSystem;
                pRatingSystem = NULL;
            }

            j++;
        }
    }

    // end of enum will report ERROR_NO_MORE_ITEMS, don't report this as error
    if (err == ERROR_NO_MORE_ITEMS)
    {
        err = ERROR_SUCCESS;
    }

    return err;
}

BOOL PicsUser::NewInstall()
{
    nlsUsername = szDefaultUserName;
    fAllowUnknowns = FALSE;
    fPleaseMom = TRUE;
    fEnabled = TRUE;
    
    return TRUE;
}


UINT PicsUser::WriteToRegistry(HKEY hkey)
{
    UINT err;

    //Delete it to clean out registry
    MyRegDeleteKey(hkey, nlsUsername.QueryPch());

    CRegKey             keyUser;

    err = keyUser.Create( hkey, nlsUsername.QueryPch() );
    if (err != ERROR_SUCCESS)
    {
        TraceMsg( TF_WARNING, "PicsUser::WriteToRegistry() - Failed to Create User Key nlsUsername='%s'!", nlsUsername.QueryPch() );
        return err;
    }

    SetRegBool( keyUser.m_hKey, VAL_UNKNOWNS, fAllowUnknowns);
    SetRegBool( keyUser.m_hKey, VAL_PLEASEMOM, fPleaseMom);
    SetRegBool( keyUser.m_hKey, VAL_ENABLED, fEnabled);

    {
        UserRatingSystem *pSystem;

        /* Note, if any user settings correspond to invalid or unknown
         * rating systems, we still save them here.  That way, the user
         * settings don't get lost if the supervisor later fixes a problem
         * with a .RAT file.
         *
         * We clean up user settings to match the installed rating systems
         * in the add/remove rating systems dialog code.
         */
        for (pSystem = m_pRatingSystems; pSystem != NULL; pSystem = pSystem->m_pNext)
        {
            err = pSystem->WriteToRegistry( keyUser.m_hKey );
            if (err != ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "PicsUser::WriteToRegistry() - Failed pSystem->WriteToRegistry()!" );
                break;
            }
        }
    }

    return err;
}


PicsUser *GetUserObject(LPCSTR pszUsername /* = NULL */ )
{
    ASSERT( gPRSI );

    return gPRSI ? gPRSI->pUserObject : NULL;
}


void DeleteUserSettings(PicsRatingSystem *pPRS)
{
    if (!pPRS->etstrRatingService.fIsInit())
        return;        /* can't recognize user settings without this */

    PicsUser *pPU = GetUserObject();

    UserRatingSystem **ppLast = &pPU->m_pRatingSystems;

    while (*ppLast != NULL)
    {
        if (!stricmpf((*ppLast)->QueryPch(), pPRS->etstrRatingService.Get()))
        {
            UserRatingSystem *pCurrent = *ppLast;
            *ppLast = pCurrent->m_pNext;    /* remove from list */
            delete pCurrent;
            pCurrent = NULL;
            break;
        }
        else
        {
            ppLast = &((*ppLast)->m_pNext);
        }
    }
}


void CheckUserCategory(UserRatingSystem *pURS, PicsCategory *pPC)
{
    for (UserRating *pRating = pURS->m_pRatingList;
         pRating != NULL;
         pRating = pRating->m_pNext)
    {
        if (!::strcmpf(pRating->QueryPch(), pPC->etstrTransmitAs.Get()))
            break;
    }

    if (pRating == NULL) {
        /* User setting not found for this category.  Add one. */

        pRating = new UserRating;
        if (pRating != NULL) {
            pRating->SetName(pPC->etstrTransmitAs.Get());
            pRating->m_pPC = pPC;
            pRating->m_pNext = pURS->m_pRatingList;
            pURS->m_pRatingList = pRating;
            if ((pPC->etfLabelled.fIsInit() && pPC->etfLabelled.Get()) ||
                !pPC->etnMin.fIsInit())
                pRating->m_nValue = 0;
            else
                pRating->m_nValue = pPC->etnMin.Get();
        }
    }

    /* Check all subcategories in this category as well.
     */
    UINT cCategories = pPC->arrpPC.Length();
    for (UINT i=0; i<cCategories; i++)
        CheckUserCategory(pURS, pPC->arrpPC[i]);
}


void CheckUserSettings(PicsRatingSystem *pPRS)
{
    if (pPRS == NULL || !(pPRS->dwFlags & PRS_ISVALID) ||
        !pPRS->etstrRatingService.fIsInit())
        return;

    PicsUser *pPU = GetUserObject();

    UserRatingSystem **ppLast = &pPU->m_pRatingSystems;

    while (*ppLast != NULL) {
        if (!stricmpf((*ppLast)->QueryPch(), pPRS->etstrRatingService.Get())) {
            break;
        }
        ppLast = &((*ppLast)->m_pNext);
    }

    if (*ppLast == NULL) {
        *ppLast = new UserRatingSystem;
        if (*ppLast == NULL)
            return;
        (*ppLast)->SetName(pPRS->etstrRatingService.Get());
    }

    UserRatingSystem *pCurrent = *ppLast;

    pCurrent->m_pPRS = pPRS;

    /* First go through all the settings for the user and make sure the
     * categories are valid.  If not, delete them.
     */
    UserRating **ppRating = &pCurrent->m_pRatingList;
    while (*ppRating != NULL)
    {
        UserRating *pRating = *ppRating;
        pRating->m_pPC = FindInstalledCategory(pPRS->arrpPC, pRating->QueryPch());
        if (pRating->m_pPC == NULL)
        {
            *ppRating = pRating->m_pNext;        /* remove from list */
            delete pRating;
            pRating = NULL;
        }
        else
        {
            ppRating = &pRating->m_pNext;
        }
    }

    /* Now go through all the categories in the rating system and make
     * sure the user has settings for them.  If any are missing, add
     * settings for the default values (minimums).
     */
    UINT cCategories = pPRS->arrpPC.Length();
    for (UINT i=0; i<cCategories; i++)
        CheckUserCategory(pCurrent, pPRS->arrpPC[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\picsrule.h ===
//*******************************************************************
//*
//* PICSRule.h
//*
//* Revision History:
//*     Created 7/98 - Mark Hammond (t-markh)
//*
//* Contains classes and function prototypes
//* used for processing PICSRules files.
//*
//*******************************************************************

#ifndef PICS_RULE_H
#define PICS_RULE_H

//*******************************************************************
//*
//* Function Prototypes / class declarations
//*
//*******************************************************************

//Forward class declarations
class PICSRulesQuotedURL;
class PICSRulesQuotedEmail;
class PICSRulesQuotedDate;
class PICSRulesYesNo;
class PICSRulesPassFail;
class PICSRulesPolicyExpression;
class PICSRulesByURL;
class PICSRulesPolicy;
class PICSRulesName;
class PICSRulesSource;
class PICSRulesServiceInfo;
class PICSRulesOptExtension;
class PICSRulesReqExtension;
class PICSRulesFileParser;
class PICSRulesRatingSystem;
class CParsedLabelList;

//This function is called by ApprovedSitesDlgProc while processing
//WM_COMMOND with LOWORD(wParam)==IDC_PICSRULESOPEN in msludlg.cpp
//The argument lpszFileName is the name of the PICSRules file
//selected by the user to import.
//
//This begins the PICSRules Import process.
HRESULT PICSRulesImport(char *lpszFileName, PICSRulesRatingSystem **pprrsOut);

//For reading and saving processed PICSRules from the registry
HRESULT PICSRulesSaveToRegistry(DWORD dwSystemToSave, PICSRulesRatingSystem **ppPRRS);
HRESULT PICSRulesReadFromRegistry(DWORD dwSystemToRead, PICSRulesRatingSystem **ppPRRS);
HRESULT PICSRulesDeleteSystem(DWORD dwSystemToDelete);
HRESULT PICSRulesSetNumSystems(DWORD dwNumSystems);
HRESULT PICSRulesGetNumSystems(DWORD * pdwNumSystems);
HRESULT PICSRulesCheckApprovedSitesAccess(LPCSTR lpszUrl,BOOL *fPassFail);
HRESULT PICSRulesCheckAccess(LPCSTR lpszUrl,LPCSTR lpszRatingInfo,BOOL *fPassFail,CParsedLabelList **ppParsed);
void PICSRulesOutOfMemory();

//The following are handler functions which parse the various
//kinds of content which can occur within a parenthesized object.
//
//ppszIn is always advanced to the next non-white space token
//ppszOut returns the processed data
HRESULT PICSRulesParseString(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParseNumber(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParseYesNo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
HRESULT PICSRulesParsePassFail(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);

BOOL IsURLValid(WCHAR wcszURL[]);

//*******************************************************************
//*
//* Definitions used by the PICSRules code
//*
//*******************************************************************
#define PR_QUOTE_DOUBLE     1
#define PR_QUOTE_SINGLE     0

#define BYURL_SCHEME    1
#define BYURL_USER      2
#define BYURL_HOST      4
#define BYURL_PORT      8
#define BYURL_PATH      16

#define PICSRULES_FIRSTSYSTEMINDEX  100
#define PICSRULES_MAXSYSTEM         1000000
#define PICSRULES_APPROVEDSITES     0

#define PICSRULES_ALWAYS            1
#define PICSRULES_NEVER             0

#define PICSRULES_PAGE              1
#define PICSRULES_SITE              0

#define PICS_LABEL_FROM_HEADER      0
#define PICS_LABEL_FROM_PAGE        1
#define PICS_LABEL_FROM_BUREAU      2

struct PICSRULES_VERSION
{
    int iPICSRulesVerMajor,iPICSRulesVerMinor;
};

//Data types for the necessary logic in evaluating
//the rules.
enum PICSRulesOperators
{
    PR_OPERATOR_INVALID,
    PR_OPERATOR_GREATEROREQUAL,
    PR_OPERATOR_GREATER,
    PR_OPERATOR_EQUAL,
    PR_OPERATOR_LESSOREQUAL,
    PR_OPERATOR_LESS,
    PR_OPERATOR_DEGENERATE,
    PR_OPERATOR_SERVICEONLY,
    PR_OPERATOR_SERVICEANDCATEGORY,
    PR_OPERATOR_RESULT
};

enum PICSRulesEvaluation
{
    PR_EVALUATION_DOESAPPLY,
    PR_EVALUATION_DOESNOTAPPLY
};

//This indicates which member is valid in a PICSRulesPolicy
//Class
enum PICSRulesPolicyAttribute
{
    PR_POLICY_NONEVALID,
    PR_POLICY_REJECTBYURL,
    PR_POLICY_ACCEPTBYURL,
    PR_POLICY_REJECTIF,
    PR_POLICY_ACCEPTIF,
    PR_POLICY_REJECTUNLESS,
    PR_POLICY_ACCEPTUNLESS
};

//This indicates if a PolicyExpression is embedded in another
//PolicyExpression, and if so, what logic to use.
enum PICSRulesPolicyEmbedded
{
    PR_POLICYEMBEDDED_NONE,
    PR_POLICYEMBEDDED_OR,
    PR_POLICYEMBEDDED_AND
};

//*******************************************************************
//*
//* Classes to handle possible value types... all derive from
//* ETS (the encapsulated string type) since the are found as
//* strings during processing.
//*
//* The Set() and SetTo() member functions are overloaded on the
//* types which convert from a string.  We want to keep the original
//* string in case the data is invalid.
//*
//* Additional member functions are provided to assure that the
//* data is what it says it is, and to return the non-string type.
//*
//*******************************************************************
class PICSRulesByURLExpression
{
    public:
        PICSRulesByURLExpression();
        ~PICSRulesByURLExpression();

        BOOL    m_fInternetPattern;
        BYTE    m_bNonWild,m_bSpecified;
        ETS     m_etstrScheme,m_etstrUser,m_etstrHost,m_etstrPort,m_etstrPath,m_etstrURL;
};

class PICSRulesQuotedURL : public ETS
{
    public:
        PICSRulesQuotedURL();
        ~PICSRulesQuotedURL();

        BOOL IsURLValid();
        BOOL IsURLValid(char * lpszURL);
        BOOL IsURLValid(ETS etstrURL);
};

class PICSRulesQuotedEmail : public ETS
{
    public:
        PICSRulesQuotedEmail();
        ~PICSRulesQuotedEmail();

        BOOL IsEmailValid();
        BOOL IsEmailValid(char * lpszEmail);
        BOOL IsEmailValid(ETS etstrEmail);
};

class PICSRulesQuotedDate : public ETS
{
    public:
        PICSRulesQuotedDate();
        ~PICSRulesQuotedDate();

        BOOL IsDateValid();
        BOOL IsDateValid(char * lpszDate);
        BOOL IsDateValid(ETS etstrDate);

        HRESULT Set(const char *pIn);
        HRESULT SetTo(char *pIn);

        DWORD GetDate()
        {
            return m_dwDate;
        };

    private:
        DWORD m_dwDate;
};

class PICSRulesYesNo : public ETS
{
    public:
        PICSRulesYesNo();
        ~PICSRulesYesNo();

        void Set(const BOOL *pIn);
        void SetTo(BOOL *pIn);

        BOOL GetYesNo()
        {
            return m_fYesOrNo;
        };

    private:
        BOOL m_fYesOrNo;
};
        
class PICSRulesPassFail : public ETS
{
    public:
        PICSRulesPassFail();
        ~PICSRulesPassFail();

        void Set(const BOOL *pIn);
        void SetTo(BOOL *pIn);

        BOOL GetPassFail()
        {
            return m_fPassOrFail;
        };

    private:
        BOOL m_fPassOrFail;
};

//*******************************************************************
//*
//* The PICSRulesPolicy class handles the "Policy" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     Policy (
//*         [Explanation]   quoted
//*         RejectByURL     URL | ( [patterns]  URL )
//*         AcceptByURL     URL | ( [patterns]  URL )
//*         RejectIf        PolicyExpression
//*         RejectUnless    PolicyExpression
//*         AcceptIf        PolicyExpression
//*         AcceptUnless    PolicyExpression
//*         *Extension* )
//*
//*******************************************************************

class PICSRulesPolicyExpression
{
    public:
        PICSRulesPolicyExpression       * m_pPRPolicyExpressionLeft,
                                        * m_pPRPolicyExpressionRight;
        ETS                             m_etstrServiceName,m_etstrCategoryName,
                                        m_etstrFullServiceName;
        ETN                             m_etnValue;
        PICSRulesYesNo                  m_prYesNoUseEmbedded;
        enum PICSRulesOperators         m_PROPolicyOperator;
        enum PICSRulesPolicyEmbedded    m_PRPEPolicyEmbedded;

        PICSRulesPolicyExpression();
        ~PICSRulesPolicyExpression();

        PICSRulesEvaluation EvaluateRule(CParsedLabelList *pParsed);
};

class PICSRulesByURL
{
    public:
        array<PICSRulesByURLExpression*> m_arrpPRByURL;

        PICSRulesByURL();
        ~PICSRulesByURL();

        PICSRulesEvaluation EvaluateRule(PICSRulesQuotedURL *pprurlComparisonURL);
};

class PICSRulesPolicy : public PICSRulesObjectBase
{
    public:
        ETS                                 m_etstrExplanation;
        PICSRulesPolicyExpression           * m_pPRRejectIf,* m_pPRRejectUnless,
                                            * m_pPRAcceptIf,* m_pPRAcceptUnless;
        PICSRulesByURL                      * m_pPRRejectByURL,* m_pPRAcceptByURL;
        PICSRulesPolicyAttribute            m_PRPolicyAttribute;
        
        PICSRulesPolicy();
        ~PICSRulesPolicy();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesName class handles the "name" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     name (
//*         [Rulename]  quoted
//*         Description quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesName : public PICSRulesObjectBase
{
    public:
        ETS m_etstrRuleName,m_etstrDescription;

        PICSRulesName();
        ~PICSRulesName();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesSource class handles the "source" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     source (
//*         [SourceURL]     URL
//*         CreationTool    quoted (has format toolname/version)
//*         author          email
//*         LastModified    ISO Date
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesSource : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLSourceURL;
        ETS                     m_etstrCreationTool;
        PICSRulesQuotedEmail    m_prEmailAuthor;
        PICSRulesQuotedDate     m_prDateLastModified;
        
        PICSRulesSource();
        ~PICSRulesSource();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();

        char * GetToolName();
};

//*******************************************************************
//*
//* The PICSRulesServiceInfo class handles the "serviceinfo" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//* The Ratfile attribute is either an entire machine readable .RAT
//* file, or the URL where the .RAT file can be obtained.
//*
//*     serviceinfo (
//*         [Name]              URL
//*         shortname           quoted
//*         BureauURL           URL
//*         UseEmbedded         Y|N
//*         Ratfile             quoted
//*         BureauUnavailable   PASS|FAIL
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesServiceInfo : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLName,m_prURLBureauURL;
        ETS                     m_etstrShortName,m_etstrRatfile;
        PICSRulesYesNo          m_prYesNoUseEmbedded;
        PICSRulesPassFail       m_prPassFailBureauUnavailable;

        PICSRulesServiceInfo();
        ~PICSRulesServiceInfo();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesOptExtension class handles the "optextension" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     optextension (
//*         [extension-name]    URL
//*         shortname           quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesOptExtension : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLExtensionName;
        ETS                     m_etstrShortName;

        PICSRulesOptExtension();
        ~PICSRulesOptExtension();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesReqExtension class handles the "reqextension" token
//* from a PICSRules stream, and its attributes (square brackets
//* denote the primary attribute):
//*
//*     reqextension (
//*         [extension-name]    URL
//*         shortname           quoted
//*         *Extension* )
//*
//*******************************************************************
class PICSRulesReqExtension : public PICSRulesObjectBase
{
    public:
        PICSRulesQuotedURL      m_prURLExtensionName;
        ETS                     m_etstrShortName;

        PICSRulesReqExtension();
        ~PICSRulesReqExtension();

        HRESULT AddItem(PICSRulesObjectID proid, LPVOID pData);
        HRESULT InitializeMyDefaults();
};

//*******************************************************************
//*
//* The PICSRulesRatingSystem class encapsulates all of the
//* information from a give PICSRules source.  Multiple
//* instantiations are created in the PicsRatingSystemInfo class,
//* created at startup and stored in gPRSI.
//*
//*******************************************************************
class PICSRulesRatingSystem : public PICSRulesObjectBase
{
    public:
        array<PICSRulesPolicy*>         m_arrpPRPolicy;
        array<PICSRulesServiceInfo*>    m_arrpPRServiceInfo;
        array<PICSRulesOptExtension*>   m_arrpPROptExtension;
        array<PICSRulesReqExtension*>   m_arrpPRReqExtension;
        PICSRulesName                   * m_pPRName;
        PICSRulesSource                 * m_pPRSource;
        ETS                             m_etstrFile;
        ETN                             m_etnPRVerMajor,m_etnPRVerMinor;
        DWORD                           m_dwFlags;
        UINT                            m_nErrLine;

        PICSRulesRatingSystem();
        ~PICSRulesRatingSystem();
        HRESULT Parse(LPCSTR pszFile, LPSTR pStreamIn);

        HRESULT AddItem(PICSRulesObjectID roid, LPVOID pData);
        HRESULT InitializeMyDefaults();
        void ReportError(HRESULT hres);
};

//*******************************************************************
//*
//* The PICSRulesFileParser class exists to provide a line number
//* shared by all the parsing routines.  This line number is updated
//* as the parser walks through the stream, and is frozen as soon as
//* an error is found.  This line number can later be reported to the
//* user to help localize errors.
//*
//*******************************************************************
class PICSRulesFileParser
{
public:
    UINT m_nLine;

    PICSRulesFileParser() { m_nLine = 1; }

    LPSTR EatQuotedString(LPSTR pIn,BOOL fQuote=PR_QUOTE_DOUBLE);
    HRESULT ParseToOpening(LPSTR *ppIn, PICSRulesAllowableOption  *paoExpected,
                           PICSRulesAllowableOption  **ppFound);
    HRESULT ParseParenthesizedObject(
        LPSTR *ppIn,                    //where we are in the text stream
        PICSRulesAllowableOption aao[], //allowable things inside this object
        PICSRulesObjectBase *pObject    //object to set parameters into
    );
    char* FindNonWhite(char *pc);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\picsrule.cpp ===
//*******************************************************************
//*
//* PICSRule.cpp
//*
//* Revision History:
//*     Created 7/98 - Mark Hammond (t-markh)
//*
//* Implements PICSRules parsing, decision making,
//* exporting, and editing.
//*
//*******************************************************************

//*******************************************************************
//*
//* A brief rundown on PICSRules files:
//*    (The official spec is at: http://www.w3.org/TR/REC-PICSRules)
//*
//* PICSRules files have MIME type: application/pics-rules and
//* consist of a sequence of parenthesis encapsulated attribute
//* value pairs.  Values consist of quoted strings or parenthesized
//* lists of further attribute value pairs.  Every subsection of a
//* PICSRules file has a primary attribute (denoted in the outline
//* below by square brackets); if any value is not paired with an
//* attribute, it is assigned to the primary attribute.
//*
//* Whitespace consists of the characters ' ', '\t', '\r', and '\n'
//* and is ignored except between attribute value pairs.
//*
//* Quoted strings can be encapsulated in either single ticks ('')
//* or double ticks (""), but may not use mixed notation ('" or "').
//*
//* The following escape sequences are observed in the quoted strings:
//*     " = %22
//*     ' = %27
//*     % = %25
//* Any other escape sequence is invalid.
//*
//* Both attributes and values are case sensitive.
//*
//* Curly brackets denote comments.
//*
//* --- Code Requirements ---
//*
//* The rule evaluator needs to return yes (accept) or no (reject)
//* AS WELL AS the policy clause that determined the answer.
//*
//* The rule evaluator stops when it hits the first policy clause
//* which is applicable.
//*
//* If no clause is satisfied, the default clause is:
//* AcceptIf "otherwise".  In this implementation, if no clause is
//* satisfied, evaluation is passed to our non-PICSRule evaluator.
//*
//* PICSRules 1.1 does NOT support Internationalization of the name
//* section (i.e. each language needs its own PICSRules file).
//* The AddItem function of the PICSRulesName class can easily be
//* extended if this behavior changes in a future revision of the
//* PICSRules spec.
//*
//* The Ratfile attribute is either an entire machine readable .RAT
//* file, or the URL where the .RAT file can be obtained.
//*
//* --- Attribute Value specifications ---
//*
//*
//* The main body of a PICSRules has the form:
//*
//* (PicsRule-%verMajor%.%verMinor%
//*     (
//*         Attribute Value
//*         ...
//*         Tag (
//*                 Attribute Value
//*                 ...
//*         )
//*     )
//* )
//*
//* The current %verMajor% is 1
//* The current %verMinor% is 1
//*
//* Possible Tags and their Attribute Value pairs are:
//*
//* Policy (
//*     [Explanation]       quoted
//*     RejectByURL         URL | ( [patterns]  URL )
//*     AcceptByURL         URL | ( [patterns]  URL )
//*     RejectIf            PolicyExpression
//*     RejectUnless        PolicyExpression
//*     AcceptIf            PolicyExpression
//*     AcceptUnless        PolicyExpression
//*     *Extension* )
//*
//* name (
//*     [Rulename]          quoted
//*     Description         quoted
//*     *Extension* )
//*
//* source (
//*     [SourceURL]         URL
//*     CreationTool        quoted (has format application/version)
//*     author              email
//*     LastModified        ISO Date
//*     *Extension* )
//*
//* serviceinfo (
//*     [Name]              URL
//*     shortname           quoted
//*     BureauURL           URL
//*     UseEmbedded         Y|N
//*     Ratfile             quoted
//*     BureauUnavailable   PASS|FAIL
//*     *Extension* )
//*
//* optextension (
//*     [extension-name]    URL
//*         shortname       quoted
//*         *Extension* )
//*
//* reqextension (
//*     [extension-name]    URL
//*         shortname       quoted
//*         *Extension* )
//*
//* *Extension*
//*
//* Further comments are given below
//*
//*******************************************************************


//*******************************************************************
//*
//* #Includes
//*
//*******************************************************************
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include "parselbl.h"       /* we use a couple of this guy's subroutines */
#include "msluglob.h"
#include "reghive.h"        // CRegistryHive
#include "buffer.h"
#include "resource.h"
#include <wininet.h>
#include "picsrule.h"

#include <mluisupp.h>
#include <winsock2.h>
#include <shlwapip.h>

//*******************************************************************
//*
//* Globals
//*
//*******************************************************************
array<PICSRulesRatingSystem*>   g_arrpPRRS;         //this is the array of PICSRules systems
                                                    //which are inforced while ie is running
PICSRulesRatingSystem *         g_pApprovedPRRS;    //this is the Approved Sites PICSRules
                                                    //system
PICSRulesRatingSystem *         g_pPRRS=NULL;       //this is a temporary pointer used while
                                                    //parsing a PICSRules file
HMODULE                         g_hURLMON,g_hWININET;

BOOL                            g_fPICSRulesEnforced,g_fApprovedSitesEnforced;

char                            g_szLastURL[INTERNET_MAX_URL_LENGTH];

extern DWORD                    g_dwDataSource;

extern HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
extern long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

//*******************************************************************
//*
//* Function Prototypes
//*
//*******************************************************************
HRESULT PICSRulesParseSubPolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser);
HRESULT PICSRulesParseSimplePolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser);
BOOL IsServiceDefined(LPSTR lpszService,LPSTR lpszFullService,PICSRulesServiceInfo **ppServiceInfo);
BOOL IsOptExtensionDefined(LPSTR lpszExtension);
BOOL IsReqExtensionDefined(LPSTR lpszExtension);
HRESULT PICSRulesParseSingleByURL(LPSTR lpszByURL, PICSRulesByURLExpression *pPRByURLExpression, PICSRulesFileParser *pParser);

//*******************************************************************
//*
//* Some definitions specific to this file
//*
//*******************************************************************
PICSRulesAllowableOption aaoPICSRules[] = {
    { PROID_PICSVERSION, 0 },
    
    { PROID_POLICY, AO_MANDATORY },
        { PROID_EXPLANATION, AO_SINGLE },
        { PROID_REJECTBYURL, AO_SINGLE },
        { PROID_ACCEPTBYURL, AO_SINGLE },
        { PROID_REJECTIF, AO_SINGLE },
        { PROID_ACCEPTIF, AO_SINGLE },
        { PROID_ACCEPTUNLESS, AO_SINGLE },
        { PROID_REJECTUNLESS, AO_SINGLE },
    { PROID_NAME, AO_SINGLE },
        { PROID_RULENAME, 0 },
        { PROID_DESCRIPTION, 0 },
    { PROID_SOURCE, AO_SINGLE },
        { PROID_SOURCEURL, 0 },
        { PROID_CREATIONTOOL, 0 },
        { PROID_AUTHOR, 0 },
        { PROID_LASTMODIFIED, 0 },
    { PROID_SERVICEINFO, 0 },
        { PROID_SINAME, AO_SINGLE },
        { PROID_SHORTNAME, AO_SINGLE },
        { PROID_BUREAUURL, 0 },
        { PROID_USEEMBEDDED, AO_SINGLE },
        { PROID_RATFILE, AO_SINGLE },
        { PROID_BUREAUUNAVAILABLE, AO_SINGLE },
    { PROID_OPTEXTENSION, 0 },
        { PROID_EXTENSIONNAME, AO_SINGLE },
      //{ PROID_SHORTNAME, AO_SINGLE },
    { PROID_REQEXTENSION, 0 },
      //{ PROID_EXTENSIONNAME, AO_SINGLE },
      //{ PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },

    { PROID_POLICYDEFAULT, AO_SINGLE },
    { PROID_NAMEDEFAULT, AO_SINGLE },
    { PROID_SOURCEDEFAULT, AO_SINGLE },
    { PROID_SERVICEINFODEFAULT, AO_SINGLE },
    { PROID_OPTEXTENSIONDEFAULT, AO_SINGLE },
    { PROID_REQEXTENSIONDEFAULT, AO_SINGLE },

    { PROID_INVALID, 0 }
};
const UINT caoPICSRules=sizeof(aaoPICSRules)/sizeof(aaoPICSRules[0]);

//The FN_INTERNETCRACKURL type describes the URLMON function InternetCrackUrl
typedef BOOL (*FN_INTERNETCRACKURL)(LPCTSTR lpszUrl,DWORD dwUrlLength,DWORD dwFlags,LPURL_COMPONENTS lpUrlComponents);

//The FN_ISVALIDURL type describes the URLMON function IsValidURL
//and is called by the three IsURLValid methods of PICSRulesQuotedURL
typedef HRESULT (*FN_ISVALIDURL)(LPBC pBC,LPCWSTR szURL,DWORD dwReserved);

//*******************************************************************
//*
//* This function is called by AdvancedDlgProc while processing
//* WM_COMMOND with LOWORD(wParam)==IDC_PICSRULESOPEN in msludlg.cpp
//* The argument lpszFileName is the name of the PICSRules file
//* selected by the user to import.
//*
//* This begins the PICSRules Import process.
//*
//*******************************************************************
HRESULT PICSRulesImport(char *lpszFileName, PICSRulesRatingSystem **pprrsOut)
{
    PICSRulesRatingSystem *pPRRS=new PICSRulesRatingSystem;

    *pprrsOut=pPRRS;
    
    if(pPRRS==NULL)
    {
        return E_OUTOFMEMORY;
    }

    UINT cbFilename=strlenf(lpszFileName)+1+1;      //room for marker character
    LPSTR lpszNameCopy=new char[cbFilename];
    
    if(lpszNameCopy==NULL)
    {
        return E_OUTOFMEMORY;
    }

    strcpyf(lpszNameCopy,lpszFileName);
    pPRRS->m_etstrFile.SetTo(lpszNameCopy);

    HRESULT hRes;

    HANDLE hFile=CreateFile(lpszNameCopy,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_SEQUENTIAL_SCAN,NULL);

    if(hFile!=INVALID_HANDLE_VALUE)
    {
        DWORD cbFile=::GetFileSize(hFile,NULL);

        BUFFER bufData(cbFile+1);

        if(bufData.QueryPtr()!=NULL)
        {
            LPSTR lpszData=(LPSTR)bufData.QueryPtr();
            DWORD cbRead;

            if(ReadFile(hFile,lpszData,cbFile,&cbRead,NULL))
            {
                lpszData[cbRead]='\0';              //null terminate whole file

                g_pPRRS=pPRRS;                      //make data available to
                                                    //parsing functions during
                                                    //parsing

                hRes=pPRRS->Parse(lpszFileName,lpszData);

                if(SUCCEEDED(hRes))
                {
                    pPRRS->m_dwFlags|=PRRS_ISVALID;
                }
                else
                {
                    g_pPRRS=NULL;
                }
            }
            else
            {
                hRes=HRESULT_FROM_WIN32(::GetLastError());
            }
            
            CloseHandle(hFile);
        }
        else
        {
            hRes=E_OUTOFMEMORY;
        }
    }
    else
    {
        hRes=HRESULT_FROM_WIN32(::GetLastError());
    }

    if(!(pPRRS->m_dwFlags&PRS_ISVALID))
    {
        //file is invalid
    }

    return hRes;
}

/* White returns a pointer to the first whitespace character starting at pc.*/
extern char* White(char *);

/* NonWhite returns a pointer to the first non-whitespace character starting at pc.*/
extern char* NonWhite(char *);

//*******************************************************************
//*
//* The following are handler functions which parse the various
//* kinds of content which can occur within a parenthesized object.
//*
//* ppszIn is always advanced to the next non-white space token
//* ppszOut returns the processed data
//*
//*******************************************************************

//The following escape sequences are observed:
//  "   =%22
//  '   =%27
//  %   =%25
//any other escape sequence is invalid
HRESULT PICSRulesParseString(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL fQuote;
    LPSTR lpszEscapeSequence,lpszNewEnd;

    *ppOut=NULL;
    
    LPSTR pszCurrent=*ppszIn;

    if(*pszCurrent=='\"')
    {
        fQuote=PR_QUOTE_DOUBLE;
    }
    else if(*pszCurrent=='\'')
    {
        fQuote=PR_QUOTE_SINGLE;
    }
    else
    {
        return(PICSRULES_E_EXPECTEDSTRING);
    }

    pszCurrent++;

    LPSTR pszEnd=pParser->EatQuotedString(pszCurrent,fQuote);
    
    if(pszEnd==NULL)
    {
        return(PICSRULES_E_EXPECTEDSTRING);
    }

    lpszNewEnd=pszEnd;

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%22");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='\"';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%27");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='\'';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    do
    {
        lpszEscapeSequence=strstrf(pszCurrent,"%25");

        if(lpszEscapeSequence>lpszNewEnd)
        {
            lpszEscapeSequence=NULL;
        }

        if(lpszEscapeSequence!=NULL)
        {
            *lpszEscapeSequence='%';

            memcpyf(lpszEscapeSequence+1,lpszEscapeSequence+3,(int)(lpszNewEnd-lpszEscapeSequence-3));

            lpszNewEnd-=2;
        }

    } while(lpszEscapeSequence!=NULL);

    UINT cbString= (unsigned int) (lpszNewEnd-pszCurrent);
    LPSTR pszNew = new char[cbString + 1];  //This memory gets assigned to an ET derived
                                            //type via the AddItem call for the class handling
                                            //the parenthesized object.  The memory is
                                            //deallocated when the handling class, and hence
                                            //the ET derived type, goes out of scope.
    if (pszNew==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpyf(pszNew, pszCurrent, cbString);
    pszNew[cbString]='\0';

    *ppOut=(LPVOID) pszNew;
    *ppszIn=pParser->FindNonWhite(pszEnd+1);

    return(NOERROR);
}

HRESULT PICSRulesParseNumber(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    int n;

    LPSTR pszCurrent=*ppszIn;
    HRESULT hres=::ParseNumber(&pszCurrent,&n,TRUE);

    if(FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDNUMBER);
    }

    *(int *)ppOut=n;

    LPSTR pszNewline=strchrf(*ppszIn, '\n');

    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }
    
    *ppszIn=pszCurrent;

    return(NOERROR);
}


HRESULT PICSRulesParseYesNo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL b;

    //The PICSRules spec allows the following:
    //
    //            "y" == Yes
    //          "yes" == Yes
    //            "n" == no
    //           "no" == no
    //
    //  string comparison is not case sensitive
    //

    LPSTR pszCurrent=*ppszIn;

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    HRESULT hres=::GetBool(&pszCurrent,&b,PR_BOOLEAN_YESNO);

    if (FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDBOOL);
    }

    LPSTR pszNewline=strchrf(*ppszIn,'\n');
    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    *ppszIn=pszCurrent;

    *(LPBOOL)ppOut=b;

    return(NOERROR);
}

HRESULT PICSRulesParsePassFail(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    BOOL b;

    //The PICSRules spec allows the following:
    //
    //         "pass" == pass
    //         "fail" == fail
    //
    //  for completeness we add:
    //
    //            "p" == pass
    //            "f" == fail
    //
    //  string comparison is not case sensitive
    //

    LPSTR pszCurrent=*ppszIn;

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    HRESULT hres=::GetBool(&pszCurrent,&b,PR_BOOLEAN_PASSFAIL);

    if (FAILED(hres))
    {
        return(PICSRULES_E_EXPECTEDBOOL);
    }

    LPSTR pszNewline=strchrf(*ppszIn,'\n');
    while((pszNewline!=NULL)&&(pszNewline<pszCurrent))
    {
        pParser->m_nLine++;
        pszNewline=strchrf(pszNewline+1,'\n');
    }

    if((*pszCurrent=='\"')||(*pszCurrent=='\''))
    {
        pszCurrent++;
    }

    *ppszIn=pszCurrent;

    *(LPBOOL)ppOut=b;

    return(NOERROR);
}

HRESULT PICSRulesParseVersion(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //t-markh - 8/98 - This shouldn't get called, version info should be filled
    //                 out before processing begins

    return(E_UNEXPECTED);
}

PICSRulesAllowableOption aaoPICSRulesPolicy[] = {
    { PROID_EXPLANATION, AO_SINGLE },
    { PROID_REJECTBYURL, AO_SINGLE },
    { PROID_ACCEPTBYURL, AO_SINGLE },
    { PROID_REJECTIF, AO_SINGLE },
    { PROID_ACCEPTIF, AO_SINGLE },
    { PROID_ACCEPTUNLESS, AO_SINGLE },
    { PROID_REJECTUNLESS, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesPolicy=sizeof(aaoPICSRulesPolicy)/sizeof(aaoPICSRulesPolicy[0]);

HRESULT PICSRulesParsePolicy(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesPolicy];

    ::memcpyf(aao,::aaoPICSRulesPolicy,sizeof(aao));

    PICSRulesPolicy *pPolicy=new PICSRulesPolicy;
    
    if(pPolicy==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pPolicy);               //object to add items back to

    if (FAILED(hres))
    {
        delete pPolicy;
        pPolicy = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pPolicy;

    return NOERROR;
}

//PICSRules URLpatterns can be presented to ParseByURL as either a single
//pattern, or a parenthesized list of multiple patterns. i.e.
//
//  Policy (RejectByURL "http://*@*.badsite.com:*/*" )
//  Policy (AcceptByURL (
//              "http://*@www.goodsite.com:*/*"
//              "ftp://*@www.goodsite.com:*/*" ) )
//
//The general form of an URLpattern is:
//
// internet pattern         -   internetscheme://user@hostoraddr:port/pathmatch
// other pattern            -   otherscheme:nonquotedcharacters
//
// in all cases, an ommitted section only matches to a URL if that section
// was omitted in the URL being navigated to.
//
// the wild card character '*' may be used to match any pattern as specified
// on a per section basis below.  To encode the actual character '*' the escape
// sequence '%*' is recognized.
//
// recognized internet schemes are:
//      ftp, http, gopher, nntp, irc, prospero, telnet, and *
//
// the user section consists of '*' nonquotedcharacters '*', in other words, an
// alphanumeric user name with optional wild card sections before and after the
// name.  A single * matches all names.
//
// the hostoraddr section can be in one of two forms, either:
//      '*' hostname, or ipnum.ipnum.ipnum.ipnum!bitlength
// hostname must be a substring of a fully qualified domain name
// bitlength is an integer between 0 and 32 inclusive, and
// ipnum is an integer between 0 and 255 inclusive.
// the bitlength parameter masks out the last n bits of the 32 bit ip address
// specified (i.e. treats them as a wild card)
//
// the port section can have one of four forms:
//      *
//      *-portnum
//      portnum-*
//      portnum-portnum
//
// a single * matches against all port numbers, *-portnum matches all ports
// lessthan or equal to portnum, portnum-* matches all aports greaterthan or
// equal to portnum, and portnum-portnum matches all ports between the two
// portnums, inclusive.
//
// the pathmatch section has the form:
//      '*' nonquotedchars '*'
// i.e. *foo* would match any pathname containing the word foo.  A single *
// matches all pathnames.
HRESULT PICSRulesParseByURL(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    PICSRulesByURLExpression    *pPRByURLExpression;
    PICSRulesByURL              *pPRByURL;
    HRESULT                     hRes;
    LPSTR                       lpszCurrent;

    pPRByURL=new PICSRulesByURL;

    //first, we need to find out if we have a list of URLpatterns or a single
    //URLpattern

    if(**ppszIn=='(') //we have a list of patterns
    {
        lpszCurrent=pParser->FindNonWhite(*ppszIn+1);
        
        while(*lpszCurrent!=')')
        {
            LPSTR lpszSubString;

            if(*lpszCurrent=='\0')
            {
                delete pPRByURL;
                pPRByURL = NULL;

                return(E_INVALIDARG);
            }

            hRes=PICSRulesParseString(&lpszCurrent,ppOut,pParser); //get the string

            if(FAILED(hRes))
            {
                //we couldn't get the string, so lets fail
                delete pPRByURL;
                pPRByURL = NULL;

                return(hRes);
            }

            lpszSubString=(char *) *ppOut;

            //we've got it, so lets instantiate the classes to fill out;

            pPRByURLExpression=new PICSRulesByURLExpression;

            hRes=pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression) ? S_OK : E_OUTOFMEMORY;
        
            if(FAILED(hRes))
            {
                delete lpszSubString;
                lpszSubString = NULL;
                delete pPRByURLExpression;
                pPRByURLExpression = NULL;
                delete pPRByURL;
                pPRByURL = NULL;

                return(hRes);
            }

            hRes=PICSRulesParseSingleByURL(lpszSubString,pPRByURLExpression,pParser);
        
            if(FAILED(hRes))
            {
                delete lpszSubString;
                lpszSubString = NULL;
                delete pPRByURL; //deleting the array deletes the embeeded expression
                pPRByURL = NULL;

                return(hRes);
            }

            delete lpszSubString;
            lpszSubString = NULL;
        }

        if(*lpszCurrent==')')
        {
            *ppszIn=pParser->FindNonWhite(lpszCurrent+1);
        }
    }
    else //we have a single pattern
    {
        hRes=PICSRulesParseString(ppszIn,ppOut,pParser); //get the string

        if(FAILED(hRes))
        {
            //we couldn't get the string, so lets fail
            delete pPRByURL;
            pPRByURL = NULL;

            return(hRes);
        }

        lpszCurrent=(char *) *ppOut;

        //we've got it, so lets instantiate the classes to fill out;

        pPRByURLExpression=new PICSRulesByURLExpression;

        hRes=pPRByURL->m_arrpPRByURL.Append(pPRByURLExpression) ? S_OK : E_OUTOFMEMORY;
        
        if(FAILED(hRes))
        {
            delete lpszCurrent;
            lpszCurrent = NULL;
            delete pPRByURLExpression;
            pPRByURLExpression = NULL;
            delete pPRByURL;
            pPRByURL = NULL;

            return(hRes);
        }

        hRes=PICSRulesParseSingleByURL(lpszCurrent,pPRByURLExpression,pParser);
    
        if(FAILED(hRes))
        {
            delete lpszCurrent;
            lpszCurrent = NULL;
            delete pPRByURL; //deleting the array deletes the embeeded expression
            pPRByURL = NULL;

            return(hRes);
        }

        delete lpszCurrent;
        lpszCurrent= NULL;
    }

    *ppOut=(void *) pPRByURL;

    return(NOERROR);
}

HRESULT PICSRulesParseSingleByURL(LPSTR lpszByURL, PICSRulesByURLExpression *pPRByURLExpression, PICSRulesFileParser *pParser)
{
    LPSTR lpszMarker;

    lpszMarker=strchrf(lpszByURL,':'); //find the marker '://' for an internet
                                       //pattern or ':' for a non-internet pattern

    if(lpszMarker==NULL) //no marker, i.e. our string is invalid
    {
        return(E_INVALIDARG);
    }

    //check the scheme for a wild card
    if(*lpszByURL=='*')
    {
        if((lpszByURL+1)!=lpszMarker) //we have a non-internet scheme
        {
            pPRByURLExpression->m_fInternetPattern=FALSE;

            *lpszMarker='\0';

            pPRByURLExpression->m_etstrScheme.Set(lpszByURL);

            lpszByURL=lpszMarker+1;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);

            return(S_OK);
        }

        //no need to set a NonWild flag, just move
        //on to the user name
        pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;
    }
    else
    {
        *lpszMarker='\0';

        //check for an internet pattern

        if((lstrcmpi(lpszByURL,szPICSRulesFTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesHTTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesGOPHER)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesNNTP)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesIRC)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesPROSPERO)!=0)&&
           (lstrcmpi(lpszByURL,szPICSRulesTELNET)!=0)) //we've got a non-internet pattern
        {
            pPRByURLExpression->m_fInternetPattern=FALSE;
            pPRByURLExpression->m_bNonWild=BYURL_SCHEME|BYURL_PATH;
            pPRByURLExpression->m_bSpecified=BYURL_SCHEME|BYURL_PATH;
            pPRByURLExpression->m_etstrScheme.Set(lpszByURL);

            lpszByURL=lpszMarker+1;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);

            return(S_OK);
        }

        pPRByURLExpression->m_bNonWild|=BYURL_SCHEME;
        pPRByURLExpression->m_bSpecified|=BYURL_SCHEME;
        pPRByURLExpression->m_etstrScheme.Set(lpszByURL);   
    }

    if((*(lpszMarker+1)=='/')&&(*(lpszMarker+2)=='/'))
    {
        pPRByURLExpression->m_fInternetPattern=TRUE;
        lpszByURL=lpszMarker+3;
    }
    else
    {
        return(E_INVALIDARG);
    }

    //we've got an internet pattern, and lpszURL now points
    //to the user field

    lpszMarker=strchrf(lpszByURL,'@'); //find the marker between user and host
    
    if(lpszMarker!=NULL) //a user name was specified
    {
        pPRByURLExpression->m_bSpecified|=BYURL_USER;

        //check for a wild card
        if(!((*lpszByURL=='*')&&((lpszByURL+1)==lpszMarker)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_USER;
            
            *lpszMarker='\0';

            pPRByURLExpression->m_etstrUser.Set(lpszByURL);
        }

        lpszByURL=lpszMarker+1;
    }

    //lpszByURL now points to host

    lpszMarker=strchrf(lpszByURL,':');

    if(lpszMarker==NULL) //the port was omitted
    {
        lpszMarker=strchrf(lpszByURL,'/');

        if(lpszMarker!=NULL) //there is a pathmatch
        {
            pPRByURLExpression->m_bSpecified|=BYURL_PATH;       
        }
    }
    else //we have a host and port
    {
        pPRByURLExpression->m_bSpecified|=BYURL_PORT;
    }
    
    pPRByURLExpression->m_bSpecified|=BYURL_HOST;

    if(lpszMarker!=NULL)
    {
        *lpszMarker='\0';
    }

    if(lstrcmp(lpszByURL,"*")!=0)
    {
        pPRByURLExpression->m_bNonWild|=BYURL_HOST;
    }

    pPRByURLExpression->m_etstrHost.Set(lpszByURL);

    if(lpszMarker==NULL)
    {
        return(S_OK);
    }

    lpszByURL=lpszMarker+1;

    if(pPRByURLExpression->m_bSpecified&BYURL_PORT)
    {
        lpszMarker=strchrf(lpszByURL,'/');

        if(lpszMarker!=NULL) //there is a pathmatch
        {
            pPRByURLExpression->m_bSpecified|=BYURL_PATH;       
            *lpszMarker='\0';   
        }

        if(!((*lpszByURL=='*')&&(lpszByURL+1==lpszMarker)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_PORT;

            pPRByURLExpression->m_etstrPort.Set(lpszByURL);
        }

        if(pPRByURLExpression->m_bSpecified&BYURL_PATH)
        {
            lpszByURL=lpszMarker+1;
        }
    }

    if(pPRByURLExpression->m_bSpecified&BYURL_PATH)
    {
        if(!((*lpszByURL=='*')&&(*(lpszByURL+1)==NULL)))
        {
            pPRByURLExpression->m_bNonWild|=BYURL_PATH;

            pPRByURLExpression->m_etstrPath.Set(lpszByURL);
        }
    }

    return(S_OK);
}

//PICSRules PolicyExpressions have 6 possible expressions:
//
// simple-expression        -   ( Service.Category [Operator] [Constant] )
// or-expression            -   ( PolicyExpression or PolicyExpression )
// and-expression           -   ( PolicyExpression and PolicyExpression )
// service & category       -   ( Service.Category )
// service only             -   ( Service )
// degenerate-expression    -   "otherwise"
//
// thus, for example, embedded expressions can take the form:
//
// "((Cool.Coolness < 3) or (Cool.Graphics < 3))"
// 
// or
//
// "(((Cool.Coolness < 3) or (Cool.Graphics < 3)) and (Cool.Fun < 2))"
//
// ad infinitum
//
// thus, existing pics labels can be encoded as:
//
// "((((RSACi.s <= 0) and (RSACi.v <= 0)) and (RSACi.n <= 0)) and RSACi.l <=0)"
//
// allowable operators are: '<', '<=', '=', '>=', '>'
//
// the service only expression evaluates to TRUE iff a label from that
// service is found.
//
// the service & category expression evaluates to TRUE iff a label from
// that service is found, and it contains at least one value for the
// indicated category.
//
// the degenerate-expression always evaluates to TRUE
HRESULT PICSRulesParsePolicyExpression(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    PICSRulesPolicyExpression   *pPRPolicyExpression;
    HRESULT                     hRes;
    LPSTR                       lpszPolicyExpression,lpszCurrent;

    //first lets get the string
    hRes=PICSRulesParseString(ppszIn,ppOut,pParser);

    if(FAILED(hRes))
    {
        //we couldn't get the string, so lets fail
        return(hRes);
    }
    lpszPolicyExpression=(char *) *ppOut;

    //we've got it, so lets instantiate a PICSRulesPolicyExpression to fill out
    pPRPolicyExpression=new PICSRulesPolicyExpression;

    if(pPRPolicyExpression==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_RESULT; //set as the topmost node
                                                                 //of the binary tree

    if(lstrcmpi(lpszPolicyExpression,szPICSRulesDegenerateExpression)==0)
    {
        //we have a degenerate expression, so delete lpszPolicyExpresion

        delete lpszPolicyExpression;
        lpszPolicyExpression = NULL;

        pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_DEGENERATE;

        *ppOut=(LPVOID) pPRPolicyExpression;

        return(NOERROR);
    }

    //make sure we have a parenthesized object
    if(*lpszPolicyExpression!='(')
    {
        delete lpszPolicyExpression;
        lpszPolicyExpression = NULL;
        delete pPRPolicyExpression;
        pPRPolicyExpression= NULL;
        
        return(E_INVALIDARG);
    }
    
    lpszCurrent=NonWhite(lpszPolicyExpression+1);

    //check for an or-expression or an and-expression
    if(*lpszCurrent=='(')
    {
        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpression,pParser);

        if(FAILED(hRes))
        {
            delete lpszPolicyExpression;
            lpszPolicyExpression = NULL;
            delete pPRPolicyExpression;
            pPRPolicyExpression = NULL;
            
            return(hRes);
        }
        else
        {
            if((pPRPolicyExpression->m_pPRPolicyExpressionLeft)!=NULL)
            {
                BOOL fFlag;
                
                fFlag=pPRPolicyExpression->m_pPRPolicyExpressionLeft->m_prYesNoUseEmbedded.GetYesNo();

                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }
        }
    }
    else //we've got a simple-expression
    {
        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpression,pParser);

        if(FAILED(hRes))
        {
            delete lpszPolicyExpression;
            lpszPolicyExpression = NULL;
            delete pPRPolicyExpression;
            pPRPolicyExpression= NULL;

            return(hRes);
        }
    }

    delete lpszPolicyExpression;
    lpszPolicyExpression= NULL;

    *ppOut=(void *) pPRPolicyExpression;

    return(NOERROR);
}

//Our PolicyExpression is either an or-expression or an and-expression
//so pPRPolicyExpression need to have another PICSRulesPolicyExpression
//embedded in it, with all the details filled out.
HRESULT PICSRulesParseSubPolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser)
{
    HRESULT hRes;
    PICSRulesPolicyExpression   * pPRPolicyExpressionEmbeddedLeft,
                                * pPRPolicyExpressionEmbeddedRight;
    LPSTR                       lpszNextPolicyExpression,
                                lpszOrAnd,lpszOrAndEnd;
    int                         iStringLen;
    BOOL                        fFlag;

    lpszCurrent=NonWhite(lpszCurrent+1);

    //check for nested or-expressions and and-expressions
    if(*lpszCurrent=='(')
    {
        pPRPolicyExpressionEmbeddedLeft=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedLeft==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        pPRPolicyExpressionEmbeddedLeft->m_PROPolicyOperator=PR_OPERATOR_RESULT;

        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedLeft,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedLeft;
            pPRPolicyExpressionEmbeddedLeft = NULL;

            return(hRes);
        }

        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRPolicyExpressionEmbeddedLeft;
        
        fFlag=pPRPolicyExpressionEmbeddedLeft->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }
    else //only one level deep
    {
        pPRPolicyExpressionEmbeddedLeft=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedLeft==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedLeft,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedLeft;
            pPRPolicyExpressionEmbeddedLeft= NULL;

            return(hRes);
        }

        pPRPolicyExpression->m_pPRPolicyExpressionLeft=pPRPolicyExpressionEmbeddedLeft;

        fFlag=pPRPolicyExpressionEmbeddedLeft->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);

        lpszCurrent=strchrf(lpszCurrent,')');
        lpszCurrent=NonWhite(lpszCurrent+1);
    }

    lpszNextPolicyExpression=strchrf(lpszCurrent,'(');
    
    if(lpszNextPolicyExpression==NULL) //invalid policy expression
    {
        return(E_INVALIDARG);
    }

    lpszOrAndEnd=White(lpszCurrent);

    if(lpszOrAndEnd>lpszNextPolicyExpression) //no white space
    {
        lpszOrAndEnd=lpszNextPolicyExpression;
    }

    iStringLen=(int) (lpszOrAndEnd-lpszCurrent);

    lpszOrAnd=new char[iStringLen+1];

    if(lpszOrAnd==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    memcpyf(lpszOrAnd,lpszCurrent,iStringLen);
    lpszOrAnd[iStringLen]='\0';

    if(lstrcmpi(lpszOrAnd,szPICSRulesAnd)==0)
    {
        pPRPolicyExpression->m_PRPEPolicyEmbedded=PR_POLICYEMBEDDED_AND;
    }
    else if(lstrcmpi(lpszOrAnd,szPICSRulesOr)==0)
    {
        pPRPolicyExpression->m_PRPEPolicyEmbedded=PR_POLICYEMBEDDED_OR;
    }
    else
    {
        delete lpszOrAnd;
        lpszOrAnd = NULL;

        return(E_INVALIDARG);
    }

    delete lpszOrAnd;
    lpszOrAnd= NULL;

    lpszCurrent=NonWhite(lpszOrAndEnd+1);

    if(lpszCurrent!=lpszNextPolicyExpression)
    {
        return(E_INVALIDARG);
    }

    lpszCurrent=NonWhite(lpszCurrent+1);

    //do we have more embedded objects, or another simple-expression?
    if(*lpszCurrent=='(') //more embedded
    {
        pPRPolicyExpressionEmbeddedRight=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedRight==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        pPRPolicyExpressionEmbeddedRight->m_PROPolicyOperator=PR_OPERATOR_RESULT;
        
        hRes=PICSRulesParseSubPolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedRight,pParser);

        if(FAILED(hRes))
        {
            return(hRes);
        }

        if(*lpszCurrent!=')')
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight= NULL;

            return(E_INVALIDARG);
        }

        lpszCurrent=NonWhite(lpszCurrent+1);

        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRPolicyExpressionEmbeddedRight;

        fFlag=pPRPolicyExpressionEmbeddedRight->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }
    else //simple expression
    {
        pPRPolicyExpressionEmbeddedRight=new PICSRulesPolicyExpression;

        if(pPRPolicyExpressionEmbeddedRight==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        hRes=PICSRulesParseSimplePolicyExpression(lpszCurrent,pPRPolicyExpressionEmbeddedRight,pParser);

        if(FAILED(hRes))
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight = NULL;

            return(hRes);
        }

        lpszCurrent=strchrf(lpszCurrent,')');
        lpszCurrent=NonWhite(lpszCurrent+1);

        if(*lpszCurrent!=')')
        {
            delete pPRPolicyExpressionEmbeddedRight;
            pPRPolicyExpressionEmbeddedRight= NULL;

            return(E_INVALIDARG);
        }

        lpszCurrent=NonWhite(lpszCurrent+1);

        pPRPolicyExpression->m_pPRPolicyExpressionRight=pPRPolicyExpressionEmbeddedRight;

        fFlag=pPRPolicyExpressionEmbeddedRight->m_prYesNoUseEmbedded.GetYesNo();

        pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
    }

    return(S_OK);
}

HRESULT PICSRulesParseSimplePolicyExpression(LPSTR& lpszCurrent,PICSRulesPolicyExpression *pPRPolicyExpression,PICSRulesFileParser *pParser)
{
    LPSTR                lpszEnd,lpszDot;
    PICSRulesServiceInfo *pPRServiceInfo=NULL;
    
    lpszEnd=strchrf(lpszCurrent,')');

    if(lpszEnd==NULL) //we don't have a valid expression
    {
        return(E_INVALIDARG);
    }

    lpszDot=strchrf(lpszCurrent,'.');

    if(lpszDot==NULL) //we have a service only expression
    {
        LPSTR   lpszService,lpszServiceEnd,lpszFullService;
        int     iStringLen;

        lpszServiceEnd=White(lpszCurrent);
        
        if(lpszServiceEnd>lpszEnd) //there isn't any white space between
                                   //the service name and the closing
                                   //parenthesis
        {
            lpszServiceEnd=lpszEnd;
        }

        iStringLen=(int)(lpszServiceEnd-lpszCurrent);

        lpszService=new char[iStringLen+1];

        if(lpszService==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszService,lpszCurrent,iStringLen);
        lpszService[iStringLen]='\0';

        lpszFullService=new char[INTERNET_MAX_URL_LENGTH+1];

        if(IsServiceDefined(lpszService,lpszFullService,&pPRServiceInfo)==FALSE)
        {
            delete lpszService;
            lpszService = NULL;

            delete lpszFullService;
            lpszFullService = NULL;
            
            return(PICSRULES_E_SERVICEUNDEFINED);
        }

        //we have a valid service only expression
        if(pPRServiceInfo!=NULL)
        {
            BOOL fFlag;

            fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
            pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
        }

        pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
        pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
        pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_SERVICEONLY;
    }
    else //could be service and category or a full simple-expression
    {
        LPSTR   lpszService,lpszCategory,lpszCategoryEnd,lpszOperator,lpszFullService;
        int     iStringLen;

        lpszCategoryEnd=White(lpszCurrent);
        
        if(lpszCategoryEnd>lpszEnd) //there isn't any white space between
                                    //the category name and the closing
                                    //parenthesis
        { 
            lpszCategoryEnd=lpszEnd;
        }

        lpszOperator=strchrf(lpszCurrent,'<');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        lpszOperator=strchrf(lpszCurrent,'>');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        lpszOperator=strchrf(lpszCurrent,'=');

        if(lpszOperator!=NULL)
        {
            if(lpszOperator<lpszCategoryEnd) //there was an operator with
                                             //no white space
            {
                lpszCategoryEnd=lpszOperator;
            }
        }

        iStringLen=(int)(lpszDot-lpszCurrent);

        lpszService=new char[iStringLen+1];

        if(lpszService==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszService,lpszCurrent,iStringLen);
        lpszService[iStringLen]='\0';

        lpszFullService=new char[INTERNET_MAX_URL_LENGTH+1];

        if(IsServiceDefined(lpszService,lpszFullService,&pPRServiceInfo)==FALSE)
        {
            delete lpszService;
            lpszService = NULL;

            delete lpszFullService;
            lpszFullService= NULL;
            
            return(PICSRULES_E_SERVICEUNDEFINED);
        }

        iStringLen=(int)(lpszCategoryEnd-lpszDot-1);
        
        lpszCategory=new char[iStringLen+1];

        if(lpszCategory==NULL)
        {
            return(E_OUTOFMEMORY);
        }

        memcpyf(lpszCategory,lpszDot+1,iStringLen);
        lpszCategory[iStringLen]='\0';

        lpszCurrent=NonWhite(lpszCategoryEnd);

        if(*lpszCurrent==')') //we have a valid service and category expression
        {
            if(pPRServiceInfo!=NULL)
            {
                BOOL fFlag;

                fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }

            pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
            pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
            pPRPolicyExpression->m_etstrCategoryName.SetTo(lpszCategory);
            pPRPolicyExpression->m_PROPolicyOperator=PR_OPERATOR_SERVICEANDCATEGORY;
        }
        else //we have a full simple-expression
        {
            //lpszCurrent should be pointing to an operator
            enum PICSRulesOperators PROPolicyOperator;
            int                     iValue;

            switch(*lpszCurrent)
            {
                case '>':
                {
                    if(*(lpszCurrent+1)=='=')
                    {
                        PROPolicyOperator=PR_OPERATOR_GREATEROREQUAL;
                        lpszCurrent=NonWhite(lpszCurrent+2);
                    }
                    else
                    {
                        PROPolicyOperator=PR_OPERATOR_GREATER;
                        lpszCurrent=NonWhite(lpszCurrent+1);
                    }

                    break;
                }
                case '<':
                {
                    if(*(lpszCurrent+1)=='=')
                    {
                        PROPolicyOperator=PR_OPERATOR_LESSOREQUAL;
                        lpszCurrent=NonWhite(lpszCurrent+2);
                    }
                    else
                    {
                        PROPolicyOperator=PR_OPERATOR_LESS;
                        lpszCurrent=NonWhite(lpszCurrent+1);
                    }

                    break;
                }
                case '=':
                {
                    PROPolicyOperator=PR_OPERATOR_EQUAL;
                    lpszCurrent=NonWhite(lpszCurrent+1);

                    break;
                }
                default: //we didn't get a valid operator
                {
                    delete lpszService;
                    lpszService = NULL;

                    delete lpszCategory;
                    lpszCategory = NULL;
                    
                    return(E_INVALIDARG);
                }
            }

            //lpszCurrent now points at the Value
            if(FAILED(ParseNumber(&lpszCurrent,&iValue,FALSE)))
            {
                delete lpszService;
                lpszService = NULL;

                delete lpszCategory;
                lpszCategory = NULL;

                return(E_INVALIDARG);
            }

            if(*lpszCurrent!=')') //we should be done, so the argument is invalid
            {
                delete lpszService;
                lpszService = NULL;

                delete lpszCategory;
                lpszCategory = NULL;

                return(E_INVALIDARG);           
            }

            //we now have a complete simple-expression
            if(pPRServiceInfo!=NULL)
            {
                BOOL fFlag;

                fFlag=pPRServiceInfo->m_prYesNoUseEmbedded.GetYesNo();
                pPRPolicyExpression->m_prYesNoUseEmbedded.Set(&fFlag);
            }

            pPRPolicyExpression->m_etstrServiceName.SetTo(lpszService);
            pPRPolicyExpression->m_etstrFullServiceName.SetTo(lpszFullService);
            pPRPolicyExpression->m_etstrCategoryName.SetTo(lpszCategory);
            pPRPolicyExpression->m_etnValue.Set(iValue);
            pPRPolicyExpression->m_PROPolicyOperator=PROPolicyOperator;
        }
    }

    return(S_OK);
}

//Determines if the service name in lpszService has been read in a
//ServiceInfo section of the PICSRules file
BOOL IsServiceDefined(LPSTR lpszService,LPSTR lpszFullService,PICSRulesServiceInfo **ppServiceInfo)
{
    array<PICSRulesServiceInfo*>    *arrpPRServiceInfo;
    LPSTR                           lpszShortName;
    int                             iNumServices,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPRServiceInfo=(array<PICSRulesServiceInfo*> *) &(g_pPRRS->m_arrpPRServiceInfo);

    iNumServices=arrpPRServiceInfo->Length();

    for(iCounter=0;iCounter<iNumServices;iCounter++)
    {
        PICSRulesServiceInfo * pPRServiceInfo;
        
        pPRServiceInfo=(*arrpPRServiceInfo)[iCounter];

        lpszShortName=pPRServiceInfo->m_etstrShortName.Get();

        if(lstrcmp(lpszService,lpszShortName)==0)
        {
            fDefined=TRUE;

            if(ppServiceInfo!=NULL)
            {
                *ppServiceInfo=pPRServiceInfo;
            }

            lstrcpy(lpszFullService,pPRServiceInfo->m_prURLName.Get());

            break;
        }
    }

    return(fDefined);
}

//Determines if the extension name in lpszExtension has been read in a
//OptExtension of the PICSRules file
BOOL IsOptExtensionDefined(LPSTR lpszExtension)
{
    array<PICSRulesOptExtension*>   *arrpPROptExtension;
    LPSTR                           lpszShortName;
    int                             iNumExtensions,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPROptExtension=(array<PICSRulesOptExtension*> *) &(g_pPRRS->m_arrpPROptExtension);

    iNumExtensions=arrpPROptExtension->Length();

    for(iCounter=0;iCounter<iNumExtensions;iCounter++)
    {
        PICSRulesOptExtension * pPROptExtension;
        
        pPROptExtension=(*arrpPROptExtension)[iCounter];

        lpszShortName=pPROptExtension->m_etstrShortName.Get();

        if(lstrcmp(lpszExtension,lpszShortName)==0)
        {
            fDefined=TRUE;
            
            break;
        }
    }

    return(fDefined);
}

//Deteremines is the extension name in lpszExtension has been read in a
//ReqExtension of the PICSRules file
BOOL IsReqExtensionDefined(LPSTR lpszExtension)
{
    array<PICSRulesReqExtension*>   *arrpPRReqExtension;
    LPSTR                           lpszShortName;
    int                             iNumExtensions,iCounter;
    BOOL                            fDefined=FALSE;

    if(g_pPRRS==NULL)
    {
        return(FALSE);
    }

    arrpPRReqExtension=(array<PICSRulesReqExtension*> *) &(g_pPRRS->m_arrpPRReqExtension);

    iNumExtensions=arrpPRReqExtension->Length();

    for(iCounter=0;iCounter<iNumExtensions;iCounter++)
    {
        PICSRulesReqExtension * pPRReqExtension;
        
        pPRReqExtension=(*arrpPRReqExtension)[iCounter];

        lpszShortName=pPRReqExtension->m_etstrShortName.Get();

        if(lstrcmp(lpszExtension,lpszShortName)==0)
        {
            fDefined=TRUE;
            
            break;
        }
    }

    return(fDefined);
}

PICSRulesAllowableOption aaoPICSRulesName[] = {
    { PROID_RULENAME, 0 },
    { PROID_DESCRIPTION, 0 },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesName=sizeof(aaoPICSRulesName)/sizeof(aaoPICSRulesName[0]);

HRESULT PICSRulesParseName(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesName];

    ::memcpyf(aao,::aaoPICSRulesName,sizeof(aao));

    PICSRulesName *pName=new PICSRulesName;
    
    if(pName==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pName);                 //object to add items back to

    if (FAILED(hres))
    {
        delete pName;
        pName = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pName;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesSource[] = {
    { PROID_SOURCEURL, 0 },
    { PROID_CREATIONTOOL, 0 },
    { PROID_AUTHOR, 0 },
    { PROID_LASTMODIFIED, 0 },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesSource=sizeof(aaoPICSRulesSource)/sizeof(aaoPICSRulesSource[0]);

HRESULT PICSRulesParseSource(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesSource];

    ::memcpyf(aao,::aaoPICSRulesSource,sizeof(aao));

    PICSRulesSource *pSource=new PICSRulesSource;
    
    if(pSource==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pSource);               //object to add items back to

    if (FAILED(hres))
    {
        delete pSource;
        pSource = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pSource;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesServiceInfo[] = {
    { PROID_SINAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_BUREAUURL, 0 },
    { PROID_USEEMBEDDED, AO_SINGLE },
    { PROID_RATFILE, AO_SINGLE },
    { PROID_BUREAUUNAVAILABLE, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesServiceInfo=sizeof(aaoPICSRulesServiceInfo)/sizeof(aaoPICSRulesServiceInfo[0]);

HRESULT PICSRulesParseServiceInfo(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesServiceInfo];

    ::memcpyf(aao,::aaoPICSRulesServiceInfo,sizeof(aao));

    PICSRulesServiceInfo *pServiceInfo=new PICSRulesServiceInfo;
    
    if(pServiceInfo==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pServiceInfo);          //object to add items back to

    if (FAILED(hres))
    {
        delete pServiceInfo;
        pServiceInfo = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pServiceInfo;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesOptExtension[] = {
    { PROID_EXTENSIONNAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesOptExtension=sizeof(aaoPICSRulesOptExtension)/sizeof(aaoPICSRulesOptExtension[0]);

HRESULT PICSRulesParseOptExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesOptExtension];

    ::memcpyf(aao,::aaoPICSRulesOptExtension,sizeof(aao));

    PICSRulesOptExtension *pOptExtension=new PICSRulesOptExtension;
    
    if(pOptExtension==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pOptExtension);         //object to add items back to

    if (FAILED(hres))
    {
        delete pOptExtension;
        pOptExtension = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pOptExtension;

    return NOERROR;
}

PICSRulesAllowableOption aaoPICSRulesReqExtension[] = {
    { PROID_EXTENSIONNAME, AO_SINGLE },
    { PROID_SHORTNAME, AO_SINGLE },
    { PROID_EXTENSION, 0 },
    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesReqExtension=sizeof(aaoPICSRulesReqExtension)/sizeof(aaoPICSRulesReqExtension[0]);

HRESULT PICSRulesParseReqExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    //We must make a copy of the allowable options array because the
    //parser will fiddle with the flags in the entries -- specifically,
    //setting AO_SEEN.  It wouldn't be thread-safe to do this to a
    //static array.

    PICSRulesAllowableOption aao[caoPICSRulesReqExtension];

    ::memcpyf(aao,::aaoPICSRulesReqExtension,sizeof(aao));

    PICSRulesReqExtension *pReqExtension=new PICSRulesReqExtension;
    
    if(pReqExtension==NULL)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hres=pParser->ParseParenthesizedObject(
                            ppszIn,                 //var containing current ptr
                            aao,                    //what's legal in this object
                            pReqExtension);         //object to add items back to

    if (FAILED(hres))
    {
        delete pReqExtension;
        pReqExtension = NULL;
        return hres;
    }

    *ppOut=(LPVOID) pReqExtension;

    return NOERROR;
}

//Currently, we acknowledge no extensions.  If support for an extension
//needs to be added in the future, a PICSRulesParseExtensionName function
//should be added, similar to the other PICSRulesParseSection functions.
//This function should be called after confirming the extension string
//here.
//
//For now, we just eat the extensions
HRESULT PICSRulesParseExtension(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser)
{
    LPTSTR lpszExtension,lpszEnd;

    lpszEnd=strchrf(*ppszIn,'.');
    
    if(lpszEnd==NULL)
    {
        return(PICSRULES_E_UNKNOWNITEM);
    }

    *lpszEnd='\0';

    //*ppszIn now points to the extension name
    //if we ever implement support for extensions, we'll need to do a comparison
    //here.  After the comparison is completed, the following code will point
    //to the extension's method.

    *ppszIn=lpszEnd+1;

    lpszEnd=strchrf(*ppszIn,'(');
    
    if(lpszEnd==NULL)
    {
        return(PICSRULES_E_EXPECTEDLEFT);
    }

    lpszExtension=White(*ppszIn);

    if((lpszExtension!=NULL)&&(lpszExtension<lpszEnd))
    {
        *lpszExtension='\0';
    }
    else
    {
        *lpszEnd='\0';
    }

    lpszExtension=*ppszIn;

    //lpszExtension now points to the clause on the given extension name
    //if we ever implement support for extensions, we'll need to do a comparison
    //here.  Using both this comparison and the one above, a callback needs
    //to be implemented to support the extension, for now we'll just parse to
    //the closing parenthesis and eat the extension.

    *ppszIn=lpszEnd+1;

    int iOpenParenthesis=1;

    do
    {
        if(**ppszIn=='(')
        {
            iOpenParenthesis++;
        }
        else if (**ppszIn==')')
        {
            iOpenParenthesis--;

            if(iOpenParenthesis==0)
            {
                break;
            }
        }

        *ppszIn=pParser->FindNonWhite(*ppszIn+1);

    } while (**ppszIn!='\0');

    if(**ppszIn=='\0')
    {
        return(PICSRULES_E_EXPECTEDRIGHT);
    }
    else
    {
        *ppszIn=pParser->FindNonWhite(*ppszIn+1);
    }

    *ppOut=(LPVOID) NULL;

    return NOERROR;
}

//*******************************************************************
//*
//* Code for the PICSRulesRatingSystem class
//*
//*******************************************************************
PICSRulesRatingSystem::PICSRulesRatingSystem()
    : m_dwFlags(0),
      m_nErrLine(0)
{
    // nothing to do but construct members
}

PICSRulesRatingSystem::~PICSRulesRatingSystem()
{
    m_arrpPRPolicy.DeleteAll();
    m_arrpPRServiceInfo.DeleteAll();
    m_arrpPROptExtension.DeleteAll();
    m_arrpPRReqExtension.DeleteAll();
}

HRESULT PICSRulesRatingSystem::InitializeMyDefaults()
{
    return NOERROR;     //no defaults to initialize
}

//Allowable options from within PICSRulesRaginSystem's scope include only the
//first teer of aaoPICSRules[] defined in picsrule.h
PICSRulesAllowableOption aaoPICSRulesRatingSystem[] = {
    { PROID_PICSVERSION, 0 },
    
    { PROID_POLICY, AO_MANDATORY },
    { PROID_NAME, AO_SINGLE },
    { PROID_SOURCE, AO_SINGLE },
    { PROID_SERVICEINFO, 0 },
    { PROID_OPTEXTENSION, 0 },
    { PROID_REQEXTENSION, 0 },
    { PROID_EXTENSION, 0 },

    { PROID_INVALID, 0 }
};
const UINT caoPICSRulesRatingSystem=sizeof(aaoPICSRulesRatingSystem)/sizeof(aaoPICSRulesRatingSystem[0]);

//The following array is indexed by PICSRulesObjectID values.
//PICSRulesObjectHandler is defined in mslubase.h as:
//typedef HRESULT (*PICSRulesObjectHandler)(LPSTR *ppszIn, LPVOID *ppOut, PICSRulesFileParser *pParser);
struct {
    LPCSTR lpszToken;                       //token by which we identify it
    PICSRulesObjectHandler pHandler;        //function which parses the object's contents
} aPRObjectDescriptions[] = {
    { szNULL, NULL },
    { szPICSRulesVersion, PICSRulesParseVersion },
    { szPICSRulesPolicy, PICSRulesParsePolicy },
    { szPICSRulesExplanation, PICSRulesParseString },
    { szPICSRulesRejectByURL, PICSRulesParseByURL },
    { szPICSRulesAcceptByURL, PICSRulesParseByURL },
    { szPICSRulesRejectIf, PICSRulesParsePolicyExpression },
    { szPICSRulesAcceptIf, PICSRulesParsePolicyExpression },
    { szPICSRulesAcceptUnless, PICSRulesParsePolicyExpression },
    { szPICSRulesRejectUnless, PICSRulesParsePolicyExpression },
    { szPICSRulesName, PICSRulesParseName },
    { szPICSRulesRuleName, PICSRulesParseString },
    { szPICSRulesDescription, PICSRulesParseString },
    { szPICSRulesSource, PICSRulesParseSource },
    { szPICSRulesSourceURL, PICSRulesParseString },
    { szPICSRulesCreationTool, PICSRulesParseString },
    { szPICSRulesAuthor, PICSRulesParseString },
    { szPICSRulesLastModified, PICSRulesParseString },
    { szPICSRulesServiceInfo, PICSRulesParseServiceInfo },
    { szPICSRulesSIName, PICSRulesParseString },
    { szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesBureauURL, PICSRulesParseString },
    { szPICSRulesUseEmbedded, PICSRulesParseYesNo },
    { szPICSRulesRATFile, PICSRulesParseString },
    { szPICSRulesBureauUnavailable, PICSRulesParsePassFail },
    { szPICSRulesOptExtension, PICSRulesParseOptExtension },
    { szPICSRulesExtensionName, PICSRulesParseString },
  //{ szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesReqExtension, PICSRulesParseReqExtension },
  //{ szPICSRulesExtensionName, PICSRulesParseString },
  //{ szPICSRulesShortName, PICSRulesParseString },
    { szPICSRulesExtension, PICSRulesParseExtension },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString },
    { szPICSRulesOptionDefault, PICSRulesParseString }
};

HRESULT PICSRulesRatingSystem::Parse(LPCSTR pszFilename, LPSTR pIn)
{
    //This guy is small enough to just init directly on the stack
    PICSRulesAllowableOption aaoRoot[] = { { PROID_PICSVERSION, 0 }, { PROID_INVALID, 0 } };
    PICSRulesAllowableOption aao[caoPICSRulesRatingSystem];

    ::memcpyf(aao,::aaoPICSRulesRatingSystem,sizeof(aao));

    PICSRulesAllowableOption *pFound;

    PICSRulesFileParser parser;

    LPSTR lpszVersionDash=strchrf(pIn,'-');     //since this is the first
                                                //time through, we need to
                                                //prepare the PicsRule
                                                //token for the parser

    if(lpszVersionDash!=NULL)                   //check for no dash we'll
                                                //fail in ParseToOpening
                                                //if this is the case
    {
        *lpszVersionDash=' ';                   //set it up for the parser
    }

    HRESULT hres=parser.ParseToOpening(&pIn,aaoRoot,&pFound);

    if (FAILED(hres))
    {
        return hres;                            //some error early on
    }
    else                                        //we got the PicsRule tag
                                                //now we need to check
                                                //the version number
    {
        LPSTR   lpszDot=strchrf(pIn,'.');
        
        if(lpszDot!=NULL)                       //continue on and fail
                                                //in ParseParenthesizedObject
        {
            int iVersion;

            *lpszDot=' ';

            ParseNumber(&pIn,&iVersion,TRUE);
            m_etnPRVerMajor.Set(iVersion);

            pIn=parser.FindNonWhite(pIn);

            ParseNumber(&pIn,&iVersion,TRUE);
            m_etnPRVerMinor.Set(iVersion);

            pIn=parser.FindNonWhite(pIn);
        }
    }

    //we'll fail if the version is 1.0, or 2.0 or higher
    //versions 1.1 - 2.0 (not including 2.0) will pass

    int iVerNumber=m_etnPRVerMajor.Get();

    if(iVerNumber!=1)
    {
        hres=PICSRULES_E_VERSION;
        m_nErrLine=parser.m_nLine;

        return(hres);
    }
    else //check the minor version number
    {
        iVerNumber=m_etnPRVerMinor.Get();

        if(iVerNumber==0)
        {
            hres=PICSRULES_E_VERSION;
            m_nErrLine=parser.m_nLine;

            return(hres);
        }
    }

    hres=parser.ParseParenthesizedObject(
                        &pIn,                   //var containing current ptr
                        aao,                    //what's legal in this object
                        this);                  //object to add items back to

    if(SUCCEEDED(hres))
    {
        if(*pIn!=')') //check for a closing parenthesis
        {
            hres=PICSRULES_E_EXPECTEDRIGHT;
        }
        else
        {
            LPTSTR lpszEnd=NonWhite(pIn+1);

            if(*lpszEnd!='\0') // make sure we're at the end of the file
            {
                hres=PICSRULES_E_EXPECTEDEND;
            }
        }
    }

    if(FAILED(hres))
    {
        m_nErrLine=parser.m_nLine;
    }

    return hres;
}

HRESULT PICSRulesRatingSystem::AddItem(PICSRulesObjectID roid, LPVOID pData)
{
    HRESULT hres = S_OK;

    switch (roid)
    {
        case PROID_PICSVERSION:
        {
            //Takes a pointer to a PICSRULES_VERSION struct (defined in picsrule.h)
            PICSRULES_VERSION * PRVer;

            if(PRVer=((PICSRULES_VERSION *) pData))
            {
                m_etnPRVerMajor.Set(PRVer->iPICSRulesVerMajor);     
                m_etnPRVerMinor.Set(PRVer->iPICSRulesVerMinor);     
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_OPTEXTENSION:
        {
            PICSRulesOptExtension *pOptExtension;

            if(pOptExtension=((PICSRulesOptExtension *) pData))
            {
                hres=m_arrpPROptExtension.Append(pOptExtension) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pOptExtension;
                    pOptExtension = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_REQEXTENSION:
        {
            PICSRulesReqExtension *pReqExtension;

            if(pReqExtension=((PICSRulesReqExtension *) pData))
            {
                hres=m_arrpPRReqExtension.Append(pReqExtension) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pReqExtension;
                    pReqExtension= NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_POLICY:
        {
            PICSRulesPolicy *pPolicy;
                
            if(pPolicy=((PICSRulesPolicy *) pData))
            {
                hres=m_arrpPRPolicy.Append(pPolicy) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pPolicy;
                    pPolicy = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_NAME:
        {
            PICSRulesName *pName;
                
            if(pName=((PICSRulesName *) pData))
            {
                m_pPRName=pName;
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_SOURCE:
        {
            PICSRulesSource *pSource;
                
            if(pSource=((PICSRulesSource *) pData))
            {
                m_pPRSource=pSource;
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_SERVICEINFO:
        {
            PICSRulesServiceInfo *pServiceInfo;
                
            if(pServiceInfo=((PICSRulesServiceInfo *) pData))
            {
                hres=m_arrpPRServiceInfo.Append(pServiceInfo) ? S_OK : E_OUTOFMEMORY;
                
                if (FAILED(hres))
                {
                    delete pServiceInfo;
                    pServiceInfo = NULL;
                }
            }
            else
            {
                hres=E_INVALIDARG;
            }

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hres=E_UNEXPECTED;
            break;
        }
    }
    return hres;
}

void PICSRulesRatingSystem::ReportError(HRESULT hres)
{
    UINT    idMsg,idTemplate;
    WCHAR   szErrorMessage[MAX_PATH],szErrorTitle[MAX_PATH],
            szLoadStringTemp[MAX_PATH];
    //we may be reporting E_OUTOFMEMORY, so we'll keep our string memory
    //on the stack so that its gauranteed to be there

    if((hres==E_OUTOFMEMORY)||((hres>PICSRULES_E_BASE)&&(hres<=PICSRULES_E_BASE+0xffff)))
    {
        idTemplate=IDS_PICSRULES_SYNTAX_TEMPLATE;   //default is PICSRules content error
        switch(hres)
        {
            case E_OUTOFMEMORY:
            {
                idMsg=IDS_PICSRULES_MEMORY;
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                break;
            }
            case PICSRULES_E_EXPECTEDLEFT:
            {
                idMsg=IDS_PICSRULES_EXPECTEDLEFT;
                break;
            }
            case PICSRULES_E_EXPECTEDRIGHT:
            {
                idMsg=IDS_PICSRULES_EXPECTEDRIGHT;
                break;
            }
            case PICSRULES_E_EXPECTEDTOKEN:
            {
                idMsg=IDS_PICSRULES_EXPECTEDTOKEN;
                break;
            }
            case PICSRULES_E_EXPECTEDSTRING:
            {
                idMsg=IDS_PICSRULES_EXPECTEDSTRING;
                break;
            }
            case PICSRULES_E_EXPECTEDNUMBER:
            {
                idMsg=IDS_PICSRULES_EXPECTEDNUMBER;
                break;
            }
            case PICSRULES_E_EXPECTEDBOOL:
            {
                idMsg=IDS_PICSRULES_EXPECTEDBOOL;
                break;
            }
            case PICSRULES_E_DUPLICATEITEM:
            {
                idMsg=IDS_PICSRULES_DUPLICATEITEM;
                break;
            }
            case PICSRULES_E_MISSINGITEM:
            {
                idMsg=IDS_PICSRULES_MISSINGITEM;
                break;
            }
            case PICSRULES_E_UNKNOWNITEM:
            {
                idMsg=IDS_PICSRULES_UNKNOWNITEM;
                break;
            }
            case PICSRULES_E_UNKNOWNMANDATORY:
            {
                idMsg=IDS_PICSRULES_UNKNOWNMANDATORY;
                break;
            }
            case PICSRULES_E_SERVICEUNDEFINED:
            {
                idMsg=IDS_PICSRULES_SERVICEUNDEFINED;
                break;
            }
            case PICSRULES_E_EXPECTEDEND:
            {
                idMsg=IDS_PICSRULES_EXPECTEDEND;

                break;
            }
            case PICSRULES_E_REQEXTENSIONUSED:
            {
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                idMsg=IDS_PICSRULES_REQEXTENSIONUSED;

                break;
            }
            case PICSRULES_E_VERSION:
            {
                idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;
                idMsg=IDS_PICSRULES_BADVERSION;

                break;
            }
            default:
            {
                ASSERT(FALSE);  //there aren't any other PICSRULES_E_ errors
                idMsg=IDS_PICSRULES_UNKNOWNERROR;
                break;
            }
        }

        MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
        wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

        MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
        wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,m_nErrLine);

        lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
    }
    else
    {
        idTemplate=IDS_PICSRULES_GENERIC_TEMPLATE;

        if(HRESULT_FACILITY(hres)==FACILITY_WIN32)
        {
            switch(hres)
            {
                case E_OUTOFMEMORY:
                {
                    idMsg=IDS_PICSRULES_MEMORY;
                    break;
                }
                case E_INVALIDARG:
                {
                    idMsg=IDS_PICSRULES_INVALID;
                    break;
                }
                default:
                {
                    idMsg=IDS_PICSRULES_WINERROR;
                    break;
                }
            }
            
            MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

            MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
            
            if(idMsg==IDS_PICSRULES_WINERROR)
            {
                wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,HRESULT_CODE(hres));
            }
            else
            {
                wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,m_nErrLine);
            }

            lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
        }
        else
        {
            idMsg=IDS_PICSRULES_MISCERROR;

            MLLoadString(idTemplate,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorMessage,(LPTSTR) szLoadStringTemp,m_etstrFile.Get());

            MLLoadString(idMsg,(LPTSTR) szLoadStringTemp,MAX_PATH);
            wsprintf((LPTSTR) szErrorTitle,(LPTSTR) szLoadStringTemp,HRESULT_CODE(hres));

            lstrcat((LPTSTR) szErrorMessage,(LPTSTR) szErrorTitle);
        }
    }

    MLLoadString(IDS_ERROR,(LPTSTR) szErrorTitle,MAX_PATH);
    MessageBox(NULL,(LPCTSTR) szErrorMessage,(LPCTSTR) szErrorTitle,MB_OK|MB_ICONERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesByURL class
//*
//*******************************************************************

PICSRulesByURL::PICSRulesByURL()
{
    //nothing to do
}

PICSRulesByURL::~PICSRulesByURL()
{
    m_arrpPRByURL.DeleteAll();
}

PICSRulesEvaluation PICSRulesByURL::EvaluateRule(PICSRulesQuotedURL *pprurlComparisonURL)
{
    int                         iCounter;
    URL_COMPONENTS              URLComponents;
    FN_INTERNETCRACKURL         pfnInternetCrackUrl;
    INTERNET_SCHEME             INetScheme=INTERNET_SCHEME_DEFAULT;
    INTERNET_PORT               INetPort=INTERNET_INVALID_PORT_NUMBER;
    LPSTR                       lpszScheme,lpszHostName,lpszUserName,
                                lpszPassword,lpszUrlPath,lpszExtraInfo;
    BOOL                        fApplies=FALSE;

    lpszScheme=new char[INTERNET_MAX_SCHEME_LENGTH+1];
    lpszHostName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUserName=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszPassword=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszUrlPath=new char[INTERNET_MAX_PATH_LENGTH+1];
    lpszExtraInfo=new char[INTERNET_MAX_PATH_LENGTH+1];

    if(lpszScheme==NULL ||
       lpszHostName==NULL ||
       lpszUserName==NULL ||
       lpszPassword==NULL ||
       lpszUrlPath==NULL ||
       lpszExtraInfo==NULL)
    {
        if (lpszScheme)
        {
            delete [] lpszScheme;
            lpszScheme = NULL;
        }

        if (lpszHostName)
        {
            delete [] lpszHostName;
            lpszHostName = NULL;
        }

        if (lpszUserName)
        {
            delete [] lpszUserName;
            lpszUserName = NULL;
        }

        if (lpszPassword)
        {
            delete [] lpszPassword;
            lpszPassword = NULL;
        }

        if (lpszUrlPath)
        {
            delete [] lpszUrlPath;
            lpszUrlPath = NULL;
        }

        if (lpszExtraInfo)
        {
            delete [] lpszExtraInfo;
            lpszExtraInfo = NULL;
        }

        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    URLComponents.dwStructSize=sizeof(URL_COMPONENTS);
    URLComponents.lpszScheme=lpszScheme;
    URLComponents.dwSchemeLength=INTERNET_MAX_SCHEME_LENGTH;
    URLComponents.nScheme=INetScheme;
    URLComponents.lpszHostName=lpszHostName;
    URLComponents.dwHostNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.nPort=INetPort;
    URLComponents.lpszUserName=lpszUserName;
    URLComponents.dwUserNameLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszPassword=lpszPassword;
    URLComponents.dwPasswordLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszUrlPath=lpszUrlPath;
    URLComponents.dwUrlPathLength=INTERNET_MAX_PATH_LENGTH;
    URLComponents.lpszExtraInfo=lpszExtraInfo;
    URLComponents.dwExtraInfoLength=INTERNET_MAX_PATH_LENGTH;

    pfnInternetCrackUrl=(FN_INTERNETCRACKURL) GetProcAddress(g_hWININET,"InternetCrackUrlA");

    if(pfnInternetCrackUrl==NULL)
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    pfnInternetCrackUrl(pprurlComparisonURL->Get(),0,ICU_DECODE,&URLComponents);

    for(iCounter=0;iCounter<m_arrpPRByURL.Length();iCounter++)
    {
        PICSRulesByURLExpression * pPRByURLExpression;

        pPRByURLExpression=m_arrpPRByURL[iCounter];

        //schemes must be specified as per the spec, so there is no need to check
        //the m_bSpecified flag against BYURL_SCHEME

        //if the scheme is non-wild then we match against exact strings only, the
        //match is case insensitive as per the spec
        if(pPRByURLExpression->m_bNonWild&BYURL_SCHEME)
        {
            if(lstrcmp(lpszScheme,pPRByURLExpression->m_etstrScheme.Get())!=0)
            {
                continue;
            }
        }

        //if the user name is omitted we only match if the url navigated to also
        //had the user name omitted
        if(!(pPRByURLExpression->m_bSpecified&BYURL_USER))
        {
            if(*lpszUserName!=NULL)
            {
                continue;
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_USER)
        {
            int     iLength;
            char    * lpszCurrent,lpszCompare[INTERNET_MAX_URL_LENGTH+1],
                    lpszCopy[INTERNET_MAX_URL_LENGTH+1];
            BOOL    fFrontWild=0,fBackWild=0,fFrontEscaped=0,fBackEscaped=0;

            //if the user was specified we match a '*' at the beginning as wild, a '*'
            //at the end as wild, and '%*' matches aginst the character '*', this
            //comparison is case sensitive

            lstrcpy(lpszCompare,pPRByURLExpression->m_etstrUser.Get());
            
            iLength=lstrlen(lpszCompare);

            if(lpszCompare[0]=='*')
            {
                fFrontWild=1;
            }
            
            if(lpszCompare[iLength-1]=='*')
            {
                fBackWild=1;
                
                lpszCompare[iLength-1]='\0';
            }

            if((lpszCompare[0]=='%')&&(lpszCompare[1]=='*'))
            {
                fFrontEscaped=1;
            }

            if((lpszCompare[iLength-2]=='%')&&fBackWild)
            {
                fBackWild=0;
                fBackEscaped=1;

                lpszCompare[iLength-2]='*';
            }

            lpszCurrent=lpszCompare+fFrontWild+fFrontEscaped;

            lstrcpy(lpszCopy,lpszCurrent);

            if(fFrontWild==1)
            {
                lpszCurrent=strstrf(lpszUserName,lpszCopy);
                
                if(lpszCurrent!=NULL)
                {
                    if(fBackWild==0)
                    {
                        if(lstrcmp(lpszCurrent,lpszUserName)!=0)
                        {
                            continue;
                        }
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                if(fBackWild==1)
                {
                    lpszUserName[lstrlen(lpszCopy)]='\0';
                }

                if(lstrcmp(lpszUserName,lpszCopy)!=0)
                {
                    continue;
                }
            }
        }

        //the host (or ipwild) must always be specified, so there is no need to
        //check against m_bSpecified

        //the host is either an ipwild (i.e. #.#.#.#!#) or a URL substring.  If
        //we have an ipwild, then we have to first resolve the site being browsed
        //to to a set of IP addresses.  We consider it a match if we match any
        //of those IPs.  If the host is an URL substring, then the first character
        //being a '*' matches any number of characters, and being '%*' matches '*'
        //itself.  Everything further must match exactly.  The compare is case-
        //insensitive.
        if(pPRByURLExpression->m_bNonWild&BYURL_HOST)
        {
            BOOL        fFrontWild=0,fWasIpWild=FALSE,fNoneMatched=TRUE;
            DWORD       dwIpRules=0;
            char        * lpszCurrent;

            lpszCurrent=pPRByURLExpression->m_etstrHost.Get();

            if((lpszCurrent[0]>='0')&&(lpszCurrent[0]<='9'))
            {
                //make a copy of the string since we are going to delete the masking '!'
                //to test for an ipwild
                char * lpszMask;
                char lpszIpWild[INTERNET_MAX_PATH_LENGTH+1];
                int  iBitMask=(sizeof(DWORD)*8);
                
                lstrcpy(lpszIpWild,lpszCurrent);

                lpszMask=strchrf(lpszIpWild,'!');

                if(lpszMask!=NULL)
                {
                    *lpszMask='\0';
                    lpszMask++;

                    ParseNumber(&lpszMask,&iBitMask,TRUE);
                }

                //test for an ipwild case
                dwIpRules = inet_addr(lpszIpWild);
                if(dwIpRules != INADDR_NONE)
                {
                    //we definately have an ipwild
                    array<DWORD*>      arrpIpCompare;
                    HOSTENT            * pHostEnt;
                    int                iCounter;

                    fWasIpWild=TRUE;

                    pHostEnt=gethostbyname(lpszHostName);

                    if(pHostEnt!=NULL)
                    {
                        char *lpszHosts;

                        lpszHosts=pHostEnt->h_addr_list[0];

                        iCounter=0;

                        while(lpszHosts!=NULL)
                        {
                            DWORD *pdwIP;
    
                            pdwIP=new DWORD;

                            *pdwIP=*((DWORD *) lpszHosts);

                            arrpIpCompare.Append(pdwIP);

                            iCounter++;

                            lpszHosts=pHostEnt->h_addr_list[iCounter];
                        }
                    }

                    //we've got all the IPs to test against, so lets do it
                    for(iCounter=0;iCounter<arrpIpCompare.Length();iCounter++)
                    {
                        DWORD dwIpCompare;
                        int   iBitCounter;
                        BOOL  fMatched;
                        
                        dwIpCompare=*(arrpIpCompare[iCounter]);
                        fMatched=TRUE;

                        //compare the first iBitMask bits as per the spec
                        for(iBitCounter=0;
                            iBitCounter<iBitMask;
                            iBitCounter++)
                        {
                            int iPower;
                            DWORD dwMask=1;

                            for(iPower=0;iPower<iBitCounter;iPower++)
                            {
                                dwMask*=2;
                            }

                            if((dwIpRules&dwMask)!=(dwIpCompare&dwMask))
                            {
                                //they don't match
                                fMatched=FALSE;

                                break;
                            }
                        }

                        if(fMatched==TRUE)
                        {
                            fNoneMatched=FALSE;

                            break;
                        }
                    }
                }
            }

            if(fWasIpWild)
            {
                if(fNoneMatched)
                {
                    //if none matched, we don't apply, so continue to the next
                    //iteration of the loop
                    continue;
                }
            }
            else
            {
                if((lpszCurrent[0]=='%')&&(lpszCurrent[1]=='*'))
                {
                    lpszCurrent++;
                }
                else if (lpszCurrent[0]=='*')
                {
                    fFrontWild=1;
                    lpszCurrent++;
                }
        
                if(fFrontWild==1)
                {
                    char * lpszTest;

                    lpszTest=strstrf(lpszHostName,lpszCurrent);

                    if(lstrcmpi(lpszTest,lpszCurrent)!=0)
                    {
                        continue;
                    }
                }
                else
                {
                    if(lstrcmpi(lpszHostName,lpszCurrent)!=0)
                    {
                        continue;
                    }
                }
            }
        }
        
        //if the port is ommitted, we only match if the port was also ommitted in
        //the URL being browsed to.
        if(!(pPRByURLExpression->m_bSpecified&BYURL_PORT))
        {
            if(URLComponents.nPort!=INTERNET_INVALID_PORT_NUMBER)
            {
                char * lpszCheck;

                //URLComponents.nPort gets filled in anyway due to the scheme, so
                //check it against the string itself

                lpszCheck=strstrf(pprurlComparisonURL->Get(),lpszHostName);

                if(lpszCheck!=NULL)
                {
                    lpszCheck+=lstrlen(lpszHostName);

                    if(*lpszCheck==':')
                    {
                        continue;
                    }
                }
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_PORT)
        {
            char * lpszPort,* lpszRange;

            //the port can be a single number or a range, with wild cards at both ends
            //of the range

            lpszPort=pPRByURLExpression->m_etstrPort.Get();

            lpszRange=strchrf(lpszPort,'-');
            
            if(lpszRange==NULL)
            {
                int iPort;

                //we've got a single port

                ParseNumber(&lpszPort,&iPort,TRUE);

                if(iPort!=URLComponents.nPort)
                {
                    continue;
                }
            }
            else
            {
                int iLow,iHigh;

                *lpszRange='\0';
                lpszRange++;

                if(*lpszPort=='*')
                {
                    iLow=0;
                }
                else
                {
                    ParseNumber(&lpszPort,&iLow,TRUE);
                }

                if(*lpszRange=='*')
                {
                    iHigh=INTERNET_MAX_PORT_NUMBER_VALUE;
                }
                else
                {
                    ParseNumber(&lpszRange,&iHigh,TRUE);
                }

                if((URLComponents.nPort>iHigh)||URLComponents.nPort<iLow)
                {
                    continue;
                }
            }
        }

        //if the path is ommitted, we only match if the path was also ommitted in
        //the URL being browsed to.
        if(!(pPRByURLExpression->m_bSpecified&BYURL_PATH))
        {
            if(*lpszUrlPath!=NULL)
            {
                if(!((*lpszUrlPath=='/')&&(*(lpszUrlPath+1)==NULL)))
                {
                    continue;
                }
            }
        }
        else if(pPRByURLExpression->m_bNonWild&BYURL_PATH)
        {
            int     iLength;
            char    * lpszCurrent,lpszCompare[INTERNET_MAX_URL_LENGTH+1],
                    lpszCopy[INTERNET_MAX_URL_LENGTH+1],* lpszUrlCheck,
                    * lpszPreCompare;
            BOOL    fFrontWild=0,fBackWild=0,fFrontEscaped=0,fBackEscaped=0;

            //if the path was specified we match a '*' at the beginning as wild, a '*'
            //at the end as wild, and '%*' matches aginst the character '*', this
            //comparison is case sensitive

            //kill leading slashes
            if(*lpszUrlPath=='/')
            {
                lpszUrlCheck=lpszUrlPath+1;
            }
            else
            {
                lpszUrlCheck=lpszUrlPath;
            }

            iLength=lstrlen(lpszUrlCheck);

            //kill trailing slashes
            if(lpszUrlCheck[iLength-1]=='/')
            {
                lpszUrlCheck[iLength-1]='\0';
            }

            lpszPreCompare=pPRByURLExpression->m_etstrPath.Get();

            //kill leading slashes
            if(*lpszPreCompare=='/')
            {
                lstrcpy(lpszCompare,lpszPreCompare+1);
            }
            else
            {
                lstrcpy(lpszCompare,lpszPreCompare);
            }
            
            iLength=lstrlen(lpszCompare);

            //kill trailing slashes
            if(lpszCompare[iLength-1]=='/')
            {
                lpszCompare[iLength-1]='\0';
            }

            if(lpszCompare[0]=='*')
            {
                fFrontWild=1;
            }
            
            if(lpszCompare[iLength-1]=='*')
            {
                fBackWild=1;
                
                lpszCompare[iLength-1]='\0';
            }

            if((lpszCompare[0]=='%')&&(lpszCompare[1]=='*'))
            {
                fFrontEscaped=1;
            }

            if((lpszCompare[iLength-2]=='%')&&fBackWild)
            {
                fBackWild=0;
                fBackEscaped=1;

                lpszCompare[iLength-2]='*';
            }

            lpszCurrent=lpszCompare+fFrontWild+fFrontEscaped;

            lstrcpy(lpszCopy,lpszCurrent);

            if(fFrontWild==1)
            {
                lpszCurrent=strstrf(lpszUrlCheck,lpszCopy);
                
                if(lpszCurrent!=NULL)
                {
                    if(fBackWild==0)
                    {
                        if(lstrcmp(lpszCurrent,lpszUrlCheck)!=0)
                        {
                            continue;
                        }
                    }
                }
                else
                {
                    continue;
                }
            }
            else
            {
                if(fBackWild==1)
                {
                    lpszUrlCheck[lstrlen(lpszCopy)]='\0';
                }

                if(lstrcmp(lpszUrlCheck,lpszCopy)!=0)
                {
                    continue;
                }
            }
        }

        //if we made it this far we do apply!
        fApplies=TRUE;
        
        break;
    }

    delete lpszScheme;
    lpszScheme = NULL;
    delete lpszHostName;
    lpszHostName = NULL;
    delete lpszUserName;
    lpszUserName = NULL;
    delete lpszPassword;
    lpszPassword = NULL;
    delete lpszUrlPath;
    lpszUrlPath = NULL;
    delete lpszExtraInfo;
    lpszExtraInfo = NULL;
    
    if(fApplies==TRUE)
    {
        return(PR_EVALUATION_DOESAPPLY);
    }
    else
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }
}

//*******************************************************************
//*
//* Code for the PICSRulesFileParser class
//*
//*******************************************************************

//FindNonWhite returns a pointer to the first non-whitespace
//character starting at pc.
char* PICSRulesFileParser::FindNonWhite(char *pc)
{
    ASSERT(pc);
    while (1)
    {
        if (*pc != ' ' &&
            *pc != '\t' &&
            *pc != '\r' &&
            *pc != '\n')            /* includes null terminator */
        {
            return pc;
        }
        if (*pc == '\n')

        m_nLine++;
        pc++;
    }
}

//Returns a pointer to the closing quotation mark of a quoted
//string, counting linefeeds as we go.  Returns NULL if no closing
//quotation mark is found.
//
//fQuote can be either PR_QUOTE_DOUBLE or PR_QUOTE_SINGLE
//defaults to PR_QUOTE_DOUBLE.
LPSTR PICSRulesFileParser::EatQuotedString(LPSTR pIn,BOOL fQuote)
{
    LPSTR pszQuote;

    if(fQuote==PR_QUOTE_DOUBLE)
    {
        pszQuote=strchrf(pIn,'\"');
    }
    else
    {
        pszQuote=strchrf(pIn,'\'');
    }

    if (pszQuote == NULL)
    {
        return NULL;
    }

    pIn=strchrf(pIn,'\n');
    while ((pIn!=NULL)&&(pIn<pszQuote))
    {
        m_nLine++;
        pIn=strchrf(pIn+1,'\n');
    }

    return pszQuote;
}

//ParseToOpening eats the opening '(' of a parenthesized object, and
//verifies that the token just inside it is one of the expected ones.
//If so, *ppIn is advanced past that token to the next non-whitespace
//character;  otherwise, an error is returned.
//
//For example, if *ppIn is pointing at "(PicsRule-1.1)", and
//PROID_PICSVERSION is in the allowable option table supplied, then
//NOERROR is returned and *ppIn will point at "1.1)".
//
//If the function is successful, *ppFound is set to point to the element
//in the allowable-options table which matches the type of thing this
//object actually is.
HRESULT PICSRulesFileParser::ParseToOpening(LPSTR *ppIn,
                                            PICSRulesAllowableOption *paoExpected,
                                            PICSRulesAllowableOption **ppFound)
{
    LPSTR lpszCurrent=*ppIn;

    lpszCurrent=FindNonWhite(lpszCurrent);
    
    if(*lpszCurrent=='(')
    {
        lpszCurrent=FindNonWhite(lpszCurrent+1);    //skip ( and whitespace
    }

    if((*lpszCurrent=='\"')||(*lpszCurrent=='\''))
    {
        //we found a default option section, treat it as a string and return
        //ppFound set to PROID_NAMEDEFAULT

        paoExpected->roid=PROID_NAMEDEFAULT;
        *ppFound=paoExpected;
        *ppIn=lpszCurrent;

        return NOERROR;
    }

    LPSTR lpszTokenEnd=FindTokenEnd(lpszCurrent);

    for(;paoExpected->roid!=PROID_INVALID;paoExpected++)
    {
        LPCSTR lpszThisToken=aPRObjectDescriptions[paoExpected->roid].lpszToken;

        if(paoExpected->roid==PROID_EXTENSION)
        {
            LPTSTR lpszDot;

            lpszDot=strchrf(lpszCurrent,'.');

            if(lpszDot!=NULL)
            {
                *lpszDot='\0';

                if(IsOptExtensionDefined(lpszCurrent)==TRUE)
                {
                    *lpszDot='.';

                    lpszTokenEnd=lpszCurrent;

                    break;
                }

                if(IsReqExtensionDefined(lpszCurrent)==TRUE)
                {
                    //currently no extensions are supported so we return
                    //an error on a required extension.
                    //if support for extensions is implemented
                    //this should be identical to above with a different
                    //callback for reqextensions defined.

                    return(PICSRULES_E_REQEXTENSIONUSED);
                }
            }
        }

        if(IsEqualToken(lpszCurrent,lpszTokenEnd,lpszThisToken))
        {
            break;
        }
    }

    if(paoExpected->roid!=PROID_INVALID)
    {
        *ppIn=FindNonWhite(lpszTokenEnd);       //skip token and whitespace
        *ppFound=paoExpected;
        
        return NOERROR;
    }
    else
    {
        return PICSRULES_E_UNKNOWNITEM;
    }
}

//ParseParenthesizedObjectContents is called with a text pointer pointing at
//the first non-whitespace thing following the token identifying the type of
//object.  It parses the rest of the contents of the object, up to and
//including the ')' which closes it.  The array of PICSRulesAllowableOption
//structures specifies which understood options are allowed to occur within
//this object.
HRESULT PICSRulesFileParser::ParseParenthesizedObject(LPSTR *ppIn,
                                                      PICSRulesAllowableOption aao[],
                                                      PICSRulesObjectBase *pObject)
{
    PICSRulesAllowableOption *pFound;

    HRESULT hres=S_OK;
    LPSTR pszCurrent=*ppIn;

    for(pFound=aao;pFound->roid!=PROID_INVALID;pFound++)
    {
        pFound->fdwOptions&=~AO_SEEN;
    }

    pFound=NULL;

    while((*pszCurrent!=')')&&(*pszCurrent!='\0')&&(SUCCEEDED(hres)))
    {
        hres=ParseToOpening(&pszCurrent,aao,&pFound);

        if(SUCCEEDED(hres))
        {
            LPVOID pData;

            hres=(*(aPRObjectDescriptions[pFound->roid].pHandler))(&pszCurrent,&pData,this);
            
            if(SUCCEEDED(hres))
            {
                if((pFound->fdwOptions&(AO_SINGLE|AO_SEEN))==(AO_SINGLE|AO_SEEN))
                {
                    hres=PICSRULES_E_DUPLICATEITEM;
                }
                else
                {
                    pFound->fdwOptions|=AO_SEEN;
                    
                    hres=pObject->AddItem(pFound->roid,pData);
                    
                    if(SUCCEEDED(hres))
                    {
                        pszCurrent=FindNonWhite(pszCurrent);
                    }
                }
            }
        }
    }

    if(FAILED(hres))
    {
        return hres;
    }

    for(pFound=aao;pFound->roid!=PROID_INVALID;pFound++)
    {
        if((pFound->fdwOptions&(AO_MANDATORY|AO_SEEN))==AO_MANDATORY)
        {
            return(PICSRULES_E_MISSINGITEM);        //mandatory item not found
        }
    }

    pszCurrent=FindNonWhite(pszCurrent+1);  //skip the closing parenthesis
    *ppIn=pszCurrent;

    return(hres);
}

//*******************************************************************
//*
//* Code for the PICSRulesName class
//*
//*******************************************************************

PICSRulesName::PICSRulesName()
{
    //just need to construct members
}

PICSRulesName::~PICSRulesName()
{
    //nothing to do
}

HRESULT PICSRulesName::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_RULENAME:
        {
            m_etstrRuleName.SetTo((char *) pData);
            
            break;
        }
        case PROID_DESCRIPTION:
        {
            m_etstrDescription.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesName::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesOptExtension class
//*
//*******************************************************************

PICSRulesOptExtension::PICSRulesOptExtension()
{
    //nothing to do
}

PICSRulesOptExtension::~PICSRulesOptExtension()
{
    //nothing to do
}

HRESULT PICSRulesOptExtension::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXTENSIONNAME:
        {
            m_prURLExtensionName.SetTo((char *) pData);
            
            if(m_prURLExtensionName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesOptExtension::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesPassFail class
//*
//*******************************************************************

PICSRulesPassFail::PICSRulesPassFail()
{
    m_fPassOrFail=PR_PASSFAIL_PASS;
}

PICSRulesPassFail::~PICSRulesPassFail()
{
    //nothing to do
}

void PICSRulesPassFail::Set(const BOOL *pIn)
{
    switch(*pIn)
    {
        case PR_PASSFAIL_PASS:
        {
            ETS::Set(szPRPass);
            m_fPassOrFail=PR_PASSFAIL_PASS;

            break;
        }
        case PR_PASSFAIL_FAIL:
        {
            ETS::Set(szPRFail);
            m_fPassOrFail=PR_PASSFAIL_FAIL;

            break;
        }
    }
}

void PICSRulesPassFail::SetTo(BOOL *pIn)
{
    Set(pIn);
}

//*******************************************************************
//*
//* Code for the PICSRulesPolicy class
//*
//*******************************************************************

PICSRulesPolicy::PICSRulesPolicy()
{
    m_PRPolicyAttribute=PR_POLICY_NONEVALID;
}

PICSRulesPolicy::~PICSRulesPolicy()
{
    switch(m_PRPolicyAttribute)
    {
        case PR_POLICY_REJECTBYURL:
        {
            if(m_pPRRejectByURL!=NULL)
            {
                delete m_pPRRejectByURL;
                m_pPRRejectByURL = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTBYURL:
        {
            if(m_pPRAcceptByURL!=NULL)
            {
                delete m_pPRAcceptByURL;
                m_pPRAcceptByURL = NULL;
            }
            break;
        }
        case PR_POLICY_REJECTIF:
        {
            if(m_pPRRejectIf!=NULL)
            {
                delete m_pPRRejectIf;
                m_pPRRejectIf = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTIF:
        {
            if(m_pPRAcceptIf!=NULL)
            {
                delete m_pPRAcceptIf;
                m_pPRAcceptIf = NULL;
            }
            break;
        }
        case PR_POLICY_REJECTUNLESS:
        {
            if(m_pPRRejectUnless!=NULL)
            {
                delete m_pPRRejectUnless;
                m_pPRRejectUnless = NULL;
            }
            break;
        }
        case PR_POLICY_ACCEPTUNLESS:
        {
            if(m_pPRAcceptUnless!=NULL)
            {
                delete m_pPRAcceptUnless;
                m_pPRAcceptUnless = NULL;
            }
            break;
        }
        case PR_POLICY_NONEVALID:
        default:
        {
            break;
        }
    }
}

HRESULT PICSRulesPolicy::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXPLANATION:
        {
            m_etstrExplanation.SetTo((char *) pData);
            
            break;
        }
        case PROID_REJECTBYURL:
        {
            m_pPRRejectByURL=((PICSRulesByURL *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTBYURL;

            break;
        }
        case PROID_ACCEPTBYURL:
        {
            m_pPRAcceptByURL=((PICSRulesByURL *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTBYURL;

            break;
        }
        case PROID_REJECTIF:
        {
            m_pPRRejectIf=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTIF;

            break;
        }
        case PROID_ACCEPTIF:
        {
            m_pPRAcceptIf=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTIF;

            break;
        }
        case PROID_REJECTUNLESS:
        {
            m_pPRRejectUnless=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_REJECTUNLESS;

            break;
        }
        case PROID_ACCEPTUNLESS:
        {
            m_pPRAcceptUnless=((PICSRulesPolicyExpression *) pData);
            m_PRPolicyAttribute=PR_POLICY_ACCEPTUNLESS;

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesPolicy::InitializeMyDefaults()
{
    return(NOERROR);    //no defaults to initialize
}

//*******************************************************************
//*
//* Code for the PICSRulesPolicyExpression class
//*
//*******************************************************************

PICSRulesPolicyExpression::PICSRulesPolicyExpression()
{
    m_PRPEPolicyEmbedded=       PR_POLICYEMBEDDED_NONE;
    m_PROPolicyOperator=        PR_OPERATOR_INVALID;
    m_pPRPolicyExpressionLeft=  NULL;
    m_pPRPolicyExpressionRight= NULL;
}

PICSRulesPolicyExpression::~PICSRulesPolicyExpression()
{
    if(m_PRPEPolicyEmbedded!=PR_POLICYEMBEDDED_NONE)    //do we need to delete an
                                                        //embedded PolicyExpression?
    {
        if(m_pPRPolicyExpressionLeft!=NULL)             //double check, just to make sure
        {
            delete m_pPRPolicyExpressionLeft;
            m_pPRPolicyExpressionLeft = NULL;
        }
        if(m_pPRPolicyExpressionRight!=NULL)            //double check, just to make sure
        {
            delete m_pPRPolicyExpressionRight;
            m_pPRPolicyExpressionRight = NULL;
        }
    }
}

PICSRulesEvaluation PICSRulesPolicyExpression::EvaluateRule(CParsedLabelList *pParsed)
{
    PICSRulesEvaluation PREvaluationResult;

    if((pParsed==NULL)||(m_PROPolicyOperator==PR_OPERATOR_DEGENERATE))
    {
        //we can't apply if there is no label, and we
        //don't handle the degenerate case since we have
        //to pass on to the PICS handler

        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    if((m_prYesNoUseEmbedded.GetYesNo()==PR_YESNO_NO)&&(g_dwDataSource==PICS_LABEL_FROM_PAGE))
    {
        return(PR_EVALUATION_DOESNOTAPPLY);
    }

    switch(m_PRPEPolicyEmbedded)
    {
        case PR_POLICYEMBEDDED_NONE:
        {
            switch(m_PROPolicyOperator)
            {
                case PR_OPERATOR_GREATEROREQUAL:
                case PR_OPERATOR_GREATER:
                case PR_OPERATOR_EQUAL:
                case PR_OPERATOR_LESSOREQUAL:
                case PR_OPERATOR_LESS:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    CParsedRating      * pCParsedRating;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iCounter;

                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        //we've got the service, now check for the category

                        for(iCounter=0;iCounter<pCParsedServiceInfo->aRatings.Length();iCounter++)
                        {
                            pCParsedRating=&(pCParsedServiceInfo->aRatings[iCounter]);

                            if(lstrcmp(pCParsedRating->pszTransmitName,m_etstrCategoryName.Get())==0)
                            {
                                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                                break;
                            }
                        }
                    }

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iLabelValue;
                        
                        iLabelValue=pCParsedRating->nValue;

                        //now check the values
                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        switch(m_PROPolicyOperator)
                        {
                            case PR_OPERATOR_GREATEROREQUAL:
                            {
                                if(iLabelValue>=m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_GREATER:
                            {
                                if(iLabelValue>m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_EQUAL:
                            {
                                if(iLabelValue==m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_LESSOREQUAL:
                            {
                                if(iLabelValue<=m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                            case PR_OPERATOR_LESS:
                            {
                                if(iLabelValue<m_etnValue.Get())
                                {
                                    PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                                }

                                break;
                            }
                        }
                    }

                    break;
                }
                case PR_OPERATOR_SERVICEONLY:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    break;
                }
                case PR_OPERATOR_SERVICEANDCATEGORY:
                {
                    LPCSTR             lpszTest;
                    CParsedServiceInfo * pCParsedServiceInfo;
                    
                    PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                    pCParsedServiceInfo=&(pParsed->m_ServiceInfo);
                    
                    do
                    {
                        lpszTest=pCParsedServiceInfo->m_pszServiceName;

                        if(lstrcmp(lpszTest,m_etstrFullServiceName.Get())==0)
                        {
                            PREvaluationResult=PR_EVALUATION_DOESAPPLY;
                            
                            break;
                        }

                        pCParsedServiceInfo=pCParsedServiceInfo->Next();
                    } while (pCParsedServiceInfo!=NULL);

                    if(PREvaluationResult==PR_EVALUATION_DOESAPPLY)
                    {
                        int iCounter;

                        PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;

                        //we've got the service, now check for the category

                        for(iCounter=0;iCounter<pCParsedServiceInfo->aRatings.Length();iCounter++)
                        {
                            CParsedRating * pCParsedRating;

                            pCParsedRating=&(pCParsedServiceInfo->aRatings[iCounter]);

                            if(lstrcmp(pCParsedRating->pszTransmitName,m_etstrCategoryName.Get())==0)
                            {
                                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                                break;
                            }
                        }
                    }

                    break;
                }
            }

            break;
        }
        case PR_POLICYEMBEDDED_OR:
        {
            PICSRulesEvaluation PREvaluationIntermediate;

            PREvaluationIntermediate=m_pPRPolicyExpressionLeft->EvaluateRule(pParsed);

            if(PREvaluationIntermediate==PR_EVALUATION_DOESAPPLY)
            {
                PREvaluationResult=PR_EVALUATION_DOESAPPLY;

                break;
            }
            else
            {
                PREvaluationResult=m_pPRPolicyExpressionRight->EvaluateRule(pParsed);
            }
            
            break;
        }
        case PR_POLICYEMBEDDED_AND:
        {
            PICSRulesEvaluation PREvaluationIntermediate;

            PREvaluationIntermediate=m_pPRPolicyExpressionLeft->EvaluateRule(pParsed);

            PREvaluationResult=m_pPRPolicyExpressionRight->EvaluateRule(pParsed);

            if((PREvaluationIntermediate==PR_EVALUATION_DOESAPPLY)&&
               (PREvaluationResult==PR_EVALUATION_DOESAPPLY))
            {
                break;
            }
            else
            {
                PREvaluationResult=PR_EVALUATION_DOESNOTAPPLY;
            }

            break;
        }
    }

    return(PREvaluationResult);
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedDate class
//*
//*******************************************************************

PICSRulesQuotedDate::PICSRulesQuotedDate()
{
    m_dwDate=0;
}

PICSRulesQuotedDate::~PICSRulesQuotedDate()
{
    //nothing to do
}

HRESULT PICSRulesQuotedDate::Set(const char *pIn)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime((char *) pIn,&dwDate);

    if(FAILED(hRes))
    {
        return(E_INVALIDARG);
    }

    m_dwDate=dwDate;

    ETS::Set(pIn);

    return(S_OK);
}

HRESULT PICSRulesQuotedDate::SetTo(char *pIn)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime(pIn,&dwDate,TRUE);

    if(FAILED(hRes))
    {
        return(E_INVALIDARG);
    }

    m_dwDate=dwDate;

    ETS::SetTo(pIn);

    return(S_OK);
}

BOOL PICSRulesQuotedDate::IsDateValid()
{
    if(m_dwDate)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedDate::IsDateValid(char * lpszDate)
{
    HRESULT hRes;
    DWORD   dwDate;

    hRes=ParseTime(lpszDate,&dwDate);

    if(SUCCEEDED(hRes))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedDate::IsDateValid(ETS etstrDate)
{
    HRESULT hRes;
    DWORD   dwDate;
    LPTSTR  lpszDate;

    lpszDate=etstrDate.Get();

    hRes=ParseTime(lpszDate,&dwDate);

    if(SUCCEEDED(hRes))
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedEmail class
//*
//*******************************************************************

PICSRulesQuotedEmail::PICSRulesQuotedEmail()
{
    //nothing to do
}

PICSRulesQuotedEmail::~PICSRulesQuotedEmail()
{
    //nothing to do
}

BOOL PICSRulesQuotedEmail::IsEmailValid()
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

BOOL PICSRulesQuotedEmail::IsEmailValid(char * lpszEmail)
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

BOOL PICSRulesQuotedEmail::IsEmailValid(ETS etstrEmail)
{
    //We don't use this internally, so as far as we are concerned
    //its always valid.
    //If we ever add UI that displays this, we can defer verification
    //of the email address to the mail client by sticking a mailto://
    //in front of our string

    return(TRUE);
}

//*******************************************************************
//*
//* Code for the PICSRulesQuotedURL class
//*
//*******************************************************************

PICSRulesQuotedURL::PICSRulesQuotedURL()
{
    //nothing to do
}

PICSRulesQuotedURL::~PICSRulesQuotedURL()
{
    //nothing to do
}

BOOL IsURLValid(WCHAR wcszURL[INTERNET_MAX_URL_LENGTH])
{
    FN_ISVALIDURL   pfnIsValidURL;

    pfnIsValidURL=(FN_ISVALIDURL) GetProcAddress(g_hURLMON,"IsValidURL");

    if(pfnIsValidURL==NULL)
    {
        return(FALSE);
    }

    if(pfnIsValidURL(NULL,wcszURL,0)==S_OK)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

BOOL PICSRulesQuotedURL::IsURLValid()
{
    char            * lpszURL;
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    lpszURL=Get();

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);
    
    return(::IsURLValid(wcszURL));
}

BOOL PICSRulesQuotedURL::IsURLValid(char * lpszURL)
{
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);

    return(::IsURLValid(wcszURL));
}

BOOL PICSRulesQuotedURL::IsURLValid(ETS etstrURL)
{
    char            * lpszURL;
    WCHAR           wcszURL[INTERNET_MAX_URL_LENGTH];

    lpszURL=etstrURL.Get();

    MultiByteToWideChar(CP_OEMCP,MB_PRECOMPOSED,lpszURL,-1,wcszURL,INTERNET_MAX_URL_LENGTH);

    return(::IsURLValid(wcszURL));
}

//*******************************************************************
//*
//* Code for the PICSRulesReqExtension class
//*
//*******************************************************************

PICSRulesReqExtension::PICSRulesReqExtension()
{
    //nothing to do
}

PICSRulesReqExtension::~PICSRulesReqExtension()
{
    //nothing to do
}

HRESULT PICSRulesReqExtension::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_EXTENSIONNAME:
        {
            m_prURLExtensionName.SetTo((char *) pData);
            
            if(m_prURLExtensionName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesReqExtension::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

//*******************************************************************
//*
//* Code for the PICSRulesServiceInfo class
//*
//*******************************************************************

PICSRulesServiceInfo::PICSRulesServiceInfo()
{
    const BOOL fYes=PR_YESNO_YES;
    const BOOL fPass=PR_PASSFAIL_PASS;

    m_prPassFailBureauUnavailable.Set(&fPass);
    m_prYesNoUseEmbedded.Set(&fYes);
}

PICSRulesServiceInfo::~PICSRulesServiceInfo()
{
    //nothing to do
}

HRESULT PICSRulesServiceInfo::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_NAME:
        case PROID_SINAME:
        {
            m_prURLName.SetTo((char *) pData);
            
            if(m_prURLName.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_SHORTNAME:
        {
            m_etstrShortName.SetTo((char *) pData);

            break;
        }
        case PROID_BUREAUURL:
        {
            m_prURLBureauURL.SetTo((char *) pData);

            if(m_prURLBureauURL.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_USEEMBEDDED:
        {
            m_prYesNoUseEmbedded.SetTo((BOOL *) &pData);

            break;
        }
        case PROID_RATFILE:
        {
            m_etstrRatfile.SetTo((char *) pData);

            break;
        }
        case PROID_BUREAUUNAVAILABLE:
        {
            m_prPassFailBureauUnavailable.SetTo((BOOL *) &pData);

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesServiceInfo::InitializeMyDefaults()
{
    //nothing to do
    return(S_OK);
}

//*******************************************************************
//*
//* Code for the PICSRulesSource class
//*
//*******************************************************************

PICSRulesSource::PICSRulesSource()
{
    //nothing to do but construct members
}

PICSRulesSource::~PICSRulesSource()
{
    //nothing to do
}

HRESULT PICSRulesSource::AddItem(PICSRulesObjectID proid, LPVOID pData)
{
    HRESULT hRes = S_OK;

    switch (proid)
    {
        case PROID_NAMEDEFAULT:
        case PROID_SOURCEURL:
        {
            m_prURLSourceURL.SetTo((char *) pData);
            
            if(m_prURLSourceURL.IsURLValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_AUTHOR:
        {
            m_prEmailAuthor.SetTo((char *) pData);

            if(m_prEmailAuthor.IsEmailValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_CREATIONTOOL:
        {
            m_etstrCreationTool.SetTo((char *) pData);

            break;
        }
        case PROID_LASTMODIFIED:
        {
            m_prDateLastModified.SetTo((char *) pData);

            if(m_prDateLastModified.IsDateValid()==FALSE)
            {
                hRes=E_INVALIDARG;
            }

            break;
        }
        case PROID_EXTENSION:
        {
            //just eat extensions
            break;
        }
        case PROID_INVALID:
        default:
        {
            ASSERT(FALSE);      // shouldn't have been given a PROID that wasn't in
                                // the table we passed to the parser!
            hRes=E_UNEXPECTED;
            break;
        }
    }
    return hRes;
}

HRESULT PICSRulesSource::InitializeMyDefaults()
{
    //no defaults to initialize
    return(NOERROR);
}

char * PICSRulesSource::GetToolName()
{
    return m_etstrCreationTool.Get();
}

//*******************************************************************
//*
//* Code for the PICSRulesYesNo class
//*
//*******************************************************************

PICSRulesYesNo::PICSRulesYesNo()
{
    m_fYesOrNo=PR_YESNO_YES;
}

PICSRulesYesNo::~PICSRulesYesNo()
{
}

void PICSRulesYesNo::Set(const BOOL *pIn)
{
    switch(*pIn)
    {
        case PR_YESNO_YES:
        {
            ETS::Set(szPRYes);
            m_fYesOrNo=PR_YESNO_YES;

            break;
        }
        case PR_YESNO_NO:
        {
            ETS::Set(szPRNo);
            m_fYesOrNo=PR_YESNO_NO;

            break;
        }
    }
}

void PICSRulesYesNo::SetTo(BOOL *pIn)
{
    Set(pIn);
}

//*******************************************************************
//*
//* Code for the PICSRulesByURLExpression class
//*
//*******************************************************************
PICSRulesByURLExpression::PICSRulesByURLExpression()
{
    m_bNonWild=0;
    m_bSpecified=0;
}

PICSRulesByURLExpression::~PICSRulesByURLExpression()
{
    //nothing to do
}

HRESULT EtStringRegWriteCipher(ETS &ets,HKEY hKey,char *pKeyWord)
{
    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(ets.fIsInit())
    {
        return(RegSetValueEx(hKey,pKeyWord,0,REG_SZ,(LPBYTE)ets.Get(),strlenf(ets.Get())+1));
    }

    return(NOERROR);
}

HRESULT EtNumRegWriteCipher(ETN &etn,HKEY hKey,char *pKeyWord)
{
    int iTemp;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(etn.fIsInit())
    {
        iTemp=etn.Get();

        return(RegSetValueEx(hKey,pKeyWord,0,REG_DWORD,(LPBYTE)&iTemp,sizeof(iTemp)));
    }

    return(NOERROR);
}

HRESULT EtBoolRegWriteCipher(ETB &etb,HKEY hKey,char *pKeyWord)
{
    DWORD dwNum;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    if(etb.fIsInit())
    {
        dwNum=etb.Get();

        return(RegSetValueEx(hKey,pKeyWord,0,REG_DWORD,(LPBYTE)&dwNum,sizeof(dwNum)));
    }

    return(NOERROR);
}

HRESULT EtStringRegReadCipher(ETS &ets,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    char * lpszString=new char[INTERNET_MAX_URL_LENGTH + 1];
    DWORD dwSizeOfString=INTERNET_MAX_URL_LENGTH + 1;
    
    if(lpszString==NULL)
    {
        return(E_OUTOFMEMORY);
    }

    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) lpszString,&dwSizeOfString)!=ERROR_SUCCESS)
    {
        ets.SetTo(NULL);

        delete lpszString;
        lpszString = NULL;

        return(E_UNEXPECTED);
    }
    else
    {
        ets.SetTo(lpszString);
    }

    return(NOERROR);
}

HRESULT EtNumRegReadCipher(ETN &etn,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    DWORD dwNum;
    DWORD dwSizeOfNum=sizeof(DWORD);
    
    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) &dwNum,&dwSizeOfNum)!=ERROR_SUCCESS)
    {
        etn.Set(0);

        return(E_UNEXPECTED);
    }
    else
    {
        etn.Set(dwNum);
    }

    return(NOERROR);
}

HRESULT EtBoolRegReadCipher(ETB &etb,HKEY hKey,char *pKeyWord)
{
    unsigned long lType;

    if(pKeyWord==NULL)
    {
        return(E_INVALIDARG);
    }

    BOOL fFlag;
    DWORD dwSizeOfFlag=sizeof(BOOL);
    
    if(RegQueryValueEx(hKey,pKeyWord,NULL,&lType,(LPBYTE) &fFlag,&dwSizeOfFlag)!=ERROR_SUCCESS)
    {
        etb.Set(0);

        return(E_UNEXPECTED);
    }
    else
    {
        etb.Set(fFlag);
    }

    return(NOERROR);
}

void PICSRulesOutOfMemory()
{
    char szTitle[MAX_PATH],szMessage[MAX_PATH];

    MLLoadString(IDS_ERROR,(LPTSTR) szTitle,MAX_PATH);
    MLLoadString(IDS_PICSRULES_OUTOFMEMORY,(LPTSTR) szMessage,MAX_PATH);

    MessageBox(NULL,(LPCTSTR) szMessage,(LPCTSTR) szTitle,MB_OK|MB_ICONERROR);
}

HRESULT CopySubPolicyExpressionFromRegistry(PICSRulesPolicyExpression * pPRPolicyExpressionBeingCopied,HKEY hKeyExpression)
{
    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
    ETB                       etb;
    ETN                       etn;
    int                       iTemp;
    long                      lError;

    EtBoolRegReadCipher(etb,hKeyExpression,(char *) szPICSRULESEXPRESSIONEMBEDDED);
    iTemp=(int) etb.Get();
    pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONSERVICENAME);
    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrCategoryName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONCATEGORYNAME);
    EtStringRegReadCipher(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONFULLSERVICENAME);

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONVALUE);
    pPRPolicyExpressionBeingCopied->m_etnValue.Set(etn.Get());

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR);
    pPRPolicyExpressionBeingCopied->m_PROPolicyOperator=(PICSRulesOperators) etn.Get();

    EtNumRegReadCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED);
    pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded=(PICSRulesPolicyEmbedded) etn.Get();

    // Handle Left Expression
    {
        CRegKey                   keyExpressionSubKey;

        lError = keyExpressionSubKey.Open( hKeyExpression, szPICSRULESEXPRESSIONLEFT, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=NULL;
        }
        else
        {
            pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

            if(pPRSubPolicyExpressionToCopy==NULL)
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed PICSRulesPolicyExpression Creation LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }

            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=pPRSubPolicyExpressionToCopy;

            if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey )))
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed Copy LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
                return(E_OUTOFMEMORY);
            }
        }
    }

    // Handle Right Expression
    {
        CRegKey                   keyExpressionSubKey;

        lError = keyExpressionSubKey.Open( hKeyExpression, szPICSRULESEXPRESSIONRIGHT, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=NULL;
        }
        else
        {
            pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

            if(pPRSubPolicyExpressionToCopy==NULL)
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed PICSRulesPolicyExpression Creation RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }

            pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=pPRSubPolicyExpressionToCopy;

            if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
            {
                TraceMsg( TF_WARNING, "CopySubPolicyExpressionFromRegistry() - Failed Copy RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
                return(E_OUTOFMEMORY);
            }
        }
    }

    return(NOERROR);
}

class CReadRatingSystem
{
private:
    PICSRulesRatingSystem ** m_ppPRRS;

public:
    CReadRatingSystem( PICSRulesRatingSystem ** p_ppPRRS )
    {
        m_ppPRRS = p_ppPRRS;
    }

    ~CReadRatingSystem()
    {
        if ( m_ppPRRS )
        {
            if ( *m_ppPRRS )
            {
                delete *m_ppPRRS;
                *m_ppPRRS = NULL;
            }

            m_ppPRRS = NULL;
        }
    }

    void ValidRatingSystem( void )      { m_ppPRRS = NULL; }
};

HRESULT ReadSystemFromRegistry(HKEY hKey,PICSRulesRatingSystem **ppPRRS)
{
    PICSRulesRatingSystem       * pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRNameBeingCopied;
    PICSRulesSource             * pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpressionToCopy;
    ETN                         etn;
    ETB                         etb;
    long                        lError;
    char                        szNumber[MAX_PATH];
    DWORD                       dwNumSystems,dwSubCounter,dwNumServiceInfo,dwNumExtensions;

    pPRRSBeingCopied=*ppPRRS;

    if(pPRRSBeingCopied!=NULL)
    {
        delete pPRRSBeingCopied;
        pPRRSBeingCopied = NULL;
    }

    pPRRSBeingCopied=new PICSRulesRatingSystem;

    if(pPRRSBeingCopied==NULL)
    {
        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesRatingSystem Creation!" );

        PICSRulesOutOfMemory();

        return(E_OUTOFMEMORY);
    }

    *ppPRRS=pPRRSBeingCopied;

    CReadRatingSystem           readRatingSystem( ppPRRS );

    EtStringRegReadCipher(pPRRSBeingCopied->m_etstrFile,hKey,(char *) &szPICSRULESFILENAME);
    EtNumRegReadCipher(pPRRSBeingCopied->m_etnPRVerMajor,hKey,(char *) &szPICSRULESVERMAJOR);
    EtNumRegReadCipher(pPRRSBeingCopied->m_etnPRVerMinor,hKey,(char *) &szPICSRULESVERMINOR);

    EtNumRegReadCipher(etn,hKey,(char *) &szPICSRULESDWFLAGS);
    pPRRSBeingCopied->m_dwFlags=etn.Get();

    EtNumRegReadCipher(etn,hKey,(char *) &szPICSRULESERRLINE);
    pPRRSBeingCopied->m_nErrLine=etn.Get();

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesName Structure
        lError = keySubKey.Open( hKey, szPICSRULESPRNAME, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRRSBeingCopied->m_pPRName=NULL;
        }
        else
        {
            pPRNameBeingCopied=new PICSRulesName;

            if(pPRNameBeingCopied==NULL)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesName Creation!" );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }
            else
            {
                pPRRSBeingCopied->m_pPRName=pPRNameBeingCopied;
            }
        }

        if((pPRRSBeingCopied->m_pPRName)!=NULL)
        {
            EtStringRegReadCipher( pPRNameBeingCopied->m_etstrRuleName, keySubKey.m_hKey, (char *) &szPICSRULESRULENAME );
            EtStringRegReadCipher( pPRNameBeingCopied->m_etstrDescription, keySubKey.m_hKey ,(char *) &szPICSRULESDESCRIPTION );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesSource Structure
        lError = keySubKey.Open( hKey, szPICSRULESPRSOURCE, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            pPRRSBeingCopied->m_pPRSource=NULL;
        }
        else
        {
            pPRSourceBeingCopied=new PICSRulesSource;

            if(pPRSourceBeingCopied==NULL)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesSource Creation!" );
                PICSRulesOutOfMemory();
                return(E_OUTOFMEMORY);
            }
            else
            {
                pPRRSBeingCopied->m_pPRSource=pPRSourceBeingCopied;
            }
        }

        if((pPRRSBeingCopied->m_pPRSource)!=NULL)
        {
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prURLSourceURL, keySubKey.m_hKey, (char *) &szPICSRULESSOURCEURL );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_etstrCreationTool, keySubKey.m_hKey, (char *) &szPICSRULESCREATIONTOOL );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prEmailAuthor, keySubKey.m_hKey, (char *) &szPICSRULESEMAILAUTHOR );
            EtStringRegReadCipher( pPRSourceBeingCopied->m_prDateLastModified, keySubKey.m_hKey, (char *) &szPICSRULESLASTMODIFIED );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in the PICSRulesPolicy structure    
        lError = keySubKey.Open( hKey, szPICSRULESPRPOLICY, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumSystems=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMPOLICYS );

            dwNumSystems=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<dwNumSystems;dwSubCounter++)
        {
            DWORD dwPolicyExpressionSubCounter;
            wsprintf(szNumber,"%d",dwSubCounter);

            CRegKey             keyCopy;

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRPolicyBeingCopied=new PICSRulesPolicy;

                if(pPRPolicyBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesPolicy Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRPolicy.Append(pPRPolicyBeingCopied);

            EtStringRegReadCipher( pPRPolicyBeingCopied->m_etstrExplanation, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYEXPLANATION );

            EtNumRegReadCipher( etn, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYATTRIBUTE );

            pPRPolicyBeingCopied->m_PRPolicyAttribute=(PICSRulesPolicyAttribute) etn.Get();

            CRegKey             keyExpression;

            lError = keyExpression.Open( keyCopy.m_hKey, szPICSRULESPOLICYSUB, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyExpression Open szPICSRULESPOLICYSUB='%s'!", szPICSRULESPOLICYSUB );
                return(E_FAIL);
            }

            pPRByURLToCopy=NULL;
            pPRPolicyExpressionBeingCopied=NULL;

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                case PR_POLICY_REJECTBYURL:
                {
                    pPRByURLToCopy=new PICSRulesByURL;

                    if(pPRByURLToCopy==NULL)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesByURL Creation!" );
                        PICSRulesOutOfMemory();
                        return(E_OUTOFMEMORY);
                    }

                    break;
                }
                case PR_POLICY_REJECTIF:
                case PR_POLICY_ACCEPTIF:
                case PR_POLICY_REJECTUNLESS:
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=new PICSRulesPolicyExpression;

                    if(pPRPolicyExpressionBeingCopied==NULL)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesPolicyExpression Creation!" );
                        PICSRulesOutOfMemory();
                        return(E_OUTOFMEMORY);
                    }

                    break;
                }
            }

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptByURL=pPRByURLToCopy;
            
                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    pPRPolicyBeingCopied->m_pPRRejectByURL=pPRByURLToCopy;

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    pPRPolicyBeingCopied->m_pPRRejectIf=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptIf=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    pPRPolicyBeingCopied->m_pPRRejectUnless=pPRPolicyExpressionBeingCopied;

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyBeingCopied->m_pPRAcceptUnless=pPRPolicyExpressionBeingCopied;

                    break;
                }
            }

            if(pPRByURLToCopy!=NULL)
            {
                DWORD dwNumExpressions;

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESNUMBYURL );
                dwNumExpressions=etn.Get();

                for(dwPolicyExpressionSubCounter=0;
                    dwPolicyExpressionSubCounter<dwNumExpressions;
                    dwPolicyExpressionSubCounter++)
                {
                    CRegKey             keyByURL;

                    wsprintf(szNumber,"%d",dwPolicyExpressionSubCounter);

                    lError = keyByURL.Open( keyExpression.m_hKey, szNumber, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed keyByURL Open szNumber='%s'!", szNumber );
                        return(E_FAIL);
                    }
                    else
                    {
                        pPRByURLExpressionToCopy=new PICSRulesByURLExpression;

                        if(pPRByURLExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesByURLExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_FAIL);
                        }
                    }

                    pPRByURLToCopy->m_arrpPRByURL.Append(pPRByURLExpressionToCopy);

                    EtBoolRegReadCipher( etb, keyByURL.m_hKey, (char *) szPICSRULESBYURLINTERNETPATTERN );
                    pPRByURLExpressionToCopy->m_fInternetPattern=etb.Get();

                    EtNumRegReadCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLNONWILD );
                    pPRByURLExpressionToCopy->m_bNonWild = (unsigned char) etn.Get();

                    EtNumRegReadCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLSPECIFIED );
                    pPRByURLExpressionToCopy->m_bSpecified = (unsigned char) etn.Get();

                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrScheme, keyByURL.m_hKey, (char *) &szPICSRULESBYURLSCHEME );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrUser, keyByURL.m_hKey, (char *) &szPICSRULESBYURLUSER );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrHost, keyByURL.m_hKey, (char *) &szPICSRULESBYURLHOST );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrPort, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPORT );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrPath, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPATH );
                    EtStringRegReadCipher( pPRByURLExpressionToCopy->m_etstrURL, keyByURL.m_hKey, (char *) &szPICSRULESBYURLURL );
                }
            }

            if(pPRPolicyExpressionBeingCopied!=NULL)
            {
                PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                int                       iTemp;

                EtBoolRegReadCipher( etb, keyExpression.m_hKey,(char *) szPICSRULESEXPRESSIONEMBEDDED );
                iTemp=(int) etb.Get();
                pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONSERVICENAME );
                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrCategoryName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONCATEGORYNAME );
                EtStringRegReadCipher( pPRPolicyExpressionBeingCopied->m_etstrFullServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONFULLSERVICENAME );

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONVALUE );
                pPRPolicyExpressionBeingCopied->m_etnValue.Set(etn.Get());

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR );
                pPRPolicyExpressionBeingCopied->m_PROPolicyOperator=(PICSRulesOperators) etn.Get();

                EtNumRegReadCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED );
                pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded=(PICSRulesPolicyEmbedded) etn.Get();

                {
                    CRegKey                 keyExpressionSubKey;

                    lError = keyExpressionSubKey.Open( keyExpression.m_hKey, szPICSRULESEXPRESSIONLEFT, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=NULL;
                    }
                    else
                    {
                        pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed LEFT PICSRulesPolicyExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft=pPRSubPolicyExpressionToCopy;

                        if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed LEFT CopySubPolicyExpressionFromRegistry()!" );
                            return(E_FAIL);
                        }
                    }
                }

                {
                    CRegKey                 keyExpressionSubKey;

                    lError = keyExpressionSubKey.Open( keyExpression.m_hKey, szPICSRULESEXPRESSIONRIGHT, KEY_READ );

                    if(lError!=ERROR_SUCCESS)
                    {
                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=NULL;
                    }
                    else
                    {
                        pPRSubPolicyExpressionToCopy=new PICSRulesPolicyExpression;

                        if(pPRSubPolicyExpressionToCopy==NULL)
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed RIGHT PICSRulesPolicyExpression Creation!" );
                            PICSRulesOutOfMemory();
                            return(E_OUTOFMEMORY);
                        }

                        pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight=pPRSubPolicyExpressionToCopy;

                        if ( FAILED( CopySubPolicyExpressionFromRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                        {
                            TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed RIGHT CopySubPolicyExpressionFromRegistry()!" );
                            return(E_FAIL);
                        }
                    }
                }
            }
        }
    }

    {
        CRegKey             keySubKey;

        //Read In PICSRulesServiceInfo Structure
        lError = keySubKey.Open( hKey, szPICSRULESSERVICEINFO, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumServiceInfo=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey ,(char *) &szPICSRULESNUMSERVICEINFO );
            dwNumServiceInfo=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<dwNumServiceInfo;dwSubCounter++)
        {
            CRegKey         keyCopy;
            int  iTemp;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESSERVICEINFO keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRServiceInfoBeingCopied=new PICSRulesServiceInfo;

                if(pPRServiceInfoBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesServiceInfo Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRServiceInfo.Append(pPRServiceInfoBeingCopied);

            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_prURLName, keyCopy.m_hKey, (char *) &szPICSRULESSIURLNAME );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_prURLBureauURL, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUURL );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESSISHORTNAME );
            EtStringRegReadCipher( pPRServiceInfoBeingCopied->m_etstrRatfile, keyCopy.m_hKey, (char *) &szPICSRULESSIRATFILE );

            EtBoolRegReadCipher( etb, keyCopy.m_hKey, (char *) &szPICSRULESSIUSEEMBEDDED );
            iTemp=(int) etb.Get();
            pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.Set(&iTemp);

            EtBoolRegReadCipher( etb, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUUNAVAILABLE );
            iTemp=(int) etb.Get();
            pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.Set(&iTemp);
        }
    }

    {
        CRegKey             keySubKey;

        //Read in OptExtension Structures
        lError = keySubKey.Open( hKey, szPICSRULESOPTEXTENSION, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumExtensions=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMOPTEXTENSIONS );
            dwNumExtensions=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESOPTEXTENSION keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPROptExtensionBeingCopied=new PICSRulesOptExtension;

                if(pPROptExtensionBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesOptExtension Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPROptExtension.Append(pPROptExtensionBeingCopied);

            EtStringRegReadCipher( pPROptExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTNAME );
            EtStringRegReadCipher( pPROptExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTSHORTNAME );
        }
    }

    {
        CRegKey             keySubKey;

        //Read in ReqExtension Structures
        lError = keySubKey.Open( hKey, szPICSRULESREQEXTENSION, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            dwNumExtensions=0;
        }
        else
        {
            EtNumRegReadCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMREQEXTENSIONS );
            dwNumExtensions=etn.Get();
        }

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Open( keySubKey.m_hKey, szNumber, KEY_READ );

            if(lError!=ERROR_SUCCESS)
            {
                TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed szPICSRULESREQEXTENSION keyCopy Open szNumber='%s'!", szNumber );
                return(E_FAIL);
            }
            else
            {
                pPRReqExtensionBeingCopied=new PICSRulesReqExtension;

                if(pPRReqExtensionBeingCopied==NULL)
                {
                    TraceMsg( TF_WARNING, "ReadSystemFromRegistry() - Failed PICSRulesReqExtension Creation!" );
                    PICSRulesOutOfMemory();
                    return(E_OUTOFMEMORY);
                }
            }

            pPRRSBeingCopied->m_arrpPRReqExtension.Append(pPRReqExtensionBeingCopied);

            EtStringRegReadCipher( pPRReqExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTNAME );
            EtStringRegReadCipher( pPRReqExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTSHORTNAME );
        }
    }

    // Insure the Copied Rating System is not deleted.
    readRatingSystem.ValidRatingSystem();

    TraceMsg( TF_ALWAYS, "ReadSystemFromRegistry() - Successfully Read PICS Rules from Registry!" );

    return(NOERROR);
}

HRESULT CopySubPolicyExpressionToRegistry(PICSRulesPolicyExpression * pPRPolicyExpressionBeingCopied,HKEY hKeyExpression)
{
    ETB  etb;
    ETN  etn;
    long lError;

    etb.Set(pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
    EtBoolRegWriteCipher(etb,hKeyExpression,(char *) szPICSRULESEXPRESSIONEMBEDDED);

    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONSERVICENAME);
    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrCategoryName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONCATEGORYNAME);
    EtStringRegWriteCipher(pPRPolicyExpressionBeingCopied->m_etstrFullServiceName,hKeyExpression,(char *) &szPICSRULESEXPRESSIONFULLSERVICENAME);

    etn.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONVALUE);

    etn.Set(pPRPolicyExpressionBeingCopied->m_PROPolicyOperator);
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR);

    etn.Set(pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded);
    EtNumRegWriteCipher(etn,hKeyExpression,(char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED);

    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
        CRegKey                     keyExpressionSubKey;

        lError = keyExpressionSubKey.Create( hKeyExpression, szPICSRULESEXPRESSIONLEFT );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed Registry Key Creation LEFT '%s' Expression!", szPICSRULESEXPRESSIONLEFT );
            return(E_FAIL);
        }

        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

        if ( FAILED( CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed LEFT CopySubPolicyExpressionToRegistry() Recursive Call!" );
            return(E_FAIL);
        }
    }

    if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
    {
        PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
        CRegKey                     keyExpressionSubKey;

        lError = keyExpressionSubKey.Create( hKeyExpression, szPICSRULESEXPRESSIONRIGHT );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed Registry Key Creation RIGHT '%s' Expression!", szPICSRULESEXPRESSIONRIGHT );
            return(E_FAIL);
        }

        pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

        if ( FAILED( CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
        {
            TraceMsg( TF_WARNING, "CopySubPolicyExpressionToRegistry() - Failed RIGHT CopySubPolicyExpressionToRegistry() Recursive Call!" );
            return(E_FAIL);
        }
    }

    return(NOERROR);
}

HRESULT WriteSystemToRegistry(HKEY hKey,PICSRulesRatingSystem **ppPRRS)
{
    PICSRulesRatingSystem       * pPRRSBeingCopied;
    PICSRulesPolicy             * pPRPolicyBeingCopied;
    PICSRulesPolicyExpression   * pPRPolicyExpressionBeingCopied;
    PICSRulesServiceInfo        * pPRServiceInfoBeingCopied;
    PICSRulesOptExtension       * pPROptExtensionBeingCopied;
    PICSRulesReqExtension       * pPRReqExtensionBeingCopied;
    PICSRulesName               * pPRNameBeingCopied;
    PICSRulesSource             * pPRSourceBeingCopied;
    PICSRulesByURL              * pPRByURLToCopy;
    PICSRulesByURLExpression    * pPRByURLExpressionToCopy;
    ETN                         etn;
    ETB                         etb;
    long                        lError;
    char                        szNumber[MAX_PATH];

    pPRRSBeingCopied=*ppPRRS;

    if(pPRRSBeingCopied==NULL)
    {
        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - pPRRSBeingCopied is NULL!" );
        return(E_INVALIDARG);
    }

    EtStringRegWriteCipher( pPRRSBeingCopied->m_etstrFile, hKey, (char *) &szPICSRULESFILENAME );
    EtNumRegWriteCipher( pPRRSBeingCopied->m_etnPRVerMajor, hKey, (char *) &szPICSRULESVERMAJOR );
    EtNumRegWriteCipher( pPRRSBeingCopied->m_etnPRVerMinor, hKey, (char *) &szPICSRULESVERMINOR );

    etn.Set(pPRRSBeingCopied->m_dwFlags);
    EtNumRegWriteCipher( etn, hKey, (char *) &szPICSRULESDWFLAGS );

    etn.Set(pPRRSBeingCopied->m_nErrLine);
    EtNumRegWriteCipher( etn, hKey, (char *) &szPICSRULESERRLINE );

    if((pPRRSBeingCopied->m_pPRName)!=NULL)
    {
        CRegKey             keySubKey;

        lError = keySubKey.Create( hKey, szPICSRULESPRNAME );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRNAME='%s' Key!", szPICSRULESPRNAME );
            return(E_FAIL);
        }

        pPRNameBeingCopied=pPRRSBeingCopied->m_pPRName;

        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrRuleName, hKey, (char *) &szPICSRULESSYSTEMNAME );
        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrRuleName, keySubKey.m_hKey, (char *) &szPICSRULESRULENAME );
        EtStringRegWriteCipher( pPRNameBeingCopied->m_etstrDescription, keySubKey.m_hKey, (char *) &szPICSRULESDESCRIPTION );
    }

    if((pPRRSBeingCopied->m_pPRSource)!=NULL)
    {
        CRegKey             keySubKey;

        lError = keySubKey.Create( hKey, szPICSRULESPRSOURCE );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRSOURCE='%s' Key!", szPICSRULESPRSOURCE );
            return(E_FAIL);
        }

        pPRSourceBeingCopied=pPRRSBeingCopied->m_pPRSource;

        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prURLSourceURL, keySubKey.m_hKey, (char *) &szPICSRULESSOURCEURL );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_etstrCreationTool, keySubKey.m_hKey, (char *) &szPICSRULESCREATIONTOOL );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prEmailAuthor, keySubKey.m_hKey, (char *) &szPICSRULESEMAILAUTHOR );
        EtStringRegWriteCipher( pPRSourceBeingCopied->m_prDateLastModified, keySubKey.m_hKey, (char *) &szPICSRULESLASTMODIFIED );
    }

    if(pPRRSBeingCopied->m_arrpPRPolicy.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESPRPOLICY );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPRPOLICY='%s' Key!", szPICSRULESPRPOLICY );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRPolicy.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMPOLICYS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRPolicy.Length());dwSubCounter++)
        {
            DWORD dwPolicyExpressionSubCounter;

            wsprintf(szNumber,"%d",dwSubCounter);

            CRegKey                 keyCopy;

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRPolicy szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRPolicyBeingCopied=pPRRSBeingCopied->m_arrpPRPolicy[dwSubCounter];

            EtStringRegWriteCipher( pPRPolicyBeingCopied->m_etstrExplanation, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYEXPLANATION );

            etn.Set(pPRPolicyBeingCopied->m_PRPolicyAttribute);
            EtNumRegWriteCipher( etn, keyCopy.m_hKey, (char *) &szPICSRULESPOLICYATTRIBUTE );

            CRegKey                 keyExpression;

            lError = keyExpression.Create( keyCopy.m_hKey, szPICSRULESPOLICYSUB );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESPOLICYSUB='%s' Key!", szPICSRULESPOLICYSUB );
                return(E_FAIL);
            }

            pPRByURLToCopy=NULL;
            pPRPolicyExpressionBeingCopied=NULL;

            switch(pPRPolicyBeingCopied->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRAcceptByURL;
                
                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    pPRByURLToCopy=pPRPolicyBeingCopied->m_pPRRejectByURL;

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectIf;

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptIf;

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRRejectUnless;

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    pPRPolicyExpressionBeingCopied=pPRPolicyBeingCopied->m_pPRAcceptUnless;

                    break;
                }
            }

            if(pPRByURLToCopy!=NULL)
            {
                etn.Set(pPRByURLToCopy->m_arrpPRByURL.Length());
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESNUMBYURL );

                for(dwPolicyExpressionSubCounter=0;
                    dwPolicyExpressionSubCounter<(DWORD) (pPRByURLToCopy->m_arrpPRByURL.Length());
                    dwPolicyExpressionSubCounter++)
                {
                    CRegKey         keyByURL;

                    wsprintf(szNumber,"%d",dwPolicyExpressionSubCounter);

                    lError = keyByURL.Create( keyExpression.m_hKey, szNumber );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRByURL szNumber='%s' Key!", szNumber );
                        return(E_FAIL);
                    }

                    pPRByURLExpressionToCopy=pPRByURLToCopy->m_arrpPRByURL[dwPolicyExpressionSubCounter];

                    etb.Set(pPRByURLExpressionToCopy->m_fInternetPattern);
                    EtBoolRegWriteCipher( etb, keyByURL.m_hKey, (char *) szPICSRULESBYURLINTERNETPATTERN );

                    etn.Set(pPRByURLExpressionToCopy->m_bNonWild);
                    EtNumRegWriteCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLNONWILD );

                    etn.Set(pPRByURLExpressionToCopy->m_bSpecified);
                    EtNumRegWriteCipher( etn, keyByURL.m_hKey, (char *) szPICSRULESBYURLSPECIFIED );

                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrScheme, keyByURL.m_hKey, (char *) &szPICSRULESBYURLSCHEME );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrUser, keyByURL.m_hKey, (char *) &szPICSRULESBYURLUSER );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrHost, keyByURL.m_hKey, (char *) &szPICSRULESBYURLHOST );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrPort, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPORT );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrPath, keyByURL.m_hKey, (char *) &szPICSRULESBYURLPATH );
                    EtStringRegWriteCipher( pPRByURLExpressionToCopy->m_etstrURL, keyByURL.m_hKey, (char *) &szPICSRULESBYURLURL );
                }
            }

            if(pPRPolicyExpressionBeingCopied!=NULL)
            {
                etb.Set(pPRPolicyExpressionBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
                EtBoolRegWriteCipher( etb, keyExpression.m_hKey, (char *) szPICSRULESEXPRESSIONEMBEDDED );

                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONSERVICENAME );
                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrCategoryName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONCATEGORYNAME );
                EtStringRegWriteCipher( pPRPolicyExpressionBeingCopied->m_etstrFullServiceName, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONFULLSERVICENAME );

                etn.Set(pPRPolicyExpressionBeingCopied->m_etnValue.Get());
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONVALUE );

                etn.Set(pPRPolicyExpressionBeingCopied->m_PROPolicyOperator);
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONPOLICYOPERATOR );

                etn.Set(pPRPolicyExpressionBeingCopied->m_PRPEPolicyEmbedded);
                EtNumRegWriteCipher( etn, keyExpression.m_hKey, (char *) &szPICSRULESEXPRESSIONOPPOLICYEMBEDDED );

                if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft!=NULL)
                {
                    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                    CRegKey                     keyExpressionSubKey;

                    lError = keyExpressionSubKey.Create( keyExpression.m_hKey, szPICSRULESEXPRESSIONLEFT );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESEXPRESSIONLEFT='%s' Key!", szPICSRULESEXPRESSIONLEFT );
                        return(E_FAIL);
                    }

                    pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionLeft;

                    if ( FAILED( CopySubPolicyExpressionToRegistry( pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey ) ) )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed LEFT CopySubPolicyExpressionToRegistry() Call!" );
                        return(E_FAIL);
                    }
                }

                if(pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight!=NULL)
                {
                    PICSRulesPolicyExpression * pPRSubPolicyExpressionToCopy;
                    CRegKey                     keyExpressionSubKey;

                    lError = keyExpressionSubKey.Create( keyExpression.m_hKey, szPICSRULESEXPRESSIONRIGHT );
                    if ( lError != ERROR_SUCCESS )
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESEXPRESSIONRIGHT='%s' Key!", szPICSRULESEXPRESSIONRIGHT );
                        return(E_FAIL);
                    }

                    pPRSubPolicyExpressionToCopy=pPRPolicyExpressionBeingCopied->m_pPRPolicyExpressionRight;

                    if(FAILED(CopySubPolicyExpressionToRegistry(pPRSubPolicyExpressionToCopy, keyExpressionSubKey.m_hKey )))
                    {
                        TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed RIGHT CopySubPolicyExpressionToRegistry() Call!" );
                        return(E_FAIL);
                    }
                }
            }
        }
    }

    if(pPRRSBeingCopied->m_arrpPRServiceInfo.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESSERVICEINFO );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESSERVICEINFO='%s' Key!", szPICSRULESSERVICEINFO );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRServiceInfo.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMSERVICEINFO );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRServiceInfo.Length());dwSubCounter++)
        {
            CRegKey             keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRServiceInfo szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRServiceInfoBeingCopied=pPRRSBeingCopied->m_arrpPRServiceInfo[dwSubCounter];

            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_prURLName, keyCopy.m_hKey, (char *) &szPICSRULESSIURLNAME );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_prURLBureauURL, keyCopy.m_hKey, (char *) &szPICSRULESSIBUREAUURL );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESSISHORTNAME );
            EtStringRegWriteCipher( pPRServiceInfoBeingCopied->m_etstrRatfile, keyCopy.m_hKey, (char *) &szPICSRULESSIRATFILE );

            etb.Set(pPRServiceInfoBeingCopied->m_prYesNoUseEmbedded.GetYesNo());
            EtBoolRegWriteCipher( etb, keyCopy.m_hKey,(char *) &szPICSRULESSIUSEEMBEDDED );

            etb.Set(pPRServiceInfoBeingCopied->m_prPassFailBureauUnavailable.GetPassFail());
            EtBoolRegWriteCipher( etb, keyCopy.m_hKey,(char *) &szPICSRULESSIBUREAUUNAVAILABLE );
        }
    }

    if(pPRRSBeingCopied->m_arrpPROptExtension.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESOPTEXTENSION );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESOPTEXTENSION='%s' Key!", szPICSRULESOPTEXTENSION );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPROptExtension.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMOPTEXTENSIONS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPROptExtension.Length());dwSubCounter++)
        {
            CRegKey         keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPROptExtension szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPROptExtensionBeingCopied=pPRRSBeingCopied->m_arrpPROptExtension[dwSubCounter];

            EtStringRegWriteCipher( pPROptExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTNAME );
            EtStringRegWriteCipher( pPROptExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESOPTEXTSHORTNAME );
        }
    }

    if(pPRRSBeingCopied->m_arrpPRReqExtension.Length()>0)
    {
        CRegKey             keySubKey;
        DWORD dwSubCounter;

        lError = keySubKey.Create( hKey, szPICSRULESREQEXTENSION );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create szPICSRULESREQEXTENSION='%s' Key!", szPICSRULESREQEXTENSION );
            return(E_FAIL);
        }

        etn.Set(pPRRSBeingCopied->m_arrpPRReqExtension.Length());
        EtNumRegWriteCipher( etn, keySubKey.m_hKey, (char *) &szPICSRULESNUMREQEXTENSIONS );

        for(dwSubCounter=0;dwSubCounter<(DWORD) (pPRRSBeingCopied->m_arrpPRReqExtension.Length());dwSubCounter++)
        {
            CRegKey             keyCopy;

            wsprintf(szNumber,"%d",dwSubCounter);

            lError = keyCopy.Create( keySubKey.m_hKey, szNumber );
            if ( lError != ERROR_SUCCESS )
            {
                TraceMsg( TF_WARNING, "WriteSystemToRegistry() - Failed to Create m_arrpPRReqExtension szNumber='%s' Key!", szNumber );
                return(E_FAIL);
            }

            pPRReqExtensionBeingCopied=pPRRSBeingCopied->m_arrpPRReqExtension[dwSubCounter];

            EtStringRegWriteCipher( pPRReqExtensionBeingCopied->m_prURLExtensionName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTNAME );
            EtStringRegWriteCipher( pPRReqExtensionBeingCopied->m_etstrShortName, keyCopy.m_hKey, (char *) &szPICSRULESREQEXTSHORTNAME );
        }
    }

    TraceMsg( TF_ALWAYS, "WriteSystemToRegistry() - Successfully Created PICS Rules in Registry!" );

    return(NOERROR);
}

//*******************************************************************
//*
//* Code for saving and reading processed PICSRules from the registry
//*
//*******************************************************************
HRESULT WritePICSRulesToRegistry(LPCTSTR lpszUserName,HKEY hkeyUser,DWORD dwSystemToSave,PICSRulesRatingSystem **ppPRRS)
{
    long    lError;
    char    *lpszSystemNumber;
    HRESULT hRes;

    lpszSystemNumber=(char *) GlobalAlloc(GPTR,MAX_PATH);

    if(lpszSystemNumber==NULL)
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - lpszSystemNumber is NULL!" );
        return(E_OUTOFMEMORY);
    }

    CRegKey             keyWrite;

    lError = keyWrite.Create( hkeyUser, lpszUserName );
    if ( lError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - Failed to Create lpszUserName='%s' Key!", lpszUserName );
        return(E_FAIL);
    }

    wsprintf(lpszSystemNumber,"%d",dwSystemToSave);

    CRegKey             keyNumbered;

    lError = keyNumbered.Create( keyWrite.m_hKey, lpszSystemNumber );
    if ( lError != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "WritePICSRulesToRegistry() - Failed to Create lpszSystemNumber='%s' Key!", lpszSystemNumber );
        return(E_FAIL);
    }

    hRes = WriteSystemToRegistry( keyNumbered.m_hKey, ppPRRS );

    GlobalFree(lpszSystemNumber);
    lpszSystemNumber = NULL;

    return(hRes);
}

HRESULT PICSRulesSaveToRegistry(DWORD dwSystemToSave,PICSRulesRatingSystem **ppPRRS)
{
    HRESULT hRes;
    CRegistryHive       rh;
    CRegKey             keyUser;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to save to
    }

    //load the hive file
    if ( gPRSI->fStoreInRegistry )
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //write information to the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        hRes = WritePICSRulesToRegistry( lpszUsername, keyUser.m_hKey, dwSystemToSave, ppPRRS );

        keyUser.Close();

        if ( FAILED(hRes) )
        {
            TraceMsg( TF_WARNING, "PICSRulesSaveToRegistry() - WritePICSRulesToRegistry Failed with hRes=0x%x!", hRes );
            return(hRes);
        }
    }
    else
    {
        // failed to create the registry key
        hRes = E_FAIL;
    }

    return(hRes);
}

HRESULT PICSRulesReadFromRegistry(DWORD dwSystemToRead, PICSRulesRatingSystem **ppPRRS)
{
    long            lError;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        lError = keyUser.Open( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS, KEY_READ );
    }
    else
    {
        if ( rh.OpenHiveFile( false ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            lError = keyUser.Open( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS, KEY_READ );
        }
    }

    //read information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 
        TCHAR szSystem[20];

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        CRegKey         keyWrite;

        lError = keyWrite.Open( keyUser.m_hKey, lpszUsername, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed keyWrite lpszUsername='%s' Key Open!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        wnsprintf(szSystem,ARRAYSIZE(szSystem),"%d",dwSystemToRead);

        CRegKey         keySystem;

        lError = keySystem.Open( keyWrite.m_hKey, szSystem, KEY_READ );

        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed keySystem lpszSystem='%s' Key Open!", szSystem );
        }

        if( lError != ERROR_SUCCESS )
        {
            keyWrite.Close();
            keyUser.Close();
            return(E_FAIL);
        }

        HRESULT     hr = ReadSystemFromRegistry( keySystem.m_hKey, ppPRRS );

        keySystem.Close();
        keyWrite.Close();
        keyUser.Close();

        if ( FAILED( hr ) )
        {
            TraceMsg( TF_WARNING, "PICSRulesReadFromRegistry() - Failed ReadSystemFromRegistry()!" );
            return(E_FAIL);
        }
    }

    return(S_OK);
}

HRESULT PICSRulesDeleteSystem(DWORD dwSystemToDelete)
{
    long            lError;
    char            * lpszSystem;
    CRegistryHive   rh;
    CRegKey         keyUser;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    //load the hive file
    if ( gPRSI->fStoreInRegistry )
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //delete information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        CRegKey         keyWrite;
        LPCTSTR         lpszUsername;

        lpszUsername = gPRSI->pUserObject->nlsUsername.QueryPch();

        lError = keyWrite.Create( keyUser.m_hKey, lpszUsername );
        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesDeleteSystem() - Failed to Create lpszUsername='%s' Key!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        lpszSystem=(char *) GlobalAlloc(GPTR,MAX_PATH);

        wsprintf(lpszSystem,"%d",dwSystemToDelete);

        MyRegDeleteKey( keyWrite.m_hKey, lpszSystem );

        GlobalFree(lpszSystem);
        lpszSystem = NULL;

        keyWrite.Close();
        keyUser.Close();
    }

    return(NOERROR);
}

HRESULT PICSRulesGetNumSystems(DWORD * pdwNumSystems)
{
    long            lError;

    if (pdwNumSystems)
    {
        *pdwNumSystems = 0;
    }

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to read from
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        keyUser.Open( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS, KEY_READ );
    }
    else
    {
        if ( rh.OpenHiveFile( false ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            keyUser.Open( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS, KEY_READ );
        }
    }

    //read information from the registry
    if ( keyUser.m_hKey != NULL )
    {
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        CRegKey         keyWrite;

        lError = keyWrite.Open( keyUser.m_hKey, lpszUsername, KEY_READ );

        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesGetNumSystems() - Failed keyWrite lpszUsername='%s' Key Open!", lpszUsername );
            return(E_FAIL);
        }

        DWORD           dwNumSystems;

        if ( keyWrite.QueryValue( dwNumSystems, szPICSRULESNUMSYS ) != ERROR_SUCCESS )
        {
            //no value set, so we have zero systems installed
            *pdwNumSystems = 0;
        }
        else
        {
            *pdwNumSystems = dwNumSystems;
        }

        keyWrite.Close();
        keyUser.Close();
    }

    return(NOERROR);
}

HRESULT PICSRulesSetNumSystems(DWORD dwNumSystems)
{
    long        lError;

    if(!(gPRSI->fSettingsValid)||!(gPRSI->fRatingInstalled))
    {
        return(E_INVALIDARG); //there isn't a valid ratings system to save to
    }

    CRegistryHive   rh;
    CRegKey         keyUser;

    //load the hive file
    if(gPRSI->fStoreInRegistry)
    {
        keyUser.Create( HKEY_LOCAL_MACHINE, szPICSRULESSYSTEMS );
    }
    else
    {
        if ( rh.OpenHiveFile( true ) )
        {
            ASSERT( rh.GetHiveKey().m_hKey != NULL );

            keyUser.Create( rh.GetHiveKey().m_hKey, szPICSRULESSYSTEMS );
        }
    }

    //write information to the registry
    if ( keyUser.m_hKey != NULL )
    {
        CRegKey     keyWrite;
        LPCTSTR lpszUsername; 

        lpszUsername=gPRSI->pUserObject->nlsUsername.QueryPch();

        lError = keyWrite.Create( keyUser.m_hKey, lpszUsername );
        if(lError!=ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "PICSRulesSetNumSystems() - Failed to Create keyWrite lpszUsername='%s' Key!", lpszUsername );
            keyUser.Close();
            return(E_FAIL);
        }

        lError = keyWrite.SetValue( dwNumSystems, szPICSRULESNUMSYS );

        keyWrite.Close();
        keyUser.Close();

        if ( lError != ERROR_SUCCESS )
        {
            TraceMsg( TF_WARNING, "PICSRulesSetNumSystems() - Failed to Set keyWrite dwNumSystems='%d' Value!", dwNumSystems );
            return(E_FAIL);
        }
    }

    return(NOERROR);
}

HRESULT PICSRulesCheckApprovedSitesAccess(LPCSTR lpszUrl,BOOL *fPassFail)
{
    int                     iCounter;
    PICSRulesEvaluation     PREvaluation = PR_EVALUATION_DOESNOTAPPLY;

    if(g_pApprovedPRRS==NULL)
    {
        return(E_FAIL);
    }

    if(g_lApprovedSitesGlobalCounterValue!=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter))
    {
        PICSRulesRatingSystem * pPRRS=NULL;
        HRESULT               hRes;

        hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&pPRRS);

        if(SUCCEEDED(hRes))
        {
            if(g_pApprovedPRRS!=NULL)
            {
                delete g_pApprovedPRRS;
            }

            g_pApprovedPRRS=pPRRS;
        }

        g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);
    }

    for(iCounter=0;iCounter<g_pApprovedPRRS->m_arrpPRPolicy.Length();iCounter++)
    {
        PICSRulesPolicy     * pPRPolicy;
        PICSRulesByURL      * pPRByURL;
        PICSRulesQuotedURL  PRQuotedURL;

        pPRPolicy=g_pApprovedPRRS->m_arrpPRPolicy[iCounter];

        if(pPRPolicy->m_PRPolicyAttribute==PR_POLICY_ACCEPTBYURL)
        {
            *fPassFail=PR_PASSFAIL_PASS;

            pPRByURL=pPRPolicy->m_pPRAcceptByURL;
        }
        else
        {
            *fPassFail=PR_PASSFAIL_FAIL;

            pPRByURL=pPRPolicy->m_pPRRejectByURL;
        }

        PRQuotedURL.Set(lpszUrl);

        PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

        if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
        {
            break;
        }
    }
    
    if(PREvaluation==PR_EVALUATION_DOESAPPLY)
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}

HRESULT PICSRulesCheckAccess(LPCSTR lpszUrl,LPCSTR lpszRatingInfo,BOOL *fPassFail,CParsedLabelList **ppParsed)
{
    int                     iCounter,iSystemCounter;
    PICSRulesEvaluation     PREvaluation;
    CParsedLabelList        *pParsed=NULL;
    
    if(g_arrpPRRS.Length()==0)
    {
        return(E_FAIL);
    }

    if(g_lGlobalCounterValue!=SHGlobalCounterGetValue(g_HandleGlobalCounter))
    {
        HRESULT                 hRes;
        DWORD                   dwNumSystems;
        PICSRulesRatingSystem   * pPRRS=NULL;

        g_arrpPRRS.DeleteAll();

        //someone modified our settings, so we'd better reload them.
        hRes=PICSRulesGetNumSystems(&dwNumSystems);

        if(SUCCEEDED(hRes))
        {
            DWORD dwCounter;

            for(dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
                dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
                dwCounter++)
            {
                hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

                if(FAILED(hRes))
                {
                    char    *lpszTitle,*lpszMessage;

                    //we couldn't read in the systems, so don't inforce PICSRules,
                    //and notify the user
        
                    g_arrpPRRS.DeleteAll();

                    lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                    lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                    MLLoadString(IDS_PICSRULES_TAMPEREDREADTITLE,(LPTSTR) lpszTitle,MAX_PATH);
                    MLLoadString(IDS_PICSRULES_TAMPEREDREADMSG,(LPTSTR) lpszMessage,MAX_PATH);

                    MessageBox(NULL,(LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                    GlobalFree(lpszTitle);
                    lpszTitle = NULL;
                    GlobalFree(lpszMessage);
                    lpszMessage = NULL;

                    break;
                }
                else
                {
                    g_arrpPRRS.Append(pPRRS);

                    pPRRS=NULL;
                }
            }
        }

        g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);
    }

    if(lpszRatingInfo!=NULL)
    {
        ParseLabelList(lpszRatingInfo,ppParsed);
        pParsed=*ppParsed;
    }

    for(iSystemCounter=0;iSystemCounter<g_arrpPRRS.Length();iSystemCounter++)
    {
        PICSRulesRatingSystem * pPRRSCheck;

        pPRRSCheck=g_arrpPRRS[iSystemCounter];

        for(iCounter=0;iCounter<pPRRSCheck->m_arrpPRPolicy.Length();iCounter++)
        {
            PICSRulesPolicy           * pPRPolicy;
            PICSRulesPolicyExpression * pPRPolicyExpression;
            PICSRulesByURL            * pPRByURL;
            PICSRulesQuotedURL        PRQuotedURL;

            pPRPolicy=pPRRSCheck->m_arrpPRPolicy[iCounter];

            switch(pPRPolicy->m_PRPolicyAttribute)
            {
                case PR_POLICY_ACCEPTBYURL:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRByURL=pPRPolicy->m_pPRAcceptByURL;

                    PRQuotedURL.Set(lpszUrl);

                    PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

                    break;
                }
                case PR_POLICY_REJECTBYURL:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRByURL=pPRPolicy->m_pPRRejectByURL;

                    PRQuotedURL.Set(lpszUrl);

                    PREvaluation=pPRByURL->EvaluateRule(&PRQuotedURL);

                    break;
                }
                case PR_POLICY_REJECTIF:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRPolicyExpression=pPRPolicy->m_pPRRejectIf;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    break;
                }
                case PR_POLICY_ACCEPTIF:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRPolicyExpression=pPRPolicy->m_pPRAcceptIf;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    break;
                }
                case PR_POLICY_REJECTUNLESS:
                {
                    *fPassFail=PR_PASSFAIL_FAIL;

                    pPRPolicyExpression=pPRPolicy->m_pPRRejectUnless;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    if(PREvaluation==PR_EVALUATION_DOESNOTAPPLY)
                    {
                        PREvaluation=PR_EVALUATION_DOESAPPLY;
                    }
                    else
                    {
                        PREvaluation=PR_EVALUATION_DOESNOTAPPLY;
                    }

                    break;
                }
                case PR_POLICY_ACCEPTUNLESS:
                {
                    *fPassFail=PR_PASSFAIL_PASS;

                    pPRPolicyExpression=pPRPolicy->m_pPRAcceptUnless;
                    
                    PREvaluation=pPRPolicyExpression->EvaluateRule(pParsed);

                    if(PREvaluation==PR_EVALUATION_DOESNOTAPPLY)
                    {
                        PREvaluation=PR_EVALUATION_DOESAPPLY;
                    }
                    else
                    {
                        PREvaluation=PR_EVALUATION_DOESNOTAPPLY;
                    }

                    break;
                }
                case PR_POLICY_NONEVALID:
                default:
                {
                    PREvaluation=PR_EVALUATION_DOESNOTAPPLY;

                    continue;
                }
            }

            if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
            {
                break;
            }
        }

        if(PREvaluation!=PR_EVALUATION_DOESNOTAPPLY)
        {
            break;
        }
    }
    
    if(PREvaluation==PR_EVALUATION_DOESAPPLY)
    {
        return(S_OK);
    }
    else
    {
        return(E_FAIL);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\reghive.h ===
/****************************************************************************\
 *
 *   reghive.h
 *
 *   Created:   William Taylor (wtaylor) 02/13/01
 *
 *   MS Ratings Registry Hive Handling
 *
\****************************************************************************/

#ifndef REGISTRY_HIVE_H
#define REGISTRY_HIVE_H

class CRegistryHive
{
private:
    bool        m_fHiveLoaded;              // Hive Loaded?
    char        m_szPath[MAXPATHLEN+1];     // Hive File Path
    CRegKey     m_keyHive;                  // Registry Key to Hive

public:
    CRegistryHive();
    ~CRegistryHive();

    const CRegKey &     GetHiveKey( void )      { return m_keyHive; }

    void    UnloadHive( void );
    bool    OpenHiveFile( bool p_fCreate );

protected:
    bool    OpenHiveKey( void );
    void    DeleteRegistryHive( void );
    bool    CreateNewHive( int & p_riHiveFile );
    bool    SaveHiveKey( CRegKey & p_keyHive, int p_iFile );
    void    ClearHivePath( void )               { m_szPath[0] = '\0'; }
    BOOL    BuildPolName(LPSTR pBuffer, UINT cbBuffer, UINT (WINAPI *PathProvider)(LPTSTR, UINT));
    void    SetHiveName( int p_iFile );
    void    LoadHiveFile( int p_iFile );

#ifdef DEBUG
    void    EnumerateRegistryKeys( HKEY hkeyTop, LPSTR pszKeyName, int iLevel );
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\resource.h ===
#define IDB_KEYS                         99
#define IDB_LOCK                         100
#define IDB_BITMAP1                      101
#define IDI_SECURITY                     102
#define IDI_MAIN                         104
#define IDI_UNRATED                      105
#define IDI_KEYS                         106
#define IDI_MASTER_KEY                   107
#define IDD_LOGON                        108
#define IDI_RATING_CATEGORIES            109
#define IDI_RATED_SITES                  110
#define IDD_PLEASE                       111
#define IDI_RATING_SYSTEMS               112
#define IDD_GENERAL                      113
#define IDI_INTERNET_RATINGS             114
#define IDC_UNRATED                      115
#define IDC_PLEASE_MOMMY                 116
#define IDD_PICSRULES                    117
#define IDD_APPROVEDSITES                118
#define IDC_CHANGE_PASSWORD              119
#define IDI_APPROVED                     120
#define IDC_MASTER_USER                  121
#define IDC_CONTROL_PANEL                122
#define IDC_NEW_APPS                     123
#define IDD_PROVIDERS                    124
#define IDC_PROVIDERLIST                 125
#define IDC_OPENPROVIDER                 126
#define IDC_CLOSEPROVIDER                127
#define IDD_ADVANCED                     128
#define IDD_CREATE_PASSWORD              129
#define IDD_PASSWORD                     130
#define IDC_PASSWORD                     131
#define IDC_CONFIRM_PASSWORD             132
#define IDD_INTRO                        133
#define IDC_SET_RATINGS                  134
#define IDC_TURN_ONOFF                   135
#define IDC_INTRO_TEXT                   136
#define IDD_CHANGE_PASSWORD              137
#define IDC_OLD_PASSWORD                 138
#define IDD_RATINGS                      139
#define IDC_RATING_LABEL                 140
#define IDD_USER_LIST                    141
#define IDC_PG_A_EDIT                    142
#define IDC_L_COMBO                      143
#define IDC_PT_TREE                      144
#define IDC_PT_T_RSN_LDESC               145
#define IDC_PT_TB_SELECT                 146
#define IDC_PT_T_RSN_SDESC               147
#define IDC_PT_T_BITMAP_CATEGORY         148
#define IDC_PT_T_BITMAP_LABEL            149
#define IDC_ADD                          150
#define IDC_REMOVE                       151
#define IDC_PROPERTIES                   152
#define IDC_USERNAME                     153
#define IDC_APPLY                        154
#define IDC_PROVIDER                     155
#define IDB_ICON_PROVIDER                156
#define IDC_3RD_COMBO                    157
#define IDC_TEXT1                        158
#define IDC_TEXT2                        159
#define IDC_TEXT3                        160
#define IDC_STATIC1                      161
#define IDC_STATIC2                      162
#define IDC_STATIC3                      163
#define IDC_STATIC4                      164
#define IDC_STATIC5                      165
#define IDC_STATIC6                      166
#define IDC_STATIC7                      167
#define IDC_STATIC8                      168
#define IDC_STATIC9                      169
#define IDC_CREATE_PASSWORD              170
#define IDS_RAT_OPENFILE                 225
#define IDS_RAT_FILTER_DESC              226
#define IDS_RAT_FILTER                   227
#define IDS_NOCANDO_TITLE                228
#define IDS_NOCANDO                      229
#define IDS_RATING_OFF                   230
#define IDS_RATING_ON                    231
#define IDS_TURN_ON                      232
#define IDS_TURN_OFF                     233
#define IDS_GENERIC                      234
#define IDS_NOW_ON                       235
#define IDS_NOW_OFF                      236
#define IDS_NO_PASSWORD                  237
#define IDS_NO_CONFIRM                   238
#define IDS_NO_MATCH                     239
#define IDS_BADPASSWORD                  240
#define IDS_NO_OLD                       241
#define IDS_NO_PROVIDERS                 242
#define IDS_INSTALL_INFO                 243
#define IDS_TURN_ONOFF                   244
#define IDS_RATING_NEW                   245
#define IDS_BADBUREAU                    246
#define IDS_VALUE                        247
#define IDS_NEEDBUREAU                   248
#define IDS_CANT_LAUNCH                  249
#define IDS_PASSWORD_CHANGED             250
#define IDS_RATINGTEMPLATE               251
#define IDS_UNRATED                      252
#define IDS_UNKNOWNSYSTEM                253
#define IDS_INVALIDRATING                254
#define IDS_EXPIRED                      255
#define IDS_WRONGURL                     256
#define IDS_LABELERROR                   257
#define IDS_UNKNOWNRATING                258
#define IDS_UNKNOWNRATINGTEMPLATE        259
#define IDS_NOWENABLED                   260
#define IDS_LOADRAT_MEMORY               261
#define IDS_LOADRAT_EXPECTEDLEFT         262
#define IDS_LOADRAT_EXPECTEDRIGHT        263
#define IDS_LOADRAT_EXPECTEDTOKEN        264
#define IDS_LOADRAT_EXPECTEDSTRING       265
#define IDS_LOADRAT_EXPECTEDNUMBER       266
#define IDS_LOADRAT_EXPECTEDBOOL         267
#define IDS_LOADRAT_DUPLICATEITEM        268
#define IDS_LOADRAT_MISSINGITEM          269
#define IDS_LOADRAT_UNKNOWNITEM          270
#define IDS_LOADRAT_UNKNOWNMANDATORY     271
#define IDS_LOADRAT_UNKNOWNERROR         272
#define IDS_LOADRAT_WINERROR             273
#define IDS_LOADRAT_MISCERROR            274
#define IDS_LOADRAT_SYNTAX_TEMPLATE      275
#define IDS_LOADRAT_GENERIC_TEMPLATE     276
#define IDS_INVALID_PROVIDERS            277
#define IDS_ALREADY_INSTALLED            278
#define IDS_NO_BUREAU                    279
#define IDS_NO_SETTINGS                  280
#define IDS_DESCRIPTION_SEPARATOR        281
#define IDS_FRAME                        282
#define IDS_ENABLE_WARNING               283
#define IDS_PICSRULES_SYNTAX_TEMPLATE    284
#define IDS_PICSRULES_GENERIC_TEMPLATE   285
#define IDS_PICSRULES_MEMORY             286
#define IDS_PICSRULES_EXPECTEDLEFT       287
#define IDS_PICSRULES_EXPECTEDRIGHT      288
#define IDS_PICSRULES_EXPECTEDTOKEN      289
#define IDS_PICSRULES_EXPECTEDSTRING     290
#define IDS_PICSRULES_EXPECTEDNUMBER     291
#define IDS_PICSRULES_EXPECTEDBOOL       292
#define IDS_PICSRULES_DUPLICATEITEM      293
#define IDS_PICSRULES_MISSINGITEM        294
#define IDS_PICSRULES_UNKNOWNITEM        295
#define IDS_PICSRULES_UNKNOWNMANDATORY   296
#define IDS_PICSRULES_UNKNOWNERROR       297
#define IDS_PICSRULES_WINERROR           298
#define IDS_PICSRULES_MISCERROR          299
#define IDS_ERROR                        300
#define IDS_PICSRULES_INVALID            301
#define IDS_PICSRULES_SERVICEUNDEFINED   302
#define IDS_OPENDIALOGFILTER             303
#define IDS_OPENDIALOGTITLE              304
#define IDS_PICSRULES_REQEXTENSIONUSED   305
#define IDS_PICSRULES_BADVERSION         306
#define IDS_PICSRULES_EXPECTEDEND        307
#define IDS_PICSRULES_SYSTEMERROR        308
#define IDS_PICSRULES_TAMPEREDTITLE      309
#define IDS_PICSRULES_TAMPEREDMESSAGE    310
#define IDS_PICSRULES_EXISTSTITLE        311
#define IDS_PICSRULES_EXISTSMESSAGE      312
#define IDS_PICSRULES_ERRORSAVINGTITLE   313
#define IDS_PICSRULES_ERRORSAVINGMSG     314
#define IDS_PICSRULES_SUCCESSTITLE       315
#define IDS_PICSRULES_SUCCESSMESSAGE     316
#define IDS_PICSRULES_TAMPEREDREADTITLE  317
#define IDS_PICSRULES_TAMPEREDREADMSG    318
#define IDI_ACCEPTALWAYS                 319
#define IDI_ACCEPTNEVER                  320
#define IDS_PICSRULES_DUPLICATETITLE     321
#define IDS_PICSRULES_DUPLICATEMSG       322
#define IDS_PICSRULES_BADURLTITLE        323
#define IDS_PICSRULES_BADURLMSG          324
#define IDS_PICSRULES_OUTOFMEMORY        325
#define IDS_PICSRULES_NOAPPROVEDSAVE     326
#define IDS_APPROVEDSITES_ENFORCED       327
#define IDS_PICSRULES_ENFORCED           328
#define IDC_BLOCKING_SITE                329
#define IDC_BLOCKING_PAGE                330
#define IDC_BLOCKING_ONCE                331
#define IDS_APPROVED_CANTSAVE            332
#define IDS_LOADRAT_EXPECTEDEND          333
#define IDS_NO_NULL_PASSWORD             334
#define IDC_PICSRULES_DOWN               335
#define IDI_PICSRULES_UP                 336
#define IDI_PICSRULES_DOWN               337
#define IDB_SYSTEMS                      338
#define IDB_CATEGORIES                   339
#define IDC_ADVISOR_OFF_CHECK            340
#define IDD_TURNOFF                      341
#define IDS_SOURCE_SERVER                342
#define IDS_SOURCE_EMBEDDED              343
#define IDS_SOURCE_BUREAU                344
#define IDS_TAMPEREDRATING1              345
#define IDS_TAMPEREDRATING2              346
#define IDS_PICSRULES_CLICKIMPORTTITLE   347
#define IDS_PICSRULES_CLICKIMPORTMESSAGE 348
#define IDS_PICSRULES_CLICKIMPORTON      349
#define IDS_PICSRULES_CLICKFINISHED      350
#define IDS_PICSRULES_CLICKRATON         351
#define IDS_PICSRULES_CLICKRATMESSAGE    352
#define IDD_PRFPASSWORDNOEXIST           353
#define IDD_PRFPASSWORDEXISTS            354
#define IDC_PRFPASSWORD                  355
#define IDC_RATPASSWORD                  356
#define IDD_RATPASSWORDEXISTS            357
#define IDD_RATPASSWORDNOEXIST           358
#define IDS_PASSWORD_LABEL              500
#define IDS_PICS_RULES_LABEL            501
#define IDS_RATING_SYSTEM_LABEL         502
#define IDS_NO_HINT                     503
#define IDS_HINT_RECOMMENDED            504
#define IDS_REGISTRY_NOT_MODIFIABLE     505
#define IDS_PASSWORD_CREATED            506
#define IDS_CREATE_PASSWORD             507
#define IDS_CHANGE_PASSWORD             508
#define IDC_FINDRATINGS                  1000
#define IDC_PICSRULES_SPIN               1002
#define IDC_PICSRULES_LIST               1004
#define IDC_DETAILSBUTTON                1005
#define IDC_PICSRULES_UP                 1005
#define IDC_CONTENTLABEL                 1006
#define IDC_CONTENTDESCRIPTION           1007
#define IDC_CONTENTERROR                 1008
#define IDC_PICSRULESOPEN                1009
#define IDC_PICSRULESEDIT                1010
#define IDC_PICSRULESAPPROVEDEDIT        1011
#define IDC_PICSRULESAPPROVEDALWAYS      1012
#define IDC_PICSRULESAPPROVEDLIST        1014
#define IDC_PICSRULESAPPROVEDREMOVE      1015
#define IDC_STATIC_ALLOW                 1017
#define IDC_PICSRULESAPPROVEDNEVER       1018
#define IDC_STATIC_LIST                  1019
#define IDC_PICSRULESAPPROVEDCOMMBAND    1020
#define IDC_STATIC_COMMBAND1             1021
#define IDC_STATIC_COMMBAND2             1022
#define IDC_STATIC_PICSRULES             1023
#define IDC_STATIC_PICSRULES2            1024
#define IDC_HINT_EDIT                   1001
#define IDC_HINT_TEXT                   1002
#define IDC_HINT_LABEL                  1003
#define IDC_OLD_HINT_LABEL              1004
#define IDC_OLD_HINT_TEXT               1005
#define IDS_RATING_SYSTEM_FILE           3000
#define IDS_PICS_RULES_FILE              3001
#define IDS_CONTENT_ADVISOR_TITLE        3002
#define IDS_CONTENT_ADVISOR_HTTP_TITLE   3003
#define IDC_STATIC                       (-1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\ratings.cpp ===
/****************************************************************************\
 *
 *   RATINGS.CPP --Parses out the actual ratings from a site.
 *
 *   Created:   Ann McCurdy
 *     
\****************************************************************************/

/*Includes---------------------------------------------------------*/
#include "msrating.h"
#include "mslubase.h"
#include "debug.h"
#include <ratings.h>
#include <ratingsp.h>
#include "parselbl.h"
#include "picsrule.h"
#include "pleasdlg.h"       // CPleaseDialog
#include <convtime.h>
#include <contxids.h>
#include <shlwapip.h>


#include <wininet.h>

#include <mluisupp.h>

extern PICSRulesRatingSystem * g_pPRRS;
extern array<PICSRulesRatingSystem*> g_arrpPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRS;
extern PICSRulesRatingSystem * g_pApprovedPRRSPreApply;
extern array<PICSRulesRatingSystem*> g_arrpPICSRulesPRRSPreApply;

extern BOOL g_fPICSRulesEnforced,g_fApprovedSitesEnforced;

extern HMODULE g_hURLMON,g_hWININET;

extern char g_szLastURL[INTERNET_MAX_URL_LENGTH];

extern HINSTANCE g_hInstance;

HANDLE g_HandleGlobalCounter,g_ApprovedSitesHandleGlobalCounter;
long   g_lGlobalCounterValue,g_lApprovedSitesGlobalCounterValue;

DWORD g_dwDataSource;
BOOL  g_fInvalid;

PicsRatingSystemInfo *gPRSI = NULL;


//7c9c1e2a-4dcd-11d2-b972-0060b0c4834d
const GUID GUID_Ratings = { 0x7c9c1e2aL, 0x4dcd, 0x11d2, { 0xb9, 0x72, 0x00, 0x60, 0xb0, 0xc4, 0x83, 0x4d } };

//7c9c1e2b-4dcd-11d2-b972-0060b0c4834d
const GUID GUID_ApprovedSites = { 0x7c9c1e2bL, 0x4dcd, 0x11d2, { 0xb9, 0x72, 0x00, 0x60, 0xb0, 0xc4, 0x83, 0x4d } };


extern CustomRatingHelper *g_pCustomRatingHelperList;
BOOL g_fIsRunningUnderCustom = FALSE;

void TerminateRatings(BOOL bProcessDetach);

//+-----------------------------------------------------------------------
//
//  Function:  RatingsCustomInit
//
//  Synopsis:  Initialize the msrating dll for Custom
//
//  Arguments: bInit (Default TRUE) - TRUE: change into Custom Mode
//                                    FALSE: change out of Custom Mode
//
//  Returns:   S_OK if properly initialized, E_OUTOFMEMORY otherwise
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomInit(BOOL bInit)
{
    HRESULT hres = E_OUTOFMEMORY;

    ENTERCRITICAL;

    if (bInit)
    {
        if (NULL != gPRSI)
        {
            delete gPRSI;
        }
        gPRSI = new PicsRatingSystemInfo;
        if (gPRSI)
        {
            g_fIsRunningUnderCustom = TRUE;
            hres = S_OK;
        }
    }
    else
    {
        TerminateRatings(FALSE);
        RatingInit();
        g_fIsRunningUnderCustom = FALSE;
        hres = S_OK;
    }
    LEAVECRITICAL;

    return hres;
    
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomAddRatingSystem
//
//  Synopsis:  Hand the description of a PICS rating system file to msrating.
//             The description is simply the contents of an RAT file.
//
//  Arguments: pszRatingSystemBuffer : buffer containing the description
//             nBufferSize : the size of pszRatingSystemBuffer
//
//  Returns:   Success if rating system added
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
STDAPI RatingCustomAddRatingSystem(LPSTR pszRatingSystemBuffer, UINT nBufferSize)
{
    HRESULT hres = E_OUTOFMEMORY;

    if(!pszRatingSystemBuffer || nBufferSize == 0)
    {
        return E_INVALIDARG;
    }

    if (g_fIsRunningUnderCustom)
    {
        PicsRatingSystem* pPRS = new PicsRatingSystem;
 
        if (pPRS)
        {
            hres = pPRS->Parse(NULL, pszRatingSystemBuffer);
            if (SUCCEEDED(hres))
            {
                pPRS->dwFlags |= PRS_ISVALID;
            }
        }
        
        if (SUCCEEDED(hres))
        {
            ENTERCRITICAL;
        
            gPRSI->arrpPRS.Append(pPRS);
            gPRSI->fRatingInstalled = TRUE;

            LEAVECRITICAL;
        }
        else
        {
            if(pPRS)
            {
                delete pPRS;
                pPRS = NULL;
            }
        }
    }
    else
    {
        hres = E_FAIL;
    }
    return hres;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomSetUserOptions
//
//  Synopsis:  Set the user options for the msrating dll for this process
//
//  Arguments: pRSSetings : pointer to an array of rating system settings
//             cSettings : number of rating systems
//
//  Returns:   Success if user properly set
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomSetUserOptions(RATINGSYSTEMSETTING* pRSSettings, UINT cSettings) {

    if (!pRSSettings || cSettings == 0)
    {
        return E_INVALIDARG;
    }
    ENTERCRITICAL;

    HRESULT hres = E_OUTOFMEMORY;
    UINT err, errTemp;

    if (g_fIsRunningUnderCustom)
    {
        if (gPRSI)
        {
            PicsUser* puser = new PicsUser;

            if (puser)
            {
                for (UINT i=0; i<cSettings; i++)
                {
                    UserRatingSystem* pURS = new UserRatingSystem;
                    if (!pURS)
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                        break;
                    }
                    if (errTemp = pURS->QueryError())
                    {
                        err = errTemp;
                        break;
                    }
                    RATINGSYSTEMSETTING* parss = &pRSSettings[i];
                    
                    pURS->SetName(parss->pszRatingSystemName);
                    pURS->m_pPRS = FindInstalledRatingSystem(parss->pszRatingSystemName);
                    
                    for (UINT j=0; j<parss->cCategories; j++)
                    {
                        UserRating* pUR = new UserRating;
                        if (pUR)
                        {
                            if (errTemp = pUR->QueryError())
                            {
                                err = errTemp;
                            }
                            else
                            {
                                RATINGCATEGORYSETTING* parcs = &parss->paRCS[j];
                                pUR->SetName(parcs->pszValueName);
                                pUR->m_nValue = parcs->nValue;
                                if (pURS->m_pPRS)
                                {
                                    pUR->m_pPC = FindInstalledCategory(pURS->m_pPRS->arrpPC, parcs->pszValueName);
                                }
                                err = pURS->AddRating(pUR);
                            }
                        }
                        else
                        {
                            err = ERROR_NOT_ENOUGH_MEMORY;
                        }
                        if (ERROR_SUCCESS != err)
                        {
                            if (pUR)
                            {
                                delete pUR;
                                pUR = NULL;
                            }
                            break;
                        }
                    }
                    if (ERROR_SUCCESS == err)
                    {
                        err = puser->AddRatingSystem(pURS);
                    }
                    if (ERROR_SUCCESS != err)
                    {
                        if (pURS)
                        {
                            delete pURS;
                            pURS = NULL;
                        }
                        break;
                    }
                }
                if (ERROR_SUCCESS == err)
                {
                    hres = NOERROR;
                    gPRSI->fSettingsValid = TRUE;
                    if (gPRSI->pUserObject)
                    {
                        delete gPRSI->pUserObject;
                    }
                    gPRSI->pUserObject = puser;
                }
            }
        }
        else
        {
            hres = E_UNEXPECTED;
        }
    }
    else
    {
        hres = E_FAIL;
    }
    LEAVECRITICAL;
    
    return hres;

}


//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomAddRatingHelper
//
//  Synopsis:  Add a Custom ratings helper object
//
//  Arguments: pszLibraryName : name of the library to load the helper from
//             clsid : CLSID of the rating helper
//             dwSort : Sort order or priority of the helper
//
//  Returns:   Success if rating helper added properly set
//             This function will not succeed if RatingCustomInit has
//             not been called.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomAddRatingHelper(LPCSTR pszLibraryName, CLSID clsid, DWORD dwSort)
{ 
    HRESULT hr = E_UNEXPECTED;

    if (g_fIsRunningUnderCustom)
    {
        CustomRatingHelper* pmrh = new CustomRatingHelper;

        if(NULL == pmrh)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pmrh->hLibrary = LoadLibrary(pszLibraryName);
            if (pmrh->hLibrary)
            {
                pmrh->clsid = clsid;
                pmrh->dwSort = dwSort;

                ENTERCRITICAL;

                CustomRatingHelper* pmrhCurrent = g_pCustomRatingHelperList;
                CustomRatingHelper* pmrhPrev = NULL;

                while (pmrhCurrent && pmrhCurrent->dwSort < pmrh->dwSort)
                {
                    pmrhPrev = pmrhCurrent;
                    pmrhCurrent = pmrhCurrent->pNextHelper;
                }

                if (pmrhPrev)
                {
                    ASSERT(pmrhPrev->pNextHelper == pmrhCurrent);

                    pmrh->pNextHelper = pmrhCurrent;
                    pmrhPrev->pNextHelper = pmrh;
                }
                else
                {
                    ASSERT(pmrhCurrent == g_pCustomRatingHelperList);

                    pmrh->pNextHelper = g_pCustomRatingHelperList;
                    g_pCustomRatingHelperList = pmrh;
                }


                hr = S_OK;

                LEAVECRITICAL;
            
            } // if (pmrh->hLibrary)
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomRemoveRatingHelper
//
//  Synopsis:  Remove Custom rating helpers
//
//  Arguments: CLSID : CLSID of the helper to remove
//
//  Returns:   S_OK if rating helper removed, S_FALSE if not found
//             E_UNEXPECTED if the global custom helper list is corrupted.
//             This function will not succeed if RatingCustomInit has
//             not been called and will return E_FAIL
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomRemoveRatingHelper(CLSID clsid)
{
    CustomRatingHelper* pmrhCurrent = NULL;
    CustomRatingHelper* pmrhTemp = NULL;
    CustomRatingHelper* pmrhPrev = NULL;

    HRESULT hr = E_UNEXPECTED;

    if (g_fIsRunningUnderCustom)
    {
        if (NULL != g_pCustomRatingHelperList)
        {
            hr = S_FALSE;

            ENTERCRITICAL;
        
            pmrhCurrent = g_pCustomRatingHelperList;

            while (pmrhCurrent && pmrhCurrent->clsid != clsid)
            {
                pmrhPrev = pmrhCurrent;
                pmrhCurrent = pmrhCurrent->pNextHelper;
            }

            if (pmrhCurrent)
            {
                //
                // Snag copy of the node
                //
                pmrhTemp = pmrhCurrent;

                if (pmrhPrev)   // Not on first node
                {
                    //
                    // Unlink the deleted node
                    //
                    pmrhPrev->pNextHelper = pmrhCurrent->pNextHelper;
                }
                else            // First node -- adjust head pointer
                {
                    ASSERT(pmrhCurrent == g_pCustomRatingHelperList);

                    g_pCustomRatingHelperList = g_pCustomRatingHelperList->pNextHelper;
                }

                //
                // Wipe out the node
                //
                delete pmrhTemp;
                pmrhTemp = NULL;

                hr = S_OK;
            }

            LEAVECRITICAL;
        }
    }
    else
    {
        hr = E_FAIL;
    }
    return hr;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomSetDefaultBureau
//
//  Synopsis:  Set the URL of the default rating bureau
//
//  Arguments: pszRatingBureau - URL of the rating bureau
//
//  Returns:   S_OK if success, E_FAIL if RatingCustomInit has not been
//             called, E_OUTOFMEMORY if unable to allocate memory
//             E_INVALIDARG if pszRatingBureau is NULL
//             This function will not succeed if RatingCustomInit has
//             not been called and return E_FAIL.
//
//------------------------------------------------------------------------
HRESULT WINAPI RatingCustomSetDefaultBureau(LPCSTR pszRatingBureau)
{
    HRESULT hr;

    if (pszRatingBureau)
    {
        if (g_fIsRunningUnderCustom)
        {
            LPSTR pszTemp = new char[strlenf(pszRatingBureau)+1];
            if (pszTemp)
            {
                strcpy(pszTemp, pszRatingBureau);
                gPRSI->etstrRatingBureau.SetTo(pszTemp);
                hr = S_OK;
            } // if (pszTemp)
            else
            {
                hr = E_OUTOFMEMORY;
            }
        } // if(g_fIsRunningUnderCustom)
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT WINAPI RatingInit()
{
    DWORD                   dwNumSystems,dwCounter;
    HRESULT                 hRes;
    PICSRulesRatingSystem   * pPRRS=NULL;

    g_hURLMON=LoadLibrary("URLMON.DLL");

    if (g_hURLMON==NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - Failed to Load URLMON!" );

        g_pPRRS=NULL;                   //we couldn't load URLMON

        hRes=E_UNEXPECTED;
    }

    g_hWININET=LoadLibrary("WININET.DLL");

    if (g_hWININET==NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - Failed to Load WININET!" );

        g_pPRRS=NULL;                   //we couldn't load WININET

        hRes=E_UNEXPECTED;
    }

    g_HandleGlobalCounter=SHGlobalCounterCreate(GUID_Ratings);
    g_lGlobalCounterValue=SHGlobalCounterGetValue(g_HandleGlobalCounter);

    g_ApprovedSitesHandleGlobalCounter=SHGlobalCounterCreate(GUID_ApprovedSites);
    g_lApprovedSitesGlobalCounterValue=SHGlobalCounterGetValue(g_ApprovedSitesHandleGlobalCounter);

    gPRSI = new PicsRatingSystemInfo;
    if(gPRSI == NULL)
    {
        TraceMsg( TF_ERROR, "RatingInit() - gPRSI is NULL!" );
        return E_OUTOFMEMORY;
    }

    gPRSI->Init();

    hRes=PICSRulesReadFromRegistry(PICSRULES_APPROVEDSITES,&g_pApprovedPRRS);

    if (FAILED(hRes))
    {
        g_pApprovedPRRS=NULL;
    }

    hRes=PICSRulesGetNumSystems(&dwNumSystems);

    if (SUCCEEDED(hRes)) //we have PICSRules systems to inforce
    {
        for (dwCounter=PICSRULES_FIRSTSYSTEMINDEX;
            dwCounter<(dwNumSystems+PICSRULES_FIRSTSYSTEMINDEX);
            dwCounter++)
        {
            hRes=PICSRulesReadFromRegistry(dwCounter,&pPRRS);

            if (FAILED(hRes))
            {
                char    *lpszTitle,*lpszMessage;

                //we couldn't read in the systems, so don't inforce PICSRules,
                //and notify the user
                
                g_arrpPRRS.DeleteAll();

                lpszTitle=(char *) GlobalAlloc(GPTR,MAX_PATH);
                lpszMessage=(char *) GlobalAlloc(GPTR,MAX_PATH);

                MLLoadString(IDS_PICSRULES_TAMPEREDREADTITLE,(LPTSTR) lpszTitle,MAX_PATH);
                MLLoadString(IDS_PICSRULES_TAMPEREDREADMSG,(LPTSTR) lpszMessage,MAX_PATH);

                MessageBox(NULL,(LPCTSTR) lpszMessage,(LPCTSTR) lpszTitle,MB_OK|MB_ICONERROR);

                GlobalFree(lpszTitle);
                lpszTitle = NULL;
                GlobalFree(lpszMessage);
                lpszMessage = NULL;

                break;
            }
            else
            {
                g_arrpPRRS.Append(pPRRS);

                pPRRS=NULL;
            }
        }
    }

    return NOERROR; 
}

// YANGXU: 11/16/1999
// Actual rating term function that does the work
// bProcessDetach: pass in as true if terminating during
// ProcessDetach so libraries are not freed

void TerminateRatings(BOOL bProcessDetach)
{
    delete gPRSI;
    gPRSI = NULL;

    if (g_pApprovedPRRS != NULL)
    {
        delete g_pApprovedPRRS;
        g_pApprovedPRRS = NULL;
    }

    if (g_pApprovedPRRSPreApply != NULL)
    {
        delete g_pApprovedPRRSPreApply;
        g_pApprovedPRRSPreApply = NULL;
    }

    g_arrpPRRS.DeleteAll();
    g_arrpPICSRulesPRRSPreApply.DeleteAll();

    CloseHandle(g_HandleGlobalCounter);
    CloseHandle(g_ApprovedSitesHandleGlobalCounter);

    CustomRatingHelper  *pTemp;
    
    while (g_pCustomRatingHelperList)
    {
        pTemp = g_pCustomRatingHelperList;

        if (bProcessDetach)
        {
            // TRICKY: Can't FreeLibrary() during DLL_PROCESS_DETACH, so leak the HMODULE...
            //         (setting to NULL prevents the destructor from doing FreeLibrary()).
            //
            g_pCustomRatingHelperList->hLibrary = NULL;
        }
        
        g_pCustomRatingHelperList = g_pCustomRatingHelperList->pNextHelper;

        delete pTemp;
        pTemp = NULL;
    }

    if (bProcessDetach)
    {
        if ( g_hURLMON )
        {
            FreeLibrary(g_hURLMON);
            g_hURLMON = NULL;
        }

        if ( g_hWININET )
        {
            FreeLibrary(g_hWININET);
            g_hWININET = NULL;
        }
    }
}

void RatingTerm()
{
    TerminateRatings(TRUE);
}


HRESULT WINAPI RatingEnabledQuery()
{
    CheckGlobalInfoRev();

    // $BUG - If the Settings are not valid should we return E_FAIL?
    if (gPRSI && !gPRSI->fSettingsValid)
        return S_OK;

    if (gPRSI && gPRSI->fRatingInstalled) {
        PicsUser *pUser = ::GetUserObject();
        return (pUser && pUser->fEnabled) ? S_OK : S_FALSE;
    }
    else {
        return E_FAIL;
    }
}

// Store the Parsed Label List of Ratings Information to ppRatingDetails.
void StoreRatingDetails( CParsedLabelList * pParsed, LPVOID * ppRatingDetails )
{
    if (ppRatingDetails != NULL)
    {
        *ppRatingDetails = pParsed;
    }
    else
    {
        if ( pParsed )
        {
            FreeParsedLabelList(pParsed);
            pParsed = NULL;
        }
    }
}

HRESULT WINAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                                     LPCSTR pszRatingInfo, LPBYTE pData,
                                     DWORD cbData, LPVOID *ppRatingDetails)
{
    HRESULT hRes;
    BOOL    fPassFail;

    g_fInvalid=FALSE;
    g_dwDataSource=cbData;
    g_fPICSRulesEnforced=FALSE;
    g_fApprovedSitesEnforced=FALSE;
    if (pszURL)
        lstrcpy(g_szLastURL,pszURL);

    CheckGlobalInfoRev();

    if (ppRatingDetails != NULL)
        *ppRatingDetails = NULL;

    if (!gPRSI->fSettingsValid)
        return ResultFromScode(S_FALSE);

    if (!gPRSI->fRatingInstalled)
        return ResultFromScode(S_OK);

    PicsUser *pUser = GetUserObject(pszUsername);
    if (pUser == NULL) {
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    if (!pUser->fEnabled)
        return ResultFromScode(S_OK);

    //check Approved Sites list
    hRes=PICSRulesCheckApprovedSitesAccess(pszURL,&fPassFail);

    if (SUCCEEDED(hRes)&&!g_fIsRunningUnderCustom) //the list made a determination, skip if Custom
    {
        g_fApprovedSitesEnforced=TRUE;

        if (fPassFail==PR_PASSFAIL_PASS)
        {
            return ResultFromScode(S_OK);
        }
        else
        {
            return ResultFromScode(S_FALSE);
        }
    }

    CParsedLabelList *pParsed=NULL;

    //check PICSRules systems
    hRes=PICSRulesCheckAccess(pszURL,pszRatingInfo,&fPassFail,&pParsed);

    if (SUCCEEDED(hRes)&&!g_fIsRunningUnderCustom) //the list made a determination, skip if Custom
    {
        g_fPICSRulesEnforced=TRUE;

        if (ppRatingDetails != NULL)
            *ppRatingDetails = pParsed;
        else
            FreeParsedLabelList(pParsed);

        if (fPassFail==PR_PASSFAIL_PASS)
        {
            return ResultFromScode(S_OK);
        }
        else
        {
            return ResultFromScode(S_FALSE);
        }
    }

    if (pszRatingInfo == NULL)
    {
        if (pUser->fAllowUnknowns)
        {
            hRes = ResultFromScode(S_OK);
        }
        else
        {
            hRes = ResultFromScode(S_FALSE);
        }

        //Site is unrated.  Check if user can see unrated sites.
        /** Custom **/
        // if notification interface exists, put in the URL
        if ( ( g_fIsRunningUnderCustom || ( hRes != S_OK ) )
                && ( ppRatingDetails != NULL ) )
        {
            if (!pParsed)
            {
                pParsed = new CParsedLabelList;
            }
            if (pParsed)
            {
                ASSERT(!pParsed->m_pszURL);
                pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
                if (pParsed->m_pszURL != NULL)
                {
                    strcpyf(pParsed->m_pszURL, pszURL);
                }

                pParsed->m_fNoRating = TRUE;
                *ppRatingDetails = pParsed;
            }
        }

        return hRes;
    }    
    else
    {
        if (pParsed!=NULL)
        {
            hRes = S_OK;
        }
        else
        {
            hRes = ParseLabelList(pszRatingInfo, &pParsed);
        }
    }

    if (SUCCEEDED(hRes))
    {
        BOOL fRated = FALSE;
        BOOL fDenied = FALSE;

        ASSERT(pParsed != NULL);
        /** Custom **/
        // if notification interface exists, put in the URL
        if (g_fIsRunningUnderCustom)
        {
            ASSERT(!pParsed->m_pszURL);
            pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
            if (pParsed->m_pszURL != NULL)
            {
                strcpyf(pParsed->m_pszURL, pszURL);
            }
        }

        DWORD timeCurrent = GetCurrentNetDate();

        CParsedServiceInfo *psi = &pParsed->m_ServiceInfo;

        while (psi != NULL && !fDenied)
        {
            UserRatingSystem *pURS = pUser->FindRatingSystem(psi->m_pszServiceName);
            if (pURS != NULL && pURS->m_pPRS != NULL)
            {
                psi->m_fInstalled = TRUE;
                UINT cRatings = psi->aRatings.Length();
                for (UINT i=0; i<cRatings; i++)
                {
                    CParsedRating *pRating = &psi->aRatings[i];
                    // YANGXU: 11/17/1999
                    // Do not check the URL if under Custom mode
                    // Checking the URL causes inaccuracies
                    // when a label is returned for an URL on
                    // a page whose server can have two different
                    // DNS entries. We can't just not check because
                    // passing in the URL is part of the published API
                    if (!g_fIsRunningUnderCustom)
                    {
                        if (!pRating->pOptions->CheckURL(pszURL))
                        {
                            pParsed->m_pszURL = new char[strlenf(pszURL) + 1];
                            if (pParsed->m_pszURL != NULL)
                            {
                                strcpyf(pParsed->m_pszURL, pszURL);
                            }

                            continue;    /* this rating has expired or is for
                                         * another URL, ignore it
                                         */
                        }
                    }
                    if (!pRating->pOptions->CheckUntil(timeCurrent))
                        continue;

                    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
                    if (pUR != NULL)
                    {
                        fRated = TRUE;
                        pRating->fFound = TRUE;
                        if ((*pUR).m_pPC!=NULL)
                        {
                            if ((pRating->nValue > (*((*pUR).m_pPC)).etnMax.Get())||
                                (pRating->nValue < (*((*pUR).m_pPC)).etnMin.Get()))
                            {
                                g_fInvalid = TRUE;
                                fDenied = TRUE;
                                pRating->fFailed = TRUE;
                            }
                        }
                        if (pRating->nValue > pUR->m_nValue)
                        {
                            fDenied = TRUE;
                            pRating->fFailed = TRUE;
                        }
                        else
                            pRating->fFailed = FALSE;
                    }
                    else
                    {
                        g_fInvalid = TRUE;
                        fDenied = TRUE;
                        pRating->fFailed = TRUE;
                    }
                }
            }
            else
            {
                psi->m_fInstalled = FALSE;
            }

            psi = psi->Next();
        }

        if (!fRated)
        {
            pParsed->m_fRated = FALSE;
            hRes = E_RATING_NOT_FOUND;
        }
        else
        {
            pParsed->m_fRated = TRUE;
            if (fDenied)
                hRes = ResultFromScode(S_FALSE);
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "RatingCheckUserAccess() - ParseLabelList() Failed with hres=0x%x!", hRes );

        // Although the site has invalid PICS rules, the site should still be considered rated.
        hRes = ResultFromScode(S_FALSE);
    }

    StoreRatingDetails( pParsed, ppRatingDetails );

    return hRes;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomDeleteCrackedData
//
//  Synopsis:  frees the memory of structure returned by RatingCustomCrackData
//
//  Arguments: prbInfo : pointer to RATINGBLOCKINGINFO to be deleted
//
//  Returns:   S_OK if delete successful, E_FAIL otherwise
//
//------------------------------------------------------------------------
HRESULT RatingCustomDeleteCrackedData(RATINGBLOCKINGINFO* prbInfo)
{
    HRESULT hres = E_FAIL;
    RATINGBLOCKINGLABELLIST* prblTemp = NULL;
    
    if (NULL != prbInfo)
    {
        if (prbInfo->pwszDeniedURL)
        {
            delete [] prbInfo->pwszDeniedURL;
            prbInfo->pwszDeniedURL = NULL;
        }
        if (prbInfo->prbLabelList)
        {
            for (UINT j = 0; j < prbInfo->cLabels; j++)
            {
                prblTemp = &prbInfo->prbLabelList[j];
                if (prblTemp->pwszRatingSystemName)
                {
                    delete [] prblTemp->pwszRatingSystemName;
                    prblTemp->pwszRatingSystemName = NULL;
                }
                if (prblTemp->paRBLS)
                {
                    for (UINT i = 0; i < prblTemp->cBlockingLabels; i++)
                    {
                        if (prblTemp->paRBLS[i].pwszCategoryName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszCategoryName;
                            prblTemp->paRBLS[i].pwszCategoryName = NULL;
                        }
                        if (prblTemp->paRBLS[i].pwszTransmitName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszTransmitName;
                            prblTemp->paRBLS[i].pwszTransmitName = NULL;
                        }
                        if (prblTemp->paRBLS[i].pwszValueName)
                        {
                            delete [] prblTemp->paRBLS[i].pwszValueName;
                            prblTemp->paRBLS[i].pwszValueName = NULL;
                        }
                    }

                    delete [] prblTemp->paRBLS;
                    prblTemp->paRBLS = NULL;
                }
            }

            delete [] prbInfo->prbLabelList;
            prbInfo->prbLabelList = NULL;
        }
        if (prbInfo->pwszRatingHelperName)
        {
            delete [] prbInfo->pwszRatingHelperName;
            prbInfo->pwszRatingHelperName = NULL;
        }

        hres = S_OK;
        if (prbInfo->pwszRatingHelperReason)
        {
            delete [] prbInfo->pwszRatingHelperReason;
            prbInfo->pwszRatingHelperReason = NULL;
        }

        delete prbInfo;
        prbInfo = NULL;
    }

    return hres;
}

HRESULT _CrackCategory(CParsedRating *pRating,
                       RATINGBLOCKINGCATEGORY *pRBLS,
                       UserRatingSystem* pURS)
{
    UserRating *pUR = pURS->FindRating(pRating->pszTransmitName);
    if (pUR)
    {
        //
        //  Mutated code from InitPleaseDialog, hope it works
        //
        PicsCategory* pPC = pUR->m_pPC;
        if (pPC)
        {
            pRBLS->nValue = pRating->nValue;

            Ansi2Unicode(&pRBLS->pwszTransmitName, pRating->pszTransmitName);
        
            LPCSTR pszCategory = NULL;

            if (pPC->etstrName.fIsInit())
            {
                pszCategory = pPC->etstrName.Get();
            }
            else if (pPC->etstrDesc.fIsInit())
            {
                pszCategory = pPC->etstrDesc.Get();
            }
            else
            {
                pszCategory = pRating->pszTransmitName;
            }

            Ansi2Unicode(&pRBLS->pwszCategoryName, pszCategory);

            UINT cValues = pPC->arrpPE.Length();
            PicsEnum *pPE;

            for (UINT iValue=0; iValue < cValues; iValue++)
            {
                pPE = pPC->arrpPE[iValue];
                if (pPE->etnValue.Get() == pRating->nValue)
                {
                    break;
                }
            }

            LPCSTR pszValue = NULL;
            if (iValue < cValues)
            {
                if (pPE->etstrName.fIsInit())
                {
                    pszValue = pPE->etstrName.Get();
                }
                else if (pPE->etstrDesc.fIsInit())
                {
                    pszValue = pPE->etstrDesc.Get();
                }

                Ansi2Unicode(&pRBLS->pwszValueName, pszValue);
            }
        }
    }
    
    return S_OK;
}

//+-----------------------------------------------------------------------
//
//  Function:  RatingCustomCrackData
//
//  Synopsis:  packages the persistent, opaque data describing why a site
//             was denied into readable form
//
//  Arguments: pszUsername : name of the user
//             pRatingDetails : pointer to the opaque data
//             pprbInfo : a RATINGBLOCKINGINFO representation of the data
//
//  Returns:   Success if data packaged
//
//------------------------------------------------------------------------
HRESULT RatingCustomCrackData(LPCSTR pszUsername, void* pvRatingDetails, RATINGBLOCKINGINFO** pprbInfo) {

    if(NULL != *pprbInfo)
    {
        return E_INVALIDARG;
    }

    RATINGBLOCKINGINFO* prbInfo = new RATINGBLOCKINGINFO;
    CParsedLabelList *pRatingDetails = (CParsedLabelList*)pvRatingDetails;
    if (!prbInfo)
    {
        return E_OUTOFMEMORY;
    }
    prbInfo->pwszDeniedURL = NULL;
    prbInfo->rbSource = RBS_ERROR;
    prbInfo->rbMethod = RBM_UNINIT;
    prbInfo->cLabels = 0;
    prbInfo->prbLabelList = NULL;
    prbInfo->pwszRatingHelperName = NULL;
    prbInfo->pwszRatingHelperReason = NULL;
    
    RATINGBLOCKINGLABELLIST* prblTemp = NULL;
    RATINGBLOCKINGLABELLIST* prblPrev = NULL;


    if (!g_fInvalid)
    {
        if (g_fIsRunningUnderCustom)
        {
            // pRatingDetails should not be NULL unless
            // we ran out of memory
            ASSERT(pRatingDetails);
            
            if (pRatingDetails->m_pszURL)
            {
                Ansi2Unicode(&prbInfo->pwszDeniedURL, pRatingDetails->m_pszURL);
            }
            if (pRatingDetails->m_fRated)
            {
                // The page can be rated or denied, but not both
                ASSERT(!pRatingDetails->m_fDenied);
                ASSERT(!pRatingDetails->m_fNoRating);
                
                prbInfo->rbMethod = RBM_LABEL;
                PicsUser* pPU = GetUserObject(pszUsername);
                if (pPU)
                {
                    // first find out how many systems there are
                    UINT cLabels =  0;
                    CParsedServiceInfo *ppsi = &pRatingDetails->m_ServiceInfo;
                    while (ppsi)
                    {
                        cLabels++;
                        ppsi = ppsi->Next();
                    }
                    // should have at least one label
                    ASSERT(cLabels > 0);
                    prbInfo->prbLabelList = new RATINGBLOCKINGLABELLIST[cLabels];

                    if (prbInfo->prbLabelList)
                    {
                        UINT iLabel = 0;
                        for (ppsi = &pRatingDetails->m_ServiceInfo;ppsi;ppsi = ppsi->Next())
                        {
                            if (!ppsi->m_fInstalled)
                            {
                                continue;
                            }
                            UserRatingSystem* pURS = pPU->FindRatingSystem(ppsi->m_pszServiceName);
                            if (NULL == pURS || NULL == pURS->m_pPRS)
                            {
                                continue;
                            }

                            prblTemp = &(prbInfo->prbLabelList[iLabel]);
                            
                            Ansi2Unicode(&prblTemp->pwszRatingSystemName, pURS->m_pPRS->etstrName.Get());
                            
                            UINT cRatings = ppsi->aRatings.Length();
                            prblTemp->paRBLS = new RATINGBLOCKINGCATEGORY[cRatings];
                            if (prblTemp->paRBLS == NULL)
                            {
                                RatingCustomDeleteCrackedData(prbInfo);
                                return E_OUTOFMEMORY;
                            } // if (prblTemp->paRBLS == NULL)
                            prblTemp->cBlockingLabels = cRatings;
                            
                            for (UINT i=0; i < cRatings; i++)
                            {
                                CParsedRating *pRating = &ppsi->aRatings[i];
                                RATINGBLOCKINGCATEGORY* pRBLS = &prblTemp->paRBLS[i];
                                _CrackCategory(pRating, pRBLS, pURS);
                            } // for (UINT i=0; i < cRatings; i++)

                            // at this point, we should have valid ratings for
                            // a system
                            iLabel++;
                        } // for (ppsi = &pRatingDetails->m_ServiceInfo;ppsi;ppsi = ppsi->Next())
                        prbInfo->cLabels = iLabel;
                    } // if (prbInfo->prbLabelList)
                    else
                    {
                        RatingCustomDeleteCrackedData(prbInfo);
                        return E_OUTOFMEMORY;
                    }
                    if (!pRatingDetails->m_fIsHelper)
                    {
                       prbInfo->rbSource = RBS_PAGE;
                    }
                    else
                    {
                        if (pRatingDetails->m_fIsCustomHelper)
                        {
                            prbInfo->rbSource = RBS_CUSTOM_RATING_HELPER;
                            if (pRatingDetails->m_pszRatingName)
                            {
                                Ansi2Unicode(&prbInfo->pwszRatingHelperName, pRatingDetails->m_pszRatingName);
                            }
                            if (pRatingDetails->m_pszRatingReason)
                            {
                                Ansi2Unicode(&prbInfo->pwszRatingHelperReason, pRatingDetails->m_pszRatingReason);
                            }
                        }
                        else
                        {
                            prbInfo->rbSource = RBS_RATING_HELPER;
                        }
                    }
                }
            } // if (pRatingDetails->m_fRated)
            else
            {
                if (pRatingDetails->m_fDenied)
                {
                    prbInfo->rbMethod = RBM_DENY;
                    if (!pRatingDetails->m_fIsHelper)
                    {
                       prbInfo->rbSource = RBS_PAGE;
                    }
                    else
                    {
                        if (pRatingDetails->m_fIsCustomHelper)
                        {
                            prbInfo->rbSource = RBS_CUSTOM_RATING_HELPER;
                        }
                        else
                        {
                            prbInfo->rbSource = RBS_RATING_HELPER;
                        }
                    }
                }
                else
                {
                    if (pRatingDetails->m_fNoRating)
                    {
                        prbInfo->rbSource = RBS_NO_RATINGS;
                    }
                }
            }
        } // if (g_fIsRunningUnderCustom)
        else
        {
            prbInfo->rbMethod = RBM_ERROR_NOT_IN_CUSTOM_MODE;
        }
    } // (!g_fInvalid)
    *pprbInfo = prbInfo;
    return S_OK;
}

HRESULT WINAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, LPVOID pRatingDetails)
{
    HRESULT hres;

    PleaseDlgData pdd;

    pdd.pszUsername = pszUsername;
    pdd.pPU = GetUserObject(pszUsername);
    if (pdd.pPU == NULL)
    {
        TraceMsg( TF_WARNING, "RatingAccessDeniedDialog() - Username is not valid!" );
        return HRESULT_FROM_WIN32(ERROR_BAD_USERNAME);
    }

    pdd.pszContentDescription = pszContentDescription;
    pdd.pLabelList = (CParsedLabelList *)pRatingDetails;
    pdd.hwndEC = NULL;
    pdd.dwFlags = 0;
    pdd.hwndDlg = NULL;
    pdd.hwndOwner = hDlg;
    pdd.cLabels = 0;

    CPleaseDialog           pleaseDialog( &pdd );

    if ( pleaseDialog.DoModal( hDlg ) )
    {
        hres = ResultFromScode(S_OK);
    }
    else
    {
        hres = ResultFromScode(S_FALSE);
    }

    for (UINT i=0; i<pdd.cLabels; i++)
    {
        delete pdd.apLabelStrings[i];
        pdd.apLabelStrings[i] = NULL;
    }
    
    return hres;
}

HRESULT WINAPI RatingAccessDeniedDialog2(HWND hwndParent, LPCSTR pszUsername, LPVOID pRatingDetails)
{
    PleaseDlgData *ppdd = (PleaseDlgData *)GetProp( hwndParent, szRatingsProp );
    if (ppdd == NULL)
    {
        return RatingAccessDeniedDialog( hwndParent, pszUsername, NULL, pRatingDetails );
    }

    HWND            hwndDialog = ppdd->hwndDlg;

    ASSERT( hwndDialog );

    ppdd->pLabelList = (CParsedLabelList *)pRatingDetails;

    SendMessage( hwndDialog, WM_NEWDIALOG, 0, (LPARAM)ppdd );

    // The ppdd is only valid during the RatingAccessDeniedDialog() scope!!
    ppdd = NULL;

    // $REVIEW - Should we use a Windows Hook instead of looping to wait for the
    //      modal dialog box to complete?
    // $CLEANUP - Use a CMessageLoop instead.

    // Property is removed once the modal dialog is toasted.
    while ( ::IsWindow( hwndParent ) && ::GetProp( hwndParent, szRatingsProp ) )
    {
        MSG msg;

        if ( PeekMessage( &msg, NULL, 0, 0, PM_NOREMOVE ) )
        {
            if ( GetMessage( &msg, NULL, 0, 0 ) > 0 )
//              && !IsDialogMessage(ppdd->hwndDlg, &msg)) {
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            ::Sleep( 100 );     // Empty message queue means check again in 100 msecs
        }
    }

    DWORD           dwFlags;

    dwFlags = ::IsWindow( hwndParent ) ? PtrToUlong( GetProp( hwndParent, szRatingsValue ) ) : PDD_DONE;

    TraceMsg( TF_ALWAYS, "RatingAccessDeniedDialog2() - Message Loop exited with dwFlags=%d", dwFlags );

    return ( dwFlags & PDD_ALLOW ) ? S_OK : S_FALSE;
}

HRESULT WINAPI RatingFreeDetails(LPVOID pRatingDetails)
{
    if (pRatingDetails)
    {
        FreeParsedLabelList((CParsedLabelList *)pRatingDetails);
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\roll.cpp ===
/*Includes-----------------------------------------------------------*/
#include "msrating.h"
#pragma hdrstop

#include <npassert.h>
#include "ratings.h"

#include "roll.h"




/*IsUrlInFile---------------------------------------------------------------*/
/*
    Return VAlue length of Best Match
*/
static HRESULT IsUrlInFile(LPCTSTR pszTargetUrl, char **ppRating, const char* pFile, DWORD dwFile, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size))
{
    LocalListRecordHeader *pllrh;
    DWORD dwBytesRead;
    HRESULT hrRet = S_OK;
    int nBest, nActual, nCmp;
    const char *pBest;
    BOOL fAbort;

    dwBytesRead = 0;
    nBest   = 0;
    nActual = strlenf(pszTargetUrl);
    fAbort  = FALSE;

    //Go through each recored until there is a match good enough or an abort
    while (!fAbort && nActual != nBest && dwBytesRead <= dwFile)
    {
        pllrh = (LocalListRecordHeader*) pFile;
        if (pllrh->nUrl > nBest && 
                (
                    (pllrh->nUrl == nActual)
                    ||            
                    (
                        pllrh->nUrl < nActual && 
                        (
                            (pszTargetUrl[pllrh->nUrl] == '\\') 
                            || 
                            (pszTargetUrl[pllrh->nUrl] == '/')
                            || 
                            (pszTargetUrl[pllrh->nUrl] == ':')
                        )
                    )
                )                
            )
        {
            nCmp = strnicmpf(pFile+sizeof(LocalListRecordHeader), pszTargetUrl, pllrh->nUrl);
            if (0==nCmp)
            {
                nBest = pllrh->nUrl;
                pBest = pFile;
                hrRet = pllrh->hrRet;
            }
            //the local list is alphabetized
            else if (1==nCmp) break;

        }
        dwBytesRead += pllrh->nUrl + pllrh->nRating + sizeof(LocalListRecordHeader);
        pFile       += pllrh->nUrl + pllrh->nRating + sizeof(LocalListRecordHeader);
        fAbort       = (WAIT_OBJECT_0 == WaitForSingleObject(hAbortEvent, 0));
    }

    //was the match close enough??!?!?
    if (!fAbort && nBest)
    {
        //yes, now try to copy rating
        pllrh = (LocalListRecordHeader*) pBest;
        if (pllrh->nRating)
        {
            *ppRating = (char*) MemAlloc(pllrh->nRating+1);
            if (*ppRating)
            {
                CopyMemory(*ppRating, pBest + sizeof(LocalListRecordHeader) + pllrh->nUrl, pllrh->nRating);
                (*ppRating)[pllrh->nRating] = 0;
            }
        }
    }
    else
    {
        //no... oh well
        hrRet = E_RATING_NOT_FOUND;
    }

    return hrRet;
}



/*RatingObtainFromLocalList-------------------------------------------------*/
/*
    Grab rating information from local file.
    Should operate synchronously and take small amount of time.
    Doesn't check pOrd->fAbort too often.
*/



HRESULT RatingHelperProcLocalList(LPCTSTR pszTargetUrl, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size), char **ppRatingOut)
{
    DWORD dwFile;
    HRESULT hrRet = E_RATING_NOT_FOUND;
    HANDLE hFile, hMap;
    BOOL fAbort;
    const char *pFile;

    ASSERT(ppRatingOut);
    //Open and check from approved list
    hFile = CreateFile(
        FILE_NAME_LIST, GENERIC_READ, 
        FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwFile = GetFileSize(hFile, NULL);
        hMap   = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0, NULL);
        if (hMap)
        {
            pFile = (const char*) MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, 0);
            if (pFile) 
            {
                //check for correct file type
        if (BATCAVE_LOCAL_LIST_MAGIC_COOKIE == *((DWORD*) pFile))
        {
          pFile  += sizeof(DWORD);
          dwFile -= sizeof(DWORD);
          fAbort  = (WAIT_OBJECT_0 == WaitForSingleObject(hAbortEvent, 0));
          if (!fAbort) hrRet = IsUrlInFile(pszTargetUrl, ppRatingOut, pFile, dwFile, hAbortEvent, MemAlloc);
          pFile  -= sizeof(DWORD);
        }
            }
            dwFile = (DWORD) UnmapViewOfFile((LPVOID)pFile);
            CloseHandle(hMap);
        }
        CloseHandle(hFile);
    }
    return hrRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\reghive.cpp ===
/****************************************************************************\
 *
 *   reghive.cpp
 *
 *   Created:   William Taylor (wtaylor) 02/13/01
 *
 *   MS Ratings Registry Hive Handling
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "reghive.h"         // CRegistryHive
#include "debug.h"

const int c_iHiveFile1 = 0x1;
const int c_iHiveFile2 = 0x2;

CRegistryHive::CRegistryHive()
{
    m_fHiveLoaded = false;
    ClearHivePath();
}

CRegistryHive::~CRegistryHive()
{
    UnloadHive();
}

void CRegistryHive::UnloadHive( void )
{
    if ( m_keyHive.m_hKey != NULL )
    {
        ::RegFlushKey( m_keyHive.m_hKey );
        m_keyHive.Close();
        ::RegFlushKey( HKEY_LOCAL_MACHINE );
    }

    if ( m_fHiveLoaded )
    {
        LONG            err;

        err = ::RegUnLoadKey( HKEY_LOCAL_MACHINE, szTMPDATA );

        if ( err == ERROR_SUCCESS )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::UnloadHive() - Succesfully Unloaded Hive '%s' from szTMPDATA='%s'!", m_szPath, szTMPDATA );
            m_fHiveLoaded = false;
            ClearHivePath();
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::UnloadHive() - Failed RegUnLoadKey 0x%x with szTMPDATA='%s'!", err, szTMPDATA );
        }
    }

    ASSERT( ! m_fHiveLoaded );
}

bool CRegistryHive::OpenHiveFile( bool p_fCreate )
{
    UnloadHive();

    ASSERT( ! m_fHiveLoaded );

    LoadHiveFile( c_iHiveFile1 );

    if ( ! m_fHiveLoaded )
    {
        LoadHiveFile( c_iHiveFile2 );
    }

    if ( m_fHiveLoaded )
    {
#ifdef DEBUG
        EnumerateRegistryKeys( HKEY_LOCAL_MACHINE, (LPSTR) szTMPDATA, 0 );
#endif

        if ( OpenHiveKey() )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveFile() - OpenHiveKey() succeeeded." );
            return true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - OpenHiveKey() failed!" );
        }
    }

    UnloadHive();

    if ( ! p_fCreate )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - Failed to Open Existing Hive File!" );
        return false;
    }

    DeleteRegistryHive();

    int         iHiveFile;

    // Returns the iHiveFile set to the hive file created (c_iHiveFile1 or c_iHiveFile2).
    if ( ! CreateNewHive( iHiveFile ) )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - Failed to Create Hive File!" );
        return false;
    }

    DeleteRegistryHive();

    LoadHiveFile( iHiveFile );

    if ( m_fHiveLoaded )
    {
        if ( OpenHiveKey() )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveFile() - OpenHiveKey() succeeeded." );
            return true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveFile() - OpenHiveKey() failed!" );
        }
    }

    UnloadHive();

    return false;
}

bool CRegistryHive::OpenHiveKey( void )
{
    LONG            err;

    err = m_keyHive.Open( HKEY_LOCAL_MACHINE, szPOLUSER );

    if (err == ERROR_SUCCESS)
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::OpenHiveKey() - Successful m_keyHive Open with szPOLUSER='%s'", szPOLUSER );
        return true;
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::OpenHiveKey() - Failed m_keyHive Open with szPOLUSER='%s'!", szPOLUSER );
    }

    return false;
}

void CRegistryHive::DeleteRegistryHive( void )
{
    MyRegDeleteKey( HKEY_LOCAL_MACHINE, szTMPDATA );

    RegFlushKey( HKEY_LOCAL_MACHINE );
}

bool CRegistryHive::CreateNewHive( int & p_riHiveFile )
{
    CRegKey     keyHive;

    if ( keyHive.Create( HKEY_LOCAL_MACHINE, szTMPDATA ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Create Hive Key szTMPDATA='%s'!", szTMPDATA );
        return false;
    }

    CRegKey     keyUser;

    if ( keyUser.Create( keyHive.m_hKey, szUSERS ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Create User Key szUSERS='%s'!", szUSERS );
        return false;
    }

    if ( SaveHiveKey( keyHive, c_iHiveFile1 ) )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::CreateNewHive() - Saved Hive Key to Hive File 1!" );
        p_riHiveFile  = c_iHiveFile1;
        return true;
    }

    if ( SaveHiveKey( keyHive, c_iHiveFile2 ) )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::CreateNewHive() - Saved Hive Key to Hive File 2!" );
        p_riHiveFile  = c_iHiveFile2;
        return true;
    }

    TraceMsg( TF_WARNING, "CRegistryHive::CreateNewHive() - Failed to Save Hive Key to Registry!" );
    return false;
}

bool CRegistryHive::SaveHiveKey( CRegKey & p_keyHive, int p_iFile )
{
    bool            fReturn = false;

    ASSERT( p_keyHive.m_hKey != NULL );

    SetHiveName( p_iFile );

    LONG            err;

    err = ::RegSaveKey( p_keyHive.m_hKey, m_szPath, 0 );

    if ( err == ERROR_SUCCESS )
    {
        TraceMsg( TF_ALWAYS, "CRegistryHive::SaveHiveKey() - Saved Hive Key to m_szPath='%s'!", m_szPath );
        fReturn = true;
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::SaveHiveKey() - Failed to Save Hive Key 0x%x to m_szPath='%s'!", err, m_szPath );
    }

    return fReturn;
}

BOOL CRegistryHive::BuildPolName(LPSTR pBuffer, UINT cbBuffer, UINT (WINAPI *PathProvider)(LPTSTR, UINT))
{
    if ((*PathProvider)(pBuffer, cbBuffer) + strlenf(szPOLFILE) + 2 > cbBuffer)
        return FALSE;

    LPSTR pchBackslash = strrchrf(pBuffer, '\\');
    if (pchBackslash == NULL || *(pchBackslash+1) != '\0')
        strcatf(pBuffer, "\\");

    strcatf(pBuffer, szPOLFILE);

    return TRUE;
}

void CRegistryHive::SetHiveName( int p_iFile )
{
    ASSERT( p_iFile == c_iHiveFile1 || p_iFile == c_iHiveFile2 );

    ClearHivePath();

    if ( p_iFile == c_iHiveFile1 )
    {
        BuildPolName( m_szPath, sizeof(m_szPath), GetSystemDirectory );
    }
    else
    {
        BuildPolName( m_szPath, sizeof(m_szPath), GetWindowsDirectory );
    }
}

void CRegistryHive::LoadHiveFile( int p_iFile )
{
    LONG            err;
    
    err = ERROR_FILE_NOT_FOUND;

    ASSERT( ! m_fHiveLoaded );

    if ( m_fHiveLoaded )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::LoadHiveFile() - Hive File Already Loaded!" );
        return;
    }

    SetHiveName( p_iFile );

    if ( ::GetFileAttributes( m_szPath ) != 0xFFFFFFFF )
    {
        err = ::RegLoadKey( HKEY_LOCAL_MACHINE, szTMPDATA, m_szPath );

        if ( err == ERROR_SUCCESS )
        {
            TraceMsg( TF_ALWAYS, "CRegistryHive::LoadHiveFile() - Loaded Hive File szTMPDATA='%s' m_szPath='%s'!", szTMPDATA, m_szPath );
            m_fHiveLoaded = true;
        }
        else
        {
            TraceMsg( TF_WARNING, "CRegistryHive::LoadHiveFile() - Failed RegLoadKey szTMPDATA='%s' m_szPath='%s'!", szTMPDATA, m_szPath );
        }
    }

    if ( ! m_fHiveLoaded )
    {
        ClearHivePath();
    }

    return;
}

#ifdef DEBUG
void CRegistryHive::EnumerateRegistryKeys( HKEY hkeyTop, LPSTR pszKeyName, int iLevel )
{
    if ( ! hkeyTop )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - hkeyTop is NULL!" );
        return;
    }

    if ( ! pszKeyName )
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - pszKeyName is NULL!" );
        return;
    }

    CRegKey         keyHive;

    if ( keyHive.Open( hkeyTop, pszKeyName ) == ERROR_SUCCESS )
    {
        // Enumerate Open Key's Values.
        {
            char szKeyValue[MAXPATHLEN];
            int j = 0;
            DWORD       cchValueSize = sizeof(szKeyValue);
            DWORD       dwType;

            // enumerate the subkeys, which are rating systems
            while ( RegEnumValue( keyHive.m_hKey, j, szKeyValue, &cchValueSize,
                        NULL, &dwType, NULL, NULL ) == ERROR_SUCCESS )
            {
                switch ( dwType )
                {
                case REG_DWORD:
                    {
                        ETN         etn;

                        EtNumRegRead( etn, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: etn=0x%x for %d pszKeyName='%s' szKeyValue='%s'", iLevel, etn.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                case REG_BINARY:
                    {
                        ETB         etb;

                        EtBoolRegRead( etb, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: etb=0x%x for %d pszKeyName='%s' szKeyValue='%s'", iLevel, etb.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                case REG_SZ:
                    {
                        ETS         ets;

                        EtStringRegRead( ets, keyHive.m_hKey, szKeyValue );

                        TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: ets='%s' for %d pszKeyName='%s' szKeyValue='%s'", iLevel, ets.Get(), j, pszKeyName, szKeyValue );
                    }
                    break;

                default:
                    TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Unhandled Enumeration Type %d for szKeyValue='%s'!", iLevel, dwType, szKeyValue );
                    break;
                }

                cchValueSize = sizeof(szKeyValue);
                j++;
            }

            TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Completed Enumeration of %d values in pszKeyName='%s'", iLevel, j, pszKeyName );
        }

        // Enumerate Open Key's Subkeys.
        {
            char szKeyName[MAXPATHLEN];
            int j = 0;

            // enumerate the subkeys, which are rating systems
            while ( RegEnumKey( keyHive.m_hKey, j, szKeyName, sizeof(szKeyName) ) == ERROR_SUCCESS )
            {
                EnumerateRegistryKeys( keyHive.m_hKey, szKeyName, iLevel+1 );
                j++;
            }

            TraceMsg( TF_ALWAYS, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Completed Enumeration of %d keys in pszKeyName='%s'", iLevel, j, pszKeyName );
        }
    }
    else
    {
        TraceMsg( TF_WARNING, "CRegistryHive::EnumerateRegistryKeys() - [%d]: Failed to Open key pszKeyName='%s' for Enumeration!", iLevel, pszKeyName );
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\dll\makefile.inc ===
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\roll.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _ROLL_H_
#define _ROLL_H_


/*Includes-----------------------------------------------------------*/

/*Classes------------------------------------------------------------*/
/*
The format of the local list file is as follows:

    BATCAVE_LOCAL_LIST_MAGIC_COOKIE
    LocalListRecordHeader_1 pUrl_1 pRating_1
    .
    .
    .
    .
    LocalListRecordHeader_n pUrl_n pRating_n

The file is binary.

Entries should be sorted based on pUrl

pUrl and pRating are both strings whose size is determined
by the record header.  They are NOT null terminated!
*/

#define BATCAVE_LOCAL_LIST_MAGIC_COOKIE 0x4e4f5845

//BUG BUG should either be inside of registry or user profile
#define FILE_NAME_LIST  "ratings.lst"

struct LocalListRecordHeader{
    int     nUrl;
    int     nRating;
    HRESULT hrRet;
};

/*Prototypes---------------------------------------------------------*/
HRESULT RatingHelperProcLocalList(LPCTSTR pszTargetUrl, HANDLE hAbortEvent, void* (WINAPI *MemAlloc)(long size), char **ppRatingOut);

#endif 
//_ROLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\rocycle.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

/*Included Files------------------------------------------------------------*/
#include "msrating.h"
#include "ratings.h"
#include <ratingsp.h>
#include <npassert.h>
#include <npstring.h>

#include "mslubase.h"
#include "roll.h"
#include "rors.h"
#include "picsrule.h"
#include "parselbl.h"
#include "debug.h"

typedef HRESULT (STDAPICALLTYPE *PFNCoInitialize)(LPVOID pvReserved);
typedef void (STDAPICALLTYPE *PFNCoUninitialize)(void);
typedef HRESULT (STDAPICALLTYPE *PFNCoGetMalloc)(
    DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
typedef HRESULT (STDAPICALLTYPE *PFNCoCreateInstance)(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);
typedef HRESULT (STDAPICALLTYPE *PFNCLSIDFromString)(LPOLESTR lpsz, LPCLSID pclsid);

PFNCoInitialize pfnCoInitialize = NULL;
PFNCoUninitialize pfnCoUninitialize = NULL;
PFNCoGetMalloc pfnCoGetMalloc = NULL;
PFNCoCreateInstance pfnCoCreateInstance = NULL;
PFNCLSIDFromString pfnCLSIDFromString = NULL;

#undef CoInitialize
#undef CoUninitialize
#undef CoGetMalloc
#undef CoCreateInstance
#undef CLSIDFromString

#define CoInitialize pfnCoInitialize
#define CoUninitialize pfnCoUninitialize
#define CoGetMalloc pfnCoGetMalloc
#define CoCreateInstance pfnCoCreateInstance
#define CLSIDFromString pfnCLSIDFromString

struct {
    FARPROC *ppfn;
    LPCSTR pszName;
} aOLEImports[] = {
    { (FARPROC *)&pfnCoInitialize, "CoInitialize" },
    { (FARPROC *)&pfnCoUninitialize, "CoUninitialize" },
    { (FARPROC *)&pfnCoGetMalloc, "CoGetMalloc" },
    { (FARPROC *)&pfnCoCreateInstance, "CoCreateInstance" },
    { (FARPROC *)&pfnCLSIDFromString, "CLSIDFromString" },
};

const UINT cOLEImports = sizeof(aOLEImports) / sizeof(aOLEImports[0]);

HINSTANCE hOLE32 = NULL;
BOOL fTriedOLELoad = FALSE;

BOOL LoadOLE(void)
{
    if (fTriedOLELoad)
        return (hOLE32 != NULL);

    fTriedOLELoad = TRUE;

    hOLE32 = ::LoadLibrary("OLE32.DLL");
    if (hOLE32 == NULL)
        return FALSE;

    for (UINT i=0; i<cOLEImports; i++) {
        *(aOLEImports[i].ppfn) = ::GetProcAddress(hOLE32, aOLEImports[i].pszName);
        if (*(aOLEImports[i].ppfn) == NULL) {
            CleanupOLE();
            return FALSE;
        }
    }

    return TRUE;
}


void CleanupOLE(void)
{
    if (hOLE32 != NULL) {
        for (UINT i=0; i<cOLEImports; i++) {
            *(aOLEImports[i].ppfn) = NULL;
        }
        ::FreeLibrary(hOLE32);
        hOLE32 = NULL;
    }
}


/*Obtain Rating Data--------------------------------------------------------*/
class RatingObtainData
{
    public:
        NLS_STR  nlsTargetUrl;
        HANDLE   hAbortEvent;
        DWORD    dwUserData;
        void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, LPVOID lpvRatingDetails) ;

        RatingObtainData(LPCTSTR pszTargetUrl);
        ~RatingObtainData();
};

RatingObtainData::RatingObtainData(LPCTSTR pszTargetUrl)
    : nlsTargetUrl(pszTargetUrl)
{
    hAbortEvent  = NULL;
    dwUserData   = 0;
    fCallback    = NULL;
}
RatingObtainData::~RatingObtainData()
{
    if (hAbortEvent) CloseHandle(hAbortEvent);
}


struct RatingHelper {
    CLSID clsid;
    DWORD dwSort;
};

array<RatingHelper> *paRatingHelpers = NULL;
CustomRatingHelper *g_pCustomRatingHelperList;

BOOL fTriedLoadingHelpers = FALSE;


void InitRatingHelpers()
{
    BOOL fCOMInitialized = FALSE;
    RatingHelper helper;

    if (fTriedLoadingHelpers || !LoadOLE())
    {
        TraceMsg( TF_WARNING, "InitRatingHelpers() - Tried Loading Helpers or OLE Load Failed!");
        return;
    }

    fTriedLoadingHelpers = TRUE;

    paRatingHelpers = new array<RatingHelper>;
    if (paRatingHelpers == NULL)
    {
        TraceMsg( TF_ERROR, "InitRatingHelpers() - Failed to Create paRatingHelpers!");
        return;
    }

    CRegKey         key;

    /* REARCHITECT - should this be in the policy file?  it shouldn't be per-user, that's for sure. */
    if ( key.Open( HKEY_LOCAL_MACHINE, szRATINGHELPERS, KEY_READ ) != ERROR_SUCCESS )
    {
        TraceMsg( TF_WARNING, "InitRatingHelpers() - Failed to Open key szRATINGHELPERS='%s'!", szRATINGHELPERS );
        return;
    }

    UINT iValue = 0;
    LONG err = ERROR_SUCCESS;
    char szValue[39];       /* just big enough for a null-terminated GUID string */
    WCHAR wszValue[39];     /* unicode version */

    // YANGXU : 11/15/1999
    // under custom mode, if we have a bureau string, load the bureau
    // rating helper, but do not load any other rating helpers
    if (g_fIsRunningUnderCustom)
    {
        if (gPRSI->etstrRatingBureau.fIsInit())
        {
            ASSERT(FALSE == fCOMInitialized);
            if (SUCCEEDED(CoInitialize(NULL)))
            {
                fCOMInitialized = TRUE;
                IObtainRating *pHelper;
                helper.clsid = CLSID_RemoteSite;

                if (SUCCEEDED(CoCreateInstance(helper.clsid, NULL,
                                               CLSCTX_INPROC_SERVER,
                                               IID_IObtainRating,
                                               (LPVOID *)&pHelper)))
                {
                    helper.dwSort = pHelper->GetSortOrder();
                    if (!paRatingHelpers->Append(helper))
                    {
                        err = ERROR_NOT_ENOUGH_MEMORY;
                    }

                    pHelper->Release();
#ifdef DEBUG
                    pHelper = NULL;
#endif
                }
            }
        }
    }
    else
    {
        /* Note, special care is taken to make sure that we only CoInitialize for
         * as long as we need to, and CoUninitialize when we're done.  We cannot
         * CoUninitialize on a different thread than we initialized on, nor do we
         * want to call CoUninitialize at thread-detach time (would require using
         * TLS).  This is done here and in the asynchronous thread that actually
         * calls into the rating helpers to get ratings.
         */

        do
        {
            DWORD cchValue = sizeof(szValue);
            err = RegEnumValue( key.m_hKey, iValue, szValue, &cchValue, NULL, NULL, NULL, NULL);
            if (err == ERROR_SUCCESS)
            {
                if (!fCOMInitialized)
                {
                    if (FAILED(CoInitialize(NULL)))
                    {
                        break;
                    }
                    fCOMInitialized = TRUE;
                }

                if (MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szValue, -1, wszValue, ARRAYSIZE(wszValue))) {
                    if (SUCCEEDED(CLSIDFromString(wszValue, &helper.clsid)))
                    {
                        IObtainRating *pHelper;

                        if (SUCCEEDED(CoCreateInstance(helper.clsid, NULL,
                                                       CLSCTX_INPROC_SERVER,
                                                       IID_IObtainRating,
                                                       (LPVOID *)&pHelper)))
                        {
                            helper.dwSort = pHelper->GetSortOrder();
                            if (!paRatingHelpers->Append(helper))
                            {
                                err = ERROR_NOT_ENOUGH_MEMORY;
                            }

                            pHelper->Release();
#ifdef DEBUG
                            pHelper = NULL;
#endif
                        }
                    }
                }
            }
            iValue++;
        } while (ERROR_SUCCESS == err);
    }

    if (fCOMInitialized)
    {
        CoUninitialize();
    }

    /* If more than one helper, sort them by their reported sort orders.
     * We will rarely have more than two or three of these guys, and this
     * is one time code, so we don't need a super-slick sort algorithm.
     *
     * CODEWORK: could modify array<> template to support an Insert()
     * method which reallocates the buffer like Append() does, but inserts
     * at a specific location.
     */
    if (paRatingHelpers->Length() > 1)
    {
        for (INT i=0; i < paRatingHelpers->Length() - 1; i++)
        {
            for (INT j=i+1; j < paRatingHelpers->Length(); j++)
            {
                if ((*paRatingHelpers)[i].dwSort > (*paRatingHelpers)[j].dwSort)
                {
                    RatingHelper temp = (*paRatingHelpers)[i];
                    (*paRatingHelpers)[i] = (*paRatingHelpers)[j];
                    (*paRatingHelpers)[j] = temp;
                }
            }
        }
    }
}


void CleanupRatingHelpers(void)
{
    if (paRatingHelpers != NULL) {
        delete paRatingHelpers;
        paRatingHelpers = NULL;
    }
    fTriedLoadingHelpers = FALSE;
}


/*
    This procedure runs on its own thread (1 per request).
    This cycles through all the helper DLLs looking for a ratings.
    It goes on down the list one at a time until either a rating 
    is found, or the this is aborted by the programmer.
*/
DWORD __stdcall RatingCycleThread(LPVOID pData)
{
    RatingObtainData *pOrd = (RatingObtainData*) pData;
    LPVOID            lpvRatingDetails = NULL;
    HRESULT           hrRet = E_FAIL;
    int               nProc;
    BOOL              fAbort = FALSE;
    BOOL              fFoundWithCustomHelper = FALSE;
    IMalloc *pAllocator = NULL;
    LPSTR pszRating = NULL;
    LPSTR pszRatingName = NULL;
    LPSTR pszRatingReason = NULL;
    BOOL fCOMInitialized = FALSE;
    CustomRatingHelper* pmrhCurrent = NULL;

    ASSERT(pOrd);

    //
    // Check the Custom Helpers first
    //
    if(g_pCustomRatingHelperList)
    {
        // we should only have custom rating helpers under custom mode
        ASSERT(g_fIsRunningUnderCustom);
        if(SUCCEEDED(CoInitialize(NULL)))
        {
            fCOMInitialized = TRUE;
            // get a cotaskmem allocator
            hrRet = CoGetMalloc(MEMCTX_TASK, &pAllocator);
            if (SUCCEEDED(hrRet))
            {
                pmrhCurrent = g_pCustomRatingHelperList;
                while(pmrhCurrent)
                {
                    HRESULT (* pfn)(REFCLSID, REFIID, LPVOID *) = NULL;
                    ICustomRatingHelper* pCustomHelper = NULL;
                    IClassFactory* pFactory = NULL;

                    ASSERT(pmrhCurrent->hLibrary);

                    *(FARPROC *) &pfn = GetProcAddress(pmrhCurrent->hLibrary, "DllGetClassObject");
                    if (pfn)
                    {
                        hrRet = pfn(pmrhCurrent->clsid, IID_IClassFactory, (void**)&pFactory);
                        if (SUCCEEDED(hrRet))
                        {
                            hrRet = pFactory->CreateInstance(NULL, IID_ICustomRatingHelper, (void**)&pCustomHelper);
                            if (SUCCEEDED(hrRet))
                            {
                                hrRet = pCustomHelper->ObtainCustomRating(pOrd->nlsTargetUrl.QueryPch(),
                                                                  pOrd->hAbortEvent,
                                                                  pAllocator,
                                                                  &pszRating,
                                                                  &pszRatingName,
                                                                  &pszRatingReason);
                                pCustomHelper->Release();
                                pCustomHelper = NULL;
                                fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(pOrd->hAbortEvent, 0));
                                if (fAbort || SUCCEEDED(hrRet))
                                    break;
                            }
                            pFactory->Release();
                        } // if (SUCCEEDED(pfn(pmrhCurrent->clsid, IID_ICustomRatingHelper, (void**)&pCustomHelper)))
                    } // if (pfn)
                    else
                    {
                        hrRet = E_UNEXPECTED;
                    }

                    pmrhCurrent = pmrhCurrent->pNextHelper;
                }
            }
        }
    }

    if(SUCCEEDED(hrRet))
    {
        fFoundWithCustomHelper = TRUE;
    }

    if(paRatingHelpers && paRatingHelpers->Length()>0 && !SUCCEEDED(hrRet) && !fAbort)
    {
        /* Note that CoInitialize and CoUninitialize must be done once per thread. */
        if(!fCOMInitialized)
        {
            if(SUCCEEDED(CoInitialize(NULL)))
            {
                fCOMInitialized = TRUE;
            }
        }
        if (fCOMInitialized) {
            if (!pAllocator)
            {
                hrRet = CoGetMalloc(MEMCTX_TASK, &pAllocator);
            }
            if (pAllocator) {

                //Cycle through list of rating procs till one gives us the answer, we abort, or there are no more
                int nRatingHelperProcs = ::paRatingHelpers->Length();
                for (nProc = 0; nProc < nRatingHelperProcs; ++nProc)
                {
                    IObtainRating *pHelper;
                    if (SUCCEEDED(CoCreateInstance((*paRatingHelpers)[nProc].clsid, NULL,
                                                   CLSCTX_INPROC_SERVER,
                                                   IID_IObtainRating,
                                                   (LPVOID *)&pHelper))) {
                        hrRet  = pHelper->ObtainRating(pOrd->nlsTargetUrl.QueryPch(),
                                        pOrd->hAbortEvent, pAllocator, &pszRating);
                        pHelper->Release();
#ifdef DEBUG
                        pHelper = NULL;
#endif
                    }
                    fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(pOrd->hAbortEvent, 0));
                    if (fAbort || SUCCEEDED(hrRet)) break;
                }
            }
        }
        else
            hrRet = E_RATING_NOT_FOUND;
    }

    /*return results to user*/
    if (!fAbort)
    {
        /*
         * If one of the providers found a rating, we must call CheckUserAccess
         * and tell the client whether the user has access or not.  If we did
         * not find a rating, then we tell the client that, by passing the
         * callback a code of E_RATING_NOT_FOUND.
         *
         * The provider may also return S_RATING_ALLOW or S_RATING_DENY, which
         * means that it has already checked the user's access (for example,
         * against a system-wide exclusion list).
         */
        if (hrRet == S_RATING_FOUND)
        {
            hrRet = RatingCheckUserAccess(NULL, pOrd->nlsTargetUrl.QueryPch(),
                                          pszRating, NULL, PICS_LABEL_FROM_BUREAU,
                                          &lpvRatingDetails);
        }
        else
        {
            if(S_RATING_DENY == hrRet && g_fIsRunningUnderCustom)
            {
                lpvRatingDetails = (LPVOID)(new CParsedLabelList);
                if (lpvRatingDetails)
                {
                    ((CParsedLabelList*)lpvRatingDetails)->m_fDenied = TRUE;
                    ((CParsedLabelList*)lpvRatingDetails)->m_pszURL = StrDup(pOrd->nlsTargetUrl.QueryPch());
                }
                else
                {
                    hrRet = E_OUTOFMEMORY;
                }
            }
        }

        if (S_RATING_DENY == hrRet && g_fIsRunningUnderCustom)
        {
            // lpvRatingDetails should be non NULL at this point
            ASSERT(lpvRatingDetails);

            ((CParsedLabelList*)lpvRatingDetails)->m_fIsHelper = TRUE;
            if(fFoundWithCustomHelper)
            {
                ((CParsedLabelList*)lpvRatingDetails)->m_fIsCustomHelper = TRUE;
                if (pszRatingName)
                {
                    if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName = new char[strlen(pszRatingName)+1])
                    {
                        strcpyf(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName,pszRatingName);
                    } // if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingName = new char[strlen(pszRatingName)+1])

                }
                if (pszRatingReason)
                {
                    if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason = new char[strlen(pszRatingReason)+1])
                    {
                        strcpyf(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason, pszRatingReason);
                    } // if(((CParsedLabelList*)lpvRatingDetails)->m_pszRatingReason = new char[strlen(pszRatingReason)+1])
                }
            }
        }

        /* Range-check other success codes to make sure they're not anything
         * that the browser callback isn't expecting.
         */
        if (SUCCEEDED(hrRet) && (hrRet != S_RATING_ALLOW && hrRet != S_RATING_DENY))
            hrRet = E_RATING_NOT_FOUND;
        (*pOrd->fCallback)(pOrd->dwUserData, hrRet, pszRating, (LPVOID) lpvRatingDetails);
    }

    /*cleanup*/
    delete pOrd;
    pOrd = NULL;

    if (pAllocator != NULL) {
        pAllocator->Free(pszRating);
        if(pszRatingName)
        {
            pAllocator->Free(pszRatingName);
        }
        if(pszRatingReason)
        {
            pAllocator->Free(pszRatingReason);
        }
        pAllocator->Release();
    }

    if (fCOMInitialized)
        CoUninitialize();

    return (DWORD) fAbort;
}




/*Public Functions----------------------------------------------------------*/

//Startup thread that finds rating, return immediately
HRESULT WINAPI RatingObtainQuery(LPCTSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, LPVOID lpvRatingDetails), HANDLE *phRatingObtainQuery)
{
    RatingObtainData *pOrd;
    HANDLE hThread;
    DWORD dwThid;

    CheckGlobalInfoRev();

    if (!g_fIsRunningUnderCustom)
    {
        if (::RatingEnabledQuery() != S_OK ||
            !gPRSI->fSettingsValid)         /* ratings not enabled? fail immediately. */
            return E_RATING_NOT_FOUND;
    }

    InitRatingHelpers();

    if (NULL == g_pCustomRatingHelperList
            && (::paRatingHelpers == NULL || ::paRatingHelpers->Length() < 1)) {

        return E_RATING_NOT_FOUND;
    }

    if (fCallback && pszTargetUrl)
    {
        pOrd = new RatingObtainData(pszTargetUrl);
        if (pOrd)
        {
            if (pOrd->nlsTargetUrl.QueryError() == ERROR_SUCCESS) {
                pOrd->dwUserData   = dwUserData;
                pOrd->fCallback    = fCallback;
                pOrd->hAbortEvent  = CreateEvent(NULL, TRUE, FALSE, NULL);

                if (pOrd->hAbortEvent)
                {
                    hThread = CreateThread(NULL, 0, RatingCycleThread, (LPVOID) pOrd, 0, &dwThid);
                    if (hThread)
                    {
                        CloseHandle(hThread);
                        if (phRatingObtainQuery) *phRatingObtainQuery = pOrd->hAbortEvent;
                        return NOERROR;
                    }
                    CloseHandle(pOrd->hAbortEvent);
                }
            }

            delete pOrd;
            pOrd = NULL;
        }
    }

    return E_FAIL;
}

//Cancel an existing query
HRESULT WINAPI RatingObtainCancel(HANDLE hRatingObtainQuery)
{
    //what happens if hRatingObtainQuery has already been closed?!?!
    if (hRatingObtainQuery)
    {
        if (SetEvent(hRatingObtainQuery)) return NOERROR;
    }
    return E_HANDLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\rors.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _RORS_H_
#define _RORS_H_


/*Includes-----------------------------------------------------------*/


/*Prototypes---------------------------------------------------------*/

class CRORemoteSite : public IObtainRating
{
private:
    UINT m_cRef;

public:
    CRORemoteSite() { m_cRef = 1; }
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

    STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut);

    STDMETHOD_(ULONG,GetSortOrder) (THIS);
};

#endif 
//_RORS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\superpw.cpp ===
#include "msrating.h"
#include "msluglob.h"
#include "mslubase.h"
#include "hint.h"
#include "debug.h"
#include <md5.h>

extern PicsRatingSystemInfo *gPRSI;

HRESULT VerifySupervisorPassword(LPCSTR pszPassword)
{
    if ( ! ::fSupervisorKeyInit )
    {
        HKEY hkeyRating;
        LONG err;

        hkeyRating = CreateRegKeyNT(::szRATINGS);
        if (hkeyRating !=  NULL)
        {
            DWORD cbData = sizeof(::abSupervisorKey);
            DWORD dwType;

            // Attempt to look for "Key"
            err = ::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                                    &dwType, (LPBYTE)::abSupervisorKey, &cbData);

            ::RegCloseKey(hkeyRating);
            hkeyRating = NULL;

            if (err == ERROR_SUCCESS)
            {
                if (dwType != REG_BINARY || cbData != sizeof(::abSupervisorKey))
                {
                    TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Unexpected Error dwType=%d, cbData=%d!", dwType, cbData );
                    return E_UNEXPECTED;
                }

                ::fSupervisorKeyInit = TRUE;
            }
            else
            {
                if (pszPassword == NULL)
                {
                    TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Supervisor Key '%s' not found!", ::szRatingsSupervisorKeyName );
                    return E_FAIL;
                }
            }
        }
        else
        {
            TraceMsg( TF_ERROR, "VerifySupervisorPassword() - Failed to Create Ratings Registry Key!" );
            err = ERROR_FILE_NOT_FOUND;
        }

        if (err != ERROR_SUCCESS)
        {
            TraceMsg( TF_WARNING, "VerifySupervisorPassword() - Error=0x%x!", err );
            return HRESULT_FROM_WIN32(err);
        }
    }

    if (pszPassword == NULL)
    {
        TraceMsg( TF_ALWAYS, "VerifySupervisorPassword() - Comparing to NULL pszPassword returning S_FALSE." );
        return ResultFromScode(S_FALSE);
    }

    // We should probably not be comparing to a blank password.
//  ASSERT( pszPassword[0] != '\0' );

    if ( pszPassword[0] == '\0' )
    {
        TraceMsg( TF_ALWAYS, "VerifySupervisorPassword() - Comparing to blank pszPassword." );
    }

    MD5_CTX ctx;

    MD5Init(&ctx);
    MD5Update(&ctx, (const BYTE *)pszPassword, ::strlenf(pszPassword)+1);
    MD5Final(&ctx);

    return ResultFromScode(::memcmpf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey)) ? S_FALSE : S_OK);
}


HRESULT ChangeSupervisorPassword(LPCSTR pszOldPassword, LPCSTR pszNewPassword)
{
    HRESULT hres;

    hres = ::VerifySupervisorPassword(pszOldPassword);
    if (hres == S_FALSE)
    {
        TraceMsg( TF_WARNING, "ChangeSupervisorPassword() - VerifySupervisorPassword() false!" );
        return E_ACCESSDENIED;
    }

    // If pszNewPassword is NULL or "" (blank password) we call RemoveSupervisorPassword().
    if ( ! pszNewPassword )
    {
        TraceMsg( TF_ALWAYS, "ChangeSupervisorPassword() - pszNewPassword is NULL - Removing Supervisor Password!" );
        return RemoveSupervisorPassword();
    }

    // Attempting to set a blank password should remove the Key from the Registry.
    if ( pszNewPassword[0] == '\0' )
    {
        TraceMsg( TF_ALWAYS, "ChangeSupervisorPassword() - pszNewPassword is an empty string - Removing Supervisor Password!" );
        return RemoveSupervisorPassword();
    }

    MD5_CTX ctx;

    MD5Init(&ctx);
    MD5Update(&ctx, (const BYTE *)pszNewPassword, ::strlenf(pszNewPassword)+1);
    MD5Final(&ctx);

    ::memcpyf(::abSupervisorKey, ctx.digest, sizeof(::abSupervisorKey));
    ::fSupervisorKeyInit = TRUE;

    hres = NOERROR;

    HKEY hkeyRating;

    hkeyRating = CreateRegKeyNT(::szRATINGS);
    if (hkeyRating != NULL)
    {
        BYTE abTemp[sizeof(::abSupervisorKey)];
        DWORD cbData = sizeof(::abSupervisorKey);
        DWORD dwType;
        if (::RegQueryValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                              &dwType, abTemp, &cbData) != ERROR_SUCCESS)
        {
            hres = S_FALSE; /* tell caller we're creating the new key */
        }

        ::RegSetValueEx(hkeyRating, ::szRatingsSupervisorKeyName, NULL,
                        REG_BINARY, (const BYTE *)::abSupervisorKey, sizeof(::abSupervisorKey));
        ::RegCloseKey(hkeyRating);
    }
    else
    {
        TraceMsg( TF_ERROR, "ChangeSupervisorPassword() - Failed to Create Ratings Registry Key!" );
        hres = E_FAIL;
    }

    return hres;
}


HRESULT RemoveSupervisorPassword(void)
{
    HKEY hkeyRating;
    LONG err = E_FAIL;

    hkeyRating = CreateRegKeyNT(::szRATINGS);
    if (hkeyRating !=  NULL)
    {
        err = ::RegDeleteValue(hkeyRating, ::szRatingsSupervisorKeyName);

        if ( err == ERROR_SUCCESS )
        {
            CHint           hint;

            hint.RemoveHint();

            TraceMsg( TF_ALWAYS, "RemoveSupervisorPassword() - Removed supervisor password and hint." );
        }

        ::RegCloseKey(hkeyRating);
        hkeyRating = NULL;
    }
    else
    {
        TraceMsg( TF_ERROR, "RemoveSupervisorPassword() - Failed to Create Ratings Registry Key!" );
    }

    if ( gPRSI )
    {
        gPRSI->fRatingInstalled = FALSE;
    }

    ::fSupervisorKeyInit = FALSE;
    return HRESULT_FROM_WIN32(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\toffdlg.h ===
/****************************************************************************\
 *
 *   toffdlg.h
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Turn Off Ratings Dialog
 *
\****************************************************************************/

#ifndef TURN_OFF_DIALOG_H
#define TURN_OFF_DIALOG_H

#include "basedlg.h"        // CBaseDialog

class CTurnOffDialog: public CBaseDialog<CTurnOffDialog>
{
public:
    enum { IDD = IDD_TURNOFF };

public:
    CTurnOffDialog();

public:
    typedef CTurnOffDialog thisClass;
    typedef CBaseDialog<thisClass> baseClass;

    BEGIN_MSG_MAP(thisClass)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)

        COMMAND_ID_HANDLER(IDOK, OnOK)

        CHAIN_MSG_MAP(baseClass)
    END_MSG_MAP()

protected:
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\toffdlg.cpp ===
/****************************************************************************\
 *
 *   toffdlg.cpp
 *
 *   Created:   William Taylor (wtaylor) 01/22/01
 *
 *   MS Ratings Turn Off Ratings Dialog
 *
\****************************************************************************/

#include "msrating.h"
#include "mslubase.h"
#include "toffdlg.h"        // CTurnOffDialog
#include "debug.h"

CTurnOffDialog::CTurnOffDialog()
{
    // Add construction here...
}

LRESULT CTurnOffDialog::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    SendDlgItemMessage(IDC_ADVISOR_OFF_CHECK,BM_SETCHECK,(WPARAM) BST_UNCHECKED,(LPARAM) 0);

    bHandled = FALSE;
    return 1L;  // Let the system set the focus
}

LRESULT CTurnOffDialog::OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
{
    if(BST_CHECKED==SendDlgItemMessage(IDC_ADVISOR_OFF_CHECK,
                                       BM_GETCHECK,
                                       (WPARAM) 0,
                                       (LPARAM) 0))
    {
        HKEY            hkeyRating;

        hkeyRating = CreateRegKeyNT(::szRATINGS);

        if ( hkeyRating != NULL )
        {
            CRegKey         key;

            key.Attach( hkeyRating );

            DWORD dwTurnOff=1;

            key.SetValue( dwTurnOff, szTURNOFF );
        }
        else
        {
            TraceMsg( TF_ERROR, "CTurnOffDialog::OnOK() - Failed to Create Ratings Registry Key!" );
        }
    }

    EndDialog(TRUE);

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\resdll\makefile.inc ===
..\msratelc.rc : $(MSRATING_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\msrating\rors.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

/*Included Files------------------------------------------------------------*/
#include "msrating.h"
#pragma hdrstop

#include <npassert.h>
#include <buffer.h>
#include "ratings.h"
#include "mslubase.h"
#include "parselbl.h"

#include "rors.h"
#include "wininet.h"


typedef HINTERNET (WINAPI *PFNInternetOpen)(
    IN LPCTSTR lpszCallerName,
    IN DWORD dwAccessType,
    IN LPCTSTR lpszServerName OPTIONAL,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags
    );
typedef BOOL (WINAPI *PFNInternetCloseHandle)(
    IN HINTERNET hInternet
    );
typedef HINTERNET (WINAPI *PFNInternetConnect)(
    IN HINTERNET hInternet,
    IN LPCTSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCTSTR lpszUsername OPTIONAL,
    IN LPCTSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
typedef BOOL (WINAPI *PFNInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );
typedef INTERNET_STATUS_CALLBACK (WINAPI *PFNInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );
typedef HINTERNET (WINAPI *PFNHttpOpenRequest)(
    IN HINTERNET hHttpSession,
    IN LPCTSTR lpszVerb,
    IN LPCTSTR lpszObjectName,
    IN LPCTSTR lpszVersion,
    IN LPCTSTR lpszReferrer OPTIONAL,
    IN LPCTSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    );
typedef BOOL (WINAPI *PFNHttpSendRequest)(
    IN HINTERNET hHttpRequest,
    IN LPCTSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );
typedef BOOL (WINAPI *PFNInternetCrackUrl)(
    IN LPCTSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );
typedef BOOL (WINAPI *PFNInternetCanonicalizeUrl)(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


PFNInternetReadFile pfnInternetReadFile = NULL;
PFNHttpSendRequest pfnHttpSendRequest = NULL;
PFNInternetOpen pfnInternetOpen = NULL;
PFNInternetSetStatusCallback pfnInternetSetStatusCallback = NULL;
PFNInternetConnect pfnInternetConnect = NULL;
PFNHttpOpenRequest pfnHttpOpenRequest = NULL;
PFNInternetCloseHandle pfnInternetCloseHandle = NULL;
PFNInternetCrackUrl pfnInternetCrackUrl = NULL;
PFNInternetCanonicalizeUrl pfnInternetCanonicalizeUrl = NULL;

#undef InternetReadFile
#undef HttpSendRequest
#undef InternetOpen
#undef InternetSetStatusCallback
#undef InternetConnect
#undef HttpOpenRequest
#undef InternetCloseHandle
#undef InternetCrackUrl
#undef InternetCanonicalizeUrl

#define InternetReadFile pfnInternetReadFile
#define HttpSendRequest pfnHttpSendRequest
#define InternetOpen pfnInternetOpen
#define InternetSetStatusCallback pfnInternetSetStatusCallback
#define InternetConnect pfnInternetConnect
#define HttpOpenRequest pfnHttpOpenRequest
#define InternetCloseHandle pfnInternetCloseHandle
#define InternetCrackUrl pfnInternetCrackUrl
#define InternetCanonicalizeUrl pfnInternetCanonicalizeUrl

struct {
    FARPROC *ppfn;
    LPCSTR pszName;
} aImports[] = {
#ifndef UNICODE
    { (FARPROC *)&pfnInternetReadFile, "InternetReadFile" },
    { (FARPROC *)&pfnHttpSendRequest, "HttpSendRequestA" },
    { (FARPROC *)&pfnInternetOpen, "InternetOpenA" },
    { (FARPROC *)&pfnInternetSetStatusCallback, "InternetSetStatusCallback" },
    { (FARPROC *)&pfnInternetConnect, "InternetConnectA" },
    { (FARPROC *)&pfnHttpOpenRequest, "HttpOpenRequestA" },
    { (FARPROC *)&pfnInternetCloseHandle, "InternetCloseHandle" },
    { (FARPROC *)&pfnInternetCrackUrl, "InternetCrackUrlA" },
    { (FARPROC *)&pfnInternetCanonicalizeUrl, "InternetCanonicalizeUrlA" },
#else
    { (FARPROC *)&pfnInternetReadFile, "InternetReadFile" },
    { (FARPROC *)&pfnHttpSendRequest, "HttpSendRequestW" },
    { (FARPROC *)&pfnInternetOpen, "InternetOpenW" },
    { (FARPROC *)&pfnInternetSetStatusCallback, "InternetSetStatusCallback" },
    { (FARPROC *)&pfnInternetConnect, "InternetConnectW" },
    { (FARPROC *)&pfnHttpOpenRequest, "HttpOpenRequestW" },
    { (FARPROC *)&pfnInternetCloseHandle, "InternetCloseHandle" },
    { (FARPROC *)&pfnInternetCrackUrl, "InternetCrackUrlW" },
    { (FARPROC *)&pfnInternetCanonicalizeUrl, "InternetCanonicalizeUrlW" },
#endif
};

const UINT cImports = sizeof(aImports) / sizeof(aImports[0]);

HINSTANCE hWinINet = NULL;
BOOL fTriedLoad = FALSE;
HINTERNET hI = NULL;

void _stdcall WinInetCallbackProc(HINTERNET hInternet, DWORD_PTR Context, DWORD Status, LPVOID Info, DWORD Length);
#define USER_AGENT_STRING "Batcave(bcrs)"


BOOL LoadWinINet(void)
{
    if (fTriedLoad)
    {
        return (hWinINet != NULL);
    }

    fTriedLoad = TRUE;

    hWinINet = ::LoadLibrary("WININET.DLL");
    if (hWinINet == NULL)
    {
        return FALSE;
    }

    for (UINT i=0; i<cImports; i++)
    {
        *(aImports[i].ppfn) = ::GetProcAddress(hWinINet, aImports[i].pszName);
        if (*(aImports[i].ppfn) == NULL)
        {
            CleanupWinINet();
            return FALSE;
        }
    }

    hI = InternetOpen(USER_AGENT_STRING, PRE_CONFIG_INTERNET_ACCESS, NULL, 0, INTERNET_FLAG_ASYNC);
    if (hI == NULL)
    {
        CleanupWinINet();
        return FALSE;
    }

    InternetSetStatusCallback(hI, WinInetCallbackProc);

    return TRUE;
}


void CleanupWinINet(void)
{
    if (hI != NULL)
    {
        InternetCloseHandle(hI);
        hI = NULL;
    }

    if (hWinINet != NULL)
    {
        for (UINT i=0; i<cImports; i++)
        {
            *(aImports[i].ppfn) = NULL;
        }

        ::FreeLibrary(hWinINet);
        hWinINet = NULL;
    }
}


void _stdcall WinInetCallbackProc(HINTERNET hInternet, DWORD_PTR Context, DWORD Status, LPVOID Info, DWORD Length)
{
    BOOL unknown = FALSE;
    HANDLE  hAsyncEvent = (HANDLE) Context;

    char *type$;
    switch (Status)
    {
        case INTERNET_STATUS_RESOLVING_NAME:
        type$ = "RESOLVING NAME";
        break;

        case INTERNET_STATUS_NAME_RESOLVED:
        type$ = "NAME RESOLVED";
        break;

        case INTERNET_STATUS_CONNECTING_TO_SERVER:
        type$ = "CONNECTING TO SERVER";
        break;

        case INTERNET_STATUS_CONNECTED_TO_SERVER:
        type$ = "CONNECTED TO SERVER";
        break;

        case INTERNET_STATUS_SENDING_REQUEST:
        type$ = "SENDING REQUEST";
        break;

        case INTERNET_STATUS_REQUEST_SENT:
        type$ = "REQUEST SENT";
        break;

        case INTERNET_STATUS_RECEIVING_RESPONSE:
        type$ = "RECEIVING RESPONSE";
        break;

        case INTERNET_STATUS_RESPONSE_RECEIVED:
        type$ = "RESPONSE RECEIVED";
        break;

        case INTERNET_STATUS_CLOSING_CONNECTION:
        type$ = "CLOSING CONNECTION";
        break;

        case INTERNET_STATUS_CONNECTION_CLOSED:
        type$ = "CONNECTION CLOSED";
        break;

        case INTERNET_STATUS_REQUEST_COMPLETE:
        type$ = "REQUEST COMPLETE";
        SetEvent(hAsyncEvent);
        break;

        default:
        type$ = "???";
        unknown = TRUE;
        break;
    }

/*
    printf("callback: handle %x [context %x ] %s \n",
        hInternet,
        Context,
        type$
        );
*/
}

#define ABORT_EVENT 0
#define ASYNC_EVENT 1


BOOL ShouldAbort(HANDLE hAbort)
{
    return (WAIT_OBJECT_0 == WaitForSingleObject(hAbort, 0));
}

BOOL WaitForAsync(HANDLE rgEvents[])
{
    BOOL fAbort;

//  if (ERROR_IO_PENDING != GetLastError()) return FALSE;       

    fAbort = (WAIT_OBJECT_0 == WaitForMultipleObjects(2, rgEvents, FALSE, INFINITE));
//  fAbort = (WAIT_OBJECT_0 == WaitForSingleObject(rgEvents[ABORT_EVENT], 0));

    return !fAbort;
}


void EncodeUrl(LPCTSTR pszTargetUrl, char *pBuf)
{
    while (*pszTargetUrl)
    {
        switch (*pszTargetUrl)
        {
        case ':':
            *pBuf++ = '%';
            *pBuf++ = '3';
            *pBuf++ = 'A';
            break;
        case '/':
            *pBuf++ = '%';
            *pBuf++ = '2';
            *pBuf++ = 'F';
            break;      
        default:
            *pBuf++ = *pszTargetUrl;
            break;
        }

        ++pszTargetUrl; 
    }

    *pBuf = 0;
}


STDMETHODIMP CRORemoteSite::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IObtainRating))
    {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CRORemoteSite::AddRef(void)
{
    RefThisDLL(TRUE);

    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CRORemoteSite::Release(void)
{
    RefThisDLL(FALSE);

    if (!--m_cRef)
    {
        delete this;
        return 0;
    }
    else
    {
        return m_cRef;
    }
}


LPSTR FindRatingLabel(LPSTR pszResponse)
{
    /* pszResponse is the complete response message from the HTTP server.
     * It could be a simple response (just the PICS label we want) or it
     * could be a full response including headers.  In the former case we
     * just return the label, in the latter we have to skip the headers
     * to the message body.
     *
     * To be extra tolerant of poorly written label bureaus, we start by
     * looking at the start of the data to see if it's a left paren.  If
     * it isn't, we assume we've got some headers, so we skip to the
     * double CRLF which HTTP requires to terminate headers.  We don't
     * require a Status-Line (such as "HTTP/1.1 200 OK") even though
     * technically HTTP does.  If we don't find the double CRLF, then
     * we look for the string "(PICS-" which is usually what begins a
     * PICS label list.  If they've done everything else wrong and they're
     * also perverse enough to insert whitespace there (such as "( PICS-"),
     * tough.
     */

    SkipWhitespace(&pszResponse);       /* skip leading whitespace just in case */
    if (*pszResponse != '(')
    {          /* doesn't seem to start with a label */
        LPSTR pszBody = ::strstrf(pszResponse, ::szDoubleCRLF);
        if (pszBody != NULL)
        {          /* found double CRLF, end of HTTP headers */
            pszResponse = pszBody + 4;  /* length of CRLFCRLF */
        }
        else
        {                          /* no double CRLF, hunt for PICS label */
            pszBody = ::strstrf(pszResponse, ::szPicsOpening);
            if (pszBody != NULL)
            {
                pszResponse = pszBody;  /* beginning of PICS label */
            }
        }
    }

    return pszResponse;
}


const char szRequestTemplate[] = "?opt=normal&u=\"";
const UINT cchRequestTemplate = sizeof(szRequestTemplate) + 1;

STDMETHODIMP CRORemoteSite::ObtainRating(THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
                             IMalloc *pAllocator, LPSTR *ppRatingOut)
{
    HINTERNET hIC, hH;
    HANDLE  rgEvents[2];
    BOOL fRet;
    HRESULT hrRet = E_RATING_NOT_FOUND;
    char rgBuf[10000], *pBuf;   // PERF - way too much stack!
    DWORD  nRead, nBuf = sizeof(rgBuf) - 1;
    LPSTR pszRatingServer;

    if (!gPRSI->etstrRatingBureau.fIsInit())
    {
        return hrRet;
    }

    if (!LoadWinINet())
    {
        return hrRet;
    }

    pszRatingServer = gPRSI->etstrRatingBureau.Get();

    BUFFER bufBureauHostName(INTERNET_MAX_HOST_NAME_LENGTH);
    BUFFER bufBureauPath(INTERNET_MAX_PATH_LENGTH);

    if (!bufBureauHostName.QueryPtr() || !bufBureauPath.QueryPtr())
    {
        return E_OUTOFMEMORY;
    }

    URL_COMPONENTS uc;

    uc.dwStructSize = sizeof(uc);
    uc.lpszScheme = NULL;
    uc.dwSchemeLength = 0;
    uc.lpszHostName = (LPSTR)bufBureauHostName.QueryPtr();
    uc.dwHostNameLength = bufBureauHostName.QuerySize();
    uc.lpszUserName = NULL;
    uc.dwUserNameLength = 0;
    uc.lpszPassword = NULL;
    uc.dwPasswordLength = 0;
    uc.lpszUrlPath = (LPSTR)bufBureauPath.QueryPtr();
    uc.dwUrlPathLength = bufBureauPath.QuerySize();
    uc.lpszExtraInfo = NULL;
    uc.dwExtraInfoLength = 0;

    if (!InternetCrackUrl(pszRatingServer, 0, 0, &uc))
    {
        return HRESULT_FROM_WIN32(GetLastError());
    }

    BUFFER bufRequest(INTERNET_MAX_URL_LENGTH + uc.dwUrlPathLength + cchRequestTemplate);

    LPSTR pszRequest = (LPSTR)bufRequest.QueryPtr();
    if (pszRequest == NULL)
    {
        return E_OUTOFMEMORY;
    }

    LPSTR pszCurrent = pszRequest;
    ::strcpyf(pszCurrent, uc.lpszUrlPath);
    pszCurrent += uc.dwUrlPathLength;

    ::strcpyf(pszCurrent, szRequestTemplate);
    pszCurrent += ::strlenf(pszCurrent);

    /* Encode the target URL. */
    EncodeUrl(pszTargetUrl, pszCurrent);

    ::strcatf(pszCurrent, "\"");

    hIC = hH = NULL;
    
    rgEvents[ABORT_EVENT] = hAbortEvent;
    rgEvents[ASYNC_EVENT] = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (!rgEvents[ASYNC_EVENT])
    {
        goto STATE_CLEANUP;
    }

    hIC = InternetConnect(hI, uc.lpszHostName, uc.nPort, NULL, NULL,
                          INTERNET_SERVICE_HTTP, 0, (DWORD_PTR) rgEvents[ASYNC_EVENT]);
    if (hIC == NULL || ShouldAbort(hAbortEvent))
    {
        goto STATE_CLEANUP;
    }

    hH = HttpOpenRequest(hIC, "GET", pszRequest, NULL, NULL, NULL,
                         INTERNET_FLAG_DONT_CACHE | INTERNET_FLAG_RELOAD,
                         (DWORD_PTR) rgEvents[ASYNC_EVENT]);
    if (hH == NULL || ShouldAbort(hAbortEvent))
    {
        goto STATE_CLEANUP;
    }

    fRet = HttpSendRequest(hH, NULL, (DWORD) 0, NULL, 0);
    if (!fRet && !WaitForAsync(rgEvents))
    {
        goto STATE_CLEANUP;
    }

    pBuf  = rgBuf;
    nRead = 0;
    do
    {
        fRet = InternetReadFile(hH, pBuf, nBuf-nRead, &nRead);
        if (!fRet && !WaitForAsync(rgEvents))
        {
            goto STATE_CLEANUP;
        }

        if (nRead)
        {
            pBuf += nRead;
            hrRet = NOERROR;
        }

    } while (nRead);
        

STATE_CLEANUP:
    if (hH)  InternetCloseHandle(hH);
    if (hIC) InternetCloseHandle(hIC);
    if (rgEvents[ASYNC_EVENT])
    {
        CloseHandle(rgEvents[ASYNC_EVENT]);
    }

    if (hrRet == NOERROR)
    {
        (*ppRatingOut) = (char*) pAllocator->Alloc((int)(pBuf - rgBuf + 1));
        if (*ppRatingOut != NULL)
        {
            *pBuf = '\0';
            LPSTR pszLabel = FindRatingLabel(rgBuf);
            strcpyf(*ppRatingOut, pszLabel);
        }
        else
        {
            hrRet = ResultFromScode(E_OUTOFMEMORY);
        }
    }

    if (hrRet == NOERROR)
    {
        hrRet = S_RATING_FOUND;
    }

    return hrRet;
}



STDMETHODIMP_(ULONG) CRORemoteSite::GetSortOrder(THIS)
{
    return RATING_ORDER_REMOTESITE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\npstub\nphook.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPHOOK.H -- Internal header for hooking calls into network providers.
 *
 *
 * History:
 *  05/17/94    lens   Created.
 *
 */

#include <npdefs.h>
#include <netspi.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define ORD_NPSHookMPR               222
#define ORD_NPSUnHookMPR             223
#define ORD_NPSUnHookMe              224
#define ORD_NPSGetHandleFromInstance 225

#define NPSHookMPR NPSHookMPRA
#define NPSUnHookMPR NPSUnHookMPRA
#define NPSUnHookMe NPSUnHookMeA
#define NPSGetHandleFromInstance NPSGetHandleFromInstanceA

typedef HMODULE F_LoadLibrary(
    LPCTSTR  lpszLibFile
    );
typedef F_LoadLibrary *PF_LoadLibrary;

typedef BOOL F_FreeLibrary(
    HMODULE hLibModule
    );
typedef F_FreeLibrary *PF_FreeLibrary;

typedef FARPROC F_GetProcAddress(
    HMODULE hModule,
    LPCSTR  lpszProc
    );
typedef F_GetProcAddress *PF_GetProcAddress;

typedef HANDLE16 F_LoadLibrary16(
    LPCTSTR  lpszLibFile
    );
typedef F_LoadLibrary16 *PF_LoadLibrary16;

typedef VOID F_FreeLibrary16(
    HANDLE16 hLibModule
    );
typedef F_FreeLibrary16 *PF_FreeLibrary16;

typedef DWORD WINAPI F_GetProcAddressByName16(
    LPCSTR   lpszProc,
    HANDLE16 hModule
    );
typedef F_GetProcAddressByName16 *PF_GetProcAddressByName16;

typedef DWORD WINAPI F_GetProcAddressByOrdinal16(
    WORD     wOrdinal,
    HANDLE16 hModule
    );
typedef F_GetProcAddressByOrdinal16 *PF_GetProcAddressByOrdinal16;

typedef DWORD NPSERVICE F_NPSHookMPR(
    struct _MPRCALLS *pMPRCalls
    );
typedef F_NPSHookMPR *PF_NPSHookMPR;

F_NPSHookMPR NPSHookMPR;

typedef DWORD NPSERVICE F_UnHookMPR(
    PF_NPSHookMPR pfNPSHookMPR, 
    struct _MPRCALLS *pMPRCalls
    );
typedef F_UnHookMPR *PF_UnHookMPR;

typedef DWORD NPSERVICE F_NPSUnHookMPR(
    PF_NPSHookMPR pfReqNPSHookMPR, 
    struct _MPRCALLS *pReqMPRCalls,
    struct _MPRCALLS *pChainedMPRCalls
    );
typedef F_NPSUnHookMPR *PF_NPSUnHookMPR;

F_NPSUnHookMPR NPSUnHookMPR;

typedef DWORD NPSERVICE F_NPSUnHookMe(
    PF_NPSHookMPR pfMyNPSHookMPR, 
    struct _MPRCALLS *pChainedMPRCalls
    );
typedef F_NPSUnHookMe *PF_NPSUnHookMe;

F_NPSUnHookMe NPSUnHookMe;

typedef struct _MPRCALLS {
    PF_NPSHookMPR       pfNPSHookMPR;       /* NPSHookMPR call */
    PF_UnHookMPR        pfUnHookMPR;        /* UnHookMPR call */
    PF_LoadLibrary      pfLoadLibrary;      /* LoadLibrary call */
    PF_FreeLibrary      pfFreeLibrary;      /* FreeLibrary call */
    PF_GetProcAddress   pfGetProcAddress;   /* GetProcAddress call */
    PF_LoadLibrary16    pfLoadLibrary16;    /* LoadLibrary call */
    PF_FreeLibrary16    pfFreeLibrary16;    /* FreeLibrary call */
    PF_GetProcAddressByName16 pfGetProcAddressByName16; /* GetProcAddress call */
    PF_GetProcAddressByOrdinal16 pfGetProcAddressByOrdinal16; /* GetProcAddress call */
} MPRCALLS, *PMPRCALLS;

typedef HPROVIDER NPSERVICE F_NPSGetHandleFromInstance(
    BOOL    bWinnet16, 
	LPVOID  phInstance
	);
typedef F_NPSGetHandleFromInstance *PF_NPSGetHandleFromInstance;

F_NPSGetHandleFromInstance NPSGetHandleFromInstance;

#ifdef __cplusplus
}
#endif  /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\npstub\npord.h ===
/*****************************************************************/
/**               Microsoft Windows for Workgroups              **/
/**           Copyright (C) Microsoft Corp., 1991-1992          **/
/*****************************************************************/

/* NPORD.H -- Network service provider ordinal definitions.
 *
 * This is a PRIVATE header file.  Nobody but the MNR needs to call
 * a network provider directly.
 *
 * History:
 *  03/29/93    gregj   Created
 *  05/27/97    gregj   Taken from WNET source to implement NP delay load stub
 *
 */

#ifndef _INC_NPORD
#define _INC_NPORD

#ifndef RC_INVOKED
#pragma pack(1)         /* Assume byte packing throughout */
#endif /* !RC_INVOKED */

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

#define ORD_GETCONNECTIONS      12
#define ORD_GETCAPS             13
//#define ORD_DEVICEMODE          14      /* no longer supported */
#define ORD_GETUSER             16
#define ORD_ADDCONNECTION       17
#define ORD_CANCELCONNECTION    18
//#define ORD_PROPERTYDIALOG      29      /* no longer supported */
//#define ORD_GETDIRECTORYTYPE    30      /* no longer supported */      
//#define ORD_DIRECTORYNOTIFY     31      /* no longer supported */     
//#define ORD_GETPROPERTYTEXT     32      /* no longer supported */
#define ORD_OPENENUM            33
#define ORD_ENUMRESOURCE        34
#define ORD_CLOSEENUM           35
#define ORD_GETUNIVERSALNAME    36
//#define ORD_SEARCHDIALOG        38      /* no longer supported */
#define ORD_GETRESOURCEPARENT   41
#define ORD_VALIDDEVICE         42
#define ORD_LOGON               43
#define ORD_LOGOFF              44
#define ORD_GETHOMEDIRECTORY    45
#define ORD_FORMATNETWORKNAME   46
#define ORD_GETCONNPERFORMANCE  49
#define ORD_GETPOLICYPATH    	50
#define ORD_GETRESOURCEINFORMATION   52

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#ifndef RC_INVOKED
#pragma pack()
#endif  /* !RC_INVOKED */

#endif  /* !_INC_NPORD */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\npstub\npstub.h ===
/*****************************************************************/
/**				  Microsoft Windows for Workgroups				**/
/**		      Copyright (C) Microsoft Corp., 1991-1997			**/
/*****************************************************************/ 

/* NPSTUB.H -- Definitions for example hooking network provider DLL.
 *
 * History:
 *	06/02/94	lens	Created
 */

#include <windows.h>
#include <netspi.h>

// Macros to define process local storage:

#define PROCESS_LOCAL_BEGIN data_seg(".PrcLcl","INSTANCE")
#define PROCESS_LOCAL_END data_seg()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\defguid.h ===
// GUID for this server
extern const GUID CLSID_Sample;
extern const char szOurGUID[];

// 19427BA0-826C-11CF-8DAB-00AA006C1A01
extern const GUID IID_IObtainRating;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\classes.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

class CSampleObtainRating : public IObtainRating
{
private:
	UINT m_cRef;

public:
	CSampleObtainRating();
	~CSampleObtainRating();
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef) (THIS);
    STDMETHOD_(ULONG,Release) (THIS);

	STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut);

	STDMETHOD_(ULONG,GetSortOrder) (THIS);
};


class CSampleClassFactory : public IClassFactory
{
public:
	STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
	STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
	STDMETHODIMP LockServer(BOOL fLock);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\project.h ===
#include <windows.h>
#include "ratings.h"
#include "classes.h"
#include "defguid.h"

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\npstub\npstub.cpp ===
#include "npstub.h"
#include <netspi.h>
#include <npord.h>
#include <nphook.h>
#include <npstubx.h>    /* message defs, class name */

#define ARRAYSIZE(x) (sizeof(x)/sizeof((x)[0]))

HINSTANCE hInstance = NULL;
HWND hwndMonitor = NULL;
CRITICAL_SECTION critsec;
ATOM aClass = NULL;

#define ENTERCRITICAL EnterCriticalSection(&::critsec);
#define LEAVECRITICAL LeaveCriticalSection(&::critsec);

UINT cCallsInProgress = 0;
BOOL fShouldUnload = FALSE;


/* This chunk of code invokes the entrypoint hooking feature of MPR.  We hook
 * things and immediately unhook ourselves.  We don't really want to hook
 * any functionality, this is just a way to kick MPR so he'll redetermine
 * the capabilities (via NPGetCaps) of all the net providers, including
 * ours.
 */
F_NPSHookMPR HookHookMPR;
F_UnHookMPR HookUnHookMPR;
F_LoadLibrary HookLoadLibrary;
F_FreeLibrary HookFreeLibrary;
F_GetProcAddress HookGetProcAddress;
F_LoadLibrary16 HookWMLoadWinnet16;
F_FreeLibrary16 HookWMFreeWinnet16;
F_GetProcAddressByName16 HookWMGetProcAddressByName;
F_GetProcAddressByOrdinal16 HookWMGetProcAddressByOrdinal;

MPRCALLS        MPRCalls = { HookHookMPR,
                             HookUnHookMPR,
                             HookLoadLibrary,
                             HookFreeLibrary,
                             HookGetProcAddress,
                             HookWMLoadWinnet16,
                             HookWMFreeWinnet16,
                             HookWMGetProcAddressByName,
                             HookWMGetProcAddressByOrdinal };


DWORD NPSERVICE HookHookMPR ( PMPRCALLS pMPRCalls )
{
    return ((PF_NPSHookMPR)(MPRCalls.pfNPSHookMPR))(pMPRCalls);
}

DWORD NPSERVICE HookUnHookMPR ( PF_NPSHookMPR pfReqNPSHookMPR, 
    PMPRCALLS pReqMPRCalls )
{
    if (pfReqNPSHookMPR == HookHookMPR) {
    
        // The unhook request has reached the hooker that issued
        // the NPSUnHookMe call (us).
        // In other words we are now sucessfully unhooked
        // and may do our unhooking cleanup.
        // In particular, we can release our tables that
        // manage LoadLibrary/GetProcAddress.
        // Note that this code may be executing on a different
        // thread to the NPSUnHookMe call which may have returned
        // a while ago.

        return WN_SUCCESS;
    }
    else {

        // Another hooker has requested to unhook by calling
        // NPSUnHookMe which causes us to be called here.
        // Pass the request on to the MPR service NPSUnHookMPR to
        // process the request, giving it our MPRCALLS
        // data structure so that it can figure out if
        // we are the right hooker to update and otherwise
        // MPR will pass the request on to the next hooker.

        return NPSUnHookMPR ( pfReqNPSHookMPR,
                              pReqMPRCalls,
                              (PMPRCALLS)&MPRCalls );
    }    
}

HINSTANCE HookLoadLibrary(
    LPCTSTR  lpszLibFile
    )
{
    return MPRCalls.pfLoadLibrary(lpszLibFile);
}

BOOL HookFreeLibrary(
    HMODULE hLibModule
    )
{
    return MPRCalls.pfFreeLibrary(hLibModule);
}

FARPROC HookGetProcAddress(
    HMODULE hModule,
    LPCSTR  lpszProc
    )
{
    return MPRCalls.pfGetProcAddress(hModule, lpszProc);
}

HANDLE16 HookWMLoadWinnet16(
    LPCTSTR  lpszLibFile
    )
{
    return MPRCalls.pfLoadLibrary16(lpszLibFile);
}

VOID HookWMFreeWinnet16(
    HANDLE16 hLibModule
    )
{
    MPRCalls.pfFreeLibrary16(hLibModule);
}

DWORD WINAPI HookWMGetProcAddressByName(
    LPCSTR   lpszProc,
    HANDLE16 hModule
    )
{
    return MPRCalls.pfGetProcAddressByName16(lpszProc, hModule);
}

DWORD WINAPI HookWMGetProcAddressByOrdinal(
    WORD     wOrdinal,
    HANDLE16 hModule
    )
{
    return MPRCalls.pfGetProcAddressByOrdinal16(wOrdinal, hModule);
}

void KickMPR(void)
{
    if (NPSHookMPR((PMPRCALLS)&MPRCalls) == WN_SUCCESS) {
        NPSUnHookMe(HookHookMPR, (PMPRCALLS)&MPRCalls);
    }
}
/***** End MPR hooking code *****/


/***** Begin code to delay-load the real net provider DLL *****/
HMODULE hmodRealNP = NULL;

PF_NPGetCaps pfnNPGetCaps = NULL;
PF_NPGetUniversalName pfnNPGetUniversalName = NULL;
PF_NPGetUser pfnNPGetUser = NULL;
PF_NPValidLocalDevice pfnNPValidLocalDevice = NULL;
PF_NPAddConnection pfnNPAddConnection = NULL;
PF_NPCancelConnection pfnNPCancelConnection = NULL;
PF_NPGetConnection pfnNPGetConnection = NULL;
PF_NPGetConnectionPerformance pfnNPGetConnectionPerformance = NULL;
PF_NPFormatNetworkName pfnNPFormatNetworkName = NULL;
PF_NPOpenEnum pfnNPOpenEnum = NULL;
PF_NPEnumResource pfnNPEnumResource = NULL;
PF_NPCloseEnum pfnNPCloseEnum = NULL;
PF_NPGetResourceParent pfnNPGetResourceParent = NULL;
PF_NPGetResourceInformation pfnNPGetResourceInformation = NULL;
PF_NPLogon pfnNPLogon = NULL;
PF_NPLogoff pfnNPLogoff = NULL;
PF_NPGetHomeDirectory pfnNPGetHomeDirectory = NULL;
PF_NPGetPolicyPath pfnNPGetPolicyPath = NULL;


struct {
    UINT nOrd;
    FARPROC *ppfn;
} aProcs[] = {
    { ORD_GETCAPS, (FARPROC *)&pfnNPGetCaps },
    { ORD_GETUNIVERSALNAME, (FARPROC *)&pfnNPGetUniversalName },
    { ORD_GETUSER, (FARPROC *)&pfnNPGetUser },
    { ORD_VALIDDEVICE, (FARPROC *)&pfnNPValidLocalDevice },
    { ORD_ADDCONNECTION, (FARPROC *)&pfnNPAddConnection },
    { ORD_CANCELCONNECTION, (FARPROC *)&pfnNPCancelConnection },
    { ORD_GETCONNECTIONS, (FARPROC *)&pfnNPGetConnection },
    { ORD_GETCONNPERFORMANCE, (FARPROC *)&pfnNPGetConnectionPerformance },
    { ORD_FORMATNETWORKNAME, (FARPROC *)&pfnNPFormatNetworkName },
    { ORD_OPENENUM, (FARPROC *)&pfnNPOpenEnum },
    { ORD_ENUMRESOURCE, (FARPROC *)&pfnNPEnumResource },
    { ORD_CLOSEENUM, (FARPROC *)&pfnNPCloseEnum },
    { ORD_GETRESOURCEPARENT, (FARPROC *)&pfnNPGetResourceParent },
    { ORD_GETRESOURCEINFORMATION, (FARPROC *)&pfnNPGetResourceInformation },
    { ORD_LOGON, (FARPROC *)&pfnNPLogon },
    { ORD_LOGOFF, (FARPROC *)&pfnNPLogoff },
    { ORD_GETHOMEDIRECTORY, (FARPROC *)&pfnNPGetHomeDirectory },
    { ORD_GETPOLICYPATH, (FARPROC *)&pfnNPGetPolicyPath },
};


void LoadRealNP(void)
{
    ENTERCRITICAL

    if (::hmodRealNP == NULL) {
        char szDLLName[MAX_PATH];

        szDLLName[0] = '\0';
        HKEY hkeySection;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\NPSTUB\\NetworkProvider",
                         0, KEY_QUERY_VALUE, &hkeySection) == ERROR_SUCCESS) {
            DWORD dwType;
            DWORD cbData = sizeof(szDLLName);
            RegQueryValueEx(hkeySection, "RealDLL", NULL, &dwType, (LPBYTE)szDLLName, &cbData);
            RegCloseKey(hkeySection);
        }

        if (szDLLName[0] == '\0')
            lstrcpy(szDLLName, "mslocusr.dll");

        ::hmodRealNP = LoadLibrary(szDLLName);

        if (::hmodRealNP != NULL) {
            for (UINT i=0; i<ARRAYSIZE(::aProcs); i++) {
                *(aProcs[i].ppfn) = GetProcAddress(::hmodRealNP, (LPCSTR)aProcs[i].nOrd);
            }
        }
    }
    LEAVECRITICAL
}


void UnloadRealNP(void)
{
    ENTERCRITICAL
    {
        if (cCallsInProgress > 0) {
            fShouldUnload = TRUE;
        }
        else {
            for (UINT i=0; i<ARRAYSIZE(::aProcs); i++) {
                *(aProcs[i].ppfn) = NULL;
            }

            FreeLibrary(hmodRealNP);
            hmodRealNP = NULL;
            fShouldUnload = FALSE;
            KickMPR();
        }
    }
    LEAVECRITICAL
}


LRESULT MonitorWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg) {
    case WM_NPSTUB_LOADDLL:
        LoadRealNP();
        KickMPR();
        break;

    case WM_NPSTUB_UNLOADDLL:
        UnloadRealNP();
        break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

void _ProcessAttach()
{
    //
    // All the per-instance initialization code should come here.
    //
	::DisableThreadLibraryCalls(::hInstance);

    InitializeCriticalSection(&::critsec);

    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MonitorWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = ::hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szNPSTUBClassName;

    ::aClass = RegisterClass(&wc);

    if (::aClass != NULL) {
        ::hwndMonitor = CreateWindow(szNPSTUBClassName, "",
                                     WS_POPUP | WS_DISABLED,
                                     0, 0, 0, 0,
                                     NULL, NULL,
                                     ::hInstance, NULL);
    }

    LoadRealNP();
}


void _ProcessDetach()
{
    if (::hwndMonitor != NULL)
        DestroyWindow(::hwndMonitor);
    if (::aClass != NULL)
        UnregisterClass((LPSTR)(WORD)::aClass, ::hInstance);

    DeleteCriticalSection(&::critsec);
}


extern "C" STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        ::hInstance = hInstDll;
        _ProcessAttach();
    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        _ProcessDetach();
    }

    return TRUE;
}


void EnterSPI(void)
{
    ENTERCRITICAL
    {
        ::cCallsInProgress++;
    }
    LEAVECRITICAL
}


void LeaveSPI(void)
{
    ENTERCRITICAL
    {
        ::cCallsInProgress--;

        if (::fShouldUnload && !::cCallsInProgress)
            PostMessage(::hwndMonitor, WM_NPSTUB_UNLOADDLL, 0, 0);
    }
    LEAVECRITICAL
}


#define CALLNP(name,err,params)         \
    {                                   \
        if (pfn##name == NULL)          \
            return err;                 \
        DWORD dwRet = err;              \
        EnterSPI();                     \
        if (pfn##name != NULL)          \
            dwRet = (*pfn##name)params; \
        LeaveSPI();                     \
        return dwRet;                   \
    }                                   //last line doesn't need a backslash


SPIENTRY NPGetCaps(
    DWORD nIndex
    )
{
    CALLNP(NPGetCaps,0,(nIndex));
}


SPIENTRY NPGetUniversalName(
	LPTSTR  lpLocalPath,
	DWORD   dwInfoLevel,
	LPVOID  lpBuffer,
	LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetUniversalName,WN_NOT_SUPPORTED,
           (lpLocalPath,dwInfoLevel,lpBuffer,lpBufferSize));
}


SPIENTRY NPGetUser(
    LPTSTR  lpName,
    LPTSTR  lpAuthenticationID,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetUser,WN_NOT_SUPPORTED,
           (lpName,lpAuthenticationID,lpBufferSize));
}


SPIENTRY NPValidLocalDevice(
    DWORD dwType,
    DWORD dwNumber
    )
{
    CALLNP(NPValidLocalDevice,WN_NOT_SUPPORTED,(dwType,dwNumber));
}


SPIENTRY NPAddConnection(
    HWND hwndOwner,
    LPNETRESOURCE lpNetResource,
    LPTSTR lpPassword,
    LPTSTR lpUserID,
    DWORD dwFlags,
	LPTSTR lpAccessName,
	LPDWORD lpBufferSize,
	LPDWORD lpResult
    )
{
    CALLNP(NPAddConnection,WN_NOT_SUPPORTED,
           (hwndOwner,lpNetResource,lpPassword,lpUserID,dwFlags,lpAccessName,lpBufferSize,lpResult));
}


SPIENTRY NPCancelConnection(
    LPTSTR lpName,
    BOOL fForce,
 	DWORD dwFlags
    )
{
    CALLNP(NPCancelConnection,WN_NOT_SUPPORTED,
           (lpName,fForce,dwFlags));
}


SPIENTRY NPGetConnection(
    LPTSTR lpLocalName,
    LPTSTR lpRemoteName,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetConnection,WN_NOT_SUPPORTED,
           (lpLocalName,lpRemoteName,lpBufferSize));
}


SPIENTRY NPGetConnectionPerformance(
    LPTSTR lpRemoteName, 
    LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    )
{
    CALLNP(NPGetConnectionPerformance,WN_NOT_SUPPORTED,
           (lpRemoteName,lpNetConnectInfoStruct));
}


SPIENTRY NPFormatNetworkName(
    LPTSTR lpRemoteName,
    LPTSTR lpFormattedName,
    LPDWORD lpnLength,
    DWORD dwFlags,
    DWORD dwAveCharPerLine
    )
{
    CALLNP(NPFormatNetworkName,WN_NOT_SUPPORTED,
           (lpRemoteName,lpFormattedName,lpnLength,dwFlags,dwAveCharPerLine));
}


SPIENTRY NPOpenEnum(
    DWORD dwScope,
    DWORD dwType,
    DWORD dwUsage,
    LPNETRESOURCE lpNetResource,
    LPHANDLE lphEnum
    )
{
    CALLNP(NPOpenEnum,WN_NOT_SUPPORTED,
           (dwScope,dwType,dwUsage,lpNetResource,lphEnum));
}


SPIENTRY NPEnumResource(
    HANDLE hEnum,
    LPDWORD lpcCount,
    LPVOID lpBuffer,
    DWORD cbBuffer,
    LPDWORD lpcbFree
    )
{
    CALLNP(NPEnumResource,WN_NOT_SUPPORTED,
           (hEnum,lpcCount,lpBuffer,cbBuffer,lpcbFree));
}


SPIENTRY NPCloseEnum(
    HANDLE hEnum
    )
{
    CALLNP(NPCloseEnum,WN_NOT_SUPPORTED,
           (hEnum));
}


SPIENTRY NPGetResourceParent(
    LPNETRESOURCE lpNetResource,
    LPVOID lpBuffer,
    LPDWORD cbBuffer
    )
{
    CALLNP(NPGetResourceParent,WN_NOT_SUPPORTED,
           (lpNetResource,lpBuffer,cbBuffer));
}


SPIENTRY NPGetResourceInformation(
	LPNETRESOURCE lpNetResource,
	LPVOID lpBuffer,
	LPDWORD cbBuffer,
	LPSTR *lplpSystem
    )
{
    CALLNP(NPGetResourceInformation,WN_NOT_SUPPORTED,
           (lpNetResource,lpBuffer,cbBuffer,lplpSystem));
}


SPIENTRY NPLogon(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    LPLOGONINFO lpPreviousAuthentInfo,
    LPTSTR lpLogonScript,
    DWORD dwBufferSize,
    DWORD dwFlags
    )
{
    CALLNP(NPLogon,WN_NOT_SUPPORTED,
           (hwndOwner,lpAuthentInfo,lpPreviousAuthentInfo,lpLogonScript,dwBufferSize,dwFlags));
}


SPIENTRY NPLogoff(
    HWND hwndOwner,
    LPLOGONINFO lpAuthentInfo,
    DWORD dwReason
    )
{
    CALLNP(NPLogoff,WN_NOT_SUPPORTED,
           (hwndOwner,lpAuthentInfo,dwReason));
}


SPIENTRY NPGetHomeDirectory(
    LPTSTR lpDirectory,
    LPDWORD lpBufferSize
    )
{
    CALLNP(NPGetHomeDirectory,WN_NOT_SUPPORTED,
           (lpDirectory,lpBufferSize));
}


SPIENTRY NPGetPolicyPath(
    LPTSTR lpPath,
    LPDWORD lpBufferSize,
	DWORD dwFlags
    )
{
    CALLNP(NPGetPolicyPath,WN_NOT_SUPPORTED,
           (lpPath,lpBufferSize,dwFlags));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\defguid.cpp ===
#include "project.h"


// declaring the GUIDs inline avoids having to use INITGUID
// avoiding unneeded GUIDs being pulled in.

/* IMPORTANT: Run GUIDGEN and insert your own GUID for CLSID_SAMPLE */
/* ALSO insert the registry format equivalent for szOurGUID */
// {E9489DE0-B311-11cf-83B1-00C04FD705B2}
const GUID CLSID_Sample = 
{ 0xe9489de0, 0xb311, 0x11cf, { 0x83, 0xb1, 0x0, 0xc0, 0x4f, 0xd7, 0x5, 0xb2 } };
const char szOurGUID[] = "{E9489DE0-B311-11cf-83B1-00C04FD705B2}";

/* Interface ID for the IObtainRating interface. Leave this the way it is. */
// 19427BA0-826C-11CF-8DAB-00AA006C1A01
const GUID IID_IObtainRating = {0x19427BA0L, 0x826C, 0x11CF, 0x8D, 0xAB, 0x00, 0xAA, 0x00, 0x6C, 0x1A, 0x01};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\getlabel.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#include "project.h"


CSampleObtainRating::CSampleObtainRating()
{
    m_cRef = 1; 
    DllAddRef();
}

CSampleObtainRating::~CSampleObtainRating()
{
    DllRelease();
}


STDMETHODIMP CSampleObtainRating::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IObtainRating)) {
		*ppvObject = (void *)this;
		AddRef();
		return NOERROR;
	}
	*ppvObject = NULL;
	return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CSampleObtainRating::AddRef(void)
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) CSampleObtainRating::Release(void)
{
	if (!--m_cRef) {
		delete this;
		return 0;
	}
	else
		return m_cRef;
}


/* The sample rating obtainer reads the rating for the site from
 * a .INI file (ratings.ini) which looks like this:
 *
 * [Ratings]
 * http://www.msn.com=l 0 s 0 n 0 v 0
 * http://www.playboy.com=l 3 s 4 n 4 v 0
 *
 * For this sample implementation, the URL must match exactly with
 * an entry in the file.
 */
const TCHAR szRatingTemplate[] =
    "(PICS-1.0 \"http://www.rsac.org/ratingsv01.html\" l by \"Sample Rating Obtainer\" for \"%s\" on \"1996.04.16T08:15-0500\" exp \"1997.03.04T08:15-0500\" r (%s))";


STDMETHODIMP CSampleObtainRating::ObtainRating(THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut)
{
	TCHAR szRating[18];	/* big enough for "l 0 s 0 n 0 v 0" */
	UINT cchCopied;
	
	cchCopied = GetPrivateProfileString("Allow", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied > 0) {
		return S_RATING_ALLOW;		/* explicitly allow access */
	}

	cchCopied = GetPrivateProfileString("Deny", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied > 0) {
		return S_RATING_DENY;		/* explicitly deny access */
	}

	cchCopied = GetPrivateProfileString("Ratings", pszTargetUrl, "", szRating, sizeof(szRating), "ratings.ini");
	if (cchCopied == 0) {
		return E_RATING_NOT_FOUND;		/* rating not found */
	}

	LPSTR pBuffer = (LPSTR)pAllocator->Alloc(sizeof(szRatingTemplate) + lstrlen(pszTargetUrl) + lstrlen(szRating));
	if (pBuffer == NULL)
		return E_OUTOFMEMORY;

	::wsprintf(pBuffer, szRatingTemplate, pszTargetUrl, szRating);

	*ppRatingOut = pBuffer;

	return S_RATING_FOUND;
}


/* We want the sample provider to override any HTTP rating bureau
 * which might be installed, so we return a sort order value which
 * is less than the one used by that provider (0x80000000).
 */
STDMETHODIMP_(ULONG) CSampleObtainRating::GetSortOrder(THIS)
{
	return 0x40000000;	/* before rating bureau */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\comobj.cpp ===
// 
// standard inprocserver DLL code, you should not need to mess with this
//

#include "project.h"


HANDLE g_hInst = NULL;
LONG g_cRefDll = 0;     // Number of locks on this DLL



STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    InterlockedDecrement(&g_cRefDll);
}


STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID reserved)
{
    if (fdwReason == DLL_PROCESS_ATTACH)
    {
        g_hInst = hInstDll;
    }
    return TRUE;
}

STDMETHODIMP CSampleClassFactory::QueryInterface(REFIID riid, void **ppvObject)
{
	if (IsEqualIID(riid, IID_IUnknown) ||
		IsEqualIID(riid, IID_IClassFactory)) {
		*ppvObject = (void *)this;
		AddRef();
		return NOERROR;
	}

	*ppvObject = NULL;
	return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSampleClassFactory::AddRef(void)
{
	DllAddRef();
	return 2;
}

STDMETHODIMP_(ULONG) CSampleClassFactory::Release(void)
{
	DllRelease();
	return 1;
}

STDMETHODIMP CSampleClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject)
{
    *ppvObject = NULL;

	if (NULL != pUnkOuter)
		return CLASS_E_NOAGGREGATION;

	CSampleObtainRating *pObj = new CSampleObtainRating;	/* doing this does implicit AddRef() */

	if (NULL == pObj)
		return E_OUTOFMEMORY;

	HRESULT hr = pObj->QueryInterface(riid, ppvObject);
    pObj->Release();

	return hr;
}
        
STDMETHODIMP CSampleClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();

    return NOERROR;
}

//
// standard COM DLL self registering entry point
//

STDAPI DllRegisterServer(void)
{
	HKEY hkeyCLSID;
	LONG err;
    TCHAR szPath[MAX_PATH];

    // get path to this DLL

    GetModuleFileName(g_hInst, szPath, MAX_PATH);

	/* First register our CLSID under HKEY_CLASSES_ROOT. */
	err = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
    	HKEY hkeyOurs;
		err = ::RegCreateKey(hkeyCLSID, ::szOurGUID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
        	HKEY hkeyInproc;
			err = ::RegCreateKey(hkeyOurs, "InProcServer32", &hkeyInproc);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyInproc, NULL, 0, REG_SZ,
					(LPBYTE)szPath, lstrlen(szPath) + 1);
				if (err == ERROR_SUCCESS) {
					err = ::RegSetValueEx(hkeyInproc, "ThreadingModel", 0,
										  REG_SZ, (LPBYTE)"Apartment", 10);
				}
				::RegCloseKey(hkeyInproc);
			}

			::RegCloseKey(hkeyOurs);
		}

		::RegCloseKey(hkeyCLSID);

		/* Now install ourselves as a ratings helper. */
		if (err == ERROR_SUCCESS) {
			err = ::RegCreateKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers", &hkeyCLSID);
			if (err == ERROR_SUCCESS) {
				err = ::RegSetValueEx(hkeyCLSID, ::szOurGUID, 0, REG_SZ, (LPBYTE)"", 2);
				::RegCloseKey(hkeyCLSID);
			}
		}
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}

//
// standard COM DLL self registering entry point
//

STDAPI DllUnregisterServer(void)
{
	HKEY hkeyCLSID;
	LONG err;

	err = ::RegOpenKey(HKEY_CLASSES_ROOT, "CLSID", &hkeyCLSID);
	if (err == ERROR_SUCCESS) {
    	HKEY hkeyOurs;
		err = ::RegOpenKey(hkeyCLSID, ::szOurGUID, &hkeyOurs);
		if (err == ERROR_SUCCESS) {
			err = ::RegDeleteKey(hkeyOurs, "InProcServer32");

			::RegCloseKey(hkeyOurs);

			if (err == ERROR_SUCCESS)
				err = ::RegDeleteKey(hkeyCLSID, ::szOurGUID);
		}

		::RegCloseKey(hkeyCLSID);

		if (err == ERROR_SUCCESS) {
			err = ::RegOpenKey(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Rating Helpers", &hkeyCLSID);
			if (err == ERROR_SUCCESS) {
				err = ::RegDeleteValue(hkeyCLSID, ::szOurGUID);
				::RegCloseKey(hkeyCLSID);
			}
		}
	}

	if (err == ERROR_SUCCESS)
		return S_OK;
	else
		return HRESULT_FROM_WIN32(err);
}

//
// standard COM DLL entry point
//

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
	if (IsEqualCLSID(rclsid, CLSID_Sample)) 
    {
	    static CSampleClassFactory cf;	/* note, declaring this doesn't constitute a reference */

	    return cf.QueryInterface(riid, ppv);	/* will AddRef() if successful */
	}
    // to make this support more com objects add them here

    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;;
}

//
// standard COM DLL entry point
//

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\ratings\sample\ratings.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1996                    **
//*********************************************************************

#ifndef _RATINGS_H_
#define _RATINGS_H_

#include <winerror.h>

STDAPI RatingEnable(BOOL fEnable);
STDAPI RatingCheckUserAccess(LPCSTR pszUsername, LPCSTR pszURL,
                             LPCSTR pszRatingInfo, LPBYTE pData,
                             DWORD cbData, void **ppRatingDetails);
STDAPI RatingAccessDeniedDialog(HWND hDlg, LPCSTR pszUsername, LPCSTR pszContentDescription, void *pRatingDetails);
STDAPI RatingFreeDetails(void *pRatingDetails);
STDAPI RatingObtainCancel(HANDLE hRatingObtainQuery);
STDAPI RatingObtainQuery(LPCTSTR pszTargetUrl, DWORD dwUserData, void (*fCallback)(DWORD dwUserData, HRESULT hr, LPCTSTR pszRating, void *lpvRatingDetails), HANDLE *phRatingObtainQuery);
STDAPI RatingSetupUI(HWND hDlg, LPCSTR pszUsername);
#ifdef _INC_COMMCTRL
STDAPI RatingAddPropertyPage(PROPSHEETHEADER *ppsh);
#endif

STDAPI RatingEnabledQuery();
STDAPI RatingInit();
STDAPI_(void) RatingTerm();


#define S_RATING_ALLOW		S_OK
#define S_RATING_DENY		S_FALSE
#define S_RATING_FOUND		0x00000002
#define E_RATING_NOT_FOUND	0x80000001

/************************************************************************

IObtainRating interface

This interface is used to obtain the rating (PICS label) for a URL.
It is entirely up to the server to determine how to come up with the
label.  The ObtainRating call may be synchronous.

GetSortOrder returns a ULONG which is used to sort this rating helper
into the list of installed helpers.  The helpers are sorted in ascending
order, so a lower numbered helper will be called before a higher numbered
one.

************************************************************************/

DECLARE_INTERFACE_(IObtainRating, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	STDMETHOD(ObtainRating) (THIS_ LPCTSTR pszTargetUrl, HANDLE hAbortEvent,
							 IMalloc *pAllocator, LPSTR *ppRatingOut) PURE;

	STDMETHOD_(ULONG,GetSortOrder) (THIS) PURE;
};

#define RATING_ORDER_REMOTESITE		0x80000000
#define RATING_ORDER_LOCALLIST		0xC0000000


#endif
// _RATINGS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\debug.cpp ===
#include "precomp.h"
#pragma hdrstop

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "sendmail"
#define SZ_MODULE           "SENDMAIL"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\desklink.cpp ===
#include "precomp.h"               // pch file
#include "sendto.h"
#pragma hdrstop


// class that implements the send to desktop (as shortcut)

const GUID CLSID_DesktopShortcut = { 0x9E56BE61L, 0xC50F, 0x11CF, 0x9A, 0x2C, 0x00, 0xA0, 0xC9, 0x0A, 0x90, 0xCE };

class CDesktopShortcut : public CSendTo
{
private:    
    LPIDA _GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium);
    LPCITEMIDLIST _GetIDListPtr(LPIDA pida, UINT i);
    void _ReleaseStgMedium(void *pv, STGMEDIUM *pmedium);
    HRESULT _BindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut);
    HRESULT _InvokeVerbOnItems(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *apidl, LPCTSTR pszDirectory);
    HRESULT _InvokeVerbOnDataObj(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IDataObject *pdtobj, LPCTSTR pszDirectory);

protected:
    HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect);

public:
    CDesktopShortcut();
};


// construct the sendto object with the appropriate CLSID.

CDesktopShortcut::CDesktopShortcut() :
    CSendTo(CLSID_DesktopShortcut)
{
}


// helper methods

LPIDA CDesktopShortcut::_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pmedium)
    {
        pmedium->pUnkForRelease = NULL;
        pmedium->hGlobal = NULL;
    }

    if (!pmedium)
    {
        if (SUCCEEDED(pdtobj->QueryGetData(&fmte)))
            return (LPIDA)TRUE;
        else
            return (LPIDA)FALSE;
    }
    else if (SUCCEEDED(pdtobj->GetData(&fmte, pmedium)))
    {
        return (LPIDA)GlobalLock(pmedium->hGlobal);
    }

    return NULL;
}

LPCITEMIDLIST CDesktopShortcut::_GetIDListPtr(LPIDA pida, UINT i)
{
    if (NULL == pida)
    {
        return NULL;
    }

    if (i == (UINT)-1 || i < pida->cidl)
    {
        return (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1]);
    }

    return NULL;
}

// release a storage medium (doing a Global unlock as required).

void CDesktopShortcut::_ReleaseStgMedium(void *pv, STGMEDIUM *pmedium)
{
    if (pmedium->hGlobal && (pmedium->tymed == TYMED_HGLOBAL))
    {
        GlobalUnlock(pmedium->hGlobal);
    }
    ReleaseStgMedium(pmedium);
}

// dupe of shell\lib SHBindToObject() to avoid link dependancies... (OLEAUT32 gets pulled in by 
// stuff that does VARIANT goo in that lib)

HRESULT CDesktopShortcut::_BindToObject(IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppvOut)
{
    HRESULT hr;
    IShellFolder *psfRelease;

    *ppvOut = NULL;

    if (!psf)
    {
        hr = SHGetDesktopFolder(&psf);
        psfRelease = psf;
    }
    else
    {
        psfRelease = NULL;
        hr = S_OK;
    }

    if (FAILED(hr))
    {
        // leave error code in hr
    }
    else if (!pidl || ILIsEmpty(pidl))
    {
        hr = psf->QueryInterface(riid, ppvOut);
    }
    else
    {
        hr = psf->BindToObject(pidl, NULL, riid, ppvOut);
    }

    if (psfRelease)
        psfRelease->Release();

    if (SUCCEEDED(hr) && (*ppvOut == NULL))
    {
        hr = E_FAIL;
    }

    return hr;
}

// invoke a verb on an array of items in the folder.

HRESULT CDesktopShortcut::_InvokeVerbOnItems(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IShellFolder *psf, UINT cidl, LPCITEMIDLIST *apidl, LPCTSTR pszDirectory)
{
    IContextMenu *pcm;
    HRESULT hr = psf->GetUIObjectOf(hwnd, cidl, apidl, IID_IContextMenu, NULL, (void **)&pcm);
    if (SUCCEEDED(hr))
    {
        CHAR szVerbA[128];
        WCHAR szVerbW[128];
        CHAR szDirA[MAX_PATH];
        WCHAR szDirW[MAX_PATH];
        CMINVOKECOMMANDINFOEX ici =
        {
            SIZEOF(CMINVOKECOMMANDINFOEX),
            uFlags | CMIC_MASK_UNICODE | CMIC_MASK_FLAG_NO_UI,
            hwnd,
            NULL,
            NULL,
            NULL,
            SW_NORMAL,
        };

        SHTCharToAnsi(pszVerb, szVerbA, ARRAYSIZE(szVerbA));
        SHTCharToUnicode(pszVerb, szVerbW, ARRAYSIZE(szVerbW));

        if (pszDirectory)
        {
            SHTCharToAnsi(pszDirectory, szDirA, ARRAYSIZE(szDirA));
            SHTCharToUnicode(pszDirectory, szDirW, ARRAYSIZE(szDirW));
            ici.lpDirectory = szDirA;
            ici.lpDirectoryW = szDirW;
        }

        ici.lpVerb = szVerbA;
        ici.lpVerbW = szVerbW;

        hr = pcm->InvokeCommand((CMINVOKECOMMANDINFO*)&ici);
        pcm->Release();
    }
    return hr;
}

// invoke a verb on the data object item

HRESULT CDesktopShortcut::_InvokeVerbOnDataObj(HWND hwnd, LPCTSTR pszVerb, UINT uFlags, IDataObject *pdtobj, LPCTSTR pszDirectory)
{
    HRESULT hr;
    STGMEDIUM medium;
    LPIDA pida = _GetHIDA(pdtobj, &medium);
    if (pida)
    {
        LPCITEMIDLIST pidlParent = _GetIDListPtr(pida, (UINT)-1);
        IShellFolder *psf;
        hr = _BindToObject(NULL, IID_IShellFolder, pidlParent, (void **)&psf);
        if (SUCCEEDED(hr))
        {
            LPCITEMIDLIST *ppidl = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
            if (ppidl)
            {
                UINT i;
                for (i = 0; i < pida->cidl; i++) 
                {
                    ppidl[i] = _GetIDListPtr(pida, i);
                }
                hr = _InvokeVerbOnItems(hwnd, pszVerb, uFlags, psf, pida->cidl, ppidl, pszDirectory);
                LocalFree((LPVOID)ppidl);
            }
            psf->Release();
        }
        _ReleaseStgMedium(pida, &medium);
    }
    else
        hr = E_FAIL;
    return hr;
}

// handle the drop on the object, so for each item in the HIDA invoke the create
// link verb on them.

HRESULT CDesktopShortcut::v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect)
{
    TCHAR szDesktop[MAX_PATH];
    if (_SHGetSpecialFolderPath(NULL, szDesktop, CSIDL_DESKTOPDIRECTORY, FALSE))
    {
        if (g_cfHIDA == 0)
        {
            g_cfHIDA = (CLIPFORMAT) RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        }
        return _InvokeVerbOnDataObj (NULL, TEXT("link"), 0, pdtobj, szDesktop);
    }
    return E_OUTOFMEMORY;
}

// create an instance of desktop link object

STDAPI DesktopShortcut_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;          // assume failure

    if ( punkOuter )
        return CLASS_E_NOAGGREGATION;

    CDesktopShortcut *pds = new CDesktopShortcut;
    if ( !pds )
        return E_OUTOFMEMORY;

    HRESULT hr = pds->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pds->Release();
    return hr;
}

// handler registration of the desktop link verb

#define DESKLINK_EXTENSION  TEXT("DeskLink")

STDAPI DesktopShortcut_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule)
{
    TCHAR szFile[MAX_PATH];
    if (bReg)
    {
        HKEY hk;

        // get rid of old name "Desktop as Shortcut" link from IE4

        if (SUCCEEDED(GetDropTargetPath(szFile, IDS_DESKTOPLINK_FILENAME, DESKLINK_EXTENSION)))
            DeleteFile(szFile);

        if (RegCreateKey(hkCLSID, DEFAULTICON, &hk) == ERROR_SUCCESS) 
        {
            TCHAR szExplorer[MAX_PATH];
            TCHAR szIcon[MAX_PATH+10];
            GetWindowsDirectory(szExplorer, ARRAYSIZE(szExplorer));
            wnsprintf(szIcon, ARRAYSIZE(szIcon), TEXT("%s\\explorer.exe,-103"), szExplorer);    // ICO_DESKTOP res ID
            RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szIcon, (lstrlen(szIcon) + 1) * SIZEOF(TCHAR));
            RegCloseKey(hk);
        }
        
        CommonRegister(hkCLSID, pszCLSID, DESKLINK_EXTENSION, IDS_DESKTOPLINK_FILENAME_NEW);
    }
    else
    {
        if (SUCCEEDED(GetDropTargetPath(szFile, IDS_DESKTOPLINK_FILENAME, DESKLINK_EXTENSION)))
        {
            DeleteFile(szFile);
        }
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\mail.cpp ===
#include "precomp.h"       // pch file
#include "mapi.h"
#include "sendto.h"
#pragma hdrstop


// class that implement the MAPI send mail handler

typedef struct 
{
    TCHAR szTempShortcut[MAX_PATH];
    MapiMessage mm;
    MapiFileDesc mfd[0];
} MAPIFILES;

class CMailRecipient : public CSendTo
{
public:
    CMailRecipient();

private:    
    BOOL _GetDefaultMailHandler(LPTSTR pszMAPIDLL, DWORD cbMAPIDLL, BOOL *pbWantsCodePageInfo);
    HMODULE _LoadMailProvider(BOOL *pbWantsCodePageInfo);
    MAPIFILES *_AllocMAPIFiles(MRPARAM *pmp);
    void _FreeMAPIFiles(MAPIFILES *pmf);

    DWORD _grfKeyState;
    IStream *_pstrmDataObj;             // marshalled IDataObject

    static DWORD CALLBACK s_MAPISendMailThread(void *pv);
    DWORD _MAPISendMailThread();

protected:
    HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect);
};


// construct the sendto object with the appropriate CLSID.

CMailRecipient::CMailRecipient() :
    CSendTo(CLSID_MailRecipient)
{
}


// read the default mail handler from the regstiry

#define MAIL_HANDLER    TEXT("Software\\Clients\\Mail")
#define MAIL_ATHENA_V1  TEXT("Internet Mail and News")
#define MAIL_ATHENA_V2  TEXT("Outlook Express")

BOOL CMailRecipient::_GetDefaultMailHandler(LPTSTR pszMAPIDLL, DWORD cbMAPIDLL, BOOL *pbWantsCodePageInfo)
{
    TCHAR szDefaultProg[80];
    DWORD cb = SIZEOF(szDefaultProg);

    *pbWantsCodePageInfo = FALSE;

    *pszMAPIDLL = 0;
    if (ERROR_SUCCESS == SHRegGetUSValue(MAIL_HANDLER, TEXT(""), NULL, szDefaultProg, &cb, FALSE, NULL, 0))
    {
        HKEY hkey;
        TCHAR szProgKey[128];

        lstrcpy(szProgKey, MAIL_HANDLER TEXT("\\"));
        lstrcat(szProgKey, szDefaultProg);

        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szProgKey, 
            0,  KEY_QUERY_VALUE,  &hkey))
        {
            // ugly, hard code this for OE
            *pbWantsCodePageInfo = (lstrcmpi(szDefaultProg, MAIL_ATHENA_V2) == 0);

            cb = cbMAPIDLL;
            if (ERROR_SUCCESS != SHQueryValueEx(hkey, TEXT("DLLPath"), 0, NULL, (LPBYTE)pszMAPIDLL, &cb))
            {
                if (lstrcmpi(szDefaultProg, MAIL_ATHENA_V1) == 0)
                {
                    lstrcpyn(pszMAPIDLL, TEXT("mailnews.dll"), cbMAPIDLL);
                }
            }
            RegCloseKey(hkey);
        }
    }
    return *pszMAPIDLL;
}


// load the mail provider, returning a suitable default if we can't read it from the registry

HMODULE CMailRecipient::_LoadMailProvider(BOOL *pbWantsCodePageInfo)
{
    TCHAR szMAPIDLL[MAX_PATH];

    if (!_GetDefaultMailHandler(szMAPIDLL, sizeof(szMAPIDLL), pbWantsCodePageInfo))
    {
        // read win.ini (bogus hu!) for mapi dll provider
        if (GetProfileString(TEXT("Mail"), TEXT("CMCDLLName32"), TEXT(""), szMAPIDLL, ARRAYSIZE(szMAPIDLL)) <= 0)
        {
            lstrcpy(szMAPIDLL, TEXT("mapi32.dll"));
        }
    }
    return LoadLibrary(szMAPIDLL);
}


// allocate a list of MAPI files

MAPIFILES* CMailRecipient::_AllocMAPIFiles(MRPARAM *pmp)
{
    MAPIFILES *pmf;
    int n = SIZEOF(*pmf) + (pmp->nFiles * SIZEOF(pmf->mfd[0]));;

    pmf = (MAPIFILES*)GlobalAlloc(GPTR, n + (pmp->nFiles * pmp->cchFile * 2)); 
    if (pmf)
    {
        pmf->mm.nFileCount = pmp->nFiles;
        if (pmp->nFiles)
        {
            int i;
            LPSTR pszA = (CHAR *)pmf + n;   // thunk buffer

            pmf->mm.lpFiles = pmf->mfd;

            CFileEnum MREnum(pmp, NULL);
            MRFILEENTRY *pFile;

            i = 0;
            while (pFile = MREnum.Next())
            {
                // if the first item is a folder, we will create a shortcut to
                // that instead of trying to mail the folder (that MAPI does
                // not support)

                SHPathToAnsi(pFile->pszFileName, pszA, pmp->cchFile * sizeof(TCHAR));

                pmf->mfd[i].lpszPathName = pszA;
                pmf->mfd[i].lpszFileName = PathFindFileNameA(pszA);
                pmf->mfd[i].nPosition = (UINT)-1;

                pszA += lstrlenA(pszA) + 1;
                ++i;
            }

        }
    }
    return pmf;
}


// free the list of mapi files

void CMailRecipient::_FreeMAPIFiles(MAPIFILES *pmf)
{
    if (pmf->szTempShortcut[0])
        DeleteFile(pmf->szTempShortcut);
    GlobalFree(pmf);
}


// package up the parameters and then kick off a background thread which will do
// the processing for the send mail.

HRESULT CMailRecipient::v_DropHandler(IDataObject *pdo, DWORD grfKeyState, DWORD dwEffect)
{
    _grfKeyState = grfKeyState;
    _pstrmDataObj = NULL;

    HRESULT hr = S_OK;
    if (pdo)
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &_pstrmDataObj);

    if (SUCCEEDED(hr))
    {   
        AddRef();
        if (!SHCreateThread(s_MAPISendMailThread, this,  CTF_PROCESS_REF|CTF_FREELIBANDEXIT|CTF_COINIT, NULL))
        {
            Release();
            hr = E_FAIL;
        }
    }

    if (FAILED(hr) && _pstrmDataObj)
    {
        _pstrmDataObj->Release();
        _pstrmDataObj = NULL;
    }

    return hr;
}
        
DWORD CALLBACK CMailRecipient::s_MAPISendMailThread(void *pv)
{
    CMailRecipient *pmr = (CMailRecipient *)pv;
    return pmr->_MAPISendMailThread();
}


// handler for the drop.  this creates a list of files and then passes the object to
// another thread which inturn releases it.

const TCHAR c_szPad[] = TEXT(" \r\n ");

DWORD CMailRecipient::_MAPISendMailThread()
{
    HRESULT hr = S_OK;
    MRPARAM *pmp = (MRPARAM*)GlobalAlloc(GPTR, SIZEOF(*pmp));
    if (pmp)
    {
        // if we have an IDataObject stream then lets unmarshall it and 
        // create the file list from it.

        if (_pstrmDataObj)
        {
            IDataObject *pdo;
            hr = CoGetInterfaceAndReleaseStream(_pstrmDataObj, IID_PPV_ARG(IDataObject, &pdo));
            if (SUCCEEDED(hr))
            {
                hr = CreateSendToFilesFromDataObj(pdo, _grfKeyState, pmp);
                pdo->Release();
            }
            _pstrmDataObj = NULL;

        }

        // lets build the MAPI information so that we can send the files.

        if (SUCCEEDED(hr))
        {
            MAPIFILES *pmf = _AllocMAPIFiles(pmp);
            if (pmf)
            {
                TCHAR szText[MAX_PATH] ={0};    // body text.
                TCHAR szTitle[2048] ={0};
                CHAR szTextA[ARRAYSIZE(szText)];         // ...
                CHAR szTitleA[ARRAYSIZE(szTitle)];        // because the title is supposed to be non-const (and ansi)
    
                if (pmf->mm.nFileCount)
                {
                    CFileEnum MREnum(pmp, NULL);
                    MRFILEENTRY *pFile;

                    LoadString(g_hinst, IDS_SENDMAIL_MSGTITLE, szTitle, ARRAYSIZE(szTitle));

                    // release our stream objects
                    for (int iFile = 0; (NULL != (pFile = MREnum.Next())); iFile++)
                    {
                        if (iFile>0)
                        {
                            StrCatBuff(szTitle, TEXT(", "), ARRAYSIZE(szTitle));
                        }
                        StrCatBuff(szTitle, pFile->pszTitle, ARRAYSIZE(szTitle));

// can change this logic once CFileStream supports STGM_DELETE_ON_RELEASE
                        ATOMICRELEASE(pFile->pStream);
                    }

                    // lets set the body text
                    LoadString(g_hinst, IDS_SENDMAIL_MSGBODY, szText, ARRAYSIZE(szText));

                    // Don't fill in lpszNoteText if we know we are sending documents because OE will puke on it 
                    SHTCharToAnsi(szText, szTextA, ARRAYSIZE(szTextA));
                    if (!(pmp->dwFlags & MRPARAM_DOC)) 
                    {
                        pmf->mm.lpszNoteText = szTextA;
                    }
                    else
                    {
                        Assert(pmf->mm.lpszNoteText == NULL);  
                    }

                    SHTCharToAnsi(szTitle, szTitleA, ARRAYSIZE(szTitleA));
                    pmf->mm.lpszSubject = szTitleA;
                }

                BOOL bWantsCodePageInfo = FALSE;
                HMODULE hmodMail = _LoadMailProvider(&bWantsCodePageInfo);
                if (bWantsCodePageInfo && (pmp->dwFlags & MRPARAM_USECODEPAGE))
                {
                    // When this flag is set, we know that we have just one file to send and we have a code page
                    // Athena will then look at ulReserved for the code page
                    // Will the other MAPI handlers puke on this?  -- dli
                    ASSERT(pmf->mm.nFileCount == 1);
                    pmf->mfd[0].ulReserved = ((MRPARAM *)pmp)->uiCodePage;
                }

                if (hmodMail)
                {
                    LPMAPISENDMAIL pfnSendMail = (LPMAPISENDMAIL)GetProcAddress(hmodMail, "MAPISendMail");
                    if (pfnSendMail)
                    {
                        pfnSendMail(0, 0, &pmf->mm, MAPI_LOGON_UI | MAPI_DIALOG, 0);
                    }
                    FreeLibrary(hmodMail);
                }
                _FreeMAPIFiles(pmf);
            }
        }
        CleanupPMP(pmp);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    
    Release();
    return 0;
}


// construct the send to mail recipient object

STDAPI MailRecipient_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;          // assume failure

    if ( punkOuter )
        return CLASS_E_NOAGGREGATION;

    CMailRecipient *psm = new CMailRecipient;
    if ( !psm )
        return E_OUTOFMEMORY;

    HRESULT hr = psm->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psm->Release();
    return hr;
}


// handle registration / link creation for the send mail verb

#define SENDMAIL_EXTENSION  TEXT("MAPIMail")
#define EXCHANGE_EXTENSION  TEXT("lnk")

STDAPI MailRecipient_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule)
{
    TCHAR szFile[MAX_PATH];
    if (bReg)
    {
        HKEY hk;
        CommonRegister(hkCLSID, pszCLSID, SENDMAIL_EXTENSION, IDS_MAIL_FILENAME);

        if (RegCreateKey(hkCLSID, DEFAULTICON, &hk) == ERROR_SUCCESS) 
        {
            TCHAR szIcon[MAX_PATH + 10];
            wnsprintf(szIcon, ARRAYSIZE(szIcon), TEXT("%s,-%d"), pszModule, IDI_MAIL);
            RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szIcon, (lstrlen(szIcon) + 1) * SIZEOF(TCHAR));
            RegCloseKey(hk);
        }

        // hide the exchange shortcut
        if (SUCCEEDED(GetDropTargetPath(szFile, IDS_MAIL_FILENAME, EXCHANGE_EXTENSION)))
            SetFileAttributes(szFile, FILE_ATTRIBUTE_HIDDEN);
    }
    else
    {
        if (SUCCEEDED(GetDropTargetPath(szFile, IDS_MAIL_FILENAME, SENDMAIL_EXTENSION)))
            DeleteFile(szFile);

        // unhide the exchange shortcut
        if (SUCCEEDED(GetDropTargetPath(szFile, IDS_MAIL_FILENAME, EXCHANGE_EXTENSION)))
            SetFileAttributes(szFile, FILE_ATTRIBUTE_NORMAL);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\comdll.cpp ===
#include "precomp.h"       // pch file
#include "cfdefs.h"        // CClassFactory, LPOBJECTINFO
#pragma hdrstop

STDAPI MailRecipient_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
STDAPI MailRecipient_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

STDAPI DesktopShortcut_RegUnReg(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
STDAPI DesktopShortcut_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

// tables for object construction and registration 

CF_TABLE_BEGIN( g_ObjectInfo )

    CF_TABLE_ENTRY(&CLSID_MailRecipient, MailRecipient_CreateInstance, COCREATEONLY), 
    CF_TABLE_ENTRY(&CLSID_DesktopShortcut, DesktopShortcut_CreateInstance, COCREATEONLY), 

CF_TABLE_END( g_ObjectInfo )

typedef struct
{
    const CLSID *pclsid;
    HRESULT (STDMETHODCALLTYPE *pfnRegUnReg)(BOOL bReg, HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszModule);
} REGISTRATIONINFO;

const REGISTRATIONINFO c_ri[] =
{
    { &CLSID_MailRecipient, MailRecipient_RegUnReg },
    { &CLSID_DesktopShortcut, DesktopShortcut_RegUnReg },
    { NULL },
};

LONG g_cRefDll = 0;         // reference count for this DLL
HINSTANCE g_hinst = NULL;   // HMODULE for this DLL


// life-time manangement and registration

STDAPI_(void) DllAddRef()
{
    InterlockedIncrement(&g_cRefDll);
}

STDAPI_(void) DllRelease()
{
    InterlockedDecrement(&g_cRefDll);
}

STDAPI DllCanUnloadNow(void)
{
    return g_cRefDll == 0 ? S_OK : S_FALSE;
}

STDAPI_(BOOL) DllMain(HINSTANCE hDll, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hinst = hDll;
        SHFusionInitializeFromModule(hDll);
        DisableThreadLibraryCalls(hDll);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
    }
    return TRUE;
}

void StringFromGUID(const CLSID* piid, LPTSTR pszBuf)
{
    wnsprintf(pszBuf, MAX_PATH, TEXT("{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}"), piid->Data1,
            piid->Data2, piid->Data3, piid->Data4[0], piid->Data4[1], piid->Data4[2],
            piid->Data4[3], piid->Data4[4], piid->Data4[5], piid->Data4[6], piid->Data4[7]);
}

BOOL DeleteKeyAndSubKeys(HKEY hkIn, LPCTSTR pszSubKey)
{
    HKEY  hk;
    TCHAR szTmp[MAX_PATH];
    DWORD dwTmpSize;
    long  l;
    BOOL  f;
    int   x;

    l = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) 
        return FALSE;

    // loop through all subkeys, blowing them away.
    //
    f = TRUE;
    x = 0;
    while (f) {
        dwTmpSize = MAX_PATH;
        l = RegEnumKeyEx(hk, x, szTmp, &dwTmpSize, 0, NULL, NULL, NULL);
        if (l != ERROR_SUCCESS) 
            break;
        f = DeleteKeyAndSubKeys(hk, szTmp);
        x++;
    }

    // there are no subkeys left, [or we'll just generate an error and return FALSE].
    // let's go blow this dude away.
    //
    RegCloseKey(hk);
    l = RegDeleteKey(hkIn, pszSubKey);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}


#define INPROCSERVER32  TEXT("InProcServer32")
#define CLSID           TEXT("CLSID")
#define THREADINGMODEL  TEXT("ThreadingModel")
#define APARTMENT       TEXT("Apartment")
#define APPROVED        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved")
#define DESC            TEXT("Sendmail service")

STDAPI DllRegisterServer(void)
{
    const REGISTRATIONINFO *pcls;
    TCHAR szPath[MAX_PATH];

    GetModuleFileName(g_hinst, szPath, ARRAYSIZE(szPath));  // get path to this DLL

    for (pcls = c_ri; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS) 
        {
            HKEY hkOurs;
            LONG err;
            TCHAR szGUID[80];

            StringFromGUID(pcls->pclsid, szGUID);

            err = RegCreateKey(hkCLSID, szGUID, &hkOurs);
            if (err == ERROR_SUCCESS) 
            {
                HKEY hkInproc;
                err = RegCreateKey(hkOurs, INPROCSERVER32, &hkInproc);
                if (err == ERROR_SUCCESS) 
                {
                    err = RegSetValueEx(hkInproc, NULL, 0, REG_SZ, (LPBYTE)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
                    if (err == ERROR_SUCCESS) 
                    {
                        err = RegSetValueEx(hkInproc, THREADINGMODEL, 0, REG_SZ, (LPBYTE)APARTMENT, sizeof(APARTMENT));
                    }
                    RegCloseKey(hkInproc);
                }

                if (pcls->pfnRegUnReg)
                    pcls->pfnRegUnReg(TRUE, hkOurs, szGUID, szPath);

                if (err == ERROR_SUCCESS)
                {   
                    HKEY hkApproved;
                    
                    err = RegOpenKey(HKEY_LOCAL_MACHINE, APPROVED, &hkApproved);
                    if (err == ERROR_SUCCESS)
                    {
                        err = RegSetValueEx(hkApproved, szGUID, 0, REG_SZ, (LPBYTE)DESC, sizeof(DESC));
                        RegCloseKey(hkApproved);
                    }
                }
                RegCloseKey(hkOurs);
            }
            RegCloseKey(hkCLSID);

            if (err != ERROR_SUCCESS)
                return HRESULT_FROM_WIN32(err);
        }
    }
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    const REGISTRATIONINFO *pcls;
    for (pcls = c_ri; pcls->pclsid; pcls++)
    {
        HKEY hkCLSID;
        if (RegOpenKey(HKEY_CLASSES_ROOT, CLSID, &hkCLSID) == ERROR_SUCCESS) 
        {
            TCHAR szGUID[80];
            HKEY  hkApproved;

            StringFromGUID(pcls->pclsid, szGUID);

            DeleteKeyAndSubKeys(hkCLSID, szGUID);
            if (RegOpenKey(HKEY_LOCAL_MACHINE, APPROVED, &hkApproved) == ERROR_SUCCESS)
            {
                RegDeleteValue(hkApproved, szGUID);
                RegCloseKey(hkApproved);
            }

            RegCloseKey(hkCLSID);

            if (pcls->pfnRegUnReg)
                pcls->pfnRegUnReg(FALSE, NULL, szGUID, NULL);

        }
    }
    return S_OK;
}


// class factory stuff

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid,void**ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        DllAddRef();
        return NOERROR;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    DllAddRef();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    DllRelease();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid,void**ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;
       
        if (punkOuter) // && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hr = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hr))
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
    
        return hr;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        DllAddRef();
    else
        DllRelease();
    return S_OK;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid,void**ppv)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls; 
                DllAddRef();        // class factory holds DLL ref count
                return NOERROR;
            }
        }
    }
    *ppv = NULL;
    return CLASS_E_CLASSNOTAVAILABLE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\precomp.h ===
#pragma warning(disable:4001)

#define STRICT
#define CONST_VTABLE

//
//  ATL / OLE HACKHACK
//
//  Include <w95wraps.h> before anything else that messes with names.
//  Although everybody gets the wrong name, at least it's *consistently*
//  the wrong name, so everything links.
//
//  NOTE:  This means that while debugging you will see functions like
//  CWindowImplBase__DefWindowProcWrapW when you expected to see
//  CWindowImplBase__DefWindowProc.
//

#include <windows.h>
#include <windowsx.h>

#include <intshcut.h>
#include <wininet.h> 
#include <shellapi.h>
#include <commctrl.h>
#include "shfusion.h"
#include <shlobj.h>
#include <ieguidp.h>
#include <shlwapi.h>
#include <varutil.h>
#include <ccstock.h>
#include <crtfree.h>
#include <cfdefs.h>
#include <port32.h>

#include "debug.h"
#include "resource.h"

// gotta redirect to shlwapi, o.w. fail (quietly!) on w95
#define lstrcmpW    StrCmpW
#define lstrcmpiW   StrCmpIW
#define lstrcpyW    StrCpyW
#define lstrcpynW   StrCpyNW
#define lstrcatW    StrCatW
// lstrlen is o.k.

// constants and DLL life time manangement

extern HINSTANCE g_hinst;

STDAPI_(void) DllAddRef();
STDAPI_(void) DllRelease();


// stuff for COM objects. every object needs to have a CLSID and Create function

extern const GUID CLSID_DesktopShortcut;

extern CLIPFORMAT g_cfHIDA;           // from sendmail.cpp

#define DEFAULTICON TEXT("DefaultIcon")


// in util.cpp
HRESULT ShellLinkSetPath(IUnknown *punk, LPCTSTR pszPath);
HRESULT ShellLinkGetPath(IUnknown *punk, LPTSTR pszPath, UINT cch);
BOOL RunningOnNT();
BOOL IsShortcut(LPCTSTR pszFile);
HRESULT CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid);
BOOL GetShortcutTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch);
HRESULT GetDropTargetPath(LPTSTR pszPath, int id, LPCTSTR pszExt);
void CommonRegister(HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszExtension, int idFileName);
BOOL SHPathToAnsi(LPCTSTR pszSrc, LPSTR pszDest, int cbDest);
BOOL _SHGetSpecialFolderPath(HWND hwnd, LPTSTR pszPath, int nFolder, BOOL fCreate);
BOOL PathYetAnotherMakeUniqueNameT(LPTSTR  pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sendmail.rc
//
#define IDS_SUREUNINST                  1
#define IDS_THISDLL                     2
#define IDS_OTHERFLD_FILENAME           3
#define IDS_MAIL_FILENAME               4

#define IDS_SENDMAIL_URL_FILENAME       5
#define IDS_SENDMAIL_FAILUREMSG         9
#define IDS_SENDMAIL_TITLE              10
#define IDS_SENDMAIL_RECOMPRESS         11
#define IDS_SENDMAIL_MSGBODY            12
#define IDS_SENDMAIL_MSGTITLE           13
#define IDS_SENDMAIL_SHOWMORE           14
#define IDS_SENDMAIL_SHOWLESS           15

#define IDS_DESKTOPLINK_FILENAME        20
#define IDS_DESKTOPLINK_FILENAME_NEW    21

#define IDD_RECOMPRESS                  352

#define IDC_RECOMPORIGINAL              910
#define IDC_RECOMPALL                   911
#define IDC_RECOMPMAKETHEM              912
#define IDC_RECOMPSMALL                 913
#define IDC_RECOMPMEDIUM                914
#define IDC_RECOMPLARGE                 915
#define IDC_RECOMPSHOWHIDE              916
#define IDC_RECOMPTHUMBNAIL             917

#define IDC_FROM                        1000
#define IDC_TO                          1001
#define IDC_MOVE                        1002
#define IDC_COPY                        1003
#define IDC_LINK                        1004
#define IDC_COMBO2                      1006
#define IDC_BROWSE                      1008

#define IDI_OTHERFLD                    2000
#define IDI_MAIL                        2001

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\sendto.cpp ===
#include "precomp.h"       // pch file
#include "sendto.h"
#pragma hdrstop

CLIPFORMAT g_cfShellURL = 0;
CLIPFORMAT g_cfFileContents = 0;
CLIPFORMAT g_cfFileDescA = 0;
CLIPFORMAT g_cfFileDescW = 0;
CLIPFORMAT g_cfHIDA = 0;


// registry key for recompressing settings

struct
{
    int cx;
    int cy;
    int iQuality;
} 
_aQuality[] = 
{
    { 640,  480, 80 },          // low quality
    { 800,  600, 80 },          // medium quality
    { 1024, 768, 80 },          // high quality
};

#define QUALITY_LOW 0
#define QUALITY_MEDIUM 1
#define QUALITY_HIGH 2

#define RESPONSE_UNKNOWN 0
#define RESPONSE_CANCEL 1
#define RESPONSE_ORIGINAL 2
#define RESPONSE_RECOMPRESS 3

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)


// these bits are set by the user (holding down the keys) durring drag drop,
// but more importantly, they are set in the SimulateDragDrop() call that the
// browser implements to get the "Send Page..." vs "Send Link..." feature

#define IS_FORCE_LINK(grfKeyState)   ((grfKeyState == (MK_LBUTTON | MK_CONTROL | MK_SHIFT)) || \
                                      (grfKeyState == (MK_LBUTTON | MK_ALT)))

#define IS_FORCE_COPY(grfKeyState)   (grfKeyState == (MK_LBUTTON | MK_CONTROL))



// constructor / destructor

CSendTo::CSendTo(CLSID clsid) :
    _clsid(clsid), _cRef(1), _iRecompSetting(QUALITY_LOW)
{
    
    DllAddRef();    
}

CSendTo::~CSendTo()
{
    if (_pStorageTemp)
        _pStorageTemp->Release();
        
    DllRelease();
}

STDMETHODIMP CSendTo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CSendTo, IShellExtInit),
        QITABENT(CSendTo, IDropTarget),
        QITABENT(CSendTo, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}    

STDMETHODIMP_(ULONG) CSendTo::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSendTo::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CSendTo::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    TraceMsg(DM_TRACE, "CSendTo::DragEnter");
    _grfKeyStateLast = grfKeyState;
    _dwEffectLast = *pdwEffect;

    return S_OK;
}

STDMETHODIMP CSendTo::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= ~DROPEFFECT_MOVE;

    if (IS_FORCE_COPY(grfKeyState))
        *pdwEffect &= DROPEFFECT_COPY;
    else if (IS_FORCE_LINK(grfKeyState))
        *pdwEffect &= DROPEFFECT_LINK;

    _grfKeyStateLast = grfKeyState;
    _dwEffectLast = *pdwEffect;

    return S_OK;
}

STDMETHODIMP CSendTo::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr = v_DropHandler(pdtobj, _grfKeyStateLast, _dwEffectLast);
    *pdwEffect = DROPEFFECT_COPY;                       // don't let source delete data
    return hr;
}

//
// helper methods
// 

int CSendTo::_PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec)
{
    if (RunningOnNT())
    {
        WCHAR wzDir[MAX_PATH];
        WCHAR wzSpec[MAX_PATH];
        LPWSTR pwszDir = wzDir;
        int iRet;

        if (pszDir)
            SHTCharToUnicode(pszDir, wzDir, ARRAYSIZE(wzDir));
        else
            pwszDir = NULL;

        SHTCharToUnicode(pszSpec, wzSpec, ARRAYSIZE(wzSpec));
        iRet = PathCleanupSpec((LPTSTR)pwszDir, (LPTSTR)wzSpec);

        SHUnicodeToTChar(wzSpec, pszSpec, MAX_PATH);
        return iRet;
    }
    else
    {
        CHAR szDir[MAX_PATH];
        CHAR szSpec[MAX_PATH];
        LPSTR pszDir2 = szDir;
        int iRet;

        if (pszDir)
            SHTCharToAnsi(pszDir, szDir, ARRAYSIZE(szDir));
        else
            pszDir2 = NULL;

        SHTCharToAnsi(pszSpec, szSpec, ARRAYSIZE(szSpec));
        iRet = PathCleanupSpec((LPTSTR)pszDir2, (LPTSTR)szSpec);

        SHAnsiToTChar(szSpec, pszSpec, MAX_PATH);
        return iRet;
    }
}

HRESULT CSendTo::_CreateShortcutToPath(LPCTSTR pszPath, LPCTSTR pszTarget)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        ShellLinkSetPath(punk, pszTarget);

        IPersistFile *ppf;
        hr = punk->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            WCHAR wszPath[MAX_PATH];
            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));

            hr = ppf->Save(wszPath, TRUE);
            ppf->Release();
        }
        punk->Release();
    }
    return hr;
}


// thunk A/W funciton to access A/W FILEGROUPDESCRIPTOR
// this relies on the fact that the first part of the A/W structures are
// identical. only the string buffer part is different. so all accesses to the
// cFileName field need to go through this function.

FILEDESCRIPTOR* CSendTo::_GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName)
{
    if (fUnicode)
    {
        // Yes, so grab the data because it matches.
        FILEGROUPDESCRIPTORW * pfgdW = (FILEGROUPDESCRIPTORW *)pfgd;    // cast to what this really is
        if (pszName)
            SHUnicodeToTChar(pfgdW->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdW->fgd[nIndex];   // cast assume the non string parts are the same!
    }
    else
    {
        FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA *)pfgd;     // cast to what this really is

        if (pszName)
            SHAnsiToTChar(pfgdA->fgd[nIndex].cFileName, pszName, MAX_PATH);

        return (FILEDESCRIPTOR *)&pfgdA->fgd[nIndex];   // cast assume the non string parts are the same!
    }
}


// our own impl since URLMON IStream::CopyTo is busted, danpoz will be fixing this
HRESULT CSendTo::_StreamCopyTo(IStream *pstmFrom, IStream *pstmTo, LARGE_INTEGER cb, LARGE_INTEGER *pcbRead, LARGE_INTEGER *pcbWritten)
{
    BYTE buf[512];
    ULONG cbRead;
    HRESULT hr = S_OK;

    if (pcbRead)
    {
        pcbRead->LowPart = 0;
        pcbRead->HighPart = 0;
    }
    if (pcbWritten)
    {
        pcbWritten->LowPart = 0;
        pcbWritten->HighPart = 0;
    }

    ASSERT(cb.HighPart == 0);

    while (cb.LowPart)
    {
        hr = pstmFrom->Read(buf, min(cb.LowPart, SIZEOF(buf)), &cbRead);

        if (pcbRead)
            pcbRead->LowPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;

        cb.LowPart -= cbRead;

        hr = pstmTo->Write(buf, cbRead, &cbRead);

        if (pcbWritten)
            pcbWritten->LowPart += cbRead;

        if (FAILED(hr) || (cbRead == 0))
            break;
    }

    return hr;
}


// create a temporary shortcut to a file
// FEATURE: Colision is not handled here

BOOL CSendTo::_CreateTempFileShortcut(LPCTSTR pszTarget, LPTSTR pszShortcut)
{
    TCHAR szShortcutPath[MAX_PATH + 1];
    BOOL bSuccess = FALSE;
    
    if (GetTempPath(ARRAYSIZE(szShortcutPath), szShortcutPath))
    {
        PathAppend(szShortcutPath, PathFindFileName(pszTarget));

        if (IsShortcut(pszTarget))
        {
            TCHAR szTarget[MAX_PATH + 1];
            SHFILEOPSTRUCT shop = {0};
            shop.wFunc = FO_COPY;
            shop.pFrom = szTarget;
            shop.pTo = szShortcutPath;
            shop.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR;

            StrCpyN(szTarget, pszTarget, ARRAYSIZE(szTarget));
            szTarget[lstrlen(szTarget) + 1] = TEXT('\0');

            szShortcutPath[lstrlen(szShortcutPath) + 1] = TEXT('\0');

            bSuccess = (0 ==  SHFileOperation(&shop));
        }
        else
        {
            PathRenameExtension(szShortcutPath, TEXT(".lnk"));
            bSuccess = SUCCEEDED(_CreateShortcutToPath(szShortcutPath, pszTarget));
        }

        if (bSuccess)
            lstrcpyn(pszShortcut, szShortcutPath, MAX_PATH);
    }
    return bSuccess;
} 


HRESULT CSendTo::_GetFileNameFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, LPTSTR pszDescription)
{
    STGMEDIUM medium;
    HRESULT hr = pdtobj->GetData(pfmtetc, &medium);
    if (SUCCEEDED(hr))
    {
        // NOTE: this is a TCHAR format, we depend on how we are compiled, we really
        // should test both the A and W formats
        FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(medium.hGlobal);
        if (pfgd)
        {
            TCHAR szFdName[MAX_PATH];       // pfd->cFileName
            FILEDESCRIPTOR *pfd;

            // &pfgd->fgd[0], w/ thunk
            ASSERT(pfmtetc->cfFormat == g_cfFileDescW
              || pfmtetc->cfFormat == g_cfFileDescA);
            // for now, all callers are ANSI (other untested)
            //ASSERT(pfmtetc->cfFormat == g_cfFileDescA);
            pfd = _GetFileDescriptor(pfgd, pfmtetc->cfFormat == g_cfFileDescW, 0, szFdName);

            lstrcpy(pszDescription, szFdName);      // pfd->cFileName

            GlobalUnlock(medium.hGlobal);
            hr = S_OK;
        }
        ReleaseStgMedium(&medium);
    }
    return hr;
}


// construct a nice title "<File Name> (<File Type>)"

void CSendTo::_GetFileAndTypeDescFromPath(LPCTSTR pszPath, LPTSTR pszDesc)
{
    SHFILEINFO sfi;

    if (!SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES | SHGFI_TYPENAME | SHGFI_DISPLAYNAME))
    {
        lstrcpyn(sfi.szDisplayName, PathFindFileName(pszPath), ARRAYSIZE(sfi.szDisplayName));
        sfi.szTypeName[0] = 0;
    }

    lstrcpyn(pszDesc, sfi.szDisplayName, MAX_PATH);
}


// pcszURL -> "ftp://ftp.microsoft.com"
// pcszPath -> "c:\windows\desktop\internet\Microsoft FTP.url"

HRESULT CSendTo::_CreateNewURLShortcut(LPCTSTR pcszURL, LPCTSTR pcszURLFile)
{
    IUniformResourceLocator *purl;
    HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUniformResourceLocator, &purl));
    if (SUCCEEDED(hr))
    {
        hr = purl->SetURL(pcszURL, 0);
        if (SUCCEEDED(hr))
        {
            IPersistFile *ppf;
            hr = purl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                WCHAR wszFile[INTERNET_MAX_URL_LENGTH];
                SHTCharToUnicode(pcszURLFile, wszFile, ARRAYSIZE(wszFile));

                hr = ppf->Save(wszFile, TRUE);
                ppf->Release();
            }
        }
        purl->Release();
    }
    return hr;
}


HRESULT CSendTo::_CreateURLFileToSend(IDataObject *pdtobj, MRPARAM *pmp)
{
    MRFILEENTRY *pFile = pmp->pFiles;
    HRESULT hr = CSendTo::_CreateNewURLShortcut(pFile->pszTitle, pFile->pszFileName);
    if (SUCCEEDED(hr))
    {
        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle);
        pFile->dwFlags |= MRFILE_DELETE;
    }    
    return hr;
}


HRESULT CSendTo::_GetHDROPFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;
    HDROP hDrop = (HDROP)pmedium->hGlobal;

    pmp->nFiles = DragQueryFile(hDrop, -1, NULL, 0);

    if (pmp->nFiles && AllocatePMP(pmp, MAX_PATH, MAX_PATH))
    {
        int i;
        CFileEnum MREnum(pmp, NULL);
        MRFILEENTRY *pFile;

        for (i = 0; (pFile = MREnum.Next()) && DragQueryFile(hDrop, i, pFile->pszFileName, pmp->cchFile); ++i)
        {
            if (IS_FORCE_LINK(grfKeyState) || PathIsDirectory(pFile->pszFileName))
            {
                // Want to send a link even for the real file, we will create links to the real files
                // and send it.
                _CreateTempFileShortcut(pFile->pszFileName, pFile->pszFileName);
                pFile->dwFlags |= MRFILE_DELETE;
            }

            _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle);
        }

        // If loop terminates early update our item count
        pmp->nFiles = i;

        hr = S_OK;
    }
    return hr;
}


// "Uniform Resource Locator" format

HRESULT CSendTo::_GetURLFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;

    // This DataObj is from the internet
    // NOTE: We only allow to send one file here.
    pmp->nFiles = 1;
    if (AllocatePMP(pmp, INTERNET_MAX_URL_LENGTH, MAX_PATH))
    {
        // n.b. STR not TSTR!  since URLs only support ansi
        //lstrcpyn(pmp->pszTitle, (LPSTR)GlobalLock(pmedium->hGlobal), INTERNET_MAX_URL_LENGTH);
        MRFILEENTRY *pFile = pmp->pFiles;
        SHAnsiToTChar((LPSTR)GlobalLock(pmedium->hGlobal), pFile->pszTitle, INTERNET_MAX_URL_LENGTH);
        GlobalUnlock(pmedium->hGlobal);
        
        if (pFile->pszTitle[0])
        {
            // Note some of these functions depend on which OS we
            // are running on to know if we should pass ansi or unicode strings
            // to it Windows 95

            if (GetTempPath(MAX_PATH, pFile->pszFileName))
            {
                TCHAR szFileName[MAX_PATH];

                // it's an URL, which is always ANSI, but the filename
                // can still be wide (?)
                FORMATETC fmteW = {g_cfFileDescW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                FORMATETC fmteA = {g_cfFileDescA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
                
                if (FAILED(_GetFileNameFromData(pdtobj, &fmteW, szFileName)))
                {
                    if (FAILED(_GetFileNameFromData(pdtobj, &fmteA, szFileName)))
                    {
                        LoadString(g_hinst, IDS_SENDMAIL_URL_FILENAME, szFileName, ARRAYSIZE(szFileName));
                    }
                }

                _PathCleanupSpec(pFile->pszFileName, szFileName);
                hr = _CreateURLFileToSend(pdtobj, pmp);
            }
        }
    }
    return hr;
}


// transfer FILECONTENTS/FILEGROUPDESCRIPTOR data to a temp file then send that in mail

HRESULT CSendTo::_GetFileContentsFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr = E_FAIL;
    MRFILEENTRY *pFile = NULL;

    // NOTE: We only allow to send one file here.
    pmp->nFiles = 1;
    if (AllocatePMP(pmp, INTERNET_MAX_URL_LENGTH, MAX_PATH))
    {
        pFile = pmp->pFiles;
        
        FILEGROUPDESCRIPTOR *pfgd = (FILEGROUPDESCRIPTOR *)GlobalLock(pmedium->hGlobal);
        if (pfgd)
        {
            TCHAR szFdName[MAX_PATH];       // pfd->cFileName
            FILEDESCRIPTOR *pfd;

            // &pfgd->fgd[0], w/ thunk
            ASSERT((pfmtetc->cfFormat == g_cfFileDescW) || (pfmtetc->cfFormat == g_cfFileDescA));
            pfd = _GetFileDescriptor(pfgd, pfmtetc->cfFormat == g_cfFileDescW, 0, szFdName);

            if (GetTempPath(MAX_PATH, pFile->pszFileName))
            {
                STGMEDIUM medium;
                FORMATETC fmte = {g_cfFileContents, NULL, pfmtetc->dwAspect, 0, TYMED_ISTREAM | TYMED_HGLOBAL};
                hr = pdtobj->GetData(&fmte, &medium);
                if (SUCCEEDED(hr))
                {
                    PathAppend(pFile->pszFileName, szFdName);    // pfd->cFileName
                    _PathCleanupSpec(pFile->pszFileName, PathFindFileName(pFile->pszFileName));
                    PathYetAnotherMakeUniqueNameT(pFile->pszFileName, pFile->pszFileName, NULL, NULL);

                    IStream *pstmFile;
                    hr = SHCreateStreamOnFile(pFile->pszFileName, STGM_WRITE | STGM_CREATE, &pstmFile);
                    if (SUCCEEDED(hr))
                    {
                        switch (medium.tymed) 
                        {
                            case TYMED_ISTREAM:
                            {
                                const LARGE_INTEGER li = {-1, 0};   // the whole thing
                                hr = _StreamCopyTo(medium.pstm, pstmFile, li, NULL, NULL);
                                break;
                            }

                            case TYMED_HGLOBAL:
                                hr = pstmFile->Write(GlobalLock(medium.hGlobal), 
                                                       pfd->dwFlags & FD_FILESIZE ? pfd->nFileSizeLow:(DWORD)GlobalSize(medium.hGlobal),
                                                       NULL);
                                GlobalUnlock(medium.hGlobal);
                                break;

                            default:
                                hr = E_FAIL;
                        }

                        pstmFile->Release();
                        if (FAILED(hr))
                            DeleteFile(pFile->pszFileName);
                    }
                    ReleaseStgMedium(&medium);
                }
            }
            GlobalUnlock(pmedium->hGlobal);
        }
    }

    if (SUCCEEDED(hr))
    {
        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle);
        pFile->dwFlags |= MRFILE_DELETE;
        
        if (pfmtetc->dwAspect == DVASPECT_COPY)
        {
            pmp->dwFlags |= MRPARAM_DOC;    // we are sending the document

            // get the code page if there is one
            IQueryCodePage *pqcp;
            if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pqcp))))
            {
                if (SUCCEEDED(pqcp->GetCodePage(&pmp->uiCodePage)))
                    pmp->dwFlags |= MRPARAM_USECODEPAGE;
                pqcp->Release();
            }
        }
    }
    else if (pfmtetc->dwAspect == DVASPECT_COPY)
    {
        TCHAR szFailureMsg[MAX_PATH], szFailureMsgTitle[40];
        LoadString(g_hinst, IDS_SENDMAIL_FAILUREMSG, szFailureMsg, ARRAYSIZE(szFailureMsg));
        LoadString(g_hinst, IDS_SENDMAIL_TITLE, szFailureMsgTitle, ARRAYSIZE(szFailureMsgTitle));
                    
        int iRet = MessageBox(NULL, szFailureMsg, szFailureMsgTitle, MB_YESNO);
        if (iRet == IDNO)
            hr = S_FALSE;     // convert to success to we don't try DVASPECT_LINK
    }

    return hr;
}


// generate a set of files from the data object

typedef struct 
{
    INT format;
    FORMATETC fmte;
} DATA_HANDLER;

#define GET_FILECONTENT 0
#define GET_HDROP       1
#define GET_URL         2

// Note: If this function returns E_CANCELLED that tells the caller that the user requested us to cancel the
//       sendmail operation.
HRESULT CSendTo::CreateSendToFilesFromDataObj(IDataObject *pdtobj, DWORD grfKeyState, MRPARAM *pmp)
{
    HRESULT hr;
    DWORD dwAspectPrefered;
    IEnumFORMATETC *penum;

    if (g_cfShellURL == 0)
    {
        g_cfShellURL = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLURL);                     // URL is always ANSI
        g_cfFileContents = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfFileDescA = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileDescW = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
    }

    if (IS_FORCE_COPY(grfKeyState))
        dwAspectPrefered = DVASPECT_COPY;
    else if (IS_FORCE_LINK(grfKeyState))
        dwAspectPrefered = DVASPECT_LINK;
    else
        dwAspectPrefered = DVASPECT_CONTENT;

    hr = pdtobj->EnumFormatEtc(DATADIR_GET, &penum);
    if (SUCCEEDED(hr))
    {
        DATA_HANDLER rg_data_handlers[] = {
            GET_FILECONTENT, {g_cfFileDescW, NULL, dwAspectPrefered, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescA, NULL, dwAspectPrefered, -1, TYMED_HGLOBAL},
            GET_FILECONTENT, {g_cfFileDescA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_HDROP,       {CF_HDROP,      NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
            GET_URL,         {g_cfShellURL,  NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        };

        FORMATETC fmte;
        while (penum->Next(1, &fmte, NULL) == S_OK)
        {
            SHFree(fmte.ptd);
            fmte.ptd = NULL; // so nobody looks at it
            int i;
            for (i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                if (rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat &&
                    rg_data_handlers[i].fmte.dwAspect == fmte.dwAspect)
                {
                    STGMEDIUM medium;
                    if (SUCCEEDED(pdtobj->GetData(&rg_data_handlers[i].fmte, &medium)))
                    {
                        switch ( rg_data_handlers[i].format )
                        {
                            case GET_FILECONTENT:
                                hr = _GetFileContentsFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;
            
                            case GET_HDROP:
                                hr = _GetHDROPFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;

                            case GET_URL:
                                hr = _GetURLFromData(pdtobj, &fmte, &medium, grfKeyState, pmp);
                                break;                                
                        }

                        ReleaseStgMedium(&medium);

                        if (SUCCEEDED(hr))
                            goto Done;
                    }
                }
            }
        }
Done:
        penum->Release();
    }

    if (SUCCEEDED(hr))
        hr = FilterPMP(pmp);
        
    return hr;
}


// allocate and free a file list.  pmp->nFiles MUST be initialized before calling this function!

BOOL CSendTo::AllocatePMP(MRPARAM *pmp, DWORD cchTitle, DWORD cchFiles)
{
    // Remember the array sizes for overflow checks, etc.
    pmp->cchFile = cchFiles;
    pmp->cchTitle = cchTitle;

    // compute size of each file entry and allocate enough for the number of files we have.  Also
    // add a TCHAR to the end of the buffer so we can do a double null termination safely while deleting files
    pmp->cchFileEntry = sizeof(MRFILEENTRY) + (cchTitle + cchFiles) * sizeof(TCHAR);
    pmp->pFiles = (MRFILEENTRY *)GlobalAlloc(GPTR, pmp->cchFileEntry * pmp->nFiles + sizeof(TCHAR));
    if (!pmp->pFiles)
        return FALSE;

    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    // Note: The use of the enumerator here is questionable since this is the loop that initializes the 
    //       data structure.  If the implementation changes in the future be sure this assumption still holds.

    while (pFile = MREnum.Next())
    {
        pFile->pszFileName = (LPTSTR)pFile->chBuf;
        pFile->pszTitle = pFile->pszFileName + cchFiles;

        ASSERTMSG(pFile->dwFlags == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pszFileName[cchFiles-1] == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pszTitle[cchTitle-1] == 0, "Expected zero-inited memory allocation");
        ASSERTMSG(pFile->pStream == NULL, "Expected zero-inited memory allocation");
    }
    
    return TRUE;
}

BOOL CSendTo::CleanupPMP(MRPARAM *pmp)
{
    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    while (pFile = MREnum.Next())
    {
        // delete the file if we are supposed to
        if (pFile->dwFlags & MRFILE_DELETE)
            DeleteFile(pFile->pszFileName);

        // If we held on to a temporary stream release it so the underlying data will be deleted.
        ATOMICRELEASE(pFile->pStream);
    }

    if (pmp->pFiles)
    {
        GlobalFree((LPVOID)pmp->pFiles);
        pmp->pFiles = NULL;
    }

    GlobalFree(pmp);
    return TRUE;
}


// allow files to be massaged before sending

HRESULT CSendTo::FilterPMP(MRPARAM *pmp)
{
    // lets handle the initialization of the progress dialog
    IActionProgress *pap;
    HRESULT hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgress, &pap));
    if (SUCCEEDED(hr))
    {
        TCHAR szBuffer[MAX_PATH];
        IActionProgressDialog *papd;
        hr = pap->QueryInterface(IID_PPV_ARG(IActionProgressDialog, &papd));
        if (SUCCEEDED(hr))
        {
            LoadString(g_hinst, IDS_SENDMAIL_TITLE, szBuffer, ARRAYSIZE(szBuffer));
            hr = papd->Initialize(0x0, szBuffer, NULL);
            papd->Release();
        }
        
        if (SUCCEEDED(hr))
        {
            LoadString(g_hinst, IDS_SENDMAIL_RECOMPRESS, szBuffer, ARRAYSIZE(szBuffer));
            pap->UpdateText(SPTEXT_ACTIONDESCRIPTION, szBuffer, FALSE);
            pap->Begin(SPACTION_COPYING, SPBEGINF_NORMAL);
        }

        if (FAILED(hr))
        {
            pap->Release();
            pap = NULL;
        }
    }

    // walk the files and perform the recompress if we need to.

    int iResponse = RESPONSE_UNKNOWN;

    CFileEnum MREnum(pmp, pap);
    MRFILEENTRY *pFile;
    for (hr = S_OK; (pFile = MREnum.Next()) && SUCCEEDED(hr); )
    {
        if (pap)
            pap->UpdateText(SPTEXT_ACTIONDETAIL, pFile->pszFileName, TRUE);

        // if this is a picture then lets off the option to recompress the image 

        if (PathIsImage(pFile->pszFileName))
        {
            LPITEMIDLIST pidl;
            hr = SHILCreateFromPath(pFile->pszFileName, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHCreateShellItem(NULL, NULL, pidl, &_psi);
                if (SUCCEEDED(hr))
                {   
                    // if the response is unknown then we need to prompt for which type of optimization
                    // needs to be performed. 

                    if (iResponse == RESPONSE_UNKNOWN)
                    {
                        // we need the link control window

                        INITCOMMONCONTROLSEX initComctl32;
                        initComctl32.dwSize = sizeof(initComctl32); 
                        initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 
                        InitCommonControlsEx(&initComctl32);

                        // we need a parent window

                        HWND hwnd = GetActiveWindow();
                        if (pap)
                            IUnknown_GetWindow(pap, &hwnd);

                        iResponse = (int)DialogBoxParam(g_hinst, MAKEINTRESOURCE(IDD_RECOMPRESS), 
                                                        hwnd, s_ConfirmDlgProc, (LPARAM)this);

                    }
            
                    // based on the response we either have cache or the dialog lets perform
                    // that operation as needed.

                    if (iResponse == RESPONSE_CANCEL)
                    {
                        hr = E_CANCELLED;
                    }
                    else if (iResponse == RESPONSE_RECOMPRESS)
                    {
                        IStorage *pstg;
                        hr = _GetTempStorage(&pstg);
                        if (SUCCEEDED(hr))
                        {
                            IImageRecompress *pir;
                            hr = CoCreateInstance(CLSID_ImageRecompress, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IImageRecompress, &pir));
                            if (SUCCEEDED(hr))
                            {
                                IStream *pstrm;
                                hr = pir->RecompressImage(_psi, _aQuality[_iRecompSetting].cx, _aQuality[_iRecompSetting].cy, _aQuality[_iRecompSetting].iQuality, pstg, &pstrm);
                                if (hr == S_OK)
                                {
                                    STATSTG stat;
                                    hr = pstrm->Stat(&stat, STATFLAG_DEFAULT);
                                    if (SUCCEEDED(hr))
                                    {
                                        // its OK to delete this file now, b/c we are going to replace it with the recompressed
                                        // stream we have just generated from the source.
                                        if (pFile->dwFlags & MRFILE_DELETE)
                                            DeleteFile(pFile->pszFileName);

                                        // get the information on the recompressed object.
                                        StrCpyNW(pFile->pszFileName, _szTempPath, pmp->cchFile);
                                        PathAppend(pFile->pszFileName, stat.pwcsName);
                                        _GetFileAndTypeDescFromPath(pFile->pszFileName, pFile->pszTitle);

                                        pFile->dwFlags |= MRFILE_DELETE;
                                        pstrm->QueryInterface(IID_PPV_ARG(IStream, &pFile->pStream));
        
                                        CoTaskMemFree(stat.pwcsName);
                                    }
                                    pstrm->Release();
                                }
                                pir->Release();
                            }
                            pstg->Release();
                        }
                    }

                    if (SUCCEEDED(hr) && pap)
                    {
                        BOOL fCancelled;
                        if (SUCCEEDED(pap->QueryCancel(&fCancelled)) && fCancelled)
                        {
                            hr = E_CANCELLED;
                        }
                    }

                    _psi->Release();
                }
                ILFree(pidl);
            }
        }
    }

    if (pap)
    {
        pap->End();
        pap->Release();
    }

    return hr;
}


HRESULT CSendTo::_GetTempStorage(IStorage **ppStorage)
{    
    *ppStorage = NULL;
        
    HRESULT hr;
    if (_pStorageTemp == NULL)
    {
        if (GetTempPath(ARRAYSIZE(_szTempPath), _szTempPath))
        {
            LPITEMIDLIST pidl = NULL;
            hr = SHILCreateFromPath(_szTempPath, &pidl, NULL);
            if (SUCCEEDED(hr))
            {
                hr = SHBindToObjectEx(NULL, pidl, NULL, IID_PPV_ARG(IStorage, ppStorage));
                if (SUCCEEDED(hr))
                {
                    hr = (*ppStorage)->QueryInterface(IID_PPV_ARG(IStorage, &_pStorageTemp));
                }
                ILFree(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = _pStorageTemp->QueryInterface(IID_PPV_ARG(IStorage, ppStorage));
    }

    return hr;
}


void CSendTo::_CollapseOptions(HWND hwnd, BOOL fHide)
{
    _fOptionsHidden = fHide;

    RECT rc1, rc2;        
    GetWindowRect(GetDlgItem(hwnd, IDC_RECOMPORIGINAL), &rc1);
    GetWindowRect(GetDlgItem(hwnd, IDC_RECOMPLARGE), &rc2);
    int cyAdjust = (rc2.top - rc1.top) * (fHide ? -1:1);

    // show/hide the controls we are not going to use

    UINT idHide[] = { IDC_RECOMPMAKETHEM, IDC_RECOMPSMALL, IDC_RECOMPMEDIUM, IDC_RECOMPLARGE };
    for (int i = 0; i < ARRAYSIZE(idHide); i++)
    {
        ShowWindow(GetDlgItem(hwnd, idHide[i]), fHide ? SW_HIDE:SW_SHOW);
    }

    // move the buttons at the bottom of the dialog

    UINT idMove[] = { IDC_RECOMPSHOWHIDE, IDOK, IDCANCEL };
    for (int i = 0; i < ARRAYSIZE(idMove); i++)
    {
        RECT rcItem;
        GetWindowRect(GetDlgItem(hwnd, idMove[i]), &rcItem);
        MapWindowPoints(NULL, hwnd, (LPPOINT)&rcItem, 2);

        SetWindowPos(GetDlgItem(hwnd, idMove[i]), NULL, 
                     rcItem.left, rcItem.top + cyAdjust, 0, 0, 
                     SWP_NOSIZE|SWP_NOZORDER);
    }

    // resize the dialog accordingly

    RECT rcWindow;
    GetWindowRect(hwnd, &rcWindow);
    SetWindowPos(hwnd, NULL, 
                 0, 0, RECTWIDTH(rcWindow), RECTHEIGHT(rcWindow) + cyAdjust, 
                 SWP_NOZORDER|SWP_NOMOVE);

    // update the link control

    TCHAR szBuffer[MAX_PATH];
    LoadString(g_hinst, fHide ? IDS_SENDMAIL_SHOWMORE:IDS_SENDMAIL_SHOWLESS, szBuffer, ARRAYSIZE(szBuffer));
    SetDlgItemText(hwnd, IDC_RECOMPSHOWHIDE, szBuffer);
}


// dialog proc for the recompress prompt

BOOL_PTR CSendTo::s_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CSendTo *pst = (CSendTo*)GetWindowLongPtr(hwnd, DWLP_USER);
    if (msg == WM_INITDIALOG)
    {
        SetWindowLongPtr(hwnd, DWLP_USER, lParam);
        pst = (CSendTo*)lParam;
    }    
    return pst->_ConfirmDlgProc(hwnd, msg, wParam, lParam);
}

BOOL_PTR CSendTo::_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{    
    switch (msg)
    {
        case WM_INITDIALOG:
        {
            HWND hwndThumbnail = GetDlgItem(hwnd, IDC_RECOMPTHUMBNAIL);
            LONG_PTR dwStyle = GetWindowLongPtr(hwndThumbnail, GWL_STYLE);

            // set the default state of the dialog
            _CollapseOptions(hwnd, TRUE);

            // set the default state of the buttons
            CheckRadioButton(hwnd, IDC_RECOMPORIGINAL, IDC_RECOMPALL, IDC_RECOMPALL);
            CheckRadioButton(hwnd, IDC_RECOMPSMALL, IDC_RECOMPLARGE, IDC_RECOMPSMALL + _iRecompSetting);

            // get the thumbnail and show it.
            IExtractImage *pei;
            HRESULT hr = _psi->BindToHandler(NULL, BHID_SFUIObject, IID_PPV_ARG(IExtractImage, &pei));
            if (SUCCEEDED(hr))
            {
                RECT rcThumbnail;
                GetClientRect(GetDlgItem(hwnd, IDC_RECOMPTHUMBNAIL), &rcThumbnail);

                SIZE sz = {RECTWIDTH(rcThumbnail), RECTHEIGHT(rcThumbnail)};
                WCHAR szImage[MAX_PATH];
                DWORD dwFlags = 0;

                hr = pei->GetLocation(szImage, ARRAYSIZE(szImage), NULL, &sz, 24, &dwFlags);
                if (SUCCEEDED(hr))
                {
                    HBITMAP hbmp;
                    hr = pei->Extract(&hbmp);
                    if (SUCCEEDED(hr))
                    {
                        SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_BITMAP);
                        HBITMAP hbmp2 = (HBITMAP)SendMessage(hwndThumbnail, STM_SETIMAGE, (WPARAM)IMAGE_BITMAP, (LPARAM)hbmp);
                        if (hbmp2)
                        {
                            DeleteObject(hbmp2);
                        }
                    }
                }
                pei->Release();
            }

            // if that failed then lets get the icon for the file and place that into the dialog,
            // this is less likely to fail - I hope.

            if (FAILED(hr))
            {
                IPersistIDList *ppid;
                hr = _psi->QueryInterface(IID_PPV_ARG(IPersistIDList, &ppid));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = ppid->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCWSTR)pidl, -1, &sfi, sizeof(sfi), SHGFI_ICON|SHGFI_PIDL|SHGFI_ADDOVERLAYS))
                        {
                            SetWindowLongPtr(hwndThumbnail, GWL_STYLE, dwStyle | SS_ICON);
                            HICON hIcon = (HICON)SendMessage(hwndThumbnail, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)sfi.hIcon);
                            if (hIcon)
                            {
                                DeleteObject(hIcon);
                            }
                        }
                        ILFree(pidl);
                    }
                    ppid->Release();
                }
            }

            break;
        }

        case WM_NOTIFY:
        {
           // Did they click/keyboard on the alter settings link?
            NMHDR *pnmh = (NMHDR *)lParam;
            if ((wParam == IDC_RECOMPSHOWHIDE) &&
                    (pnmh->code == NM_CLICK || pnmh->code == NM_RETURN)) 
            {
                _CollapseOptions(hwnd, !_fOptionsHidden);
                return TRUE;
            }
            break;
        }
           
        case WM_COMMAND:
        {
            switch (wParam)
            {
                case IDOK:
                {
                    // read back the quality index and store
                    if (IsDlgButtonChecked(hwnd, IDC_RECOMPSMALL))
                        _iRecompSetting = QUALITY_LOW;
                    else if (IsDlgButtonChecked(hwnd, IDC_RECOMPMEDIUM))
                        _iRecompSetting = QUALITY_MEDIUM;
                    else
                        _iRecompSetting = QUALITY_HIGH;

                    // dismiss the dialog, returning the radio button state
                    EndDialog(hwnd,(IsDlgButtonChecked(hwnd, IDC_RECOMPALL)) ? RESPONSE_RECOMPRESS:RESPONSE_ORIGINAL);
                    return FALSE;
                }

                case IDCANCEL:
                    EndDialog(hwnd, RESPONSE_CANCEL);
                    return FALSE;

                default: 
                    break;
            }
            break;
        }
            
        default:
            return FALSE;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\sendto.h ===
// class that provides the base implementation of the send to object.  from here
// you can override the v_DropHandler and add your own functionality.

#define HINST_THISDLL   g_hinst

// shorthand for error code saying user requested cancel
#define E_CANCELLED     HRESULT_FROM_WIN32(ERROR_CANCELLED)

#define MRPARAM_DOC         0x00000001
#define MRPARAM_USECODEPAGE 0x00000002

#define MRFILE_DELETE       0x00000001

#include <shimgdata.h>

typedef struct
{
    DWORD   dwFlags;        // MRFILE_*
    LPTSTR  pszFileName;    // points to beginning of chBuf
    LPTSTR  pszTitle;       // points to space in chBuf after space needed for filename
    IStream *pStream;       // If non-null release stream when deleting the structure
    TCHAR   chBuf[1];
} MRFILEENTRY;

typedef struct 
{
    DWORD dwFlags;    // Attributes passed to the MAPI apis
    MRFILEENTRY *pFiles; // List of file information
    DWORD cchFileEntry; // number of bytes in a single MRFILELIST entry
    DWORD cchFile;      // number of bytes in pszFileName field of MRFILELIST entry
    DWORD cchTitle;     // number of bytes in pszTitle field of MRFILELIST entry
    int nFiles;       // The number of files being sent.
    UINT uiCodePage;  // Code page 
} MRPARAM;


/*
    Helper class for walking file list.  Example:
    
    CFileEnum MREnum(pmp, NULL);
    MRFILEENTRY *pFile;

    while (pFile = MREnum.Next())
    {
        ... do stuff with pFile ...
    }
*/
class CFileEnum
{
private:
    int             _nFilesLeft;
    MRPARAM *       _pmp;
    MRFILEENTRY *   _pFile;
    IActionProgress *_pap;

public:    
    CFileEnum(MRPARAM *pmp, IActionProgress *pap) 
        { _pmp = pmp; _pFile = NULL; _nFilesLeft = -1; _pap = NULL; IUnknown_Set((IUnknown**)&_pap, pap); }

    ~CFileEnum()
        { ATOMICRELEASE(_pap); }

    MRFILEENTRY * Next()
        { 
            if (_nFilesLeft < 0)
            {
                _nFilesLeft = _pmp->nFiles;
                _pFile = _pmp->pFiles;
            }

            MRFILEENTRY *pFile = NULL;            
            if (_nFilesLeft > 0)
            {
                pFile = _pFile;
                
                _pFile = (MRFILEENTRY *)((LPBYTE)_pFile + _pmp->cchFileEntry);
                --_nFilesLeft;
            }

            if (_pap)
                _pap->UpdateProgress(_pmp->nFiles-_nFilesLeft, _pmp->nFiles);

            return pFile;
        }
};

class CSendTo : public IDropTarget, IShellExtInit, IPersistFile
{
private:
    CLSID      _clsid;
    LONG       _cRef;
    DWORD      _grfKeyStateLast;
    DWORD      _dwEffectLast;    
    IStorage * _pStorageTemp;
    TCHAR      _szTempPath[MAX_PATH];
    
    BOOL        _fOptionsHidden;   
    INT         _iRecompSetting;
    IShellItem *_psi;

    int _PathCleanupSpec(/*IN OPTIONAL*/ LPCTSTR pszDir, /*IN OUT*/ LPTSTR pszSpec);
    HRESULT _CreateShortcutToPath(LPCTSTR pszPath, LPCTSTR pszTarget);
    FILEDESCRIPTOR* _GetFileDescriptor(FILEGROUPDESCRIPTOR *pfgd, BOOL fUnicode, int nIndex, LPTSTR pszName);
    HRESULT _StreamCopyTo(IStream *pstmFrom, IStream *pstmTo, LARGE_INTEGER cb, LARGE_INTEGER *pcbRead, LARGE_INTEGER *pcbWritten);
    BOOL _CreateTempFileShortcut(LPCTSTR pszTarget, LPTSTR pszShortcut);
    HRESULT _GetFileNameFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, LPTSTR pszDescription);
    void _GetFileAndTypeDescFromPath(LPCTSTR pszPath, LPTSTR pszDesc);
    HRESULT _CreateNewURLShortcut(LPCTSTR pcszURL, LPCTSTR pcszURLFile);
    HRESULT _CreateURLFileToSend(IDataObject *pdtobj, MRPARAM *pmp);
    HRESULT _GetHDROPFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetURLFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetFileContentsFromData(IDataObject *pdtobj, FORMATETC *pfmtetc, STGMEDIUM *pmedium, DWORD grfKeyState, MRPARAM *pmp);
    HRESULT _GetTempStorage(IStorage **ppStorage);
    void _CollapseOptions(HWND hwnd, BOOL fHide);
    static BOOL_PTR s_ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
    BOOL_PTR _ConfirmDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

protected:
    BOOL AllocatePMP(MRPARAM *pmp, DWORD cchTitle, DWORD cchFiles);
    BOOL CleanupPMP(MRPARAM *pmp);
    HRESULT FilterPMP(MRPARAM *pmp);
    HRESULT CreateSendToFilesFromDataObj(IDataObject *pdtobj, DWORD grfKeyState, MRPARAM *pmp);

    // Virtual drop method implemented by derived object
    virtual HRESULT v_DropHandler(IDataObject *pdtobj, DWORD grfKeyState, DWORD dwEffect) PURE;

public:
    CSendTo(CLSID clsid);
    virtual ~CSendTo();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)(); 

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *lpdobj, HKEY hkeyProgID)
        { return S_OK; };

    // IDropTarget
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave()
        { return S_OK; }
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pClassID)
        { *pClassID = _clsid; return S_OK; };

    // IPersistFile
    STDMETHODIMP IsDirty(void)
        { return S_FALSE; };
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode)
        { return S_OK; };
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember)
        { return S_OK; };
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName)
        { return S_OK; };
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName)
        { *ppszFileName = NULL; return S_OK; };
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shfolder\app\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__F2FC1D73_C03E_11D1_8529_006008059367__INCLUDED_)
#define AFX_STDAFX_H__F2FC1D73_C03E_11D1_8529_006008059367__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F2FC1D73_C03E_11D1_8529_006008059367__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shfolder\app\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	app.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shfolder\folder.c ===
#define _SHFOLDER_
#define NO_SHLWAPI_PATH
#include <windows.h>
#include <shlwapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <platform.h>

#include "resource.h"

#ifdef DBG
#define ASSERT(x) if (!(x)) DebugBreak();
#else
#define ASSERT(x)
#endif

#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))

// We can't rely on shlwapi SHUnicodeToAnsi/SHAnsiToUnicode in this module
#define SHAnsiToUnicode(psz, pwsz, cchwsz)  MultiByteToWideChar(CP_ACP, MB_ERR_INVALID_CHARS, psz, -1, pwsz, cchwsz)
#define SHUnicodeToAnsi _SHUnicodeToAnsi

//
// Global array of static system SIDs, corresponding to UI_SystemSid
//
struct
{
    SID sid;                // contains 1 subauthority
    DWORD dwSubAuth[1];     // we currently need at most 2 subauthorities
}
c_StaticSids[] =
{
    {{SID_REVISION, 1, SECURITY_CREATOR_SID_AUTHORITY, {SECURITY_CREATOR_OWNER_RID}},      {0}                             },
    {{SID_REVISION, 1, SECURITY_NT_AUTHORITY,          {SECURITY_AUTHENTICATED_USER_RID}}, {0}                             },
    {{SID_REVISION, 1, SECURITY_NT_AUTHORITY,          {SECURITY_LOCAL_SYSTEM_RID}},       {0}                             },
    {{SID_REVISION, 2, SECURITY_NT_AUTHORITY,          {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_ADMINS}       },
    {{SID_REVISION, 2, SECURITY_NT_AUTHORITY,          {SECURITY_BUILTIN_DOMAIN_RID}},     {DOMAIN_ALIAS_RID_POWER_USERS}  },
};

#define SSI_CREATOROWNER    0
#define SSI_AUTHUSER        1
#define SSI_SYSTEM          2
#define SSI_ADMIN           3
#define SSI_POWERUSER       4

typedef struct tagACEPARAMLIST
{
    DWORD dwSidIndex;
    DWORD AccessMask;
    DWORD dwAceFlags;
}
ACEPARAMLIST;

#define ACE_INHERIT         (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE)
#define FILE_MODIFY         (FILE_ALL_ACCESS & ~(WRITE_DAC | WRITE_OWNER))

const ACEPARAMLIST c_paplUnsecure[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_MODIFY,        0,
    SSI_AUTHUSER,       FILE_MODIFY,        ACE_INHERIT,
};

//
// CSIDL_COMMON_DOCUMENTS
// Admins, System, Creator Owner: Full Control - Container Inherit, Object Inherit
// Users, Power Users: Read - Container Inherit, Object Inherit
// Users, Power Users: Write - Container Inherit
//
// Non admin users can create files and directories. They have full control over 
// the files they create. All other users can read those files by default, but 
// they cannot modify the files unless the original creator gives them explicit 
// permissions to do so.
//
const ACEPARAMLIST c_paplCommonDocs[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_ADMIN,          FILE_ALL_ACCESS,    0,
    SSI_ADMIN,          GENERIC_ALL,        ACE_INHERIT,
    SSI_CREATOROWNER,   GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_READ,  0,
    SSI_AUTHUSER,       GENERIC_READ,       ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_WRITE, 0,
    SSI_AUTHUSER,       GENERIC_WRITE,      (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE),
    SSI_POWERUSER,      FILE_GENERIC_READ,  0,
    SSI_POWERUSER,      GENERIC_READ,       ACE_INHERIT,
    SSI_POWERUSER,      FILE_GENERIC_WRITE, 0,
    SSI_POWERUSER,      GENERIC_WRITE,      (CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE),
};

//
// CSIDL_COMMON_APPDATA
// Admins, System, Creator Owner: Full Control - Container Inherit, Object Inherit
// Power Users: Modify - Container Inherit, Object Inherit
// Users: Read - Container Inherit, Object Inherit
//
// Users can only read common appdata which is presumably created by admins or 
// power users during setup.
//
const ACEPARAMLIST c_paplCommonAppData[] =
{
    SSI_SYSTEM,         FILE_ALL_ACCESS,    0,
    SSI_SYSTEM,         GENERIC_ALL,        ACE_INHERIT,
    SSI_ADMIN,          FILE_ALL_ACCESS,    0,
    SSI_ADMIN,          GENERIC_ALL,        ACE_INHERIT,
    SSI_CREATOROWNER,   GENERIC_ALL,        ACE_INHERIT,
    SSI_AUTHUSER,       FILE_GENERIC_READ,  0,
    SSI_AUTHUSER,       GENERIC_READ,       ACE_INHERIT,
    SSI_POWERUSER,      FILE_MODIFY,        0,
    SSI_POWERUSER,      FILE_MODIFY,        ACE_INHERIT,
};


long _SHUnicodeToAnsi(LPCWSTR pwsz, LPSTR psz, long cchCount)
{
    psz[0] = 0;
    return WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cchCount, 0, 0);
}


LPWSTR _lstrcpyW(LPWSTR pwszDest, LPCWSTR pwszOrig)
{
    if (pwszDest && pwszOrig)
    {
        do 
        {
            *pwszDest = *pwszOrig;
            pwszDest ++;
        } while ( *pwszOrig++);

        return pwszDest;
    }
    return 0;
}



BOOL _SetDirAccess(LPCWSTR pszFile, const ACEPARAMLIST* papl, ULONG cPapl);

HINSTANCE g_hinst = NULL;

typedef void (__stdcall * PFNSHFLUSHSFCACHE)();

BOOL IsNewShlwapi(HMODULE hmod)
{
    DLLGETVERSIONPROC pfnGetVersion = (DLLGETVERSIONPROC)GetProcAddress(hmod, "DllGetVersion");
    if (pfnGetVersion)
    {
        DLLVERSIONINFO dllinfo;
        dllinfo.cbSize = sizeof(dllinfo);
        if (pfnGetVersion(&dllinfo) == NOERROR)
        {
            return  (dllinfo.dwMajorVersion > 5) ||
                    ((dllinfo.dwMajorVersion == 5) &&
                     ((dllinfo.dwMinorVersion > 0) ||
                      ((dllinfo.dwMinorVersion == 0) &&
                       (dllinfo.dwBuildNumber > 2012))));
        }
    }
    return 0;
}

void FlushShellFolderCache()
{
    // We could link directly now, but this is a smaller delta...
    HMODULE hmod = LoadLibraryA("shlwapi.dll");
    if (hmod) 
    {
        // avoid IE5 beta1 shlwapi.dll that has an export here but
        // not what we expect
        if (IsNewShlwapi(hmod))
        {
            PFNSHFLUSHSFCACHE pfn = (PFNSHFLUSHSFCACHE)GetProcAddress(hmod, (CHAR *) MAKEINTRESOURCE(419));
            if (pfn) 
                pfn();
        }
        FreeLibrary(hmod);
    }
}

HRESULT _SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath)
{
    HRESULT hr = E_NOTIMPL;
    HMODULE hmod = LoadLibraryA("shell32.dll");
    if (hmod) 
    {
        PFNSHGETFOLDERPATHW pfn = (PFNSHGETFOLDERPATHW)GetProcAddress(hmod, "SHGetFolderPathW");
        if (pfn) 
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
        FreeLibrary(hmod);
    }
    return hr;
}

BOOL RunningOnNT()
{
    static BOOL s_fRunningOnNT = 42;
    if (s_fRunningOnNT == 42)
    {
        OSVERSIONINFO osvi;

        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        s_fRunningOnNT = (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId);
    }
    return s_fRunningOnNT;
}


// shell32.SHGetSpecialFolderPath (175)
// undocumented API, but the only one that exists on all platforms
//
// this thunk deals with the A/W issues based on the platform as
// the export was TCHAR
//      

typedef BOOL(__stdcall * PFNSHGETSPECIALFOLDERPATH)(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate);

BOOL _SHGetSpecialFolderPath(HWND hwnd, LPWSTR pszPath, int csidl, BOOL fCreate)
{
    BOOL bRet = FALSE;
    HMODULE hmod = LoadLibraryA("shell32.dll");
    if (hmod) 
    {
        PFNSHGETSPECIALFOLDERPATH pfn = (PFNSHGETSPECIALFOLDERPATH)GetProcAddress(hmod, (CHAR*) MAKEINTRESOURCE(175));
        if (pfn)
        {
            if (RunningOnNT())         // compute from Get
            {
                bRet = pfn(hwnd, pszPath, csidl, fCreate);
            }
            else
            {
                CHAR szPath[MAX_PATH];
                szPath[0] = 0;
                bRet = pfn(hwnd, (LPWSTR)szPath, csidl, fCreate);
                if (bRet)
                    SHAnsiToUnicode(szPath, pszPath, MAX_PATH);      // WideCharToMultiByte wrapper
            }
        }
        FreeLibrary(hmod);
    }
    return bRet;
}

BOOL GetProgramFiles(LPCWSTR pszValue, LPWSTR pszPath)
{
    HKEY hkey;
    DWORD cbPath = MAX_PATH;

    *pszPath = 0;
    if (ERROR_SUCCESS == RegOpenKeyA(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion", &hkey)) 
    {
        if (RunningOnNT()) 
        {
            cbPath *= sizeof(WCHAR);
            RegQueryValueExW(hkey, pszValue, NULL, NULL, (LPBYTE) pszPath, &cbPath);
        }
        else 
        {
            CHAR szPath[MAX_PATH], szValue[64];
            szPath[0] = 0;
            _SHUnicodeToAnsi(pszValue, szValue, ARRAYSIZE(szValue));
            RegQueryValueExA(hkey, szValue, NULL, NULL, szPath, &cbPath);
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
        }
        RegCloseKey(hkey);
    }
    return (BOOL)*pszPath;
}


// get the equiv of %USERPROFILE% on both win95 and NT
//
// on Win95 without user profiles turned on this will fail
// out:
//      phkey   optional out param
//
// returns:
//      length of the profile path

UINT GetProfilePath(LPWSTR pszPath, HKEY *phkey, UINT *pcchProfile)
{
    
    if (phkey)
        *phkey = NULL;

    if (pcchProfile)
        *pcchProfile = 0;

    if (RunningOnNT()) 
    {
        ExpandEnvironmentStringsW(L"%USERPROFILE%", pszPath, MAX_PATH);
        if (pszPath[0] == L'%')
            pszPath[0] = 0;
    }
    else 
    {
        HKEY hkeyProfRec;
        LONG err;
        CHAR szProfileDir[MAX_PATH];
        szProfileDir [0] = 0;
        err = RegCreateKeyExA(HKEY_CURRENT_USER, "Software\\Microsoft\\Windows\\CurrentVersion\\ProfileReconciliation", 0, NULL,
                                  REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                                  NULL, &hkeyProfRec, NULL);
        if (err == ERROR_SUCCESS) 
        {
            DWORD cbData = sizeof(szProfileDir);
            RegQueryValueExA(hkeyProfRec, "ProfileDirectory", 0, NULL, (LPBYTE)szProfileDir, &cbData);
            if (phkey)
                *phkey = hkeyProfRec;
            else
                RegCloseKey(hkeyProfRec);
            if (pcchProfile)
                *pcchProfile = lstrlenA(szProfileDir);
            SHAnsiToUnicode(szProfileDir, pszPath, MAX_PATH);
        }
    }

    return lstrlenW(pszPath);
}

void SHGetWindowsDirectory(LPWSTR pszPath)
{
    if (RunningOnNT())
        GetWindowsDirectoryW(pszPath, MAX_PATH);
    else 
    {
        CHAR szPath[MAX_PATH];
        if (GetWindowsDirectoryA(szPath, ARRAYSIZE(szPath)-1))
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
    }
}

#define CH_WHACK FILENAME_SEPARATOR_W

// add a backslash to a qualified path
//
// in:
//  pszPath    path (A:, C:\foo, etc)
//
// out:
//  pszPath    A:\, C:\foo\    ;
//
// returns:
//  pointer to the NULL that terminates the path


STDAPI_(LPWSTR) PathAddBackslash(LPWSTR pszPath)
{
    LPWSTR pszEnd;

    // try to keep us from tromping over MAX_PATH in size.
    // if we find these cases, return NULL.  Note: We need to
    // check those places that call us to handle their GP fault
    // if they try to use the NULL!

    int ichPath = lstrlenW(pszPath);
    if (ichPath >= (MAX_PATH - 1))
        return NULL;

    pszEnd = pszPath + ichPath;

    // this is really an error, caller shouldn't pass
    // an empty string
    if (!*pszPath)
        return pszEnd;

    /* Get the end of the source directory
    */
    switch(* (pszEnd-1)) {
    case CH_WHACK:
        break;

    default:
        *pszEnd++ = CH_WHACK;
        *pszEnd = 0;
    }
    return pszEnd;
}

// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

STDAPI_(LPWSTR) PathFindFileName(LPCWSTR pPath)
{
    LPCWSTR pT;

    for (pT = pPath; *pPath; ++pPath) 
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':' || pPath[0] == L'/')
            && pPath[1] &&  pPath[1] != L'\\'  &&   pPath[1] != L'/')
            pT = pPath + 1;
    }
    return (LPWSTR)pT;   // const -> non const
}

STDAPI_(LPWSTR) PathFindSecondFileName(LPCWSTR pPath)
{
    LPCWSTR pT, pRet = NULL;
    
    for (pT = pPath; *pPath; ++pPath) 
    {
        if ((pPath[0] == L'\\' || pPath[0] == L':' || pPath[0] == L'/')
            && pPath[1] &&  pPath[1] != L'\\'  &&   pPath[1] != L'/')
        {
            pRet = pT;    // remember last
            
            pT = pPath + 1;
        }
    }
    return (LPWSTR)pRet;   // const -> non const
}


// This function is modified in that if the string's length is 0, the null terminator is NOT copied to the buffer.

int _LoadStringExW(
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    cch = 0;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    if (hResInfo = FindResourceExW(g_hinst, (LPCWSTR)RT_STRING,
                                   (LPWSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)), wLangId))
    {
        // Load that segment.
        hStringSeg = LoadResource(g_hinst, hResInfo);

        // Lock the resource.
        if (lpsz = (LPWSTR)LockResource(hStringSeg))
        {
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)
            wID &= 0x0F;
            while (TRUE)
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }


            // Account for the NULL
            cchBufferMax--;

            // Don't copy more than the max allowed.
            if (cch > cchBufferMax)
                cch = cchBufferMax;

            // Copy the string into the buffer.
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));


            // Attach Null terminator.
            lpBuffer[cch] = 0;
        }
    }
    return cch;
}

BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCWSTR lpszType, LPCWSTR lpszName, LANGID wLangId, LPARAM lParam)
{
    *(LANGID *)lParam = wLangId;
    return FALSE;
}

BOOL CALLBACK EnumResNameProc(HINSTANCE hinst, LPCWSTR lpszType, LPCWSTR lpszName, LPARAM lParam)
{
    EnumResourceLanguagesW(hinst, lpszType, lpszName, EnumResLangProc, lParam);
    return FALSE;
}

LANGID GetShellLangId()
{
    static LANGID wShellLangID=0xffff;
    if (0xffff == wShellLangID) 
    {
        BOOL fSuccess;
        HINSTANCE hShell;
        hShell = LoadLibraryA("shell32.dll");
        if (hShell)
        {
            EnumResourceNamesW(hShell,  (LPWSTR) RT_VERSION, EnumResNameProc, (LPARAM) &wShellLangID);
            FreeLibrary(hShell);
        }
        if (0xffff == wShellLangID)
            wShellLangID = GetSystemDefaultLangID();
    }
    return wShellLangID;
}


void PathAppendResource(LPWSTR pszPath, UINT id)
{
    WCHAR sz[MAX_PATH];
    sz[0] = 0;

    if (!_LoadStringExW(id, sz, ARRAYSIZE(sz), GetShellLangId()))
        _LoadStringExW(id, sz, ARRAYSIZE(sz), MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US));
    if (*sz && ((lstrlenW(pszPath) + lstrlenW(sz)) < MAX_PATH))
        _lstrcpyW(PathAddBackslash(pszPath),sz);
}

void PathAppend(LPWSTR pszPath, LPCWSTR pszAppend)
{
    if (pszPath && pszAppend)
    {
        if (((lstrlenW(pszPath) + lstrlenW(pszAppend)) < MAX_PATH))
            _lstrcpyW(PathAddBackslash(pszPath), pszAppend);
    }
}

const CHAR c_szUSF[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";
const CHAR c_szSF[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";

LONG RegSetStrW(HKEY hkey, LPCWSTR pszValueName, LPCWSTR pszValue)
{
    return RegSetValueExW(hkey, pszValueName, 0, REG_SZ, (LPBYTE)pszValue, (lstrlenW(pszValue) + 1) * sizeof(WCHAR));
}

LONG RegSetStrA(HKEY hkey, LPCSTR pszValueName, LPCSTR pszValue)
{
    return RegSetValueExA(hkey, pszValueName, 0, REG_SZ, (LPBYTE)pszValue, (lstrlenA(pszValue) + 1) * sizeof(CHAR));
}

void MakeFolderRoam(HKEY hkeyProfRec, LPCSTR pszName, LPCWSTR pszPath, UINT cchProfile)
{
    HKEY hSubKey;
    LONG err;
    CHAR szPath[MAX_PATH];


    ASSERT(!RunningOnNT());

    _SHUnicodeToAnsi(pszPath, szPath, MAX_PATH);

    err = RegCreateKeyExA(hkeyProfRec, pszName, 0, NULL, REG_OPTION_NON_VOLATILE,
                              KEY_WRITE, NULL, &hSubKey, NULL);
    if (err == ERROR_SUCCESS)
    {
        CHAR szDefaultPath[MAX_PATH];
        DWORD dwOne = 1;
        LPCSTR pszEnd = szPath + cchProfile + 1;

        szDefaultPath[0] = 0;
        lstrcpyA(szDefaultPath, "*windir");
        lstrcatA(szDefaultPath, szPath + cchProfile);

        RegSetStrA(hSubKey, "CentralFile", pszEnd);
        RegSetStrA(hSubKey, "LocalFile",   pszEnd);
        RegSetStrA(hSubKey, "Name",        "*.*");
        RegSetStrA(hSubKey, "DefaultDir",  szDefaultPath);

        RegSetValueExA(hSubKey, "MustBeRelative", 0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne));
        RegSetValueExA(hSubKey, "Default",        0, REG_DWORD, (LPBYTE)&dwOne, sizeof(dwOne));

        RegSetStrA(hSubKey, "RegKey",   c_szUSF);
        RegSetStrA(hSubKey, "RegValue", pszName);

        RegCloseKey(hSubKey);
    }
}

typedef struct _FOLDER_INFO
{
    int id;                 // CSIDL value
    HKEY hkRoot;            // per user, per machine
    UINT idsDirName;        // esource ID for directory name 
    LPCSTR pszRegValue;    // Name of reg value and ProfileReconciliation subkey
    BOOL (*pfnGetPath)(const struct _FOLDER_INFO *, LPWSTR);  // compute the path if not found
    const ACEPARAMLIST* papl;
    ULONG cApl;
}
FOLDER_INFO;

typedef struct _NT_FOLDER_INFO
{
    const FOLDER_INFO *pfi; 
    WCHAR wszRegValue[60]; // this should be long enough to hold the longest member of FOLDER_INFO.pszRegValue
}
NT_FOLDER_INFO;

BOOL DownLevelRoaming(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    HKEY hkeyProfRec;
    UINT cchProfile;
    UINT cwchProfile = GetProfilePath(pszPath, &hkeyProfRec, &cchProfile);
    if (cwchProfile)
    {
        PathAppendResource(pszPath, pfi->idsDirName);
        if (hkeyProfRec)
        {
            MakeFolderRoam(hkeyProfRec, pfi->pszRegValue, pszPath, cchProfile);
            RegCloseKey(hkeyProfRec);
        }
    }
    else
    {
        SHGetWindowsDirectory(pszPath);
        if (pfi->id == CSIDL_PERSONAL)
        {
            if (pszPath[1] == TEXT(':') &&
                pszPath[2] == TEXT('\\'))
            {
                pszPath[3] = 0; // strip to "C:\"
            }
        }
        PathAppendResource(pszPath, pfi->idsDirName);
    }

    return (BOOL)*pszPath;
}

BOOL DownLevelNonRoaming(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    UINT cchProfile = GetProfilePath(pszPath, NULL, 0);
    if (cchProfile)
    {
        PathAppendResource(pszPath, pfi->idsDirName);
    }
    else
    {
        SHGetWindowsDirectory(pszPath);
        PathAppendResource(pszPath, pfi->idsDirName);
    }

    return (BOOL)*pszPath;
}

BOOL DownLevelRelative(UINT csidl, UINT id, LPWSTR pszPath)
{
    *pszPath = 0;   // assume error

    // since this is inside MyDocs make sure MyDocs exists first (for the create call)
    if (SHGetFolderPathW(NULL, csidl | CSIDL_FLAG_CREATE, NULL, 0, pszPath) == S_OK)
    {
        PathAppendResource(pszPath, id);
    }
    return (BOOL)*pszPath;
}

// we explictly don't want the MyPics folder to roam. the reasonaing being
// that the contents of this are typically too large to give a good roaming
// experience. but of course NT4 (< SP4) still roams everyting in the profile
// dir thus this will roam on those platforms.

BOOL DownLevelMyPictures(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PERSONAL, IDS_CSIDL_MYPICTURES, pszPath);
}

BOOL DownLevelMyMusic(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PERSONAL, IDS_CSIDL_MYMUSIC, pszPath);
}

BOOL DownLevelAdminTools(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_PROGRAMS, IDS_CSIDL_ADMINTOOLS, pszPath);
}

BOOL DownLevelCommonAdminTools(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    return DownLevelRelative(CSIDL_COMMON_PROGRAMS, IDS_CSIDL_ADMINTOOLS, pszPath);
}

const WCHAR c_wszAllUsers[] = L"All Users"; // not localized

BOOL GetAllUsersRoot(LPWSTR pszPath)
{
    if (GetProfilePath(pszPath, NULL, 0))
    {
        // yes, non localized "All Users" per ericflo (NT4 behavior)

        if (lstrlenW(pszPath) + ARRAYSIZE(c_wszAllUsers) < MAX_PATH)
            _lstrcpyW(PathFindFileName(pszPath), c_wszAllUsers);
    }
    else
    {
        // Win95 case
        SHGetWindowsDirectory(pszPath);
        // yes, non localized "All Users" per ericflo (NT4 behavior)
        _lstrcpyW(PathAddBackslash(pszPath), c_wszAllUsers);
    }
    return *pszPath;
}

BOOL DownLevelCommon(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    if (GetAllUsersRoot(pszPath))
    {
        PathAppendResource(pszPath, pfi->idsDirName);
    }
    return (BOOL)*pszPath;
}

BOOL DownLevelCommonPrograms(const FOLDER_INFO *pfi, LPWSTR pszPath)
{
    WCHAR szPath[MAX_PATH];

    if (S_OK == SHGetFolderPathW(NULL, CSIDL_PROGRAMS, NULL, 0, szPath))
    {
        if (GetAllUsersRoot(pszPath))
        {
            PathAppend(pszPath, PathFindSecondFileName(szPath));
        }
    }
    return (BOOL)*pszPath;
}


#define HKLM    HKEY_LOCAL_MACHINE
#define HKCU    HKEY_CURRENT_USER

const FOLDER_INFO c_rgFolders[] =
{
    { CSIDL_PERSONAL,           HKCU, IDS_CSIDL_PERSONAL,         "Personal",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_MYPICTURES,         HKCU, IDS_CSIDL_MYPICTURES,       "My Pictures",
            DownLevelMyPictures,        NULL,                0 },
    { CSIDL_MYMUSIC,            HKCU, IDS_CSIDL_MYMUSIC,          "My Music",
            DownLevelMyMusic,           NULL,                0 },
    { CSIDL_APPDATA,            HKCU, IDS_CSIDL_APPDATA,          "AppData",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_LOCAL_APPDATA,      HKCU, IDS_CSIDL_LOCAL_APPDATA,    "Local AppData",
            DownLevelNonRoaming,        NULL,                0 },
    { CSIDL_INTERNET_CACHE,     HKCU, IDS_CSIDL_CACHE,            "Cache",
            DownLevelNonRoaming,        NULL,                0 },
    { CSIDL_COOKIES,            HKCU, IDS_CSIDL_COOKIES,          "Cookies",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_HISTORY,            HKCU, IDS_CSIDL_HISTORY,          "History",
            DownLevelRoaming,           NULL,                0 },
    { CSIDL_ADMINTOOLS,         HKCU, IDS_CSIDL_ADMINTOOLS,       "Administrative Tools",
            DownLevelAdminTools,        NULL,                0 },
    { CSIDL_COMMON_APPDATA,     HKLM, IDS_CSIDL_APPDATA,          "Common AppData",
            DownLevelCommon,            c_paplCommonAppData, ARRAYSIZE(c_paplCommonAppData) },
    { CSIDL_COMMON_DOCUMENTS,   HKLM, IDS_CSIDL_COMMON_DOCUMENTS, "Common Documents",
            DownLevelCommon,            c_paplCommonDocs,    ARRAYSIZE(c_paplCommonDocs) },
    { CSIDL_COMMON_PROGRAMS,    HKLM, 0,                          "Common Programs",
            DownLevelCommonPrograms,    c_paplUnsecure,      ARRAYSIZE(c_paplUnsecure) },
    { CSIDL_COMMON_ADMINTOOLS,  HKLM, IDS_CSIDL_ADMINTOOLS,       "Common Administrative Tools",
            DownLevelCommonAdminTools,  c_paplUnsecure,      ARRAYSIZE(c_paplUnsecure) },

    { -1, HKCU, 0, NULL, NULL, NULL }
};

BOOL UnExpandEnvironmentString(LPCWSTR pszPath, LPCWSTR pszEnvVar, LPWSTR pszResult, UINT cbResult)
{
    DWORD nToCmp;
    WCHAR szEnvVar[MAX_PATH];
    szEnvVar[0] = 0;
    ASSERT(RunningOnNT());
    ExpandEnvironmentStringsW(pszEnvVar, szEnvVar, ARRAYSIZE(szEnvVar)); // don't count the NULL
    nToCmp = lstrlenW(szEnvVar);
   
    if (CompareStringW(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, nToCmp, pszPath, nToCmp) == 2) 
    {
        if (lstrlenW(pszPath) - (int)nToCmp  + lstrlenW(pszEnvVar) < (int)cbResult)
        {
            _lstrcpyW(pszResult, pszEnvVar);
            _lstrcpyW(pszResult + lstrlenW(pszResult), pszPath + nToCmp);
            return TRUE;
        }
    }
    return FALSE;
}

const FOLDER_INFO *FindFolderInfo(int csidl)
{
    const FOLDER_INFO *pfi;
    for (pfi = c_rgFolders; pfi->id != -1; pfi++)
    {
        if (pfi->id == csidl) 
            return pfi;
    }
    return NULL;
}

BOOL _SHCreateDirectory(LPCWSTR pszPath) 
{
    if (RunningOnNT())
        return CreateDirectoryW(pszPath, NULL);
    else 
    {
        // no check for Unicode -> Ansi needed here, because we validated 
        // the path in _EnsureExistsOrCreate()
        CHAR szPath[MAX_PATH];
        _SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        return CreateDirectoryA(szPath, NULL);
    }
}

BOOL _CreateDirectoryDeep(LPCWSTR pszPath)
{
    BOOL bRet = _SHCreateDirectory(pszPath);
    if (!bRet && (lstrlenW(pszPath) < MAX_PATH))
    {
        WCHAR *pEnd, *pSlash, szTemp[MAX_PATH + 1];  // +1 for PathAddBackslash()

        // There are certain error codes that we should bail out here
        // before going through and walking up the tree...
        switch (GetLastError())
        {
        case ERROR_FILENAME_EXCED_RANGE:
        case ERROR_FILE_EXISTS:
            return FALSE;
        }

        _lstrcpyW(szTemp, pszPath);
        pEnd = PathAddBackslash(szTemp); // for the loop below

        // assume we have 'X:\' to start this should even work
        // on UNC names because will will ignore the first error

        pSlash = szTemp + 3;

        // create each part of the dir in order

        while (*pSlash) 
        {
            while (*pSlash && *pSlash != CH_WHACK)
                pSlash ++;

            if (*pSlash) 
            {
                *pSlash = 0;    // terminate path at seperator
                bRet = _SHCreateDirectory(szTemp);
            }
            *pSlash++ = CH_WHACK;     // put the seperator back
        }
    }
    return bRet;
}

// check for
//      X:\foo
//      \\foo

BOOL PathIsFullyQualified(LPCWSTR pszPath)
{
    return pszPath[0] && pszPath[1] && 
        (pszPath[1] == ':' || (pszPath[0] == '\\' && pszPath[1] == '\\'));
}

HRESULT GetPathFromRegOrDefault(const NT_FOLDER_INFO *npfi, LPWSTR pszPath)
{
    HRESULT hr;
    HKEY hkeyUserShellFolders;
    LONG err;
    CHAR szPath[MAX_PATH];
    const FOLDER_INFO *pfi = npfi->pfi;

    szPath[0] = 0;

    err = RegCreateKeyExA(pfi->hkRoot, c_szUSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_READ, NULL, &hkeyUserShellFolders, NULL);

    if (err == ERROR_SUCCESS)
    {
        DWORD dwType, cbData = MAX_PATH * sizeof(*pszPath);
        if (RunningOnNT()) 
        {
            err = RegQueryValueExW(hkeyUserShellFolders, npfi->wszRegValue, NULL, &dwType, (LPBYTE)pszPath, &cbData);
        }
        else
        {
            err = RegQueryValueExA(hkeyUserShellFolders, pfi->pszRegValue, NULL, &dwType, (LPBYTE)szPath, &cbData);
            SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
        }

        if (err == ERROR_SUCCESS && cbData)
        {
            if (dwType == REG_EXPAND_SZ)
            {
                if (RunningOnNT()) 
                {
                    WCHAR szExpand[MAX_PATH];
                    szExpand[0] = 0;
                    if (ExpandEnvironmentStringsW(pszPath, szExpand, ARRAYSIZE(szExpand)))
                        lstrcpynW(pszPath, szExpand, MAX_PATH);
                }
                else
                {
                    CHAR szExpand[MAX_PATH];
                    szExpand[0] = 0;
                    ExpandEnvironmentStringsA(szPath, szExpand, ARRAYSIZE(szExpand));   
                    SHAnsiToUnicode(szExpand,  pszPath, MAX_PATH);
                }
            }

        }
        else if (pfi->pfnGetPath && pfi->pfnGetPath(pfi, pszPath))
        {
            err = ERROR_SUCCESS;

            // store results back to "User Shell Folders" on NT, but not on Win95

            if (RunningOnNT())
            {
                WCHAR szDefaultPath[MAX_PATH];
                HKEY hkeyWriteUserShellFolders;
                LONG err2;

                szDefaultPath[0] = 0;

                if (!UnExpandEnvironmentString(pszPath, L"%USERPROFILE%", szDefaultPath, ARRAYSIZE(szDefaultPath)))
                {
                    if (!UnExpandEnvironmentString(pszPath, L"%SYSTEMROOT%", szDefaultPath, ARRAYSIZE(szDefaultPath)))
                    {
                        _lstrcpyW(szDefaultPath, pszPath);
                    }
                }

                err2 = RegCreateKeyExA(pfi->hkRoot, c_szUSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                                KEY_WRITE, NULL, &hkeyWriteUserShellFolders, NULL);

                if (err2 == ERROR_SUCCESS)
                {
                    RegSetValueExW(hkeyWriteUserShellFolders, npfi->wszRegValue, 0, REG_EXPAND_SZ, (LPBYTE)szDefaultPath, (lstrlenW(szDefaultPath) + 1) * sizeof(szDefaultPath[0]));

                    RegCloseKey(hkeyWriteUserShellFolders);
                }
            }
        }
        else
            err = ERROR_PATH_NOT_FOUND;

        // validate the returned path here
        if (err == ERROR_SUCCESS)
        {
            // expand failed (or some app messed up and did not use REG_EXPAND_SZ)
            if (*pszPath == L'%')
            {
                err = ERROR_ENVVAR_NOT_FOUND;
                *pszPath = 0;
            }
            else if (!PathIsFullyQualified(pszPath))
            {
                err = ERROR_PATH_NOT_FOUND;
                *pszPath = 0;
            }
        }

        RegCloseKey(hkeyUserShellFolders);
    }
    return HRESULT_FROM_WIN32(err);
}

HRESULT _EnsureExistsOrCreate(LPWSTR pszPath, BOOL bCreate, const ACEPARAMLIST* papl, ULONG cApl)
{
    HRESULT hr;
    DWORD dwFileAttributes;


    if (RunningOnNT()) 
        dwFileAttributes = GetFileAttributesW(pszPath);
    else 
    {
        CHAR szPath[MAX_PATH];
        if (_SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath)))
            dwFileAttributes = GetFileAttributesA(szPath);
        else
        {
            pszPath[0] = 0;
            return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);
        }
    }

        
    if (dwFileAttributes == -1)
    {
        if (bCreate)
        {
            if (_CreateDirectoryDeep(pszPath))
            {
                hr = S_OK;
                if (papl && RunningOnNT())
                {
                   _SetDirAccess(pszPath, papl, cApl);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                *pszPath = 0;
            }
        }
        else
        {
            hr = S_FALSE;
            *pszPath = 0;
        }
    }
    else
        hr = S_OK;

    return hr;
}

HRESULT _DownLevelGetFolderPath(int csidl, LPWSTR pszPath, BOOL bCreate)
{
    const FOLDER_INFO *pfi;
    HRESULT hr = E_INVALIDARG;
    
    *pszPath = 0;   // assume error
    
    pfi = FindFolderInfo(csidl);
    if (pfi)
    {
        NT_FOLDER_INFO nfi;
        nfi.pfi = pfi;
        SHAnsiToUnicode(pfi->pszRegValue, nfi.wszRegValue, ARRAYSIZE(nfi.wszRegValue));
        // get default value from "User Shell Folders"
        
        hr = GetPathFromRegOrDefault(&nfi, pszPath);
        if (SUCCEEDED(hr))
        {
            hr = _EnsureExistsOrCreate(pszPath, bCreate, pfi->papl, pfi->cApl);
            if (hr == S_OK)
            {
                HKEY hkeyShellFolders;
                LONG err;
                
                // store to "Shell Folders"
                err = RegCreateKeyExA(pfi->hkRoot, c_szSF, 0, NULL, REG_OPTION_NON_VOLATILE,
                    KEY_READ | KEY_WRITE, NULL, &hkeyShellFolders, NULL);

                if (err == ERROR_SUCCESS)
                {
                    if (RunningOnNT())  
                    {
                        RegSetStrW(hkeyShellFolders, nfi.wszRegValue, pszPath);
                    }
                    else 
                    {
                        CHAR szPath[MAX_PATH]; 
                        _SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
                        RegSetStrA(hkeyShellFolders, pfi->pszRegValue, szPath);
                    }
                    RegCloseKey(hkeyShellFolders);
                }
                
                FlushShellFolderCache();
            }
        }
    }
    else
    {
        if (csidl == CSIDL_WINDOWS)
        {
            SHGetWindowsDirectory(pszPath);
            hr = S_OK;
        }
        else if (csidl == CSIDL_SYSTEM)
        {
            if (RunningOnNT())
                GetSystemDirectoryW(pszPath, MAX_PATH);
            else {
                CHAR szPath[MAX_PATH];
                szPath[0] = 0;
                GetSystemDirectoryA(szPath, MAX_PATH);
                SHAnsiToUnicode(szPath, pszPath, MAX_PATH);
            }
            hr = S_OK;
        }
        else if (csidl == CSIDL_PROGRAM_FILES)
        {
            hr = GetProgramFiles(L"ProgramFilesDir", pszPath) ? S_OK : S_FALSE;
        }
        else if (csidl == CSIDL_PROGRAM_FILES_COMMON)
        {
            hr = GetProgramFiles(L"CommonFilesDir", pszPath) ? S_OK : S_FALSE;
        }
    }
    return hr;
}

// We pass csidl to _SHGetSpecialFolderPath only for NT 4 English folders
// NT bug # 60970
// NT bug # 222510
// NT bug # 221492

STDAPI SHGetFolderPathW(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPWSTR pszPath)
{
    HRESULT hr;

    if (IsBadWritePtr(pszPath, MAX_PATH * sizeof(WCHAR)))
        return E_INVALIDARG;

    pszPath[0] = 0;
    hr = _SHGetFolderPath(hwnd, csidl, hToken, dwFlags, pszPath);
    if (hr == E_NOTIMPL || hr == E_INVALIDARG)
    {
        BOOL bCreate = csidl & CSIDL_FLAG_CREATE;
        csidl &= ~CSIDL_FLAG_MASK;    // strip the flags

        if (hToken || dwFlags)
            return E_INVALIDARG;

        if ((csidl < CSIDL_LOCAL_APPDATA) && _SHGetSpecialFolderPath(hwnd, pszPath, csidl, bCreate))
        {
            hr = S_OK;
        }
        else
        {
            hr = _DownLevelGetFolderPath(csidl, pszPath, bCreate);
        }
    }
    return hr;
}


STDAPI SHGetFolderPathA(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    WCHAR wsz[MAX_PATH];
    HRESULT hr;

    wsz[0] = 0;
    if (IsBadWritePtr(pszPath, MAX_PATH * sizeof(*pszPath)))
        return E_INVALIDARG;

    pszPath[0] = 0;

    hr = SHGetFolderPathW(hwnd, csidl, NULL, 0, wsz);
    if (_SHUnicodeToAnsi(wsz, pszPath, MAX_PATH))
        return hr;
    else
        return HRESULT_FROM_WIN32(ERROR_NO_UNICODE_TRANSLATION);       
}

BOOL APIENTRY DllMain(IN HANDLE hDll, IN DWORD dwReason, IN LPVOID lpReserved)
{
    switch(dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        g_hinst = hDll;
        break;
        
    default:
        break;
    }
    
    return TRUE;
}

BOOL _AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid)
{
    //
    // First verify that the SID is valid on this platform
    //
    WCHAR szName[MAX_PATH], szDomain[MAX_PATH];
    DWORD cbName = ARRAYSIZE(szName);
    DWORD cbDomain = ARRAYSIZE(szDomain);

    SID_NAME_USE snu;
    if (LookupAccountSidW(NULL, pSid, szName, &cbName, szDomain, &cbDomain, &snu))
    {
        //
        // Yes, it's valid; now add the ACE
        //
        return AddAccessAllowedAce(pAcl, dwAceRevision, AccessMask, pSid);
    }

    return FALSE;
}

BOOL _AddAces(PACL pAcl, const ACEPARAMLIST* papl, ULONG cPapl)
{
    ULONG i;
    for (i = 0; i < cPapl; i++)
    {
        PSID psid = &c_StaticSids[papl[i].dwSidIndex];

        if (_AddAccessAllowedAce(pAcl, ACL_REVISION, papl[i].AccessMask, psid))
        {
            if (papl[i].dwAceFlags)
            {
                ACE_HEADER* pAceHeader;
                if (GetAce(pAcl, i, &pAceHeader))
                {
                    pAceHeader->AceFlags |= papl[i].dwAceFlags;
                }
                else
                {
                    return FALSE;
                }
            }
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}

PACL _CreateAcl(ULONG cPapl)
{
    // Allocate space for the ACL
    DWORD cbAcl = (cPapl * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + sizeof(c_StaticSids[0])))
                  + sizeof(ACL);

    PACL pAcl = (PACL) GlobalAlloc(GPTR, cbAcl);
    if (pAcl) 
    {
        InitializeAcl(pAcl, cbAcl, ACL_REVISION);
    }

    return pAcl;
}

BOOL _SetDirAccess(LPCWSTR pszDir, const ACEPARAMLIST* papl, ULONG cPapl)
{
    BOOL bRetVal = FALSE;
    PACL pAcl;

    ASSERT(RunningOnNT());

    pAcl = _CreateAcl(cPapl);
    if (pAcl)
    {
        if (_AddAces(pAcl, papl, cPapl))
        {
            SECURITY_DESCRIPTOR sd;

            // Put together the security descriptor
            if (InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
            {
                if (SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE))
                {
                    // Set the security
                    bRetVal = SetFileSecurityW(pszDir, DACL_SECURITY_INFORMATION, &sd);
                }
            }
        }

        GlobalFree(pAcl);
    }

    return bRetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\sendmail\util.cpp ===
#include "precomp.h"       // pch file
#pragma hdrstop
#define DECL_CRTFREE
#include <crtfree.h>

// deal with IShellLinkA/W uglyness...

HRESULT ShellLinkSetPath(IUnknown *punk, LPCTSTR pszPath)
{
    HRESULT hres;
#ifdef UNICODE
    IShellLinkW *pslW;
    hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->SetPath(pszPath);
        pslW->Release();
    }
    else
#endif
    {
        IShellLinkA *pslA;
        hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkA, &pslA));
        if (SUCCEEDED(hres))
        {
            CHAR szPath[MAX_PATH];
            SHUnicodeToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
            hres = pslA->SetPath(szPath);
            pslA->Release();
        }
    }
    return hres;
}

// deal with IShellLinkA/W uglyness...

HRESULT ShellLinkGetPath(IUnknown *punk, LPTSTR pszPath, UINT cch)
{
    HRESULT hres;
#ifdef UNICODE
    IShellLinkW *pslW;
    hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->GetPath(pszPath, cch, NULL, SLGP_UNCPRIORITY);
        pslW->Release();
    }
    else
#endif
    {
        IShellLinkA *pslA;
        hres = punk->QueryInterface(IID_PPV_ARG(IShellLinkA, &pslA));
        if (SUCCEEDED(hres))
        {
            CHAR szPath[MAX_PATH];
            hres = pslA->GetPath(szPath, ARRAYSIZE(szPath), NULL, SLGP_UNCPRIORITY);
            if (SUCCEEDED(hres))
                SHAnsiToUnicode(szPath, pszPath, cch);
            pslA->Release();
        }
    }
    return hres;
}


// return if we are running on NT or not?

BOOL RunningOnNT()
{
    static int s_bOnNT = -1;  // -1 means uninited, 0 means no, 1 means yes
    if (s_bOnNT == -1) 
    {
        OSVERSIONINFO osvi;
        osvi.dwOSVersionInfoSize = sizeof(osvi);
        GetVersionEx(&osvi);
        if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
            s_bOnNT = 1;
        else 
            s_bOnNT = 0;
    }
    return (BOOL)s_bOnNT;
}


// is a file a shortcut?  check its attributes

BOOL IsShortcut(LPCTSTR pszFile)
{
    SHFILEINFO sfi;
    return SHGetFileInfo(pszFile, 0, &sfi, sizeof(sfi), SHGFI_ATTRIBUTES) 
                                                && (sfi.dwAttributes & SFGAO_LINK);
}


// like OLE GetClassFile(), but it only works on ProgID\CLSID type registration
// not real doc files or pattern matched files

HRESULT CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid)
{
    TCHAR szProgID[80];
    LONG cb = SIZEOF(szProgID);
    if (RegQueryValue(HKEY_CLASSES_ROOT, pszExt, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];

        lstrcat(szProgID, TEXT("\\CLSID"));
        cb = SIZEOF(szCLSID);

        if (RegQueryValue(HKEY_CLASSES_ROOT, szProgID, szCLSID, &cb) == ERROR_SUCCESS)
        {
            WCHAR wszCLSID[80];

            SHTCharToUnicode(szCLSID, wszCLSID, ARRAYSIZE(wszCLSID));

            return CLSIDFromString(wszCLSID, pclsid);
        }
    }
    return E_FAIL;
}


// get the target of a shortcut. this uses IShellLink which 
// Internet Shortcuts (.URL) and Shell Shortcuts (.LNK) support so
// it should work generally

BOOL GetShortcutTarget(LPCTSTR pszPath, LPTSTR pszTarget, UINT cch)
{
    IUnknown *punk;
    HRESULT hres;
    CLSID clsid;

    *pszTarget = 0;     // assume none

    if (!IsShortcut(pszPath))
        return FALSE;

    if (FAILED(CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];
            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
            ppf->Load(wszPath, 0);
            ppf->Release();
        }
        hres = ShellLinkGetPath(punk, pszTarget, cch);
        punk->Release();
    }

    return FALSE;
}


// get the pathname to a sendto folder item

HRESULT GetDropTargetPath(LPTSTR pszPath, int id, LPCTSTR pszExt)
{
    LPITEMIDLIST pidl;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_SENDTO, &pidl)))
    {
        TCHAR szFileName[128], szBase[64];

        SHGetPathFromIDList(pidl, pszPath);
        SHFree(pidl);

        LoadString(g_hinst, id, szBase, ARRAYSIZE(szBase));
        wnsprintf(szFileName, ARRAYSIZE(szFileName), TEXT("\\%s.%s"), szBase, pszExt);

        lstrcat(pszPath, szFileName);
        return S_OK;
    }
    return E_FAIL;
}


// do common registration

#define NEVERSHOWEXT            TEXT("NeverShowExt")
#define SHELLEXT_DROPHANDLER    TEXT("shellex\\DropHandler")

void CommonRegister(HKEY hkCLSID, LPCTSTR pszCLSID, LPCTSTR pszExtension, int idFileName)
{
    TCHAR szFile[MAX_PATH];
    HKEY hk;
    TCHAR szKey[80];

    RegSetValueEx(hkCLSID, NEVERSHOWEXT, 0, REG_SZ, (BYTE *)TEXT(""), SIZEOF(TCHAR));

    if (RegCreateKey(hkCLSID, SHELLEXT_DROPHANDLER, &hk) == ERROR_SUCCESS) 
    {
        RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)pszCLSID, (lstrlen(pszCLSID) + 1) * SIZEOF(TCHAR));
        RegCloseKey(hk);
    }

    wnsprintf(szKey, ARRAYSIZE(szKey), TEXT(".%s"), pszExtension);
    if (RegCreateKey(HKEY_CLASSES_ROOT, szKey, &hk) == ERROR_SUCCESS) 
    {
        TCHAR szProgID[80];

        wnsprintf(szProgID, ARRAYSIZE(szProgID), TEXT("CLSID\\%s"), pszCLSID);

        RegSetValueEx(hk, NULL, 0, REG_SZ, (LPBYTE)szProgID, (lstrlen(szProgID) + 1) * SIZEOF(TCHAR));
        RegCloseKey(hk);
    }

    if (SUCCEEDED(GetDropTargetPath(szFile, idFileName, pszExtension)))
    {
        HANDLE hfile = CreateFile(szFile, 0, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hfile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hfile);
            SHSetLocalizedName(szFile, L"sendmail.dll", idFileName);
        }
    }
}

// SHPathToAnsi creates an ANSI version of a pathname.  If there is going to be a
// loss when converting from Unicode, the short pathname is obtained and stored in the 
// destination.  
//
// pszSrc  : Source buffer containing filename (of existing file) to be converted
// pszDest : Destination buffer to receive converted ANSI string.
// cbDest  : Size of the destination buffer, in bytes.
// 
// returns:
//      TRUE, the filename was converted without change
//      FALSE, we had to convert to short name
//

BOOL SHPathToAnsi(LPCTSTR pszSrc, LPSTR pszDest, int cbDest)
{
#ifdef UNICODE
    BOOL bUsedDefaultChar = FALSE;
   
    WideCharToMultiByte(CP_ACP, 0, pszSrc, -1, pszDest, cbDest, NULL, &bUsedDefaultChar);

    if (bUsedDefaultChar) 
    {  
        TCHAR szTemp[MAX_PATH];
        if (GetShortPathName(pszSrc, szTemp, ARRAYSIZE(szTemp)))
            SHTCharToAnsi(szTemp, pszDest, cbDest);
    }

    return !bUsedDefaultChar;
#else
    SHTCharToAnsi(pszSrc, pszDest, cbDest);
    return TRUE;
#endif
}

// First undefine everything that we are intercepting as to not forward back to us...
#undef SHGetSpecialFolderPath

// Explicit prototype because only the A/W prototypes exist in the headers
STDAPI_(BOOL) SHGetSpecialFolderPath(HWND hwnd, LPTSTR lpszPath, int nFolder, BOOL fCreate);

BOOL _SHGetSpecialFolderPath(HWND hwnd, LPTSTR pszPath, int nFolder, BOOL fCreate)
{
    BOOL fRet;

    if (RunningOnNT())
    {
#ifdef UNICODE
        fRet = SHGetSpecialFolderPath(hwnd, pszPath, nFolder, fCreate);
#else
        WCHAR wszPath[MAX_PATH];
        fRet = SHGetSpecialFolderPath(hwnd, (LPTSTR)wszPath, nFolder, fCreate);
        if (fRet)
            SHUnicodeToTChar(wszPath, pszPath, MAX_PATH);
#endif
    }
    else
    {
#ifdef UNICODE
        CHAR szPath[MAX_PATH];
        fRet = SHGetSpecialFolderPath(hwnd, (LPTSTR)szPath, nFolder, fCreate);
        if (fRet)
            SHAnsiToTChar(szPath, pszPath, MAX_PATH);
#else
        fRet = SHGetSpecialFolderPath(hwnd, pszPath, nFolder, fCreate);
#endif
    }
    return fRet;
}

BOOL PathYetAnotherMakeUniqueNameT(LPTSTR  pszUniqueName,
                                   LPCTSTR pszPath,
                                   LPCTSTR pszShort,
                                   LPCTSTR pszFileSpec)
{
    if (RunningOnNT())
    {
        WCHAR wszUniqueName[MAX_PATH];
        WCHAR wszPath[MAX_PATH];
        WCHAR wszShort[32];
        WCHAR wszFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
        pszPath = (LPCTSTR)wszPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToUnicode(pszShort, wszShort, ARRAYSIZE(wszShort));
            pszShort = (LPCTSTR)wszShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToUnicode(pszFileSpec, wszFileSpec, ARRAYSIZE(wszFileSpec));
            pszFileSpec = (LPCTSTR)wszFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)wszUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHUnicodeToTChar(wszUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
    else {
        // win9x thunk code from runonnt.c
        CHAR szUniqueName[MAX_PATH];
        CHAR szPath[MAX_PATH];
        CHAR szShort[32];
        CHAR szFileSpec[MAX_PATH];
        BOOL fRet;

        SHTCharToAnsi(pszPath, szPath, ARRAYSIZE(szPath));
        pszPath = (LPCTSTR)szPath;  // overload the pointer to pass through...

        if (pszShort)
        {
            SHTCharToAnsi(pszShort, szShort, ARRAYSIZE(szShort));
            pszShort = (LPCTSTR)szShort;  // overload the pointer to pass through...
        }

        if (pszFileSpec)
        {
            SHTCharToAnsi(pszFileSpec, szFileSpec, ARRAYSIZE(szFileSpec));
            pszFileSpec = (LPCTSTR)szFileSpec;  // overload the pointer to pass through...
        }

        fRet = PathYetAnotherMakeUniqueName((LPTSTR)szUniqueName, pszPath, pszShort, pszFileSpec);
        if (fRet)
            SHAnsiToTChar(szUniqueName, pszUniqueName, MAX_PATH);

        return fRet;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shfolder\resource.h ===
#define IDS_CSIDL_PERSONAL          1
#define IDS_CSIDL_MYPICTURES        2
#define IDS_CSIDL_APPDATA           3
#define IDS_CSIDL_LOCAL_APPDATA     4
#define IDS_CSIDL_CACHE             5
#define IDS_CSIDL_COOKIES           6
#define IDS_CSIDL_HISTORY           7
#define IDS_CSIDL_COMMON_DOCUMENTS  8
#define IDS_CSIDL_ADMINTOOLS        9
#define IDS_CSIDL_MYMUSIC           10
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cenumusernotify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       CEnumUserNotify.cpp
//
//  Contents:   implements CEnumUserNotify object
//
//----------------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cenumusers.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       EnumUsers.cpp
//
//  Contents:   implementation of CLogonEnumUsers
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "resource.h"
#include "UserOM.h"
#include <lmaccess.h>   // for NetQueryDisplayInformation
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success

#include <sddl.h>       // for ConvertSidToStringSid
#include <userenv.h>    // for DeleteProfile
#include <aclapi.h>     // for TreeResetNamedSecurityInfo
#include <tokenutil.h>  // for CPrivilegeEnable

#include <GinaIPC.h>
#include <MSGinaExports.h>


HRESULT BackupUserData(LPCTSTR pszSid, LPTSTR pszProfilePath, LPCTSTR pszDestPath);
DWORD EnsureAdminFileAccess(LPTSTR pszPath);


//
// IUnknown Interface
//

ULONG CLogonEnumUsers::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLogonEnumUsers::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLogonEnumUsers::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLogonEnumUsers, IDispatch),
        QITABENT(CLogonEnumUsers, IEnumVARIANT),
        QITABENT(CLogonEnumUsers, ILogonEnumUsers),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLogonEnumUsers::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLogonEnumUsers::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLogonEnumUsers::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLogonEnumUsers::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


STDMETHODIMP CLogonEnumUsers::Next(ULONG cUsers, VARIANT* rgvar, ULONG* pcUsersFetched)
{
    UNREFERENCED_PARAMETER(cUsers);
    UNREFERENCED_PARAMETER(rgvar);

    *pcUsersFetched = 0;
    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Skip(ULONG cUsers)
{
    UNREFERENCED_PARAMETER(cUsers);

    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Reset()
{
    return E_NOTIMPL;
}
STDMETHODIMP CLogonEnumUsers::Clone(IEnumVARIANT** ppenum)
{
    *ppenum = 0;
    return E_NOTIMPL;
}


//
// ILogonEnumUsers Interface
//

STDMETHODIMP CLogonEnumUsers::get_Domain(BSTR* pbstr)
{
    HRESULT hr;

    if (pbstr)
    {
        *pbstr = SysAllocString(_szDomain);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::put_Domain(BSTR bstr)
{
    HRESULT hr;

    if (bstr)
    {
        lstrcpyn(_szDomain, bstr, ARRAYSIZE(_szDomain));
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::get_EnumFlags(ILUEORDER* porder)
{
    HRESULT hr;

    if (porder)
    {
        *porder = _enumorder;
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::put_EnumFlags(ILUEORDER order)
{
    _enumorder = order;

    return S_OK;
}

STDMETHODIMP CLogonEnumUsers::get_currentUser(ILogonUser** ppLogonUserInfo)
{
    HRESULT hr = E_FAIL;

    *ppLogonUserInfo = NULL;
    if (ppLogonUserInfo)
    {
        WCHAR wszUsername[UNLEN+1];
        DWORD cch = UNLEN;

        if (GetUserNameW(wszUsername, &cch))
        {
            hr = _GetUserByName(wszUsername, ppLogonUserInfo);
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::get_length(UINT* pcUsers)
{
    HRESULT hr;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    if (pcUsers)
    {
        *pcUsers = (UINT)DPA_GetPtrCount(_hdpaUsers);
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::item(VARIANT varUserID, ILogonUser** ppLogonUserInfo)
{
    HRESULT hr = S_FALSE;
    
    *ppLogonUserInfo = NULL;

    if (varUserID.vt == (VT_BYREF | VT_VARIANT) && varUserID.pvarVal)
    {
        // This is sortof gross, but if we are passed a pointer to another variant, simply
        // update our copy here...
        varUserID = *(varUserID.pvarVal);
    }

    switch (varUserID.vt)
    {
        case VT_ERROR:
            // BUGBUG (reinerf) - what do we do here??
            hr = E_INVALIDARG;
            break;

        case VT_I2:
            varUserID.lVal = (long)varUserID.iVal;
            // fall through...
        case VT_I4:
            hr = _GetUserByIndex(varUserID.lVal, ppLogonUserInfo);
            break;
        case VT_BSTR:
            hr = _GetUserByName(varUserID.bstrVal, ppLogonUserInfo);
            break;
        default:
            hr = E_NOTIMPL;
    }

    return hr;
}


STDMETHODIMP CLogonEnumUsers::_NewEnum(IUnknown** ppunk)
{
    return QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
}


STDMETHODIMP CLogonEnumUsers::create(BSTR bstrLoginName, ILogonUser **ppLogonUser)
{
    HRESULT hr;

    hr = E_FAIL;

    if ( bstrLoginName && *bstrLoginName )
    {
        NET_API_STATUS nasRet;
        USER_INFO_1 usri1 = {0};

        usri1.usri1_name     = bstrLoginName;
        usri1.usri1_priv     = USER_PRIV_USER;
        usri1.usri1_flags    = UF_NORMAL_ACCOUNT | UF_SCRIPT | UF_DONT_EXPIRE_PASSWD;

        nasRet = NetUserAdd(NULL,           // local computer
                            1,              // structure level
                            (LPBYTE)&usri1, // user infomarmation
                            NULL);          // don't care

        if ( nasRet == NERR_PasswordTooShort )
        {
            // Password policy is in effect. Set UF_PASSWD_NOTREQD so we can
            // create the account with no password, and remove
            // UF_DONT_EXPIRE_PASSWD.
            //
            // We will then expire the password below, to force the user to
            // change it at first logon.

            usri1.usri1_flags = (usri1.usri1_flags & ~UF_DONT_EXPIRE_PASSWD) | UF_PASSWD_NOTREQD;
            nasRet = NetUserAdd(NULL,           // local computer
                                1,              // structure level
                                (LPBYTE)&usri1, // user infomarmation
                                NULL);          // don't care
        }

        if ( nasRet == NERR_Success )
        {
            TCHAR szDomainAndName[256];
            LOCALGROUP_MEMBERS_INFO_3 lgrmi3;

            wnsprintf(szDomainAndName, 
                      ARRAYSIZE(szDomainAndName), 
                      TEXT("%s\\%s"),
                      _szDomain,
                      bstrLoginName);

            lgrmi3.lgrmi3_domainandname = szDomainAndName;

            // by default newly created accounts will be child accounts

            nasRet = NetLocalGroupAddMembers(
                        NULL,
                        TEXT("Users"),
                        3,
                        (LPBYTE)&lgrmi3,
                        1);

            if (usri1.usri1_flags & UF_PASSWD_NOTREQD)
            {
                // Expire the password to force the user to change it at
                // first logon.

                PUSER_INFO_4 pusri4;
                nasRet = NetUserGetInfo(NULL, bstrLoginName, 4, (LPBYTE*)&pusri4);
                if (nasRet == NERR_Success)
                {
                    pusri4->usri4_password_expired = TRUE;
                    nasRet = NetUserSetInfo(NULL, bstrLoginName, 4, (LPBYTE)pusri4, NULL);
                    NetApiBufferFree(pusri4);
                }
            }

            if ( SUCCEEDED(CLogonUser::Create(bstrLoginName, TEXT(""), _szDomain, IID_ILogonUser, (LPVOID*)ppLogonUser)) )
            {
                if ( _hdpaUsers && DPA_AppendPtr(_hdpaUsers, *ppLogonUser) != -1 )
                {
                    (*ppLogonUser)->AddRef();
                }
                else
                {
                    // Invalidate the cached user infomation forcing
                    // a reenumeration the next time a client uses
                    // this object
                    _DestroyHDPAUsers();
                }
                hr = S_OK;
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


void _BuildBackupPath(ILogonUser *pLogonUser, LPCWSTR pszLoginName, LPCWSTR pszDir, LPWSTR szPath)
{
    WCHAR szName[MAX_PATH];
    VARIANT varDisplayName = {0};

    szName[0] = L'\0';

    pLogonUser->get_setting(L"DisplayName", &varDisplayName);

    if (varDisplayName.vt == VT_BSTR && varDisplayName.bstrVal && *varDisplayName.bstrVal)
    {
        lstrcpynW(szName, varDisplayName.bstrVal, ARRAYSIZE(szName));
    }
    else
    {
        lstrcpynW(szName, pszLoginName, ARRAYSIZE(szName));
    }

    if ((PathCleanupSpec(pszDir, szName) & (PCS_PATHTOOLONG | PCS_FATAL)) || (L'\0' == szName[0]))
    {
        LoadStringW(HINST_THISDLL, IDS_DEFAULT_BACKUP_PATH, szName, ARRAYSIZE(szName));
    }

    PathCombineW(szPath, pszDir, szName);
}


STDMETHODIMP CLogonEnumUsers::remove(VARIANT varUserId, VARIANT varBackupPath, VARIANT_BOOL *pbSuccess)
{
    HRESULT hr;
    ILogonUser *pLogonUser;

    // TODO: Check for multi-session. If the user is logged on,
    // forcibly log them off.

    *pbSuccess = VARIANT_FALSE;
    hr = S_FALSE;
    pLogonUser = NULL;

    if ( SUCCEEDED(item(varUserId, &pLogonUser)) )
    {
        HRESULT         hrSid;
        NET_API_STATUS  nasRet;
        VARIANT         varLoginName = {0};
        VARIANT         varStringSid = {0};

        pLogonUser->get_setting(L"LoginName", &varLoginName);
        hrSid = pLogonUser->get_setting(L"SID", &varStringSid);

        ASSERT(varLoginName.vt == VT_BSTR);

        if (SUCCEEDED(hrSid))
        {
            TCHAR szKey[MAX_PATH];
            TCHAR szProfilePath[MAX_PATH];

            szProfilePath[0] = TEXT('\0');

            // First, get the profile path

            lstrcpy(szKey, TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\"));
            lstrcat(szKey, varStringSid.bstrVal);
            DWORD dwSize = sizeof(szProfilePath);
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                            szKey,
                                            TEXT("ProfileImagePath"),
                                            NULL,
                                            szProfilePath,
                                            &dwSize))
            {
                // Reset ACLs on the profile so we can backup files and
                // later delete the profile.
                EnsureAdminFileAccess(szProfilePath);

                // Backup the user's files, if requested
                if (varBackupPath.vt == VT_BSTR && varBackupPath.bstrVal && *varBackupPath.bstrVal)
                {
                    WCHAR szPath[MAX_PATH];

                    _BuildBackupPath(pLogonUser, varLoginName.bstrVal, varBackupPath.bstrVal, szPath);

                    ASSERT(varStringSid.vt == VT_BSTR);
                    hr = BackupUserData(varStringSid.bstrVal, szProfilePath, szPath);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            nasRet = NetUserDel(NULL, varLoginName.bstrVal);

            // NERR_UserNotFound can happen if the account was deleted via
            // some other mechanism (e.g. lusrmgr.msc). However, we know
            // that the account existed recently, so try to clean up the
            // picture, profile, etc. and remove the user from our DPA.

            if (nasRet == NERR_Success || nasRet == NERR_UserNotFound)
            {
                TCHAR szHintKey[MAX_PATH];
                int iUserIndex;

                // Delete the user's picture if it exists
                SHSetUserPicturePath(varLoginName.bstrVal, 0, NULL);

                // Delete the user's profile
                if (SUCCEEDED(hrSid))
                {
                    ASSERT(varStringSid.vt == VT_BSTR);
                    DeleteProfile(varStringSid.bstrVal, NULL, NULL);
                }

                // Delete the user's hint
                PathCombine(szHintKey, c_szRegRoot, varLoginName.bstrVal);
                SHDeleteKey(HKEY_LOCAL_MACHINE, szHintKey);

                // Indicate success
                *pbSuccess = VARIANT_TRUE;
                hr = S_OK;

                // Patch up the list of users
                iUserIndex = DPA_GetPtrIndex(_hdpaUsers, pLogonUser);
                if ( iUserIndex != -1 )
                {
                    // Release ref held by DPA and remove from DPA
                    pLogonUser->Release();
                    DPA_DeletePtr(_hdpaUsers, iUserIndex);
                }
                else
                {
                    // Invalidate the cached user infomation forcing
                    // a reenumeration the next time a client uses
                    // this object
                    _DestroyHDPAUsers();
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(nasRet);
            }
        }

        pLogonUser->Release();

        SysFreeString(varLoginName.bstrVal);
        SysFreeString(varStringSid.bstrVal);
    }

    return hr;
}


HRESULT CLogonEnumUsers::_GetUserByName(BSTR bstrLoginName, ILogonUser** ppLogonUserInfo)
{
    HRESULT    hr;
    INT        cUsers, cRet;
    ILogonUser *pLogonUser;
    VARIANT    varLoginName;
    int        i;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users.
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    cUsers = DPA_GetPtrCount(_hdpaUsers);
    hr = E_INVALIDARG;
    for (i = 0; i < cUsers; i++)
    {
        pLogonUser = (ILogonUser*)DPA_FastGetPtr(_hdpaUsers, i);
        pLogonUser->get_setting(L"LoginName", &varLoginName);

        ASSERT(varLoginName.vt == VT_BSTR);
        cRet = StrCmpW(bstrLoginName, varLoginName.bstrVal);
        SysFreeString(varLoginName.bstrVal);

        if ( cRet == 0 )
        {
            *ppLogonUserInfo = pLogonUser;
            (*ppLogonUserInfo)->AddRef();
            hr = S_OK;
            break;
        }

    }

    return hr;
}


HRESULT CLogonEnumUsers::_GetUserByIndex(LONG lUserID, ILogonUser** ppLogonUserInfo)
{
    HRESULT hr;
    int cUsers;

    *ppLogonUserInfo = NULL;

    if (!_hdpaUsers)
    {
        // need to go enumerate all of the users.
        hr = _EnumerateUsers();
        if (FAILED(hr))
        {
            TraceMsg(TF_WARNING, "CLogonEnumUsers::get_length: failed to create _hdpaUsers!");
            return hr;
        }
    }

    cUsers = DPA_GetPtrCount(_hdpaUsers);

    if ((cUsers > 0) && (lUserID >= 0) && (lUserID < cUsers))
    {
        *ppLogonUserInfo = (ILogonUser*)DPA_FastGetPtr(_hdpaUsers, lUserID);
        (*ppLogonUserInfo)->AddRef();
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


STDAPI_(int) ReleaseLogonUserCallback(LPVOID pData1, LPVOID pData2)
{
    UNREFERENCED_PARAMETER(pData2);

    ILogonUser* pUser = (ILogonUser*)pData1;
    pUser->Release();

    return 1;
}


void CLogonEnumUsers::_DestroyHDPAUsers()
{
    HDPA hdpaToFree = (HDPA)InterlockedExchangePointer(reinterpret_cast<void**>(&_hdpaUsers), NULL);

    if (hdpaToFree)
    {
        DPA_DestroyCallback(hdpaToFree, ReleaseLogonUserCallback, 0);
    }
}

// creates the _hdpaUsers for each user on the system 
HRESULT CLogonEnumUsers::_EnumerateUsers()
{
    HRESULT hr = S_FALSE;
    NET_API_STATUS nasRet;
    GINA_USER_INFORMATION* pgui = NULL;
    DWORD dwEntriesRead = 0;

    nasRet = ShellGetUserList(FALSE,                               // don't remove Guest
                              &dwEntriesRead,
                              (LPVOID*)&pgui);
    if ((nasRet == NERR_Success) || (nasRet == ERROR_MORE_DATA))
    {
        if (_hdpaUsers)
        {
            // we have an old data in the dpa and we should dump it and start over
            _DestroyHDPAUsers();
        }

        // create a dpa with spaces for all of the users
        _hdpaUsers = DPA_Create(dwEntriesRead);

        if (_hdpaUsers)
        {
            if (dwEntriesRead != 0)
            {
                GINA_USER_INFORMATION* pguiCurrent;
                UINT uEntry;

                // cycle through and add each user to the hdpa
                for (uEntry = 0, pguiCurrent = pgui; uEntry < dwEntriesRead; uEntry++, pguiCurrent++)
                {
                    CLogonUser* pUser;

                    if (pguiCurrent->dwFlags & UF_ACCOUNTDISABLE)
                    {
                        // skip users whos account is disabled
                        continue;
                    }

                    if (SUCCEEDED(CLogonUser::Create(pguiCurrent->pszName, pguiCurrent->pszFullName, pguiCurrent->pszDomain, IID_ILogonUser, (void**)&pUser)))
                    {
                        ASSERT(pUser);

                        if (DPA_AppendPtr(_hdpaUsers, pUser) != -1)
                        {
                            // success! we added this user to the hdpa
                            hr = S_OK;
                        }
                        else
                        {
                            TraceMsg(TF_WARNING, "CLogonEnumUsers::_EnumerateUsers: failed to add new user to the DPA!");
                            pUser->Release();
                        }
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (pgui != NULL)
        {
            LocalFree(pgui);
        }
    }
    else
    {
        TraceMsg(TF_WARNING, "CLogonEnumUsers::_EnumerateUsers: NetQueryDisplayInformation failed!!");
        hr = E_FAIL;
    }

    return hr;
}


CLogonEnumUsers::CLogonEnumUsers() : _cRef(1), CIDispatchHelper(&IID_ILogonEnumUsers, &LIBID_SHGINALib)
{
    DllAddRef();
}


CLogonEnumUsers::~CLogonEnumUsers()
{
    ASSERT(_cRef == 0);
    _DestroyHDPAUsers();
    DllRelease();
}


STDAPI CLogonEnumUsers_Create(REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLogonEnumUsers* pEnumUsers = new CLogonEnumUsers;

    if (pEnumUsers)
    {
        hr = pEnumUsers->QueryInterface(riid, ppv);
        pEnumUsers->Release();
    }

    return hr;
}

DWORD LoadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if ( NT_SUCCESS(status) )
    {
        dwErr = RegLoadKey(hKey, pszSubKey, pszHive);

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

DWORD UnloadHive(HKEY hKey, LPCTSTR pszSubKey)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if ( NT_SUCCESS(status) )
    {
        dwErr = RegUnLoadKey(hKey, pszSubKey);

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

void DeleteFilesInTree(LPCTSTR pszDir, LPCTSTR pszFilter)
{
    TCHAR szPath[MAX_PATH];
    HANDLE hFind;
    WIN32_FIND_DATA fd;

    // This is best effort only. All errors are ignored
    // and no error or success code is returned.

    // Look for files matching the filter and delete them
    PathCombine(szPath, pszDir, pszFilter);
    hFind = FindFirstFileEx(szPath, FindExInfoStandard, &fd, FindExSearchNameMatch, NULL, 0);
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( !(fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
            {
                PathRemoveFileSpec(szPath);
                PathAppend(szPath, fd.cFileName);
                DeleteFile(szPath);
            }
        }
        while ( FindNextFile(hFind, &fd) );

        FindClose(hFind);
    }

    // Look for subdirectories and recurse into them
    PathCombine(szPath, pszDir, TEXT("*"));
    hFind = FindFirstFileEx(szPath, FindExInfoStandard, &fd, FindExSearchLimitToDirectories, NULL, 0);
    if ( hFind != INVALID_HANDLE_VALUE )
    {
        do
        {
            if ( PathIsDotOrDotDot(fd.cFileName) )
                continue;

            // FindExSearchLimitToDirectories is only an advisory flag,
            // so need to check for FILE_ATTRIBUTE_DIRECTORY here.
            if ( fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                PathRemoveFileSpec(szPath);
                PathAppend(szPath, fd.cFileName);
                DeleteFilesInTree(szPath, pszFilter);

                // Expect this to fail if the dir is non-empty
                RemoveDirectory(szPath);
            }
        }
        while ( FindNextFile(hFind, &fd) );

        FindClose(hFind);
    }
}

BOOL
_PathIsEqualOrSubFolder(
    LPTSTR pszParent,
    LPCTSTR pszSubFolder
    )
{
    TCHAR szCommon[MAX_PATH];

    //  PathCommonPrefix() always removes the slash on common
    return (pszParent[0] && PathRemoveBackslash(pszParent)
            && PathCommonPrefix(pszParent, pszSubFolder, szCommon)
            && lstrcmpi(pszParent, szCommon) == 0);
}

HRESULT BackupUserData(LPCTSTR pszSid, LPTSTR pszProfilePath, LPCTSTR pszDestPath)
{
    DWORD dwErr;
    TCHAR szHive[MAX_PATH];

    // We will copy these special folders
    const LPCTSTR aValueNames[] = 
    {
        TEXT("Desktop"),
        TEXT("Personal"),
        TEXT("My Pictures") // must come after Personal
    };

    if ( pszSid == NULL || *pszSid == TEXT('\0') ||
         pszProfilePath == NULL || *pszProfilePath == TEXT('\0') ||
         pszDestPath == NULL || *pszDestPath == TEXT('\0') )
    {
        return E_INVALIDARG;
    }

    // Before we do anything else, make sure the destination directory
    // exists. Create this even if we don't copy any files below, so the
    // user sees that something happened.
    dwErr = SHCreateDirectoryEx(NULL, pszDestPath, NULL);

    if ( dwErr == ERROR_FILE_EXISTS || dwErr == ERROR_ALREADY_EXISTS )
        dwErr = ERROR_SUCCESS;

    if ( dwErr != ERROR_SUCCESS )
        return dwErr;

    // Load the user's hive
    PathCombine(szHive, pszProfilePath, TEXT("ntuser.dat"));
    dwErr = LoadHive(HKEY_USERS, pszSid, szHive);

    if ( dwErr == ERROR_SUCCESS )
    {
        HKEY hkShellFolders;
        TCHAR szKey[MAX_PATH];

        // Open the Shell Folders key for the user. We use "Shell Folders"
        // here rather than "User Shell Folders" so we don't have to expand
        // ENV strings for the user (we don't have a token).
        //
        // The only way Shell Folders can be out of date is if someone
        // changed User Shell Folders since the last time the target user
        // logged on, and didn't subsequently call SHGetFolderPath. This
        // is a very small risk, but it's possible.
        //
        // If we encounter problems here, then we will need to build a
        // pseudo-environment block for the user containing USERNAME and
        // USERPROFILE (at least) so we can switch to User Shell Folders
        // and do the ENV substitution.

        lstrcpy(szKey, pszSid);
        lstrcat(szKey, TEXT("\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"));

        dwErr = RegOpenKeyEx(HKEY_USERS,
                             szKey,
                             0,
                             KEY_QUERY_VALUE,
                             &hkShellFolders);

        if ( dwErr == ERROR_SUCCESS )
        {
            LPTSTR szFrom;
            LPTSTR szTo;

            // Allocate 2 buffers for double-NULL terminated lists of paths.
            // Note that the buffers have 1 extra char (compared to cchFrom
            // and cchTo below) and are zero-inited. This extra char ensures
            // that the list is double-NULL terminated.

            szFrom = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH * ARRAYSIZE(aValueNames) + 1) * sizeof(TCHAR));
            szTo = (LPTSTR)LocalAlloc(LPTR, (MAX_PATH * ARRAYSIZE(aValueNames) + 1) * sizeof(TCHAR));

            if ( szFrom != NULL && szTo != NULL )
            {
                int i;

                // Keep track of the current position in the list buffers
                LPTSTR pszFrom = szFrom;
                LPTSTR pszTo = szTo;

                // Keep track of the remaining space available
                ULONG cchFrom = MAX_PATH * ARRAYSIZE(aValueNames);
                ULONG cchTo = MAX_PATH * ARRAYSIZE(aValueNames);

                // Get each source directory from the registry, build
                // a corresponding destination path, and add the paths
                // to the lists for SHFileOperation.

                for (i = 0; i < ARRAYSIZE(aValueNames); i++)
                {
                    // Copy the source path directly into the list
                    DWORD dwSize = cchFrom * sizeof(TCHAR);
                    dwErr = RegQueryValueEx(hkShellFolders,
                                            aValueNames[i],
                                            NULL,
                                            NULL,
                                            (LPBYTE)pszFrom,
                                            &dwSize);

                    if ( dwErr == ERROR_SUCCESS )
                    {
                        // Build a destination path with the same
                        // leaf name as the source.
                        PathRemoveBackslash(pszFrom);
                        lstrcpyn(pszTo, pszDestPath, cchTo);
                        LPCTSTR pszDir = PathFindFileName(pszFrom);
                        if ( PathIsFileSpec(pszDir) )
                        {
                            PathAppend(pszTo, pszDir);
                        }

                        // Make sure we have access to the directory before
                        // we try to move it. We've already done this to the
                        // profile folder, so only do it here if the dir is
                        // outside the profile.
                        if (!_PathIsEqualOrSubFolder(pszProfilePath, pszFrom))
                            EnsureAdminFileAccess(pszFrom);

                        // Move past the new list entries in the buffers
                        ULONG cch = lstrlen(pszFrom) + 1; // include NULL
                        cchFrom -= cch;
                        pszFrom += cch;

                        cch = lstrlen(pszTo) + 1;
                        cchTo -= cch;
                        pszTo += cch;
                    }
                    else if ( dwErr != ERROR_FILE_NOT_FOUND )
                    {
                        break;
                    }
                }

                // Did we find anything?
                if ( *szFrom != TEXT('\0') && *szTo != TEXT('\0') )
                {
                    SHFILEOPSTRUCT fo;

                    fo.hwnd = NULL;
                    fo.wFunc = FO_MOVE;
                    fo.pFrom = szFrom;
                    fo.pTo = szTo;
                    fo.fFlags = FOF_MULTIDESTFILES | FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR |
                        FOF_NOCOPYSECURITYATTRIBS | FOF_NOERRORUI | FOF_RENAMEONCOLLISION;

                    // Move everything in one shot
                    dwErr = SHFileOperation(&fo);

                    // We get ERROR_CANCELLED when My Pictures is contained
                    // within My Documents, which is the normal case. In this
                    // case My Pictures is moved along with My Documents and
                    // doesn't exist any more in the source location when the
                    // copy engine gets around to moving My Pictures.
                    //
                    // We have to continue to specify My Pictures separately
                    // to account for any cases where it is not contained
                    // in My Documents, even though that's relatively rare.
                    //
                    // Note that putting My Pictures ahead of Personal in
                    // aValueNames above would avoid the error, but My Pictures
                    // would no longer be under My Documents after the move.

                    if ( dwErr == ERROR_CANCELLED )
                        dwErr = ERROR_SUCCESS;

                    if ( dwErr == ERROR_SUCCESS )
                    {
                        // Now go back and delete stuff we didn't really
                        // want (i.e. shortcut files)
                        DeleteFilesInTree(pszDestPath, TEXT("*.lnk"));
                    }
                }
            }
            else
            {
                dwErr = ERROR_OUTOFMEMORY;
            }

            if ( szFrom != NULL )
                LocalFree(szFrom);

            if ( szTo != NULL )
                LocalFree(szTo);

            // Close the Shell Folders key
            RegCloseKey(hkShellFolders);
        }

        // Unload the hive
        UnloadHive(HKEY_USERS, pszSid);
    }

    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        // Something was missing, possibly the entire profile (e.g. if the
        // user had never logged on), or possibly just one of the Shell Folders
        // reg values. It just means there was less work to do.
        dwErr = ERROR_SUCCESS;
    }

    return HRESULT_FROM_WIN32(dwErr);
}


BOOL _SetFileSecurityUsingNTName(LPWSTR pObjectName,
                                 PSECURITY_DESCRIPTOR pSD,
                                 PBOOL pbIsFile)
{
    NTSTATUS Status;
    UNICODE_STRING usFileName;
    OBJECT_ATTRIBUTES Obja;
    IO_STATUS_BLOCK IoStatusBlock;
    HANDLE hFile = NULL;

    RtlInitUnicodeString(&usFileName, pObjectName);

    InitializeObjectAttributes(
        &Obja,
        &usFileName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                 &hFile,
                 WRITE_DAC,
                 &Obja,
                 &IoStatusBlock,
                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                 FILE_OPEN_REPARSE_POINT
                 );

    if ( Status == STATUS_INVALID_PARAMETER ) {
        Status = NtOpenFile(
                     &hFile,
                     WRITE_DAC,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     );
    }


    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    if (!SetKernelObjectSecurity(
         hFile,
         DACL_SECURITY_INFORMATION,
         pSD
         ))
    {
        // We successfully opened for WRITE_DAC access, so this shouldn't fail
        ASSERT(FALSE);
        NtClose(hFile);
        return FALSE;
    }

    NtClose(hFile);

    //
    // That worked. Now open the file again and read attributes, to see
    // if it's a file or directory.  Default to File if this fails.
    // See comments in _TreeResetCallback below.
    //
    *pbIsFile = TRUE;

    if (NT_SUCCESS(Status = NtOpenFile(
                     &hFile,
                     FILE_GENERIC_READ,
                     &Obja,
                     &IoStatusBlock,
                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                     0
                     )))
    {
       //
       // Query the attributes for the file/dir.
       // In case of error, assume that it is a dir.
       //
       FILE_BASIC_INFORMATION BasicFileInfo;
       if (NT_SUCCESS(Status = NtQueryInformationFile(
               hFile,
               &IoStatusBlock,
               &BasicFileInfo,
               sizeof(BasicFileInfo),
               FileBasicInformation)))
        {
            if(BasicFileInfo.FileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                *pbIsFile = FALSE;
        }

        NtClose(hFile);
    }
    return TRUE;
}


void _TreeResetCallback(LPWSTR               pObjectName,
                        DWORD                status,
                        PPROG_INVOKE_SETTING pInvokeSetting,
                        PVOID                pContext,
                        BOOL                 bSecuritySet)
{
    BOOL bIsFile = TRUE;

    // Default is "continue"
    *pInvokeSetting = ProgressInvokeEveryObject;

    // Stamp the permissions on this object
    _SetFileSecurityUsingNTName(pObjectName, (PSECURITY_DESCRIPTOR)pContext, &bIsFile);

    //
    // bSecuritySet = TRUE means TreeResetNamedSecurityInfo set the owner.
    //
    // status != ERROR_SUCCESS means it couldn't enumerate the child.
    //
    // If it's not a file, retry the operation (with no access initially,
    // TreeResetNamedSecurityInfo can't get attributes and tries to
    // enumerate everything as if it's a directory).
    //
    // Have to be careful to avoid infinite loops here. Basically, we assume
    // everything is a file. If we can grant ourselves access above, we get
    // good attributes and do the right thing. If not, we skip the retry.
    //
    if (bSecuritySet && status != ERROR_SUCCESS && !bIsFile)
    {
        *pInvokeSetting = ProgressRetryOperation;
    }
}


DWORD EnsureAdminFileAccess(LPTSTR pszPath)
{
    DWORD dwErr;
    PSECURITY_DESCRIPTOR pSD;

    const TCHAR c_szAdminSD[] = TEXT("O:BAG:BAD:(A;OICI;FA;;;SY)(A;OICI;FA;;;BA)");

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(c_szAdminSD, SDDL_REVISION_1, &pSD, NULL))
    {
        PSID pOwner = NULL;
        BOOL bDefault;

        CPrivilegeEnable privilege(SE_TAKE_OWNERSHIP_NAME);

        GetSecurityDescriptorOwner(pSD, &pOwner, &bDefault);

        //
        // When the current user doesn't have any access, we have to do things
        // in the correct order. For each file or directory in the tree,
        // 1. Take ownership, this gives us permission to...
        // 2. Set permissions, this gives us permission to...
        // 3. If a directory, recurse into it
        //
        // TreeResetNamedSecurityInfo doesn't quite work that way, so we use
        // it to set the owner and do the enumeration.  The callback sets
        // the permissions, and tells TreeResetNamedSecurityInfo to retry
        // the enumeration if necessary.
        //
        dwErr = TreeResetNamedSecurityInfo(pszPath,
                                           SE_FILE_OBJECT,
                                           OWNER_SECURITY_INFORMATION,
                                           pOwner,
                                           NULL,
                                           NULL,
                                           NULL,
                                           FALSE,
                                           _TreeResetCallback,
                                           ProgressInvokeEveryObject,
                                           pSD);

        LocalFree(pSD);
    }
    else
    {
        dwErr = GetLastError();
    }

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shfolder\app\app.cpp ===
// app.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

#include <windows.h>
#include <stdio.h>
#include <shlobj.h>
#include <shfolder.h>
#include <windowsx.h>
#include <resource.h>

#define chHANDLE_DLGMSG(hwnd, message, fn)                           \
   case (message): return (SetDlgMsgResult(hwnd, uMsg,               \
      HANDLE_##message((hwnd), (wParam), (lParam), (fn))))


#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#define SHAnsiToUnicode(psz, pwsz, cchwsz)  MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, cchwsz);
#define SHUnicodeToAnsi(pwsz, psz, cchsz)   WideCharToMultiByte(CP_ACP, 0, pwsz, -1, psz, cchsz, NULL, NULL);

#ifdef UNICODE

#else
#define SHTCharToUnicode(t, w, cc) SHAnsiToUnicode(t, w, cc)
#endif

#define Q(x) #x,x
#define HKCU HKEY_CURRENT_USER
#define HKLM HKEY_LOCAL_MACHINE
struct {
    CHAR *pszName;
    UINT csidl;
    HKEY hkey;
    char *pszRegValue;
} Folders[] = {
   Q(CSIDL_DESKTOP), 0,0,
   Q(CSIDL_INTERNET),0,0,
   Q(CSIDL_PROGRAMS), HKCU,"Programs",
   Q(CSIDL_CONTROLS), 0,0,
   Q(CSIDL_PRINTERS), 0,0,
   Q(CSIDL_PERSONAL), HKCU, "Personal",
   Q(CSIDL_FAVORITES), HKCU, "Favorites",
   Q(CSIDL_STARTUP), HKCU, "Startup",
   Q(CSIDL_RECENT), HKCU, "Recent",
   Q(CSIDL_SENDTO), HKCU, "SendTo", 
   Q(CSIDL_BITBUCKET),0,0,
   Q(CSIDL_STARTMENU), HKCU, "Start Menu",
   Q(CSIDL_DESKTOPDIRECTORY), HKCU, "Desktop",
   Q(CSIDL_DRIVES), 0,0,
   Q(CSIDL_NETWORK), 0,0,
   Q(CSIDL_NETHOOD), HKCU, "NetHood",
   Q(CSIDL_FONTS), HKCU, "Fonts",
   Q(CSIDL_TEMPLATES), HKCU, "Templates",
   Q(CSIDL_COMMON_STARTMENU),HKLM, "Common Start Menu",
   Q(CSIDL_COMMON_PROGRAMS), HKLM, "Common Programs",
   Q(CSIDL_COMMON_STARTUP), HKLM, "Common Startup",
   Q(CSIDL_COMMON_DESKTOPDIRECTORY), HKLM, "Common Desktop",
   Q(CSIDL_APPDATA), HKCU, "AppData",
   Q(CSIDL_PRINTHOOD), HKCU, "PrintHood",
   Q(CSIDL_LOCAL_APPDATA), HKCU, "Local AppData",
   Q(CSIDL_ALTSTARTUP), HKCU, "AltStartup",
   Q(CSIDL_COMMON_ALTSTARTUP), HKLM, "Common AltStartup",
   Q(CSIDL_COMMON_FAVORITES), HKLM, "Common Favorites",
   Q(CSIDL_INTERNET_CACHE), HKCU, "Cache",
   Q(CSIDL_COOKIES), HKCU, "Cookies",
   Q(CSIDL_HISTORY), HKCU, "History",
   Q(CSIDL_COMMON_APPDATA), HKLM, "Common AppData",
   Q(CSIDL_WINDOWS),0,0,
   Q(CSIDL_SYSTEM),0,0,
   Q(CSIDL_PROGRAM_FILES),0,0,
   Q(CSIDL_MYPICTURES),HKCU, "My Pictures",
   Q(CSIDL_PROFILE),0,0,
   Q(CSIDL_SYSTEMX86),0,0,
   Q(CSIDL_PROGRAM_FILESX86),0,0,
   Q(CSIDL_PROGRAM_FILES_COMMON),0,0,
   Q(CSIDL_PROGRAM_FILES_COMMONX86),0,0,
   Q(CSIDL_COMMON_TEMPLATES),HKLM, "Common Templates",
   Q(CSIDL_COMMON_DOCUMENTS), HKLM, "Common Documents",
   Q(CSIDL_COMMON_ADMINTOOLS), HKLM, "Common Administrative Tools",
   Q(CSIDL_ADMINTOOLS), HKCU, "Administrative Tools",
/*
*/
    "Invalid",0xff,0,0,
};

HANDLE GetCurrentUserToken()
{
    HANDLE hToken;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) ||
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        return hToken;
    return NULL;
}

const CHAR c_szUSF[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders";
const CHAR c_szSF[]  = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders";


void AddToList(HWND hwndList, UINT iItem, HRESULT hr, UINT iFolder, BOOL fUnicode, LPBYTE pzPath, BOOL fCreate)
{
    LVITEMA lva;
    LVITEMW lvw;
    CHAR sz[MAX_PATH];
    WCHAR wsz[MAX_PATH];
    
    ZeroMemory(&lva, sizeof(lva));
    ZeroMemory(&lvw, sizeof(lvw));
    lva.mask = lvw.mask = LVIF_TEXT;
    lva.iItem = lvw.iItem = iItem;

    wsprintf(sz, "%x", hr);
    lva.pszText = sz;
    lva.iSubItem = 0;
    if (iItem != SendMessageA(hwndList, LVM_INSERTITEMA, 0, (LPARAM)&lva))
        MessageBox(0, "debug",0, MB_OK);

    if (fUnicode)
    {
        lvw.pszText = (WCHAR*)pzPath;
        lvw.iSubItem = 1;
        SendMessageW(hwndList,LVM_SETITEMW,0, (LPARAM)&lvw);
        lva.pszText = "1";
        lva.iSubItem = 4;
        SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);

    } 
    else
    {
        lva.pszText = (CHAR*)pzPath;
        lva.iSubItem = 1;
        SendMessageA(hwndList,LVM_SETITEMA,0, (LPARAM)&lva);
        lva.pszText = "0";
        lva.iSubItem = 4;
        SendMessageA(hwndList,LVM_SETITEMA, 0, (LPARAM)&lva);
    }

    if (Folders[iFolder].hkey) 
    {
        HKEY hkey;
        DWORD dwType;
        DWORD dwSize;
        wsz[0] = 0;
        sz[0] = 0;
        if (ERROR_SUCCESS == RegOpenKey(Folders[iFolder].hkey, c_szUSF, &hkey))
        {
            if (fUnicode) 
            {
                WCHAR wszRegValue[MAX_PATH];
                dwSize = sizeof(sz);
                SHAnsiToUnicode( Folders[iFolder].pszRegValue, wszRegValue, MAX_PATH);
                RegQueryValueExW(hkey, wszRegValue, 0, &dwType, (LPBYTE) wsz, &dwSize);
                lvw.iSubItem = 2;
                lvw.pszText = wsz;
                SendMessageW(hwndList, LVM_SETITEMW, 0, (LPARAM)&lvw);
            } 
            else
            {
                DWORD dwSize = sizeof(sz);
                RegQueryValueExA(hkey, Folders[iFolder].pszRegValue, 0, &dwType, (LPBYTE)sz,&dwSize );
                lva.iSubItem = 2;
                lva.pszText = sz;
                SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);
            }


            RegCloseKey(hkey);
        }
        if (ERROR_SUCCESS == RegOpenKey(Folders[iFolder].hkey, c_szSF, &hkey))
        {
            if (fUnicode) 
            {
                WCHAR wszRegValue[MAX_PATH];
                dwSize = sizeof(wsz);
                SHAnsiToUnicode( Folders[iFolder].pszRegValue, wszRegValue, MAX_PATH);
                RegQueryValueExW(hkey, wszRegValue, 0, &dwType, (LPBYTE) wsz, &dwSize);
                lvw.iSubItem = 3;
                lvw.pszText = wsz;
                SendMessageW(hwndList, LVM_SETITEMW, 0, (LPARAM)&lvw);
            } 
            else
            {
                DWORD dwSize = sizeof(sz);
                RegQueryValueExA(hkey, Folders[iFolder].pszRegValue, 0, &dwType, (LPBYTE)sz, &dwSize);
                lva.iSubItem = 3;
                lva.pszText = sz;
                SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);
            }


            RegCloseKey(hkey);
        }


    }
    else
    {
        lva.pszText = "N/A";
        lva.iSubItem = 2;
        SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);
        lva.iSubItem = 3;
        SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);
    }

    lva.iSubItem = 5;
    if (fCreate)
        lva.pszText = "1";
    else
        lva.pszText = "0";
    SendMessageA(hwndList, LVM_SETITEMA, 0, (LPARAM)&lva);

}

void CheckFolders( HWND hList)
{
    int i;
    int j;
    static HINSTANCE hmod;
    PFNSHGETFOLDERPATHA GetFolderPathA;
    PFNSHGETFOLDERPATHW GetFolderPathW;
    CHAR szDll[] = "shfolder.dll";
    hmod = LoadLibrary(szDll);
    if( !hmod) {
        MessageBoxA(0,"couldn't find your dll %s\n", 0, MB_OK);
        ExitProcess(1);
    }
    GetFolderPathA = (PFNSHGETFOLDERPATHA) GetProcAddress( hmod, "SHGetFolderPathA");
    GetFolderPathW = (PFNSHGETFOLDERPATHW) GetProcAddress( hmod, "SHGetFolderPathW");
    // SendMessageA(hList, LB_RESETCONTENT,0,0);
    SendMessage(hList, LVM_DELETEALLITEMS,0,0);
    
    

    for ( i=0,j=0; i< ARRAYSIZE(Folders); i++)
    {
        CHAR szPath[MAX_PATH];
        WCHAR wszPath[MAX_PATH];
        HRESULT hr;
        CHAR szOut[MAX_PATH];
        WCHAR wszOut[MAX_PATH];
        WCHAR wszConv[MAX_PATH];
        LPBYTE pzPath;
        int k;
        
        for (k=0; k<6; k++) 
        {
            BOOL fCreate = (k == 3) || (k == 2);
            if (k%2) 
            {
                hr = GetFolderPathW(NULL, Folders[i].csidl |fCreate, NULL,0, wszPath);
                pzPath = (LPBYTE) wszPath;
            }    
            else
            {
                hr = GetFolderPathA(NULL, Folders[i].csidl | fCreate, NULL, 0, szPath);
                pzPath = (LPBYTE) szPath;
            }
            
            AddToList(hList, j++ ,hr, i, k%2, pzPath, fCreate);

        }
    }
}

BOOL Dlg_OnInitDialog (HWND hwnd, HWND hwndFocus,
   LPARAM lParam) 
{

   RECT rc;
   LVCOLUMN lvc;
   HWND hwndList = GetDlgItem(hwnd, IDC_LIST1);

   ZeroMemory(&lvc, sizeof(lvc));
   lvc.mask = LVCF_FMT | LVCF_ORDER |LVCF_SUBITEM | LVCF_TEXT;
   lvc.fmt = LVCFMT_LEFT;
   
   lvc.pszText = "HRESULT";
   lvc.iOrder = 0;
   lvc.iSubItem = 0;
   ListView_InsertColumn(hwndList, 0, &lvc);
 

   lvc.pszText = "Value";
   lvc.iOrder = 1;
   lvc.iSubItem = 1;
   ListView_InsertColumn(hwndList, 1, &lvc);

   lvc.pszText ="USF value";
   lvc.iOrder =2 ;
   lvc.iSubItem = 2;
   ListView_InsertColumn(hwndList, 2, &lvc);

   lvc.pszText = "SF value";
   lvc.iOrder = 3;
   lvc.iSubItem = 3;
   ListView_InsertColumn(hwndList, 3, &lvc);

   lvc.pszText = "Unicode";
   lvc.iOrder = 4;
   lvc.iSubItem = 4;
   ListView_InsertColumn(hwndList, 4, &lvc);
   
   lvc.pszText = "Create";
   lvc.iOrder = 5;
   lvc.iSubItem = 5;
   ListView_InsertColumn(hwndList, 5, &lvc); 

    
   // Associate an icon with the dialog box.
   CheckFolders(hwndList);

   GetClientRect(hwnd, &rc);
   SetWindowPos(GetDlgItem(hwnd, IDC_LIST1), NULL,
       0, 0, rc.right, rc.bottom, SWP_NOZORDER);
   return(TRUE);
}

void Dlg_OnSize (HWND hwnd, UINT state, int cx, int cy) {
//   SetWindowPos(GetDlgItem(hwnd, IDC_LIST1), NULL, 0, 0,
      // cx, cy, SWP_NOZORDER);
}

void Dlg_OnCommand (HWND hwnd, int id, HWND hwndCtl,
   UINT codeNotify) 
{

   switch (id) 
   {
      case IDCANCEL:
         EndDialog(hwnd, id);
         break;

      case IDOK:
         // Call the recursive routine to walk the tree.
         CheckFolders(GetDlgItem(hwnd, IDC_LIST1));
         break;
   }
}



BOOL CALLBACK Dlg_Proc (HWND hwnd, UINT uMsg,
   WPARAM wParam, LPARAM lParam) 
{

   switch (uMsg) {
      chHANDLE_DLGMSG(hwnd, WM_INITDIALOG,  Dlg_OnInitDialog);
      chHANDLE_DLGMSG(hwnd, WM_SIZE,        Dlg_OnSize);
      chHANDLE_DLGMSG(hwnd, WM_COMMAND,     Dlg_OnCommand);
   }
   return(FALSE);
}

int  WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, 
        LPSTR pszArgs, INT command)
{
#if 0
    if (argc > 1)
        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, argv[1], NULL);

    Sleep(6000);
#endif
    CoInitialize(0);

    DialogBox( hInstance, MAKEINTRESOURCE(IDD_DIALOG1), 0, Dlg_Proc);
    GetLastError();

#if 0
    SHFILEINFO fi;
    SHGetFileInfo(TEXT("\\\\chrisg06\\public"), FILE_ATTRIBUTE_DIRECTORY, &fi, sizeof(fi), SHGFI_USEFILEATTRIBUTES | SHGFI_DISPLAYNAME | SHGFI_ICON);

    {
        TCHAR szPath[MAX_PATH];

        SHGetFolderPath(NULL, CSIDL_LOCAL_APPDATA, GetCurrentUserToken(), 0, szPath);

        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szPath);
        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES_COMMON, NULL, 0, szPath);

        SHGetFolderPath(NULL, CSIDL_COMMON_DOCUMENTS | CSIDL_FLAG_CREATE, NULL, 0, szPath);
        SHGetFolderPath(NULL, CSIDL_COMMON_TEMPLATES | CSIDL_FLAG_CREATE, NULL, 0, szPath);

        SHGetFolderPath(NULL, CSIDL_RECENT, NULL, 0, szPath);
        SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, 0, szPath);
        SHGetFolderPath(NULL, CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, NULL, 0, szPath);
        SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, 0, szPath);


        // SHGetFolderPath(NULL, CSIDL_PERSONAL, NULL, 0, szPath);
        // SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, szPath);
    }

#endif
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\clocalmachine.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CLocalMachine.cpp
//
//  Contents:   implementation of CLocalMachine
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "UserOM.h"
#include "LogonIPC.h"
#include "CInteractiveLogon.h"
#include "WinUser.h"
#include "trayp.h"      // for TM_REFRESH
#include <lmaccess.h>   // for NetUserModalsGet
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success
#include <ntlsa.h>
#include <cfgmgr32.h>
//
// IUnknown Interface
//

ULONG CLocalMachine::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLocalMachine::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLocalMachine::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLocalMachine, IDispatch),
        QITABENT(CLocalMachine, ILocalMachine),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLocalMachine::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLocalMachine::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLocalMachine::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLocalMachine::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


//
// ILocalMachine Interface
//



STDMETHODIMP CLocalMachine::get_MachineName(VARIANT* pvar)
{
    HRESULT hr;
    DWORD cch;
    WCHAR szMachineName[MAX_COMPUTERNAME_LENGTH+1];

    if (pvar)
    {
        pvar->vt = VT_BSTR;
        cch = MAX_COMPUTERNAME_LENGTH+1;
        if (GetComputerNameW(szMachineName, &cch))
        {
            pvar->bstrVal = SysAllocString(szMachineName);
        }
        else
        {
            pvar->bstrVal = SysAllocString(TEXT(""));
        }
        hr = S_OK;
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


DWORD BuildAccountSidFromRid(LPCWSTR pszServer, DWORD dwRid, PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;
    PUSER_MODALS_INFO_2 umi2;
    NET_API_STATUS nasRet;

    // Get the account domain Sid on the target machine
    nasRet = NetUserModalsGet(pszServer, 2, (LPBYTE*)&umi2);

    if ( nasRet == NERR_Success )
    {
        UCHAR cSubAuthorities;
        PSID pSid;

        cSubAuthorities = *GetSidSubAuthorityCount(umi2->usrmod2_domain_id);

        // Allocate storage for new the Sid (domain Sid + account Rid)
        pSid = (PSID)LocalAlloc(LPTR, GetSidLengthRequired((UCHAR)(cSubAuthorities+1)));

        if ( pSid != NULL )
        {
            if ( InitializeSid(pSid,
                               GetSidIdentifierAuthority(umi2->usrmod2_domain_id),
                               (BYTE)(cSubAuthorities+1)) )
            {
                // Copy existing subauthorities from domain Sid to new Sid
                for (UINT i = 0; i < cSubAuthorities; i++)
                {
                    *GetSidSubAuthority(pSid, i) = *GetSidSubAuthority(umi2->usrmod2_domain_id, i);
                }

                // Append Rid to new Sid
                *GetSidSubAuthority(pSid, cSubAuthorities) = dwRid;

                *ppSid = pSid;
            }
            else
            {
                dwErr = GetLastError();
                LocalFree(pSid);
            }
        }
        else
        {
            dwErr = GetLastError();
        }

        NetApiBufferFree(umi2);
    }
    else
    {
        dwErr = nasRet;
    }

    return dwErr;
}

BYTE s_rgbGuestSid[sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG)] = {0};

DWORD GetGuestSid(PSID* ppSid)
{
    DWORD dwErr = ERROR_SUCCESS;

    if (0 == *GetSidSubAuthorityCount((PSID)s_rgbGuestSid))
    {
        PSID pSid = NULL;
        dwErr = BuildAccountSidFromRid(NULL, DOMAIN_USER_RID_GUEST, &pSid);

        if (ERROR_SUCCESS == dwErr)
        {
            CopySid(sizeof(s_rgbGuestSid), (PSID)s_rgbGuestSid, pSid);
            LocalFree(pSid);
        }
    }

    // There is no need to free the returned PSID (static buffer)
    *ppSid = (PSID)s_rgbGuestSid;

    return dwErr;
}

WCHAR s_szGuest[UNLEN + sizeof('\0')]     =   L"";

LPCWSTR GetGuestAccountName(void)
{
    if (s_szGuest[0] == L'\0')
    {
        DWORD           dwGuestSize, dwDomainSize;
        WCHAR           szDomain[DNLEN + sizeof('\0')];
        PSID            pSID;
        SID_NAME_USE    eUse;

        dwGuestSize = ARRAYSIZE(s_szGuest);
        dwDomainSize = ARRAYSIZE(szDomain);
        if ((ERROR_SUCCESS != GetGuestSid(&pSID)) ||
            !LookupAccountSidW(NULL,
                               pSID,
                               s_szGuest,
                               &dwGuestSize,
                               szDomain,
                               &dwDomainSize,
                               &eUse))
        {
            // Huh?  No Guest account on this machine. Try English.
            lstrcpyW(s_szGuest, L"Guest");

            // Try to go the other way and lookup the SID.
            // If this fails, we're SOL.
            *GetSidSubAuthorityCount((PSID)s_rgbGuestSid) = 0;
            dwGuestSize = sizeof(s_rgbGuestSid);
            dwDomainSize = ARRAYSIZE(szDomain);
            LookupAccountNameW(NULL,
                               s_szGuest,
                               (PSID)s_rgbGuestSid,
                               &dwGuestSize,
                               szDomain,
                               &dwDomainSize,
                               &eUse);
        }
    }
    return(s_szGuest);
}

STDMETHODIMP CLocalMachine::get_isGuestEnabled(ILM_GUEST_FLAGS flags, VARIANT_BOOL* pbEnabled)
{
    HRESULT         hr = S_OK;
    DWORD           dwErr;
    BOOL            bEnabled = FALSE;
    USER_INFO_1     *pusri1 = NULL;
    DWORD           dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));

    if (NULL == pbEnabled)
        return E_POINTER;

    //  First check to see if the guest account is truly enabled

    dwErr = NetUserGetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE*)&pusri1);
    if ((ERROR_SUCCESS == dwErr) && ((pusri1->usri1_flags & UF_ACCOUNTDISABLE) == 0))
    {
        // Guest is enabled
        bEnabled = TRUE;

        // Do they want to check the LSA logon rights?
        if (0 != dwFlags)
        {
            BOOL bDenyInteractiveLogon = FALSE;
            BOOL bDenyNetworkLogon = FALSE;
            LSA_HANDLE hLsa;
            LSA_OBJECT_ATTRIBUTES oa = {0};

            oa.Length = sizeof(oa);
            dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_LOOKUP_NAMES, &hLsa));

            if (ERROR_SUCCESS == dwErr)
            {
                PSID pSid;

                dwErr = GetGuestSid(&pSid);
                if (ERROR_SUCCESS == dwErr)
                {
                    PLSA_UNICODE_STRING pAccountRights;
                    ULONG cRights;

                    // Get the list of LSA rights assigned to the Guest account
                    //
                    // Note that SE_INTERACTIVE_LOGON_NAME is often inherited via
                    // group membership, so its absence doesn't mean much. We could
                    // bend over backwards and check group membership and such, but
                    // Guest normally gets SE_INTERACTIVE_LOGON_NAME one way or
                    // another, so we only check for SE_DENY_INTERACTIVE_LOGON_NAME
                    // here.

                    dwErr = LsaNtStatusToWinError(LsaEnumerateAccountRights(hLsa, pSid, &pAccountRights, &cRights));
                    if (ERROR_SUCCESS == dwErr)
                    {
                        PLSA_UNICODE_STRING pRight;
                        for (pRight = pAccountRights; cRights > 0 && 0 != dwFlags; pRight++, cRights--)
                        {
                            if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON) &&
                                CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                                             NORM_IGNORECASE,
                                                             SE_DENY_INTERACTIVE_LOGON_NAME,
                                                             -1,
                                                             pRight->Buffer,
                                                             pRight->Length/2))
                            {
                                bDenyInteractiveLogon = TRUE;
                                dwFlags &= ~ILM_GUEST_INTERACTIVE_LOGON;
                            }
                            else if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON) &&
                                CSTR_EQUAL == CompareStringW(LOCALE_SYSTEM_DEFAULT,
                                                             NORM_IGNORECASE,
                                                             SE_DENY_NETWORK_LOGON_NAME,
                                                             -1,
                                                             pRight->Buffer,
                                                             pRight->Length/2))
                            {
                                bDenyNetworkLogon = TRUE;
                                dwFlags &= ~ILM_GUEST_NETWORK_LOGON;
                            }
                        }
                        LsaFreeMemory(pAccountRights);
                    }
                    else if (ERROR_FILE_NOT_FOUND == dwErr)
                    {
                        // Guest isn't in LSA's database, so we know it can't
                        // have either of the deny logon rights.
                        dwErr = ERROR_SUCCESS;
                    }
                }
                LsaClose(hLsa);
            }

            if (bDenyInteractiveLogon || bDenyNetworkLogon)
                bEnabled = FALSE;
        }
    }

    if (NULL != pusri1)
    {
        (NET_API_STATUS)NetApiBufferFree(pusri1);
    }

    hr = HRESULT_FROM_WIN32(dwErr);

    *pbEnabled = bEnabled ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}

STDMETHODIMP CLocalMachine::EnableGuest(ILM_GUEST_FLAGS flags)
{
    DWORD           dwErr;
    USER_INFO_1     *pusri1;
    DWORD dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));

    //  First truly enable the guest account. Do this ALL the time.

    dwErr = NetUserGetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE*)&pusri1);
    if (ERROR_SUCCESS == dwErr)
    {
        pusri1->usri1_flags &= ~UF_ACCOUNTDISABLE;
        dwErr = NetUserSetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE)pusri1, NULL);
        if (ERROR_SUCCESS == dwErr && 0 != dwFlags)
        {
            LSA_HANDLE hLsa;
            LSA_OBJECT_ATTRIBUTES oa = {0};

            oa.Length = sizeof(oa);
            dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_LOOKUP_NAMES, &hLsa));

            if (ERROR_SUCCESS == dwErr)
            {
                PSID pSid;

                dwErr = GetGuestSid(&pSid);
                if (ERROR_SUCCESS == dwErr)
                {
                    if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON))
                    {
                        DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_INTERACTIVE_LOGON_NAME);
                        NTSTATUS status = LsaRemoveAccountRights(hLsa, pSid, FALSE, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                        dwErr = LsaNtStatusToWinError(status);
                    }
                    if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON))
                    {
                        DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_NETWORK_LOGON_NAME);
                        NTSTATUS status = LsaRemoveAccountRights(hLsa, pSid, FALSE, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                        if (ERROR_SUCCESS == dwErr)
                            dwErr = LsaNtStatusToWinError(status);
                    }

                    if (ERROR_FILE_NOT_FOUND == dwErr)
                    {
                        //
                        // NTRAID#NTBUG9-396428-2001/05/16-jeffreys
                        //
                        // This means Guest isn't in LSA's database, so we know
                        // it can't have either of the deny logon rights. Since
                        // we were trying to remove one or both rights, count
                        // this as success.
                        //
                        dwErr = ERROR_SUCCESS;
                    }
                }
                LsaClose(hLsa);
            }
        }
        (NET_API_STATUS)NetApiBufferFree(pusri1);
    }

    return HRESULT_FROM_WIN32(dwErr);
}

STDMETHODIMP CLocalMachine::DisableGuest(ILM_GUEST_FLAGS flags)
{
    DWORD dwErr = ERROR_SUCCESS;
    DWORD dwFlags = (DWORD)(flags & (ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON));

    if (0 != dwFlags)
    {
        LSA_HANDLE hLsa;
        LSA_OBJECT_ATTRIBUTES oa = {0};

        // Turn on DenyInteractiveLogon and/or DenyNetworkLogon, but don't
        // necessarily change the enabled state of the guest account.

        oa.Length = sizeof(oa);
        dwErr = LsaNtStatusToWinError(LsaOpenPolicy(NULL, &oa, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES, &hLsa));

        if (ERROR_SUCCESS == dwErr)
        {
            PSID pSid;

            dwErr = GetGuestSid(&pSid);
            if (ERROR_SUCCESS == dwErr)
            {
                if (0 != (dwFlags & ILM_GUEST_INTERACTIVE_LOGON))
                {
                    DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_INTERACTIVE_LOGON_NAME);
                    NTSTATUS status = LsaAddAccountRights(hLsa, pSid, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                    dwErr = LsaNtStatusToWinError(status);
                }
                if (0 != (dwFlags & ILM_GUEST_NETWORK_LOGON))
                {
                    DECLARE_CONST_UNICODE_STRING(usDenyLogon, SE_DENY_NETWORK_LOGON_NAME);
                    NTSTATUS status = LsaAddAccountRights(hLsa, pSid, (PLSA_UNICODE_STRING)&usDenyLogon, 1);
                    if (ERROR_SUCCESS == dwErr)
                        dwErr = LsaNtStatusToWinError(status);
                }
            }
            LsaClose(hLsa);
        }

        if (ERROR_SUCCESS == dwErr)
        {
            // If both  SE_DENY_INTERACTIVE_LOGON_NAME and SE_DENY_NETWORK_LOGON_NAME
            // are turned on, then we might as well disable the account altogether.
            if ((ILM_GUEST_INTERACTIVE_LOGON | ILM_GUEST_NETWORK_LOGON) == dwFlags)
            {
                // We just turned both on, so disable guest below
                dwFlags = 0;
            }
            else
            {
                VARIANT_BOOL bEnabled;

                if (ILM_GUEST_INTERACTIVE_LOGON == dwFlags)
                {
                    // We just turned on SE_DENY_INTERACTIVE_LOGON_NAME, check
                    // for SE_DENY_NETWORK_LOGON_NAME.
                    flags = ILM_GUEST_NETWORK_LOGON;
                }
                else if (ILM_GUEST_NETWORK_LOGON == dwFlags)
                {
                    // We just turned on SE_DENY_NETWORK_LOGON_NAME, check
                    // for SE_DENY_INTERACTIVE_LOGON_NAME.
                    flags = ILM_GUEST_INTERACTIVE_LOGON;
                }
                else
                {
                    // Getting here implies that someone defined a new flag.
                    // Setting flags to ILM_GUEST_ACCOUNT causes a benign
                    // result in all cases (we only disable guest if guest
                    // is already disabled).
                    flags = ILM_GUEST_ACCOUNT;
                }

                if (SUCCEEDED(get_isGuestEnabled(flags, &bEnabled)) && (VARIANT_FALSE == bEnabled))
                {
                    // Both are on, so disable guest below
                    dwFlags = 0;
                }
            }
        }
    }

    if (0 == dwFlags)
    {
        USER_INFO_1 *pusri1;

        //  Truly disable the guest account.

        dwErr = NetUserGetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE*)&pusri1);
        if (ERROR_SUCCESS == dwErr)
        {
            pusri1->usri1_flags |= UF_ACCOUNTDISABLE;
            dwErr = NetUserSetInfo(NULL, GetGuestAccountName(), 1, (LPBYTE)pusri1, NULL);
            (NET_API_STATUS)NetApiBufferFree(pusri1);
        }
    }

    return HRESULT_FROM_WIN32(dwErr);
}

STDMETHODIMP CLocalMachine::get_isFriendlyUIEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsFriendlyUIActive() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isFriendlyUIEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableFriendlyUI(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

STDMETHODIMP CLocalMachine::get_isMultipleUsersEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsMultipleUsersEnabled() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isMultipleUsersEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableMultipleUsers(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

STDMETHODIMP CLocalMachine::get_isRemoteConnectionsEnabled(VARIANT_BOOL* pbEnabled)

{
    *pbEnabled = ShellIsRemoteConnectionsEnabled() ? VARIANT_TRUE : VARIANT_FALSE;
    return(S_OK);
}

STDMETHODIMP CLocalMachine::put_isRemoteConnectionsEnabled(VARIANT_BOOL bEnabled)

{
    HRESULT hr;

    if (ShellEnableRemoteConnections(bEnabled != VARIANT_FALSE ? TRUE : FALSE) != FALSE)
    {
        RefreshStartMenu();
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return(hr);
}

BOOL _CanEject()
{
    BOOL fEjectAllowed = FALSE;

    if(SHRestricted(REST_NOSMEJECTPC))  //Is there a policy restriction?
        return FALSE;

    CM_Is_Dock_Station_Present(&fEjectAllowed);

    return SHTestTokenPrivilege(NULL, SE_UNDOCK_NAME) &&
           fEjectAllowed  &&
           !GetSystemMetrics(SM_REMOTESESSION);
}

STDMETHODIMP CLocalMachine::get_isUndockEnabled(VARIANT_BOOL* pbEnabled)

{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbEnabled = objLogon.TestEjectAllowed() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbEnabled = _CanEject() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    return(S_OK);
}

STDMETHODIMP CLocalMachine::get_isShutdownAllowed(VARIANT_BOOL* pbShutdownAllowed)

{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbShutdownAllowed = objLogon.TestShutdownAllowed() ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbShutdownAllowed = VARIANT_FALSE;
    }
    return(S_OK);
}

STDMETHODIMP CLocalMachine::get_isGuestAccessMode(VARIANT_BOOL* pbForceGuest)
{
    *pbForceGuest = SUCCEEDED(_IsGuestAccessMode()) ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}


STDMETHODIMP CLocalMachine::get_isOfflineFilesEnabled(VARIANT_BOOL *pbEnabled)
{
    HRESULT hr = S_OK;
    *pbEnabled = VARIANT_FALSE;
        
    HINSTANCE hInstCscdll = LoadLibrary(TEXT("cscdll.dll"));
    if (NULL != hInstCscdll)
    {
        typedef BOOL (WINAPI *LPCSCENABLED)(void);
        LPCSCENABLED pfnCscEnabled = (LPCSCENABLED)GetProcAddress(hInstCscdll, "CSCIsCSCEnabled");
        if (NULL != pfnCscEnabled)
        {
            if ((*pfnCscEnabled)())
            {
                *pbEnabled = VARIANT_TRUE;
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
        FreeLibrary(hInstCscdll);
    }
    else
    {
        hr = ResultFromLastError();
    }
    return hr;
}


WCHAR s_szAdmin[UNLEN + sizeof('\0')]     =   L"";

LPCWSTR GetAdminAccountName(void)
{
    if (s_szAdmin[0] == L'\0')
    {
        BOOL bSuccess = FALSE;
        PSID pSid;

        if (ERROR_SUCCESS == BuildAccountSidFromRid(NULL,
                                                    DOMAIN_USER_RID_ADMIN,
                                                    &pSid))
        {
            DWORD           dwAdminSize, dwDomainSize;
            WCHAR           szDomain[DNLEN + sizeof('\0')];
            SID_NAME_USE    eUse;

            dwAdminSize = ARRAYSIZE(s_szAdmin);
            dwDomainSize = ARRAYSIZE(szDomain);

            bSuccess = LookupAccountSidW(NULL,
                                         pSid,
                                         s_szAdmin,
                                         &dwAdminSize,
                                         szDomain,
                                         &dwDomainSize,
                                         &eUse);
            LocalFree(pSid);
        }
        if (!bSuccess)
        {
            lstrcpyW(s_szAdmin, L"Administrator");
        }
    }
    return(s_szAdmin);
}



STDMETHODIMP CLocalMachine::get_AccountName(VARIANT varAccount, VARIANT* pvar)
{
    DWORD dwRID = 0;
    LPCWSTR pszName = NULL;

    if (NULL == pvar)
        return E_POINTER;

    switch (varAccount.vt)
    {
    case VT_I4:
    case VT_UI4:
        dwRID = varAccount.ulVal;
        break;

    case VT_BSTR:
        if (0 == StrCmpIW(varAccount.bstrVal, L"Guest"))
            dwRID = DOMAIN_USER_RID_GUEST;
        else if (0 == StrCmpIW(varAccount.bstrVal, L"Administrator"))
            dwRID = DOMAIN_USER_RID_ADMIN;
        else
            return E_INVALIDARG;
        break;

    default:
        return E_INVALIDARG;
    }

    switch (dwRID)
    {
    case DOMAIN_USER_RID_GUEST:
        pszName = GetGuestAccountName();
        break;

    case DOMAIN_USER_RID_ADMIN:
        pszName = GetAdminAccountName();
        break;

    default:
        return E_INVALIDARG;
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(pszName);

    return(S_OK);
}

STDMETHODIMP CLocalMachine::TurnOffComputer()
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (objLogon.TurnOffComputer ())
        hr = S_OK;
    else
        hr = E_FAIL;

    return hr;
}

STDMETHODIMP CLocalMachine::UndockComputer()
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (objLogon.EjectComputer())
        hr = S_OK;
    else
        hr = E_FAIL;
    return hr;
}

STDMETHODIMP CLocalMachine::SignalUIHostFailure()
{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    objLogon.SignalUIHostFailure ();
    return S_OK;
}

STDMETHODIMP CLocalMachine::AllowExternalCredentials()

{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    if (!objLogon.AllowExternalCredentials ())
    {
        return E_NOTIMPL;
    }
    else
    {
        return S_OK;
    }
}

STDMETHODIMP CLocalMachine::RequestExternalCredentials()
{
    CLogonIPC   objLogon;

    if (!objLogon.IsLogonServiceAvailable())
    {
        return E_FAIL;
    }

    objLogon.RequestExternalCredentials ();
    return S_OK;
}

STDMETHODIMP CLocalMachine::LogonWithExternalCredentials(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;
    CLogonIPC   objLogon;
    TCHAR   szUsername[UNLEN + sizeof('\0')],
            szDomain[DNLEN + sizeof('\0')],
            szPassword[PWLEN + sizeof('\0')];

    if (pstrUsername)
    {
        lstrcpyn(szUsername, pstrUsername, ARRAYSIZE(szUsername));
    }
    else
    {
        szUsername[0] = TEXT('\0');
    }
    if (pstrDomain)
    {
        lstrcpyn(szDomain, pstrDomain, ARRAYSIZE(szDomain));
    }
    else
    {
        szDomain[0] = TEXT('\0');
    }
    if (pstrPassword)
    {
        lstrcpyn(szPassword, pstrPassword, ARRAYSIZE(szPassword));
    }
    else
    {
        szPassword[0] = TEXT('\0');
    }
        
    if (!objLogon.IsLogonServiceAvailable())
    {
        *pbRet = VARIANT_FALSE;
        return S_OK;
    }

    if (objLogon.LogUserOn (szUsername, szDomain, szPassword))
        *pbRet = VARIANT_TRUE;
    else
        *pbRet = VARIANT_FALSE;


    if (*pbRet)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

//  --------------------------------------------------------------------------
//  CLocalMachine::InitiateInteractiveLogon
//
//  Arguments:  pstrUsername    =   User name.
//              pstrDomain      =   Domain.
//              pstrPassword    =   Password (in clear text).
//              pbRet           =   Result (returned).
//
//  Returns:    HRESULT
//
//  Purpose:    Send a request for interactive logon using CInteractiveLogon.
//              It's magic. I don't care how it works.
//
//  History:    2000-12-06  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP CLocalMachine::InitiateInteractiveLogon(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, DWORD dwTimeout, VARIANT_BOOL* pbRet)

{
    DWORD   dwErrorCode;

    dwErrorCode = CInteractiveLogon::Initiate(pstrUsername, pstrDomain, pstrPassword, dwTimeout);
    *pbRet = (ERROR_SUCCESS == dwErrorCode) ? VARIANT_TRUE : VARIANT_FALSE;
    return(HRESULT_FROM_WIN32(dwErrorCode));
}

//  --------------------------------------------------------------------------
//  CLocalMachine::RefreshStartMenu
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Finds the shell tray window and sends it a message to refresh
//              its contents.
//
//  History:    2000-08-01  vtan        created
//  --------------------------------------------------------------------------

void    CLocalMachine::RefreshStartMenu (void)

{
    HWND    hwndTray;

    hwndTray = FindWindow(TEXT("Shell_TrayWnd"), NULL);
    if (hwndTray != NULL)
    {
        TBOOL(PostMessage(hwndTray, TM_REFRESH, 0, 0));
    }
}

CLocalMachine::CLocalMachine() : _cRef(1), CIDispatchHelper(&IID_ILocalMachine, &LIBID_SHGINALib)
{
    DllAddRef();
}


CLocalMachine::~CLocalMachine()
{
    ASSERT(_cRef == 0);
    DllRelease();
}


STDAPI CLocalMachine_Create(REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLocalMachine* pLocalMachine = new CLocalMachine();

    if (pLocalMachine)
    {
        hr = pLocalMachine->QueryInterface(riid, ppv);
        pLocalMachine->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cinteractivelogon.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CInteractiveLogon.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that implements encapsulation of interactive logon information.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

#include "priv.h"
#include "CInteractiveLogon.h"

#include <winsta.h>

#include "GinaIPC.h"
#include "TokenInformation.h"
#include "UIHostIPC.h"

const TCHAR     CInteractiveLogon::s_szEventReplyName[]     =   TEXT("shgina: InteractiveLogonRequestReply");
const TCHAR     CInteractiveLogon::s_szEventSignalName[]    =   TEXT("shgina: InteractiveLogonRequestSignal");
const TCHAR     CInteractiveLogon::s_szSectionName[]        =   TEXT("shgina: InteractiveLogonRequestSection");

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::CRequestData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CRequestData.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CRequestData::CRequestData (void)

{
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::~CRequestData
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CRequestData.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CRequestData::~CRequestData (void)

{
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::Set
//
//  Arguments:  pszUsername     =   Username.
//              pszDomain       =   Domain.
//              pszPassword     =   Password.
//
//  Returns:    <none>
//
//  Purpose:    Sets the information into the section object. Makes the data
//              valid by signing it with a 4-byte signature.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::CRequestData::Set (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    UNICODE_STRING  passwordString;

    _ulMagicNumber = MAGIC_NUMBER;
    _dwErrorCode = ERROR_ACCESS_DENIED;
    lstrcpyn(_szEventReplyName, s_szEventReplyName, ARRAYSIZE(s_szEventReplyName));
    lstrcpyn(_szUsername, pszUsername, ARRAYSIZE(_szUsername));
    lstrcpyn(_szDomain, pszDomain, ARRAYSIZE(_szDomain));
    lstrcpyn(_szPassword, pszPassword, ARRAYSIZE(_szPassword));
    ZeroMemory(pszPassword, (lstrlen(pszPassword) + sizeof('\0')) * sizeof(WCHAR));
    _iPasswordLength = lstrlen(_szPassword);
    if (_iPasswordLength > 127)
    {
        _iPasswordLength = 127;
    }
    _szPassword[_iPasswordLength] = L'\0';
    RtlInitUnicodeString(&passwordString, _szPassword);
    _ucSeed = 0;
    RtlRunEncodeUnicodeString(&_ucSeed, &passwordString);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::Get
//
//  Arguments:  pszUsername     =   Username (returned).
//              pszDomain       =   Domain (returned).
//              pszPassword     =   Password (clear-text) returned.
//
//  Returns:    DWORD
//
//  Purpose:    Extracts the information transmitted in the section across
//              sessions in the receiving process' context. Checks the
//              signature written by Set.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CRequestData::Get (WCHAR *pszUsername, WCHAR *pszDomain, WCHAR *pszPassword)  const

{
    DWORD   dwErrorCode;

    if (_ulMagicNumber == MAGIC_NUMBER)
    {
        UNICODE_STRING  passwordString;

        lstrcpy(pszUsername, _szUsername);
        lstrcpy(pszDomain, _szDomain);
        CopyMemory(pszPassword, _szPassword, (PWLEN + sizeof('\0')) * sizeof(WCHAR));
        passwordString.Length = (PWLEN * sizeof(WCHAR));
        passwordString.MaximumLength = (PWLEN + sizeof('\0')) * sizeof(WCHAR);
        passwordString.Buffer = pszPassword;
        RtlRunDecodeUnicodeString(_ucSeed, &passwordString);
        pszPassword[_iPasswordLength] = L'\0';
        dwErrorCode = ERROR_SUCCESS;
    }
    else
    {
        dwErrorCode = ERROR_INVALID_PARAMETER;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::SetErrorCode
//
//  Arguments:  dwErrorCode     =   Error code to set.
//
//  Returns:    DWORD
//
//  Purpose:    Sets the error code into the section.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::CRequestData::SetErrorCode (DWORD dwErrorCode)

{
    _dwErrorCode = dwErrorCode;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::GetErrorCode
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the error code from the section.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CRequestData::GetErrorCode (void)     const

{
    return(_dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CRequestData::OpenEventReply
//
//  Arguments:  <none>
//
//  Returns:    HANDLE
//
//  Purpose:    Opens a handle to the reply event. The reply event is named
//              in the section object.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CRequestData::OpenEventReply (void)   const

{
    return(OpenEvent(EVENT_MODIFY_STATE, FALSE, _szEventReplyName));
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CInteractiveLogon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CInteractiveLogon. Create a thread to wait
//              on the auto-reset event signaled on an external request. This
//              thread is cleaned up on object destruction and also on
//              process termination.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::CInteractiveLogon (void) :
    _hThread(NULL),
    _fContinue(true),
    _hwndHost(NULL)

{
    Start();
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::~CInteractiveLogon
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Terminate the wait thread. Queue an APC to set the member
//              variable to end the termination. The wait is satisfied and
//              returns (WAIT_IO_COMPLETION). The loop is exited and the
//              thread is exited.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

CInteractiveLogon::~CInteractiveLogon (void)

{
    Stop();
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Start
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Create the thread that listens on interactive logon requests.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::Start (void)

{
    if (_hThread == NULL)
    {
        DWORD   dwThreadID;

        _hThread = CreateThread(NULL,
                                0,
                                CB_ThreadProc,
                                this,
                                0,
                                &dwThreadID);
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Stop
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Stop the thread that listens on interactive logon requests.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::Stop (void)

{
    HANDLE  hThread;

    hThread = InterlockedExchangePointer(&_hThread, NULL);
    if (hThread != NULL)
    {
        if (QueueUserAPC(CB_APCProc, hThread, reinterpret_cast<ULONG_PTR>(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::SetHostWindow
//
//  Arguments:  hwndHost    =   HWND of the actual UI host.
//
//  Returns:    <none>
//
//  Purpose:    Sets the HWND into the member variable so that the message
//              can be sent directly to the UI host rather than the status
//              host which is a go-between.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::SetHostWindow (HWND hwndHost)

{
    _hwndHost = hwndHost;
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::Initiate
//
//  Arguments:  pszUsername     =   User name.
//              pszDomain       =   Domain.
//              pszPassword     =   Password.
//              dwTimeout       =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    External entry point implementing interactive logon requests.
//              This function checks for privileges and mutexes and events
//              and does the right thing.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::Initiate (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    dwErrorCode = CheckInteractiveLogonAllowed(dwTimeout);
    if (ERROR_SUCCESS == dwErrorCode)
    {
        HANDLE  hToken;

        //  First authenticate the user with the given credentials for an
        //  interactive logon. Go no further unless that's valid.

        dwErrorCode = CTokenInformation::LogonUser(pszUsername,
                                                   pszDomain,
                                                   pszPassword,
                                                   &hToken);
        if (ERROR_SUCCESS == dwErrorCode)
        {
            HANDLE  hMutex;

            hMutex = OpenMutex(SYNCHRONIZE | MUTEX_MODIFY_STATE, FALSE, SZ_INTERACTIVE_LOGON_REQUEST_MUTEX_NAME);
            if (hMutex != NULL)
            {
                dwErrorCode = WaitForSingleObject(hMutex, dwTimeout);
                if (WAIT_OBJECT_0 == dwErrorCode)
                {
                    DWORD   dwSessionID, dwUserSessionID;
                    HANDLE  hEvent;

                    //  User is authenticated correctly. There are several cases
                    //  that need to be handled.

                    dwSessionID = USER_SHARED_DATA->ActiveConsoleId;

                    //  Determine if the session has the welcome screen displayed
                    //  by opening the named signal event for the session.

                    hEvent = OpenSessionNamedSignalEvent(dwSessionID);
                    if (hEvent != NULL)
                    {
                        TBOOL(CloseHandle(hEvent));
                        dwErrorCode = SendRequest(pszUsername, pszDomain, pszPassword);
                    }
                    else
                    {

                        //  Do whatever needs to be done to log the user on.

                        if (FoundUserSessionID(hToken, &dwUserSessionID))
                        {
                            if (dwUserSessionID == dwSessionID)
                            {

                                //  User is the active console session. No further work needs
                                //  to be done. Return success.

                                dwErrorCode = ERROR_SUCCESS;
                            }
                            else
                            {

                                //  User is disconnected. Reconnect back to the user session.
                                //  If that fails then return the error code back.

                                if (WinStationConnect(SERVERNAME_CURRENT,
                                                      dwUserSessionID,
                                                      USER_SHARED_DATA->ActiveConsoleId,
                                                      L"",
                                                      TRUE) != FALSE)
                                {
                                    dwErrorCode = ERROR_SUCCESS;
                                }
                                else
                                {
                                    dwErrorCode = GetLastError();
                                }
                            }
                        }
                        else
                        {
                            HANDLE  hEvent;

                            hEvent = CreateEvent(NULL, TRUE, FALSE, SZ_INTERACTIVE_LOGON_REPLY_EVENT_NAME);
                            if (hEvent != NULL)
                            {

                                //  User has no session. If at the welcome screen then send the
                                //  request to the welcome screen. Otherwise disconnect the
                                //  current session and use a new session to log the user on.

                                dwErrorCode = ShellStartCredentialServer(pszUsername, pszDomain, pszPassword, dwTimeout);
                                if (ERROR_SUCCESS == dwErrorCode)
                                {
                                    dwErrorCode = WaitForSingleObject(hEvent, dwTimeout);
                                }
                                TBOOL(CloseHandle(hEvent));
                            }
                            else
                            {
                                dwErrorCode = GetLastError();
                            }
                        }
                    }
                    TBOOL(ReleaseMutex(hMutex));
                }
                TBOOL(CloseHandle(hMutex));
            }
            TBOOL(CloseHandle(hToken));
        }
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckInteractiveLogonAllowed
//
//  Arguments:  dwTimeout   =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    Check whether the interactive logon request is allowed. To
//              make this call:
//
//              1. You must have SE_TCB_PRIVILEGE.
//              2. There must be an active console session ID that's valid.
//              3. The machine must not be shutting down.
//              4. The logon mutex must be available.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckInteractiveLogonAllowed (DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    //  1. Check for trusted call (SE_TCB_PRIVILEGE).

    if (SHTestTokenPrivilege(NULL, SE_TCB_NAME) != FALSE)
    {

        //  2. Check for active console session.

        if (USER_SHARED_DATA->ActiveConsoleId != static_cast<DWORD>(-1))
        {

            //  3. Check for machine shutdown.

            dwErrorCode = CheckShutdown();
            if (ERROR_SUCCESS == dwErrorCode)
            {

                //  4. Check for mutex availability.

                dwErrorCode = CheckMutex(dwTimeout);
            }
        }
        else
        {
            dwErrorCode = ERROR_NOT_READY;
        }
    }
    else
    {
        dwErrorCode = ERROR_PRIVILEGE_NOT_HELD;
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckShutdown
//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns an error code indicating if the machine is shutting
//              down or not. If the event cannot be opened then the request
//              is rejected.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckShutdown (void)

{
    DWORD   dwErrorCode;
    HANDLE  hEvent;

    hEvent = OpenEvent(SYNCHRONIZE, FALSE, SZ_SHUT_DOWN_EVENT_NAME);
    if (hEvent != NULL)
    {
        if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 0))
        {
            dwErrorCode = ERROR_SHUTDOWN_IN_PROGRESS;
        }
        else
        {
            dwErrorCode = ERROR_SUCCESS;
        }
        TBOOL(CloseHandle(hEvent));
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CheckMutex
//
//  Arguments:  dwTimeout   =   Timeout value.
//
//  Returns:    DWORD
//
//  Purpose:    Attempts to grab the logon mutex. This ensures that the state
//              of winlogon is known and it's not busy processing a request.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::CheckMutex (DWORD dwTimeout)

{
    DWORD   dwErrorCode;
    HANDLE  hMutex;

    hMutex = OpenMutex(SYNCHRONIZE, FALSE, SZ_INTERACTIVE_LOGON_MUTEX_NAME);
    if (hMutex != NULL)
    {
        dwErrorCode = WaitForSingleObject(hMutex, dwTimeout);
        if ((WAIT_OBJECT_0 == dwErrorCode) || (WAIT_ABANDONED == dwErrorCode))
        {
            TBOOL(ReleaseMutex(hMutex));
            dwErrorCode = ERROR_SUCCESS;
        }
    }
    else
    {
        dwErrorCode = GetLastError();
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::FoundUserSessionID
//
//  Arguments:  hToken          =   Token of user session to find.
//              pdwSessionID    =   Returned session ID.
//
//  Returns:    bool
//
//  Purpose:    Looks for a user session based on a given token. The match
//              is made by user SID.
//
//  History:    2001-04-06  vtan        created
//  --------------------------------------------------------------------------

bool    CInteractiveLogon::FoundUserSessionID (HANDLE hToken, DWORD *pdwSessionID)

{
    bool        fResult;
    PLOGONID    pLogonIDs;
    ULONG       ulEntries;

    fResult = false;
    if (WinStationEnumerate(SERVERNAME_CURRENT, &pLogonIDs, &ulEntries) != FALSE)
    {
        ULONG       ulIndex;
        PLOGONID    pLogonID;

        for (ulIndex = 0, pLogonID = pLogonIDs; !fResult && (ulIndex < ulEntries); ++ulIndex, ++pLogonID)
        {
            if ((pLogonID->State == State_Active) || (pLogonID->State == State_Disconnected))
            {
                ULONG                   ulReturnLength;
                WINSTATIONUSERTOKEN     winStationUserToken;

                winStationUserToken.ProcessId = ULongToHandle(GetCurrentProcessId());
                winStationUserToken.ThreadId = ULongToHandle(GetCurrentThreadId());
                winStationUserToken.UserToken = NULL;
                if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                               pLogonID->SessionId,
                                               WinStationUserToken,
                                               &winStationUserToken,
                                               sizeof(winStationUserToken),
                                               &ulReturnLength) != FALSE)
                {
                    fResult = CTokenInformation::IsSameUser(hToken, winStationUserToken.UserToken);
                    if (fResult)
                    {
                        *pdwSessionID = pLogonID->SessionId;
                    }
                    TBOOL(CloseHandle(winStationUserToken.UserToken));
                }
            }
        }

        //  Free any resources used.

        (BOOLEAN)WinStationFreeMemory(pLogonIDs);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::SendRequest
//
//  Arguments:  pszUsername     =   Username.
//              pszDomain       =   Domain.
//              pszPassword     =   Password. This string must be writable.
//
//  Returns:    DWORD
//
//  Purpose:    This function knows how to transmit the interactive logon
//              request from (presumably) session 0 to whatever session is
//              the active console session ID.
//
//              pszUsername must be UNLEN + sizeof('\0') characters.
//              pszDomain must be DNLEN + sizeof('\0') characters.
//              pszPassword must be PWLEN + sizeof('\0') characters.
//
//              pszPassword must be writable. The password is copied and
//              encoded and erased from the source buffer.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

DWORD   CInteractiveLogon::SendRequest (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword)

{
    DWORD   dwErrorCode, dwActiveConsoleID;
    HANDLE  hEventReply;

    dwErrorCode = ERROR_ACCESS_DENIED;

    //  First get the active console session ID.

    dwActiveConsoleID = USER_SHARED_DATA->ActiveConsoleId;

    //  Create a named event in that session named object space.

    hEventReply = CreateSessionNamedReplyEvent(dwActiveConsoleID);
    if (hEventReply != NULL)
    {
        HANDLE  hEventSignal;

        hEventSignal = OpenSessionNamedSignalEvent(dwActiveConsoleID);
        if (hEventSignal != NULL)
        {
            HANDLE  hSection;

            //  Create a named section that the UI host will open. This code
            //  is executed in the service context so it's always on session 0.

            hSection = CreateSessionNamedSection(dwActiveConsoleID);
            if (hSection != NULL)
            {
                void    *pV;

                //  Map the section into this process address space so we can put
                //  stuff it in.

                pV = MapViewOfFile(hSection,
                                   FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0);
                if (pV != NULL)
                {
                    __try
                    {
                        DWORD           dwWaitResult;
                        CRequestData    *pRequestData;

                        //  Fill the section data with the information given.

                        pRequestData = static_cast<CRequestData*>(pV);
                        pRequestData->Set(pszUsername, pszDomain, pszPassword);

                        //  Wake up the waiting thread in the UI host.

                        TBOOL(SetEvent(hEventSignal));

                        //  Wait 15 seconds for a reply the UI host.

                        dwWaitResult = WaitForSingleObject(hEventReply, 15000);

                        //  Return an error code accordingly.

                        if (WAIT_OBJECT_0 == dwWaitResult)
                        {
                            dwErrorCode = pRequestData->GetErrorCode();
                        }
                        else
                        {
                            dwErrorCode = dwWaitResult;
                        }
                    }
                    __except (EXCEPTION_EXECUTE_HANDLER)
                    {
                        dwErrorCode = ERROR_OUTOFMEMORY;
                    }
                    TBOOL(UnmapViewOfFile(pV));
                }
                TBOOL(CloseHandle(hSection));
            }
            TBOOL(CloseHandle(hEventSignal));
        }
        TBOOL(CloseHandle(hEventReply));
    }
    return(dwErrorCode);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::FormulateObjectBasePath
//
//  Arguments:  dwSessionID     =   Session ID of the named object space.
//              pszObjectPath   =   Buffer to receive path.
//
//  Returns:    <none>
//
//  Purpose:    Creates the correct path to the named object space for the
//              given session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::FormulateObjectBasePath (DWORD dwSessionID, WCHAR *pszObjectPath)

{
    if (dwSessionID == 0)
    {
        (WCHAR*)lstrcpyW(pszObjectPath, L"\\BaseNamedObjects\\");
    }
    else
    {
        wsprintfW(pszObjectPath, L"\\Sessions\\%d\\BaseNamedObjects\\", dwSessionID);
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CreateSessionNamedReplyEvent
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Creates the named reply event in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CreateSessionNamedReplyEvent (DWORD dwSessionID)

{
    NTSTATUS            status;
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      eventName;
    WCHAR               szEventName[128];

    FormulateObjectBasePath(dwSessionID, szEventName);
    (WCHAR*)lstrcatW(szEventName, s_szEventReplyName);
    RtlInitUnicodeString(&eventName, szEventName);
    InitializeObjectAttributes(&objectAttributes,
                               &eventName,
                               0,
                               NULL,
                               NULL);
    status = NtCreateEvent(&hEvent,
                           EVENT_ALL_ACCESS,
                           &objectAttributes,
                           SynchronizationEvent,
                           FALSE);
    if (!NT_SUCCESS(status))
    {
        hEvent = NULL;
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::OpenSessionNamedSignalEvent
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Opens the named signal event in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::OpenSessionNamedSignalEvent (DWORD dwSessionID)

{
    NTSTATUS            status;
    HANDLE              hEvent;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      eventName;
    WCHAR               szEventName[128];

    FormulateObjectBasePath(dwSessionID, szEventName);
    (WCHAR*)lstrcatW(szEventName, s_szEventSignalName);
    RtlInitUnicodeString(&eventName, szEventName);
    InitializeObjectAttributes(&objectAttributes,
                               &eventName,
                               0,
                               NULL,
                               NULL);
    status = NtOpenEvent(&hEvent,
                         EVENT_MODIFY_STATE,
                         &objectAttributes);
    if (!NT_SUCCESS(status))
    {
        hEvent = NULL;
    }
    return(hEvent);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CreateSessionNamedSection
//
//  Arguments:  dwSessionID     =   Session ID.
//
//  Returns:    HANDLE
//
//  Purpose:    Creates a named section object in the target session ID.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

HANDLE  CInteractiveLogon::CreateSessionNamedSection (DWORD dwSessionID)

{
    NTSTATUS            status;
    HANDLE              hSection;
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      sectionName;
    LARGE_INTEGER       sectionSize;
    WCHAR               szSectionName[128];

    FormulateObjectBasePath(dwSessionID, szSectionName);
    (WCHAR*)lstrcatW(szSectionName, s_szSectionName);
    RtlInitUnicodeString(&sectionName, szSectionName);
    InitializeObjectAttributes(&objectAttributes,
                               &sectionName,
                               0,
                               NULL,
                               NULL);
    sectionSize.LowPart = sizeof(CRequestData);
    sectionSize.HighPart = 0;
    status = NtCreateSection(&hSection,
                             STANDARD_RIGHTS_REQUIRED | SECTION_QUERY | SECTION_MAP_WRITE | SECTION_MAP_READ,
                             &objectAttributes,
                             &sectionSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(status))
    {
        hSection = NULL;
    }
    return(hSection);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::WaitForInteractiveLogonRequest
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Thread that executes in the UI host context of the receiving
//              session. This thread waits in an alertable state for the
//              signal event. If the event is signaled it does work to log the
//              specified user on.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CInteractiveLogon::WaitForInteractiveLogonRequest (void)

{
    HANDLE  hEvent;

    hEvent = CreateEvent(NULL,
                         FALSE,
                         FALSE,
                         s_szEventSignalName);
    if (hEvent != NULL)
    {
        DWORD   dwWaitResult;

        while (_fContinue)
        {
            dwWaitResult = WaitForSingleObjectEx(hEvent, INFINITE, TRUE);
            if (WAIT_OBJECT_0 == dwWaitResult)
            {
                HANDLE  hSection;

                hSection = OpenFileMapping(FILE_MAP_WRITE,
                                           FALSE,
                                           s_szSectionName);
                if (hSection != NULL)
                {
                    void    *pV;

                    pV = MapViewOfFile(hSection,
                                       FILE_MAP_WRITE,
                                       0,
                                       0,
                                       0);
                    if (pV != NULL)
                    {
                        __try
                        {
                            DWORD                       dwErrorCode;
                            HANDLE                      hEventReply;
                            CRequestData                *pRequestData;
                            INTERACTIVE_LOGON_REQUEST   interactiveLogonRequest;

                            pRequestData = static_cast<CRequestData*>(pV);
                            hEventReply = pRequestData->OpenEventReply();
                            if (hEventReply != NULL)
                            {
                                dwErrorCode = pRequestData->Get(interactiveLogonRequest.szUsername,
                                                                interactiveLogonRequest.szDomain,
                                                                interactiveLogonRequest.szPassword);
                                if (ERROR_SUCCESS == dwErrorCode)
                                {
                                    dwErrorCode = static_cast<DWORD>(SendMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_INTERACTIVE_LOGON_REQUEST, reinterpret_cast<LPARAM>(&interactiveLogonRequest)));
                                }
                                pRequestData->SetErrorCode(dwErrorCode);
                                TBOOL(SetEvent(hEventReply));
                                TBOOL(CloseHandle(hEventReply));
                            }
                            else
                            {
                                dwErrorCode = GetLastError();
                                pRequestData->SetErrorCode(dwErrorCode);
                            }
                        }
                        __except (EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                        TBOOL(UnmapViewOfFile(pV));
                    }
                    TBOOL(CloseHandle(hSection));
                }
            }
            else
            {
                ASSERTMSG((WAIT_FAILED == dwWaitResult) || (WAIT_IO_COMPLETION == dwWaitResult), "Unexpected result from kernel32!WaitForSingleObjectEx in CInteractiveLogon::WaitForInteractiveLogonRequest");
                _fContinue = false;
            }
        }
        TBOOL(CloseHandle(hEvent));
    }
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CB_ThreadProc
//
//  Arguments:  pParameter  =   this object.
//
//  Returns:    DWORD
//
//  Purpose:    Callback function stub to member function.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI      CInteractiveLogon::CB_ThreadProc (void *pParameter)

{
    static_cast<CInteractiveLogon*>(pParameter)->WaitForInteractiveLogonRequest();
    return(0);
}

//  --------------------------------------------------------------------------
//  CInteractiveLogon::CB_APCProc
//
//  Arguments:  dwParam     =   this object.
//
//  Returns:    <none>
//
//  Purpose:    Set object member variable to exit thread loop.
//
//  History:    2000-12-08  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CInteractiveLogon::CB_APCProc (ULONG_PTR dwParam)

{
    reinterpret_cast<CInteractiveLogon*>(dwParam)->_fContinue = false;
}

//  --------------------------------------------------------------------------
//  ::InitiateInteractiveLogon
//
//  Arguments:  pszUsername     =   User name.
//              pszPassword     =   Password.
//              dwTimeout       =   Time out in milliseconds.
//
//  Returns:    BOOL
//
//  Purpose:    External entry point function exported by name to initiate
//              an interactive logon with specified timeout.
//
//  History:    2001-04-10  vtan        created
//              2001-06-04  vtan        added timeout
//  --------------------------------------------------------------------------

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogon (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout)

{
    DWORD   dwErrorCode;

    dwErrorCode = CInteractiveLogon::Initiate(pszUsername, L"", pszPassword, dwTimeout);
    if (ERROR_SUCCESS != dwErrorCode)
    {
        SetLastError(dwErrorCode);
    }
    return(ERROR_SUCCESS == dwErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cidispatchhelper.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CIDispatchHelper.cpp
//
//  Contents:   implementation of CIDispatchHelper class
//
//----------------------------------------------------------------------------

#include "priv.h"
#include "CIDispatchHelper.h"

#define TF_IDISPATCH 0


//
// helper function for pulling ITypeInfo out of the specified typelib
//
HRESULT CIDispatchHelper::_LoadTypeInfo(const GUID* rguidTypeLib, LCID lcid, UUID uuid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr;
    ITypeLib* pITypeLib;

    *ppITypeInfo = NULL;

    //
    // The type libraries are registered under 0 (neutral),
    // 7 (German), and 9 (English) with no specific sub-
    // language, which would make them 407 or 409 and such.
    // If you are sensitive to sub-languages, then use the
    // full LCID instead of just the LANGID as done here.
    //
    hr = LoadRegTypeLib(*rguidTypeLib, 1, 0, PRIMARYLANGID(lcid), &pITypeLib);

    //
    // If LoadRegTypeLib fails, try loading directly with
    // LoadTypeLib, which will register the library for us.
    // Note that there's no default case here because the
    // prior switch will have filtered lcid already.
    //
    // NOTE:  You should prepend your DIR registry key to the
    // .TLB name so you don't depend on it being it the PATH.
    // This sample will be updated later to reflect this.
    //
    if (FAILED(hr))
    {
        OLECHAR wszPath[MAX_PATH];
#ifdef UNICODE
        GetModuleFileName(HINST_THISDLL, wszPath, ARRAYSIZE(wszPath));
#else
        TCHAR szPath[MAX_PATH];
        GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath));
        MultiByteToWideChar(CP_ACP, 0, szPath, -1, wszPath, ARRAYSIZE(wszPath));
#endif

        switch (PRIMARYLANGID(lcid))
        {
            case LANG_NEUTRAL:
            case LANG_ENGLISH:
                hr = LoadTypeLib(wszPath, &pITypeLib);
                break;
        }
    }

    if (SUCCEEDED(hr))
    {
        // got the type lib, get type info for the interface we want
        hr = pITypeLib->GetTypeInfoOfGuid(uuid, ppITypeInfo);
        pITypeLib->Release();
    }

    return hr;
}


//
// IDispatch Interface
// 

//
// CIDispatchHelper::GetTypeInfoCount
//
// Purpose:
//  Returns the number of type information (ITypeInfo) interfaces
//  that the object provides (0 or 1).
//
// Parameters:
//  pctInfo         UINT * to the location to receive
//                  the count of interfaces.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetTypeInfoCount(UINT *pctInfo)
{
    // we implement GetTypeInfo so return 1
    *pctInfo = 1;

    return NOERROR;
}


//
// CIDispatchHelper::GetTypeInfo
//
// Purpose:
//  Retrieves type information for the automation interface.  This
//  is used anywhere that the right ITypeInfo interface is needed
//  for whatever LCID is applicable.  Specifically, this is used
//  from within GetIDsOfNames and Invoke.
//
// Parameters:
//  itInfo          UINT reserved.  Must be zero.
//  lcid            LCID providing the locale for the type
//                  information.  If the object does not support
//                  localization, this is ignored.
//  ppITypeInfo     ITypeInfo ** in which to store the ITypeInfo
//                  interface for the object.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetTypeInfo(UINT itInfo, LCID lcid, ITypeInfo** ppITypeInfo)
{
    HRESULT hr = S_OK;
    ITypeInfo** ppITI;

    *ppITypeInfo = NULL;

    if (itInfo != 0)
    {
        return TYPE_E_ELEMENTNOTFOUND;
    }

#if 1
    // docs say we can ignore lcid if we support only one LCID
    // we don't have to return DISP_E_UNKNOWNLCID if we're *ignoring* it
    ppITI = &_pITINeutral;
#else
    //
    // Since we returned one from GetTypeInfoCount, this function
    // can be called for a specific locale.  We support English
    // and neutral (defaults to English) locales.  Anything
    // else is an error.
    //
    // After this switch statement, ppITI will point to the proper
    // member pITypeInfo. If *ppITI is NULL, we know we need to
    // load type information, retrieve the ITypeInfo we want, and
    // then store it in *ppITI.
    //
    switch (PRIMARYLANGID(lcid))
    {
        case LANG_NEUTRAL:
        case LANG_ENGLISH:
            ppITI=&_pITINeutral;
            break;

        default:
            hr = DISP_E_UNKNOWNLCID;
    }
#endif

    if (SUCCEEDED(hr))
    {
        //Load a type lib if we don't have the information already
        if (*ppITI == NULL)
        {
            ITypeInfo* pITIDisp;

            hr = _LoadTypeInfo(_piidTypeLib, lcid, *_piid, &pITIDisp);

            if (SUCCEEDED(hr))
            {
                HREFTYPE hrefType;

                // All our IDispatch implementations are DUAL. GetTypeInfoOfGuid
                // returns the ITypeInfo of the IDispatch-part only. We need to
                // find the ITypeInfo for the dual interface-part.
                if (SUCCEEDED(pITIDisp->GetRefTypeOfImplType(0xffffffff, &hrefType)) &&
                    SUCCEEDED(pITIDisp->GetRefTypeInfo(hrefType, ppITI)))
                {
                    // GetRefTypeInfo should have filled in ppITI with the dual interface
                    (*ppITI)->AddRef(); // add the ref for our caller
                    *ppITypeInfo = *ppITI;
                    
                    pITIDisp->Release();
                }
                else
                {
                    // I suspect GetRefTypeOfImplType may fail if someone uses
                    // CIDispatchHelper on a non-dual interface. In this case the
                    // ITypeInfo we got above is just fine to use.
                    *ppITI = pITIDisp;
                }
            }
        }
        else
        {
            // we already loaded the type library and we have an ITypeInfo from it
            (*ppITI)->AddRef(); // add the ref for our caller
            *ppITypeInfo = *ppITI;
        }
    }

    return hr;
}


//
// CIDispatchHelper::GetIDsOfNames
//
// Purpose:
//  Converts text names into DISPIDs to pass to Invoke
//
// Parameters:
//  riid            REFIID reserved.  Must be IID_NULL.
//  rgszNames       OLECHAR ** pointing to the array of names to be
//                  mapped.
//  cNames          UINT number of names to be mapped.
//  lcid            LCID of the locale.
//  rgDispID        DISPID * caller allocated array containing IDs
//                  corresponging to those names in rgszNames.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgDispID)
{
    HRESULT hr;
    ITypeInfo* pTI;
 
    if (riid != IID_NULL)
    {
        return DISP_E_UNKNOWNINTERFACE;
    }

    // get the right ITypeInfo for lcid.
    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        hr = pTI->GetIDsOfNames(rgszNames, cNames, rgDispID);
        pTI->Release();
    }

    return hr;
}


//
// CIDispatchHelper::Invoke
//
// Purpose:
//  Calls a method in the dispatch interface or manipulates a
//  property.
//
// Parameters:
//  dispID          DISPID of the method or property of interest.
//  riid            REFIID reserved, must be IID_NULL.
//  lcid            LCID of the locale.
//  wFlags          USHORT describing the context of the invocation.
//  pDispParams     DISPPARAMS * to the array of arguments.
//  pVarResult      VARIANT * in which to store the result.  Is
//                  NULL if the caller is not interested.
//  pExcepInfo      EXCEPINFO * to exception information.
//  puArgErr        UINT * in which to store the index of an
//                  invalid parameter if DISP_E_TYPEMISMATCH
//                is returned.
//
// Return Value:
//  HRESULT         NOERROR or a general error code.
//
STDMETHODIMP CIDispatchHelper::Invoke(DISPID dispID, REFIID riid, LCID lcid, unsigned short wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
{
    HRESULT hr;
    ITypeInfo *pTI;

    //riid is supposed to be IID_NULL always
    if (riid != IID_NULL)
    {
        return(DISP_E_UNKNOWNINTERFACE);
    }

    // make sure we have an interface to hand off to Invoke
    if (_pdisp == NULL)
    {
        hr = QueryInterface(*_piid, (LPVOID*)&_pdisp);
        
        if (FAILED(hr))
        {
            return hr;
        }

        // don't hold a refcount on ourself
        _pdisp->Release();
    }

    // get the ITypeInfo for lcid
    hr = GetTypeInfo(0, lcid, &pTI);

    if (SUCCEEDED(hr))
    {
        // clear exceptions
        SetErrorInfo(0L, NULL);

        // this is exactly what DispInvoke does--so skip the overhead.
        hr = pTI->Invoke(_pdisp, dispID, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
        pTI->Release();
    }

    return hr;
}


CIDispatchHelper::CIDispatchHelper(const IID* piid, const IID* piidTypeLib)
{
    // the constructor takes a guid that this IDispatch implementation is for
    _piid = piid;

    // and a guid that tells us which RegTypeLib to load
    _piidTypeLib = piidTypeLib;

    ASSERT(_pITINeutral == NULL);
    ASSERT(_pdisp == NULL);

    return;
}


CIDispatchHelper::~CIDispatchHelper(void)
{
    if (_pITINeutral)
    {
        _pITINeutral->Release();
        _pITINeutral = NULL;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\classfactory.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       ClassFactory.cpp
//
//  Contents:   com class factory routines
//
//----------------------------------------------------------------------------
#include "priv.h"

#include "UserOM.h" // needed for class factory prototypes


class CSHGinaFactory : public IClassFactory
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IClassFactory ***
    virtual STDMETHODIMP CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppvObject);
    virtual STDMETHODIMP LockServer(BOOL fLock);

public:
    CSHGinaFactory(REFCLSID rclsid);
    ~CSHGinaFactory(void);

    // friend Functions
    friend HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

protected:
    int _cRef;
    CLSID _rclsid;
};


//
// IUnknown Interface
//

ULONG CSHGinaFactory::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CSHGinaFactory::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CSHGinaFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObj = SAFECAST(this, IClassFactory*);
        AddRef();
        hr = S_OK;
    }

    return hr;
}


//
// IClassFactory methods
//

HRESULT CSHGinaFactory::CreateInstance(IUnknown* punkOuter, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr = ResultFromScode(REGDB_E_CLASSNOTREG);
    *ppvObj = NULL;

    if (!punkOuter)
    {
        if (IsEqualIID(_rclsid, CLSID_ShellLogonEnumUsers))
        {
            hr = CLogonEnumUsers_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLogonUser))
        {
            hr = CLogonUser_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLocalMachine))
        {
            hr = CLocalMachine_Create(riid, ppvObj);
        }
        else if (IsEqualIID(_rclsid, CLSID_ShellLogonStatusHost))
        {
            hr = CLogonStatusHost_Create(riid, ppvObj);
        }
        else
        {
            // What are you looking for?
            ASSERTMSG(FALSE, "CSHGinaFactory::CreateInstance unable to create object.");
            hr = E_FAIL;
        }
    }
    else
    {
        // Does anybody support aggregation any more?
        hr = ResultFromScode(CLASS_E_NOAGGREGATION);
    }

    return hr;
}


HRESULT CSHGinaFactory::LockServer(BOOL fLock)
{
    if (fLock)
    {
        DllAddRef();
    }
    else
    {
        DllRelease();
    }

    return S_OK;
}


HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;
    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IClassFactory) ||
        IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (LPVOID) new CSHGinaFactory(rclsid);
        if (*ppvObj)
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = ResultFromScode(E_NOINTERFACE);
    }

    return hr;
}


CSHGinaFactory::CSHGinaFactory(REFCLSID rclsid) : _cRef(1)
{
    _rclsid = rclsid;
    DllAddRef();
}


CSHGinaFactory::~CSHGinaFactory()
{
    DllRelease();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cidispatchhelper.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CIDispatchHelper.h
//
//  Contents:   class defintion for CIDispatchHelper, a helper class to share code
//              for the IDispatch implementation that others can inherit from. 
//
//----------------------------------------------------------------------------

#ifndef _CIDISPATCHHELPER_H_
#define _CIDISPATCHHELPER_H_





class CIDispatchHelper
{
    public:
        // we need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        // *** IDispatch methods ***
        STDMETHODIMP GetTypeInfoCount(UINT* pctinfo);
        STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
        STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

        // helper function to get a ITypeInfo uuid/lcid out of the type library
        HRESULT _LoadTypeInfo(const GUID* rguidTypeLib, LCID lcid, UUID uuid, ITypeInfo** ppITypeInfo);

        CIDispatchHelper(const IID* piid, const IID* piidTypeLib);
        ~CIDispatchHelper(void);

    private:
        const IID* _piid;           // guid that this IDispatch implementation is for
        const IID* _piidTypeLib;    // guid that specifies which TypeLib to load
        IDispatch* _pdisp;
        ITypeInfo* _pITINeutral;    // cached Type information
};

#endif // _CIDISPATCHHELPER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cinteractivelogon.h ===
//  --------------------------------------------------------------------------
//  Module Name: CInteractiveLogon.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that implements encapsulation of interactive logon information.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _CInteractiveLogon_
#define     _CInteractiveLogon_

EXTERN_C    BOOL    WINAPI  InitiateInteractiveLogon (const WCHAR *pszUsername, WCHAR *pszPassword, DWORD dwTimeout);

//  --------------------------------------------------------------------------
//  CInteractiveLogon
//
//  Purpose:    This class encapsulates interactive logon implementation.
//
//  History:    2000-12-07  vtan        created
//  --------------------------------------------------------------------------

class   CInteractiveLogon
{
    private:
        static  const int       MAGIC_NUMBER    =   48517;

        class   CRequestData
        {
            public:
                                    CRequestData (void);
                                    ~CRequestData (void);

                void                Set (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
                DWORD               Get (WCHAR *pszUsername, WCHAR *pszDomain, WCHAR *pszPassword)  const;
                void                SetErrorCode (DWORD dwErrorCode);
                DWORD               GetErrorCode (void)     const;
                HANDLE              OpenEventReply (void)   const;
            private:
                unsigned long       _ulMagicNumber;
                DWORD               _dwErrorCode;
                WCHAR               _szEventReplyName[64];
                WCHAR               _szUsername[UNLEN + sizeof('\0')];
                WCHAR               _szDomain[DNLEN + sizeof('\0')];
                unsigned char       _ucSeed;
                int                 _iPasswordLength;
                WCHAR               _szPassword[PWLEN + sizeof('\0')];
        };

    public:
                                    CInteractiveLogon (void);
                                    ~CInteractiveLogon (void);

                void                Start (void);
                void                Stop (void);

                void                SetHostWindow (HWND hwndUIHost);

        static  DWORD               Initiate (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword, DWORD dwTimeout);
    private:
        static  DWORD               CheckInteractiveLogonAllowed (DWORD dwTimeout);
        static  DWORD               CheckShutdown (void);
        static  DWORD               CheckMutex (DWORD dwTimeout);
        static  bool                FoundUserSessionID (HANDLE hToken, DWORD *pdwSessionID);
        static  DWORD               SendRequest (const WCHAR *pszUsername, const WCHAR *pszDomain, WCHAR *pszPassword);
        static  void                FormulateObjectBasePath (DWORD dwSessionID, WCHAR *pszObjectPath);
        static  HANDLE              CreateSessionNamedReplyEvent (DWORD dwSessionID);
        static  HANDLE              OpenSessionNamedSignalEvent (DWORD dwSessionID);
        static  HANDLE              CreateSessionNamedSection (DWORD dwSessionID);

                void                WaitForInteractiveLogonRequest (void);

        static  DWORD   WINAPI      CB_ThreadProc (void *pParameter);
        static  void    CALLBACK    CB_APCProc (ULONG_PTR dwParam);
    private:
                HANDLE              _hThread;
                bool                _fContinue;
                HWND                _hwndHost;

        static  const TCHAR         s_szEventReplyName[];
        static  const TCHAR         s_szEventSignalName[];
        static  const TCHAR         s_szSectionName[];
};

#endif  /*  _CInteractiveLogon_     */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\clogonstatushost.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: CLogonStatusHost.cpp
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  File that contains implementation for ILogonStatusHost for use by UI host
//  executables.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

#include "priv.h"
#include <wtsapi32.h>
#include <winsta.h>

#include "UserOM.h"
#include "GinaIPC.h"
#include "CInteractiveLogon.h"

const WCHAR     CLogonStatusHost::s_szTermSrvReadyEventName[]   =   TEXT("TermSrvReadyEvent");

//
// IUnknown Interface
//

ULONG   CLogonStatusHost::AddRef (void)

{
    return(++_cRef);
}

ULONG   CLogonStatusHost::Release (void)

{
    ULONG   ulResult;

    ASSERTMSG(_cRef > 0, "Invalid reference count in CLogonStatusHost::Release");
    ulResult = --_cRef;
    if (ulResult <= 0)
    {
        delete this;
        ulResult = 0;
    }
    return(ulResult);
}

HRESULT     CLogonStatusHost::QueryInterface (REFIID riid, void **ppvObj)

{
    static  const QITAB     qit[] = 
    {
        QITABENT(CLogonStatusHost, IDispatch),
        QITABENT(CLogonStatusHost, ILogonStatusHost),
        {0},
    };

    return(QISearch(this, qit, riid, ppvObj));
}

//
// IDispatch Interface
//

STDMETHODIMP    CLogonStatusHost::GetTypeInfoCount (UINT* pctinfo)

{
    return(CIDispatchHelper::GetTypeInfoCount(pctinfo));
}

STDMETHODIMP    CLogonStatusHost::GetTypeInfo (UINT itinfo, LCID lcid, ITypeInfo** pptinfo)

{
    return(CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo));
}

STDMETHODIMP    CLogonStatusHost::GetIDsOfNames (REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)

{
    return(CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid));
}

STDMETHODIMP    CLogonStatusHost::Invoke (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)

{
    return(CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr));
}

//
// ILogonStatusHost Interface
//

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Initialize
//
//  Arguments:  hInstance   =   HINSTANCE of hosting process.
//              hwndHost    =   HWND of UI host process.
//
//  Returns:    HRESULT
//
//  Purpose:    Registers the StatusWindowClass and creates an invisible
//              window of this class to receive messages from GINA to pass
//              through to the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::Initialize (HINSTANCE hInstance, HWND hwndHost)

{
    HRESULT     hr;
    HANDLE      hEvent;
    WNDCLASSEX  wndClassEx;

    ASSERTMSG(_hInstance == NULL, "CLogonStatusHost::Initialized already invoked by caller.");

    //  Save parameters to member variables.

    _hInstance = hInstance;
    _hwndHost = hwndHost;

    //  Register this window class.

    ZeroMemory(&wndClassEx, sizeof(wndClassEx));
    wndClassEx.cbSize = sizeof(WNDCLASSEX);
    wndClassEx.lpfnWndProc = StatusWindowProc;
    wndClassEx.hInstance = hInstance;
    wndClassEx.lpszClassName = STATUS_WINDOW_CLASS_NAME;
    _atom = RegisterClassEx(&wndClassEx);

    //  Create the window to receive messages from msgina.

    _hwnd = CreateWindow(MAKEINTRESOURCE(_atom),
                         TEXT("GINA UI"),
                         WS_OVERLAPPED,
                         0, 0,
                         0, 0,
                         NULL,
                         NULL,
                         _hInstance,
                         this);

    //  Signal msgina that we're ready.

    hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("msgina: StatusHostReadyEvent"));
    if (hEvent != NULL)
    {
        TBOOL(SetEvent(hEvent));
        TBOOL(CloseHandle(hEvent));
    }

    //  If we have a window then set the host window in, start waiting
    //  for terminal services to be ready and a wait on the parent process.

    if (_hwnd != NULL)
    {
        _interactiveLogon.SetHostWindow(_hwndHost);
        StartWaitForParentProcess();
        StartWaitForTermService();
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::UnInitialize
//
//  Arguments:  <none>
//
//  Returns:    HRESULT
//
//  Purpose:    Cleans up resources and memory allocated in Initialize.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::UnInitialize (void)

{
    ASSERTMSG(_hInstance != NULL, "CLogonStatusHost::UnInitialized invoked without Initialize.");
    if (_hwnd != NULL)
    {
        EndWaitForTermService();
        EndWaitForParentProcess();
        if (_fRegisteredNotification != FALSE)
        {
            TBOOL(WinStationUnRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd));
            _fRegisteredNotification = FALSE;
        }
        TBOOL(DestroyWindow(_hwnd));
        _hwnd = NULL;
    }
    if (_atom != 0)
    {
        TBOOL(UnregisterClass(MAKEINTRESOURCE(_atom), _hInstance));
        _atom = 0;
    }
    _hwndHost = NULL;
    _hInstance = NULL;
    return(S_OK);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::WindowProcedureHelper
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    HRESULT
//
//  Purpose:    Handles certain messages for the status UI host. This allows
//              things like ALT-F4 to be discarded or power messages to be
//              responded to correctly.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

STDMETHODIMP    CLogonStatusHost::WindowProcedureHelper (HWND hwnd, UINT uMsg, VARIANT wParam, VARIANT lParam)

{
    UNREFERENCED_PARAMETER(hwnd);
    UNREFERENCED_PARAMETER(lParam);

    HRESULT     hr;

    hr = E_NOTIMPL;
    switch (uMsg)
    {
        case WM_SYSCOMMAND:
            if (SC_CLOSE == wParam.uintVal)     //  Blow off ALT-F4
            {
                hr = S_OK;
            }
            break;
        default:
            break;
    }
    return(hr);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Handle_WM_UISERVICEREQUEST
//
//  Arguments:  wParam  =   WPARAM sent from GINA.
//              lParam  =   LPARAM sent from GINA.
//
//  Returns:    LRESULT
//
//  Purpose:    Receives messages from GINA bound for the UI host. Turns
//              around and passes the messages to the UI host. This allows
//              the actual implementation to change without having to
//              rebuild the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CLogonStatusHost::Handle_WM_UISERVICEREQUEST (WPARAM wParam, LPARAM lParam)

{
    LRESULT     lResult;
    WPARAM      wParamSend;
    void        *pV;

    lResult = 0;
    pV = NULL;
    wParamSend = HM_NOACTION;
    switch (wParam)
    {
        case UI_TERMINATE:
            ExitProcess(0);
            break;
        case UI_STATE_STATUS:
            _interactiveLogon.Stop();
            wParamSend = HM_SWITCHSTATE_STATUS;
            break;
        case UI_STATE_LOGON:
            _interactiveLogon.Start();
            wParamSend = HM_SWITCHSTATE_LOGON;
            break;
        case UI_STATE_LOGGEDON:
            _interactiveLogon.Stop();
            wParamSend = HM_SWITCHSTATE_LOGGEDON;
            break;
        case UI_STATE_HIDE:
            _interactiveLogon.Stop();
            TBOOL(SetProcessWorkingSetSize(GetCurrentProcess(), static_cast<SIZE_T>(-1), static_cast<SIZE_T>(-1)));
            wParamSend = HM_SWITCHSTATE_HIDE;
            break;
        case UI_STATE_END:
            EndWaitForTermService();
            EndWaitForParentProcess();
            wParamSend = HM_SWITCHSTATE_DONE;
            break;
        case UI_NOTIFY_WAIT:
            wParamSend = HM_NOTIFY_WAIT;
            break;
        case UI_SELECT_USER:
            pV = LocalAlloc(LPTR, sizeof(SELECT_USER));
            if (pV != NULL)
            {
                (WCHAR*)lstrcpyW(static_cast<SELECT_USER*>(pV)->szUsername, reinterpret_cast<LOGONIPC_USERID*>(lParam)->wszUsername);
                (WCHAR*)lstrcpyW(static_cast<SELECT_USER*>(pV)->szDomain, reinterpret_cast<LOGONIPC_USERID*>(lParam)->wszDomain);
                wParamSend = HM_SELECT_USER;
                lParam = reinterpret_cast<LPARAM>(pV);
            }
            break;
        case UI_SET_ANIMATIONS:
            wParamSend = HM_SET_ANIMATIONS;
            break;
        case UI_INTERACTIVE_LOGON:
            pV = LocalAlloc(LPTR, sizeof(INTERACTIVE_LOGON_REQUEST));
            if (pV != NULL)
            {
                (WCHAR*)lstrcpyW(static_cast<INTERACTIVE_LOGON_REQUEST*>(pV)->szUsername, reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam)->userID.wszUsername);
                (WCHAR*)lstrcpyW(static_cast<INTERACTIVE_LOGON_REQUEST*>(pV)->szDomain, reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam)->userID.wszDomain);
                (WCHAR*)lstrcpyW(static_cast<INTERACTIVE_LOGON_REQUEST*>(pV)->szPassword, reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam)->wszPassword);
                ZeroMemory(&reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam)->wszPassword, (lstrlenW(reinterpret_cast<LOGONIPC_CREDENTIALS*>(lParam)->wszPassword) + sizeof('\0')) * sizeof(WCHAR));
                wParamSend = HM_INTERACTIVE_LOGON_REQUEST;
                lParam = reinterpret_cast<LPARAM>(pV);
            }
            break;
        case UI_DISPLAY_STATUS:
            wParamSend = HM_DISPLAYSTATUS;
            break;
        default:
            break;
    }
    if (wParam != HM_NOACTION)
    {
        lResult = SendMessage(_hwndHost, WM_UIHOSTMESSAGE, wParamSend, lParam);
    }
    else
    {
        lResult = 0;
    }
    if (pV != NULL)
    {
        (HLOCAL)LocalFree(pV);
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::Handle_WM_WTSSESSION_CHANGE
//
//  Arguments:  wParam  =   
//              lParam  =   
//
//  Returns:    LRESULT
//
//  Purpose:    Receives messages from GINA bound for the UI host. Turns
//              around and passes the messages to the UI host. This allows
//              the actual implementation to change without having to
//              rebuild the UI host.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT     CLogonStatusHost::Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam)

{
    UNREFERENCED_PARAMETER(lParam);

    LRESULT     lResult;

    lResult = 0;
    switch (wParam)
    {
        case WTS_CONSOLE_CONNECT:
        case WTS_CONSOLE_DISCONNECT:
        case WTS_REMOTE_CONNECT:
        case WTS_REMOTE_DISCONNECT:
            break;
        case WTS_SESSION_LOGON:
        case WTS_SESSION_LOGOFF:
            lResult = SendMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYREFRESH, 0);
            break;
        default:
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StatusWindowProc
//
//  Arguments:  See the platform SDK under WindowProc.
//
//  Returns:    <none>
//
//  Purpose:    Window procedure for StatusWindowClass.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

LRESULT CALLBACK    CLogonStatusHost::StatusWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)

{
    LRESULT             lResult;
    CLogonStatusHost    *pThis;

    static bool         fDisplayChange = false;

    pThis = reinterpret_cast<CLogonStatusHost*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
    switch (uMsg)
    {
        case WM_CREATE:
        {
            CREATESTRUCT    *pCreateStruct;

            pCreateStruct = reinterpret_cast<CREATESTRUCT*>(lParam);
            (LONG_PTR)SetWindowLongPtr(hwnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pCreateStruct->lpCreateParams));
            lResult = 0;
            break;
        }
        case WM_UISERVICEREQUEST:
            lResult = pThis->Handle_WM_UISERVICEREQUEST(wParam, lParam);
            break;
        case WM_WTSSESSION_CHANGE:
            lResult = pThis->Handle_WM_WTSSESSION_CHANGE(wParam, lParam);
            break;
        case WM_SETTINGCHANGE:
            if (wParam == SPI_SETWORKAREA)
            {
                lResult = SendMessage(pThis->_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYRESIZE, TRUE);
            }
            else
            {
                lResult = 0;
            }
            break;
        case WM_DISPLAYCHANGE:
            fDisplayChange = true;
            lResult = PostMessage(pThis->_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYRESIZE, FALSE);
            break;
        case WM_WINDOWPOSCHANGING:
            if (fDisplayChange)
            {
                fDisplayChange = false;
                lResult = PostMessage(pThis->_hwndHost, WM_UIHOSTMESSAGE, HM_DISPLAYRESIZE, FALSE);
            }
            else
            {
                lResult = 0;
            }
            break;
        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }
    return(lResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::IsTermServiceDisabled
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Determines from the service control manager whether terminal
//              services is disabled.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonStatusHost::IsTermServiceDisabled (void)

{
    bool        fResult;
    SC_HANDLE   hSCManager;

    fResult = false;
    hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);
    if (hSCManager != NULL)
    {
        SC_HANDLE   hSCTermService;

        hSCTermService = OpenService(hSCManager, TEXT("TermService"), SERVICE_QUERY_CONFIG);
        if (hSCTermService != NULL)
        {
            DWORD                   dwBytesNeeded;
            QUERY_SERVICE_CONFIG    *pServiceConfig;

            (BOOL)QueryServiceConfig(hSCTermService, NULL, 0, &dwBytesNeeded);
            pServiceConfig = static_cast<QUERY_SERVICE_CONFIG*>(LocalAlloc(LMEM_FIXED, dwBytesNeeded));
            if (pServiceConfig != NULL)
            {
                if (QueryServiceConfig(hSCTermService, pServiceConfig, dwBytesNeeded, &dwBytesNeeded) != FALSE)
                {
                    fResult = (pServiceConfig->dwStartType == SERVICE_DISABLED);
                }
                (HLOCAL)LocalFree(pServiceConfig);
            }
            TBOOL(CloseServiceHandle(hSCTermService));
        }
        TBOOL(CloseServiceHandle(hSCManager));
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StartWaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Register for console notifications with terminal services. If
//              the service is disabled don't bother. If the service hasn't
//              started then create a thread to wait for it and re-perform the
//              registration.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::StartWaitForTermService (void)

{

    //  Don't do anything if terminal services is disabled.

    if (!IsTermServiceDisabled())
    {

        //  Try to register the notification first.

        _fRegisteredNotification = WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS);
        if (_fRegisteredNotification == FALSE)
        {
            DWORD   dwThreadID;

            (ULONG)AddRef();
            _hThreadWaitForTermService = CreateThread(NULL,
                                                      0,
                                                      CB_WaitForTermService,
                                                      this,
                                                      0,
                                                      &dwThreadID);
            if (_hThreadWaitForTermService == NULL)
            {
                (ULONG)Release();
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::EndWaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If a thread has been created and the thread is still executing
//              then wake it up and force it to exit. If the thread cannot be
//              woken up then terminate it. Release handles.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::EndWaitForTermService (void)

{
    HANDLE  hThread;

    //  Grab the _hThreadWaitForTermService now. This will indicate to the
    //  thread should it decide to finish executing that it shouldn't release
    //  the reference on itself.

    hThread = InterlockedExchangePointer(&_hThreadWaitForTermService, NULL);
    if (hThread != NULL)
    {

        //  Queue an APC to the wait thread. If the queue succeeds then
        //  wait for the thread to finish executing. If the queue fails
        //  the thread probably finished between the time we executed the
        //  InterlockedExchangePointer above and the QueueUserAPC.

        if (QueueUserAPC(CB_WakeupThreadAPC, hThread, PtrToUlong(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::WaitForTermService
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Simple thread that waits for terminal services to signal that
//              it's ready and then registers for notifications. This is
//              required because this DLL initializes before terminal services
//              has had a chance to start up.
//
//  History:    2000-10-20  vtan        created
//              2001-01-04  vtan        allow premature exit
//  --------------------------------------------------------------------------

void    CLogonStatusHost::WaitForTermService (void)

{
    DWORD       dwWaitResult;
    int         iCounter;
    HANDLE      hTermSrvReadyEvent, hThread;

    dwWaitResult = 0;
    iCounter = 0;
    hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, s_szTermSrvReadyEventName);
    while ((dwWaitResult == 0) && (hTermSrvReadyEvent == NULL) && (iCounter < 60))
    {
        ++iCounter;
        dwWaitResult = SleepEx(1000, TRUE);
        if (dwWaitResult == 0)
        {
            hTermSrvReadyEvent = OpenEvent(SYNCHRONIZE, FALSE, s_szTermSrvReadyEventName);
        }
    }
    if (hTermSrvReadyEvent != NULL)
    {
        dwWaitResult = WaitForSingleObjectEx(hTermSrvReadyEvent, 60000, TRUE);
        if (dwWaitResult == WAIT_OBJECT_0)
        {
            _fRegisteredNotification = WinStationRegisterConsoleNotification(SERVERNAME_CURRENT, _hwnd, NOTIFY_FOR_ALL_SESSIONS);
        }
        TBOOL(CloseHandle(hTermSrvReadyEvent));
    }

    //  Grab the _hThreadWaitForTermService now. This will indicate to the
    //  EndWaitForTermService function that we've reached the point of no
    //  return and we're going to release ourselves. If we can't grab the
    //  handle then EndWaitForTermService must be telling us to stop now.

    hThread = InterlockedExchangePointer(&_hThreadWaitForTermService, NULL);
    if (hThread != NULL)
    {
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WaitForTermService
//
//  Arguments:  pParameter  =   User defined data.
//
//  Returns:    DWORD
//
//  Purpose:    Stub to call member function.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CLogonStatusHost::CB_WaitForTermService (void *pParameter)

{
    static_cast<CLogonStatusHost*>(pParameter)->WaitForTermService();
    return(0);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::StartWaitForParentProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Create a thread to wait on the parent process. Terminal
//              services will terminate a non-session 0 winlogon which will
//              leave us dangling. Detect this case and exit cleanly. This
//              will allow csrss and win32k to clean up and release resources.
//
//  History:    2001-01-03  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::StartWaitForParentProcess (void)

{
    ULONG                       ulReturnLength;
    PROCESS_BASIC_INFORMATION   processBasicInformation;

    //  Open a handle to our parent process. This will be winlogon.
    //  If the parent dies then so do we.

    if (NT_SUCCESS(NtQueryInformationProcess(GetCurrentProcess(),
                                             ProcessBasicInformation,
                                             &processBasicInformation,
                                             sizeof(processBasicInformation),
                                             &ulReturnLength)))
    {
        _hProcessParent = OpenProcess(PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                                      FALSE,
                                      static_cast<DWORD>(processBasicInformation.InheritedFromUniqueProcessId));
#ifdef      DEBUG
        if (IsDebuggerPresent())
        {
            if (NT_SUCCESS(NtQueryInformationProcess(_hProcessParent,
                                                     ProcessBasicInformation,
                                                     &processBasicInformation,
                                                     sizeof(processBasicInformation),
                                                     &ulReturnLength)))
            {
                TBOOL(CloseHandle(_hProcessParent));
                _hProcessParent = OpenProcess(PROCESS_QUERY_INFORMATION | SYNCHRONIZE,
                                              FALSE,
                                              static_cast<DWORD>(processBasicInformation.InheritedFromUniqueProcessId));
            }
        }
#endif  /*  DEBUG   */
        if (_hProcessParent != NULL)
        {
            DWORD dwThreadID;

            (ULONG)AddRef();
            _hThreadWaitForParentProcess = CreateThread(NULL,
                                                        0,
                                                        CB_WaitForParentProcess,
                                                        this,
                                                        0,
                                                        &dwThreadID);
            if (_hThreadWaitForParentProcess == NULL)
            {
                (ULONG)Release();
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::EndWaitForParentProcess
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    If a thread waiting on the parent process is executing then
//              wake it up and force it to exit. If the thread cannot be woken
//              then terminate it. Release the handles used.
//
//  History:    2000-12-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::EndWaitForParentProcess (void)

{
    HANDLE  hThread;

    //  Do exactly the same thing that EndWaitForTermService does to correctly
    //  control the reference count on the "this" object. Whoever grabs the
    //  _hThreadWaitForParentProcess is the guy who releases the reference.

    hThread = InterlockedExchangePointer(&_hThreadWaitForParentProcess, NULL);
    if (hThread != NULL)
    {
        if (QueueUserAPC(CB_WakeupThreadAPC, hThread, PtrToUlong(this)) != FALSE)
        {
            (DWORD)WaitForSingleObject(hThread, INFINITE);
        }
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }

    //  Always release this handle the callback doesn't do this.

    if (_hProcessParent != NULL)
    {
        TBOOL(CloseHandle(_hProcessParent));
        _hProcessParent = NULL;
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::ParentProcessTerminated
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Handles parent process termination. Terminate process on us.
//
//  History:    2000-12-11  vtan        created
//  --------------------------------------------------------------------------

void    CLogonStatusHost::WaitForParentProcess (void)

{
    DWORD   dwWaitResult;
    HANDLE  hThread;

    //  Make a Win32 API call now so that the thread is converted to
    //  a GUI thread. This will allow the PostMessage call to work
    //  once the parent process is terminated. If the thread isn't
    //  a GUI thread the system will not convert it to one in the
    //  state when the callback is executed.

    TBOOL(PostMessage(_hwndHost, WM_NULL, 0, 0));
    dwWaitResult = WaitForSingleObjectEx(_hProcessParent, INFINITE, TRUE);
    if (dwWaitResult == WAIT_OBJECT_0)
    {
        TBOOL(PostMessage(_hwndHost, WM_UIHOSTMESSAGE, HM_SWITCHSTATE_DONE, 0));
    }
    hThread = InterlockedExchangePointer(&_hThreadWaitForParentProcess, NULL);
    if (hThread != NULL)
    {
        TBOOL(CloseHandle(hThread));
        (ULONG)Release();
    }
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WaitForParentProcess
//
//  Arguments:  pParameter  =   User defined data.
//
//  Returns:    DWORD
//
//  Purpose:    Stub to call member function.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  CLogonStatusHost::CB_WaitForParentProcess (void *pParameter)

{
    static_cast<CLogonStatusHost*>(pParameter)->WaitForParentProcess();
    return(0);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CB_WakeupThreadAPC
//
//  Arguments:  dwParam     =   User defined data.
//
//  Returns:    <none>
//
//  Purpose:    APCProc to wake up a thread waiting in an alertable state.
//
//  History:    2001-01-04  vtan        created
//  --------------------------------------------------------------------------

void    CALLBACK    CLogonStatusHost::CB_WakeupThreadAPC (ULONG_PTR dwParam)

{
    UNREFERENCED_PARAMETER(dwParam);
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::CLogonStatusHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Constructor for CLogonStatusHost.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

CLogonStatusHost::CLogonStatusHost (void) :
    CIDispatchHelper(&IID_ILogonStatusHost, &LIBID_SHGINALib),
    _cRef(1),
    _hInstance(NULL),
    _hwnd(NULL),
    _hwndHost(NULL),
    _atom(0),
    _fRegisteredNotification(FALSE),
    _hThreadWaitForTermService(NULL),
    _hThreadWaitForParentProcess(NULL),
    _hProcessParent(NULL)

{
    DllAddRef();
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost::~CLogonStatusHost
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Destructor for CLogonStatusHost.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------

CLogonStatusHost::~CLogonStatusHost (void)
{
    ASSERTMSG((_hProcessParent == NULL) &&
              (_hThreadWaitForParentProcess == NULL) &&
              (_hThreadWaitForTermService == NULL) &&
              (_fRegisteredNotification == FALSE) &&
              (_atom == 0) &&
              (_hwndHost == NULL) &&
              (_hwnd == NULL) &&
              (_hInstance == NULL), "Must UnIniitialize object before destroying in CLogonStatusHost::~CLogonStatusHost");
    ASSERTMSG(_cRef == 0, "Reference count expected to be zero in CLogonStatusHost::~CLogonStatusHost");
    DllRelease();
}

//  --------------------------------------------------------------------------
//  CLogonStatusHost_Create
//
//  Arguments:  riid    =   Class GUID to QI to return.
//              ppv     =   Interface returned.
//
//  Returns:    HRESULT
//
//  Purpose:    Creates the CLogonStatusHost class and returns the specified
//              interface supported by the class to the caller.
//
//  History:    2000-05-10  vtan        created
//  --------------------------------------------------------------------------
STDAPI      CLogonStatusHost_Create (REFIID riid, void** ppvObj)

{
    HRESULT             hr;
    CLogonStatusHost*   pLogonStatusHost;

    hr = E_OUTOFMEMORY;
    pLogonStatusHost = new CLogonStatusHost;
    if (pLogonStatusHost != NULL)
    {
        hr = pLogonStatusHost->QueryInterface(riid, ppvObj);
        pLogonStatusHost->Release();
    }
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\cuser.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       User.cpp
//
//  Contents:   implementation of CLogonUser
//
//----------------------------------------------------------------------------

#include "priv.h"

#include "resource.h"
#include "UserOM.h"
#include <lmaccess.h>   // for NetUserSetInfo & structures
#include <lmapibuf.h>   // for NetApiBufferFree
#include <lmerr.h>      // for NERR_Success
#include <ntlsa.h>      // for LsaOpenPolicy, etc.
#include <sddl.h>       // for ConvertSidToStringSid
#include <tchar.h>      // for _TEOF
#include "LogonIPC.h"
#include "ProfileUtil.h"
#include <MSGinaExports.h>
#include <msshrui.h>    // for IsFolderPrivateForUser, SetFolderPermissionsForSharing
#include <winsta.h>     // for WinStationEnumerate, etc.
#include <ccstock.h>

#include <passrec.h>    // PRQueryStatus, dpapi.lib


typedef struct
{
    SID sid;            // contains 1 subauthority
    DWORD dwSubAuth;    // 2nd subauthority
} _ALIAS_SID;

#define DECLARE_ALIAS_SID(rid)    {{SID_REVISION,2,SECURITY_NT_AUTHORITY,{SECURITY_BUILTIN_DOMAIN_RID}},(rid)}

struct
{
    _ALIAS_SID sid;
    LPCWSTR szDefaultGroupName;
    WCHAR szActualGroupName[GNLEN + sizeof('\0')];
} g_groupname_map [] =
{
    // in ascending order of privilege
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_GUESTS),      L"Guests",         L"" },
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_USERS),       L"Users",          L"" },
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_POWER_USERS), L"Power Users",    L"" },
    { DECLARE_ALIAS_SID(DOMAIN_ALIAS_RID_ADMINS),      L"Administrators", L"" }
};

void _InitializeGroupNames()
{
    int i;

    for (i = 0; i < ARRAYSIZE(g_groupname_map); i++)
    {
        WCHAR szDomain[DNLEN + sizeof('\0')];
        DWORD dwNameSize = ARRAYSIZE(g_groupname_map[i].szActualGroupName);
        DWORD dwDomainSize = ARRAYSIZE(szDomain);
        SID_NAME_USE eUse;

        if (L'\0' == g_groupname_map[i].szActualGroupName[0] &&
            !LookupAccountSidW(NULL,
                               &g_groupname_map[i].sid,
                               g_groupname_map[i].szActualGroupName,
                               &dwNameSize,
                               szDomain,
                               &dwDomainSize,
                               &eUse))
        {
            lstrcpynW(g_groupname_map[i].szActualGroupName,
                      g_groupname_map[i].szDefaultGroupName,
                      ARRAYSIZE(g_groupname_map[i].szActualGroupName));
        }
    }
}

//
// IUnknown Interface
//

ULONG CLogonUser::AddRef()
{
    _cRef++;
    return _cRef;
}


ULONG CLogonUser::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


HRESULT CLogonUser::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CLogonUser, IDispatch),
        QITABENT(CLogonUser, ILogonUser),
        {0},
    };

    return QISearch(this, qit, riid, ppvObj);
}


//
// IDispatch Interface
//

STDMETHODIMP CLogonUser::GetTypeInfoCount(UINT* pctinfo)
{ 
    return CIDispatchHelper::GetTypeInfoCount(pctinfo); 
}


STDMETHODIMP CLogonUser::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{ 
    return CIDispatchHelper::GetTypeInfo(itinfo, lcid, pptinfo); 
}


STDMETHODIMP CLogonUser::GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{ 
    return CIDispatchHelper::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid); 
}


STDMETHODIMP CLogonUser::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    return CIDispatchHelper::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
}


//
// ILogonUser Interface
//
STDMETHODIMP CLogonUser::get_setting(BSTR bstrName, VARIANT* pvarVal)
{
    return _UserSettingAccessor(bstrName, pvarVal, FALSE);
}


STDMETHODIMP CLogonUser::put_setting(BSTR bstrName, VARIANT varVal)
{
    return _UserSettingAccessor(bstrName, &varVal, TRUE);
}

STDMETHODIMP CLogonUser::get_isLoggedOn(VARIANT_BOOL* pbLoggedOn)
{
    HRESULT   hr = S_OK;
    CLogonIPC objLogon;

    if (NULL == pbLoggedOn)
        return E_POINTER;

    *pbLoggedOn = VARIANT_FALSE;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbLoggedOn = ( objLogon.IsUserLoggedOn(_szLoginName, _szDomain) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        TCHAR szUsername[UNLEN + sizeof('\0')];
        DWORD cch = ARRAYSIZE(szUsername);

        if (GetUserName(szUsername, &cch) && !StrCmp(szUsername, _szLoginName))
        {
            *pbLoggedOn = VARIANT_TRUE;
        }
        else
        {
            PLOGONID    pSessions;
            DWORD       cSessions;

            //  Iterate the sessions looking for active and disconnected sessions only.
            //  Then match the user name and domain (case INsensitive) for a result.

            if (WinStationEnumerate(SERVERNAME_CURRENT,
                                    &pSessions,
                                    &cSessions))
            {
                PLOGONID    pSession;
                DWORD       i;

                for (i = 0, pSession = pSessions; i < cSessions; ++i, ++pSession)
                {
                    if ((pSession->State == State_Active) || (pSession->State == State_Disconnected))
                    {
                        WINSTATIONINFORMATION   winStationInformation;
                        DWORD                   cb;

                        if (WinStationQueryInformation(SERVERNAME_CURRENT,
                                                       pSession->SessionId,
                                                       WinStationInformation,
                                                       &winStationInformation,
                                                       sizeof(winStationInformation),
                                                       &cb))
                        {
                            if ((0 == lstrcmpi(winStationInformation.UserName, _szLoginName)) &&
                                (0 == lstrcmpi(winStationInformation.Domain, _szDomain)))
                            {
                                *pbLoggedOn = VARIANT_TRUE;
                                break;
                            }
                        }
                    }
                }
                WinStationFreeMemory(pSessions);
            }
            else
            {
                DWORD   dwErrorCode;

                dwErrorCode = GetLastError();

                // We get RPC_S_INVALID_BINDING in safe mode, in which case
                // FUS is disabled, so we know the user isn't logged on.
                if (dwErrorCode != RPC_S_INVALID_BINDING)
                {
                    hr = HRESULT_FROM_WIN32(dwErrorCode);
                }
            }
        }
    }

    return hr;
}


STDMETHODIMP CLogonUser::get_passwordRequired(VARIANT_BOOL* pbPasswordRequired)
{
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbPasswordRequired = objLogon.TestBlankPassword(_szLoginName, _szDomain) ? VARIANT_FALSE: VARIANT_TRUE;
    }
    else
    {
        if (NULL == pbPasswordRequired)
            return E_POINTER;

        if ((BOOL)-1 == _bPasswordRequired)
        {
            BOOL    fResult;
            HANDLE  hToken;

            // Test for a blank password by trying to
            // logon the user with a blank password.

            fResult = LogonUser(_szLoginName,
                                NULL,
                                L"",
                                LOGON32_LOGON_INTERACTIVE,
                                LOGON32_PROVIDER_DEFAULT,
                                &hToken);
            if (fResult != FALSE)
            {
                TBOOL(CloseHandle(hToken));
                _bPasswordRequired = FALSE;
            }
            else
            {
                switch (GetLastError())
                {
                case ERROR_ACCOUNT_RESTRICTION:
                    // This means that blank password logons are disallowed, from
                    // which we infer that the password is blank.
                    _bPasswordRequired = FALSE;
                    break;

                case ERROR_LOGON_TYPE_NOT_GRANTED:
                    // Interactive logon was denied. We only get this if the
                    // password is blank, otherwise we get ERROR_LOGON_FAILURE.
                    _bPasswordRequired = FALSE;
                    break;

                case ERROR_LOGON_FAILURE:           // normal case (non-blank password)
                case ERROR_PASSWORD_MUST_CHANGE:    // expired password
                    _bPasswordRequired = TRUE;
                    break;

                default:
                    // We'll guess TRUE
                    _bPasswordRequired = TRUE;
                    break;
                }
            }
        }
        *pbPasswordRequired = (FALSE != _bPasswordRequired) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CLogonUser::get_interactiveLogonAllowed(VARIANT_BOOL *pbInteractiveLogonAllowed)
{
    HRESULT hr;
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbInteractiveLogonAllowed = objLogon.TestInteractiveLogonAllowed(_szLoginName, _szDomain) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
    }
    else
    {
        int     iResult;

        iResult = ShellIsUserInteractiveLogonAllowed(_szLoginName);
        if (iResult == -1)
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            *pbInteractiveLogonAllowed = (iResult != 0) ? VARIANT_TRUE : VARIANT_FALSE;
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT _IsGuestAccessMode(void)
{
    HRESULT hr = E_FAIL;

    if (IsOS(OS_PERSONAL))
    {
        hr = S_OK;
    }
    else if (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER))
    {
        DWORD dwValue = 0;
        DWORD cbValue = sizeof(dwValue);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SYSTEM\\CurrentControlSet\\Control\\LSA"),
                                        TEXT("ForceGuest"),
                                        NULL,
                                        &dwValue,
                                        &cbValue)
            && 1 == dwValue)
        {
            hr = S_OK;
        }
    }

    return hr;
}

HMODULE g_hmodNTShrUI = NULL;
static PFNISFOLDERPRIVATEFORUSER g_pfnIsFolderPrivateForUser = NULL;
static PFNSETFOLDERPERMISSIONSFORSHARING g_pfnSetFolderPermissionsForSharing = NULL;

void _LoadNTShrUI(void)
{
    if (NULL == g_hmodNTShrUI)
    {
        g_hmodNTShrUI = LoadLibraryW(L"ntshrui.dll");

        if (NULL != g_hmodNTShrUI)
        {
            g_pfnIsFolderPrivateForUser = (PFNISFOLDERPRIVATEFORUSER)GetProcAddress(g_hmodNTShrUI, "IsFolderPrivateForUser");
            g_pfnSetFolderPermissionsForSharing = (PFNSETFOLDERPERMISSIONSFORSHARING)GetProcAddress(g_hmodNTShrUI, "SetFolderPermissionsForSharing");
        }
    }
}

STDMETHODIMP CLogonUser::get_isProfilePrivate(VARIANT_BOOL* pbPrivate)
{
    HRESULT hr;

    if (NULL == pbPrivate)
        return E_POINTER;

    *pbPrivate = VARIANT_FALSE;

    // Only succeed if we are on Personal, or Professional with ForceGuest=1.
    hr = _IsGuestAccessMode();

    if (SUCCEEDED(hr))
    {
        // assume failure here
        hr = E_FAIL;

        _LookupUserSid();
        if (NULL != _pszSID)
        {
            TCHAR szPath[MAX_PATH];

            // Get the profile path
            PathCombine(szPath, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), _pszSID);
            DWORD cbData = sizeof(szPath);
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                            szPath,
                                            TEXT("ProfileImagePath"),
                                            NULL,
                                            szPath,
                                            &cbData))
            {
                DWORD dwPrivateType;

                _LoadNTShrUI();

                if (NULL != g_pfnIsFolderPrivateForUser &&
                    g_pfnIsFolderPrivateForUser(szPath, _pszSID, &dwPrivateType, NULL))
                {
                    // Note that we return E_FAIL for FAT volumes
                    if (0 == (dwPrivateType & IFPFU_NOT_NTFS))
                    {
                        if (dwPrivateType & IFPFU_PRIVATE)
                        {
                            *pbPrivate = VARIANT_TRUE;
                        }

                        hr = S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CLogonUser::makeProfilePrivate(VARIANT_BOOL bPrivate)
{
    HRESULT hr;

    // Only succeed if we are on Personal, or Professional with ForceGuest=1.
    hr = _IsGuestAccessMode();

    if (SUCCEEDED(hr))
    {
        // assume failure here
        hr = E_FAIL;

        _LookupUserSid();
        if (NULL != _pszSID)
        {
            TCHAR szPath[MAX_PATH];

            // Get the profile path
            PathCombine(szPath, TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"), _pszSID);
            DWORD cbData = sizeof(szPath);
            if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                            szPath,
                                            TEXT("ProfileImagePath"),
                                            NULL,
                                            szPath,
                                            &cbData))
            {
                _LoadNTShrUI();

                if (NULL != g_pfnSetFolderPermissionsForSharing &&
                    g_pfnSetFolderPermissionsForSharing(szPath, _pszSID, (VARIANT_TRUE == bPrivate) ? 0 : 1, NULL))
                {
                    hr = S_OK;
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CLogonUser::logon(BSTR pbstrPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;
    CLogonIPC   objLogon;
    TCHAR   szPassword[PWLEN + sizeof('\0')];

    if (pbstrPassword)
        lstrcpyn(szPassword, pbstrPassword, ARRAYSIZE(szPassword));
    else
        szPassword[0] = 0;
        
    if (!objLogon.IsLogonServiceAvailable())
    {
        *pbRet = VARIANT_FALSE;
        return S_OK;
    }

    if (objLogon.LogUserOn (_szLoginName, _szDomain, szPassword))
        *pbRet = VARIANT_TRUE;
    else
        *pbRet = VARIANT_FALSE;


    if (*pbRet)
    {
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


STDMETHODIMP CLogonUser::logoff(VARIANT_BOOL* pbRet)
{
    HRESULT     hr;
    CLogonIPC   objLogon;

    if (objLogon.IsLogonServiceAvailable())
    {
        *pbRet = ( objLogon.LogUserOff(_szLoginName, _szDomain) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else
    {
        *pbRet = ( ExitWindowsEx(EWX_LOGOFF, 0) ) ? VARIANT_TRUE : VARIANT_FALSE;
    }

    hr = S_OK;

    return hr;
}


// Borrowed from msgina
BOOL IsAutologonUser(LPCTSTR szUser, LPCTSTR szDomain)
{
    BOOL fIsUser = FALSE;
    HKEY hkey = NULL;
    TCHAR szAutologonUser[UNLEN + sizeof('\0')];
    TCHAR szAutologonDomain[DNLEN + sizeof('\0')];
    TCHAR szTempDomainBuffer[DNLEN + sizeof('\0')];
    DWORD cbBuffer;
    DWORD dwType;

    *szTempDomainBuffer = 0;

    // Domain may be a empty string. If this is the case...
    if (0 == *szDomain)
    {
        DWORD cchBuffer;

        // We really mean the local machine name
        // Point to our local buffer
        szDomain = szTempDomainBuffer;
        cchBuffer = ARRAYSIZE(szTempDomainBuffer);

        GetComputerName(szTempDomainBuffer, &cchBuffer);
    }

    // See if the domain and user name
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hkey))
    {
        // Check the user name
        cbBuffer = sizeof (szAutologonUser);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("DefaultUserName"), 0, &dwType, (LPBYTE)szAutologonUser, &cbBuffer))
        {
            // Does it match?
            if (0 == lstrcmpi(szAutologonUser, szUser))
            {
                // Yes. Now check domain
                cbBuffer = sizeof(szAutologonDomain);
                if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("DefaultDomainName"), 0, &dwType, (LPBYTE)szAutologonDomain, &cbBuffer))
                {
                    // Make sure domain matches
                    if (0 == lstrcmpi(szAutologonDomain, szDomain))
                    {
                        // Success - the users match
                        fIsUser = TRUE;
                    }
                }
            }
        }

        RegCloseKey(hkey);
    }

    return fIsUser;
}

// Borrowed from msgina
NTSTATUS SetAutologonPassword(LPCWSTR szPassword)
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_HANDLE LsaHandle = NULL;
    UNICODE_STRING SecretName;
    UNICODE_STRING SecretValue;

    InitializeObjectAttributes(&ObjectAttributes, NULL, 0L, (HANDLE)NULL, NULL);

    Status = LsaOpenPolicy(NULL, &ObjectAttributes, POLICY_CREATE_SECRET, &LsaHandle);
    if (!NT_SUCCESS(Status))
        return Status;

    RtlInitUnicodeString(&SecretName, L"DefaultPassword");
    RtlInitUnicodeString(&SecretValue, szPassword);

    Status = LsaStorePrivateData(LsaHandle, &SecretName, &SecretValue);
    LsaClose(LsaHandle);

    return Status;
}

STDMETHODIMP CLogonUser::changePassword(VARIANT varNewPassword, VARIANT varOldPassword, VARIANT_BOOL* pbRet)
{
    HRESULT hr;

    if (VT_BSTR == varNewPassword.vt && VT_BSTR == varOldPassword.vt)
    {
        TCHAR szUsername[UNLEN + sizeof('\0')];
        DWORD cch = ARRAYSIZE(szUsername);
        NET_API_STATUS  nasRet;
        USER_MODALS_INFO_0 *pumi0 = NULL;

        LPWSTR pszNewPassword = varNewPassword.bstrVal ? varNewPassword.bstrVal : L"\0";

        // We used to create accounts with UF_PASSWD_NOTREQD, and we still do
        // when password policy is enabled.  If UF_PASSWD_NOTREQD is set, then
        // the below code will succeed even with password policy is enabled,
        // so do a minimal policy check here.

        nasRet = NetUserModalsGet(NULL, 0, (LPBYTE*)&pumi0);
        if (nasRet == NERR_Success && pumi0 != NULL)
        {
            if ((DWORD)lstrlen(pszNewPassword) < pumi0->usrmod0_min_passwd_len)
            {
                nasRet = NERR_PasswordTooShort;
            }
            NetApiBufferFree(pumi0);
        }

        if (nasRet == NERR_Success)
        {
            if (GetUserName(szUsername, &cch) && !StrCmp(szUsername, _szLoginName))
            {
                // This is the case of a user changing their own password.
                // Both passwords must be provided to effect the change.

                LPCWSTR pszOldPassword = varOldPassword.bstrVal ? varOldPassword.bstrVal : L"\0";

                nasRet = NetUserChangePassword(NULL,            // Local machine
                                               _szLoginName,    // name of the person to change
                                               pszOldPassword,  // old password
                                               pszNewPassword); // new password
            }
            else
            {
                // This is the case of an admin changing someone else's password.
                // As an administrator they don't need to enter the old password.

                USER_INFO_1003 usri1003 = { pszNewPassword };

                nasRet = NetUserSetInfo(NULL,                   // local machine
                                        _szLoginName,           // name of the person to change
                                        1003,                   // structure level
                                        (LPBYTE)&usri1003,      // the update info
                                        NULL);                  // don't care
            }

            if (nasRet == NERR_Success)
            {
                // If this is the default user for autologon, delete the cleartext
                // password from the registry and save the new password.

                if (IsAutologonUser(_szLoginName, _szDomain))
                {
                    SHDeleteValue(HKEY_LOCAL_MACHINE,
                                  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\WinLogon"),
                                  TEXT("DefaultPassword"));
                    SetAutologonPassword(pszNewPassword);
                }
                
                // Make an attempt to remove UF_PASSWD_NOTREQD if it's
                // currently set. Ignore errors since we already changed
                // the password above.

                USER_INFO_1008 *pusri1008;
                if (NERR_Success == NetUserGetInfo(NULL, _szLoginName, 1008, (LPBYTE*)&pusri1008))
                {
                    if (pusri1008->usri1008_flags & UF_PASSWD_NOTREQD)
                    {
                        pusri1008->usri1008_flags &= ~UF_PASSWD_NOTREQD;
                        NetUserSetInfo(NULL, _szLoginName, 1008, (LPBYTE)pusri1008, NULL);
                    }
                    NetApiBufferFree(pusri1008);
                }
            }
        }

        hr = HRESULT_FROM_WIN32(nasRet);

        if (SUCCEEDED(hr))
        {
            _bPasswordRequired = !(L'\0' == *pszNewPassword);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    *pbRet = ( SUCCEEDED(hr) ) ? VARIANT_TRUE : VARIANT_FALSE;

    return hr;
}


STDAPI CLogonUser_Create(REFIID riid, void** ppvObj)
{
    return CLogonUser::Create(TEXT(""), TEXT(""), TEXT(""), riid, ppvObj);
}            


HRESULT CLogonUser::Create(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain, REFIID riid, LPVOID* ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CLogonUser* pUser = new CLogonUser(pszLoginName, pszFullName, pszDomain);

    if (pUser)
    {
        hr = pUser->QueryInterface(riid, ppv);
        pUser->Release();
    }

    return hr;
}


CLogonUser::CLogonUser(LPCTSTR pszLoginName,
                       LPCTSTR pszFullName,
                       LPCTSTR pszDomain)
  : _cRef(1), CIDispatchHelper(&IID_ILogonUser, &LIBID_SHGINALib),
    _strDisplayName(NULL), _strPictureSource(NULL), _strDescription(NULL),
    _strHint(NULL), _iPrivilegeLevel(-1), _pszSID(NULL),
    _bPasswordRequired((BOOL)-1)
{
    _InitializeGroupNames();

    lstrcpyn(_szLoginName, pszLoginName, ARRAYSIZE(_szLoginName));
    lstrcpyn(_szDomain, pszDomain, ARRAYSIZE(_szDomain));

    if (pszFullName)
        _strDisplayName = SysAllocString(pszFullName);

    // Use the EOF marker to indicate an uninitialized string
    _szPicture[0] = _TEOF;

    DllAddRef();
}


CLogonUser::~CLogonUser()
{
    SysFreeString(_strDisplayName);
    SysFreeString(_strPictureSource);
    SysFreeString(_strDescription);
    SysFreeString(_strHint);

    if (_pszSID) LocalFree(_pszSID);

    ASSERT(_cRef == 0);
    DllRelease();
}


typedef HRESULT (CLogonUser::*PFNPUT)(VARIANT);
typedef HRESULT (CLogonUser::*PFNGET)(VARIANT *);

struct SETTINGMAP
{
    LPCWSTR szSetting;
    PFNGET  pfnGet;
    PFNPUT  pfnPut;
};

#define MAP_SETTING(x)          { L#x, CLogonUser::_Get##x, CLogonUser::_Put##x }
#define MAP_SETTING_GET_ONLY(x) { L#x, CLogonUser::_Get##x, NULL                }
#define MAP_SETTING_PUT_ONLY(x) { L#x, NULL,                CLogonUser::_Put##x }

// _UserSettingAccessor
//
// bstrName - name of the setting you widh to access
// pvarVal  - the value of the named setting
// bPut     - if true the named setting will be updated
//            with the value pointed to by pvarVal
//            if false the named setting will be retrieved
//            in pvarVal
//
HRESULT CLogonUser::_UserSettingAccessor(BSTR bstrName, VARIANT *pvarVal, BOOL bPut)
{
    static const SETTINGMAP setting_map[] =
    {
        // in descending order of expected access frequecy
        MAP_SETTING(LoginName),
        MAP_SETTING(DisplayName),
        MAP_SETTING(Picture),
        MAP_SETTING_GET_ONLY(PictureSource),
        MAP_SETTING(AccountType),
        MAP_SETTING(Hint),
        MAP_SETTING_GET_ONLY(Domain),
        MAP_SETTING(Description),
        MAP_SETTING_GET_ONLY(SID),
        MAP_SETTING_GET_ONLY(UnreadMail)
    };

    HRESULT hr;
    INT     i;

    // start off assuming bogus setting name
    hr = E_INVALIDARG;

    for ( i = 0; i < ARRAYSIZE(setting_map); i++)
    {
        if ( StrCmpW(bstrName, setting_map[i].szSetting) == 0 )
        {

            // what do we want to do with the named setting ... 
            if ( bPut ) 
            {
                // ... change its value 
                PFNPUT pfnPut = setting_map[i].pfnPut;

                if ( pfnPut != NULL )
                {
                    hr = (this->*pfnPut)(*pvarVal);
                }
                else
                {
                    // we don't support updated the value for this setting
                    hr = E_FAIL;
                }
            }
            else
            {
                // ... retrieve its value
                PFNGET pfnGet = setting_map[i].pfnGet;

                if ( pfnGet != NULL )
                {
                    hr = (this->*pfnGet)(pvarVal);
                }
                else
                {
                    // we don't support retieving the value for this setting
                    hr = E_FAIL;
                }
            }

            break;
        }
    }

    return hr;
}

HRESULT CLogonUser::_GetDisplayName(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strDisplayName)
    {
        PUSER_INFO_1011 pusri1011 = NULL;
        NET_API_STATUS nasRet;

        nasRet = NetUserGetInfo(NULL,                       // local machine
                                _szLoginName,               // whose information do we want
                                1011,                       // structure level
                                (LPBYTE*)&pusri1011);       // pointer to the structure we'll receive

        if ( nasRet == NERR_Success )
        {
            _strDisplayName = SysAllocString(pusri1011->usri1011_full_name);
            NetApiBufferFree(pusri1011);
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strDisplayName);

    return S_OK;
}


HRESULT CLogonUser::_PutDisplayName(VARIANT var)
{
    HRESULT hr;

    if ( var.vt == VT_BSTR )
    {
        USER_INFO_1011 usri1011;
        NET_API_STATUS nasRet;

        if ( var.bstrVal )
        {
            usri1011.usri1011_full_name = var.bstrVal;
        }
        else
        {
            // OK to have emply string as display name
            usri1011.usri1011_full_name = L"\0";
        }

        nasRet = NetUserSetInfo(NULL,                       // local machine
                                _szLoginName,               // name of the person to change
                                1011,                       // structure level
                                (LPBYTE)&usri1011,          // the update info
                                NULL);                      // don't care

        if ( nasRet == NERR_Success )
        {
            // DisplayName was successfully changed. Remember to update our
            // local copy
            SysFreeString(_strDisplayName);
            _strDisplayName = SysAllocString(usri1011.usri1011_full_name);

            // Notify everyone that a user name has changed
            SHChangeDWORDAsIDList dwidl;
            dwidl.cb      = SIZEOF(dwidl) - SIZEOF(dwidl.cbZero);
            dwidl.dwItem1 = SHCNEE_USERINFOCHANGED;
            dwidl.dwItem2 = 0;
            dwidl.cbZero  = 0;
            SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_FLUSH | SHCNF_FLUSHNOWAIT, (LPCITEMIDLIST)&dwidl, NULL);

            hr = S_OK;
        }
        else
        {
            // insufficient privileges?
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetLoginName(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szLoginName);

    return S_OK;
}


HRESULT CLogonUser::_PutLoginName(VARIANT var)
{
    HRESULT hr;

    if ( (var.vt == VT_BSTR) && (var.bstrVal) && (*var.bstrVal) )
    {
        if (_szLoginName[0] == TEXT('\0'))
        {
            // We haven't been initialized yet. Initialize to the given name.
            lstrcpyn(_szLoginName, var.bstrVal, ARRAYSIZE(_szLoginName));
            hr = S_OK;
        }
        else
        {
            USER_INFO_0 usri0;
            NET_API_STATUS nasRet;

            usri0.usri0_name = var.bstrVal;
            nasRet = NetUserSetInfo(NULL,                       // local machine
                                    _szLoginName,               // name of the person to change
                                    0,                          // structure level
                                    (LPBYTE)&usri0,             // the update info
                                    NULL);                      // don't care

            if ( nasRet == NERR_Success )
            {
                // We should also rename the user's picture file to match
                // their new LoginName
                if (_TEOF == _szPicture[0])
                {
                    // This requires _szLoginName to still have the old name,
                    // so do it before updating _szLoginName below.
                    _InitPicture();
                }

                if (TEXT('\0') != _szPicture[0])
                {
                    TCHAR  szNewPicture[ARRAYSIZE(_szPicture)];
                    LPTSTR szFileName;
                    LPTSTR szFileExt;

                    szFileName = PathFindFileName(&_szPicture[7]);
                    szFileExt  = PathFindExtension(szFileName);

                    lstrcpyn(szNewPicture, _szPicture, (int)((szFileName - _szPicture) + 1));
                    lstrcatn(szNewPicture, usri0.usri0_name, ARRAYSIZE(szNewPicture));
                    lstrcatn(szNewPicture, szFileExt, ARRAYSIZE(szNewPicture));

                    if ( MoveFileEx(&_szPicture[7], &szNewPicture[7], MOVEFILE_REPLACE_EXISTING) )
                    {
                        lstrcpyn(_szPicture, szNewPicture, ARRAYSIZE(_szPicture));
                    }
                    else
                    {
                        // Give up and just try to delete the old picture
                        // (otherwise it will be abandoned).
                        DeleteFile(&_szPicture[7]);
                        _szPicture[0] = _TEOF;
                    }
                }

                // LoginName was successfully changed. Remember to update our
                // local copy
                lstrcpyn(_szLoginName, usri0.usri0_name, ARRAYSIZE(_szLoginName));
                hr = S_OK;
            }
            else
            {
                // insufficient privileges?
                hr = HRESULT_FROM_WIN32(nasRet);
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetDomain(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szDomain);

    return S_OK;
}


HRESULT CLogonUser::_GetPicture(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (_TEOF == _szPicture[0])
    {
        _InitPicture();
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_szPicture);

    return S_OK;
}


HRESULT CLogonUser::_PutPicture(VARIANT var)
{
    HRESULT hr;

    if ( (var.vt == VT_BSTR) && (var.bstrVal) && (*var.bstrVal) )
    {
        // Passed a string which is not NULL and not empty

        TCHAR szNewPicturePath[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szNewPicturePath);

        // get the path of the image we want to copy
        if ( PathIsURL(var.bstrVal) )
        {
            PathCreateFromUrl(var.bstrVal, szNewPicturePath, &dwSize, NULL);
        }
        else
        {
            lstrcpyn(szNewPicturePath, var.bstrVal, ARRAYSIZE(szNewPicturePath));
        }

        // REVIEW (phellar) : we build the URL string ourself so we know it's of the form,
        //                    file://<path>, the path starts on the 7th character.

        if ( _TEOF == _szPicture[0] || StrCmpI(szNewPicturePath, &_szPicture[7]) != 0 )
        {
            hr = _SetPicture(szNewPicturePath);
        }
        else
        {
            // Src and Dest paths are the same

            // nothing to do
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CLogonUser::_GetPictureSource(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strPictureSource)
    {
        TCHAR szHintKey[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD dwSize = 0;

        PathCombine(szHintKey, c_szRegRoot, _szLoginName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        szHintKey,
                                        c_szPictureSrcVal,
                                        &dwType,
                                        NULL,
                                        &dwSize)
            && REG_SZ == dwType && dwSize > 0)
        {
            _strPictureSource = SysAllocStringLen(NULL, dwSize/sizeof(TCHAR));
            if (NULL != _strPictureSource)
            {
                if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                                szHintKey,
                                                c_szPictureSrcVal,
                                                NULL,
                                                (LPVOID)_strPictureSource,
                                                &dwSize))
                {
                    SysFreeString(_strPictureSource);
                    _strPictureSource = NULL;
                }
            }
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strPictureSource);

    return S_OK;
}

HRESULT CLogonUser::_GetDescription(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strDescription)
    {
        NET_API_STATUS nasRet;
        USER_INFO_1007 *pusri1007;

        nasRet = NetUserGetInfo(NULL,                       // local machine
                                _szLoginName,               // whose information do we want
                                1007,                       // structure level
                                (LPBYTE*)&pusri1007);       // pointer to the structure we'll receive

        if ( nasRet == NERR_Success )
        {
            _strDescription = SysAllocString(pusri1007->usri1007_comment);
            NetApiBufferFree(pusri1007);
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strDescription);

    return S_OK;
}


HRESULT CLogonUser::_PutDescription(VARIANT var)
{
    HRESULT        hr;

    if ( var.vt == VT_BSTR )
    {
        USER_INFO_1007 usri1007;
        NET_API_STATUS nasRet;

        if ( var.bstrVal )
        {
            usri1007.usri1007_comment = var.bstrVal;
        }
        else
        {
            // OK to have emply string as a description 
            usri1007.usri1007_comment = L"\0";
        }

        nasRet = NetUserSetInfo(NULL,                       // local machine
                                _szLoginName,               // name of the person to change
                                1007,                       // structure level
                                (LPBYTE)&usri1007,          // the update info
                                NULL);                      // don't care

        if ( nasRet == NERR_Success )
        {
            // Description was successfully changed. Remember to update our
            // local copy
            SysFreeString(_strDescription);
            _strDescription = SysAllocString(usri1007.usri1007_comment);
            hr = S_OK;
        }
        else
        {
            // insufficient privileges?
            hr = HRESULT_FROM_WIN32(nasRet);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_GetHint(VARIANT* pvar)
{
    if (NULL == pvar)
        return E_POINTER;

    if (NULL == _strHint)
    {
        TCHAR szHintKey[MAX_PATH];
        DWORD dwType = REG_SZ;
        DWORD dwSize = 0;

        PathCombine(szHintKey, c_szRegRoot, _szLoginName);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE,
                                        szHintKey,
                                        NULL,
                                        &dwType,
                                        NULL,
                                        &dwSize)
            && REG_SZ == dwType && dwSize > 0 && dwSize < 512)
        {
            _strHint = SysAllocStringLen(NULL, dwSize/sizeof(TCHAR));
            if (NULL != _strHint)
            {
                if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                                szHintKey,
                                                NULL,
                                                NULL,
                                                (LPVOID)_strHint,
                                                &dwSize))
                {
                    SysFreeString(_strHint);
                    _strHint = NULL;
                }
            }
        }
    }

    pvar->vt = VT_BSTR;
    pvar->bstrVal = SysAllocString(_strHint);

    return S_OK;
}


HRESULT CLogonUser::_PutHint(VARIANT var)
{
    HRESULT hr;

    if ( var.vt == VT_BSTR )
    {
        DWORD dwErr;
        TCHAR *pszHint;
        HKEY  hkUserHint;
        
        if (var.bstrVal)
        {
            pszHint = var.bstrVal;
        }
        else
        {
            pszHint = TEXT("\0");
        }

        dwErr = _OpenUserHintKey(KEY_SET_VALUE, &hkUserHint);

        if ( dwErr == ERROR_SUCCESS )
        {
            DWORD cbData = lstrlen(pszHint) * sizeof(TCHAR) + sizeof(TEXT('\0'));
            dwErr = RegSetValueEx(hkUserHint,
                                  NULL,
                                  0,
                                  REG_SZ,
                                  (LPBYTE)pszHint,
                                  cbData);
            RegCloseKey(hkUserHint);
        }

        if ( dwErr == ERROR_SUCCESS )
        {
            // Hint was successfully changed. Remember to update our local copy
            SysFreeString(_strHint);
            _strHint = SysAllocString(pszHint);
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(dwErr);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CLogonUser::_GetAccountType(VARIANT* pvar)
{
    HRESULT hr;

    hr = E_FAIL;

    if (pvar)
    {
        if (-1 == _iPrivilegeLevel)
        {
            NET_API_STATUS nasRet;
            PLOCALGROUP_INFO_0 plgi0;
            DWORD dwEntriesRead;
            DWORD dwEntriesTotal;

            nasRet = NetUserGetLocalGroups(
                        NULL,
                        _szLoginName,
                        0,
                        0,
                        (LPBYTE *)&plgi0,
                        MAX_PREFERRED_LENGTH,
                        &dwEntriesRead,
                        &dwEntriesTotal);

            if ( nasRet == NERR_Success )
            {
                // make sure we read all the groups
                ASSERT(dwEntriesRead == dwEntriesTotal)

                INT i, j, iMostPrivileged;

                for (i = 0, iMostPrivileged = 0; i < (INT)dwEntriesRead; i++)
                {
                    for (j = ARRAYSIZE(g_groupname_map)-1; j > 0; j--)
                    {
                        if ( lstrcmpiW(plgi0[i].lgrpi0_name, g_groupname_map[j].szActualGroupName) == 0 )
                        {
                            break;
                        }
                    }

                    iMostPrivileged = (iMostPrivileged > j) ? iMostPrivileged : j;
                }

                _iPrivilegeLevel = iMostPrivileged;

                nasRet = NetApiBufferFree((LPVOID)plgi0);
            }
            hr = HRESULT_FROM_WIN32(nasRet);
        }

        if (-1 != _iPrivilegeLevel)
        {
            pvar->vt = VT_I4;
            pvar->lVal = _iPrivilegeLevel;
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_PutAccountType(VARIANT var)
{
    HRESULT hr;

    hr = VariantChangeType(&var, &var, 0, VT_I4);

    if (SUCCEEDED(hr))
    {
        if (var.lVal < 0 || var.lVal >= ARRAYSIZE(g_groupname_map))
        {
            hr = E_INVALIDARG;
        }
        else if (var.lVal != _iPrivilegeLevel)
        {
            NET_API_STATUS nasRet;
            TCHAR szDomainAndName[256];
            LOCALGROUP_MEMBERS_INFO_3 lgrmi3;

            // First add the user to their new group

            wnsprintf(szDomainAndName, 
                      ARRAYSIZE(szDomainAndName), 
                      TEXT("%s\\%s"),
                      _szDomain,
                      _szLoginName);

            lgrmi3.lgrmi3_domainandname = szDomainAndName;

            nasRet = NetLocalGroupAddMembers(
                        NULL,
                        g_groupname_map[var.lVal].szActualGroupName,
                        3,
                        (LPBYTE)&lgrmi3,
                        1);

            // If we were successful in adding to the group or 
            // they were already in the group ...
            if ( nasRet == NERR_Success || nasRet == ERROR_MEMBER_IN_ALIAS )
            {
                // remember the new privilege level
                _iPrivilegeLevel = var.lVal;

                // remove them from all more-privileged groups

                for (int i = var.lVal+1; i < ARRAYSIZE(g_groupname_map); i++)
                {
                    // "Power Users" doesn't exist on Personal, so this will
                    // fail sometimes.

                    NetLocalGroupDelMembers(
                        NULL,
                        g_groupname_map[i].szActualGroupName,
                        3,
                        (LPBYTE)&lgrmi3,
                        1);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(nasRet);
            }
        }
    }

    return hr;
}

HRESULT CLogonUser::_LookupUserSid()
{
    HRESULT hr;

    if (NULL == _pszSID)
    {
        BYTE rgSidBuffer[sizeof(SID) + (SID_MAX_SUB_AUTHORITIES-1)*sizeof(ULONG)];
        PSID pSid = (PSID)rgSidBuffer;
        DWORD cbSid = sizeof(rgSidBuffer);
        TCHAR szDomainName[MAX_PATH];
        DWORD cbDomainName = ARRAYSIZE(szDomainName);
        SID_NAME_USE snu;

        if (LookupAccountName(
                        (TEXT('\0') != _szDomain[0]) ? _szDomain : NULL,
                        _szLoginName,
                        pSid,
                        &cbSid,
                        szDomainName,
                        &cbDomainName,
                        &snu))
        {
            ConvertSidToStringSid(pSid, &_pszSID);
        }
    }

    if (NULL == _pszSID)
    {
        DWORD dwErr = GetLastError();
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    else
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CLogonUser::_GetSID(VARIANT* pvar)
{
    HRESULT hr;

    if (pvar)
    {
        hr = _LookupUserSid();

        if (NULL != _pszSID)
        {
            pvar->vt = VT_BSTR;
            pvar->bstrVal = SysAllocString(_pszSID);
            hr = pvar->bstrVal ? S_OK : E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

DWORD   CLogonUser::_GetExpiryDays (HKEY hKeyCurrentUser)

{
    DWORD   dwDays;
    DWORD   dwDataType;
    DWORD   dwData;
    DWORD   dwDataSize;
    HKEY    hKey;

    static  const TCHAR     s_szBaseKeyName[]               =   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\UnreadMail");
    static  const TCHAR     s_szMessageExpiryValueName[]    =   TEXT("MessageExpiryDays");

    dwDays = 3;
    if (RegOpenKeyEx(hKeyCurrentUser,
                     s_szBaseKeyName,
                     0,
                     KEY_QUERY_VALUE,
                     &hKey) == ERROR_SUCCESS)
    {
        dwDataSize = sizeof(dwData);
        if ((RegQueryValueEx(hKey,
                             s_szMessageExpiryValueName,
                             NULL,
                             &dwDataType,
                             reinterpret_cast<LPBYTE>(&dwData),
                             &dwDataSize) == ERROR_SUCCESS) &&
            (dwDataType == REG_DWORD) &&
            (dwData <= 30))
        {
            dwDays = dwData;
        }
        TBOOL(RegCloseKey(hKey));
    }
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      s_szBaseKeyName,
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hKey))
    {
        dwDataSize = sizeof(dwData);
        if ((RegQueryValueEx(hKey,
                             s_szMessageExpiryValueName,
                             NULL,
                             &dwDataType,
                             reinterpret_cast<LPBYTE>(&dwData),
                             &dwDataSize) == ERROR_SUCCESS) &&
            (dwDataType == REG_DWORD) &&
            (dwData <= 30))
        {
            dwDays = dwData;
        }
        TBOOL(RegCloseKey(hKey));
    }
    return(dwDays);
}

STDMETHODIMP CLogonUser::getMailAccountInfo(UINT uiAccountIndex, VARIANT *pvarAccountName, UINT *pcUnreadMessages)
{
    HRESULT hr;

    DWORD   dwComputerNameSize;
    TCHAR   szComputerName[CNLEN + sizeof('\0')];

    hr = E_FAIL;

    //  Only do this for local computer accounts.

    dwComputerNameSize = ARRAYSIZE(szComputerName);
    if ((GetComputerName(szComputerName, &dwComputerNameSize) != FALSE) &&
        (lstrcmpi(szComputerName, _szDomain) == 0))
    {
        CUserProfile    profile(_szLoginName, _szDomain);

        if (static_cast<HKEY>(profile) != NULL)
        {
            DWORD   dwCount;
            TCHAR   szMailAccountName[100];

            hr = SHEnumerateUnreadMailAccounts(profile, uiAccountIndex, szMailAccountName, ARRAYSIZE(szMailAccountName));
            if (SUCCEEDED(hr))
            {
                if (pvarAccountName)
                {
                    pvarAccountName->vt = VT_BSTR;
                    pvarAccountName->bstrVal = SysAllocString(szMailAccountName);
                    hr = pvarAccountName->bstrVal ? S_OK : E_OUTOFMEMORY;
                }

                if (SUCCEEDED(hr) && pcUnreadMessages)
                {
                    FILETIME ft, ftCurrent;
                    SYSTEMTIME st;

                    BOOL ftExpired = false;
                    DWORD dwExpiryDays = _GetExpiryDays(profile);

                    hr = SHGetUnreadMailCount(profile, szMailAccountName, &dwCount, &ft, NULL, 0);
                    IncrementFILETIME(&ft, FT_ONEDAY * dwExpiryDays);
                    GetLocalTime(&st);
                    SystemTimeToFileTime(&st, &ftCurrent);

                    ftExpired = ((CompareFileTime(&ft, &ftCurrent) < 0) || (dwExpiryDays == 0));

                    if (SUCCEEDED(hr) && !ftExpired)
                    {
                        *pcUnreadMessages = dwCount;
                    }
                    else
                    {
                        *pcUnreadMessages = 0;
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT CLogonUser::_GetUnreadMail(VARIANT* pvar)
{
    HRESULT hr;

    if (pvar)
    {
        DWORD   dwComputerNameSize;
        TCHAR   szComputerName[CNLEN + sizeof('\0')];

        hr = E_FAIL;

        //  Only do this for local computer accounts.

        dwComputerNameSize = ARRAYSIZE(szComputerName);
        if ((GetComputerName(szComputerName, &dwComputerNameSize) != FALSE) &&
            (lstrcmpi(szComputerName, _szDomain) == 0))
        {
            CUserProfile    profile(_szLoginName, _szDomain);

            if (static_cast<HKEY>(profile) != NULL)
            {
                DWORD   dwCount;
                FILETIME ftFilter;
                SYSTEMTIME st;
                DWORD dwExpiryDays = _GetExpiryDays(profile);

                GetLocalTime(&st);
                SystemTimeToFileTime(&st, &ftFilter);
                DecrementFILETIME(&ftFilter, FT_ONEDAY * dwExpiryDays);

                hr = SHGetUnreadMailCount(profile, NULL, &dwCount, &ftFilter, NULL, 0);
                if (SUCCEEDED(hr) && (dwExpiryDays != 0))
                {
                    pvar->vt = VT_UI4;
                    pvar->uintVal = dwCount;
                }
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


HRESULT CLogonUser::_InitPicture()
{
    HRESULT hr;

    lstrcpyn(_szPicture, TEXT("file://"), ARRAYSIZE(_szPicture));
    hr = SHGetUserPicturePath(_szLoginName, SHGUPP_FLAG_CREATE, &_szPicture[7]);

    if (FAILED(hr))
    {
        _szPicture[0] = TEXT('\0');
    }

    return hr;
}


HRESULT CLogonUser::_SetPicture(LPCTSTR pszNewPicturePath)
{
    //  use shell32!SHSetUserPicturePath to set the user's
    //  picture path. If this is successful then update the
    //  _szPicture member variable.

    HRESULT hr = SHSetUserPicturePath(_szLoginName, 0, pszNewPicturePath);
    if ( S_OK == hr )
    {
        DWORD dwErr;
        HKEY  hkUserHint;

        SysFreeString(_strPictureSource);
        _strPictureSource = SysAllocString(pszNewPicturePath);

        dwErr = _OpenUserHintKey(KEY_SET_VALUE, &hkUserHint);

        if ( dwErr == ERROR_SUCCESS )
        {
            if (pszNewPicturePath)
            {
                DWORD cbData = lstrlen(pszNewPicturePath) * sizeof(TCHAR) + sizeof(TEXT('\0'));
                dwErr = RegSetValueEx(hkUserHint,
                                      c_szPictureSrcVal,
                                      0,
                                      REG_SZ,
                                      (LPBYTE)pszNewPicturePath,
                                      cbData);
            }
            else
            {
                dwErr = RegDeleteValue(hkUserHint, c_szPictureSrcVal);
            }

            RegCloseKey(hkUserHint);
        }

        lstrcpyn(_szPicture, TEXT("file://"), ARRAYSIZE(_szPicture));
        hr = SHGetUserPicturePath(_szLoginName, 0, &_szPicture[7]);

        if ( FAILED(hr) )
        {
            lstrcatn(_szPicture, pszNewPicturePath, ARRAYSIZE(_szPicture));
            hr = S_OK;
        }
    }

    return hr;
}


DWORD CLogonUser::_OpenUserHintKey(REGSAM sam, HKEY *phkey)
{
    DWORD dwErr;
    TCHAR szHintKey[MAX_PATH];

    // We have to store hint information under HKLM so the logon page can
    // access it, Also, we want to allow non-admins to change their own
    // hints, but non-admins can't write values under HKLM by default.
    //
    // The solution is to use subkeys rather than named values so we can
    // tweak the ACLs on a per-user basis.
    //
    // A non-admin user needs the ability to do 2 things:
    // 1. Create a hint subkey for themselves if one does not exist.
    // 2. Modify the hint contained in their subkey if one already exists.
    //
    // At install time, we set the ACL on the Hints key to allow
    // Authenticated Users KEY_CREATE_SUB_KEY access. Thus, a user is
    // able to create a hint for themselves if one doesn't exist.
    //
    // Immediately after creating a hint subkey, whether it was created
    // by the target user or an admin, we grant the target user
    // KEY_SET_VALUE access to the subkey. This ensures that a user can
    // modify their own hint no matter who created it for them.
    //
    // Note that we don't call RegCreateKeyEx or SHSetValue since we
    // don't want the key to be automatically created here.
    //
    // Note that admins are able to create and modify hints for any user,
    // but a non-admin is only able to create or modify their own hint.

    // First assume the hint already exists and just try to open it.
    PathCombine(szHintKey, c_szRegRoot, _szLoginName);
    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szHintKey,
                         0,
                         sam,
                         phkey);
    if ( dwErr == ERROR_FILE_NOT_FOUND )
    {
        HKEY hkHints;

        // The hint subkey doesn't exist yet for this user.
        // Try to create one.

        // Open the Hints key for KEY_CREATE_SUB_KEY
        dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             c_szRegRoot,
                             0,
                             KEY_CREATE_SUB_KEY,
                             &hkHints);
        if ( dwErr == ERROR_SUCCESS )
        {
            // Create a subkey for this user
            dwErr = RegCreateKeyEx(hkHints,
                                   _szLoginName,
                                   0,
                                   NULL,
                                   0,
                                   sam,
                                   NULL,
                                   phkey,
                                   NULL);
            if ( dwErr == ERROR_SUCCESS )
            {
                // Grant KEY_SET_VALUE access to the user so they can
                // change their own hint.
                _LookupUserSid();
                if (NULL != _pszSID)
                {
                    TCHAR szKey[MAX_PATH];
                    TCHAR szSD[MAX_PATH];

                    PathCombine(szKey, TEXT("MACHINE"), szHintKey);
                    wnsprintf(szSD,
                              ARRAYSIZE(szSD),
                              TEXT("D:(A;;0x2;;;%s)"),  // 0x2 = KEY_SET_VALUE
                              _pszSID);
                    SetDacl(szKey, SE_REGISTRY_KEY, szSD);
                }
            }
            RegCloseKey(hkHints);
        }
    }
    return dwErr;
}


STDMETHODIMP CLogonUser::get_isPasswordResetAvailable(VARIANT_BOOL* pbResetAvailable)
{
    DWORD dwResult;

    if (!pbResetAvailable)
        return E_POINTER;

    *pbResetAvailable = VARIANT_FALSE;

    if (0 == PRQueryStatus(NULL, _szLoginName, &dwResult))
    {
        if (0 == dwResult)
        {
            *pbResetAvailable = VARIANT_TRUE;
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\debug.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       debug.cpp
//
//  Contents:   #defines so we can include shell\inc\debug.h
//
//----------------------------------------------------------------------------
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "SHGINA"
#define SZ_MODULE           "SHGINA"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\resource.h ===
#ifndef RESOURCE_H 
#define RESOURCE_H 

#define IDS_LOGONUIMANIFEST     100
#define IDS_WINLOGONMANIFEST    101
#define IDS_DEFAULT_BACKUP_PATH 102

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       DllMain.cpp
//
//  Contents:   DllMain routines
//
//----------------------------------------------------------------------------

#include "priv.h"
#define DECL_CRTFREE
#include <crtfree.h>

// dll refrence count;
LONG g_cRef = 0;

// global hinstance
HINSTANCE g_hinst = 0;

extern HMODULE g_hmodNTShrUI;   // cuser.cpp

//
// DllAddRef increment dll refrence count
//
void DllAddRef(void)
{
    InterlockedIncrement(&g_cRef);
}


//
// DllRelease decrement dll refrence count
//
void DllRelease(void)
{
    LONG lRet;
    
    lRet = InterlockedDecrement(&g_cRef);
    ASSERT(lRet >= 0);

    if (0 == lRet)
    {
        HMODULE hmod = (HMODULE)InterlockedExchangePointer((PVOID*)&g_hmodNTShrUI, NULL);
        if (NULL != hmod)
        {
            FreeLibrary(hmod);
        }
    }
}



//
// DllGetClassObject
//
// OLE entry point.  Produces an IClassFactory for the indicated GUID.
//
// The artificial refcount inside DllGetClassObject helps to
// avoid the race condition described in DllCanUnloadNow.  It's
// not perfect, but it makes the race window much smaller.
//
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppvObj)
{
    HRESULT hr;

    DllAddRef();
    if (IsEqualIID(rclsid, CLSID_ShellLogonEnumUsers)               ||
        IsEqualIID(rclsid, CLSID_ShellLogonUser)                    || 
        IsEqualIID(rclsid, CLSID_ShellLocalMachine)                 ||
        IsEqualIID(rclsid, CLSID_ShellLogonStatusHost))
        //IsEqualIID(rclsid, CLSID_ShellLogonUserEnumNotifications)   ||
        //IsEqualIID(rclsid, CLSID_ShellLogonUserNotification))
    {
        hr = CSHGinaFactory_Create(rclsid, riid, ppvObj);
    }
    else
    {
        *ppvObj = NULL;
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    DllRelease();
    return hr;
}


//
// DllCanUnloadNow
//
// OLE entry point.  Fail iff there are outstanding refs.
//
// There is an unavoidable race condition between DllCanUnloadNow
// and the creation of a new IClassFactory:  Between the time we
// return from DllCanUnloadNow() and the caller inspects the value,
// another thread in the same process may decide to call
// DllGetClassObject, thus suddenly creating an object in this DLL
// when there previously was none.
//
// It is the caller's responsibility to prepare for this possibility;
// there is nothing we can do about it.
//
STDMETHODIMP DllCanUnloadNow()
{
    HRESULT hr;

    if (g_cRef == 0)
    {
        // refcount is zero, ok to unload
        hr = S_OK;
    }
    else
    {
        // still cocreated objects, dont unload
        hr = S_FALSE;
    }

    return hr;
}

#define OLD_USERS_AND_PASSWORD TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ControlPanel\\NameSpace\\{7A9D77BD-5403-11d2-8785-2E0420524153}")

//
// DllMain (attach/deatch) routine
//
STDAPI_(BOOL) DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    UNREFERENCED_PARAMETER(lpReserved);

    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:

            // HACKHACK (phellyar) Delete this registry key everytime we're loaded
            // to prevent the old users and password cpl from appearing in the
            // control panel. Since we're loaded by the welcome screen, we'll
            // be able to delete this key before a user ever gets a chance to open
            // the control panel, thereby ensuring the old cpl doesn't appear.
            RegDeleteKey(HKEY_LOCAL_MACHINE, OLD_USERS_AND_PASSWORD);
                         
            // Don't put it under #ifdef DEBUG
            CcshellGetDebugFlags();
            DisableThreadLibraryCalls(hinst);
            g_hinst = hinst;
            break;

        case DLL_PROCESS_DETACH:
        {
            ASSERTMSG(g_cRef == 0, "Dll ref count is not zero: g_cRef = %d", g_cRef);
            break;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\dllreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       DllReg.cpp
//
//  Contents:   automatic registration and unregistration
//
//----------------------------------------------------------------------------
#include "priv.h"
#include "resource.h"
#include <advpub.h> // for REGINSTALL
#include <sddl.h>   // for string security descriptor stuff
#include <shfusion.h>
#include <MSGinaExports.h>

#include <ntlsa.h>

// prototypes
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine);

//
// Calls the ADVPACK entry-point which executes an inf
// file section.
//
HRESULT CallRegInstall(HINSTANCE hinstFTP, LPSTR szSection)
{
    UNREFERENCED_PARAMETER(hinstFTP);

    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szThisDLL[MAX_PATH];

            // Get the location of this DLL from the HINSTANCE
            if (GetModuleFileNameA(HINST_THISDLL, szThisDLL, ARRAYSIZE(szThisDLL)))
            {
                STRENTRY seReg[] = {
                    {"THISDLL", szThisDLL },
                    { "25", "%SystemRoot%" },           // These two NT-specific entries
                    { "11", "%SystemRoot%\\system32" }, // must be at the end of the table
                };
                STRTABLE stReg = {ARRAYSIZE(seReg) - 2, seReg};

                hr = pfnri(HINST_THISDLL, szSection, &stReg);
            }
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


HRESULT UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    TCHAR szGuid[GUIDSTR_MAX];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szGuid, ARRAYSIZE(szGuid));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, MAXIMUM_ALLOWED, &hk) == ERROR_SUCCESS)
    {
        if (SHDeleteKey(hk, szGuid))
        {
            // success
            hr = S_OK;
        }
        RegCloseKey(hk);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}


HRESULT RegisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    ITypeLib* pTypeLib;
    WCHAR wszModuleName[MAX_PATH];

    // Load and register our type library.
    
    if (GetModuleFileNameW(HINST_THISDLL, wszModuleName, ARRAYSIZE(wszModuleName)))
    {
        hr = LoadTypeLib(wszModuleName, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library in case we had some old junk in the registry
            UnregisterTypeLibrary(piidLibrary);

            hr = RegisterTypeLib(pTypeLib, wszModuleName, NULL);
            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "RegisterTypeLibrary: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "RegisterTypeLibrary: LoadTypeLib failed (%x) on", hr);
        }
    } 

    return hr;
}


BOOL SetDacl(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszStringSD)
{
    BOOL bResult;
    PSECURITY_DESCRIPTOR pSD;

    bResult = ConvertStringSecurityDescriptorToSecurityDescriptor(pszStringSD,
                                                                  SDDL_REVISION_1,
                                                                  &pSD,
                                                                  NULL);
    if (bResult)
    {
        PACL pDacl;
        BOOL bPresent;
        BOOL bDefault;

        bResult = GetSecurityDescriptorDacl(pSD, &bPresent, &pDacl, &bDefault);
        if (bResult)
        {
            DWORD dwErr;

            dwErr = SetNamedSecurityInfo(pszTarget,
                                         seType,
                                         DACL_SECURITY_INFORMATION | UNPROTECTED_DACL_SECURITY_INFORMATION,
                                         NULL,
                                         NULL,
                                         pDacl,
                                         NULL);

            if (ERROR_SUCCESS != dwErr)
            {
                SetLastError(dwErr);
                bResult = FALSE;
            }
        }
        LocalFree(pSD);
    }

    return bResult;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL")); // keep advpack loaded across multiple calls to RegInstall

    hr = CallRegInstall(HINST_THISDLL, "ShellUserOMInstall");
    ASSERT(SUCCEEDED(hr));

    // Grant Authenticated Users the right to create subkeys under the Hints key.
    // This is so non-admins can change their own hint.
    SetDacl(TEXT("MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Hints"),
            SE_REGISTRY_KEY,
            TEXT("D:(A;;0x4;;;AU)")); // 0x4 = KEY_CREATE_SUB_KEY

    hr = RegisterTypeLibrary(&LIBID_SHGINALib);
    ASSERT(SUCCEEDED(hr));

    if (hinstAdvPack)
    {
        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


//
// This will be going away when we have resource based manifests
//
STDAPI SHSquirtManifest(HINSTANCE hInst, UINT uIdManifest, LPTSTR pszPath)
{
    HRESULT hr = E_FAIL;
    char szManifest[2048];

    if (LoadStringA(hInst, uIdManifest, szManifest, ARRAYSIZE(szManifest)))
    {
        HANDLE hFile;

        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        
        hFile = CreateFile(pszPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY, NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            DWORD dw = lstrlenA(szManifest) * sizeof(char);
            if (WriteFile(hFile, szManifest, dw, &dw, NULL))
            {
                hr = S_OK;
            }
            else
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
            }

            CloseHandle(hFile);
        }
    }

    return hr;
}


void DoFusion()
{
    // First, get the path to explorer.exe.
    TCHAR szManifest[MAX_PATH];

    GetSystemDirectory(szManifest, ARRAYSIZE(szManifest));     // e.g. c:\winnt\system32

    // Tack on logonui.exe.maniest

    StrCat(szManifest, TEXT("\\logonui.exe.manifest"));

    // Extract the fusion manifest from the resource.
    SHSquirtManifest(HINST_THISDLL, IDS_LOGONUIMANIFEST, szManifest);

    GetSystemDirectory(szManifest, ARRAYSIZE(szManifest));     // e.g. c:\winnt\system32

    // Tack on WindowsLogon.maniest

    StrCat(szManifest, TEXT("\\WindowsLogon.manifest"));

    // Extract the fusion manifest from the resource.
    SHSquirtManifest(HINST_THISDLL, IDS_WINLOGONMANIFEST, szManifest);

}
//
//  End going away....
//

//  --------------------------------------------------------------------------
//  IsLogonTypePresent
//
//  Arguments:  hKey    =   HKEY to HKLM\SW\MS\WINNT\CV\Winlogon.
//
//  Returns:    bool
//
//  Purpose:    Returns whether the value "LogonType" is present. This helps
//              determines upgrade cases.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsLogonTypePresent (HKEY hKey)

{
    DWORD   dwType, dwLogonType, dwLogonTypeSize;

    dwLogonTypeSize = sizeof(dwLogonType);
    return((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             TEXT("LogonType"),
                                             NULL,
                                             &dwType,
                                             reinterpret_cast<LPBYTE>(&dwLogonType),
                                             &dwLogonTypeSize)) &&
           (REG_DWORD == dwType));
}

//  --------------------------------------------------------------------------
//  IsDomainMember
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Is this machine a member of a domain? Use the LSA to get this
//              information.
//
//  History:    1999-09-14  vtan        created
//              2000-09-04  vtan        copied from msgina
//  --------------------------------------------------------------------------

bool    IsDomainMember (void)

{
    bool                            fResult;
    int                             iCounter;
    NTSTATUS                        status;
    OBJECT_ATTRIBUTES               objectAttributes;
    LSA_HANDLE                      lsaHandle;
    SECURITY_QUALITY_OF_SERVICE     securityQualityOfService;
    PPOLICY_DNS_DOMAIN_INFO         pDNSDomainInfo;

    fResult = false;
    securityQualityOfService.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    securityQualityOfService.ImpersonationLevel = SecurityImpersonation;
    securityQualityOfService.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    securityQualityOfService.EffectiveOnly = FALSE;
    InitializeObjectAttributes(&objectAttributes, NULL, 0, NULL, NULL);
    objectAttributes.SecurityQualityOfService = &securityQualityOfService;
    iCounter = 0;
    do
    {
        status = LsaOpenPolicy(NULL, &objectAttributes, POLICY_VIEW_LOCAL_INFORMATION, &lsaHandle);
        if (RPC_NT_SERVER_TOO_BUSY == status)
        {
            Sleep(10);
        }
    } while ((RPC_NT_SERVER_TOO_BUSY == status) && (++iCounter < 10));
    ASSERTMSG(iCounter < 10, "Abandoned advapi32!LsaOpenPolicy call - counter limit exceeded\r\n");
    if (NT_SUCCESS(status))
    {
        status = LsaQueryInformationPolicy(lsaHandle, PolicyDnsDomainInformation, reinterpret_cast<void**>(&pDNSDomainInfo));
        if (NT_SUCCESS(status) && (pDNSDomainInfo != NULL))
        {
            fResult = ((pDNSDomainInfo->DnsDomainName.Length != 0) ||
                       (pDNSDomainInfo->DnsForestName.Length != 0) ||
                       (pDNSDomainInfo->Sid != NULL));
            (NTSTATUS)LsaFreeMemory(pDNSDomainInfo);
        }
        (NTSTATUS)LsaClose(lsaHandle);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  IsDomainMembershipAttempted
//
//  Arguments:  hKey    =   HKEY to HKLM\SW\MS\WINNT\CV\Winlogon.
//
//  Returns:    bool
//
//  Purpose:    Returns whether a domain join was attempt (success or failure)
//              during network install.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsDomainMembershipAttempted (HKEY hKey)

{
    DWORD   dwType, dwRunNetAccessWizardType, dwRunNetAccessWizardTypeSize;

    dwRunNetAccessWizardTypeSize = sizeof(dwRunNetAccessWizardType);
    return((ERROR_SUCCESS == RegQueryValueEx(hKey,
                                             TEXT("RunNetAccessWizard"),
                                             NULL,
                                             &dwType,
                                             reinterpret_cast<LPBYTE>(&dwRunNetAccessWizardType),
                                             &dwRunNetAccessWizardTypeSize)) &&
           (REG_DWORD == dwType) &&
           ((NAW_PSDOMAINJOINED == dwRunNetAccessWizardType) || (NAW_PSDOMAINJOINFAILED == dwRunNetAccessWizardType)));
}

//  --------------------------------------------------------------------------
//  IsPersonal
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is personal.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsPersonal (void)

{
    return(IsOS(OS_PERSONAL) != FALSE);
}

//  --------------------------------------------------------------------------
//  IsProfessional
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is professional.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsProfessional (void)

{
    return(IsOS(OS_PROFESSIONAL) != FALSE);
}

//  --------------------------------------------------------------------------
//  IsServer
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Returns whether this product is server.
//
//  History:    2000-09-04  vtan        created
//  --------------------------------------------------------------------------

bool    IsServer (void)

{
    return(!IsPersonal() && !IsProfessional());
}

//  --------------------------------------------------------------------------
//  SetDefaultLogonType
//
//  Arguments:  ulWizardType    =   Type of network access configured during setup.
//
//  Returns:    <none>
//
//  Purpose:    Sets the default logon type based on network settings. In this case the
//              machine is still on a workgroup and therefore will have all
//              consumer UI enabled by default. Because join domain was
//              requested the logon type is set to classic GINA.
//
//  History:    2000-03-14  vtan        created
//              2000-07-24  vtan        turn on FUS by default
//              2000-09-04  vtan        moved from winlogon to shgina
//  --------------------------------------------------------------------------

void    SetDefaultLogonType (void)

{
    HKEY    hKeyWinlogon;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                                      0,
                                      KEY_QUERY_VALUE,
                                      &hKeyWinlogon))
    {

        //  Any of the following cause the logon type to be defaulted
        //  which means that the value is NOT written to the registry:
        //
        //  1.  Value already present (this is an upgrade).
        //  2.  Machine is a domain member (this is not supported).
        //  3.  Machine attempted to join a domain (this indicates security).
        //  4.  The product is a server
        //
        //  Otherwise the product is either personal or professional and
        //  the machine was joined to a workgroup or is a member of a workgroup
        //  and therefore requires the friendly UI.

        if (!IsLogonTypePresent(hKeyWinlogon) &&
            !IsDomainMember() &&
            !IsDomainMembershipAttempted(hKeyWinlogon) &&
            !IsServer())
        {
            MEMORYSTATUSEX  memoryStatusEx;

            TBOOL(ShellEnableFriendlyUI(TRUE));

            //  Multiple users used to be enabled when the friendly UI was
            //  enabled. However, on 64Mb machines the experience is
            //  unsatisfactory. Disable it on 64Mb or lower machines.

            memoryStatusEx.dwLength = sizeof(memoryStatusEx);
            GlobalMemoryStatusEx(&memoryStatusEx);
            TBOOL(ShellEnableMultipleUsers((memoryStatusEx.ullTotalPhys / (1024 * 1024) > 64)));
        }
        TW32(RegCloseKey(hKeyWinlogon));
    }
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;

    if (bInstall)
    {
        DoFusion();
        ShellInstallAccountFilterData();

#ifdef  _X86_
        SetDefaultLogonType();
#endif
    }

    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\makefile.inc ===
$(SELFREGNAME) : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln

shgina.rc : $(PROJECT_ROOT)\lib\$(O)\shgina.tlb $(SELFREGNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\logonipc.h ===
//  --------------------------------------------------------------------------
//  Module Name: LogonIPC.h
//
//  Copyright (c) 1999-2000, Microsoft Corporation
//
//  Class that implements communication between an external process and the
//  GINA logon dialog.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#ifndef     _LogonIPC_
#define     _LogonIPC_

//  --------------------------------------------------------------------------
//  CLogonIPC
//
//  Purpose:    This class handles sending messages to the GINA logon dialog
//              which provides logon services for an external process hosting
//              the UI for the logon. All string are unicode strings.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//              2000-03-09  vtan        added UI host failure
//  --------------------------------------------------------------------------

class   CLogonIPC
{
    private:
                            CLogonIPC (const CLogonIPC& copyObject);
        bool                operator == (const CLogonIPC& compareObject)    const;
        const CLogonIPC&    operator = (const CLogonIPC& assignObject);
    public:
                            CLogonIPC (void);
                            ~CLogonIPC (void);

        bool                IsLogonServiceAvailable (void);
        bool                IsUserLoggedOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                LogUserOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword);
        bool                LogUserOff (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestBlankPassword (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestInteractiveLogonAllowed (const WCHAR *pwszUsername, const WCHAR *pwszDomain);
        bool                TestEjectAllowed (void);
        bool                TestShutdownAllowed (void);
        bool                TurnOffComputer (void);
        bool                EjectComputer (void);
        bool                SignalUIHostFailure (void);
        bool                AllowExternalCredentials (void);
        bool                RequestExternalCredentials (void);
    private:
        void                PackageIdentification (const WCHAR *pwszUsername, const WCHAR *pwszDomain, void *pIdentification);
        bool                SendToLogonService (WORD wQueryType, void *pData, WORD wDataSize, bool fBlock);
        void                PostToLogonService (WORD wQueryType, void *pData, WORD wDataSize);
    private:
        int                 _iLogonAttemptCount;
        HWND                _hwndLogonService;
};

#endif  /*  _LogonIPC_  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\priv.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1998.
//
//  File:       priv.h
//
//  Contents:   precompiled header for shgina.dll
//
//----------------------------------------------------------------------------
#ifndef _PRIV_H_
#define _PRIV_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <oleauto.h>    // for IEnumVARIANT
#include <lmcons.h>     // for NET_API_STATUS

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <ccstock.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>

#include <shgina.h>     // our IDL generated header file

#include <commctrl.h>   // these are needed
#include <comctrlp.h>   // for HDPA

#include <shlwapi.h>    // these are needed
#include <shlwapip.h>   // for QISearch

#include <w4warn.h>

#include <msginaexports.h>

// dll ref counting functions
STDAPI_(void) DllAddRef(void);
STDAPI_(void) DllRelease(void);

// class factory helper function
HRESULT CSHGinaFactory_Create(REFCLSID rclsid, REFIID riid, LPVOID * ppvObj);

// helper for setting permissions on newly created files and reg keys
#include <aclapi.h>     // for SE_OBJECT_TYPE
BOOL SetDacl(LPTSTR pszTarget, SE_OBJECT_TYPE seType, LPCTSTR pszStringSD);


// global hinstance
extern HINSTANCE g_hinst;
#define HINST_THISDLL g_hinst

// global dll refrence count
extern LONG g_cRef;


#endif // _PRIV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\logonipc.cpp ===
//  --------------------------------------------------------------------------
//  Module Name: LogonIPC.cpp
//
//  Copyright (c) 1999, Microsoft Corporation
//
//  Class that implements communication between an external process and the
//  GINA logon dialog.
//
//  History:    1999-08-20  vtan        created
//              2000-01-31  vtan        moved from Neptune to Whistler
//  --------------------------------------------------------------------------

#include "priv.h"
#include "limits.h"
#include "LogonIPC.h"

#include "GinaIPC.h"

//  --------------------------------------------------------------------------
//  CLogonIPC::CLogonIPC
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Initializes the CLogonIPC class.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

CLogonIPC::CLogonIPC (void) :
    _iLogonAttemptCount(0),
    _hwndLogonService(NULL)

{
}

//  --------------------------------------------------------------------------
//  CLogonIPC::~CLogonIPC
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Releases any resources used by the CLogonIPC class.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

CLogonIPC::~CLogonIPC (void)

{
}

//  --------------------------------------------------------------------------
//  CLogonIPC::IsLogonServiceAvailable
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Presence or abscence.
//
//  Purpose:    Finds out if the window providing logon service in GINA is
//              available. The determination is not performed statically but
//              rather dynamically which allows this class to be hosted by
//              the actual window providing the service as well.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::IsLogonServiceAvailable (void)

{
    _hwndLogonService = FindWindow(NULL, TEXT("GINA Logon"));
    return(_hwndLogonService != NULL);
}

//  --------------------------------------------------------------------------
//  CLogonIPC::IsUserLoggedOn
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Presence or abscence.
//
//  Purpose:    Finds out if the given user is logged onto the system. You
//              may pass a NULL pwszDomain for the local machine.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::IsUserLoggedOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_QUERY_LOGGED_ON, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::LogUserOn
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//              pwszPassword    =   User password. This is passed clear text.
//                                  Once encoded the password buffer is
//                                  zeroed. This function owns the memory that
//                                  you pass in.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the user with the given credentials onto the
//              system. The password buffer is owned by this function for the
//              purpose of clearing it once encoded. Failed logon attempts
//              cause a counter to be incremented and a subsequent delay using
//              that counter is done to slow dictionary attacks.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::LogUserOn (const WCHAR *pwszUsername, const WCHAR *pwszDomain, WCHAR *pwszPassword)

{
    bool                    fResult;
    int                     iPasswordLength, iTruePasswordLength;
    UNICODE_STRING          passwordString;
    LOGONIPC_CREDENTIALS    logonIPCCredentials;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCCredentials.userID);

    //  Limit the password to 127 characters. RtlRunEncodeUnicodeString
    //  does not support strings greater than 127 characters.

    iTruePasswordLength = iPasswordLength = lstrlenW(pwszPassword);
    if (iPasswordLength > 127)
    {
        iPasswordLength = 127;
    }
    pwszPassword[iPasswordLength] = L'\0';
    lstrcpyW(logonIPCCredentials.wszPassword, pwszPassword);
    logonIPCCredentials.iPasswordLength = iPasswordLength;
    ZeroMemory(pwszPassword, (iTruePasswordLength + sizeof('\0')) * sizeof(WCHAR));
    logonIPCCredentials.ucPasswordSeed = static_cast<unsigned char>(GetTickCount());
    RtlInitUnicodeString(&passwordString, logonIPCCredentials.wszPassword);
    RtlRunEncodeUnicodeString(&logonIPCCredentials.ucPasswordSeed, &passwordString);
    fResult = SendToLogonService(LOGON_LOGON_USER, &logonIPCCredentials, sizeof(logonIPCCredentials), false);
    if (!fResult)
    {
        Sleep(_iLogonAttemptCount * 1000);
        if (_iLogonAttemptCount < 5)
        {
            ++_iLogonAttemptCount;
        }
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonIPC::LogUserOff
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the given user off the system. This will fail
//              if they aren't logged on.
//
//  History:    1999-08-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::LogUserOff (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_LOGOFF_USER, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestBlankPassword
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Attempts to log the given user on the system with a blank
//              password. The token is then dump and failure/success returned.
//
//  History:    2000-03-09  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestBlankPassword (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_TEST_BLANK_PASSWORD, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestInteractiveLogonAllowed
//
//  Arguments:  pwszUsername    =   User name.
//              pwszDomain      =   User domain.
//
//  Returns:    bool
//
//  Purpose:    Test whether the user has interactive logon rights to this
//              machine. The presence of SeDenyInteractiveLogonRight
//              determines this - NOT the presence of SeInteractiveLogonRight.
//
//  History:    2000-08-15  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestInteractiveLogonAllowed (const WCHAR *pwszUsername, const WCHAR *pwszDomain)

{
    LOGONIPC_USERID     logonIPCUserID;

    PackageIdentification(pwszUsername, pwszDomain, &logonIPCUserID);
    return(SendToLogonService(LOGON_TEST_INTERACTIVE_LOGON_ALLOWED, &logonIPCUserID, sizeof(logonIPCUserID), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestEjectAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Tests whether the computer is ejectable (docked laptop).
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestEjectAllowed (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TEST_EJECT_ALLOWED, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TestShutdownAllowed
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Tests whether the computer can be shut down.
//
//  History:    2001-02-22  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TestShutdownAllowed (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TEST_SHUTDOWN_ALLOWED, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::TurnOffComputer
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Brings up the "Turn Off Computer" dialog and allows the user
//              to choose what to do.
//
//  History:    2000-04-20  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::TurnOffComputer (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_TURN_OFF_COMPUTER, &logonIPC, sizeof(logonIPC), false));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::EjectComputer
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Ejects the computer (docked laptop).
//
//  History:    2001-01-10  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::EjectComputer (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_EJECT_COMPUTER, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::SignalUIHostFailure
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    Called when the UI host has an error that it cannot recover
//              from. This signals msgina to fall back to classic mode.
//
//  History:    2000-03-09  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::SignalUIHostFailure (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_SIGNAL_UIHOST_FAILURE, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::AllowExternalCredentials
//
//  Arguments:  <none>
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::AllowExternalCredentials (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_ALLOW_EXTERNAL_CREDENTIALS, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::RequestExternalCredentials
//
//  Arguments:  <none>
//
//  Returns:    bool
//
//  Purpose:    
//
//  History:    2000-06-26  vtan        created
//  --------------------------------------------------------------------------

bool    CLogonIPC::RequestExternalCredentials (void)

{
    LOGONIPC    logonIPC;

    return(SendToLogonService(LOGON_REQUEST_EXTERNAL_CREDENTIALS, &logonIPC, sizeof(logonIPC), true));
}

//  --------------------------------------------------------------------------
//  CLogonIPC::PackageIdentification
//
//  Arguments:  pwszUsername        =   User name.
//              pwszDomain          =   User domain.
//              pIdentification     =   Pointer to a LOGONIPC_USERID struct
//                                      which is masked as void* to allow
//                                      LogonIPC.h to not expose this detail.
//
//  Returns:    <none>
//
//  Purpose:    Takes the user name and domain and packages them into the
//              given struct. If no domain is given the a zero length string
//              is used which indicates to the logon service provider that
//              the local machine is desired.
//
//              Now parses the user name given. If the user has "\" then it
//              is assumed to be of the form "DOMAIN\USER". If the user has
//              "@" then it is assumed to be a UPN name.
//
//  History:    1999-08-20  vtan        created
//              2000-06-27  vtan        added UPN and DOMAIN parsing support
//  --------------------------------------------------------------------------

void    CLogonIPC::PackageIdentification (const WCHAR *pwszUsername, const WCHAR *pwszDomain, void *pIdentification)

{
    bool                fDone;
    int                 i, iStringLength;
    LOGONIPC_USERID     *pLogonIPCUserID;

    pLogonIPCUserID = reinterpret_cast<LOGONIPC_USERID*>(pIdentification);
    iStringLength = lstrlen(pwszUsername);
    for (fDone = false, i = 0; !fDone && (i < iStringLength); ++i)
    {
        if (pwszUsername[i] == L'\\')
        {
            lstrcpynW(pLogonIPCUserID->wszDomain, pwszUsername, ARRAYSIZE(pLogonIPCUserID->wszDomain));
            pLogonIPCUserID->wszDomain[i] = L'\0';
            ++i;
            lstrcpynW(pLogonIPCUserID->wszUsername, pwszUsername + i, ARRAYSIZE(pLogonIPCUserID->wszUsername));
            fDone = true;
        }
        else if (pwszUsername[i] == L'@')
        {
            lstrcpynW(pLogonIPCUserID->wszUsername, pwszUsername, ARRAYSIZE(pLogonIPCUserID->wszUsername));
            pLogonIPCUserID->wszDomain[0] = L'\0';
            fDone = true;
        }
    }
    if (!fDone)
    {
        lstrcpyW(pLogonIPCUserID->wszUsername, pwszUsername);
        if (pwszDomain != NULL)
        {
            lstrcpyW(pLogonIPCUserID->wszDomain, pwszDomain);
        }
        else
        {
            pLogonIPCUserID->wszDomain[0] = L'\0';
        }
    }
}

//  --------------------------------------------------------------------------
//  CLogonIPC::SendToLogonService
//
//  Arguments:  wQueryType  =   What type of service we are interested in.
//              pData       =   Pointer to the data.
//              wDataSize   =   Size of the data.
//              fBlock      =   Block message pump or not.
//
//  Returns:    bool    =   Success or failure.
//
//  Purpose:    Takes the package data and sends the message to the logon
//              service provider and receives the result. The logon service
//              provider started this process and reads this process' memory
//              directly (like a debugger would).
//
//              This function should block the message pump because if it
//              processes another state change message while waiting for a
//              response it could destroy data.
//
//  History:    1999-08-20  vtan        created
//              2001-06-22  vtan        changed to SendMessageTimeout
//              2001-06-28  vtan        added block parameter
//  --------------------------------------------------------------------------

bool    CLogonIPC::SendToLogonService (WORD wQueryType, void *pData, WORD wDataSize, bool fBlock)

{
    bool    fResult;

    fResult = IsLogonServiceAvailable();
    if (fResult)
    {
        DWORD_PTR   dwResult;

        reinterpret_cast<LOGONIPC*>(pData)->fResult = false;

        //  WARNING: Danger Will Robinson.

        //  Do NOT change INT_MAX to INFINITE. INT_MAX is a SIGNED number.
        //  INFINITE is an UNSIGNED number. Despite the SDK and prototype
        //  of SendMessageTimeout this timeout value is a SIGNED number.
        //  Passing in an unsigned number causes the timeout to be
        //  ignored and the function returns with a timeout.

        (LRESULT)SendMessageTimeout(_hwndLogonService,
                                    WM_LOGONSERVICEREQUEST,
                                    MAKEWPARAM(wDataSize, wQueryType),
                                    reinterpret_cast<LPARAM>(pData),
                                    fBlock ? SMTO_BLOCK : SMTO_NORMAL,
                                    INT_MAX,                                //  See above warning.
                                    &dwResult);
        fResult = (reinterpret_cast<LOGONIPC*>(pData)->fResult != FALSE);
    }
    return(fResult);
}

//  --------------------------------------------------------------------------
//  CLogonIPC::PostToLogonService
//
//  Arguments:  wQueryType  =   What type of service we are interested in.
//              pData       =   Pointer to the data.
//              wDataSize   =   Size of the data.
//
//  Returns:    <none>
//
//  Purpose:    Takes the package data and posts the message to the logon
//              service provider and receives the result. The logon service
//              provider started this process and reads this process' memory
//              directly (like a debugger would).
//
//  History:    1999-11-26  vtan        created
//  --------------------------------------------------------------------------

void    CLogonIPC::PostToLogonService (WORD wQueryType, void *pData, WORD wDataSize)

{
    if (IsLogonServiceAvailable())
    {
        TBOOL(PostMessage(_hwndLogonService, WM_LOGONSERVICEREQUEST, MAKEWPARAM(wDataSize, wQueryType), reinterpret_cast<LPARAM>(pData)));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\atl.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shgina\userom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       UserOM.h
//
//  Contents:   shell user object model (interface implemtation for ILogonEnumUsers, ILogonUser)
//
//----------------------------------------------------------------------------
#ifndef _USEROM_H_
#define _USEROM_H_

#include "priv.h"

#include "CIDispatchHelper.h"
#include "UIHostIPC.h"
#include "CInteractiveLogon.h"

HRESULT _IsGuestAccessMode(void);

const TCHAR CDECL c_szRegRoot[]         = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Hints");
const TCHAR CDECL c_szPictureSrcVal[]   = TEXT("PictureSource");

// prototypes for class factory functions
STDAPI CLogonEnumUsers_Create(REFIID riid, void** ppvObj);
STDAPI CLocalMachine_Create(REFIID riid, void** ppvObj);
STDAPI CLogonStatusHost_Create(REFIID riid, void** ppvObj);
STDAPI CLogonUser_Create(REFIID riid, void** ppvObj);

class CLogonEnumUsers : public CIDispatchHelper,
                        public IEnumVARIANT,
                        public ILogonEnumUsers
{

public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(ULONG cUsers, VARIANT* rgvar, ULONG* pcUsersFetched);
    virtual STDMETHODIMP Skip(ULONG cUsers);
    virtual STDMETHODIMP Reset();
    virtual STDMETHODIMP Clone(IEnumVARIANT** ppenum);

    // *** ILogonEnumUsers ***
    virtual STDMETHODIMP get_Domain(BSTR* pbstr);
    virtual STDMETHODIMP put_Domain(BSTR bstr);
    virtual STDMETHODIMP get_EnumFlags(ILUEORDER* porder);
    virtual STDMETHODIMP put_EnumFlags(ILUEORDER order);
    virtual STDMETHODIMP get_length(UINT* pcUsers);
    virtual STDMETHODIMP get_currentUser(ILogonUser** ppLogonUserInfo);
    virtual STDMETHODIMP item(VARIANT varUserId, ILogonUser** ppLogonUserInfo);
    virtual STDMETHODIMP _NewEnum(IUnknown** ppunk);

    virtual STDMETHODIMP create(BSTR bstrLoginName, ILogonUser **ppLogonUser);
    virtual STDMETHODIMP remove(VARIANT varUserId, VARIANT varBackupPath, VARIANT_BOOL *pbSuccess);
        
public:
    // friend functions
    friend HRESULT CLogonEnumUsers_Create(REFIID riid, void** ppvObj);

private:
    // private member variables
    int _cRef;

    TCHAR _szDomain[256];       // name of the domain we are enumerating users on
    ILUEORDER _enumorder;       // order in which to enumerate users
    HDPA _hdpaUsers;             // dpa holding the list of enumerated users

    // private member functions
    HRESULT _EnumerateUsers();
    HRESULT _GetUserByIndex(LONG lUserID, ILogonUser** ppLogonUserInfo);
    HRESULT _GetUserByName(BSTR bstrUserName, ILogonUser** ppLogonUserInfo);
    void _DestroyHDPAUsers();
    CLogonEnumUsers();
    ~CLogonEnumUsers();
};

class CLogonUser : public CIDispatchHelper,
                   public ILogonUser
{

public:
    static HRESULT Create(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain, REFIID riid, LPVOID* ppv);

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILogonUser ***
    virtual STDMETHODIMP get_setting(BSTR bstrName, VARIANT* pvarVal);
    virtual STDMETHODIMP put_setting(BSTR bstrName, VARIANT varVal);
    virtual STDMETHODIMP get_isLoggedOn(VARIANT_BOOL* pbLoggedIn);
    virtual STDMETHODIMP get_passwordRequired(VARIANT_BOOL* pbPasswordRequired);
    virtual STDMETHODIMP get_interactiveLogonAllowed(VARIANT_BOOL *pbInteractiveLogonAllowed);
    virtual STDMETHODIMP get_isProfilePrivate(VARIANT_BOOL* pbPrivate);
    virtual STDMETHODIMP get_isPasswordResetAvailable(VARIANT_BOOL* pbResetAvailable);

    virtual STDMETHODIMP logon(BSTR pstrPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP logoff(VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP changePassword(VARIANT varNewPassword, VARIANT varOldPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP makeProfilePrivate(VARIANT_BOOL bPrivate);
    virtual STDMETHODIMP getMailAccountInfo(UINT uiAccountIndex, VARIANT *pvarAccountName, UINT *pcUnreadMessages);

private:

    // private member variables
    int      _cRef;
    TCHAR    _szLoginName[UNLEN + sizeof('\0')];
    TCHAR    _szDomain[DNLEN + sizeof('\0')];
    BSTR     _strDisplayName;
    TCHAR    _szPicture[MAX_PATH+7];  // +7 for "file://" prefix
    BSTR     _strPictureSource;
    BSTR     _strHint;
    BSTR     _strDescription;
    BOOL     _bPasswordRequired;
    int      _iPrivilegeLevel;
    LPTSTR   _pszSID;

    // private member functions
    CLogonUser(LPCTSTR pszLoginName, LPCTSTR pszFullName, LPCTSTR pszDomain);
    ~CLogonUser();

    HRESULT _InitPicture();
    HRESULT _SetPicture(LPCTSTR pszNewPicturePath);
    DWORD   _OpenUserHintKey(REGSAM sam, HKEY *phkey);

    HRESULT _UserSettingAccessor(BSTR bstrName, VARIANT *pvarVal, BOOL bPut);

    // DisplayName 
    HRESULT _GetDisplayName(VARIANT* pvar);
    HRESULT _PutDisplayName(VARIANT var);

    // LoginName
    HRESULT _GetLoginName(VARIANT* pvar);
    HRESULT _PutLoginName(VARIANT var);

    // Domain
    HRESULT _GetDomain(VARIANT* pvar);

    // Picture
    HRESULT _GetPicture(VARIANT* pvar);
    HRESULT _PutPicture(VARIANT var);
    HRESULT _GetPictureSource(VARIANT* pvar);

    // Description
    HRESULT _GetDescription(VARIANT* pvar);
    HRESULT _PutDescription(VARIANT var);

    // Hint
    HRESULT _GetHint(VARIANT* pvar);
    HRESULT _PutHint(VARIANT var);

    // AccountType
    HRESULT _GetAccountType(VARIANT* pvar);
    HRESULT _PutAccountType(VARIANT var);

    // SID
    HRESULT _LookupUserSid();
    HRESULT _GetSID(VARIANT* pvar);

    //
    DWORD   _GetExpiryDays (HKEY hKeyCurrentUser);
    HRESULT _GetUnreadMail(VARIANT* pvar);
};

class CLocalMachine : public CIDispatchHelper,
                      public ILocalMachine
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILocalMachine ***
    virtual STDMETHODIMP get_MachineName(VARIANT* pvar);
    virtual STDMETHODIMP get_isGuestEnabled(ILM_GUEST_FLAGS flags, VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP get_isFriendlyUIEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isFriendlyUIEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_isMultipleUsersEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isMultipleUsersEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_isRemoteConnectionsEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP put_isRemoteConnectionsEnabled(VARIANT_BOOL bEnabled);
    virtual STDMETHODIMP get_AccountName(VARIANT varAccount, VARIANT* pvar);
    virtual STDMETHODIMP get_isUndockEnabled(VARIANT_BOOL* pbEnabled);
    virtual STDMETHODIMP get_isShutdownAllowed(VARIANT_BOOL* pbShutdownAllowed);
    virtual STDMETHODIMP get_isGuestAccessMode(VARIANT_BOOL* pbForceGuest);
    virtual STDMETHODIMP get_isOfflineFilesEnabled(VARIANT_BOOL *pbEnabled);

    virtual STDMETHODIMP TurnOffComputer(void);
    virtual STDMETHODIMP SignalUIHostFailure(void);
    virtual STDMETHODIMP AllowExternalCredentials(void);
    virtual STDMETHODIMP RequestExternalCredentials(void);
    virtual STDMETHODIMP LogonWithExternalCredentials(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP InitiateInteractiveLogon(BSTR pstrUsername, BSTR pstrDomain, BSTR pstrPassword, DWORD dwTimeout, VARIANT_BOOL* pbRet);
    virtual STDMETHODIMP UndockComputer(void);
    virtual STDMETHODIMP EnableGuest(ILM_GUEST_FLAGS flags);
    virtual STDMETHODIMP DisableGuest(ILM_GUEST_FLAGS flags);

public:
    // friend Functions
    friend HRESULT CLocalMachine_Create(REFIID riid, LPVOID* ppv);

private:
    // private member variables
    int _cRef;

private:
    // private member functions
    CLocalMachine(void);
    ~CLocalMachine();

    static  void    RefreshStartMenu(void);
};

class CLogonStatusHost : public CIDispatchHelper,
                         public ILogonStatusHost
{
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // *** ILogonStatusHost ***
    virtual STDMETHODIMP Initialize(HINSTANCE hInstance, HWND hwndHost);
    virtual STDMETHODIMP WindowProcedureHelper(HWND hwnd, UINT uMsg, VARIANT wParam, VARIANT lParam);
    virtual STDMETHODIMP UnInitialize(void);

public:
    // friend Functions
    friend HRESULT CLogonStatusHost_Create(REFIID riid, LPVOID* ppv);

private:
    // implementation helpers
    LRESULT Handle_WM_UISERVICEREQUEST (WPARAM wParam, LPARAM lParam);
    LRESULT Handle_WM_WTSSESSION_CHANGE (WPARAM wParam, LPARAM lParam);
    static  LRESULT CALLBACK    StatusWindowProc (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    // terminal service wait helpers
    bool IsTermServiceDisabled (void);
    void StartWaitForTermService (void);
    void EndWaitForTermService (void);
    void WaitForTermService (void);
    static DWORD WINAPI CB_WaitForTermService (void *pParameter);
    // parent process wait helpers
    void StartWaitForParentProcess (void);
    void EndWaitForParentProcess (void);
    void WaitForParentProcess (void);
    static DWORD WINAPI CB_WaitForParentProcess (void *pParameter);
    // thread helper
    static void CALLBACK CB_WakeupThreadAPC (ULONG_PTR dwParam);
private:
    // private member variables
    int _cRef;

    HINSTANCE               _hInstance;
    HWND                    _hwnd;
    HWND                    _hwndHost;
    ATOM                    _atom;
    BOOL                    _fRegisteredNotification;
    HANDLE                  _hThreadWaitForTermService;
    HANDLE                  _hThreadWaitForParentProcess;
    HANDLE                  _hProcessParent;
    CInteractiveLogon       _interactiveLogon;

    static  const WCHAR     s_szTermSrvReadyEventName[];
public:
    // private member functions
    CLogonStatusHost(void);
    ~CLogonStatusHost();

};


#endif // _USEROM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\autoplay.cpp ===
#include "precomp.h"
#pragma hdrstop

#include "prevwnd.h"

#include <shpriv.h>

DWORD g_dwThreadID = 0;

class CAutoplayForSlideShow : public IHWEventHandler,
                              public IDropTarget,
                              public NonATLObject
{
public:
    CAutoplayForSlideShow() : _cRef(1) {}

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IHWEventHandler
    STDMETHOD(Initialize)(LPCWSTR pszParams);
    STDMETHOD(HandleEvent)(LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID,
        LPCWSTR pszEventType);
    STDMETHOD(HandleEventWithContent)(LPCWSTR pszDeviceID,
        LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
        LPCWSTR pszContentTypeHandler, IDataObject* pdtobj);

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    LONG _cRef;
};


STDMETHODIMP CAutoplayForSlideShow::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CAutoplayForSlideShow, IHWEventHandler),
        QITABENT(CAutoplayForSlideShow, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CAutoplayForSlideShow::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAutoplayForSlideShow::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDAPI CAutoplayForSlideShow_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CAutoplayForSlideShow* pass = new CAutoplayForSlideShow();
    if (!pass)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pass->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pass->Release();
    return hr;
}

STDMETHODIMP CAutoplayForSlideShow::Initialize(LPCWSTR)
{
    // We don't care about params a this point
    return S_OK;
}

STDMETHODIMP CAutoplayForSlideShow::HandleEvent(LPCWSTR pszDeviceID,
    LPCWSTR pszAltDeviceID, LPCWSTR pszEventType)
{
    return E_NOTIMPL;
}

DWORD WINAPI SlideShowThread(void* pv)
{
    IStream *pstm = (IStream *)pv;
    IDataObject* pdtobj;
    HRESULT hr = CoGetInterfaceAndReleaseStream(pstm, IID_PPV_ARG(IDataObject, &pdtobj));
    if (SUCCEEDED(hr))
    {
        CPreviewWnd cwndPreview;
        hr = cwndPreview.Initialize(NULL, SLIDESHOW_MODE, TRUE);
        if (SUCCEEDED(hr))
        {
            // 4 is the walk depth, make sure we pick up pictures
            if (cwndPreview.CreateSlideshowWindow(4))
            {
                hr = cwndPreview.StartSlideShow(pdtobj);
                if (SUCCEEDED(hr))
                {
                    MSG msg;

                    while (GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }

                    ::PostThreadMessage(g_dwThreadID, WM_QUIT, 0, 0);
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }

        pdtobj->Release();
    }

    return hr;
}

HRESULT _StartSlideShowThread(IDataObject *pdo)
{
    IStream *pstm;
    HRESULT hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &pstm);
    if (SUCCEEDED(hr))
    {
        //  maybe do threadref?
        if (!SHCreateThread(SlideShowThread, pstm, CTF_COINIT, NULL))
        {
            pstm->Release();
            hr = E_FAIL;
        }
    }
    return hr;
}

STDMETHODIMP CAutoplayForSlideShow::HandleEventWithContent(
    LPCWSTR pszDeviceID, LPCWSTR pszAltDeviceID, LPCWSTR pszEventType,
    LPCWSTR pszContentTypeHandler, IDataObject* pdtobj)
{
    return _StartSlideShowThread(pdtobj);
}

// IDropTarget::DragEnter
HRESULT CAutoplayForSlideShow::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CAutoplayForSlideShow::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CAutoplayForSlideShow::DragLeave(void)
{
    return S_OK;
}

// IDropTarget::DragDrop
HRESULT CAutoplayForSlideShow::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return _StartSlideShowThread(pdtobj);
}

void WINAPI ImageView_COMServer(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    HRESULT hrOle = SHCoInitialize();
    if (SUCCEEDED(hrOle))
    {
        g_dwThreadID = GetCurrentThreadId();

        IUnknown* punkFact;
        // the preview window will init GDI+
        HRESULT hr = DllGetClassObject(CLSID_AutoplayForSlideShow, IID_PPV_ARG(IUnknown, &punkFact));
        if (SUCCEEDED(hr))
        {
            DWORD dwROC;
            hr = CoRegisterClassObject(CLSID_AutoplayForSlideShow, punkFact, CLSCTX_LOCAL_SERVER,
                REGCLS_SINGLEUSE, &dwROC);

            if (SUCCEEDED(hr))
            {
                MSG msg;

                while (GetMessage(&msg, NULL, 0, 0))
                {
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }

                CoRevokeClassObject(dwROC);
            }

            punkFact->Release();
        }

        SHCoUninitialize(hrOle);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\docfile.h ===
#ifndef _DOCFILE_H
#define _DOCFILE_H

class CDocFileThumb :   public IExtractImage,
                        public IPersistFile,
                        public CComObjectRoot,
                        public CComCoClass< CDocFileThumb,&CLSID_DocfileThumbnailHandler >
{
public:
    CDocFileThumb();
    ~CDocFileThumb();
    
    BEGIN_COM_MAP( CDocFileThumb )
        COM_INTERFACE_ENTRY( IExtractImage )
        COM_INTERFACE_ENTRY( IPersistFile )
    END_COM_MAP( )

    DECLARE_REGISTRY( CDocFileThumb,
                      _T("Shell.ThumbnailExtract.Docfile.1"),
                      _T("Shell.ThumbnailExtract.DocFile.1"),
                      IDS_DOCTHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CDocFileThumb );

    // IExtractThumbnail
    STDMETHOD (GetLocation) ( LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags );
 
    STDMETHOD (Extract)( HBITMAP * phBmpThumbnail);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID * pCLSID );
    STDMETHOD (IsDirty)(void);
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR * ppszFileName);
protected:
    LPWSTR m_pszPath;
    SIZE m_rgSize;
    DWORD m_dwRecClrDepth;
    BITBOOL m_fOrigSize : 1;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\docfile.cpp ===
#include "precomp.h"
#include "thumbutil.h"

HRESULT GetMediaManagerThumbnail(IPropertyStorage * pPropStg, const SIZE * prgSize, 
                            DWORD dwClrDepth, HPALETTE hpal, BOOL fOrigSize,
                            HBITMAP * phBmpThumbnail);
                                  
HRESULT GetDocFileThumbnail(IPropertyStorage * pPropStg, const SIZE * prgSize, 
                            DWORD dwClrDepth, HPALETTE hpal, BOOL fOrigSize,
                            HBITMAP * phBmpThumbnail);

// PACKEDMETA struct for DocFile thumbnails.
typedef struct
{
    WORD    mm;
    WORD    xExt;
    WORD    yExt;
    WORD    dummy;
} PACKEDMETA;

VOID CalcMetaFileSize(HDC hDC, PACKEDMETA * pMeta, const SIZEL * prgSize, RECT * pRect);

CDocFileThumb::CDocFileThumb()
{
    m_pszPath = NULL;
}

CDocFileThumb::~CDocFileThumb()
{
    LocalFree(m_pszPath);   // accepts NULL
}

STDMETHODIMP CDocFileThumb::GetLocation(LPWSTR pszFileName, DWORD cchMax,
                                        DWORD * pdwPriority, const SIZE * prgSize,
                                        DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    if (!m_pszPath)
        return E_UNEXPECTED;

    m_rgSize = *prgSize;
    m_dwRecClrDepth = dwRecClrDepth;
    
    // just copy the current path into the buffer as we do not share thumbnails...
    StrCpyNW(pszFileName, m_pszPath, cchMax);

    HRESULT hr = S_OK;
    if (*pdwFlags & IEIFLAG_ASYNC)
    {
        // we support async 
        hr = E_PENDING;
        *pdwPriority = PRIORITY_EXTRACT_NORMAL;
    }

    m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);
    
    // we don't want it cached....
    *pdwFlags &= ~IEIFLAG_CACHE;

    return hr;
}

HPALETTE PaletteFromClrDepth(DWORD dwRecClrDepth)
{
    HPALETTE hpal = NULL;
    if (dwRecClrDepth == 8)
    {
        hpal = SHCreateShellPalette(NULL);
    }
    else if (dwRecClrDepth < 8)
    {
        hpal = (HPALETTE)GetStockObject(DEFAULT_PALETTE);
    }
    return hpal;
}

STDMETHODIMP CDocFileThumb::Extract(HBITMAP * phBmpThumbnail)
{
    if (!m_pszPath)
        return E_UNEXPECTED;
    
    IStorage *pstg;
    HRESULT hr = StgOpenStorage(m_pszPath, NULL, STGM_READ | STGM_SHARE_EXCLUSIVE, NULL, NULL, &pstg);
    if (SUCCEEDED(hr))
    {
        IPropertySetStorage *pPropSetStg;
        hr = pstg->QueryInterface(IID_PPV_ARG(IPropertySetStorage, &pPropSetStg));
        if (SUCCEEDED(hr))
        {
            // "MIC" Microsoft Image Composer files needs special casing because they use
            // the Media Manager internal thumbnail propertyset ... (by what it would be like
            // to be standard for once ....)
            FMTID fmtidPropSet = StrCmpIW(PathFindExtensionW(m_pszPath), L".MIC") ?
                FMTID_SummaryInformation : FMTID_CmsThumbnailPropertySet;

            IPropertyStorage *pPropSet;
            hr = pPropSetStg->Open(fmtidPropSet, STGM_READ | STGM_SHARE_EXCLUSIVE, &pPropSet);
            if (SUCCEEDED(hr))
            {
                HPALETTE hpal = PaletteFromClrDepth(m_dwRecClrDepth);
    
                if (FMTID_CmsThumbnailPropertySet == fmtidPropSet)
                {
                    hr = GetMediaManagerThumbnail(pPropSet, &m_rgSize, m_dwRecClrDepth, hpal, m_fOrigSize, phBmpThumbnail);
                }
                else
                {
                    hr = GetDocFileThumbnail(pPropSet, &m_rgSize, m_dwRecClrDepth, hpal, m_fOrigSize, phBmpThumbnail);
                }

                if (hpal)
                    DeleteObject(hpal);
                pPropSet->Release();
            }
            pPropSetStg->Release();
        }
        pstg->Release();
    }
    
    return hr;   
}

STDMETHODIMP CDocFileThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    LocalFree(m_pszPath);
    return SHStrDup(pszFileName, &m_pszPath);
}

HRESULT GetMediaManagerThumbnail(IPropertyStorage * pPropStg,
                                 const SIZE * prgSize, DWORD dwClrDepth,
                                 HPALETTE hpal, BOOL fOrigSize, HBITMAP * phBmpThumbnail)
{
    // current version of media manager simply stores the DIB data in a under a 
    // named property Thumbnail...
    // read the thumbnail property from the property storage.
    PROPVARIANT pvarResult = {0};
    PROPSPEC propSpec;

    propSpec.ulKind = PRSPEC_LPWSTR;
    propSpec.lpwstr = L"Thumbnail";
    
    HRESULT hr = pPropStg->ReadMultiple(1, &propSpec, &pvarResult);
    if (SUCCEEDED(hr))
    {
        BITMAPINFO * pbi = (BITMAPINFO *)pvarResult.blob.pBlobData;
        void *pBits = CalcBitsOffsetInDIB(pbi);
        
        hr = E_FAIL;
        if (pbi->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
        {
            if (ConvertDIBSECTIONToThumbnail(pbi, pBits, phBmpThumbnail, prgSize, dwClrDepth, hpal, 15, fOrigSize))
            {
                hr = S_OK;
            }
        }

        PropVariantClear(&pvarResult);
    }
    
    return hr;
}

HRESULT GetDocFileThumbnail(IPropertyStorage * pPropStg,
                            const SIZE * prgSize, DWORD dwClrDepth,
                            HPALETTE hpal, BOOL fOrigSize, HBITMAP * phBmpThumbnail)
{
    HRESULT hr;

    HDC hDC = GetDC(NULL);
    HDC hMemDC = CreateCompatibleDC(hDC);
    if (hMemDC)
    {
        HBITMAP hBmp = NULL;
        PROPSPEC propSpec;
        PROPVARIANT pvarResult = {0};
        // read the thumbnail property from the property storage.
        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = PIDSI_THUMBNAIL;
        hr = pPropStg->ReadMultiple(1, &propSpec, &pvarResult);
        if (SUCCEEDED(hr))
        {
            // assume something is going to go terribly wrong
            hr = E_FAIL;

            // make sure we are dealing with a clipboard format. CLIPDATA
            if ((pvarResult.vt == VT_CF) && (pvarResult.pclipdata->ulClipFmt == -1))
            {
                LPDWORD pdwCF = (DWORD *)pvarResult.pclipdata->pClipData;
                LPBYTE  pStruct = pvarResult.pclipdata->pClipData + sizeof(DWORD);

                if (*pdwCF == CF_METAFILEPICT)
                {
                    SetMapMode(hMemDC, MM_TEXT);
                
                    // handle thumbnail that is a metafile.
                    PACKEDMETA * pMeta = (PACKEDMETA *)pStruct;
                    LPBYTE pData = pStruct + sizeof(PACKEDMETA);
                    RECT rect;

                    UINT cbSize = pvarResult.pclipdata->cbSize - sizeof(DWORD) - sizeof(pMeta->mm) - 
                    sizeof(pMeta->xExt) - sizeof(pMeta->yExt) - sizeof(pMeta->dummy);

                    // save as a metafile.
                    HMETAFILE hMF = SetMetaFileBitsEx(cbSize, pData);
                    if (hMF)
                    {    
                        SIZE rgNewSize;
                    
                        // use the mapping mode to calc the current size
                        CalcMetaFileSize(hMemDC, pMeta, prgSize, & rect);
                    
                        CalculateAspectRatio(prgSize, &rect);

                        if (fOrigSize)
                        {
                            // use the aspect rect to refigure the size...
                            rgNewSize.cx = rect.right - rect.left;
                            rgNewSize.cy = rect.bottom - rect.top;
                            prgSize = &rgNewSize;
                        
                            // adjust the rect to be the same as the size (which is the size of the metafile)
                            rect.right -= rect.left;
                            rect.bottom -= rect.top;
                            rect.left = 0;
                            rect.top = 0;
                        }

                        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, &hBmp, NULL, NULL))
                        {
                            HGDIOBJ hOldBmp = SelectObject(hMemDC, hBmp);
                            HGDIOBJ hBrush = GetStockObject(WHITE_BRUSH);
                            HGDIOBJ hOldBrush = SelectObject(hMemDC, hBrush);
                            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
                            HGDIOBJ hOldPen = SelectObject(hMemDC, hPen);

                            Rectangle(hMemDC, 0, 0, prgSize->cx, prgSize->cy);
        
                            SelectObject(hMemDC, hOldBrush);
                            SelectObject(hMemDC, hOldPen);
                    
                            int iXBorder = 0;
                            int iYBorder = 0;
                            if (rect.left == 0)
                            {
                                iXBorder ++;
                            }
                            if (rect.top == 0)
                            {
                                iYBorder ++;
                            }
                        
                            SetViewportExtEx(hMemDC, rect.right - rect.left - 2 * iXBorder, rect.bottom - rect.top - 2 * iYBorder, NULL);
                            SetViewportOrgEx(hMemDC, rect.left + iXBorder, rect.top + iYBorder, NULL);

                            SetMapMode(hMemDC, pMeta->mm);

                            // play the metafile.
                            BOOL bRet = PlayMetaFile(hMemDC, hMF);
                            if (bRet)
                            {
                                *phBmpThumbnail = hBmp;
                                if (*phBmpThumbnail)
                                {
                                    // we got the thumbnail bitmap, return success.
                                    hr = S_OK;
                                }
                            }

                            DeleteMetaFile(hMF);
                            SelectObject(hMemDC, hOldBmp);

                            if (FAILED(hr) && hBmp)
                            {
                                DeleteObject(hBmp);
                            }
                        }
                        else
                        {
                            hr = DV_E_CLIPFORMAT;
                        }
                    }
                }
                else if (*pdwCF == CF_DIB)
                {
                    // handle thumbnail that is a bitmap.
                    BITMAPINFO * pDib = (BITMAPINFO *) pStruct;

                    if (pDib->bmiHeader.biSize == sizeof(BITMAPINFOHEADER))
                    {
                        void *pBits = CalcBitsOffsetInDIB(pDib);
                    
                        if (ConvertDIBSECTIONToThumbnail(pDib, pBits, phBmpThumbnail, prgSize, dwClrDepth, hpal, 15, fOrigSize))
                        {
                            hr = S_OK;
                        }
                        else
                        {
                            hr = DV_E_CLIPFORMAT;
                        }
                    }
                }
                else
                {
                    hr = DV_E_CLIPFORMAT;
                }
            }
            else
            {
                hr = DV_E_CLIPFORMAT;
            }
            PropVariantClear(&pvarResult);
        }
        DeleteDC(hMemDC);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    ReleaseDC(NULL, hDC);
    return hr;
}


VOID CalcMetaFileSize(HDC hDC, PACKEDMETA * prgMeta, const SIZEL * prgSize, RECT * prgRect)
{
    ASSERT(prgMeta && prgRect);

    prgRect->left = 0;
    prgRect->top = 0;

    if (!prgMeta->xExt || !prgMeta->yExt)
    {
        // no size, then just use the size rect ...
        prgRect->right = prgSize->cx;
        prgRect->bottom = prgSize->cy;
    }
    else
    {
        // set the mapping mode....
        SetMapMode(hDC, prgMeta->mm);

        if (prgMeta->mm == MM_ISOTROPIC || prgMeta->mm == MM_ANISOTROPIC)
        {
            // we must set the ViewPortExtent and the window extent to get the scaling
            SetWindowExtEx(hDC, prgMeta->xExt, prgMeta->yExt, NULL);
            SetViewportExtEx(hDC, prgMeta->xExt, prgMeta->yExt, NULL);
        }

        POINT pt;
        pt.x = prgMeta->xExt;
        pt.y = prgMeta->yExt;

        // convert to pixels....
        LPtoDP(hDC, &pt, 1);

        prgRect->right = abs(pt.x);
        prgRect->bottom = abs(pt.y);
    }
}

STDMETHODIMP CDocFileThumb::GetClassID(CLSID * pCLSID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::IsDirty()
{
    return S_FALSE;
}

STDMETHODIMP CDocFileThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CDocFileThumb::GetCurFile(LPOLESTR * ppszFileName)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\events.cpp ===
// FooBarEvents.cpp : Implementation of CWebTestApp and DLL registration.

#include "precomp.h"

#include "Events.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\events.h ===
// Events.h: Definition of the FooBarEvents class
//
//////////////////////////////////////////////////////////////////////

#if !defined(__EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_)
#define __EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols
#include "shimgvw.h"

/////////////////////////////////////////////////////////////////////////////
// FooBarEvents

class CEvents
{
public:
    virtual void OnClose()
    {}
    virtual void OnPreviewReady()
    {}
    virtual void OnError()
    {}
    virtual void OnChangeUI()
    {}
    virtual void OnBestFitPress()
    {}
    virtual void OnActualSizePress()
    {}
};

template <class T>
class CControlEvents : public CEvents,
                       public IConnectionPointImpl<T, &DIID_DPreviewEvents, CComDynamicUnkArray>
{
protected:
    void _FireEvent( DWORD dwID, DISPPARAMS *pdisp = NULL )
    {
        T* pT = (T*)this;
        pT->Lock();
        IUnknown** pp = m_vec.begin();
        while (pp < m_vec.end())
        {
            if (*pp != NULL)
            {
                DISPPARAMS disp = { NULL, NULL, 0, 0 };

                if ( !pdisp )
                    pdisp = &disp;
                    
                IDispatch* pDispatch = reinterpret_cast<IDispatch*>(*pp);
                pDispatch->Invoke(dwID, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, pdisp, NULL, NULL, NULL);
            }
            pp++;
        }
        pT->Unlock();
    }
};

template <class T>
class CPreviewEvents : public CControlEvents<T>
{
public:
    virtual void OnClose()
    {
        _FireEvent( 0x1 );
    }
    virtual void OnPreviewReady()
    {
        _FireEvent( 0x2 );
    }
    virtual void OnError()
    {
        _FireEvent( 0x3 );
    }
    virtual void OnBestFitPress()
    {
        _FireEvent( 0x4 );
    }
    virtual void OnActualSizePress()
    {
        _FireEvent( 0x5 );
    }
};

#endif // !defined(__EVENTS_H__06E192AB_5CAD_11D1_B670_00A024E430AB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\gdithumb.cpp ===
#include "precomp.h"
#pragma hdrstop

CGdiPlusThumb::CGdiPlusThumb()
{
    m_pImage = NULL;
    m_pImageFactory = NULL;
    m_szPath[0] = 0;
}

CGdiPlusThumb::~CGdiPlusThumb()
{
    if (m_pImage)
        m_pImage->Release();

    if (m_pImageFactory)
        m_pImageFactory->Release();
}

STDMETHODIMP CGdiPlusThumb::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                        DWORD * pdwPriority, const SIZE *prgSize,
                                        DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = S_OK;

    if (*pdwFlags & IEIFLAG_ASYNC)
    {
        hr = E_PENDING;

        // higher than normal priority, this task is relatively fast
        *pdwPriority = PRIORITY_EXTRACT_FAST;
    }

    m_rgSize = *prgSize;
    m_dwRecClrDepth = dwRecClrDepth;
    // We only work in non-paletted modes.  Some of our extractors simply always use 24bbp, should we?
    if (m_dwRecClrDepth < 16)
        m_dwRecClrDepth = 16;

    m_fOrigSize = BOOLIFY(*pdwFlags & IEIFLAG_ORIGSIZE);
    m_fHighQuality = BOOLIFY(*pdwFlags & IEIFLAG_QUALITY);

    *pdwFlags = IEIFLAG_CACHE;

    StrCpyNW(pszPathBuffer, m_szPath, cch);

    return hr;
}

STDMETHODIMP CGdiPlusThumb::Extract(HBITMAP *phBmpThumbnail)
{
    HRESULT hr = E_FAIL;

    // Do the GDI plus stuff here
    if (m_pImageFactory && m_pImage)
    {
        if (m_fHighQuality)
        {
            hr = m_pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);
        }
        if (FAILED(hr))
        {
            hr = m_pImage->Decode(SHIMGDEC_THUMBNAIL, m_rgSize.cx, m_rgSize.cy);
        }

        if (SUCCEEDED(hr))
        {
            // Get the image's actual size, which might be less than the requested size since we asked for a thumbnail
            SIZE sizeImg;
            m_pImage->GetSize(&sizeImg);

            // we need to fill the background with the default color if we can't resize the bitmap
            // or if the image is transparent:
            m_fFillBackground = !m_fOrigSize || (m_pImage->IsTransparent() == S_OK);

            if (m_fOrigSize)
            {
                // if its too damn big, lets squish it, but try to
                // maintain the same aspect ratio.  This is the same
                // sort of thing we do for the !m_fOrigSize case, except
                // here we want to do it here because we want to return
                // a correctly sized bitmap.
                if (sizeImg.cx != 0 && sizeImg.cy != 0 &&
                    (sizeImg.cx > m_rgSize.cx || sizeImg.cy > m_rgSize.cy))
                {
                    if (m_rgSize.cx * sizeImg.cy > m_rgSize.cy * sizeImg.cx)
                    {
                        m_rgSize.cx = MulDiv(m_rgSize.cy,sizeImg.cx,sizeImg.cy);
                    }
                    else
                    {
                        m_rgSize.cy = MulDiv(m_rgSize.cx,sizeImg.cy,sizeImg.cx);
                    }
                }
                else
                {
                    // Use the size if it was small enough and they wanted original size
                    m_rgSize = sizeImg;
                }
            }

            hr = CreateDibFromBitmapImage( phBmpThumbnail );
        }
    }

    return SUCCEEDED(hr) ? S_OK : hr;
}

STDMETHODIMP CGdiPlusThumb::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_GdiThumbnailExtractor;
    return S_OK;
}

STDMETHODIMP CGdiPlusThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CGdiPlusThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    StrCpyNW(m_szPath, pszFileName, ARRAYSIZE(m_szPath));

    // Call ImageFactory->CreateFromFile here.  If Create from file failes then
    // return E_FAIL, otherwise return S_OK.
    ASSERT(NULL==m_pImageFactory);
    HRESULT hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &m_pImageFactory));
    if (SUCCEEDED(hr))
    {
        hr = m_pImageFactory->CreateImageFromFile(m_szPath, &m_pImage);
        ASSERT((SUCCEEDED(hr) && m_pImage) || (FAILED(hr) && !m_pImage));
    }

    return hr;
}

STDMETHODIMP CGdiPlusThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGdiPlusThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}


STDMETHODIMP CGdiPlusThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

HRESULT CGdiPlusThumb::CreateDibFromBitmapImage(HBITMAP * pbm)
{
    HRESULT hr = E_FAIL;
    BITMAPINFO bmi = {0};
    void * pvBits;

    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth = m_rgSize.cx;
    bmi.bmiHeader.biHeight = m_rgSize.cy;
    bmi.bmiHeader.biPlanes = 1;
    bmi.bmiHeader.biBitCount = (USHORT)m_dwRecClrDepth;
    bmi.bmiHeader.biCompression = BI_RGB;
    DWORD dwBPL = (((bmi.bmiHeader.biWidth * m_dwRecClrDepth) + 31) >> 3) & ~3;
    bmi.bmiHeader.biSizeImage = dwBPL * bmi.bmiHeader.biHeight;

    HDC hdc = GetDC(NULL);
    HBITMAP hbmp = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pvBits, NULL, 0);
    if (hbmp)
    {
        HDC hMemDC = CreateCompatibleDC(hdc);
        if (hMemDC)
        {
            HBITMAP hbmOld = (HBITMAP)SelectObject(hMemDC, hbmp);
            RECT rc = {0, 0, m_rgSize.cx, m_rgSize.cy};

            if (m_fFillBackground)
            {
                FillRect(hMemDC, &rc, GetSysColorBrush(COLOR_WINDOW));
            }
        
            // if the m_fOrigSize flag isn't set then we need to return a bitmap that is the
            // requested size.  In order to maintain aspect ratio that means we need to
            // center the thumbnail.

            if (!m_fOrigSize)
            {
                SIZE sizeImg;
                m_pImage->GetSize(&sizeImg);

                // if its too damn big, lets squish it, but try to
                // maintain the same aspect ratio.  This is the same
                // sort of thing we did for the m_fOrigSize case, except
                // here we want to do it before centering.
                if (sizeImg.cx != 0 && sizeImg.cy != 0 &&
                    (sizeImg.cx > m_rgSize.cx || sizeImg.cy > m_rgSize.cy))
                {
                    if (m_rgSize.cx * sizeImg.cy > m_rgSize.cy * sizeImg.cx)
                    {
                        sizeImg.cx = MulDiv(m_rgSize.cy,sizeImg.cx,sizeImg.cy);
                        sizeImg.cy = m_rgSize.cy;
                    }
                    else
                    {
                        sizeImg.cy = MulDiv(m_rgSize.cx,sizeImg.cy,sizeImg.cx);
                        sizeImg.cx = m_rgSize.cx;
                    }
                }

                rc.left = (m_rgSize.cx-sizeImg.cx)/2;
                rc.top = (m_rgSize.cy-sizeImg.cy)/2;
                rc.right = rc.left + sizeImg.cx;
                rc.bottom = rc.top + sizeImg.cy;
            }

            hr = m_pImage->Draw(hMemDC, &rc, NULL);

            SelectObject(hMemDC, hbmOld);
            DeleteDC(hMemDC);
        }
    }
    ReleaseDC(NULL, hdc);

    if (SUCCEEDED(hr))
    {
        *pbm = hbmp;
    }
    else if (hbmp)
    {
        DeleteObject(hbmp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\gdithumb.h ===
#pragma once

#include <shimgdata.h>

// PRIORITIES
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY

#define PRIORITY_M5         (PRIORITY_NORMAL - 5 * 0x1000)
#define PRIORITY_M4         (PRIORITY_NORMAL - 4 * 0x1000)
#define PRIORITY_M3         (PRIORITY_NORMAL - 3 * 0x1000)
#define PRIORITY_M2         (PRIORITY_NORMAL - 2 * 0x1000)
#define PRIORITY_M1         (PRIORITY_NORMAL - 1 * 0x1000)
#define PRIORITY_NORMAL     ITSAT_DEFAULT_PRIORITY
#define PRIORITY_P1         (PRIORITY_NORMAL + 1 * 0x1000)
#define PRIORITY_P2         (PRIORITY_NORMAL + 2 * 0x1000)
#define PRIORITY_P3         (PRIORITY_NORMAL + 3 * 0x1000)
#define PRIORITY_P4         (PRIORITY_NORMAL + 4 * 0x1000)
#define PRIORITY_P5         (PRIORITY_NORMAL + 5 * 0x1000)

#define PRIORITY_EXTRACT_FAST       PRIORITY_P1
#define PRIORITY_EXTRACT_NORMAL     PRIORITY_NORMAL
#define PRIORITY_EXTRACT_SLOW       PRIORITY_M1

class CGdiPlusThumb : public IExtractImage,
                      public IPersistFile,
                      public CComObjectRoot,
                      public CComCoClass< CGdiPlusThumb, &CLSID_GdiThumbnailExtractor >
{
public:
    CGdiPlusThumb();
    ~CGdiPlusThumb();

    BEGIN_COM_MAP( CGdiPlusThumb )
        COM_INTERFACE_ENTRY( IExtractImage )
        COM_INTERFACE_ENTRY( IPersistFile )
    END_COM_MAP( )

    DECLARE_REGISTRY( CGdiPlusThumb,
                      _T("Shell.ThumbnailExtract.GdiPlus.1"),
                      _T("Shell.ThumbnailExtract.GdiPlus.1"),
                      IDS_GDITHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CGdiPlusThumb );

    // IExtractImage
    STDMETHOD (GetLocation)(LPWSTR pszPathBuffer, DWORD cch,
                            DWORD *pdwPriority, const SIZE *prgSize,
                            DWORD dwRecClrDepth, DWORD *pdwFlags);

    STDMETHOD (Extract)(HBITMAP *phBmpThumbnail);

    // IPersistFile
    STDMETHOD (GetClassID)(CLSID *pClassID);
    STDMETHOD (IsDirty)();
    STDMETHOD (Load)(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save)(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted)(LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile)(LPOLESTR *ppszFileName);

protected:
    HRESULT CreateDibFromBitmapImage(HBITMAP *pbm);

    WCHAR   m_szPath[MAX_PATH];
    SIZE    m_rgSize;
    DWORD   m_dwRecClrDepth;
    BOOL    m_fOrigSize;
    BOOL    m_fFillBackground;
    BOOL    m_fHighQuality;

    IShellImageData * m_pImage;
    IShellImageDataFactory * m_pImageFactory;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\html.h ===
#ifndef _HTML_H
#define _HTML_H

#include "webvw.h"

interface IHTMLDocument2;

#define DECLAREWAITCURSOR2  HCURSOR hcursor_wait_cursor_save

//
// a class host for trident so that we can control what it downloads 
// and what it doesn't...
//
class CTridentHost : public IOleClientSite,
                     public IDispatch,
                     public IDocHostUIHandler
{
    public:
        CTridentHost();
        ~CTridentHost();

        HRESULT SetTrident( IOleObject * pTrident );

        // IUnknown
        STDMETHOD ( QueryInterface )( REFIID riid, void ** ppvObj );
        STDMETHOD_( ULONG, AddRef ) ( void );
        STDMETHOD_( ULONG, Release ) ( void );
        
        // IDispatch (ambient properties)
        STDMETHOD( GetTypeInfoCount ) (UINT *pctinfo);
        STDMETHOD( GetTypeInfo )(UINT itinfo, LCID lcid, ITypeInfo **pptinfo);
        STDMETHOD( GetIDsOfNames )(REFIID riid, OLECHAR **rgszNames, UINT cNames,
                                   LCID lcid, DISPID *rgdispid);
        STDMETHOD( Invoke )(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                            DISPPARAMS *pdispparams, VARIANT *pvarResult,
                            EXCEPINFO *pexcepinfo, UINT *puArgErr);

        // IOleClientSite
        STDMETHOD( SaveObject )(void);
        STDMETHOD( GetMoniker )(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk);
        STDMETHOD( GetContainer )(IOleContainer **ppContainer);
        STDMETHOD( ShowObject )(void);
        STDMETHOD( OnShowWindow )(BOOL fShow);
        STDMETHOD( RequestNewObjectLayout )(void);

        // IDocHostUIHandler
        STDMETHOD( ShowContextMenu )( DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved);
        STDMETHOD( GetHostInfo )( DOCHOSTUIINFO *pInfo);
        STDMETHOD( ShowUI )( DWORD dwID, IOleInPlaceActiveObject *pActiveObject,IOleCommandTarget *pCommandTarget,
            IOleInPlaceFrame *pFrame, IOleInPlaceUIWindow *pDoc);
        STDMETHOD( HideUI )( void);
        STDMETHOD( UpdateUI )( void);
        STDMETHOD( EnableModeless )( BOOL fEnable);
        STDMETHOD( OnDocWindowActivate )( BOOL fActivate);
        STDMETHOD( OnFrameWindowActivate )( BOOL fActivate);
        STDMETHOD( ResizeBorder )( LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow);
        STDMETHOD( TranslateAccelerator )( LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID);
        STDMETHOD( GetOptionKeyPath )( LPOLESTR *pchKey, DWORD dw);
        STDMETHOD( GetDropTarget )( IDropTarget *pDropTarget, IDropTarget **ppDropTarget);
        STDMETHOD( GetExternal )( IDispatch **ppDispatch);
        STDMETHOD( TranslateUrl )( DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut);
        STDMETHOD( FilterDataObject )( IDataObject *pDO, IDataObject **ppDORet);

    public:
        BITBOOL m_fOffline : 1;
        
   protected:
        long m_cRef;
};

class CHtmlThumb : public IExtractImage,
                   public IThumbnailCapture,
                   public IRunnableTask,
                   public IPropertyNotifySink,
                   public IPersistFile,
                   public IPersistMoniker,
                   public CComObjectRoot,
                   public CComCoClass< CHtmlThumb,&CLSID_HtmlThumbnailExtractor >
{
public:
    CHtmlThumb();
    ~CHtmlThumb();

    BEGIN_COM_MAP( CHtmlThumb )
        COM_INTERFACE_ENTRY( IExtractImage)
        COM_INTERFACE_ENTRY( IThumbnailCapture )
        COM_INTERFACE_ENTRY( IRunnableTask )
        COM_INTERFACE_ENTRY( IPropertyNotifySink )
        COM_INTERFACE_ENTRY( IPersistFile )
        COM_INTERFACE_ENTRY( IPersistMoniker )
    END_COM_MAP( )

    DECLARE_REGISTRY( CHtmlThumb,
                      _T("Shell.ThumbnailExtract.HTML.1"),
                      _T("Shell.ThumbnailExtract.HTML.1"),
                      IDS_HTMLTHUMBEXTRACT_DESC,
                      THREADFLAGS_APARTMENT);

    DECLARE_NOT_AGGREGATABLE( CHtmlThumb );

    // IExtractImage
    STDMETHOD (GetLocation) ( LPWSTR pszPathBuffer,
                              DWORD cch,
                              DWORD * pdwPriority,
                              const SIZE * prgSize,
                              DWORD dwRecClrDepth,
                              DWORD *pdwFlags );
 
    STDMETHOD (Extract)( HBITMAP * phBmpThumbnail );

    // IThumbnailCapture
    STDMETHOD (CaptureThumbnail) ( const SIZE * pMaxSize, IUnknown * pHTMLDoc2, HBITMAP * phbmThumbnail );

    // IRunnableTask 
    STDMETHOD (Run)( void ) ;
    STDMETHOD (Kill)( BOOL fWait );
    STDMETHOD (Suspend)( );
    STDMETHOD (Resume)( );
    STDMETHOD_( ULONG, IsRunning )( void );

    // IPropertyNotifySink
    STDMETHOD (OnChanged)( DISPID dispID);
    STDMETHOD (OnRequestEdit) ( DISPID dispID);

    // IPersistFile
    STDMETHOD (GetClassID )(CLSID *pClassID);
    STDMETHOD (IsDirty )();
    STDMETHOD (Load )( LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHOD (Save )( LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHOD (SaveCompleted )( LPCOLESTR pszFileName);
    STDMETHOD (GetCurFile )( LPOLESTR *ppszFileName);

    // IPersistMoniker
    STDMETHOD( Load )( BOOL fFullyAvailable, IMoniker *pimkName, LPBC pibc, DWORD grfMode);
    STDMETHOD( Save )( IMoniker *pimkName, LPBC pbc, BOOL fRemember);
    STDMETHOD( SaveCompleted )( IMoniker *pimkName, LPBC pibc);
    STDMETHOD( GetCurMoniker )( IMoniker **ppimkName);

protected:
    HRESULT InternalResume( void );
    HRESULT Create_URL_Moniker( IMoniker **ppMoniker );
    HRESULT WaitForRender( void );
    HRESULT Finish( HBITMAP * pBmp, const SIZE * prgSize, DWORD dwClrDepth );
    HRESULT CheckReadyState( );
    void ReportError( void ** pMsgArgs );
    
    LONG m_lState;
    BOOL m_fAsync;
    HANDLE m_hDone;
    CTridentHost m_Host;
    IHTMLDocument2 * m_pHTML;
    IOleObject * m_pOleObject;
    IConnectionPoint * m_pConPt;
    IViewObject * m_pViewObject;
    DWORD m_dwTimeout;
    DWORD m_dwCurrentTick;
    DWORD m_dwPropNotifyCookie;
    WCHAR m_szPath[MAX_PATH];
    SIZE m_rgSize;
    HBITMAP * m_phBmp;
    DWORD m_dwClrDepth;
    DECLAREWAITCURSOR2;
    DWORD m_dwXRenderSize;
    DWORD m_dwYRenderSize;
    IMoniker * m_pMoniker;
};

// time we wait before asking the internet explorer if it is done yet ...
#define TIME_PAUSE 200

// default timeout (seconds)
#define TIME_DEFAULT 90

HRESULT RegisterHTMLExtractor( void );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\htmlgen.cpp ===
#include "precomp.h"
#include <shutil.h>
#include "prevwnd.h"
#include "resource.h"
#pragma hdrstop

int DPA_ILFree(void *p, void *pData)
{
    ILFree((LPITEMIDLIST)p);
    return 1;
}

BOOL _SamePath(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    BOOL bSame = FALSE;
    TCHAR szName1[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidl1, SHGDN_FORPARSING, szName1, ARRAYSIZE(szName1), NULL)))
    {        
        TCHAR szName2[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl2, SHGDN_FORPARSING, szName2, ARRAYSIZE(szName2), NULL)))
        {
            bSame = (0 == StrCmpI(szName1, szName2));
        }
    }
    return bSame;
}
                                    
HRESULT _AddSuffix(LPCWSTR pwszSuffix, LPWSTR pwszBuffer, UINT cchBuffer)
{
    ASSERTMSG(pwszBuffer && pwszSuffix, "_AddSuffix -- invalid params to internal function");

    HRESULT hr = E_FAIL;
    LPWSTR pwszExt = PathFindExtension(pwszBuffer);
    if (pwszExt)
    {
        UINT cchSuffix = lstrlenW(pwszSuffix);
        UINT cchExt = lstrlenW(pwszExt);
        if (((pwszExt - pwszBuffer) + cchSuffix + cchExt) < cchBuffer)
        {
            memmove(pwszExt + cchSuffix, pwszExt, sizeof(WCHAR) * (1 + cchExt));
            memcpy(pwszExt, pwszSuffix, cchSuffix * sizeof(WCHAR));
            hr = S_OK;
        }
    }
    return hr;
}

HRESULT _GetImageName(HDPA hdpaItems, UINT uiDex, BOOL fAddSuffix, LPSTR* ppszOut)
{
    ASSERTMSG(hdpaItems && ppszOut && *ppszOut, "_GetImageName -- invalid params to internal function");

    HRESULT hr = E_FAIL;

    LPCITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(hdpaItems, uiDex);
    if (pidl)
    {
        TCHAR szName[MAX_PATH];
            
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName), NULL)))
        {
            if (fAddSuffix)
            {
                TCHAR szThumbSuffix[20];
                LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_SUFFIX, szThumbSuffix, ARRAYSIZE(szThumbSuffix));
                if (FAILED(_AddSuffix(szThumbSuffix, szName, ARRAYSIZE(szName))))
                {
                    return E_FAIL;
                }
            }

            USES_CONVERSION;
            *((*ppszOut)++) = '\"';
            StrCpyA(*ppszOut, W2A(szName));
            *ppszOut += lstrlenA(*ppszOut);            
            *((*ppszOut)++) = '\"';

            hr = S_OK;
        }
    }

    return hr;
}

HRESULT GetFolderFromSite(IUnknown *punkSite, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = SHGetIDListFromUnk(psf, ppidl);
            psf->Release();
        }
        pfv->Release();
    }
    return hr;
}

HRESULT CPreviewWnd::_CreateWebViewer()
{
    HRESULT hr = E_FAIL;

    TCHAR szPick[128];
    LoadString(_Module.GetModuleInstance(), IDS_CHOOSE_DIR, szPick, ARRAYSIZE(szPick));

    BROWSEINFO bi = { NULL, NULL, NULL, szPick, BIF_NEWDIALOGSTYLE, 0, 0 };
    LPITEMIDLIST pidlDest = SHBrowseForFolder(&bi);
    if (pidlDest)
    {
        // get the IStorage we'll write to
        IStorage* pstgDest;
        hr = SHBindToObjectEx(NULL, pidlDest, NULL, IID_PPV_ARG(IStorage, &pstgDest));
        if (SUCCEEDED(hr))
        {
            // get the images we'll write
            HDPA hdpaItems = NULL;
            hr = _GetSelectedImages(&hdpaItems);
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlFolder;
                hr = GetFolderFromSite(m_punkSite, &pidlFolder);
                if (SUCCEEDED(hr))
                {
                    UINT cItems = DPA_GetPtrCount(hdpaItems);

                    // we may write them to the directory chosen if it's not the original dir
                    if (!_SamePath(pidlFolder, pidlDest))
                    {
                        IStorage* pstgSrc;
                        hr = SHBindToObjectEx(NULL, pidlFolder, NULL, IID_PPV_ARG(IStorage, &pstgSrc));
                        if (SUCCEEDED(hr))
                        {
                            hr = _CopyImages(pstgSrc, pstgDest, cItems, hdpaItems);
                            pstgSrc->Release();
                        }
                    }
                    ILFree(pidlFolder);

                    // write the thumbnails to the directory chosen
                    if (SUCCEEDED(hr))
                    {
                        BOOL fThumbWritten;
                        hr = _CopyThumbnails(pidlDest, cItems, hdpaItems, &fThumbWritten);
                        if (SUCCEEDED(hr))
                        {
                            // write the HTML pages
                            hr = _WriteHTML(pstgDest, cItems, hdpaItems);
                        }
                    }
                }

                DPA_DestroyCallback(hdpaItems, DPA_ILFree, NULL);
            }
            pstgDest->Release();
        }
        ILFree(pidlDest);
    }
    return hr;
}

HRESULT CPreviewWnd::_FormatHTML(UINT cItems, HDPA hdpaItems, 
                                 LPSTR pszTemplate, DWORD cbTemplateSize,
                                 LPSTR psz1, LPSTR psz2, UINT ui1, LPSTR* ppszOut)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppszOut = (LPSTR)LocalAlloc(LPTR, cbTemplateSize + lstrlenA(psz1) + lstrlenA(psz2) + 11);
    if (*ppszOut)
    {
        LPSTR pszSrc = pszTemplate;
        LPSTR pszDest = *ppszOut;
        UINT uiStage = 0;
        while (*pszSrc && ((pszSrc - pszTemplate) < (INT)cbTemplateSize))
        {
            if ('%' == *pszSrc && 's' == *(pszSrc + 1) && 0 == uiStage) // list of images
            {
                StrCpyA(pszDest, psz1);
                pszDest += lstrlenA(psz1);
                pszSrc += 2;
                uiStage++;
            }
            else if ('%' == *pszSrc && 's' == *(pszSrc + 1) && 1 == uiStage) // list of thumbnails
            {
                StrCpyA(pszDest, psz2);
                pszDest += lstrlenA(psz2);
                pszSrc += 2;
                uiStage++;
            }
            else if ('%' == *pszSrc && 'd' == *(pszSrc + 1) && 2 == uiStage) // number of images
            {
                pszDest += wsprintfA(pszDest, "%d", ui1);
                pszSrc += 2;
                uiStage++;
            }
            else
            {
                *pszDest = *pszSrc;
                pszSrc++;
                pszDest++;
            }
        }

        hr = S_OK;
    }

    return hr;
}

const char c_szNetText1[] = "<center><a href=\"#\" onclick=\"nextFilmImage()\"><img width=80% alt=%s src=%s></a></center>";
const char c_szNetText2[] = "<td><a href=\"#\" onclick=\"filmSelect(%d)\"><img alt=%s src=%s></a></td>\r\n";
const char c_szNetText3[] = "<center><a href=\"#\" onclick=\"nextImage()\"><img width=80% alt=%s src=%s></a></center>";
const char c_szNetText4[] = "<td><a href=\"#\" onclick=\"contactSelect(%d)\"><img alt=%s src=%s></a></td>\r\n";

HRESULT CPreviewWnd::_FormatHTMLNet(UINT cItems, HDPA hdpaItems, 
                                    LPSTR pszTemplate, DWORD cbTemplateSize,                                    
                                    LPSTR psz1, UINT ui1, LPSTR* ppszOut)
{
    HRESULT hr = E_OUTOFMEMORY;
    USES_CONVERSION;

    *ppszOut = (LPSTR)LocalAlloc(LPTR, 2 * (cbTemplateSize + (11 * (cItems + 1)) + lstrlenA(psz1) * 4)); // ISSUE: we need to figure out how big this should be
    if (*ppszOut)
    {
        LPSTR pszSrc = pszTemplate;
        LPSTR pszDest = *ppszOut;
        UINT uiStage = 0;
        CHAR szStringFormatted[256];

        while (*pszSrc && ((pszSrc - pszTemplate) < (INT)cbTemplateSize))
        {
            if ('%' == *pszSrc && *(pszSrc + 1) == 's' && 0 == uiStage)
            {
                StrCpyA(pszDest, psz1);
                pszDest += lstrlenA(psz1);
                pszSrc += 2;
                uiStage++;
            }
            else if ('%' == *pszSrc && *(pszSrc + 1) == 'd' && 1 == uiStage)
            {
                pszDest += wsprintfA(pszDest, "%d", ui1);
                pszSrc += 2;
                uiStage++;
            }
            else if ('%' == *pszSrc && 's' == *(pszSrc + 1) && (2 == uiStage || 4 == uiStage)) // IDS_WEBVIEWER_NETTEXT_1, 3
            {                    
                CHAR szFirstImage[MAX_PATH];
                LPSTR pszFirstImage = szFirstImage;
                if (SUCCEEDED(_GetImageName(hdpaItems, 0, FALSE, &pszFirstImage)))
                {
                    *pszFirstImage = 0;
                    DWORD cchStringFormatted = wsprintfA(szStringFormatted, uiStage == 2 ? c_szNetText1 : c_szNetText3,
                                                         szFirstImage, szFirstImage);
                    StrCpyA(pszDest, szStringFormatted);
                    pszDest += cchStringFormatted;
                    pszSrc += 2;
                }
                uiStage++;
            }
            else if ('s' == *pszSrc && 's' == *(pszSrc + 1) && (3 == uiStage || 5 == uiStage)) // IDS_WEBVIEWER_NETTEXT_2, 4
            {                    
                WCHAR wszLoadStringThumb[20];
                LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_SUFFIX, wszLoadStringThumb, ARRAYSIZE(wszLoadStringThumb));
                for (UINT i = 0; i < cItems; i++)
                {
                    CHAR szImage[MAX_PATH];
                    LPSTR pszImage = szImage;
                    if (SUCCEEDED(_GetImageName(hdpaItems, i, TRUE, &pszImage)))
                    {
                        *pszImage = 0;
                        DWORD cchStringFormatted = wsprintfA(szStringFormatted, 3 == uiStage ? c_szNetText2 : c_szNetText4,
                                                             i, szImage, szImage);
                        StrCpyA(pszDest, szStringFormatted);
                        pszDest += cchStringFormatted;
                    }
                }
                pszSrc += 2;
                uiStage++;
            }
            else
            {
                *pszDest = *pszSrc;
                pszSrc++;
                pszDest++;
            }
        }

        hr = S_OK;
    }

    return hr;
}

#define IE_VIEWER 1
#define NET_VIEWER 2

HRESULT CPreviewWnd::_WriteHTML(IStorage* pStgDest, UINT cItems, HDPA hdpaItems)
{
    HRESULT hr = E_FAIL;

    const UINT rguiIDs[2] = { IDR_VIEWERHTML , IDR_VIEWERHTML_NET };
    LPCWSTR rgwszFiles[2] = { L"viewer.htm" , L"viewern.htm"};
    const DWORD rgdwTypes[2] = {  IE_VIEWER, NET_VIEWER };

    LPSTR pszImages = _GetImageList(cItems, hdpaItems, FALSE);

    if (pszImages)
    {
        LPSTR pszThumbs = _GetImageList(cItems, hdpaItems, TRUE);
        if (pszThumbs)
        {
            hr = S_OK;
            for (int i = 0; i < ARRAYSIZE(rguiIDs) && SUCCEEDED(hr); i++)
            {
                HRSRC hrsrc = FindResource(_Module.GetModuleInstance(), MAKEINTRESOURCE(rguiIDs[i]), RT_HTML);
                if (hrsrc)
                {
                    DWORD dwGlobSize = SizeofResource(_Module.GetModuleInstance(), hrsrc);

                    HGLOBAL hglob = LoadResource(_Module.GetModuleInstance(), hrsrc);
                    if (hglob)
                    {
                        LPSTR pszHTML = (LPSTR)LockResource(hglob);
                        if (pszHTML)
                        {
                            LPSTR pszHTMLFormatted;

                            if (IE_VIEWER == rgdwTypes[i]) // build the IE viewers
                            {
                                hr = _FormatHTML(cItems, hdpaItems, pszHTML, dwGlobSize, pszImages, pszThumbs, cItems, &pszHTMLFormatted);
                            }                                                                
                            else // build the netscape viewers
                            {
                                hr = _FormatHTMLNet(cItems, hdpaItems, pszHTML, dwGlobSize, pszImages, cItems, &pszHTMLFormatted);
                            }
            
                            if (SUCCEEDED(hr))
                            {
                                IStream* pStream;
                                if (SUCCEEDED(pStgDest->CreateStream(rgwszFiles[i], STGM_WRITE | STGM_CREATE, 0, 0, &pStream)))
                                {
                                    if (SUCCEEDED(pStream->Write(pszHTMLFormatted, lstrlenA(pszHTMLFormatted), NULL)))
                                    {
                                        hr = S_OK;
                                    }
                                    pStream->Release();
                                }
                                
                                LocalFree(pszHTMLFormatted);
                            }
                        }
                        FreeResource(hglob);
                    }
                }
            }
            LocalFree(pszThumbs);
        }
        LocalFree(pszImages);
    }
    return hr;
}

LPSTR CPreviewWnd::_GetImageList(UINT cItems, HDPA hdpaItems, BOOL fAddSuffix)
{
    LPSTR pszRetVal = (LPSTR)LocalAlloc(LPTR, cItems * MAX_PATH);
    if (pszRetVal)
    {        
        LPSTR pszPtr = pszRetVal;
        
        for (UINT i = 0; (i < cItems); i++)
        {
            if (SUCCEEDED(_GetImageName (hdpaItems, i, fAddSuffix, &pszPtr)))
            {
                if (i != (cItems - 1))
                {
                    *pszPtr++ = ',';
                }
                *pszPtr++ = '\r';
                *pszPtr++ = '\n';
            }
        }
    
        LocalReAlloc(pszRetVal, lstrlenA(pszRetVal), LMEM_MOVEABLE);
    }

    return pszRetVal;
}

// make sure it is not one of our generated thumbnails

BOOL CPreviewWnd::_IsThumbnail(LPCTSTR pszPath)
{
    // now check if is ???__thumb.gif or something, if so then is not a picture we should include
    TCHAR szThumbSuffix[20];
    LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_SUFFIX, szThumbSuffix, ARRAYSIZE(szThumbSuffix));
    int cchThumbSuffix = lstrlen(szThumbSuffix);

    LPCTSTR pszDot = PathFindExtension(pszPath);

    BOOL fIsThumbnail = FALSE;

    if ((pszDot - pszPath) > cchThumbSuffix)
    {
        if (0 == lstrncmp(pszDot - cchThumbSuffix, szThumbSuffix, cchThumbSuffix))
        {
            fIsThumbnail = TRUE;
        }
    }
    return fIsThumbnail;
}

HRESULT CPreviewWnd::_GetSelectedImages(HDPA* phdpaItems)
{
    HRESULT hr = E_OUTOFMEMORY;

    *phdpaItems = DPA_Create(5);
    if (*phdpaItems)
    {
        LPITEMIDLIST pidl;
        for (UINT i = 0; SUCCEEDED(_GetItem(i, &pidl)); i++)
        {
            TCHAR szName[MAX_PATH];
            hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName), NULL);
            if (SUCCEEDED(hr) && !_IsThumbnail(szName))
            {
                if (DPA_AppendPtr(*phdpaItems, pidl) >= 0)
                {
                    pidl = NULL;    // don't free below
                }
            }
            ILFree(pidl);   // accepts NULL
        }
    }

    return hr;
}


HRESULT CPreviewWnd::_CopyImages_SetupProgress(IProgressDialog** ppProgress,
                                               LPWSTR pwszBanner)
{
    HRESULT hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER,
                                  IID_PPV_ARG(IProgressDialog, ppProgress));
    if (SUCCEEDED(hr))
    {
        hr = (*ppProgress)->SetTitle(pwszBanner);
        if (SUCCEEDED(hr))
        {
            hr = (*ppProgress)->SetAnimation(_Module.GetModuleInstance(), IDA_FILECOPY);
            if (SUCCEEDED(hr))
            {
                hr = (*ppProgress)->StartProgressDialog(NULL, NULL, PROGDLG_NORMAL, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = (*ppProgress)->SetProgress(0, 1);
                }
            }
        }
    }

    return hr;
}

// note: this function will quite happily copy from istorage to itself, caller's responsibility
//       not to call with pstgSrc and pstgDest referring to same place
HRESULT CPreviewWnd::_CopyImages(IStorage* pstgSrc, IStorage* pstgDest, UINT cItems, HDPA hdpaItems)
{
    HRESULT hr = S_OK;

    ASSERTMSG(pstgSrc != NULL && pstgDest != NULL, "CPreviewWnd::_CopyImages -- invalid params to internal function");

    if (cItems > 0)
    {
        WCHAR wszMsgBox[128];
        WCHAR wszMsgBoxTitle[64];
        LoadString(_Module.GetModuleInstance(), IDS_COPYIMAGES_MSGBOX, wszMsgBox, ARRAYSIZE(wszMsgBox));
        LoadString(_Module.GetModuleInstance(), IDS_COPYIMAGES_MSGBOXTITLE, wszMsgBoxTitle, ARRAYSIZE(wszMsgBoxTitle));

        hr = S_OK;
        int iResult = MessageBox(wszMsgBox, wszMsgBoxTitle, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 | MB_APPLMODAL);
        if (IDYES == iResult)
        {
            WCHAR wszProgressText[64];
            LoadString(_Module.GetModuleInstance(), IDS_COPYIMAGES_PROGRESSTEXT, wszProgressText, ARRAYSIZE(wszProgressText));

            IProgressDialog* pProgress;
            hr = _CopyImages_SetupProgress(&pProgress, wszProgressText);
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; (i < cItems) && SUCCEEDED(hr) && !pProgress->HasUserCancelled(); i++)
                {
                    LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(hdpaItems, i);
                    WCHAR wszFullName[MAX_PATH];
                    hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, wszFullName, ARRAYSIZE(wszFullName), NULL);
                    if (SUCCEEDED(hr))
                    {
                        LPTSTR pszName = PathFindFileName(wszFullName);
                        hr = pProgress->SetLine(1, pszName, TRUE, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = pstgSrc->MoveElementTo(pszName, pstgDest, pszName, STGMOVE_COPY);
                            if (SUCCEEDED(hr))
                            {
                                hr = pProgress->SetProgress(i, cItems);
                            }
                        }
                    }
                }
                pProgress->StopProgressDialog();
                pProgress->Release();
            }
        }
    }
    return hr;
}

HRESULT CPreviewWnd::_CopyThumbnails(LPITEMIDLIST pidlDest, UINT cItems, HDPA hdpaItems, BOOL* fThumbWritten)
{
    HRESULT hr = E_FAIL;

    ASSERTMSG(pidlDest != NULL && fThumbWritten != NULL, "CPreviewWnd::_CopyThumbnails -- invalid params to internal function");

    WCHAR pwszDestPath[MAX_PATH];
    hr = SHGetNameAndFlags(pidlDest, SHGDN_FORPARSING, pwszDestPath, ARRAYSIZE(pwszDestPath), NULL);

    *fThumbWritten = FALSE;

    WCHAR wszMsgBox[128];
    WCHAR wszMsgBoxTitle[64];
    LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_MSGBOX, wszMsgBox, ARRAYSIZE(wszMsgBox));
    LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_MSGBOXTITLE, wszMsgBoxTitle, ARRAYSIZE(wszMsgBoxTitle));

    hr = S_OK;
    if (IDYES == MessageBox(wszMsgBox, wszMsgBoxTitle, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON1 | MB_APPLMODAL))
    {
        *fThumbWritten = TRUE;

        IProgressDialog* pProgress;
        WCHAR wszProgressText[64];
        hr = E_FAIL;
        LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_PROGRESSTEXT, wszProgressText, ARRAYSIZE(wszProgressText));

        hr = _CopyImages_SetupProgress(&pProgress, wszProgressText);
        if (SUCCEEDED(hr))
        {
            IShellImageDataFactory * pImgFact;

            hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &pImgFact));
            if (SUCCEEDED(hr))
            {
                for (UINT i = 0; (i < cItems) && SUCCEEDED(hr) && !pProgress->HasUserCancelled(); i++)
                {
                    LPITEMIDLIST pidl = (LPITEMIDLIST)DPA_GetPtr(hdpaItems, i);
                    WCHAR wszFullName[MAX_PATH];
                    hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, wszFullName, ARRAYSIZE(wszFullName), NULL);
                    if (SUCCEEDED(hr))
                    {
                        IShellImageData* pImage;
                        hr = pImgFact->CreateImageFromFile(wszFullName, &pImage);
                        if (SUCCEEDED(hr))
                        {
                            SIZE size;
                            hr = pImage->Decode(SHIMGDEC_DEFAULT, 0, 0);

                            if (SUCCEEDED(hr))
                            {
                                hr = pImage->GetSize(&size);

                                if (SUCCEEDED(hr))
                                {
                                    if (size.cx > size.cy)
                                    {
                                        hr = pImage->Scale(100, 0, InterpolationModeDefault);
                                    }
                                    else
                                    {
                                        hr = pImage->Scale(0, 100, InterpolationModeDefault);
                                    }

                                    if (SUCCEEDED(hr))
                                    {
                                        // save the file
                                        IPersistFile *ppfImg;
                                        hr = pImage->QueryInterface(IID_PPV_ARG(IPersistFile, &ppfImg));
                                        if (SUCCEEDED(hr))
                                        {
                                            hr = E_FAIL;

                                            LPWSTR pwszFileName = PathFindFileName(wszFullName);
                                            if (pwszFileName)
                                            {
                                                memmove(wszFullName, pwszFileName, sizeof(WCHAR) * (1+ lstrlenW(pwszFileName)));
                                                TCHAR szThumbSuffix[20];
                                                LoadString(_Module.GetModuleInstance(), IDS_THUMBNAIL_SUFFIX, szThumbSuffix, ARRAYSIZE(szThumbSuffix));

                                                hr = _AddSuffix(szThumbSuffix, wszFullName, ARRAYSIZE(wszFullName));
                                                if (SUCCEEDED(hr))
                                                {
                                                    WCHAR wszFileName[MAX_PATH];
                                                    if (PathCombine(wszFileName, pwszDestPath, wszFullName))
                                                    {
                                                        pProgress->SetLine(1, wszFileName, TRUE, NULL); // ignore progress errors
                                                        hr = ppfImg->Save(wszFileName, TRUE);
                                                        pProgress->SetProgress(i, cItems); // ignore progress errors
                                                    }
                                                }
                                            }
                                            ppfImg->Release();
                                        }
                                    }
                                }
                            }
                            pImage->Release();
                        }
                    }
                }
                pImgFact->Release();
            }
            pProgress->StopProgressDialog();
            pProgress->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\imagprop.h ===
#ifndef _IMAGPROP_H_
#define _IMAGPROP_H_

typedef void (*FNPROPCHANGE)(IShellImageData *, SHCOLUMNID*);

//
// CImagePropSet defines an IPropertyStorage
// implementation for image files. The properties are backed by GDI+ interfaces.
// 

class CImagePropSet : public IPropertyStorage
{
public:
    CImagePropSet(Image *pimg, IShellImageData *pData, IPropertyStorage *pps, REFFMTID fmtid, FNPROPCHANGE fnCallback=NULL);
    HRESULT SyncImagePropsToStorage();
    void SaveProps(Image *pImage, CDSA<SHCOLUMNID> *pdsaChanges);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPropertyStorage methods
    STDMETHODIMP ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);
    STDMETHODIMP WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst);
    STDMETHODIMP DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]);
    STDMETHODIMP ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]);
    STDMETHODIMP WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]);
    STDMETHODIMP DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]);
    STDMETHODIMP SetClass(REFCLSID clsid);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP Enum(IEnumSTATPROPSTG** ppenm);
    STDMETHODIMP Stat(STATPROPSETSTG* pstatpsstg);
    STDMETHODIMP SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime);

private:
    ~CImagePropSet();
    void _PopulatePropStorage();
    HRESULT _PropVarToImgProp(PROPID pid, const PROPVARIANT *pvar, PropertyItem *pprop, BOOL bUnicode);
    HRESULT _PropImgToPropvar(PropertyItem *pi, PROPVARIANT *pvar, BOOL bUnicode);
    HRESULT _MapPropidToImgPropid(PROPID propid, PROPID *ppid, PROPID *pidUnicode);
    HRESULT _MapImgPropidToPropid(PROPID propid, PROPID *ppid, BOOL *pbUnicode);
    HRESULT _GetImageSummaryProps(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]);


    LONG _cRef;
    Image *_pimg;
    IShellImageData *_pData; // addref this guy so our Image isn't deleted behind our back
    IPropertyStorage *_ppsImg;
    BOOL _fDirty;
    FMTID _fmtid;
    FNPROPCHANGE _fnPropChanged;
    BOOL _fEditable;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\guids.h ===
// GUIDs for the categories of tasks that we have:
DEFINE_GUID(TOID_PrimaryDecode, 0xAC5B936C, 0xFB81, 0x4E8B, 0x9B, 0x46, 0x74, 0x76, 0xFF, 0xB8, 0x3A, 0x81);
DEFINE_GUID(TOID_SlideshowDecode, 0x2b4ce8db, 0x3372, 0x465e, 0x9f, 0x27, 0xad, 0x60, 0x3e, 0xac, 0x4e, 0xa0);
DEFINE_GUID(TOID_DrawFrame, 0x702B4720, 0xCFAA, 0x4FB8, 0x93, 0xE8, 0xF3, 0x53, 0x9C, 0x18, 0x40, 0xE2);
DEFINE_GUID(TOID_DrawSlideshowFrame, 0x7d24187d, 0xb5be, 0x4226, 0x92, 0x8f, 0x8e, 0xda, 0x7b, 0x14, 0x94, 0x1c);

// Class ID for the context menu handler
/* e84fda7c-1d6a-45f6-b725-cb260c236066 */
DEFINE_GUID(CLSID_PhotoVerbs, 0xe84fda7c, 0x1d6a, 0x45f6, 0xb7, 0x25, 0xcb, 0x26, 0x0c, 0x23, 0x60, 0x66);

// the Media Manager Thumbnail Property set FormatID
// {4A839CC0-F8FF-11ce-A06B-00AA00A71191}
DEFINE_GUID( FMTID_CmsThumbnailPropertySet, 0x4a839cc0, 0xf8ff, 0x11ce, 0xa0, 0x6b, 0x0, 0xaa, 0x0, 0xa7, 0x11, 0x91 );


DEFINE_GUID(IID_IThumbnailMaker, 0x7aaa28d2, 0x3bf2, 0x11cf, 0xb6, 0xe6, 0x0, 0xaa, 0x0, 0xbb, 0xba, 0x9e);

// html thumbnail extractor
// {EAB841A0-9550-11cf-8C16-00805F1408F3}
DEFINE_GUID( CLSID_HtmlThumbnailExtractor, 0xeab841a0, 0x9550, 0x11cf, 0x8c, 0x16, 0x0, 0x80, 0x5f, 0x14, 0x8, 0xf3);
#define CLSIDSTR_HtmlThumbnailExtractor     "{EAB841A0-9550-11cf-8C16-00805F1408F3}"

// GDI+ thumbnail extractor .....
// {3F30C968-480A-4C6C-862D-EFC0897BB84B}
DEFINE_GUID( CLSID_GdiThumbnailExtractor, 0x3f30c968, 0x480a, 0x4c6c, 0x86, 0x2d, 0xef, 0xc0, 0x89, 0x7b, 0xb8, 0x4b);
#define CLSIDSTR_GdiThumbnailExtractor  "{3F30C968-480A-4C6C-862D-EFC0897BB84B}"

// handles the thumbnail in FMTID_SummaryInfo property set on docfiles...
// {9DBD2C50-62AD-11d0-B806-00C04FD706EC}
DEFINE_GUID( CLSID_DocfileThumbnailHandler, 0x9dbd2c50, 0x62ad, 0x11d0, 0xb8, 0x6, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec);
#define CLSIDSTR_DocfileThumbnailHandler    "{9DBD2C50-62AD-11d0-B806-00C04FD706EC}"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\html.cpp ===
#include "precomp.h"
#include <urlmon.h>
#include <mshtml.h>
#include <mshtmdid.h>
#include <idispids.h>
#include <ocidl.h>
#include <optary.h>
#include "thumbutil.h"

#ifdef SetWaitCursor
#undef SetWaitCursor
#endif
#define SetWaitCursor()   hcursor_wait_cursor_save = SetCursor(LoadCursorA(NULL, (LPCSTR) IDC_WAIT))
#define ResetWaitCursor() SetCursor(hcursor_wait_cursor_save)

#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))

#define REGSTR_THUMBNAILVIEW    "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Thumbnail View"

// the default size to render to .... these constants must be the same
#define DEFSIZE_RENDERWIDTH     800
#define DEFSIZE_RENDERHEIGHT    800

CHAR const c_szRegValueTimeout[] = "HTMLExtractTimeout";

#define PROGID_HTML L"htmlfile"
#define PROGID_MHTML    L"mhtmlfile"
#define PROGID_XML      L"xmlfile"

#define DLCTL_DOWNLOAD_FLAGS  (DLCTL_DLIMAGES | \
                                DLCTL_VIDEOS | \
                                DLCTL_NO_DLACTIVEXCTLS | \
                                DLCTL_NO_RUNACTIVEXCTLS | \
                                DLCTL_NO_JAVA | \
                                DLCTL_NO_SCRIPTS | \
                                DLCTL_SILENT)


// get color resolution of the current display.
UINT GetCurColorRes(void)
{
    HDC hdc = GetDC(NULL);
    UINT uColorRes = GetDeviceCaps(hdc, PLANES) * GetDeviceCaps(hdc, BITSPIXEL);
    ReleaseDC(NULL , hdc);
    return uColorRes;
}



// Register the classes.

CHtmlThumb::CHtmlThumb()
{
    m_lState = IRTIR_TASK_NOT_RUNNING;
    ASSERT(!m_fAsync);
    ASSERT(!m_hDone);
    ASSERT(!m_pHTML);
    ASSERT(!m_pOleObject);
    ASSERT(!m_pMoniker);

    m_dwXRenderSize = DEFSIZE_RENDERWIDTH;
    m_dwYRenderSize = DEFSIZE_RENDERHEIGHT;
}

CHtmlThumb::~CHtmlThumb()
{
    // make sure we are not registered for callbacks...
    if (m_pConPt)
    {
        m_pConPt->Unadvise(m_dwPropNotifyCookie);
        ATOMICRELEASE(m_pConPt);
    }
    
    if (m_hDone)
    {
        CloseHandle(m_hDone);
    }

    ATOMICRELEASE(m_pHTML);
    ATOMICRELEASE(m_pOleObject);
    ATOMICRELEASE(m_pViewObject);
    ATOMICRELEASE(m_pMoniker);
}

STDMETHODIMP CHtmlThumb::Run()
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::Kill(BOOL fWait)
{
    if (m_lState == IRTIR_TASK_RUNNING)
    {
        LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_PENDING);
        if (lRes == IRTIR_TASK_FINISHED)
        {
            m_lState = lRes;
        }
        else if (m_hDone)
        {
            // signal the event it is likely to be waiting on
            SetEvent(m_hDone);
        }
        
        return S_OK;
    }
    else if (m_lState == IRTIR_TASK_PENDING || m_lState == IRTIR_TASK_FINISHED)
    {
        return S_FALSE;
    }

    return E_FAIL;
}

STDMETHODIMP CHtmlThumb::Suspend()
{
    if (m_lState != IRTIR_TASK_RUNNING)
    {
        return E_FAIL;
    }

    // suspend ourselves
    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_SUSPENDED);
    if (lRes == IRTIR_TASK_FINISHED)
    {
        m_lState = lRes;
        return S_OK;
    }

    // if it is running, then there is an Event Handle, if we have passed where
    // we are using it, then we are close to finish, so it will ignore the suspend
    // request
    ASSERT(m_hDone);
    SetEvent(m_hDone);
    
    return S_OK;
}

STDMETHODIMP CHtmlThumb::Resume()
{
    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        return E_FAIL;
    }
    
    ResetEvent(m_hDone);
    m_lState = IRTIR_TASK_RUNNING;
    
    // the only point we allowed for suspension was in the wait loop while
    // trident is doing its stuff, so we just restart where we left off...
    SetWaitCursor();
    HRESULT hr = InternalResume();   
    ResetWaitCursor();
    return hr;
}

STDMETHODIMP_(ULONG) CHtmlThumb::IsRunning()
{
    return m_lState;
}

STDMETHODIMP CHtmlThumb::OnChanged(DISPID dispID)
{
    if (DISPID_READYSTATE == dispID && m_pHTML && m_hDone)
    {
        CheckReadyState();
    }

    return S_OK;
}

STDMETHODIMP CHtmlThumb::OnRequestEdit (DISPID dispID)
{
    return E_NOTIMPL;
}

// IExtractImage
STDMETHODIMP CHtmlThumb::GetLocation(LPWSTR pszPathBuffer, DWORD cch,
                                     DWORD * pdwPriority, const SIZE * prgSize,
                                     DWORD dwRecClrDepth, DWORD *pdwFlags)
{
    HRESULT hr = S_OK;

    m_rgSize = *prgSize;
    m_dwClrDepth = dwRecClrDepth;

    // fix the max colour depth at 8 bit, otherwise we are going to allocate a boat load of
    // memory just to scale the thing down.
    DWORD dwColorRes = GetCurColorRes();
    
    if (m_dwClrDepth > dwColorRes && dwColorRes >= 8)
    {
        m_dwClrDepth = dwColorRes;
    }
    
    if (*pdwFlags & IEIFLAG_SCREEN)
    {
        HDC hdc = GetDC(NULL);
        
        m_dwXRenderSize = GetDeviceCaps(hdc, HORZRES);
        m_dwYRenderSize = GetDeviceCaps(hdc, VERTRES);

        ReleaseDC(NULL, hdc);
    }
    if (*pdwFlags & IEIFLAG_ASPECT)
    {
        // scale the rect to the same proportions as the new one passed in
        if (m_rgSize.cx > m_rgSize.cy)
        {
            // make the Y size bigger
            m_dwYRenderSize = MulDiv(m_dwYRenderSize, m_rgSize.cy, m_rgSize.cx);
        }
        else
        {
            // make the X size bigger
            m_dwXRenderSize = MulDiv(m_dwXRenderSize, m_rgSize.cx, m_rgSize.cy);
        }            
    }

    // scale our drawing size to match the in
    if (*pdwFlags & IEIFLAG_ASYNC)
    {
        hr = E_PENDING;

        // much lower priority, this task could take ages ...
        *pdwPriority = 0x00010000;
        m_fAsync = TRUE;
    }

    m_Host.m_fOffline = BOOLIFY(*pdwFlags & IEIFLAG_OFFLINE);
    
    if (m_pMoniker)
    {
        LPOLESTR pszName = NULL;
        hr = m_pMoniker->GetDisplayName(NULL, NULL, &pszName);
        if (SUCCEEDED(hr))
        {
            StrCpyNW(pszPathBuffer, pszName, cch);
            CoTaskMemFree(pszName);
        }
    }
    else
    {
        StrCpyNW(pszPathBuffer, m_szPath, cch);
    }

    *pdwFlags = IEIFLAG_CACHE;

    return hr;
}

STDMETHODIMP CHtmlThumb::Extract(HBITMAP * phBmpThumbnail)
{
    if (m_lState != IRTIR_TASK_NOT_RUNNING)
    {
        return E_FAIL;
    }

    // check we were initialized somehow..
    if (m_szPath[0] == 0 && !m_pMoniker)
    {
        return E_FAIL;
    }

    // we use manual reset so that once fired we will always get it until we reset it...
    m_hDone = CreateEventA(NULL, TRUE, TRUE, NULL);
    if (!m_hDone)
    {
        return E_OUTOFMEMORY;
    }
    ResetEvent(m_hDone);
    
    // the one thing we cache is the place where the result goes....
    m_phBmp = phBmpThumbnail; 
    
    IMoniker *pURLMoniker = NULL;
    CLSID clsid;
    IUnknown *pUnk = NULL;
    IConnectionPointContainer * pConPtCtr = NULL;
    LPCWSTR pszDot = NULL;
    BOOL fUrl = FALSE;
    LPCWSTR pszProgID = NULL;
    
    if (!m_pMoniker)
    {
        // work out what the extension is....
        pszDot = PathFindExtension(m_szPath);
        if (pszDot == NULL)
        {
            return E_UNEXPECTED;
        }

        // check for what file type it is ....
        if (StrCmpIW(pszDot, L".htm") == 0 || 
            StrCmpIW(pszDot, L".html") == 0 ||
            StrCmpIW(pszDot, L".url") == 0)
        {
            pszProgID = PROGID_HTML;
        }
        else if (StrCmpIW(pszDot, L".mht") == 0 ||
                 StrCmpIW(pszDot, L".mhtml") == 0 ||
                 StrCmpIW(pszDot, L".eml") == 0 ||
                 StrCmpIW(pszDot, L".nws") == 0)
        {
            pszProgID = PROGID_MHTML;
        }
        else if (StrCmpIW(pszDot, L".xml") == 0)
        {
            pszProgID = PROGID_XML;
        }
        else
            return E_INVALIDARG;
    }
    else
    {
        pszProgID = PROGID_HTML;
    }
    
    HRESULT hr = S_OK;

    LONG lRes = InterlockedExchange(&m_lState, IRTIR_TASK_RUNNING);
    if (lRes == IRTIR_TASK_PENDING)
    {
        ResetWaitCursor();
        m_lState = IRTIR_TASK_FINISHED;
        return E_FAIL;
    }

    LPWSTR pszFullURL = NULL;
        
    if (m_pMoniker)
    {
        pURLMoniker = m_pMoniker;
        pURLMoniker->AddRef();
    }
    else if (StrCmpIW(pszDot, L".url") == 0)
    {
        hr = Create_URL_Moniker(&pURLMoniker);
        if (FAILED(hr))
        {
            return hr;
        }
        fUrl = TRUE;
    }

    SetWaitCursor();
    
    // reached here with a valid URL Moniker hopefully.....
    // or we are to use the text string and load it from a file ...
    // now fish around in the registry for the data for the MSHTML control ...

    hr = CLSIDFromProgID(pszProgID, &clsid);
    if (hr == S_OK)
    {
        hr = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER,
                               IID_PPV_ARG(IUnknown, &pUnk));
    }

    if (SUCCEEDED(hr))
    {
        // now set the extent of the object ....
        hr = pUnk->QueryInterface(IID_PPV_ARG(IOleObject, &m_pOleObject));
    }

    if (SUCCEEDED(hr))
    {
        // give trident to our hosting sub-object...
        hr = m_Host.SetTrident(m_pOleObject);
    }
    
    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IViewObject, &m_pViewObject));
    }

    // try and load the file, either through the URL moniker or
    // via IPersistFile::Load()
    if (SUCCEEDED(hr))
    {
        if (pURLMoniker != NULL)
        {
            IBindCtx *pbc = NULL;
            IPersistMoniker * pPersistMon = NULL;
                
            // have reached here with the interface I need ...  
            hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistMoniker, &pPersistMon));
            if (SUCCEEDED(hr))
            {
                hr = CreateBindCtx(0, &pbc);
            }
            if (SUCCEEDED(hr) && fUrl)
            {
                IHtmlLoadOptions *phlo;
                hr = CoCreateInstance(CLSID_HTMLLoadOptions, NULL, CLSCTX_INPROC_SERVER,
                    IID_PPV_ARG(IHtmlLoadOptions, &phlo));
                if (SUCCEEDED(hr))
                {
                    // deliberately ignore failures here
                    phlo->SetOption(HTMLLOADOPTION_INETSHORTCUTPATH, m_szPath, (lstrlenW(m_szPath) + 1)*sizeof(WCHAR));
                    pbc->RegisterObjectParam(L"__HTMLLOADOPTIONS", phlo);
                    phlo->Release();
                }
            }
            
            if (SUCCEEDED(hr))
            {            
                //tell MSHTML to start to load the page given
                hr = pPersistMon->Load(TRUE, pURLMoniker, pbc, NULL);
            }

            if (pPersistMon)
            {
                pPersistMon->Release();
            }

            if (pbc)
            {
                pbc->Release();
            }
        }
        else
        {
            IPersistFile *pPersistFile;
            hr = pUnk->QueryInterface(IID_PPV_ARG(IPersistFile, &pPersistFile));
            if (SUCCEEDED(hr))
            {
                hr = pPersistFile->Load(m_szPath, STGM_READ | STGM_SHARE_DENY_NONE);
                pPersistFile->Release();
            }
        }
    }

    if (pURLMoniker != NULL)
    {
        pURLMoniker->Release();
    }

    if (SUCCEEDED(hr))
    {
        SIZEL rgSize;
        rgSize.cx = m_dwXRenderSize;
        rgSize.cy = m_dwYRenderSize;
        
        HDC hDesktopDC = GetDC(NULL);
 
        // convert the size to himetric
        rgSize.cx = (rgSize.cx * 2540) / GetDeviceCaps(hDesktopDC, LOGPIXELSX);
        rgSize.cy = (rgSize.cy * 2540) / GetDeviceCaps(hDesktopDC, LOGPIXELSY);
            
        hr = m_pOleObject->SetExtent(DVASPECT_CONTENT, &rgSize);
        ReleaseDC(NULL, hDesktopDC);
    }

    if (SUCCEEDED(hr))
    {
        hr = pUnk->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &m_pHTML));
    }

    if (pUnk)
    {
        pUnk->Release();
    }
    
    if (SUCCEEDED(hr))
    {
        // get the timeout from the registry....
        m_dwTimeout = 0;
        DWORD cbSize = sizeof(m_dwTimeout);
        HKEY hKey;
            
        lRes = RegOpenKeyA(HKEY_CURRENT_USER, REGSTR_THUMBNAILVIEW, &hKey);

        if (lRes == ERROR_SUCCESS)
        {
            lRes = RegQueryValueExA(hKey, c_szRegValueTimeout, NULL, NULL, (LPBYTE)&m_dwTimeout, &cbSize);
            RegCloseKey(hKey);
        }

        if (m_dwTimeout == 0)
        {
            m_dwTimeout = TIME_DEFAULT;
        }

        // adjust to milliseconds
        m_dwTimeout *= 1000;
 
        // register the connection point for notification of the readystate
        hr = m_pOleObject->QueryInterface(IID_PPV_ARG(IConnectionPointContainer, &pConPtCtr));
    }

    if (SUCCEEDED(hr))
    {
        hr = pConPtCtr->FindConnectionPoint(IID_IPropertyNotifySink, &m_pConPt);
    }
    if (pConPtCtr)
    {
        pConPtCtr->Release();
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pConPt->Advise((IPropertyNotifySink *) this, &m_dwPropNotifyCookie);
    }

    if (SUCCEEDED(hr))
    {
        m_dwCurrentTick = 0;

        // delegate to the shared function
        hr = InternalResume();
    }

    ResetWaitCursor();

    return hr;
}

// this function is called from either Create or from 
HRESULT CHtmlThumb::InternalResume()
{
    HRESULT hr = WaitForRender();

    // if we getE_PENDING, we will drop out of Run()
    
    // all errors and succeeds excepting Suspend() need to Unadvise the 
    // connection point
    if (hr != E_PENDING)
    {
        // unregister the connection point ...
        m_pConPt->Unadvise(m_dwPropNotifyCookie);
        ATOMICRELEASE(m_pConPt);
    }
            
    if (m_lState == IRTIR_TASK_PENDING)
    {
        // we were told to quit, so do it...
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        hr = Finish(m_phBmp, &m_rgSize, m_dwClrDepth);
    }

    if (m_lState != IRTIR_TASK_SUSPENDED)
    {
        m_lState = IRTIR_TASK_FINISHED;
    }

    if (hr != E_PENDING)
    {
        // we are not being suspended, so we don't need any of this stuff anymore so ...
        // let it go here so that its on the same thread as where we created it...
        ATOMICRELEASE(m_pHTML);
        ATOMICRELEASE(m_pOleObject);
        ATOMICRELEASE(m_pViewObject);
        ATOMICRELEASE(m_pMoniker);
    }

    return hr;
}

HRESULT CHtmlThumb::WaitForRender()
{
    DWORD dwLastTick = GetTickCount();
    CheckReadyState();

    do
    {
        MSG msg;
        while (PeekMessageWrapW(&msg, NULL, 0, 0, PM_REMOVE))
        {
            if ((msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST) ||
                (msg.message >= WM_MOUSEFIRST && msg.message <= WM_MOUSELAST  && msg.message != WM_MOUSEMOVE))
            {
                continue;
            }
            TranslateMessage(&msg);
            DispatchMessageWrapW(&msg);
        }

        HANDLE rgWait[1] = {m_hDone};
        DWORD dwRet = MsgWaitForMultipleObjects(1, rgWait, FALSE,
                                                 m_dwTimeout - m_dwCurrentTick, QS_ALLINPUT);

        if (dwRet != WAIT_OBJECT_0)
        {
            // check the handle, TRIDENT pumps LOADS of messages, so we may never
            // detect the handle fired, even though it has...
            DWORD dwTest = WaitForSingleObject(m_hDone, 0);
            if (dwTest == WAIT_OBJECT_0)
            {
                break;
            }
        }
        
        if (dwRet == WAIT_OBJECT_0)
        {
            // Done signalled (either killed, or complete)
            break;
        }

        // was it a message that needed processing ?
        if (dwRet != WAIT_TIMEOUT)
        {
            DWORD dwNewTick = GetTickCount();
            if (dwNewTick < dwLastTick)
            {
                // it wrapped to zero, 
                m_dwCurrentTick += dwNewTick + (0xffffffff - dwLastTick);
            }
            else
            {
                m_dwCurrentTick += (dwNewTick - dwLastTick);
            }
            dwLastTick = dwNewTick;
        }

        if ((m_dwCurrentTick > m_dwTimeout) || (dwRet == WAIT_TIMEOUT))
        {
            ASSERT(m_pOleObject);
            
            m_pOleObject->Close(OLECLOSE_NOSAVE);
            
            return E_FAIL;
        }
    }
    while (TRUE);

    if (m_lState == IRTIR_TASK_SUSPENDED)
    {
        return E_PENDING;
    }

    if (m_lState == IRTIR_TASK_PENDING)
    {
        // it is being killed,
        // close the renderer down...
        m_pOleObject->Close(OLECLOSE_NOSAVE);
    }
    
    return S_OK;
}

HRESULT CHtmlThumb::Finish(HBITMAP * phBmp, const SIZE * prgSize, DWORD dwClrDepth)
{
    HRESULT hr = S_OK;
    RECTL rcLRect;
    HBITMAP hOldBmp = NULL;
    HBITMAP hHTMLBmp = NULL;
    BITMAPINFO * pBMI = NULL;
    LPVOID pBits;
    HPALETTE hpal = NULL;;
    
    // size is in pixels...
    SIZEL rgSize;
    rgSize.cx = m_dwXRenderSize;
    rgSize.cy = m_dwYRenderSize;
            
    //draw into temp DC
    HDC hDesktopDC = GetDC(NULL);
    HDC hdcHTML = CreateCompatibleDC(hDesktopDC);
    if (hdcHTML == NULL)
    {
        hr = E_OUTOFMEMORY;
    }

    if (dwClrDepth == 8)
    {
        // use the shell's palette as the default
        hpal = SHCreateShellPalette(hDesktopDC);
    }
    else if (dwClrDepth == 4)
    {
        // use the stock 16 colour palette...
        hpal = (HPALETTE) GetStockObject(DEFAULT_PALETTE);
    }
    
    if (SUCCEEDED(hr))
    {
        CreateSizedDIBSECTION(&rgSize, dwClrDepth, hpal, NULL, &hHTMLBmp, &pBMI, &pBits);
        if (hHTMLBmp == NULL)
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr))
    {
        hOldBmp = (HBITMAP) SelectObject(hdcHTML, hHTMLBmp);
            
        BitBlt(hdcHTML, 0, 0, rgSize.cx, rgSize.cy, NULL, 0, 0, WHITENESS);

        /****************** RENDER HTML PAGE to MEMORY DC *******************
        
          We will now call IViewObject::Draw in MSHTML to render the loaded
          URL into the passed in hdcMem.  The extent of the rectangle to
          render in is in RectForViewObj.  This is the call that gives
          us the image to scroll, animate, or whatever!
            
        ********************************************************************/
        rcLRect.left = 0;
        rcLRect.right = rgSize.cx;
        rcLRect.top = 0;
        rcLRect.bottom = rgSize.cy;

        hr = m_pViewObject->Draw(DVASPECT_CONTENT,
                            NULL, NULL, NULL, NULL,
                            hdcHTML, &rcLRect,
                            NULL, NULL, NULL);         

        SelectObject(hdcHTML, hOldBmp);
    }

    if (SUCCEEDED(hr))
    {
        SIZEL rgCur;
        rgCur.cx = rcLRect.bottom;
        rgCur.cy = rcLRect.right;

        ASSERT(pBMI);
        ASSERT(pBits);
        hr = ConvertDIBSECTIONToThumbnail(pBMI, pBits, phBmp, prgSize, dwClrDepth, hpal, 50, FALSE);
    }

    if (hHTMLBmp)
    {
        DeleteObject(hHTMLBmp);
    }
    
    if (hDesktopDC)
    {
        ReleaseDC(NULL, hDesktopDC);
    }

    if (hdcHTML)
    {
        DeleteDC(hdcHTML);
    }

    if (pBMI)
    {
        LocalFree(pBMI);
    }
    if (hpal)
    {
        DeleteObject(hpal);
    }
    
    return hr;
}
        
HRESULT CHtmlThumb::CheckReadyState()
{
    VARIANT     varState;
    DISPPARAMS  dp;

    if (!m_pHTML)
    {
        ASSERT(FALSE);
        return E_UNEXPECTED;
    }    
    
    VariantInit(&varState);

    if (SUCCEEDED(m_pHTML->Invoke(DISPID_READYSTATE, 
                          IID_NULL, 
                          GetUserDefaultLCID(), 
                          DISPATCH_PROPERTYGET, 
                          &dp, 
                          &varState, NULL, NULL)) &&
        V_VT(&varState)==VT_I4 && 
        V_I4(&varState)== READYSTATE_COMPLETE)
    {
        // signal the end ..
        SetEvent(m_hDone);
    }

    return S_OK;
}

HRESULT CHtmlThumb::Create_URL_Moniker(IMoniker ** ppMoniker)
{
    // we are dealing with a URL file
    WCHAR szURLData[8196];

    // URL files are actually ini files that
    // have a section [InternetShortcut]
    // and a Value URL=.....
    int iRet = SHGetIniStringW(L"InternetShortcut", L"URL",
            szURLData, ARRAYSIZE(szURLData), m_szPath);

    if (iRet == 0)
    {
        return E_FAIL;
    }

    return CreateURLMoniker(0, szURLData, ppMoniker);
}

STDMETHODIMP CHtmlThumb::GetClassID(CLSID *pClassID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::IsDirty()
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (!pszFileName)
    {
        return E_INVALIDARG;
    }
    
    StrCpyW(m_szPath, pszFileName);
    DWORD dwAttrs = GetFileAttributesWrapW(m_szPath);
    if ((dwAttrs != (DWORD) -1) && (dwAttrs & FILE_ATTRIBUTE_OFFLINE))
    {
        return E_FAIL;
    }
    
    return S_OK;
}

STDMETHODIMP CHtmlThumb::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::GetCurFile(LPOLESTR *ppszFileName)
{
    return E_NOTIMPL;
}

HRESULT RegisterHTMLExtractor()
{
    HKEY hKey;
    LONG lRes = RegCreateKeyA(HKEY_CURRENT_USER, REGSTR_THUMBNAILVIEW, &hKey);
    if (lRes != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    DWORD dwTimeout = TIME_DEFAULT;
    
    lRes = RegSetValueExA(hKey, c_szRegValueTimeout,
                          NULL, REG_DWORD, (const LPBYTE) &dwTimeout, sizeof(dwTimeout));

    RegCloseKey(hKey);
    if (lRes != ERROR_SUCCESS)
    {
        return E_FAIL;
    }

    return S_OK;
}

CTridentHost::CTridentHost()
{
    m_cRef = 1;
}

CTridentHost::~CTridentHost()
{
    // all refs should have been released...
    ASSERT(m_cRef == 1);
}

HRESULT CTridentHost::SetTrident(IOleObject * pTrident)
{
    ASSERT(pTrident);

    return pTrident->SetClientSite((IOleClientSite *) this);
}

STDMETHODIMP CTridentHost::QueryInterface(REFIID riid, void ** ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTridentHost, IOleClientSite),
        QITABENT(CTridentHost, IDispatch),
        QITABENT(CTridentHost, IDocHostUIHandler),
        // IThumbnailView is needed by Trident for some reason.  The cast to IOleClientSite is because that's what we used to do
        QITABENTMULTI(CTridentHost, IThumbnailView, IOleClientSite),
        { 0 }
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CTridentHost::AddRef(void)
{
    m_cRef ++;
    return m_cRef;
}

STDMETHODIMP_(ULONG) CTridentHost::Release(void)
{
    m_cRef --;

    // because we are created with our parent, we do not do a delete here..
    ASSERT(m_cRef > 0);

    return m_cRef;
}

STDMETHODIMP CTridentHost::GetTypeInfoCount(UINT *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetIDsOfNames(REFIID riid, OLECHAR **rgszNames, UINT cNames, LCID lcid, DISPID *rgdispid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
                                  DISPPARAMS *pdispparams, VARIANT *pvarResult,
                                  EXCEPINFO *pexcepinfo, UINT *puArgErr)
{
    if (!pvarResult)
        return E_INVALIDARG;

    ASSERT(pvarResult->vt == VT_EMPTY);

    if (wFlags == DISPATCH_PROPERTYGET)
    {
        switch (dispidMember)
        {
        case DISPID_AMBIENT_DLCONTROL :
            pvarResult->vt = VT_I4;
            pvarResult->lVal = DLCTL_DOWNLOAD_FLAGS;
            if (m_fOffline)
            {
                pvarResult->lVal |= DLCTL_OFFLINE;
            }
            return S_OK;
            
         case DISPID_AMBIENT_OFFLINEIFNOTCONNECTED:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = m_fOffline ? TRUE : FALSE;
            return S_OK;

        case DISPID_AMBIENT_SILENT:
            pvarResult->vt = VT_BOOL;
            pvarResult->boolVal = TRUE;
            return S_OK;
        }
    }

    return DISP_E_MEMBERNOTFOUND;
}


// IOleClientSite
STDMETHODIMP CTridentHost::SaveObject()
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker **ppmk)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetContainer(IOleContainer **ppContainer)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ShowObject()
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnShowWindow(BOOL fShow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::RequestNewObjectLayout()
{
    return E_NOTIMPL;
}

// IPersistMoniker stuff
STDMETHODIMP CHtmlThumb::Load(BOOL fFullyAvailable, IMoniker *pimkName, LPBC pibc, DWORD grfMode)
{
    if (!pimkName)
    {
        return E_INVALIDARG;
    }
    if (pibc || grfMode != STGM_READ)
    {
        return E_NOTIMPL;
    }

    if (m_pMoniker)
    {
        m_pMoniker->Release();
    }

    m_pMoniker = pimkName;
    ASSERT(m_pMoniker);
    m_pMoniker->AddRef();

    return S_OK;
}

STDMETHODIMP CHtmlThumb::Save(IMoniker *pimkName, LPBC pbc, BOOL fRemember)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::SaveCompleted(IMoniker *pimkName, LPBC pibc)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::GetCurMoniker(IMoniker **ppimkName)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ShowContextMenu(DWORD dwID, POINT *ppt, IUnknown *pcmdtReserved, IDispatch *pdispReserved)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetHostInfo(DOCHOSTUIINFO *pInfo)
{
    if (!pInfo)
    {
        return E_INVALIDARG;
    }

    DWORD   dwIE = URL_ENCODING_NONE;
    DWORD   dwOutLen = sizeof(DWORD);
    
    UrlMkGetSessionOption(URLMON_OPTION_URL_ENCODING, &dwIE, sizeof(DWORD), &dwOutLen, NULL);

    pInfo->dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT;
    pInfo->dwFlags |= DOCHOSTUIFLAG_SCROLL_NO;
    if (dwIE == URL_ENCODING_ENABLE_UTF8)
    {
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8;
    }
    else
    {
        pInfo->dwFlags |= DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8;
    }
    
    return S_OK;
}

STDMETHODIMP CTridentHost::ShowUI(DWORD dwID,
                                     IOleInPlaceActiveObject *pActiveObject,
                                     IOleCommandTarget *pCommandTarget,
                                     IOleInPlaceFrame *pFrame,
                                     IOleInPlaceUIWindow *pDoc)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::HideUI (void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::UpdateUI (void)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::EnableModeless (BOOL fEnable)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnDocWindowActivate (BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::OnFrameWindowActivate (BOOL fActivate)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::ResizeBorder (LPCRECT prcBorder, IOleInPlaceUIWindow *pUIWindow, BOOL fRameWindow)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::TranslateAccelerator (LPMSG lpMsg, const GUID *pguidCmdGroup, DWORD nCmdID)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetOptionKeyPath (LPOLESTR *pchKey, DWORD dw)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::GetDropTarget (IDropTarget *pDropTarget, IDropTarget **ppDropTarget)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::GetExternal (IDispatch **ppDispatch)
{
    return E_NOTIMPL;
}


STDMETHODIMP CTridentHost::TranslateUrl (DWORD dwTranslate, OLECHAR *pchURLIn, OLECHAR **ppchURLOut)
{
    return E_NOTIMPL;
}

STDMETHODIMP CTridentHost::FilterDataObject (IDataObject *pDO, IDataObject **ppDORet)
{
    return E_NOTIMPL;
}

STDMETHODIMP CHtmlThumb::CaptureThumbnail(const SIZE * pMaxSize, IUnknown * pHTMLDoc2, HBITMAP * phbmThumbnail)
{
    HRESULT hr = E_INVALIDARG;

    if (pMaxSize != NULL &&
        pHTMLDoc2 != NULL &&
        phbmThumbnail != NULL)
    {
        IHTMLDocument2 *pDoc = NULL;

        hr = pHTMLDoc2->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pDoc));
        if (SUCCEEDED(hr))
        {
            ASSERT(m_pViewObject == NULL);

            hr = pDoc->QueryInterface(IID_PPV_ARG(IViewObject, &m_pViewObject));
            if (SUCCEEDED(hr))
            {
                SIZE sizeThumbnail;

                sizeThumbnail.cy = pMaxSize->cy;
                sizeThumbnail.cx = pMaxSize->cx;

                hr = m_pViewObject->QueryInterface(IID_PPV_ARG(IOleObject, &m_pOleObject));
                if (SUCCEEDED(hr))
                {
                    SIZEL rgSize = {0,0};

                    // get the size at which trident is currently rendering
                    hr = m_pOleObject->GetExtent(DVASPECT_CONTENT, &rgSize);
                    if (SUCCEEDED(hr))
                    {
                        HDC hdcDesktop = GetDC(NULL);
                        // get the actual size at which trident renders
                        if (hdcDesktop)
                        {
                            // (overwrite) convert from himetric
                            rgSize.cx = rgSize.cx * GetDeviceCaps(hdcDesktop, LOGPIXELSX) / 2540;
                            rgSize.cy = rgSize.cy * GetDeviceCaps(hdcDesktop, LOGPIXELSY) / 2540;

                            ReleaseDC(NULL, hdcDesktop);

                            m_dwXRenderSize = rgSize.cx;
                            m_dwYRenderSize = rgSize.cy;

                            DWORD dwColorDepth = SHGetCurColorRes();

                            hr = Finish(phbmThumbnail, &sizeThumbnail, dwColorDepth);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }

                    ASSERT(m_pOleObject != NULL);
                    m_pOleObject->Release();
                }

                ASSERT(m_pViewObject != NULL);
                m_pViewObject->Release();
            }

            ASSERT(pDoc != NULL);
            pDoc->Release();
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\imgdata.cpp ===
#include "precomp.h"
#include <runtask.h>
#include "imagprop.h"
#include "shutil.h"
#pragma hdrstop

#define TF_SUSPENDRESUME    0      // turn on to debug CDecodeStream::Suspend/Resume
#define PF_NOSUSPEND        0      // disable suspend and resume (for debugging purposes)

class CDecodeStream;

////////////////////////////////////////////////////////////////////////////

class CEncoderInfo
{
public:
    CEncoderInfo();
    virtual ~CEncoderInfo();
protected:
    HRESULT _GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt);
    HRESULT _GetEncoderList();
    HRESULT _GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder);

    UINT _cEncoders;                    // number of encoders discovered
    ImageCodecInfo *_pici;              // array of image encoder classes
};

class CImageFactory : public IShellImageDataFactory, private CEncoderInfo,
                      public NonATLObject
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellImageDataFactory
    STDMETHODIMP CreateIShellImageData(IShellImageData **ppshimg);
    STDMETHODIMP CreateImageFromFile(LPCWSTR pszPath, IShellImageData **ppshimg);
    STDMETHODIMP CreateImageFromStream(IStream *pStream, IShellImageData **ppshimg);
    STDMETHODIMP GetDataFormatFromPath(LPCWSTR pszPath, GUID *pDataFormat);

    CImageFactory();

private:
    ~CImageFactory();

    LONG _cRef;
    CGraphicsInit _cgi;
};

class CImageData : public IShellImageData, IPersistFile, IPersistStream, IPropertySetStorage, private CEncoderInfo,
                   public NonATLObject
{
public:
    CImageData(BOOL fPropertyOnly = FALSE);
    static BOOL CALLBACK QueryAbort(void *pvRef);

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_ShellImageDataFactory; return S_OK; }

    // IPersistFile
    STDMETHODIMP IsDirty();
    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode);
    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember);
    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName);
    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName);

    // IPersistStream
    STDMETHOD(Load)(IStream *pstm);
    STDMETHOD(Save)(IStream *pstm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize)
        { return E_NOTIMPL; }

    // IPropertySetStorage methods
    STDMETHODIMP Create(REFFMTID fmtid, const CLSID * pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg);
    STDMETHODIMP Delete(REFFMTID fmtid);
    STDMETHODIMP Enum(IEnumSTATPROPSETSTG** ppenum);

    // IShellImageData
    STDMETHODIMP Decode(DWORD dwFlags, ULONG pcx, ULONG pcy);
    STDMETHODIMP Draw(HDC hdc, LPRECT prcDest, LPRECT prcSrc);

    STDMETHODIMP NextFrame();
    STDMETHODIMP NextPage();
    STDMETHODIMP PrevPage();

    STDMETHODIMP IsTransparent();
    STDMETHODIMP IsVector();

    STDMETHODIMP IsAnimated()
        { return _fAnimated ? S_OK : S_FALSE; }
    STDMETHODIMP IsMultipage()
        { return (!_fAnimated && _cImages > 1) ? S_OK : S_FALSE; }

    STDMETHODIMP IsDecoded();

    STDMETHODIMP IsPrintable()
        { return S_OK; }                            // all images are printable

    STDMETHODIMP IsEditable()
        { return _fEditable ? S_OK : S_FALSE; }

    STDMETHODIMP GetCurrentPage(ULONG *pnPage)
        { *pnPage = _iCurrent; return S_OK; }
    STDMETHODIMP GetPageCount(ULONG *pcPages)
        { HRESULT hr = _EnsureImage(); *pcPages = _cImages; return hr; }
    STDMETHODIMP SelectPage(ULONG iPage);
    STDMETHODIMP GetResolution(ULONG *puResolutionX, ULONG *puResolutionY);

    STDMETHODIMP GetRawDataFormat(GUID *pfmt);
    STDMETHODIMP GetPixelFormat(PixelFormat *pfmt);
    STDMETHODIMP GetSize(SIZE *pSize);
    STDMETHODIMP GetDelay(DWORD *pdwDelay);
    STDMETHODIMP DisplayName(LPWSTR wszName, UINT cch);
    STDMETHODIMP GetProperties(DWORD dwMode, IPropertySetStorage **ppPropSet);
    STDMETHODIMP Rotate(DWORD dwAngle);
    STDMETHODIMP Scale(ULONG cx, ULONG cy, InterpolationMode hints);
    STDMETHODIMP DiscardEdit();
    STDMETHODIMP SetEncoderParams(IPropertyBag *ppbEnc);
    STDMETHODIMP GetEncoderParams(GUID *pguidFmt, EncoderParameters **ppencParams);
    STDMETHODIMP RegisterAbort(IShellImageDataAbort *pAbort, IShellImageDataAbort **ppAbortPrev);
    STDMETHODIMP CloneFrame(Image **ppimg);
    STDMETHODIMP ReplaceFrame(Image *pimg);

private:
    CGraphicsInit _cgi;
    LONG _cRef;

    DWORD _dwMode;                      // open mode from IPersistFile::Load()
    CDecodeStream *_pstrm;              // stream that will produce our data

    BOOL _fLoaded;                      // true once PersistFile or PersistStream have been called
    BOOL _fDecoded;                     // true once Decode ahs been called

    DWORD _dwFlags;                     // flags and size passed to Decode method
    int _cxDesired;
    int _cyDesired;

    Image *_pImage;                     // source of the images (created from the filename)

    // REVIEW: do we need to make these be per-frame/page?
    // YES!
    Image *_pimgEdited;                 // edited image

    HDPA  _hdpaProps;                   // properties for each frame
    DWORD _dwRotation;
    BOOL _fDestructive;                 // not a lossless edit operation

    BOOL _fAnimated;                    // this is an animated stream (eg. not multi page picture)
    BOOL _fLoopForever;                 // loop the animated gif forever
    int  _cLoop;                        // loop count (0 forever, n = repeat count)

    BOOL _fEditable;                    // can be edited
    GUID _guidFmt;                      // format GUID (original stream is this)

    DWORD _cImages;                     // number of frames/pages in the image
    DWORD _iCurrent;                    // current frame/page we want to display
    PropertyItem *_piAnimDelay;         // array of the delay assocated with each frame
    BOOL _fPropertyOnly;
    BOOL _fPropertyChanged;
    // image encoder information (created on demand)
    IPropertyBag *_ppbEncoderParams;    // property bag with encoder parameters

    IShellImageDataAbort *_pAbort;      // optional abort callback
    CDSA<SHCOLUMNID> _dsaChangedProps; // which properties have changed
    
private:
    ~CImageData();
    HRESULT _EnsureImage();
    HRESULT _SuspendStream();
    HRESULT _SetDecodeStream(CDecodeStream *pds);

    HRESULT _CreateMemPropSetStorage(IPropertySetStorage **ppss);

    HRESULT _PropImgToVariant(PropertyItem *pi, VARIANT *pvar);
    HRESULT _GetProperty(PROPID id, VARIANT *pvar, VARTYPE vt);
    HRESULT _GetDisplayedImage();
    void _SetEditImage(Image *pimgEdit);
    HRESULT _SaveImages(IStream *pstrm, GUID * pguidFmt);
    HRESULT _ReplaceFile(LPCTSTR pszNewFile);
    HRESULT _MakeTempFile(LPWSTR pszFile);
    void _AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv);

    HRESULT _EnsureProperties(IPropertySetStorage **ppss);
    HRESULT _CreatePropStorage(IPropertyStorage **ppps, REFFMTID fmtid);
    static int _FreeProps(void *pProp, void *pData);
    //
    // since CImagePropSet objects come and go, we need to persist which properties need updating in the CImageData
    //
    void    _SaveFrameProperties(Image *pimg, LONG iFrame);
    static void _PropertyChanged(IShellImageData *pThis, SHCOLUMNID *pscid );
};

////////////////////////////////////////////////////////////////////////////
//
// CDecodeStream
//
//  Wraps a regular IStream, but is cancellable and can be
//  suspended/resumed to prevent the underlying file from being held
//  open unnecessarily.
//
////////////////////////////////////////////////////////////////////////////

class CDecodeStream : public IStream, public NonATLObject
{
public:
    CDecodeStream(CImageData *pid, IStream *pstrm);
    CDecodeStream(CImageData *pid, LPCTSTR pszFilename, DWORD dwMode);

    ~CDecodeStream()
    {
        ASSERT(!_pidOwner);
#ifdef DEBUG // Need #ifdef because we call a function
        if (IsFileStream())
        {
            TraceMsg(TF_SUSPENDRESUME, "ds.Release %s", PathFindFileName(_szFilename));
        }
#endif
        ATOMICRELEASE(_pstrmInner);
    }

    HRESULT Suspend();
    HRESULT Resume(BOOL fFullLoad = FALSE);
    void    Reload();
    //
    //  Before releasing, you must Detach to break the backreference.
    //  Otherwise, the next time somebody calls QueryCancel, we will fault.
    //
    void Detach()
    {
        _pidOwner = NULL;
    }

    BOOL IsFileStream() { return _szFilename[0]; }
    LPCTSTR GetFilename() { return _szFilename; }
    HRESULT DisplayName(LPWSTR wszName, UINT cch);

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // *** IStream ***
    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(void const *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

private:
    void CommonConstruct(CImageData *pid) { _cRef = 1; _pidOwner = pid; _fSuspendable = !(g_dwPrototype & PF_NOSUSPEND);}
    HRESULT FilterAccess();

private:
    IStream *   _pstrmInner;
    CImageData *_pidOwner;      // NOT REFCOUNTED
    LONG        _cRef;
    LARGE_INTEGER _liPos;       // Where we were in the file when we suspended
    TCHAR _szFilename[MAX_PATH];    // file we are a stream for
    BOOL _fSuspendable;
};

CDecodeStream::CDecodeStream(CImageData *pid, IStream *pstrm)
{
    CommonConstruct(pid);
    IUnknown_Set((IUnknown**)&_pstrmInner, pstrm);
}

CDecodeStream::CDecodeStream(CImageData *pid, LPCTSTR pszFilename, DWORD dwMode)
{
    CommonConstruct(pid);
    lstrcpyn(_szFilename, pszFilename, ARRAYSIZE(_szFilename));
    // ignore the mode
}

//reload is only used for file streams
void CDecodeStream::Reload()
{
    if (IsFileStream())
    {
        ATOMICRELEASE(_pstrmInner);
        if (_fSuspendable) 
        {
            ZeroMemory(&_liPos, sizeof(_liPos));
        }
    }
}

HRESULT CDecodeStream::Suspend()
{
    HRESULT hr;

    if (IsFileStream() && _pstrmInner && _fSuspendable)
    {
        // Remember the file position so we can restore it when we resume
        const LARGE_INTEGER liZero = { 0, 0 };
        hr = _pstrmInner->Seek(liZero, FILE_CURRENT, (ULARGE_INTEGER*)&_liPos);
        if (SUCCEEDED(hr))
        {
#ifdef DEBUG // Need #ifdef because we call a function
            TraceMsg(TF_SUSPENDRESUME, "ds.Suspend %s, pos=0x%08x",
                     PathFindFileName(_szFilename), _liPos.LowPart);
#endif
            ATOMICRELEASE(_pstrmInner);
            hr = S_OK;
        }
    }
    else 
    {
        hr = S_FALSE;           // Not suspendable or already suspended
    }
    return hr;
}

HRESULT CDecodeStream::Resume(BOOL fLoadFull)
{
    HRESULT hr;

    if (_pstrmInner)
    {
        return S_OK;
    }
    if (fLoadFull)
    {
        _fSuspendable = FALSE;
    }
    if (IsFileStream())
    {
        if (PathIsURL(_szFilename))
        {
            // TODO: use URLMon to load the image, make sure we check for being allowed to go on-line
            hr = E_NOTIMPL;
        }
        else
        {
            if (!fLoadFull)
            {
                hr = SHCreateStreamOnFileEx(_szFilename, STGM_READ | STGM_SHARE_DENY_NONE, 0, FALSE, NULL, &_pstrmInner);
                if (SUCCEEDED(hr))
                {
                    hr = _pstrmInner->Seek(_liPos, FILE_BEGIN, NULL);
                    if (SUCCEEDED(hr))
                    {
                        #ifdef DEBUG // Need #ifdef because we call a function
                        TraceMsg(TF_SUSPENDRESUME, "ds.Resumed %s, pos=0x%08x",
                                 PathFindFileName(_szFilename), _liPos.LowPart);
                        #endif
                    }
                    else
                    {
                        ATOMICRELEASE(_pstrmInner);
                    }
                }
            }
            else 
            {
                hr = S_OK;
                HANDLE hFile = CreateFile(_szFilename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
                if (INVALID_HANDLE_VALUE != hFile)
                {
                    LARGE_INTEGER liSize = {0};
                    // we can't handle huge files
                    if (GetFileSizeEx(hFile, &liSize) && !liSize.HighPart)
                    {
                        DWORD dwToRead = liSize.LowPart;
                        HGLOBAL hGlobal = GlobalAlloc(GHND, dwToRead);
                        if (hGlobal)
                        {
                            void *pv = GlobalLock(hGlobal);
                            DWORD dwRead;
                            if (pv)
                            {
                                if (ReadFile(hFile, pv, dwToRead, &dwRead, NULL))                           
                                {
                                    ASSERT(dwRead == dwToRead);
                                    GlobalUnlock(hGlobal);
                                    hr = CreateStreamOnHGlobal(hGlobal, TRUE, &_pstrmInner);                    
                                }
                                else
                                {
                                    GlobalUnlock(hGlobal);
                                }
                            }
                            if (!_pstrmInner)
                            {
                                GlobalFree(hGlobal);
                            }
                        }
                    }
                    CloseHandle(hFile);
                }
            }
            if (SUCCEEDED(hr) && !_pstrmInner)
            {
                DWORD dw = GetLastError();
                hr = HRESULT_FROM_WIN32(dw);
            }
        }
        if (FAILED(hr))
        {
#ifdef DEBUG // Need #ifdef because we call a function
            TraceMsg(TF_SUSPENDRESUME, "ds.Resume %s failed: %08x",
                     PathFindFileName(_szFilename), hr);
#endif
        }
    }
    else
    {
        hr = E_FAIL;            // Can't resume without a filename
    }

    return hr;
}

//
//  This function is called at the top of each IStream method to make
//  sure that the stream has not been cancelled and resumes it if
//  necessary.
//
HRESULT CDecodeStream::FilterAccess()
{
    if (_pidOwner && _pidOwner->QueryAbort(_pidOwner))
    {
        return E_ABORT;
    }

    return Resume();
}

HRESULT CDecodeStream::DisplayName(LPWSTR wszName, UINT cch)
{
    HRESULT hr = E_FAIL;

    if (IsFileStream())
    {
        // from the filename generate the leaf name which we can
        // return the name to caller.

        LPTSTR pszFilename = PathFindFileName(_szFilename);
        if (pszFilename)
        {
            SHTCharToUnicode(pszFilename, wszName, cch);
            hr = S_OK;
        }
    }
    else if (_pstrmInner)
    {
        // this is a stream, so lets get the display name from the that stream
        // and return that into the buffer that the caller has given us.

        STATSTG stat;
        hr = _pstrmInner->Stat(&stat, 0x0);
        if (SUCCEEDED(hr))
        {
            if (stat.pwcsName)
            {
                StrCpyN(wszName, stat.pwcsName, cch);
                CoTaskMemFree(stat.pwcsName);
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    else
    {
        hr = E_FAIL;
    }

    return hr;
}

//
//  Now the boring part...
//

// *** IUnknown ***
HRESULT CDecodeStream::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CDecodeStream, IStream),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDecodeStream::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDecodeStream::Release()
{
    if (InterlockedDecrement(&_cRef))
    {
        return _cRef;
    }

    delete this;
    return 0;
}

// *** IStream ***

#define WRAP_METHOD(fn, args, argl) \
HRESULT CDecodeStream::fn args      \
{                                   \
    HRESULT hr = FilterAccess();    \
    if (SUCCEEDED(hr))              \
    {                               \
        hr = _pstrmInner->fn argl;  \
    }                               \
    return hr;                      \
}

WRAP_METHOD(Read, (void *pv, ULONG cb, ULONG *pcbRead), (pv, cb, pcbRead))
WRAP_METHOD(Write, (void const *pv, ULONG cb, ULONG *pcbWritten), (pv, cb, pcbWritten))
WRAP_METHOD(Seek, (LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition),
                  (dlibMove, dwOrigin, plibNewPosition))
WRAP_METHOD(SetSize, (ULARGE_INTEGER libNewSize), (libNewSize))
WRAP_METHOD(CopyTo, (IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten),
                    (pstm, cb, pcbRead, pcbWritten))
WRAP_METHOD(Commit, (DWORD grfCommitFlags), (grfCommitFlags))
WRAP_METHOD(Revert, (), ())
WRAP_METHOD(LockRegion, (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType), (libOffset, cb, dwLockType))
WRAP_METHOD(UnlockRegion, (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType), (libOffset, cb, dwLockType))
WRAP_METHOD(Stat, (STATSTG *pstatstg, DWORD grfStatFlag), (pstatstg, grfStatFlag))
WRAP_METHOD(Clone, (IStream **ppstm), (ppstm))

#undef WRAP_METHOD


////////////////////////////////////////////////////////////////////////////

class CFmtEnum : public IEnumSTATPROPSETSTG, public NonATLObject
{
public:
    STDMETHODIMP Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumSTATPROPSETSTG **ppenum);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    CFmtEnum(IEnumSTATPROPSETSTG *pEnum);

private:
    ~CFmtEnum();
    IEnumSTATPROPSETSTG *_pEnum;
    ULONG _idx;
    LONG _cRef;
};

#define HR_FROM_STATUS(x) ((x) == Ok) ? S_OK : E_FAIL

// IUnknown

STDMETHODIMP CImageData::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImageData, IShellImageData),
        QITABENT(CImageData, IPersistFile),
        QITABENT(CImageData, IPersistStream),
        QITABENT(CImageData, IPropertySetStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageData::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImageData::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

CImageData::CImageData(BOOL fPropertyOnly) : _cRef(1), _cImages(1), _fPropertyOnly(fPropertyOnly), _fPropertyChanged(FALSE)
{
    // Catch unexpected STACK allocations which would break us.
    ASSERT(_dwMode           == 0);
    ASSERT(_pstrm            == NULL);
    ASSERT(_fLoaded          == FALSE);
    ASSERT(_fDecoded         == FALSE);
    ASSERT(_dwFlags          == 0);
    ASSERT(_cxDesired        == 0);
    ASSERT(_cyDesired        == 0);
    ASSERT(_pImage           == NULL);
    ASSERT(_pimgEdited       == NULL);
    ASSERT(_hdpaProps        == NULL);
    ASSERT(_dwRotation       == 0);
    ASSERT(_fDestructive     == FALSE);
    ASSERT(_fAnimated        == FALSE);
    ASSERT(_fLoopForever     == FALSE);
    ASSERT(_cLoop            == 0);
    ASSERT(_fEditable        == FALSE);
    ASSERT(_iCurrent         == 0);
    ASSERT(_piAnimDelay      == NULL);
    ASSERT(_ppbEncoderParams == NULL);
    ASSERT(_pAbort           == NULL);
}

CImageData::~CImageData()
{
    if (_fPropertyOnly && _fPropertyChanged)
    {
        Save((LPCTSTR)NULL, FALSE);
    }

    if (_pstrm)
    {
        _pstrm->Detach();
        _pstrm->Release();
    }

    if (_pImage)
    {
        delete _pImage;                      // discard the pImage object we have been using
        _pImage = NULL;
    }

    if (_pimgEdited)
    {
        delete _pimgEdited;
        _pimgEdited = NULL;
    }

    if (_piAnimDelay)
        LocalFree(_piAnimDelay);        // do we have an array of image frame delays to destroy

    if (_hdpaProps)
        DPA_DestroyCallback(_hdpaProps, _FreeProps, NULL);

    if (_fLoaded)
    {
        _dsaChangedProps.Destroy();
    }
    ATOMICRELEASE(_pAbort);
}

// IPersistStream

HRESULT CImageData::_SetDecodeStream(CDecodeStream *pds)
{
    ASSERT(_pstrm == NULL);
    _pstrm = pds;

    if (_pstrm)
    {        
        _fLoaded = TRUE;
        _dsaChangedProps.Create(10);
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

HRESULT CImageData::Load(IStream *pstrm)
{
    if (_fLoaded)
        return STG_E_INUSE;

    return _SetDecodeStream(new CDecodeStream(this, pstrm));
}

HRESULT CImageData::Save(IStream *pstrm, BOOL fClearDirty)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        hr = _SaveImages(pstrm, &_guidFmt);
    }
    return hr;
}


// IPersistFile methods

HRESULT CImageData::IsDirty()
{
    return (_dwRotation || _pimgEdited) ? S_OK : S_FALSE;
}

HRESULT CImageData::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    if (_fLoaded)
        return STG_E_INUSE;

    if (!*pszFileName)
        return E_INVALIDARG;

    return _SetDecodeStream(new CDecodeStream(this, pszFileName, dwMode));
}


#define ATTRIBUTES_TEMPFILE (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_TEMPORARY)
// IPersistFile::Save() see SDK docs

HRESULT CImageData::Save(LPCOLESTR pszFile, BOOL fRemember)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // If this fires, then somebody managed to get _EnsureImage to
        // succeed without ever actually loading anything... (?)
        ASSERT(_pstrm);
        
        if (pszFile == NULL && !_pstrm->IsFileStream())
        {
            // Trying to "save with same name you loaded from"
            // when we weren't loaded from a file to begin with
            hr = HRESULT_FROM_WIN32(ERROR_INVALID_NAME);
        }
        else
        {
            // we default to saving in the original format that we were given
            // if the name is NULL (we will also attempt to replace the original file).
            TCHAR szTempFile[MAX_PATH];
            GUID guidFmt = _guidFmt;    // default to original format
            
            BOOL fReplaceOriginal = _pstrm->IsFileStream() &&
                ((NULL == pszFile) || (S_OK == IsSameFile(pszFile, _pstrm->GetFilename())));
            
            if (fReplaceOriginal)
            {
                // we are being told to save to the current file, but we have the current file locked open.
                // To get around this we save to a temporary file, close our handles on the current file,
                // and then replace the current file with the new file
                hr = _MakeTempFile(szTempFile);
                pszFile = szTempFile;                
            }
            else if (!_ppbEncoderParams)
            {
                // the caller did not tell us which encoder to use?
                // determine the encoder based on the target file name
                
                hr = _GetDataFormatFromPath(pszFile, &guidFmt);
            }
            
            if (SUCCEEDED(hr))
            {
                // the attributes are important as they need to match those of the
                // temp file we created else this call fails
                IStream *pstrm;
                hr = SHCreateStreamOnFileEx(pszFile, STGM_WRITE | STGM_CREATE, 
                    fReplaceOriginal ? ATTRIBUTES_TEMPFILE : 0, TRUE, NULL, &pstrm);
                if (SUCCEEDED(hr))
                {
                    hr = _SaveImages(pstrm, &guidFmt);
                    pstrm->Release();
                    
                    if (SUCCEEDED(hr) && fReplaceOriginal)
                    {
                        hr = _ReplaceFile(szTempFile);
                        if (SUCCEEDED(hr))
                        {
                            delete _pImage;
                            _pImage = NULL;
                            _fDecoded = FALSE;
                            _pstrm->Reload();
                            DWORD iCurrentPage = _iCurrent;
                            hr = Decode(_dwFlags, _cxDesired, _cyDesired);
                            if (iCurrentPage < _cImages)
                                _iCurrent = iCurrentPage;
                        }
                    }
                }

                if (FAILED(hr) && fReplaceOriginal)
                {
                    // make sure temp file is gone
                    DeleteFile(szTempFile);
                }
            }
        }
    }
    return hr;
}


HRESULT CImageData::SaveCompleted(LPCOLESTR pszFileName)
{
    return E_NOTIMPL;
}

HRESULT CImageData::GetCurFile(LPOLESTR *ppszFileName)
{
    if (_pstrm && _pstrm->IsFileStream())
        return SHStrDup(_pstrm->GetFilename(), ppszFileName);

    return E_FAIL;
}


// handle decoding the image this includes updating our cache of the images

HRESULT CImageData::_EnsureImage()
{
    if (_fDecoded && _pImage)
        return S_OK;
    return E_FAIL;
}

HRESULT CImageData::_SuspendStream()
{
    HRESULT hr = S_OK;
    if (_pstrm)
    {
        hr = _pstrm->Suspend();
    }
    return hr;
}

HRESULT CImageData::_GetDisplayedImage()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;

        hr = HR_FROM_STATUS(_pImage->SelectActiveFrame(pclsidFrameDim, _iCurrent));
    }
    return hr;
}


// IShellImageData method

HRESULT CImageData::Decode(DWORD dwFlags, ULONG cx, ULONG cy)
{
    if (!_fLoaded)
        return E_FAIL;

    if (_fDecoded)
        return S_FALSE;

    HRESULT hr = S_OK;

    _dwFlags = dwFlags;
    _cxDesired = cx;
    _cyDesired = cy;

    //
    //  Resume the stream now so GDI+ won't go nuts trying to detect the
    //  image type of a file that it can't read...
    //
    hr = _pstrm->Resume(dwFlags & SHIMGDEC_LOADFULL);

    // if that succeeded then we can create an image using the stream and decode
    // the images from that.  once we are done we will release the objects.

    if (SUCCEEDED(hr))
    {
        _pImage = new Image(_pstrm, TRUE);
        if (_pImage)
        {
            if (Ok != _pImage->GetLastStatus())
            {
                delete _pImage;
                _pImage = NULL;
                hr = E_FAIL;
            }
            else
            {
                _fEditable = TRUE;
                if (_dwFlags & SHIMGDEC_THUMBNAIL)
                {
                    // for thumbnails, _cxDesired and _cyDesired define a bounding rectangle but we
                    // should maintain the original aspect ratio.
                    int cxT = _pImage->GetWidth();
                    int cyT = _pImage->GetHeight();

                    if (cxT > _cxDesired || cyT > _cyDesired)
                    {
                        if (Int32x32To64(_cxDesired, cyT) > Int32x32To64(cxT, _cyDesired))
                        {
                            // constrained by height
                            cxT = MulDiv(cxT, _cyDesired, cyT);
                            if (cxT < 1) cxT = 1;
                            cyT = _cyDesired;
                        }
                        else
                        {
                            // constrained by width
                            cyT = MulDiv(cyT, _cxDesired, cxT);
                            if (cyT < 1) cyT = 1;
                            cxT = _cxDesired;
                        }
                    }

                    Image * pThumbnail;
                    pThumbnail = _pImage->GetThumbnailImage(cxT, cyT, QueryAbort, this);

                    //
                    //  GDI+ sometimes forgets to tell us it gave up due to an abort.
                    //
                    if (pThumbnail && !QueryAbort(this))
                    {
                        delete _pImage;
                        _pImage = pThumbnail;
                    }
                    else
                    {
                        delete pThumbnail; // "delete" ignores NULL pointers
                        hr = E_FAIL;
                    }
                }
                else
                {


                    _pImage->GetRawFormat(&_guidFmt);                // read the raw format of the file
                    if (_guidFmt == ImageFormatTIFF)
                    {
                        VARIANT var;
                        if (SUCCEEDED(_GetProperty(PropertyTagExifIFD, &var, VT_UI4)))
                        {
                            // TIFF images with an EXIF IFD aren't editable by GDI+
                            _fEditable = FALSE;
                            VariantClear(&var);
                        }
                    }

                    // is this an animated/multi page image?
                    _cImages = _pImage->GetFrameCount(&FrameDimensionPage);
                    if (_cImages <= 1)
                    {
                        _cImages = _pImage->GetFrameCount(&FrameDimensionTime);
                        if (_cImages > 1)
                        {
                            _fAnimated = TRUE;

                            // store the frame delays in PropertyItem *_piAnimDelay;
                            UINT cb = _pImage->GetPropertyItemSize(PropertyTagFrameDelay);
                            if (cb)
                            {
                                _piAnimDelay = (PropertyItem*)LocalAlloc(LPTR, cb);
                                if (_piAnimDelay)
                                {
                                    if (Ok != _pImage->GetPropertyItem(PropertyTagFrameDelay, cb, _piAnimDelay))
                                    {
                                        LocalFree(_piAnimDelay);
                                        _piAnimDelay = NULL;
                                    }
                                }
                            }
                        }
                    }

                    _pImage->GetLastStatus(); // 145081: clear the error from the first call to _pImage->GetFrameCount so that
                                              // the later call to _GetProperty won't immediately fail.
                                              // we wouldn't have to do this always if the gdi interface didn't maintain its own
                                              // error code and fail automatically based on it without allowing us to check it
                                              // without resetting it.

                    // some decoders will return zero as the frame count when they don't support that dimension
                    if (0 == _cImages)
                        _cImages = 1;

                    // is it a looping image?   this will only be if its animated
                    if (_fAnimated)
                    {
                        VARIANT var;
                        if (SUCCEEDED(_GetProperty(PropertyTagLoopCount, &var, VT_UI4)))
                        {
                            _cLoop = var.ulVal;
                            _fLoopForever = (_cLoop == 0);
                            VariantClear(&var);
                        }
                    }

                    PixelFormat pf = _pImage->GetPixelFormat();

                    // can we edit this image?  NOTE: The caller needs to ensure that the file is writeable
                    // all of that jazz, we only check if we have an encoder for this format.  Just cause we
                    // can edit a file doesn't mean the file can be written to the original source location.
                    // We can't edit images with > 8 bits per channel either
                    if (_fEditable)
                    {
                        _fEditable = !_fAnimated  && SUCCEEDED(_GetEncoderFromFormat(&_guidFmt, NULL)) && !IsExtendedPixelFormat(pf);
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;             // failed to allocate the image decoder
        }
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    _fDecoded = TRUE;

    return hr;
}


HRESULT CImageData::Draw(HDC hdc, LPRECT prcDest, LPRECT prcSrc)
{
    if (!prcDest)
        return E_INVALIDARG;            // not much chance without a destination to paint into

    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        Image *pimg = _pimgEdited ? _pimgEdited : _pImage;

        RECT rcSrc;
        if (prcSrc)
        {
            rcSrc.left  = prcSrc->left;
            rcSrc.top   = prcSrc->top;
            rcSrc.right = RECTWIDTH(*prcSrc);
            rcSrc.bottom= RECTHEIGHT(*prcSrc);
        }
        else
        {
            rcSrc.left  = 0;
            rcSrc.top   = 0;
            rcSrc.right = pimg->GetWidth();
            rcSrc.bottom= pimg->GetHeight();
        }

        Unit unit;
        RectF rectf;
        if (Ok==pimg->GetBounds(&rectf, &unit) && UnitPixel==unit)
        {
            rcSrc.left += (int)rectf.X;
            rcSrc.top  += (int)rectf.Y;
        }

        // we have a source rectangle so lets apply that when we render this image.
        Rect rc(prcDest->left, prcDest->top, RECTWIDTH(*prcDest), RECTHEIGHT(*prcDest));

        DWORD dwLayout = SetLayout(hdc, LAYOUT_BITMAPORIENTATIONPRESERVED);
        Graphics g(hdc);
        g.SetPageUnit(UnitPixel); // WARNING: If you remove this line (as has happened twice since Beta 1) you will break printing.
        if (_guidFmt == ImageFormatTIFF)
        {
            g.SetInterpolationMode(InterpolationModeHighQualityBilinear);
        }
        
        hr = HR_FROM_STATUS(g.DrawImage(pimg,
                                        rc,
                                        rcSrc.left,  rcSrc.top,
                                        rcSrc.right, rcSrc.bottom,
                                        UnitPixel, NULL, QueryAbort, this));
        //
        //  GDI+ sometimes forgets to tell us it gave up due to an abort.
        //
        if (SUCCEEDED(hr) && QueryAbort(this))
            hr = E_ABORT;

        if (GDI_ERROR != dwLayout)
            SetLayout(hdc, dwLayout);
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


HRESULT CImageData::SelectPage(ULONG iPage)
{
    if (iPage >= _cImages)
        return OLE_E_ENUM_NOMORE;

    if (_iCurrent != iPage)
    {
        // Since we are moving to a different page throw away any edits
        DiscardEdit();
    }

    _iCurrent = iPage;
    return _GetDisplayedImage();
}

HRESULT CImageData::NextFrame()
{
    if (!_fAnimated)
        return S_FALSE;             // not animated, so no next frame

    // if this is the last image, then lets look at the loop
    // counter and try and decide if we should cycle this image
    // around or not.

    if ((_iCurrent == _cImages-1) && !_fLoopForever)
    {
        if (_cLoop)
            _cLoop --;

        // if cLoop is zero then we're done looping
        if (_cLoop == 0)
            return S_FALSE;
    }

    // advance to the next image in the sequence

    _iCurrent = (_iCurrent+1) % _cImages;
    return _GetDisplayedImage();
}


HRESULT CImageData::NextPage()
{
    if (_iCurrent >= _cImages-1)
        return OLE_E_ENUM_NOMORE;

    // Since we are moving to the next page throw away any edits
    DiscardEdit();

    _iCurrent++;
    return _GetDisplayedImage();
}


HRESULT CImageData::PrevPage()
{
    if (_iCurrent == 0)
        return OLE_E_ENUM_NOMORE;

    // Since we are moving to the next page throw away any edits
    DiscardEdit();
    
    _iCurrent--;
    return _GetDisplayedImage();
}


STDMETHODIMP CImageData::IsTransparent()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
        hr = (_pImage->GetFlags() & ImageFlagsHasAlpha) ? S_OK : S_FALSE;
    return hr;
}


HRESULT CImageData::IsVector()
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        hr = (_pImage->GetFlags() & ImageFlagsScalable) ? S_OK : S_FALSE;
    }
    return hr;
}


HRESULT CImageData::GetSize(SIZE *pSize)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        Image *pimg = _pimgEdited ? _pimgEdited : _pImage;
        pSize->cx = pimg->GetWidth();
        pSize->cy = pimg->GetHeight();
    }
    return hr;
}


HRESULT CImageData::GetRawDataFormat(GUID *pfmt)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        *pfmt = _guidFmt;
    }
    return hr;
}


HRESULT CImageData::GetPixelFormat(PixelFormat *pfmt)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        *pfmt = _pImage->GetPixelFormat();
    }
    return hr;
}


HRESULT CImageData::GetDelay(DWORD *pdwDelay)
{
    HRESULT hr = _EnsureImage();
    DWORD dwFrame = _iCurrent;
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        if (_piAnimDelay)
        {
            if (_piAnimDelay->length != (sizeof(DWORD) * _cImages))
            {
                dwFrame = 0; // if array is not the expected size, be safe and just grab the delay of the first image
            }

            CopyMemory(pdwDelay, (void *)((UINT_PTR)_piAnimDelay->value + dwFrame * sizeof(DWORD)), sizeof(DWORD));
            *pdwDelay = *pdwDelay * 10;

            if (*pdwDelay < 100)
            {
                *pdwDelay = 100; // hack: do the same thing as mshtml, see inetcore\mshtml\src\site\download\imggif.cxx!CImgTaskGif::ReadGIFMaster
            }

            hr = S_OK;
        }
    }
    return hr;
}


HRESULT CImageData::IsDecoded()
{
    return _pImage ? S_OK : S_FALSE;
}

HRESULT CImageData::DisplayName(LPWSTR wszName, UINT cch)
{
    HRESULT hr = E_FAIL;

    // always set the out parameter to something known
    *wszName = L'\0';


    if (_pstrm)
    {
        hr = _pstrm->DisplayName(wszName, cch);
    }

    // REVIEW: If the user has selected not to view file extentions for known types should we hide the extention?

    return hr;
}

// property handling code - decoding, conversion and other packing

HRESULT CImageData::_PropImgToVariant(PropertyItem *pi, VARIANT *pvar)
{
    HRESULT hr = S_OK;
    switch (pi->type)
    {
    case PropertyTagTypeByte:
        pvar->vt = VT_UI1;
        // check for multi-valued property and convert to safearray if found
        if (pi->length > sizeof(UCHAR))
        {
            SAFEARRAYBOUND bound;
            bound.cElements = pi->length/sizeof(UCHAR);
            bound.lLbound = 0;
            pvar->vt |= VT_ARRAY;
            hr = E_OUTOFMEMORY;
            pvar->parray = SafeArrayCreate(VT_UI1, 1, &bound);
            if (pvar->parray)
            {
                void *pv;
                hr = SafeArrayAccessData (pvar->parray, &pv);
                if (SUCCEEDED(hr))
                {
                    CopyMemory(pv, pi->value, pi->length);
                    SafeArrayUnaccessData(pvar->parray);
                }
            }
        }
        else
        {
            pvar->bVal = *((UCHAR*)pi->value);
        }

        break;

    case PropertyTagTypeShort:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pi->value);
        break;

    case PropertyTagTypeLong:
        pvar->vt = VT_UI4;
        pvar->ulVal = *((ULONG*)pi->value);
        break;

    case PropertyTagTypeASCII:
        {
            WCHAR szValue[MAX_PATH];
            SHAnsiToUnicode(((LPSTR)pi->value), szValue, ARRAYSIZE(szValue));
            hr = InitVariantFromStr(pvar, szValue);
        }
        break;

    case PropertyTagTypeRational:
        {
            LONG *pl = (LONG*)pi->value;
            LONG num = pl[0];
            LONG den = pl[1];

            pvar->vt = VT_R8;
            if (0 == den)
                pvar->dblVal = 0;           // don't divide by zero
            else
                pvar->dblVal = ((double)num)/((double)den);
        }
        break;

    case PropertyTagTypeUndefined:
    case PropertyTagTypeSLONG:
    case PropertyTagTypeSRational:
    default:
        hr = E_UNEXPECTED;
        break;
    }
    return hr;
}

HRESULT CImageData::_GetProperty(PROPID id, VARIANT *pvar, VARTYPE vt)
{
    UINT cb = _pImage->GetPropertyItemSize(id);
    HRESULT hr = HR_FROM_STATUS(_pImage->GetLastStatus());
    if (cb && SUCCEEDED(hr))
    {
        PropertyItem *pi = (PropertyItem*)LocalAlloc(LPTR, cb);
        if (pi)
        {
            hr = HR_FROM_STATUS(_pImage->GetPropertyItem(id, cb, pi));
            if (SUCCEEDED(hr))
            {
                hr = _PropImgToVariant(pi, pvar);
            }
            LocalFree(pi);
        }
    }

    if (SUCCEEDED(hr) && (vt != 0) && (pvar->vt != vt))
        hr = VariantChangeType(pvar, pvar, 0, vt);

    return hr;
}

HRESULT CImageData::GetProperties(DWORD dwMode, IPropertySetStorage **ppss)
{
    HRESULT hr = _EnsureProperties(NULL);
    if (SUCCEEDED(hr))
    {
        hr = QueryInterface(IID_PPV_ARG(IPropertySetStorage, ppss));
    }
    return hr;
}

HRESULT CImageData::_CreateMemPropSetStorage(IPropertySetStorage **ppss)
{
    *ppss = NULL;

    ILockBytes *plb;
    HRESULT hr = CreateILockBytesOnHGlobal(NULL, TRUE, &plb);
    if (SUCCEEDED(hr))
    {
        IStorage *pstg;
        hr = StgCreateDocfileOnILockBytes(plb,
            STGM_DIRECT|STGM_READWRITE|STGM_CREATE|STGM_SHARE_EXCLUSIVE, 0, &pstg);
        if (SUCCEEDED(hr))
        {
            hr = pstg->QueryInterface(IID_PPV_ARG(IPropertySetStorage, ppss));
            pstg->Release();
        }

        plb->Release();
    }
    return hr;
}

// _EnsureProperties returns an in-memory IPropertySetStorage for the current active frame
// For read-only files we may not be able to modify the property set, so handle access issues
// gracefully.
HRESULT CImageData::_EnsureProperties(IPropertySetStorage **ppss)
{
    if (ppss)
    {
        *ppss = NULL;
    }
    Decode(SHIMGDEC_DEFAULT, 0, 0);
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr) && !_hdpaProps)
    {
        _hdpaProps = DPA_Create(_cImages);
        if (!_hdpaProps)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        IPropertySetStorage *pss = (IPropertySetStorage*)DPA_GetPtr(_hdpaProps, _iCurrent);
        if (!pss)
        {
            hr = _CreateMemPropSetStorage(&pss);
            if (SUCCEEDED(hr))
            {
                // fill in the NTFS or memory-based FMTID_ImageProperties if it doesn't already exist
                IPropertyStorage *pps;
                // we use CImagePropset to fill in the propertystorage when it is first created
                if (SUCCEEDED(pss->Create(FMTID_ImageProperties, &CLSID_NULL, PROPSETFLAG_DEFAULT, STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pps)))
                {
                    CImagePropSet *ppsImg = new CImagePropSet(_pImage, NULL, pps, FMTID_ImageProperties);
                    if (ppsImg)
                    {
                        ppsImg->SyncImagePropsToStorage();
                        ppsImg->Release();
                    }
                    pps->Release();
                }
                if (_guidFmt == ImageFormatJPEG || _guidFmt == ImageFormatTIFF)
                {
                    // for now ignore failures here it's not a catastrophic problem if they aren't written
                    if (SUCCEEDED(pss->Create(FMTID_SummaryInformation, &CLSID_NULL, PROPSETFLAG_DEFAULT, STGM_FAILIFTHERE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE, &pps)))
                    {
                        CImagePropSet *ppsSummary = new CImagePropSet(_pImage, NULL, pps, FMTID_SummaryInformation);
                        if (ppsSummary)
                        {
                            ppsSummary->SyncImagePropsToStorage();
                            ppsSummary->Release();
                        }
                        pps->Release();
                    }
                }
                DPA_SetPtr(_hdpaProps, _iCurrent, pss);
            }
        }
        if (SUCCEEDED(hr) && ppss)
        {
            *ppss = pss;
        }
    }
    return hr;
}

// NOTE: ppps is an IN-OUT parameter
HRESULT CImageData::_CreatePropStorage(IPropertyStorage **ppps, REFFMTID fmtid)
{
    HRESULT hr = E_FAIL;

    if (_pImage)
    {
        CImagePropSet *ppsImg = new CImagePropSet(_pImage, this, *ppps, fmtid, _PropertyChanged);

        ATOMICRELEASE(*ppps);

        if (ppsImg)
        {
            hr = ppsImg->QueryInterface(IID_PPV_ARG(IPropertyStorage, ppps));
            ppsImg->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// IPropertySetStorage
//
// If the caller wants FMTID_ImageProperties use CImagePropSet
//
STDMETHODIMP CImageData::Create(REFFMTID fmtid, const CLSID *pclsid, DWORD grfFlags,
                                DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    IPropertySetStorage *pss;
    HRESULT hr = _EnsureProperties(&pss);
    if (SUCCEEDED(hr))
    {
        if ((S_OK != IsEditable()) && (grfMode & (STGM_READWRITE | STGM_WRITE)))
        {
            hr = STG_E_ACCESSDENIED;
        }
    }
    if (SUCCEEDED(hr))
    {
        IPropertyStorage *pps = NULL;
        hr = pss->Create(fmtid, pclsid, grfFlags, grfMode, &pps);
        if (SUCCEEDED(hr))
        {
            hr = _CreatePropStorage(&pps, fmtid);
        }
        *pppropstg = pps;
    }
    return hr;
}

STDMETHODIMP CImageData::Open(REFFMTID fmtid, DWORD grfMode, IPropertyStorage **pppropstg)
{
    *pppropstg = NULL;
    IPropertySetStorage *pss;
    HRESULT hr = _EnsureProperties(&pss);
    if (SUCCEEDED(hr))
    {
        if ((S_OK != IsEditable()) && (grfMode & (STGM_READWRITE | STGM_WRITE)))
        {
            hr = STG_E_ACCESSDENIED;
        }
    }    
    if (SUCCEEDED(hr))
    {
        IPropertyStorage *pps = NULL;
        // special case FMTID_ImageSummaryInformation...it is readonly and not backed up
        // by a real property stream.
        if (FMTID_ImageSummaryInformation != fmtid)
        {
            hr = pss->Open(fmtid, grfMode, &pps);
        }

        if (SUCCEEDED(hr))
        {
            hr = _CreatePropStorage(&pps, fmtid);
        }
        *pppropstg = pps;
    }
    return hr;
}

STDMETHODIMP CImageData::Delete(REFFMTID fmtid)
{
    IPropertySetStorage *pss;
    HRESULT hr = _EnsureProperties(&pss);
    if (SUCCEEDED(hr))
    {
        hr = pss->Delete(fmtid);
    }
    return hr;
}

STDMETHODIMP CImageData::Enum(IEnumSTATPROPSETSTG **ppenum)
{
    IPropertySetStorage *pss;
    HRESULT hr = E_INVALIDARG;
    if (ppenum)
    {
        hr = _EnsureProperties(&pss);
        *ppenum = NULL;
    }
    if (SUCCEEDED(hr))
    {
        IEnumSTATPROPSETSTG *pEnum;
        hr = pss->Enum(&pEnum);
        if (SUCCEEDED(hr))
        {
            CFmtEnum *pFmtEnum = new CFmtEnum(pEnum);
            if (pFmtEnum)
            {
                hr = pFmtEnum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
                pEnum->Release();
                pFmtEnum->Release();
            }
            else
            {
               *ppenum = pEnum;
            }
        }
    }
    return hr;
}


// editing support

void CImageData::_SetEditImage(Image *pimgEdit)
{
    if (_pimgEdited)
        delete _pimgEdited;

    _pimgEdited = pimgEdit;
}


// valid input is 0, 90, 180, or 270
HRESULT CImageData::Rotate(DWORD dwAngle)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // this has bad effects on animated images so don't do it
        if (_fAnimated)
            return E_NOTVALIDFORANIMATEDIMAGE;


        RotateFlipType rft;
        switch (dwAngle)
        {
        case 0:
            hr = S_FALSE;
            break;

        case 90:
            rft = Rotate90FlipNone;
            break;

        case 180:
            rft = Rotate180FlipNone;
            break;

        case 270:
            rft = Rotate270FlipNone;
            break;

        default:
            hr = E_INVALIDARG;
        }

        if (S_OK == hr)
        {
            // get the current image we have displayed, ready to edit it.
            Image * pimg = _pimgEdited ? _pimgEdited->Clone() : _pImage->Clone();
            if (pimg)
            {
                // In order to fix Windows bug #325413 GDIPlus needs to throw away any decoded frames 
                // in memory for the cloned image. Therefore, we can no longer rely on
                // RotateFlip to flip the decoded frame already in memory and must explicitly
                // select it into the cloned image before calling RotateFlip to fix Windows Bug #368498
                
                const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;
                hr = HR_FROM_STATUS(pimg->SelectActiveFrame(pclsidFrameDim, _iCurrent));
                
                if (SUCCEEDED(hr))
                {
                    hr = HR_FROM_STATUS(pimg->RotateFlip(rft));
                    if (SUCCEEDED(hr))
                    {
                        _dwRotation = (_dwRotation + dwAngle) % 360;
                        _SetEditImage(pimg);
                    }                    
                }
                if (FAILED(hr))
                {
                    delete pimg;   
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


HRESULT CImageData::Scale(ULONG cx, ULONG cy, InterpolationMode hints)
{
    HRESULT hr = _EnsureImage();
    if (SUCCEEDED(hr))
    {
        // this has bad effects on animated images
        if (_fAnimated)
            return E_NOTVALIDFORANIMATEDIMAGE;

        Image * pimg = _pimgEdited ? _pimgEdited : _pImage;

        // we have an image, lets determine the new size (preserving aspect ratio
        // and ensuring that we don't end up with a 0 sized image as a result.

        if (cy == 0)
            cy = MulDiv(pimg->GetHeight(), cx, pimg->GetWidth());
        else if (cx == 0)
            cx = MulDiv(pimg->GetWidth(), cy, pimg->GetHeight());

        cx = max(cx, 1);
        cy = max(cy, 1);

        // construct our new image and draw into it.

        Bitmap *pimgNew = new Bitmap(cx, cy);
        if (pimgNew)
        {
            Graphics g(pimgNew);
            g.SetInterpolationMode(hints);

            hr = HR_FROM_STATUS(g.DrawImage(pimg, Rect(0, 0, cx, cy),
                                            0, 0, pimg->GetWidth(), pimg->GetHeight(),
                                            UnitPixel, NULL, QueryAbort, this));
            //
            //  GDI+ sometimes forgets to tell us it gave up due to an abort.
            //
            if (SUCCEEDED(hr) && QueryAbort(this))
                hr = E_ABORT;

            if (SUCCEEDED(hr))
            {
                pimgNew->SetResolution(pimg->GetHorizontalResolution(), pimg->GetVerticalResolution());

                _SetEditImage(pimgNew);
                _fDestructive = TRUE;                // the edit was Destructive
            }
            else
            {
                delete pimgNew;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


HRESULT CImageData::DiscardEdit()
{
    // NB: The following code is not valid in all cases.  For example, if you rotated, then scaled, then rotated again
    // this code wouldn't work.  We currently don't allow that scenario, so we shouldn't hit this problem, but it
    // could be an issue for others using this object so we should figure out what to do about it.  This code works
    // if: 1.) your first edit is a scale, or 2.) you only do rotates.  Also note, this code will clear the "dirty" bit
    // so it would prevent the image from being saved, thus the failure of this code won't effect the data on disk.
    if (_pimgEdited)
    {
        delete _pimgEdited;
        _pimgEdited = NULL;
    }
    _dwRotation = 0;
    _fDestructive = FALSE;
    return S_OK;
}


// handle persisting images

HRESULT CImageData::SetEncoderParams(IPropertyBag *ppbEnc)
{
    IUnknown_Set((IUnknown**)&_ppbEncoderParams, ppbEnc);
    return S_OK;
}


// save images to the given stream that we have, using the format ID we have

void CImageData::_AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}


#define MAX_ENC_PARAMS 3
HRESULT CImageData::_SaveImages(IStream *pstrm, GUID * pguidFmt)
{
    HRESULT hr = S_OK;
    int iQuality = 0;           // == 0 is a special case

    // did the encoder specify a format for us to save in?
    ASSERTMSG(NULL != pguidFmt, "Invalid pguidFmt passed to internal function CImageData::_SaveImages");

    GUID guidFmt = *pguidFmt;
    if (_ppbEncoderParams)
    {
        VARIANT var = {0};

        // read the encoder format to be used
        if (SUCCEEDED(_ppbEncoderParams->Read(SHIMGKEY_RAWFORMAT, &var, NULL)))
        {
            VariantToGUID(&var, &guidFmt);
            VariantClear(&var);
        }

        // read the encoder quality to be used, this is set for the JPEG one only
        if (guidFmt == ImageFormatJPEG)
        {
            SHPropertyBag_ReadInt(_ppbEncoderParams, SHIMGKEY_QUALITY, &iQuality);
            iQuality = max(0, iQuality);
            iQuality = min(100, iQuality);
        }
    }

    // given the format GUID lets determine the encoder we intend to
    // use to save the image

    CLSID clsidEncoder;
    hr = _GetEncoderFromFormat(&guidFmt, &clsidEncoder);
    if (SUCCEEDED(hr))
    {
        // the way encoding works with GDI+ is a bit strange, you first need to call an image to
        // have it save into a particular stream/file.   if the image is multi-page then you
        // must set an encoder parameter which defines that this will be a multi-page save (and
        // that you will be calling the SaveAdd later).
        //
        // having performed the initial save, you must then attempt to add the subsequent pages
        // to the file by calling SaveAdd, you call that method on the first image you saved
        // specifying that you are adding another page (and possibly that this is the last image
        // in the series).
        BOOL bSaveCurrentOnly = FALSE;
        Image *pimgFirstSave = NULL;
        DWORD dwMaxPage = _cImages;
        DWORD dwMinPage = 0;
        // If viewing a multipage image and saving to a single page format, only save the current frame
        if (_cImages > 1 &&  !FmtSupportsMultiPage(this, &guidFmt))
        {
            bSaveCurrentOnly = TRUE;
            dwMaxPage = _iCurrent+1;
            dwMinPage = _iCurrent;
        }
        for (DWORD i = dwMinPage; SUCCEEDED(hr) && (i < dwMaxPage); i++)
        {
            EncoderParameters ep[MAX_ENC_PARAMS] = { 0 };
            ULONG ulCompression = 0; // in same scope as ep
            // we use _pImage as the source if unedited in order to preserve properties
            const CLSID * pclsidFrameDim = _fAnimated ? &FrameDimensionTime : &FrameDimensionPage;
            _pImage->SelectActiveFrame(pclsidFrameDim, i);

            Image *pimg;
            if (_pimgEdited && i==_iCurrent)
            {
                pimg = _pimgEdited;
            }
            else
            {
                pimg = _pImage;
            }
            _SaveFrameProperties(pimg, i);
            
            if (guidFmt == ImageFormatTIFF)          
            {
                VARIANT var = {0};
                if (SUCCEEDED(_GetProperty(PropertyTagCompression, &var, VT_UI2)))
                {                   
                    // be sure to preserve TIFF compression
                   // these values are taken from the TIFF spec
                    switch (var.uiVal)
                    {
                        case 1:
                            ulCompression = EncoderValueCompressionNone;
                            break;
                        case 2:
                            ulCompression = EncoderValueCompressionCCITT3;
                            break;
                        case 3:
                            ulCompression = EncoderValueCompressionCCITT4;
                            break;
                        case 5:
                            ulCompression = EncoderValueCompressionLZW;
                            break;
                        case 32773:
                            ulCompression = EncoderValueCompressionRle;
                            break;
                        default:
                            // use the GDI+ default
                            break;
                    }       
                    VariantClear(&var);                 
                    if (ulCompression)
                    {
                        _AddEncParameter(ep, EncoderCompression, EncoderParameterValueTypeLong, &ulCompression);
                    }
                }
            }

            if (i == dwMinPage)
            {
                // we are writing the first page of the image, if this is a multi-page
                // image then we need to set the encoder parameters accordingly (eg. set to
                // multi-page).
                
                ULONG ulValue = 0; // This needs to be in scope when Save is called

                // We can only to lossless rotation when:
                // * The original image is a JPEG file
                // * The destination image is a JPEG file
                // * We are only rotating and not scaling
                // * The width and height of the JPEG are multiples of 8
                // * Quality is unchanged by the caller

                if (!_fDestructive && 
                    IsEqualIID(_guidFmt, ImageFormatJPEG) && 
                    IsEqualIID(guidFmt, ImageFormatJPEG) && 
                    (iQuality == 0))
                {
                    // this code assumes JPEG files are single page since it's inside the i==0 case
                    ASSERT(_cImages == 1);

                    // for JPEG when doing only a rotate we use a special encoder parameter on the original
                    // image rather than using the edit image.  This allows lossless rotation.
                    pimg = _pImage;

                    switch (_dwRotation)
                    {
                    case 90:
                        ulValue = EncoderValueTransformRotate90;
                        break;
                    case 180:
                        ulValue = EncoderValueTransformRotate180;
                        break;
                    case 270:
                        ulValue = EncoderValueTransformRotate270;
                        break;
                    }

                    _AddEncParameter(ep, EncoderTransformation, EncoderParameterValueTypeLong, &ulValue);
                }
                else if (_cImages > 1 && !bSaveCurrentOnly)
                {
                    ulValue = EncoderValueMultiFrame;
                    _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &ulValue);
                    pimgFirstSave = pimg;           // keep this image as we will us it for appending pages
                }

                // JPEG quality is only ever set for a single image, therefore don't
                // bother passing it for the multi page case.

                if (iQuality > 0)
                    _AddEncParameter(ep, EncoderQuality, EncoderParameterValueTypeLong, &iQuality);
                
                hr = HR_FROM_STATUS(pimg->Save(pstrm, &clsidEncoder, (ep->Count > 0) ? ep:NULL));
            }
            else
            {
                // writing the next image in the series, set the encoding parameter
                // to indicate that this is the next page.  if we are writing the last
                // image then set the last frame flag.

                ULONG flagValueDim = EncoderValueFrameDimensionPage;
                ULONG flagValueLastFrame = EncoderValueLastFrame;

                _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueDim);
                
                if (i == (dwMaxPage-1))
                    _AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueLastFrame);

                hr = HR_FROM_STATUS(pimgFirstSave->SaveAdd(pimg, (ep->Count > 0) ? ep:NULL));
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        _fPropertyChanged = FALSE;
        DiscardEdit();
    }

    // Suspend the stream so we don't leave the file open
    _SuspendStream();

    return hr;
}


// returns the DPI of the image
STDMETHODIMP CImageData::GetResolution(ULONG *puResolutionX, ULONG *puResolutionY)
{
    if (!puResolutionX && !puResolutionY)
    {
        return E_INVALIDARG;
    }

    HRESULT hr = _EnsureImage();
    if (puResolutionX)
    {
        *puResolutionX = 0;
    }
    if (puResolutionY)
    {
        *puResolutionY = 0;
    }
    if (SUCCEEDED(hr))
    {
        UINT uFlags = _pImage->GetFlags();
        //
        // We only return the DPI information from the image header for TIFFs whose
        // X and Y DPI differ, those images are likely faxes. 
        // We want our client applications (slideshow, image preview)
        // to deal with actual pixel sizes for the most part
        //  
        ULONG resX = (ULONG)_pImage->GetHorizontalResolution();
        ULONG resY = (ULONG)_pImage->GetVerticalResolution();
#ifndef USE_EMBEDDED_DPI_ALWAYS
        if (_guidFmt != ImageFormatTIFF || !(uFlags & ImageFlagsHasRealDPI) || resX == resY )
        {
            // if GetDC fails we have to rely on the numbers back from GDI+
            HDC hdc = GetDC(NULL);
            if (hdc)
            {
                resX = GetDeviceCaps(hdc, LOGPIXELSX);
                resY = GetDeviceCaps(hdc, LOGPIXELSY);
                ReleaseDC(NULL, hdc);
            }
        }
#endif
        if (puResolutionX)
        {
            
            *puResolutionX = resX;
        }
        if (puResolutionY)
        {
            *puResolutionY = resY;
        }

        if ((puResolutionX && !*puResolutionX) || (puResolutionY && !*puResolutionY))
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

// handle saving and replacing the original file
// in the case of replacing an existing file, we want the temp file to be in the same volume
// as the target

HRESULT CImageData::_MakeTempFile(LPWSTR pszFile)
{
    ASSERT(_pstrm);

    WCHAR szTempPath[MAX_PATH];
    HRESULT hr = S_OK;
    if (_pstrm->IsFileStream())
    {
        StrCpyN(szTempPath, _pstrm->GetFilename(), ARRAYSIZE(szTempPath));
        PathRemoveFileSpec(szTempPath);
    }
    else if (!GetTempPath(ARRAYSIZE(szTempPath), szTempPath))
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr))
    {
        // SIV == "Shell Image Viewer"
        if (GetTempFileName(szTempPath, TEXT("SIV"), 0, pszFile))
        {
            SetFileAttributes(pszFile, ATTRIBUTES_TEMPFILE);
            // we need to suppress the change notfy from the GetTempFileName()
            // call as that causes defview to display this.
            // but for some reason it does not work
            SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFile, NULL);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CImageData::_ReplaceFile(LPCTSTR pszNewFile)
{
    // first we get some info about the file we're replacing:
    LPCTSTR pszOldFile = _pstrm->GetFilename();
    STATSTG ss = {0};
    _pstrm->Stat(&ss, STATFLAG_NONAME);
   
    // This ensures that the source handle is closed
    _SuspendStream();

    HRESULT hr;
    // ReplaceFile doesn't save the modified time, so if we rotate an image twice in quick succession
    // we won't add a full 2 seconds to the modified time. So query the time before replacing the file.
    WIN32_FIND_DATA wfd = {0};
    GetFileAttributesEx(pszOldFile, GetFileExInfoStandard, &wfd);
    if (ReplaceFile(pszOldFile, pszNewFile, NULL, REPLACEFILE_WRITE_THROUGH, NULL, NULL))
    {
        // The old file has been replaced with the new file, but now we need to ensure that the
        // filetime actually changed due to the 2 sec accuracy of FAT.
        // we do this on NTFS too, since XP pidls have 2 sec accuracy since they cast the filetime
        // down to a dos datetime.

        
        HANDLE hFile = CreateFile(pszOldFile, GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
                NULL, OPEN_EXISTING, 0, NULL);
        if (INVALID_HANDLE_VALUE != hFile)
        {
            FILETIME *pft = (CompareFileTime(&wfd.ftLastWriteTime, &ss.mtime) < 0) ? &ss.mtime : &wfd.ftLastWriteTime;
            IncrementFILETIME(pft, 2 * FT_ONESECOND);
            SetFileTime(hFile, NULL, NULL, pft);
            CloseHandle(hFile);
        }
        
        // the replacefile call wont always keep the "replaced" file (pszOldFile) attributes, if it's
        // replacing across a win98 share for example.  no biggie, just set the attributes again, using
        // the attribs we know we got from the stat.
        SetFileAttributes(pszOldFile, ss.reserved);


        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH | SHCNF_FLUSHNOWAIT | SHCNF_FLUSH, pszOldFile, NULL);
        hr = S_OK;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

void SaveProperties(IPropertySetStorage *pss, Image *pimg, REFFMTID fmtid, CDSA<SHCOLUMNID> *pdsaChanges)
{
    IPropertyStorage *pps;
    if (SUCCEEDED(pss->Open(fmtid, STGM_READWRITE | STGM_SHARE_EXCLUSIVE, &pps)))
    {
        CImagePropSet *pips = new CImagePropSet(pimg, NULL, pps, fmtid);
        if (pips)
        {
            pips->SaveProps(pimg, pdsaChanges);
            pips->Release();
        }
        pps->Release();
    }
}

void CImageData::_SaveFrameProperties(Image *pimg, LONG iFrame)
{
    // make sure _dsaChangedProps is non-NULL
    if (_hdpaProps && (HDSA)_dsaChangedProps)
    {
        IPropertySetStorage *pss = (IPropertySetStorage *)DPA_GetPtr(_hdpaProps, iFrame);
        if (pss)
        {
            // Start with FMTID_ImageProperties to make sure other FMTIDs take precedence (last one wins)
            
            SaveProperties(pss, pimg, FMTID_ImageProperties, &_dsaChangedProps);
 
            // enum all the property storages and create a CImagePropSet for each one
            // and have it save to the pimg
            IEnumSTATPROPSETSTG *penum;
            if (SUCCEEDED(pss->Enum(&penum)))
            {
                STATPROPSETSTG spss;

                while (S_OK == penum->Next(1, &spss, NULL))
                {
                    if (!IsEqualGUID(spss.fmtid, FMTID_ImageProperties))
                    {
                        SaveProperties(pss, pimg, spss.fmtid, &_dsaChangedProps);
                    }
                }
                penum->Release();
            }
        }
    }
}

void CImageData::_PropertyChanged(IShellImageData* pThis, SHCOLUMNID *pscid)
{
    ((CImageData*)pThis)->_fPropertyChanged = TRUE;
    if ((HDSA)(((CImageData*)pThis)->_dsaChangedProps))
    {
        ((CImageData*)pThis)->_dsaChangedProps.AppendItem(pscid);
    }
}

//
// This function determines the list of available encoder parameters given the file format
// Hopefully future versions of GDI+ will decouple this call from the Image() object
// Don't call this function until ready to save the loaded image
STDMETHODIMP CImageData::GetEncoderParams(GUID *pguidFmt, EncoderParameters **ppencParams)
{
    CLSID clsidEncoder;
    HRESULT hr = E_FAIL;
    if (_pImage && ppencParams)
    {
        hr = _GetEncoderFromFormat(pguidFmt, &clsidEncoder);
    }
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        UINT uSize = _pImage->GetEncoderParameterListSize(&clsidEncoder);
        if (uSize)
        {
            *ppencParams = (EncoderParameters *)CoTaskMemAlloc(uSize);
            if (*ppencParams)
            {
                hr = HR_FROM_STATUS(_pImage->GetEncoderParameterList(&clsidEncoder, uSize, *ppencParams));
                if (FAILED(hr))
                {
                    CoTaskMemFree(*ppencParams);
                    *ppencParams = NULL;
                }
            }
        }
    }
    return hr;
}

STDMETHODIMP CImageData::RegisterAbort(IShellImageDataAbort *pAbort, IShellImageDataAbort **ppAbortPrev)
{
    if (ppAbortPrev)
    {
        *ppAbortPrev = _pAbort; // Transfer ownership to caller
    }
    else if (_pAbort)
    {
        _pAbort->Release(); // Caller doesn't want it, so throw away
    }

    _pAbort = pAbort;           // Set the new abort callback

    if (_pAbort)
    {
        _pAbort->AddRef();
    }

    return S_OK;
}

BOOL CALLBACK CImageData::QueryAbort(void *pvRef)
{
    CImageData* pThis = reinterpret_cast<CImageData *>(pvRef);
    return pThis->_pAbort && pThis->_pAbort->QueryAbort() == S_FALSE;
}


HRESULT CImageData::CloneFrame(Image **ppimg)
{
    *ppimg = NULL;
    Image *pimg = _pimgEdited ? _pimgEdited : _pImage;
    if (pimg)
    {
        *ppimg = pimg->Clone();
    }
    return *ppimg ? S_OK : E_FAIL;
}

HRESULT CImageData::ReplaceFrame(Image *pimg)
{
    _SetEditImage(pimg);
    return S_OK;
}
/////////////////////////////////////////////////////////////////////////////////////////////////
// CImageDataFactory
/////////////////////////////////////////////////////////////////////////////////////////////////

STDAPI CImageDataFactory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CImageFactory *psid = new CImageFactory();
    if (!psid)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psid->Release();
    return hr;
}

CImageFactory::CImageFactory() : _cRef(1)
{
    _Module.Lock();
}

CImageFactory::~CImageFactory()
{
    _Module.Unlock();
}

STDMETHODIMP CImageFactory::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImageFactory, IShellImageDataFactory),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImageFactory::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImageFactory::Release()
{

    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CImageFactory::CreateIShellImageData(IShellImageData **ppshimg)
{
    CImageData *psid = new CImageData();
    if (!psid)
        return E_OUTOFMEMORY;

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));
    psid->Release();
    return hr;
}

HRESULT CImageFactory::CreateImageFromFile(LPCWSTR pszPath, IShellImageData **ppshimg)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageData *psid = new CImageData();
    if (psid)
    {
        IPersistFile *ppf;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            hr = ppf->Load(pszPath, STGM_READ);
            ppf->Release();
        }

        if (SUCCEEDED(hr))
            hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));

        psid->Release();
    }
    return hr;
}

HRESULT CImageFactory::CreateImageFromStream(IStream *pstrm, IShellImageData **ppshimg)
{
    HRESULT hr = E_OUTOFMEMORY;
    CImageData *psid = new CImageData();
    if (psid)
    {
        IPersistStream *ppstrm;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistStream, &ppstrm));
        if (SUCCEEDED(hr))
        {
            hr = ppstrm->Load(pstrm);
            ppstrm->Release();
        }

        if (SUCCEEDED(hr))
            hr = psid->QueryInterface(IID_PPV_ARG(IShellImageData, ppshimg));

        psid->Release();
    }
    return hr;
}

HRESULT CImageFactory::GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    return _GetDataFormatFromPath(pszPath, pguidFmt);
}

HRESULT CEncoderInfo::_GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    *pguidFmt = GUID_NULL;

    HRESULT hr = _GetEncoderList();
    if (SUCCEEDED(hr))
    {
        UINT i = FindInDecoderList(_pici, _cEncoders, pszPath);
        if (-1 != i)
        {
            *pguidFmt = _pici[i].FormatID;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    return hr;
}

HRESULT CEncoderInfo::_GetEncoderList()
{
    HRESULT hr = S_OK;
    if (!_pici)
    {
        // lets pick up the list of encoders, first we get the encoder size which
        // gives us the CB and the number of encoders that are installed on the
        // machine.

        UINT cb;
        hr = HR_FROM_STATUS(GetImageEncodersSize(&_cEncoders, &cb));
        if (SUCCEEDED(hr))
        {
            // allocate the buffer for the encoders and then fill it
            // with the encoder list.

            _pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
            if (_pici)
            {
                hr = HR_FROM_STATUS(GetImageEncoders(_cEncoders, cb, _pici));
                if (FAILED(hr))
                {
                    LocalFree(_pici);
                    _pici = NULL;
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}


HRESULT CEncoderInfo::_GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    HRESULT hr = _GetEncoderList();
    if (SUCCEEDED(hr))
    {
        hr = E_FAIL;
        for (UINT i = 0; i != _cEncoders; i++)
        {
            if (_pici[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = _pici[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

CEncoderInfo::CEncoderInfo()
{
    _pici = NULL;
    _cEncoders = 0;
}

CEncoderInfo::~CEncoderInfo()
{
    if (_pici)
        LocalFree(_pici);               // do we have an encoder array to be destroyed
}

STDAPI CImageData_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
     CImageData *psid = new CImageData(*(poi->pclsid) == CLSID_ImagePropertyHandler);
     if (!psid)
     {
         *ppunk = NULL;          // incase of failure
         return E_OUTOFMEMORY;
     }
     HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
     psid->Release();
     return hr;
}

int CImageData::_FreeProps(void* pProp, void* pData)
{
    if (pProp)
    {
        ((IPropertySetStorage*)pProp)->Release();
    }
    return 1;
}

// Our CFmtEnum is a minimal enumerator to provide FMTID_SummaryInformation in our
// formats. It's optimized for 1-by-1 enumeration
STDMETHODIMP CFmtEnum::Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    if (!celt || !rgelt)
    {
        hr = E_INVALIDARG;
    }
    else if (0 == _idx)
    {
        ZeroMemory(rgelt, sizeof(*rgelt));
        rgelt->fmtid = FMTID_ImageSummaryInformation;
        rgelt->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
        if (pceltFetched)
        {
            *pceltFetched = 1;
        }
        _idx++;
        celt--;
        rgelt++;
    }
    if (SUCCEEDED(hr) && celt)
    {
        ULONG ul;
        hr = _pEnum->Next(celt, rgelt, &ul);
        if (SUCCEEDED(hr) && pceltFetched)
        {
            (*pceltFetched) += ul;
        }
    }
    return hr;
}

STDMETHODIMP CFmtEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    if (_idx == 0)
    {
        _idx++;
        celt--;
    }

    if (celt)
    {
        hr = _pEnum->Skip(celt);
    }
    return hr;
}

STDMETHODIMP CFmtEnum::Reset(void)
{
    _idx = 0;
    return _pEnum->Reset();
}

STDMETHODIMP CFmtEnum::Clone(IEnumSTATPROPSETSTG **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CFmtEnum *pNew = new CFmtEnum(_pEnum);
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSETSTG, ppenum));
        pNew->Release();
    }
    return hr;
}

STDMETHODIMP CFmtEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CFmtEnum, IEnumSTATPROPSETSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CFmtEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CFmtEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

CFmtEnum::CFmtEnum(IEnumSTATPROPSETSTG *pEnum) : _cRef(1), _idx(0), _pEnum(pEnum)
{
    _pEnum->AddRef();
}

CFmtEnum::~CFmtEnum()
{
    _pEnum->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\imgprop.cpp ===
#include "precomp.h"
#include "imagprop.h"
#include "imgprop.h"
#include <Stdio.h>
#pragma hdrstop

static const STATPROPSTG g_cImageSummaryProps[] = 
{
    {NULL, PIDISI_CX, VT_UI4},
    {NULL, PIDISI_CY, VT_UI4},
    {NULL, PIDISI_RESOLUTIONX, VT_UI4},
    {NULL, PIDISI_RESOLUTIONY, VT_UI4},
    {NULL, PIDISI_BITDEPTH, VT_UI4},
    {NULL, PIDISI_FRAMECOUNT, VT_UI4},
    {NULL, PIDISI_DIMENSIONS, VT_LPWSTR},
};

HRESULT GetImageFrameCount(Image *pImage, PROPVARIANT *ppv);

// simple IEnumSTATPROPSTG for FMTID_ImageSummaryInformation

class CPropEnum : public IEnumSTATPROPSTG, public NonATLObject
{
public:
    CPropEnum(const STATPROPSTG *pStats, ULONG nStat);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumSTATPROPSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void);
    STDMETHODIMP Clone(IEnumSTATPROPSTG **ppenum);
private:
    ~CPropEnum();

    LONG _cRef;
    ULONG _idx;
    const STATPROPSTG *_pStat;
    ULONG _nStat;
    FMTID _fmtid;
};

CImagePropSet::CImagePropSet(Image *pimg, IShellImageData *pData, 
                             IPropertyStorage *pps, REFFMTID fmtid, FNPROPCHANGE fnCallback) 
    : _pimg(pimg), 
      _pData(pData), 
      _ppsImg(pps), 
      _cRef(1), 
      _fDirty(FALSE),
      _fmtid(fmtid),
      _fnPropChanged(fnCallback),
      _fEditable(TRUE)
{
    if (_pData)
    {
        _pData->AddRef();
        _fEditable = (S_OK == _pData->IsEditable());
    }
    if (_ppsImg)
    {
        _ppsImg->AddRef();
    }
    _Module.Lock();
}

CImagePropSet::~CImagePropSet()
{
    ATOMICRELEASE(_ppsImg);
    ATOMICRELEASE(_pData);
    _Module.Unlock();
}

// IUnknown

STDMETHODIMP CImagePropSet::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CImagePropSet, IPropertyStorage),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImagePropSet::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImagePropSet::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}

// IPropertyStorage methods
STDMETHODIMP CImagePropSet::ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[])
{
    HRESULT hr = E_UNEXPECTED;
    if (FMTID_ImageSummaryInformation == _fmtid)
    {
        hr = _GetImageSummaryProps(cpspec, rgpspec, rgvar);
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->ReadMultiple(cpspec, rgpspec, rgvar);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst)
{
    HRESULT hr = E_UNEXPECTED;

    if (!_fEditable)
    {
        hr = STG_E_ACCESSDENIED;
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->WriteMultiple(cpspec, rgpspec, rgvar, propidNameFirst);
        if (SUCCEEDED(hr))
        {
            _fDirty = TRUE;
            if (_pData && _fnPropChanged)
            {
                SHCOLUMNID scid;
                scid.fmtid = _fmtid;
                for (ULONG i=0;i<cpspec;i++)
                {
                    scid.pid = rgpspec[i].propid;
                    (*_fnPropChanged)(_pData, &scid);
                }                
            }
        }
    }
    return hr;
}

STDMETHODIMP CImagePropSet::DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[])
{
    return E_NOTIMPL;
}

STDMETHODIMP CImagePropSet::ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->ReadPropertyNames(cpropid, rgpropid, rglpwstrName);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->WritePropertyNames(cpropid, rgpropid, rglpwstrName);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[])
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->DeletePropertyNames(cpropid, rgpropid);
    }
    return hr;
}

STDMETHODIMP CImagePropSet::SetClass(REFCLSID clsid)
{
    HRESULT hr = E_UNEXPECTED;
    if (_ppsImg)
    {
        hr = _ppsImg->SetClass(clsid);
    }
    return hr;
}
    
STDMETHODIMP CImagePropSet::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = S_FALSE;

    if (_fDirty && _pData)
    {
        IPersistFile *pFile;
        if (SUCCEEDED(_pData->QueryInterface(IID_PPV_ARG(IPersistFile, &pFile))))
        {
            hr = pFile->Save(NULL, FALSE);
            pFile->Release();
        }
        else
        {
            hr = E_UNEXPECTED;
        }
    }

    return hr;
}

STDMETHODIMP CImagePropSet::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CImagePropSet::Enum(IEnumSTATPROPSTG** ppenm)
{
    HRESULT hr = E_UNEXPECTED;
    
    if (FMTID_ImageSummaryInformation == _fmtid)
    {
        CPropEnum *pEnum = new CPropEnum(g_cImageSummaryProps,
                                         ARRAYSIZE(g_cImageSummaryProps));
        if (pEnum)
        {
            hr = pEnum->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenm));
            pEnum->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (_ppsImg)
    {
        hr = _ppsImg->Enum(ppenm);
    }
    return hr;
}
    
STDMETHODIMP CImagePropSet::Stat(STATPROPSETSTG* pstatpsstg)
{
    HRESULT hr = S_OK;
    if (_ppsImg)
    {
        hr = _ppsImg->Stat(pstatpsstg);             
    }
    else if (FMTID_ImageSummaryInformation == _fmtid)
    {
        ZeroMemory(pstatpsstg, sizeof(STATPROPSETSTG));
        pstatpsstg->fmtid = _fmtid;
        pstatpsstg->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
    }
    else 
    {
        hr = E_UNEXPECTED;
    }
    if (!_fEditable)
    {
        pstatpsstg->grfFlags = STGM_READ | STGM_SHARE_DENY_NONE;
    }
    return hr;
}

STDMETHODIMP CImagePropSet::SetTimes(const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime)
{
    return E_NOTIMPL;
}

void CImagePropSet::SaveProps(Image *pImage, CDSA<SHCOLUMNID> *pdsaChanges)
{
    // enum the properties in our propertystorage and convert them to PropertyItem structs, and
    // save them to the given frame.
    
    if (_ppsImg)
    {
        for (int i=0;i<pdsaChanges->GetItemCount();i++)
        {
            SHCOLUMNID scid;
            if (pdsaChanges->GetItem(i,&scid))
            {
                if (scid.fmtid == _fmtid)
                {
                    PropertyItem pi;
                    PROPID idUnicode;
                    PROPID idStandard;
                    if (SUCCEEDED(_MapPropidToImgPropid(scid.pid, &idStandard, &idUnicode)))
                    {
                        PROPVARIANT pv = {0};
                        PROPSPEC ps = {PRSPEC_PROPID, scid.pid};
                        if (SUCCEEDED(_ppsImg->ReadMultiple(1, &ps, &pv)))
                        {
                            if (pv.vt == VT_NULL || pv.vt == VT_EMPTY)
                            {
                                if (idUnicode)
                                {
                                    pImage->RemovePropertyItem(idUnicode);
                                }
                                pImage->RemovePropertyItem(idStandard);
                            }
                            else if (SUCCEEDED(_PropVarToImgProp(idUnicode?idUnicode:idStandard, &pv, &pi, idUnicode?TRUE:FALSE)))
                            {
                                // if SetPropertyItem fails what should we do?
                                // for now just ignore it and move on
                                if (Ok == pImage->SetPropertyItem(&pi))
                                {
                                    if (idUnicode)
                                    {
                                        // remove the old ascii tag.
                                        pImage->RemovePropertyItem(idStandard);
                                    }
                                }
                                delete [] (BYTE*)pi.value;

                            }
                            PropVariantClear(&pv);
                        }
                    }
                }                
            }
        }
    }
    _fDirty = FALSE;
}

// Helper functions
HRESULT CImagePropSet::_PropVarToImgProp(PROPID pid, const PROPVARIANT *ppv, PropertyItem *pprop, BOOL bUnicode)
{
    HRESULT hr = S_OK;
    CHAR szValue[MAX_PATH*2];
    void *pBits = NULL;
    ULONG cbData = 0;
    szValue[0] = 0;
    SAFEARRAY *psa = NULL;
    switch (ppv->vt)
    {
    case VT_UI1:
        pprop->type = PropertyTagTypeByte;
        cbData = sizeof(ppv->bVal);
        pBits = (void *)&ppv->bVal;
        break;
    case VT_UI2:
        pprop->type = PropertyTagTypeShort;
        cbData = sizeof(ppv->uiVal);
        pBits = (void *)&ppv->uiVal;
        break;
    case VT_UI4:
        pprop->type = PropertyTagTypeLong;
        cbData = sizeof(ppv->ulVal);
        pBits = (void *)&ppv->ulVal;
        break;
    case VT_LPSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*(lstrlenA(ppv->pszVal)+1);
            pBits = ppv->pszVal ? ppv->pszVal : szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = SHAnsiToUnicode(ppv->pszVal, (LPWSTR)szValue, sizeof(szValue)/sizeof(WCHAR))*sizeof(WCHAR);
            pBits = szValue;
        }
        break;
    case VT_BSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*SHUnicodeToAnsi(ppv->bstrVal, szValue, ARRAYSIZE(szValue));
            pBits = szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = sizeof(WCHAR)*(1+lstrlenW(ppv->bstrVal));
            pBits = ppv->bstrVal;
        }
        break;            
    case VT_LPWSTR:
        if (!bUnicode)
        {
            pprop->type = PropertyTagTypeASCII;
            cbData = sizeof(CHAR)*SHUnicodeToAnsi(ppv->pwszVal, szValue, ARRAYSIZE(szValue));
            pBits = szValue;
        }
        else
        {
            pprop->type = PropertyTagTypeByte;
            cbData = sizeof(WCHAR)*(1+lstrlenW(ppv->pwszVal));
            pBits = ppv->pwszVal;
        }
        break;
    case VT_UI1|VT_ARRAY:
        pprop->type = PropertyTagTypeByte;
        psa = ppv->parray;
        hr = SafeArrayAccessData(psa, &pBits);
        if (SUCCEEDED(hr))
        {
            SafeArrayGetUBound(psa, 1, (LONG*)&cbData);
        }
        break;
    case VT_UI4|VT_ARRAY:
        pprop->type = PropertyTagTypeLong;
        psa = ppv->parray;
        hr = SafeArrayAccessData(psa, &pBits);
        if (SUCCEEDED(hr))
        {
            SafeArrayGetUBound(psa, 1, (LONG*)&cbData);
        }
        break;
    // we ignore rational values because we can't convert back to numerator/denominator pairs
    case VT_R8:
    default:
        hr = E_INVALIDARG;
        break;
    }
    if (SUCCEEDED(hr))
    {
        pprop->id = pid;
        pprop->length = cbData;
        pprop->value = (void **)new BYTE[cbData];
        if (pprop->value)
        {
            CopyMemory(pprop->value, pBits, cbData);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (psa)
    {
        SafeArrayUnaccessData(psa);
    }
    return hr;
}


typedef HRESULT (CALLBACK* PROPPROC)(Image *pimg, PROPVARIANT *ppv);
const static struct 
{
    FMTID fmtid;
    PROPID pid;
    PROPPROC fnPropProc;
} c_aPropList [] =
{
    {PSGUID_SUMMARYINFORMATION, PIDSI_PAGECOUNT, GetImageFrameCount},
};


#define UNI_AUTHOR   0x001
#define UNI_COMMENT  0x002
#define UNI_TITLE    0x004
#define UNI_KEYWORD  0x008
#define UNI_SUBJECT  0x010


const static struct
{
    FMTID fmtid;
    PROPID propid;
    PROPID imgPropid;
    PROPID imgPropidUnicode;
    DWORD dwMask;
}
c_rgImagePropertyMap[] = 
{
    {PSGUID_SUMMARYINFORMATION, PIDSI_TITLE, PropertyTagImageDescription, PropertyTagUnicodeDescription, UNI_TITLE},
    {PSGUID_SUMMARYINFORMATION, PIDSI_COMMENT, 0, PropertyTagUnicodeComment, UNI_COMMENT},
    {PSGUID_SUMMARYINFORMATION, PIDSI_AUTHOR, PropertyTagArtist, PropertyTagUnicodeArtist, UNI_AUTHOR},
    {PSGUID_SUMMARYINFORMATION, PIDSI_APPNAME, PropertyTagSoftwareUsed,0},
    {PSGUID_SUMMARYINFORMATION, PIDSI_CREATE_DTM, PropertyTagDateTime,0},
    // some tags have no standard EXIF/TIFF equivalent
    {PSGUID_SUMMARYINFORMATION, PIDSI_KEYWORDS, 0, PropertyTagUnicodeKeywords, UNI_KEYWORD},
    {PSGUID_SUMMARYINFORMATION, PIDSI_SUBJECT, 0, PropertyTagUnicodeSubject, UNI_SUBJECT},    
};

BOOL IsAsciiPropertyPresent(PROPID pidUnicode, PROPID *aid, UINT cProperties)
{
    // first find the ASCII value
    UINT i;
    BOOL bRet = FALSE;
    PROPID pidAscii = 0;
    for (i=0;!pidAscii && i<ARRAYSIZE(c_rgImagePropertyMap);i++)
    {
        if (pidUnicode == c_rgImagePropertyMap[i].imgPropidUnicode)
        {
            pidAscii = c_rgImagePropertyMap[i].imgPropid;
        }
    }
    if (pidAscii)
    {
        for (i=0;i<cProperties;i++)
        {
            if (pidAscii == aid[i])
            {
                bRet = TRUE;
            }
        }
    }
    return bRet;
}

void _UpdateUnicodeMask(DWORD *pdwMask, PROPID pid)
{
    for (int i=0;i<ARRAYSIZE(c_rgImagePropertyMap);i++)
    {
        if (pid == c_rgImagePropertyMap[i].imgPropidUnicode)
        {
            *pdwMask |= c_rgImagePropertyMap[i].dwMask;
        }
    }
}
// sync all of the properties in the image file (regular header and EXIF header)
//  into the property storage that we have here
// for properties that we write UNICODE equivalents, we always defer to the ASCII version
// if present in the file. 


HRESULT CImagePropSet::SyncImagePropsToStorage()
{
    UINT cProperties = _pimg->GetPropertyCount();
    PROPSPEC pspec;
    pspec.ulKind = PRSPEC_PROPID;
    PROPVARIANT pvar = {0};
    // create a simple mask for determining which of the unicode properties are written
    // if they aren't written we will special case them and write empty strings with VT_LPWSTR type
    DWORD dwUnicodeWritten = 0;
    if (cProperties)
    {
        PROPID *aid = new PROPID[cProperties];
        if (aid)
        {
            if (Ok == _pimg->GetPropertyIdList(cProperties, aid))
            {
                BOOL bUnicode;
                for (UINT i = 0; i < cProperties; i++)
                {
                    if (SUCCEEDED(_MapImgPropidToPropid(aid[i], &pspec.propid, &bUnicode)))
                    {
                        if (!bUnicode || !IsAsciiPropertyPresent(aid[i], aid, cProperties))
                        {
                            UINT cbSize = _pimg->GetPropertyItemSize(aid[i]);
                            if (cbSize)
                            {
                                PropertyItem *ppi = (PropertyItem*)LocalAlloc(LPTR, cbSize);
                                if (ppi)
                                {
                                    if (Ok == _pimg->GetPropertyItem(aid[i], cbSize, ppi))
                                    {
                                        if (SUCCEEDED(_PropImgToPropvar(ppi, &pvar, bUnicode)))
                                        {
                                            _ppsImg->WriteMultiple(1, &pspec, &pvar,2);
                                            if (_fmtid == FMTID_SummaryInformation)
                                            {
                                                _UpdateUnicodeMask(&dwUnicodeWritten, aid[i]);
                                            }
                                            PropVariantClear(&pvar);
                                        }
                                    }
                                    LocalFree(ppi);
                                }
                            }
                        }
                    }
                }
            }
            delete [] aid;
        }
    }
    //
    // Some properties are derived from other means than EXIF or TIFF tags, cycle
    // through the property list and add properties from callback functions
    //
    for (int i=0;i<ARRAYSIZE(c_aPropList);i++)
    {
        pspec.propid = c_aPropList[i].pid;
        if (_fmtid == c_aPropList[i].fmtid && 
            SUCCEEDED(c_aPropList[i].fnPropProc(_pimg, &pvar)))
        {
            _ppsImg->WriteMultiple(1, &pspec, &pvar,2);
            PropVariantClear(&pvar);
        }
    }
    //
    // Write the empty unicode strings if needed
    //
    if (_fEditable && _fmtid == FMTID_SummaryInformation)
    {
        PropVariantInit(&pvar);
        pvar.vt = VT_LPWSTR;
        pvar.pwszVal = L"";
        if (pvar.pwszVal)
        {
            for (int i=0;i<ARRAYSIZE(c_rgImagePropertyMap);i++)
            {
                if (c_rgImagePropertyMap[i].dwMask && !(c_rgImagePropertyMap[i].dwMask & dwUnicodeWritten))
                {
                    pspec.propid = c_rgImagePropertyMap[i].propid;
                    _ppsImg->WriteMultiple(1, &pspec, &pvar, 2);
                }
            }
        }
        // don't clear the propvar since we didn't heap alloc the string
    }
    return S_OK;
}


HRESULT StrDupNW(LPCWSTR psz, WCHAR **ppwsz, DWORD cch)
{
    WCHAR *pwsz;
    DWORD cb = cch*sizeof(WCHAR);
    if (psz)
    {
        if (psz[cch-1] != L'\0')
        {
            cb+=sizeof(WCHAR); // need space for NULL
        }
        pwsz = (WCHAR *)CoTaskMemAlloc(cb); 
    }
    else
        pwsz = NULL;
    
    *((PVOID UNALIGNED64 *) ppwsz) = pwsz;

    if (pwsz)
    {
        pwsz[(cb/sizeof(WCHAR))-1] = L'\0';
        memcpy(pwsz, psz, cch*sizeof(WCHAR));
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

HRESULT CImagePropSet::_PropImgToPropvar(PropertyItem *pi, PROPVARIANT *pvar, BOOL bUnicode)
{
    HRESULT hr = S_OK;
    if (!pi->length)
    {
        return E_FAIL;
    }
    switch (pi->type)
    {
    case PropertyTagTypeByte:
        pvar->vt = VT_UI1;
        // check for multi-valued property and convert to safearray or unicode string if found
        if (pi->length > sizeof(UCHAR))
        {
            if (!bUnicode)
            {
                SAFEARRAYBOUND bound;
                bound.cElements = pi->length/sizeof(UCHAR);
                bound.lLbound = 0;
                pvar->vt |= VT_ARRAY; 
                hr = E_OUTOFMEMORY;
                pvar->parray = SafeArrayCreate(VT_UI1, 1, &bound);                              
                if (pvar->parray)
                {
                    void *pv;
                    hr = SafeArrayAccessData(pvar->parray, &pv);
                    if (SUCCEEDED(hr))
                    {
                        CopyMemory(pv, pi->value, pi->length);
                        SafeArrayUnaccessData(pvar->parray);                        
                    }
                    else
                    {
                        SafeArrayDestroy(pvar->parray);
                    }
                }
            }
            else
            {
                pvar->vt = VT_LPWSTR;
                hr = StrDupNW((LPCWSTR)pi->value, &pvar->pwszVal, pi->length/sizeof(WCHAR));
            }
        }
        else
        {
            pvar->bVal = *((UCHAR*)pi->value);
        }
        
        break;
        
    case PropertyTagTypeShort:
        pvar->vt = VT_UI2;
        pvar->uiVal = *((USHORT*)pi->value);
        break;
        
    case PropertyTagTypeLong:
        pvar->vt = VT_UI4;
        if (pi->length > sizeof(ULONG))
        {
            SAFEARRAYBOUND bound;
            bound.cElements = pi->length/sizeof(ULONG);
            bound.lLbound = 0;
            pvar->vt |= VT_ARRAY; 
            hr = E_OUTOFMEMORY;
            pvar->parray = SafeArrayCreate(VT_UI4, 1, &bound);                              
            if (pvar->parray)
            {
                void *pv;
                hr = SafeArrayAccessData (pvar->parray, &pv);
                if (SUCCEEDED(hr))
                {
                    CopyMemory (pv, pi->value, pi->length);
                    SafeArrayUnaccessData(pvar->parray);                        
                }
                else
                {
                    SafeArrayDestroy(pvar->parray);
                }
            }
        }
        else
        {
            pvar->ulVal = *((ULONG*)pi->value);
        }
        break;
        
    case PropertyTagTypeASCII:
        // special case for date taken
        if (_fmtid == FMTID_ImageProperties && pi->id == PropertyTagExifDTOrig)
        {
            SYSTEMTIME st = {0};
            sscanf((LPSTR)pi->value, "%hd:%hd:%hd %hd:%hd:%hd",
                   &st.wYear, &st.wMonth,
                   &st.wDay, &st.wHour,
                   &st.wMinute, &st.wSecond);
            if (st.wYear) 
            {
                FILETIME ftUTC;
                FILETIME ftLocal;            
                // we expect cameras to return local times. Need to convert to UTC.
                SystemTimeToFileTime(&st, &ftLocal);
                LocalFileTimeToFileTime(&ftLocal, &ftUTC);
                FileTimeToSystemTime(&ftUTC, &st);
                SystemTimeToVariantTime(&st, &pvar->date);
                pvar->vt = VT_DATE;
            }
            else
            {
                pvar->vt = VT_EMPTY;
            }
        }
        else 
        {
            hr = SHStrDupA(pi->value ? (LPSTR)pi->value : "", &pvar->pwszVal);
            if (SUCCEEDED(hr))
            {
                pvar->vt = VT_LPWSTR;
            }
        }
        break;
        
    case PropertyTagTypeSRational:
    case PropertyTagTypeRational:
        {
            LONG *pl = (LONG*)pi->value;
            LONG num = pl[0];
            LONG den = pl[1];
            
            pvar->vt = VT_R8;            
            if (0 == den)
                pvar->dblVal = 0;           // don't divide by zero
            else
                pvar->dblVal = ((double)num)/((double)den);
            
            break;
        }
        
    case PropertyTagTypeUndefined:
    case PropertyTagTypeSLONG:
    default:
        hr = E_UNEXPECTED;
        break;
    }
    
    return hr;
}



HRESULT CImagePropSet::_MapPropidToImgPropid(PROPID propid, PROPID *ppid, PROPID *pidUnicode)
{
    HRESULT hr;
    *ppid = 0;
    *pidUnicode = 0;
    if (_fmtid == FMTID_ImageProperties)
    {
        *ppid = propid;     // these go into the EXIF header
        hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(c_rgImagePropertyMap); i++)
        {
            if (c_rgImagePropertyMap[i].fmtid == _fmtid && c_rgImagePropertyMap[i].propid == propid)
            {
                *ppid = c_rgImagePropertyMap[i].imgPropid;
                *pidUnicode = c_rgImagePropertyMap[i].imgPropidUnicode;
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

HRESULT CImagePropSet::_MapImgPropidToPropid(PROPID propid, PROPID *ppid, BOOL *pbUnicode)
{
    HRESULT hr;
    *pbUnicode = FALSE;
    if (_fmtid == FMTID_ImageProperties)
    {
        *ppid = propid;     // EXIF properties don't need to be mapped
        hr = S_OK;
    }
    else
    {
        *ppid = 0;
        hr = E_FAIL;
        for (int i = 0; i < ARRAYSIZE(c_rgImagePropertyMap); i++)
        {
            if (c_rgImagePropertyMap[i].fmtid == _fmtid && 
                (c_rgImagePropertyMap[i].imgPropid == propid ||
                 c_rgImagePropertyMap[i].imgPropidUnicode == propid))
            {
                *ppid = c_rgImagePropertyMap[i].propid;
                *pbUnicode = (c_rgImagePropertyMap[i].imgPropidUnicode == propid);
                hr = S_OK;
                break;
            }
        }
    }
    return hr;
}

HRESULT GetImageFrameCount(Image *pImage, PROPVARIANT *ppv)
{
    HRESULT hr = S_FALSE;
    LONG lCount;
    lCount = 1; //Default to 1 image
    UINT uiDim = pImage->GetFrameDimensionsCount();
    ppv->vt = VT_EMPTY;
    if (uiDim)
    {
        GUID *pDim = new GUID[uiDim];
        if (pDim)
        {
            if (Ok == pImage->GetFrameDimensionsList(pDim, uiDim))
            {
                lCount = 0;
                ULONG uiN;
                for (ULONG i=0;i<uiDim;i++)
                {
                    uiN = pImage->GetFrameCount(&pDim[i]);
                    lCount += uiN;                                        
                }
                ppv->vt = VT_UI4;
                ppv->lVal = lCount;
                hr = S_OK;
            }
            delete [] pDim;
        }   
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT CImagePropSet::_GetImageSummaryProps(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[])
{
    HRESULT hr = E_FAIL;
    if (_pimg)
    {
        hr = S_OK;
        for (ULONG i = 0; i < cpspec; i++)
        {
            PropVariantInit(&rgvar[i]);
            rgvar[i].vt = VT_UI4;
            switch (rgpspec[i].propid)
            {
            case PIDISI_CX:
                rgvar[i].ulVal = _pimg->GetWidth();
                break;
            case PIDISI_CY:
                rgvar[i].ulVal = _pimg->GetHeight();
                break;
            case PIDISI_RESOLUTIONX:
                rgvar[i].ulVal = (ULONG)_pimg->GetHorizontalResolution();
                break;
            case PIDISI_RESOLUTIONY:
                rgvar[i].ulVal = (ULONG)_pimg->GetVerticalResolution();
                break;
            case PIDISI_BITDEPTH:
                {
                    PixelFormat pf = _pimg->GetPixelFormat();
                    rgvar[i].ulVal = (pf >> 8) & 0xff;
                }
                break;
            case PIDISI_FRAMECOUNT:
                hr = GetImageFrameCount(_pimg, &rgvar[i]);
                break;

            case PIDISI_DIMENSIONS:
            {
                TCHAR szFmt[64];                
                if (LoadString(_Module.GetModuleInstance(), IDS_DIMENSIONS_FMT, szFmt, ARRAYSIZE(szFmt)))
                {
                    DWORD_PTR args[2];
                    args[0] = (DWORD_PTR)_pimg->GetWidth();
                    args[1] = (DWORD_PTR)_pimg->GetHeight();

                    TCHAR szBuffer[64];
                    FormatMessage(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY, 
                                   szFmt, 0, 0, szBuffer, ARRAYSIZE(szBuffer), (va_list*)args);

                    hr = SHStrDup(szBuffer, &rgvar[i].pwszVal);
                    if (SUCCEEDED(hr))
                        rgvar[i].vt = VT_LPWSTR;
                    else
                        rgvar[i].vt = VT_EMPTY;
                }
                break;
            }

            default:
                rgvar[i].vt = VT_EMPTY;
                hr = S_FALSE;
                break;
            }
        }
    }
    return hr;
}


STDMETHODIMP CPropEnum::Next(ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG uRet = 0;
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    for (;_idx < _nStat && uRet < celt;_idx++)
    {
        rgelt[uRet] = _pStat[_idx];
        uRet++;        
    }
    if (uRet < celt)
    {
        hr = S_FALSE;
    }
    if (pceltFetched)
    {
        *pceltFetched = uRet;
    }
    return hr;
}

STDMETHODIMP CPropEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;
    ULONG ul = min(_idx+celt, _nStat);
    if (ul - _idx < celt)
    {
        hr = S_FALSE;
    }
    _idx = ul;
    return hr;
}

STDMETHODIMP CPropEnum::Reset(void)
{
    _idx = 0;
    return S_OK;
}

STDMETHODIMP CPropEnum::Clone(IEnumSTATPROPSTG **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    CPropEnum *pNew = new CPropEnum(_pStat, _nStat);
    if (pNew)
    {
        hr = pNew->QueryInterface(IID_PPV_ARG(IEnumSTATPROPSTG, ppenum));
        pNew->Release();
    }
    return hr;
}

STDMETHODIMP CPropEnum::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CPropEnum, IEnumSTATPROPSTG),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CPropEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPropEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

CPropEnum::CPropEnum(const STATPROPSTG *pStats, ULONG nStats) : _idx(0), _cRef(1), _pStat(pStats), _nStat(nStats)
{
    _Module.Lock();
}

CPropEnum::~CPropEnum()
{
    _Module.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\makefile.inc ===
..\shimgvw.rc : $(PROJECT_ROOT)\lib\$(O)\shimgvw.tlb $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\photoverb.cpp ===
#include "precomp.h"
#include "shimgvw.h"
#include "cowsite.h"
#include "prevwnd.h"
#include "shutil.h"
#include "prwiziid.h"
#pragma hdrstop

// Context menu offset IDs
enum
{
    OFFSET_OPEN        = 0,
    OFFSET_PRINTTO,
    OFFSET_ROT90,
    OFFSET_ROT270,
    OFFSET_SETWALL,
    OFFSET_ZOOMIN,
    OFFSET_ZOOMOUT,
    OFFSET_ACTUALSIZE,
    OFFSET_BESTFIT,
    OFFSET_NEXTPAGE,
    OFFSET_PREVPAGE,
    OFFSET_MAX
};

#define PHOTOVERBS_THUMBNAIL    0x1
#define PHOTOVERBS_ICON         0x2
#define PHOTOVERBS_FILMSTRIP    0x3
#define PHOTOVERBS_SLIDESHOW    0x4
#define PHOTOVERBS_IMGPREVIEW   0x5


class CPhotoVerbs : public IContextMenu,
                    public IShellExtInit,
                    public IDropTarget,
                    public CObjectWithSite,
                    public NonATLObject
{
public:
    CPhotoVerbs();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pIDFolder, IDataObject *pdtobj, HKEY hKeyID);

    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pCMI);
    STDMETHODIMP GetCommandString(UINT_PTR uID, UINT uFlags, UINT *res, LPSTR pName, UINT ccMax);

    // IDropTarget ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CPhotoVerbs();
    void _RotatePictures(int iAngle, UINT idPrompt);
    void _OpenPictures();
    void _SetWallpaper();
//    HRESULT _InvokePrintToInPPW(LPCMINVOKECOMMANDINFO pCMI, IDataObject *pdtobj);
    BOOL _ImageOptionExists(IQueryAssociations *pqa, DWORD dwOption);
    HRESULT _QueryAssociations();
    DWORD _GetMode();
    BOOL _CheckForcePreview(IQueryAssociations *pqa);
    HRESULT _MapVerb(LPCMINVOKECOMMANDINFO pici, int *pidVerb);
    LONG _cRef;
    IDataObject *_pdtobj;
    BOOL  _fForcePreview;
    BOOL  _fAcceptPreview;
    BOOL  _fIncludeRotate;
    BOOL  _fIncludeSetWallpaper;
    IImgCmdTarget * _pict;              // if hosted in image preview, this allows us to delegate commands to it
    BOOL _fImgMode;                     // TRUE if we are hosted in defview and defview is in thumbnail or filmstip mode
    BOOL _fReadOnly;                    // TRUE if one or more items selected are SFGAO_READONLY

};

CPhotoVerbs::CPhotoVerbs() : _cRef(1)
{
    ASSERT(_pdtobj == NULL);
    ASSERT(_fForcePreview == FALSE);
    ASSERT(_fIncludeRotate == FALSE);
    ASSERT(_fIncludeSetWallpaper == FALSE);
}

CPhotoVerbs::~CPhotoVerbs()
{
    IUnknown_Set(&_punkSite, NULL);
    IUnknown_Set((IUnknown**)&_pdtobj, NULL);
    ATOMICRELEASE(_pict);
}

STDAPI CPhotoVerbs_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CPhotoVerbs *psid = new CPhotoVerbs();
    if (!psid)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = psid->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    psid->Release();
    return hr;
}

STDMETHODIMP CPhotoVerbs::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPhotoVerbs, IShellExtInit),
        QITABENT(CPhotoVerbs, IContextMenu),
        QITABENT(CPhotoVerbs, IDropTarget),
        QITABENT(CPhotoVerbs, IObjectWithSite),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPhotoVerbs::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CPhotoVerbs::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


// IShellExtInit

STDMETHODIMP CPhotoVerbs::Initialize(LPCITEMIDLIST pIDFolder, IDataObject *pdtobj, HKEY hKeyID)
{
    IUnknown_Set((IUnknown**)&_pdtobj, pdtobj);
    _fImgMode = FALSE;

    DWORD dwAttributes = 0;
    SHGetAttributesFromDataObject(pdtobj, SFGAO_READONLY, &dwAttributes, NULL);
    _fReadOnly  = BOOLIFY(dwAttributes);

    return S_OK;
}

BOOL CPhotoVerbs::_ImageOptionExists(IQueryAssociations *pqa, DWORD dwOption)
{
    BOOL fRetVal = FALSE;
    DWORD dwFlags = 0;
    DWORD cbFlags = sizeof(dwFlags);
    if (SUCCEEDED(pqa->GetData(0, ASSOCDATA_VALUE, TEXT("ImageOptionFlags"), &dwFlags, &cbFlags)))
    {
        fRetVal = (dwFlags & dwOption);
    }

    return fRetVal;
}

BOOL _VerbExists(IQueryAssociations *pqa, LPCTSTR pszVerb)
{
    DWORD cch;
    return SUCCEEDED(pqa->GetString(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, pszVerb, NULL, &cch)) && cch;
}

BOOL CPhotoVerbs::_CheckForcePreview(IQueryAssociations *pqa)
{
    //  we force if the app has no a preview and the user has not customized
    //  and we are not the current default (we install on open)
    BOOL fRet = FALSE;
    if (!_VerbExists(pqa, TEXT("preview")))
    {
        //  if nobody owns we always accept
        //  this is for when somebody does an InvokeCommand("preview");
        _fAcceptPreview = TRUE;
        if (S_FALSE == pqa->GetData(0, ASSOCDATA_HASPERUSERASSOC, NULL, NULL, NULL))
        {
            WCHAR sz[MAX_PATH];
            DWORD cch = ARRAYSIZE(sz);
            _fForcePreview = FAILED(pqa->GetString(0, ASSOCSTR_COMMAND, NULL, sz, &cch));
            if (!_fForcePreview)
            {
                //  there is a default handler
                //  if its us hide the preview verb
                //  because the static menu will do it for us
                if (StrStrIW(sz, L"shimgvw.dll"))
                {
                    _fAcceptPreview = FALSE;
                }
                else
                    _fForcePreview = TRUE;
            }
        }
    }

    return fRet;
}

HRESULT CPhotoVerbs::_QueryAssociations()
{
    IQueryAssociations *pqa;
    HRESULT hr = IUnknown_QueryService(_punkSite, SID_CtxQueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        //  dont do preview if the user has customized
         _CheckForcePreview(pqa);
        _fIncludeRotate       = _ImageOptionExists(pqa, IMAGEOPTION_CANROTATE);
        _fIncludeSetWallpaper = _ImageOptionExists(pqa, IMAGEOPTION_CANWALLPAPER);
        pqa->Release();
        return S_OK;
    }
    else
    {
        // we may have been invoked directly instead of via ShellExecute or right-click
        _fAcceptPreview = TRUE;
    }
    return S_FALSE;
}

DWORD CPhotoVerbs::_GetMode()
{
    DWORD dwMode, dw;
    if (_pict)
    {
        _pict->GetMode(&dw);
        switch (dw)
        {
        case SLIDESHOW_MODE:
            dwMode = PHOTOVERBS_SLIDESHOW;
            break;
        case WINDOW_MODE:
            dwMode = PHOTOVERBS_IMGPREVIEW;
            break;
        case CONTROL_MODE:
            dwMode = PHOTOVERBS_FILMSTRIP;
            break;
        default:
            dwMode = PHOTOVERBS_ICON;
            break;
        }
    }
    else
    {
        dwMode = (_fImgMode) ? PHOTOVERBS_THUMBNAIL : PHOTOVERBS_ICON;
    }

    return dwMode;
}

// IContextMenu
STDMETHODIMP CPhotoVerbs::QueryContextMenu(HMENU hMenu, UINT uIndex, UINT uIDFirst, UINT uIDLast, UINT uFlags)
{
    TCHAR szBuffer[128];
    HRESULT hr = _QueryAssociations();

    DWORD dwMultiPage = MPCMD_HIDDEN;

    hr = IUnknown_QueryService(_punkSite, SID_SImageView, IID_PPV_ARG(IImgCmdTarget, &_pict));
    if (SUCCEEDED(hr))
    {
        _pict->GetPageFlags(&dwMultiPage);
    }

    IFolderView * pfv = NULL;
    hr = IUnknown_QueryService(_punkSite, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        UINT uViewMode;
        hr = pfv->GetCurrentViewMode(&uViewMode);
        if (SUCCEEDED(hr) &&
           ((FVM_THUMBNAIL == uViewMode) || (FVM_THUMBSTRIP == uViewMode)))
        {
            _fImgMode = TRUE;
        }
        pfv->Release();
    }

    DWORD dwMode = _GetMode();
    // always load the Open verb if no static Open verb is registered
    if (_fAcceptPreview)
    {
        if (PHOTOVERBS_SLIDESHOW != dwMode && PHOTOVERBS_IMGPREVIEW != dwMode)
        {
            LoadString(_Module.GetModuleInstance(), IDS_PREVIEW_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_OPEN, szBuffer);

            //  only set to default if there isnt a preview already there
            if (_fForcePreview)
                SetMenuDefaultItem(hMenu, uIndex, MF_BYPOSITION);

            uIndex++;
        }
    }

    if (!(uFlags & CMF_DEFAULTONLY))
    {
        InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);
        if (_fIncludeRotate)
        {
            if (PHOTOVERBS_ICON != dwMode)
            {
                UINT uFlags = MF_BYPOSITION | MF_STRING;
                if (_fReadOnly && PHOTOVERBS_THUMBNAIL == dwMode)
                {
                    uFlags |= MF_GRAYED;
                }
                else
                {
                    uFlags |= MF_ENABLED; // in all modes by thumbnails, we allow temporary rotation of readonly images
                }

                LoadString(_Module.GetModuleInstance(), IDS_ROTATE90_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, uFlags, uIDFirst + OFFSET_ROT90, szBuffer);

                LoadString(_Module.GetModuleInstance(), IDS_ROTATE270_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, uFlags, uIDFirst + OFFSET_ROT270, szBuffer);
            }
        }

        if (PHOTOVERBS_IMGPREVIEW == dwMode)
        {
            LoadString(_Module.GetModuleInstance(), IDS_ZOOMIN_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_ZOOMIN, szBuffer);

            LoadString(_Module.GetModuleInstance(), IDS_ZOOMOUT_CTX, szBuffer, ARRAYSIZE(szBuffer));
            InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_ZOOMOUT, szBuffer);

            if (dwMultiPage != MPCMD_HIDDEN && dwMultiPage != MPCMD_DISABLED)
            {
                if (MPCMD_LASTPAGE != dwMultiPage)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_NEXTPAGE_CTX, szBuffer, ARRAYSIZE(szBuffer));
                    InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_NEXTPAGE, szBuffer);
                }
                if (MPCMD_FIRSTPAGE != dwMultiPage)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_PREVPAGE_CTX, szBuffer, ARRAYSIZE(szBuffer));
                    InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_PREVPAGE, szBuffer);
                }
            }
        }
        InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_SEPARATOR, 0, NULL);

        if (_fIncludeSetWallpaper)
        {
            if (PHOTOVERBS_ICON != dwMode)
            {
                LoadString(_Module.GetModuleInstance(), IDS_WALLPAPER_CTX, szBuffer, ARRAYSIZE(szBuffer));
                InsertMenu(hMenu, uIndex++, MF_BYPOSITION | MF_STRING, uIDFirst + OFFSET_SETWALL, szBuffer);
            }
        }

    }

    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, OFFSET_MAX);
}

// IDropTarget::DragEnter
HRESULT CPhotoVerbs::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragOver
HRESULT CPhotoVerbs::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    return S_OK;;
}

// IDropTarget::DragLeave
HRESULT CPhotoVerbs::DragLeave(void)
{
    return S_OK;
}

// IDropTarget::DragDrop
HRESULT CPhotoVerbs::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_COPY;
    HRESULT hr = Initialize(NULL, pdtobj, NULL);
    if (SUCCEEDED(hr))
    {
        // we may need to get the verb.
        _OpenPictures();
    }
    return hr;
}

class VerbThreadProc : public NonATLObject
{
public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    BOOL CreateVerbThread();

    VerbThreadProc(IDataObject *pdo, IUnknown *punk, HRESULT *phr);

protected:
    virtual DWORD VerbWithThreadRefCB() PURE;
    virtual DWORD VerbWithThreadRef() PURE;
    virtual DWORD VerbWithoutThreadRefCB() PURE;
    virtual DWORD VerbWithoutThreadRef() PURE;

    virtual ~VerbThreadProc();

    IDataObject *_pdo;        // the un-marshalled versions...
    IFolderView *_pfv;

private:
    static DWORD s_WithThreadRef(void *pv);
    static DWORD s_WithThreadRefCB(void *pv);

    static DWORD s_WithoutThreadRef(void *pv);
    static DWORD s_WithoutThreadRefCB(void *pv);

    void Unmarshall();

    LONG _cRef;

    IStream *_pstmDataObj;    // the marshalled IDataObject stream
    IStream *_pstmFolderView; // the marshalled IFolderView stream
};

VerbThreadProc::VerbThreadProc(IDataObject* pdo, IUnknown *punk, HRESULT *phr)
{
    _cRef = 1;

    if (punk)
    {
        IFolderView *pfv = NULL;
        if (SUCCEEDED(IUnknown_QueryService(punk, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv))))
        {
            CoMarshalInterThreadInterfaceInStream(IID_IFolderView, pfv, &_pstmFolderView);
            pfv->Release();
        }
    }

    if (pdo)
    {
        CoMarshalInterThreadInterfaceInStream(IID_IDataObject, pdo, &_pstmDataObj);
    }

    *phr = (_pstmDataObj || _pstmFolderView) ? S_OK : E_OUTOFMEMORY;
}

VerbThreadProc::~VerbThreadProc()
{
    ATOMICRELEASE(_pstmDataObj);
    ATOMICRELEASE(_pstmFolderView);
    ATOMICRELEASE(_pdo);
    ATOMICRELEASE(_pfv);
}

STDMETHODIMP_(ULONG) VerbThreadProc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) VerbThreadProc::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

DWORD VerbThreadProc::s_WithThreadRefCB(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    potd->AddRef();
    potd->Unmarshall();
    return potd->VerbWithThreadRefCB();
}

DWORD VerbThreadProc::s_WithThreadRef(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    DWORD dw = potd->VerbWithThreadRef();
    potd->Release();
    return dw;
}

DWORD VerbThreadProc::s_WithoutThreadRefCB(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    potd->AddRef();
    potd->Unmarshall();
    return potd->VerbWithoutThreadRefCB();
}

DWORD VerbThreadProc::s_WithoutThreadRef(void *pv)
{
    VerbThreadProc *potd = (VerbThreadProc *)pv;
    DWORD dw =  potd->VerbWithoutThreadRef();
    potd->Release();
    return dw;
}

void VerbThreadProc::Unmarshall()
{
    if (_pstmDataObj)
    {
        CoGetInterfaceAndReleaseStream(_pstmDataObj, IID_PPV_ARG(IDataObject, &_pdo));
        _pstmDataObj = NULL;
    }

    if (_pstmFolderView)
    {
        CoGetInterfaceAndReleaseStream(_pstmFolderView, IID_PPV_ARG(IFolderView, &_pfv));
        _pstmFolderView = NULL;
    }
}

BOOL VerbThreadProc::CreateVerbThread()
{
    BOOL bRet;

    // The thread ref is the more efficient start-up method, but we need to
    // handle the case where the caller doesn't have one.
    bRet = SHCreateThread(s_WithThreadRef, this, CTF_COINIT | CTF_THREAD_REF, s_WithThreadRefCB);
    if (!bRet)
    {
        bRet = SHCreateThread(s_WithoutThreadRef, this, CTF_COINIT | CTF_WAIT_ALLOWCOM, s_WithoutThreadRefCB);
    }

    return bRet;
}

class OpenThreadProc : public VerbThreadProc
{
public:
    DWORD VerbWithThreadRefCB();
    DWORD VerbWithThreadRef();
    DWORD VerbWithoutThreadRefCB();
    DWORD VerbWithoutThreadRef();

    OpenThreadProc(IDataObject *pdo, IUnknown *punk, HRESULT *phr) : VerbThreadProc(pdo, punk, phr) {};

private:
    HRESULT Walk();
    void Preview();

    CPreviewWnd* _pPreview;
};

DWORD OpenThreadProc::VerbWithThreadRefCB()
{
    return 0;
}

DWORD OpenThreadProc::VerbWithThreadRef()
{
    HRESULT hr = Walk();
    SHReleaseThreadRef();
    if (S_OK == hr)
    {
        Preview();
    }
    return 0;
}

DWORD OpenThreadProc::VerbWithoutThreadRefCB()
{
    Walk();
    return 0;
}

DWORD OpenThreadProc::VerbWithoutThreadRef()
{
    Preview();
    return 0;
}

HRESULT OpenThreadProc::Walk()
{
    HRESULT hr = E_OUTOFMEMORY;

    if (_pdo)
    {
        _pPreview = new CPreviewWnd();
        if (_pPreview)
        {
            if (!_pPreview->TryWindowReuse(_pdo))
            {
                hr = _pPreview->Initialize(NULL, WINDOW_MODE, FALSE);
                if (SUCCEEDED(hr))
                {
                    // create the viewer window before doing the expensive namespace walk
                    // so if a second instance is created it will find the window                   
                    if (_pPreview->CreateViewerWindow())
                    {                       
                        hr = _pPreview->WalkItemsToPreview(_pfv ? (IUnknown *)_pfv: (IUnknown *)_pdo);
                        if (_pfv && FAILED(hr))
                        {
                            hr = _pPreview->WalkItemsToPreview((IUnknown *)_pdo);
                        }
                    }
                    else
                    {
                        DWORD dw = GetLastError();
                        hr = HRESULT_FROM_WIN32(dw);
                    }
                }               
            }
            else
            {
                hr = S_FALSE;
            }                       
        }
        // We're done with these
        ATOMICRELEASE(_pdo);
        ATOMICRELEASE(_pfv);
    }

    return hr;
}

void OpenThreadProc::Preview()
{
    if (_pPreview)
    {   
        // viewer window should have been created by now
        _pPreview->PreviewItems();
        MSG msg;
        while (GetMessage(&msg, NULL, 0, 0) > 0)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
           
        delete _pPreview;
        _pPreview = NULL;
    }
}

void CPhotoVerbs::_OpenPictures()
{
    if (_pdtobj)
    {
        HRESULT hr;
        OpenThreadProc *potd = new OpenThreadProc(_pdtobj, _punkSite, &hr);
        if (potd)
        {
            if (SUCCEEDED(hr))
            {
                potd->CreateVerbThread();
            }
            potd->Release();
        }       
    }
}

// implement the rotate verb, this is a lengthy operation so put it onto a background
// thread if we can, marshall the IDataObject and let it do its thing...
class CRotateThreadProc : public VerbThreadProc
{
public:
    DWORD VerbWithThreadRefCB() { return 0; }
    DWORD VerbWithThreadRef() { return _Rotate(); }
    DWORD VerbWithoutThreadRefCB() { return _Rotate(); }
    DWORD VerbWithoutThreadRef() { return 0; }

    CRotateThreadProc(IDataObject* pdo, int iAngle, UINT idPrompt, HRESULT *phr);

private:
    DWORD _Rotate();

    int  _iAngle;
    UINT _idPrompt;
};

CRotateThreadProc::CRotateThreadProc(IDataObject* pdo, int iAngle, UINT idPrompt, HRESULT *phr) :
    VerbThreadProc(pdo, NULL, phr)
{
    _iAngle = iAngle;
    _idPrompt = idPrompt;
}

DWORD CRotateThreadProc::_Rotate()
{
    FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium = {0};

    if (_pdo)
    {
        HRESULT hr = _pdo->GetData(&fmt, &medium);
        if (SUCCEEDED(hr))
        {
            IProgressDialog *ppd;

            hr = CoCreateInstance(CLSID_ProgressDialog,  NULL, CLSCTX_INPROC, IID_PPV_ARG(IProgressDialog, &ppd));
            if (SUCCEEDED(hr))
            {
                TCHAR szBuffer[MAX_PATH];
                TCHAR szFile[MAX_PATH];
                HDROP hd = (HDROP)medium.hGlobal;
                UINT cItems = DragQueryFile(hd, (UINT)-1, NULL, 0);

                // prime the progress dialog

                if (cItems > 1)
                {
                    LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);

                    LoadString(_Module.GetModuleInstance(), _idPrompt, szBuffer, ARRAYSIZE(szBuffer));
                    ppd->SetTitle(T2W(szBuffer));

                    ppd->SetAnimation(_Module.GetModuleInstance(), IDA_ROTATEAVI);
                    ppd->StartProgressDialog(NULL, NULL, PROGDLG_AUTOTIME, NULL);
                    ppd->SetProgress(1, cItems);
                }

                // lets get GDI+, the encoder array and start messing with the bits.   this is a
                // sync operation so check for the user cancelling the UI accordingly.

                IShellImageDataFactory *pif;
                hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellImageDataFactory, &pif));
                if (SUCCEEDED(hr))
                {
                    for (UINT i = 0; (i != cItems) && !((cItems > 1) ? ppd->HasUserCancelled() : FALSE); i++)
                    {
                        if (DragQueryFile(hd, i, szFile, ARRAYSIZE(szFile)))
                        {
                            if (cItems > 1)
                            {
                                ppd->SetLine(2, T2W(szFile), TRUE, NULL);
                                ppd->SetProgress(i+1, cItems);
                            }

                            // construct an image object from the file, rotate it and save it back

                            IShellImageData *pid;
                            hr = pif->CreateImageFromFile(szFile, &pid);
                            if (SUCCEEDED(hr))
                            {
                                hr = pid->Decode(SHIMGDEC_DEFAULT,0,0);
                                if (SUCCEEDED(hr))
                                {
                                    if (!((cItems > 1) ? ppd->HasUserCancelled() : FALSE))
                                    {
                                        GUID guidFormat;
                                        SIZE sz;
                                        if ( SUCCEEDED(pid->GetRawDataFormat(&guidFormat)) &&
                                             SUCCEEDED(pid->GetSize(&sz)))
                                        {
                                            if (S_OK == pid->IsEditable())
                                            {
                                                hr = S_OK;
                                                if (::IsEqualGUID(ImageFormatJPEG, guidFormat))
                                                {
                                                    if ((sz.cx % 16) || (sz.cy % 16))
                                                    {
                                                        if (cItems > 1)
                                                        {
                                                            LoadString(_Module.GetModuleInstance(), IDS_ROTATEDLGTITLE, szBuffer, ARRAYSIZE(szBuffer));
                                                            ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                                        }

                                                        TCHAR szTitle[MAX_PATH];
                                                        TCHAR szText[1024];

                                                        LoadString(_Module.GetModuleInstance(), IDS_ROTATE_LOSS, szText, ARRAYSIZE(szText));
                                                        LoadString(_Module.GetModuleInstance(), IDS_ROTATE_CAPTION, szTitle, ARRAYSIZE(szTitle));

                                                        // Set default to return IDOK so we know if the user selected something or
                                                        // if the "don't show me this again" bit was respected
                                                        int nResult = SHMessageBoxCheck(NULL, szText, szTitle,
                                                                                        MB_YESNO|MB_ICONWARNING, IDOK, REGSTR_LOSSYROTATE);
                                                        
                                                                                                                
                                                        CRegKey Key;
                                                        if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                                                        {
                                                            Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                                                        }

                                                        if (Key.m_hKey != NULL)
                                                        {
                                                            if (nResult == IDOK) // If hidden, then load last result from registry
                                                            {
                                                                DWORD dwResult = 0;
                                                                Key.QueryValue(dwResult, REGSTR_LOSSYROTATE);
                                                                nResult = (int)dwResult;
                                                            }
                                                            else // Otherwise, write this as last result to registry
                                                            {
                                                                DWORD dwResult = (DWORD)nResult;
                                                                Key.SetValue(dwResult, REGSTR_LOSSYROTATE);
                                                            }
                                                        }

                                                        if (nResult == IDNO)                
                                                            hr = S_FALSE; // User said No, Don't make any other noise.

                                                        if (cItems > 1)
                                                        {
                                                            LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                                                            ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                                        }
                                                    }
                                                }

                                                if (hr == S_OK)
                                                {
                                                    CAnnotationSet Annotations;
                                                    Annotations.SetImageData(pid);

                                                    INT_PTR nCount = Annotations.GetCount();
                                                    for (INT_PTR ix = 0; ix < nCount; ix++)
                                                    {
                                                        CAnnotation* pAnnotation = Annotations.GetAnnotation(ix);
                                                        pAnnotation->Rotate(sz.cy, sz.cx, (_iAngle == 90));
                                                    }
                                                    Annotations.CommitAnnotations(pid);

                                                    hr = pid->Rotate(_iAngle);
                                                    if (SUCCEEDED(hr))
                                                    {
                                                        IPersistFile *ppf;
                                                        hr = pid->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
                                                        if (SUCCEEDED(hr))
                                                        {
                                                            hr = ppf->Save(NULL, TRUE);
                                                            ppf->Release();
                                                        }
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                // Animated GIFs are not editable even though
                                                // normal GIFs are.  This can cause a lot of
                                                // confusion, so provide some feedback if the
                                                // user tries to rotate an animated image.
                                                if (S_OK == pid->IsAnimated())
                                                {
                                                    // Make some noise.
                                                    ShellMessageBox(_Module.GetModuleInstance(), NULL, MAKEINTRESOURCE(IDS_ROTATE_MESSAGE), MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szFile);

                                                    // Don't make any other noise.
                                                    hr = S_FALSE;
                                                }// we can't safely rotate images with > 8 bits per channel either; we'd lose the extra bits
                                                else if (S_OK != pid->IsEditable())
                                                {
                                                    TCHAR szMsg[MAX_PATH];
                                                    // silently fail if the string isn't available
                                                    if (LoadSPString(IDS_SHIMGVW_ROTATE_MESSAGE_EXT, szMsg, ARRAYSIZE(szMsg)))
                                                    {
                                                        ShellMessageBox(_Module.GetModuleInstance(), NULL, szMsg, MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szFile);
                                                    }
                                                    // Don't make any other noise.
                                                    hr = S_FALSE;
                                                }                                                
                                            }
                                        }
                                    }
                                }

                                pid->Release();
                            }
                            if (FAILED(hr))
                            {
                                if (cItems > 1)
                                {
                                    LoadString(_Module.GetModuleInstance(), IDS_ROTATEDLGTITLE, szBuffer, ARRAYSIZE(szBuffer));
                                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                }

                                ShellMessageBox(_Module.GetModuleInstance(), NULL, MAKEINTRESOURCE(IDS_ROTATE_ERROR), MAKEINTRESOURCE(IDS_ROTATE_CAPTION), MB_OK|MB_ICONERROR);

                                if (cItems > 1)
                                {
                                    LoadString(_Module.GetModuleInstance(), IDS_ROTATETITLE, szBuffer, ARRAYSIZE(szBuffer));
                                    ppd->SetLine(1, T2W(szBuffer), FALSE, NULL);
                                }
                            }
                        }
                    }
                    pif->Release();
                }

                if (cItems > 1)
                {
                    ppd->StopProgressDialog();
                }
                // Since we always create it, we must always Release it.
                ppd->Release();
            }
            ReleaseStgMedium(&medium);
        }
    }

    return 0;
}

void CPhotoVerbs::_RotatePictures(int iAngle, UINT idPrompt)
{
    if (_pict)
    {
        _pict->Rotate(iAngle);
    }
    else if (_pdtobj)
    {
        HRESULT hr;
        CRotateThreadProc *potd = new CRotateThreadProc(_pdtobj, iAngle, idPrompt, &hr);
        if (potd)
        {
            if (SUCCEEDED(hr))
            {
                potd->CreateVerbThread();
            }
            potd->Release();
        }
    }
}


DWORD CALLBACK _WallpaperThreadProc(void *pv)
{
    IStream *pstm = (IStream*)pv;
    IDataObject *pdtobj;
    HRESULT hr = CoGetInterfaceAndReleaseStream(pstm, IID_PPV_ARG(IDataObject, &pdtobj));
    if (SUCCEEDED(hr))
    {
        FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};

        hr = pdtobj->GetData(&fmt, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            HDROP hd = (HDROP)medium.hGlobal;

            if (DragQueryFile(hd, 0, szPath, ARRAYSIZE(szPath))) // only set the first one selected as the background
            {
                SetWallpaperHelper(szPath);
            }

            ReleaseStgMedium(&medium);
        }
        pdtobj->Release();
    }
    return 0;
}

void CPhotoVerbs::_SetWallpaper()
{
    if (_pdtobj)
    {
        IStream *pstm;
        if (FAILED(CoMarshalInterThreadInterfaceInStream(IID_IDataObject, _pdtobj, &pstm)) ||
            !SHCreateThread(_WallpaperThreadProc, pstm, CTF_COINIT, NULL))
        {
            ATOMICRELEASE(pstm);
        }
    }
}

HRESULT _InvokePrintToInPPW(LPCMINVOKECOMMANDINFO pCMI,IDataObject * pdtobj)
{
    HRESULT hr = E_FAIL;
    HMODULE hDll = LoadLibrary( TEXT("photowiz.dll") );
    if (hDll)
    {
        LPFNPPWPRINTTO pfnPrintTo = (LPFNPPWPRINTTO)GetProcAddress( hDll, PHOTO_PRINT_WIZARD_PRINTTO_ENTRY );
        if (pfnPrintTo)
        {
            hr = pfnPrintTo( pCMI, pdtobj );
        }

        FreeLibrary( hDll );
    }

    return hr;
}

const struct
{
    LPCSTR pszVerb;
    int idVerb;
}
c_szVerbs[] =
{
    { "preview", OFFSET_OPEN},
    { "printto", OFFSET_PRINTTO},
    { "rotate90", OFFSET_ROT90},
    { "rotate270", OFFSET_ROT270},
};

HRESULT CPhotoVerbs::_MapVerb(LPCMINVOKECOMMANDINFO pici, int *pidVerb)
{
    HRESULT hr = S_OK;
    if (IS_INTRESOURCE(pici->lpVerb))
    {
        *pidVerb = LOWORD(pici->lpVerb);
    }
    else
    {
        hr = E_INVALIDARG;
        for (int i = 0; i < ARRAYSIZE(c_szVerbs); i++)
        {
            if (0 == lstrcmpiA(pici->lpVerb, c_szVerbs[i].pszVerb))
            {
                hr = S_OK;
                *pidVerb = c_szVerbs[i].idVerb;
                break;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPhotoVerbs::InvokeCommand(LPCMINVOKECOMMANDINFO pCMI)
{
    int idVerb;
    HRESULT hr = _MapVerb(pCMI, &idVerb);
    if (SUCCEEDED(hr))
    {
        switch (idVerb)
        {
        case OFFSET_OPEN:
            if (_fAcceptPreview)
                _OpenPictures();
            else
                hr = E_FAIL;
            break;

        case OFFSET_PRINTTO:
            hr = _InvokePrintToInPPW(pCMI,_pdtobj);
            break;

        case OFFSET_ROT90:
            _RotatePictures(90, IDS_ROTATE90);
            break;

        case OFFSET_ROT270:
            _RotatePictures(270, IDS_ROTATE270);
            break;

        case OFFSET_ZOOMIN:
            if (_pict)
            {
                _pict->ZoomIn();
            }
            break;

        case OFFSET_ZOOMOUT:
            if (_pict)
            {
                _pict->ZoomOut();
            }
            break;

        case OFFSET_ACTUALSIZE:
            if (_pict)
            {
                _pict->ActualSize();
            }
            break;

        case OFFSET_BESTFIT:
            if (_pict)
            {
                _pict->BestFit();
            }
            break;

        case OFFSET_NEXTPAGE:
            if (_pict)
            {
                _pict->NextPage();
            }
            break;

        case OFFSET_PREVPAGE:
            if (_pict)
            {
                _pict->PreviousPage();
            }
            break;

        case OFFSET_SETWALL:
            _SetWallpaper();
            break;

       default:
            hr = E_INVALIDARG;
            break;
        }
    }

    return hr;
}

STDMETHODIMP CPhotoVerbs::GetCommandString(UINT_PTR uID, UINT uFlags, UINT *res, LPSTR pName, UINT cchMax)
{
    HRESULT hr = S_OK;
    UINT idSel = (UINT)uID;

    switch (uFlags)
    {
    case GCS_VERBW:
    case GCS_VERBA:
        if (idSel < ARRAYSIZE(c_szVerbs))
        {
            if (uFlags == GCS_VERBW)
            {
                SHAnsiToUnicode(c_szVerbs[idSel].pszVerb, (LPWSTR)pName, cchMax);
            }
            else
            {
                StrCpyNA(pName, c_szVerbs[idSel].pszVerb, cchMax);
            }
        }
        break;

    case GCS_HELPTEXTW:
        LoadStringW(_Module.GetResourceInstance(), idSel+IDH_HELP_FIRST, (LPWSTR)pName, cchMax);
        break;

    case GCS_HELPTEXTA:
        LoadStringA(_Module.GetResourceInstance(), idSel+IDH_HELP_FIRST, (LPSTR)pName, cchMax);
        break;

    case GCS_VALIDATEA:
    case GCS_VALIDATEW:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


void WINAPI ImageView_Fullscreen(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    HRESULT hr = SHCoInitialize();  // suppress OLE1 DDE window
    if (SUCCEEDED(hr))
    {
        OleInitialize(NULL);    // needed to get drag and drop to work

        IDataObject *pdtobj;
        hr = GetUIObjectFromPath(pszCmdLine, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            // this scope is required to make sure cwndPreview gets destroyed before we call SHCoUninitialize  
            // the preview wnd will init GDI+ too
            CPreviewWnd cwndPreview;
            if (!cwndPreview.TryWindowReuse(pszCmdLine))
            {               
                if (SUCCEEDED(cwndPreview.Initialize(NULL, WINDOW_MODE, FALSE)) && cwndPreview.CreateViewerWindow())
                {
                    cwndPreview.PreviewItemsFromUnk(pdtobj);

                    MSG msg;
                    while (GetMessage(&msg, NULL, 0, 0))
                    {
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            pdtobj->Release();
        }

        OleUninitialize();
    }

    SHCoUninitialize(hr);
}

void WINAPI ImageView_FullscreenA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[MAX_PATH*2];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    ImageView_Fullscreen(hwnd, hAppInstance, szCmdLine, nCmdShow);
}

void WINAPI ImageView_FullscreenW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_Fullscreen(hwnd, hAppInstance, pszCmdLine, nCmdShow);
}

// To work around ACDSEE lower cases the shell command stuff causing us to need this
// export an all lowercase version of this function.  The short is, case matters for RunDLL32 exports.
void WINAPI imageview_fullscreenW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_FullscreenW(hwnd, hAppInstance, pszCmdLine, nCmdShow);
}

LPTSTR ParseCmdLine( LPTSTR pInput, LPTSTR pOutput, BOOL bStripQuotes )
{
    // copies the next token on the line to pOutput and returns
    // the first white space character after the processed token

    if (!pInput || (!*pInput) || !pOutput)
    {
        return pInput;
    }

    // first, skip any leading whitespace
    while (*pInput == TEXT(' '))
    {
        pInput++;
    }

    if (!(*pInput))
    {
        return pInput;
    }

    // next, start copying token

    // if the token starts with a
    // quote, note that and copy it
    BOOL bStartedWithQuote = FALSE;
    if (*pInput == TEXT('\"'))
    {
        bStartedWithQuote = TRUE;
        if (bStripQuotes)
        {
            pInput++;
        }
        else
        {
            *pOutput++ = *pInput++;
        }
    }

    // figure out what to stop on
    TCHAR cStopChar;
    if (bStartedWithQuote)
    {
        cStopChar = TEXT('\"');
    }
    else
    {
        cStopChar = TEXT(' ');
    }

    // copy up to the delimeter
    while( *pInput && (*pInput != cStopChar))
    {
        *pOutput++ = *pInput++;
    }

    // if the delimeter was a quote
    // we need to copy it into the output
    if (bStartedWithQuote && (*pInput == TEXT('\"')))
    {
        if (bStripQuotes)
        {
            pInput++;
        }
        else
        {
            *pOutput++ = *pInput++;
        }
    }

    *pOutput = 0;

    return pInput;

}


void WINAPI ImageView_PrintTo(HWND hwnd, HINSTANCE hAppInstance, LPTSTR pszCmdLine, int nCmdShow)
{
    // The command line comes to us like this (everything inside the <>):
    // </pt filename printer_name>

    TCHAR szFileName[ 1024 ];
    TCHAR szPrinterName[ 1024 ];

    LPTSTR psz = pszCmdLine;
    if (*psz == TEXT('/'))
    {
        // skip the "/pt"
        psz = ParseCmdLine( psz, szFileName, TRUE );
    }

    // Get the filename
    psz = ParseCmdLine( psz, szFileName, TRUE );

    // Get the printer name
    psz = ParseCmdLine( psz, szPrinterName, TRUE );


    // create a dataobject for the file in question, and then call
    // into photowiz to print it out...

    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        IDataObject *pdtobj;
        HRESULT hr = GetUIObjectFromPath(szFileName, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            // Create CMINVOKECAMMANDINFO to pass to photowiz
            CMINVOKECOMMANDINFOEX cmi = {0};
            cmi.cbSize = sizeof(cmi);
            cmi.fMask         = CMIC_MASK_UNICODE;
            cmi.lpVerbW       = L"printto";
            cmi.lpParametersW = szPrinterName;

            hr = _InvokePrintToInPPW((LPCMINVOKECOMMANDINFO )&cmi, pdtobj);
            pdtobj->Release();
        }
    }
    SHCoUninitialize(hrInit);
}

void WINAPI ImageView_PrintToA(HWND hwnd, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    TCHAR szCmdLine[1024];
    SHAnsiToTChar(pszCmdLine, szCmdLine, ARRAYSIZE(szCmdLine));
    ImageView_PrintTo(hwnd, hAppInstance, szCmdLine, nCmdShow);
}

void WINAPI ImageView_PrintToW(HWND hwnd, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    ImageView_PrintTo( hwnd, hAppInstance, pszCmdLine, nCmdShow );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\prevctrl.cpp ===
#include "precomp.h"
#include <shimgvw.h>
#include "PrevCtrl.h"
#include "autosecurity.h"
#include <dispex.h>
#pragma hdrstop

LRESULT CPreview::OnCreate(UINT , WPARAM , LPARAM , BOOL&)
{
    ATLTRACE(_T("CPreview::OnCreate\n"));

    // Create the preview window
    RECT rcWnd;
    GetClientRect(&rcWnd);
    if (m_cwndPreview.Create(m_hWnd, rcWnd, NULL, WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, 0))
    {
        m_cwndPreview.SetNotify(this);

        HPALETTE hpal;
        if (SUCCEEDED(GetAmbientPalette(hpal)))
            m_cwndPreview.SetPalette(hpal);

        return 0;
    }

    return -1;
}

LRESULT CPreview::OnActivate(UINT , WPARAM , LPARAM , BOOL& bHandled)
{
    ATLTRACE(_T("CPreview::OnActivate\n"));
    m_cwndPreview.SetFocus();
    bHandled = false;
    return 0;
}

HRESULT CPreview::OnDrawAdvanced(ATL_DRAWINFO&)
{
    ATLTRACE(_T("CPreview::OnDrawAdvanced\n"));
    return S_OK;
}

LRESULT CPreview::OnEraseBkgnd(UINT , WPARAM , LPARAM , BOOL&)
{
    ATLTRACE(_T("CPreview::OnEraseBkgnd\n"));
    return TRUE;
}

LRESULT CPreview::OnSize(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    ATLTRACE(_T("CPreview::OnSize\n"));
    ::SetWindowPos(m_cwndPreview.m_hWnd, NULL, 0,0,
        LOWORD(lParam), HIWORD(lParam), SWP_NOZORDER | SWP_NOACTIVATE);
    return 0;
}

// IObjectSafety::GetInterfaceSafetyOptions
//
// This method never gets called.  We are safe for any and every thing.  There should
// be no possible way that this control could lose, destroy, or expose data.
STDMETHODIMP CPreview::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions,
                                                  DWORD *pdwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
    HRESULT hr;
    hr = IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>::GetInterfaceSafetyOptions(riid, pdwSupportedOptions, pdwEnabledOptions);
    if (SUCCEEDED(hr))
    {
        IsHostLocalZone(CAS_REG_VALIDATION, &hr);
    }
    return hr;
}

STDMETHODIMP CPreview::SetInterfaceSafetyOptions(REFIID riid, DWORD dwSupportedOptions,
                                                  DWORD dwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::SetInterfaceSafetyOptions\n"));
    HRESULT hr;
    hr = IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>::SetInterfaceSafetyOptions(riid, dwSupportedOptions, dwEnabledOptions);
    if (SUCCEEDED(hr))
    {
        IsHostLocalZone(CAS_REG_VALIDATION, &hr);
    }
    return hr;
}

// IPersistPropertyBag::Load
//
// We have the following properties that we can load from the property bag:
//      Toolbar         false/zero = don't show the toolbar, otherwise show the toolbar
//      Full Screen     false/zero = don't show fullscreen button on toolbar, otherwise show the button
//      Context Menu    false/zero = don't show context menu, otherwise show the context menu when the user right clicks
//      Print Button    false/zero = don't show print button on toolbar, otherwise show the button
STDMETHODIMP CPreview::Load(IPropertyBag * pPropBag, IErrorLog * pErrorLog)
{
    HRESULT hr;
    VARIANT var;
    BOOL bDummy = TRUE;

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Toolbar", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_TOOLBAR,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Full Screen", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_FULLSCREENBTN,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Print Button", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_PRINTBTN,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = TRUE;
    hr = pPropBag->Read(L"Context Menu", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_CONTEXTMENU,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = FALSE;
    hr = pPropBag->Read(L"Allow Online", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_ALLOWGOONLINE,var.ulVal,bDummy);
    }

    var.vt = VT_UI4;
    var.ulVal = FALSE;
    hr = pPropBag->Read(L"Disable Edit", &var, NULL);
    if (SUCCEEDED(hr) && var.vt==VT_UI4)
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_DISABLEEDIT,var.ulVal,bDummy);
    }

    return S_OK;
}

// If we are initialized via IStream, read a DWORD from the stream that is a mask
// for which toolbar buttons to show

STDMETHODIMP CPreview::Load(IStream *pStream)
{
    DWORD dwFlags = 0;
    ULONG ulRead = 0;
    BOOL bDummy = TRUE;
    if (SUCCEEDED(pStream->Read(&dwFlags, sizeof(dwFlags), &ulRead)) && ulRead == sizeof(dwFlags))
    {
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_TOOLBAR,dwFlags & PVTB_TOOLBAR, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_FULLSCREENBTN,dwFlags & PVTB_HIDEFULLSCREEN, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_PRINTBTN,dwFlags & PVTB_HIDEPRINTBTN, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_CONTEXTMENU,dwFlags & PVTB_CONTEXTMENU, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_ALLOWGOONLINE,dwFlags & PVTB_ALLOWONLINE, bDummy);
        m_cwndPreview.IV_OnSetOptions(IV_SETOPTIONS,IVO_DISABLEEDIT,dwFlags & PVTB_DISABLEEDIT, bDummy);
    }
    return S_OK;

}

// IPreview Methods:
STDMETHODIMP CPreview::ShowFile(BSTR bstrFileName)
{
    m_cwndPreview.ShowFile(bstrFileName, 1);
    return S_OK;
}

STDMETHODIMP CPreview::ShowFile(BSTR bstrFileName, int iSelectCount)
{
    m_cwndPreview.ShowFile(bstrFileName, iSelectCount);
    return S_OK;
}

STDMETHODIMP CPreview::Show(VARIANT var)
{
    HRESULT hr;
    switch (var.vt)
    {
    case VT_UNKNOWN:
    case VT_DISPATCH:
        // QI for Folder Item
        if (var.punkVal)
        {
            FolderItems *pfis;
            FolderItem *pfi;
            hr = var.punkVal->QueryInterface(IID_PPV_ARG(FolderItem, &pfi));
            if (SUCCEEDED(hr))
            {
                // If the item is a link we want to get the link's target:
                VARIANT_BOOL vbool;
                hr = pfi->get_IsLink(&vbool);
                if (SUCCEEDED(hr) && (VARIANT_FALSE != vbool))    // IsLink returns TRUE, not VARIANT_TRUE
                {
                    IDispatch *pdisp;
                    hr = pfi->get_GetLink(&pdisp);
                    if (SUCCEEDED(hr) && pdisp)
                    {
                        IShellLinkDual2 * psl2;
                        hr = pdisp->QueryInterface(IID_PPV_ARG(IShellLinkDual2, &psl2));
                        if (SUCCEEDED(hr) && psl2)
                        {
                            FolderItem * pfiTarg;
                            hr = psl2->get_Target(&pfiTarg);
                            if (SUCCEEDED(hr) && pfiTarg)
                            {
                                pfi->Release();
                                pfi = pfiTarg;
                            }
                            psl2->Release();
                        }
                        pdisp->Release();
                    }
                }

                // Now we need to know the path for this item.  We can only view items if
                // we can get a path or URL to the target so some namespaces aren't viewable.
                BSTR bstr;
                hr = pfi->get_Path(&bstr);
                if (SUCCEEDED(hr))
                {
                    m_cwndPreview.ShowFile(bstr, 1);
                    SysFreeString(bstr);
                    hr = S_OK;
                }
                else
                {
                    // we couldn't get the path so we will display the "No Preview" message
                    m_cwndPreview.ShowFile(NULL, 1);
                    hr = S_FALSE;
                }

                // now release the Folder Item pointer
                pfi->Release();

                return hr;
            }
            else if (SUCCEEDED(var.punkVal->QueryInterface(IID_PPV_ARG(FolderItems, &pfis))))
            {
                // currently in the multi-select case we just show the multi-select message.
                // eventually this should go to slideshow mode
                m_cwndPreview.ShowFile(NULL, 2);
                pfis->Release();
                return S_FALSE;
            }
        }
        // the unknown pointer isn't for an object type that we know about
        return E_INVALIDARG;

    case VT_BSTR:
        m_cwndPreview.ShowFile(var.bstrVal, 1);
        break;

    case VT_BOOL:
        // show(false) will hide the currently previewed item
        if (VARIANT_FALSE == var.boolVal)
        {
            m_cwndPreview.ShowFile(NULL, 0);
            return S_OK;
        }
        else
        {
            return E_INVALIDARG;
        }

    default:
        return E_INVALIDARG;
    }

    return S_OK;
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//  cloned from browseui/util.cpp
//
int IsVK_TABCycler(MSG *pMsg)
{
    if (!pMsg)
        return 0;

    if (pMsg->message != WM_KEYDOWN)
        return 0;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return 0;

#if 0 // todo?
    return (GetAsyncKeyState(VK_SHIFT) < 0) ? -1 : 1;
#endif
    return 1;
}

//***
// NOTES
//  hard-coded 1/2/4 (vs. KEYMOD_*) is same thing atlctl.h does.  go figure...
DWORD GetGrfMods()
{
    DWORD dwMods;

    dwMods = 0;
    if (GetAsyncKeyState(VK_SHIFT) < 0)
        dwMods |= 1;    // KEYMOD_SHIFT
    if (GetAsyncKeyState(VK_CONTROL) < 0)
        dwMods |= 2;    // KEYMOD_CONTROL
    if (GetAsyncKeyState(VK_MENU) < 0)
        dwMods |= 4;    // KEYMOD_MENU
    return dwMods;
}

STDMETHODIMP CPreview::TranslateAccelerator(LPMSG lpmsg)
{
    ATLTRACE(_T("CPreview::TranslateAccelerator\n"));

    if (m_cwndPreview.TranslateAccelerator(lpmsg))
    {
        return S_OK;
    }

    if (IsVK_TABCycler(lpmsg))
    {
        // REVIEW: looks like newer versions of ATL might do this for us so
        // possibly we can replace w/ call to SUPER::TA when we upgrade.
        CComQIPtr <IOleControlSite, &IID_IOleControlSite> spOCS(m_spClientSite);
        if (spOCS) {
            return spOCS->TranslateAccelerator(lpmsg, GetGrfMods());
        }
    }

    return S_FALSE;
}

STDMETHODIMP CPreview::OnFrameWindowActivate(BOOL fActive)
{
    if (fActive)
    {
        m_cwndPreview.SetFocus();
    }
    return S_OK;
}

LRESULT CPreview::OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    ATLTRACE(_T("CPreview::OnSetFocus\n"));
 
    LRESULT ret = CComControl<CPreview>::OnSetFocus(uMsg,wParam,lParam, bHandled);
    m_cwndPreview.SetFocus();
    return ret;
}

STDMETHODIMP CPreview::get_printable(BOOL * pVal)
{
    // If we don't trust the host, we tell them it is always printable because we don't
    // want them to be able to see if the file exists on the disk.  Hackers can use
    // this to determine where the OS is installed and which apps are installed.
    *pVal = TRUE;

    if (IsHostLocalZone(CAS_REG_VALIDATION, NULL))
    {
        *pVal = m_cwndPreview.GetPrintable();
    }

    return S_OK;
}

STDMETHODIMP CPreview::put_printable(BOOL newVal)
{
    return S_FALSE;
}

STDMETHODIMP CPreview::get_cxImage(long * pVal)
{
    // REVIEW: Return an error and set output to zero if no image is currently displayed?
    *pVal = m_cwndPreview.m_ctlPreview.m_cxImage;

    return S_OK;
}

STDMETHODIMP CPreview::get_cyImage(long * pVal)
{
    // REVIEW: Return an error and set output to zero if no image is currently displayed?
    *pVal = m_cwndPreview.m_ctlPreview.m_cyImage;

    return S_OK;
}

STDMETHODIMP CPreview::Zoom(int iDirection)
{
    
    switch (iDirection)
    {
    case -1:
        m_cwndPreview.ZoomOut();
        break;

    case 0:
        return S_OK;

    case 1:
        m_cwndPreview.ZoomIn();
        break;

    default:
        return S_FALSE;
    }

    return S_OK;
}

STDMETHODIMP CPreview::BestFit()
{
    m_cwndPreview.BestFit();
    return S_OK;
}

STDMETHODIMP CPreview::ActualSize()
{
    m_cwndPreview.ActualSize();
    return S_OK;
}

STDMETHODIMP CPreview::SlideShow()
{
    HRESULT hr = m_cwndPreview.StartSlideShow(NULL);
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CPreview::Rotate(DWORD dwAngle)
{
    HRESULT hr = m_cwndPreview.Rotate(dwAngle);
    return SUCCEEDED(hr) ? S_OK : S_FALSE;
}

STDMETHODIMP CPreview::SetClientSite(IOleClientSite *pClientSite)
{
    IOleObjectImpl<CPreview>::SetClientSite(pClientSite);
    m_cwndPreview.SetSite(pClientSite);

    return S_OK;
}

STDMETHODIMP CPreview::SetSite(IUnknown* punkSite)
{
    IObjectWithSiteImpl<CPreview>::SetSite(punkSite);
    m_cwndPreview.SetSite(punkSite);

    if (punkSite)
    {
        if (!_pfv)
        {
            IShellView *psv;
            if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_DefView, IID_PPV_ARG(IShellView, &psv))))
            {
                IDispatch *pdisp;
                if (SUCCEEDED(psv->GetItemObject(SVGIO_BACKGROUND, IID_PPV_ARG(IDispatch, &pdisp))))
                {
                    ConnectToConnectionPoint(SAFECAST(this, IPreview2 *), DIID_DShellFolderViewEvents, TRUE, pdisp, &_dwConnectionCookie, NULL);
                    _ProcessSelection();
                    pdisp->Release();
                }

                psv->QueryInterface(IID_PPV_ARG(IFolderView, &_pfv));   // capture this

                psv->Release();
            }
        }
    }
    else
    {
        ATOMICRELEASE(_pfv);    // break ref cycle
    }
    
    return S_OK;
}

STDMETHODIMP CPreview::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, 
                        VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr)
{
    HRESULT hr = S_OK;

    if (dispidMember == DISPID_FOCUSCHANGED)
    {
        hr = _ProcessSelection();
    }
    else
    {
        hr = CStockPropImpl<CPreview, IPreview2, &IID_IPreview2, &LIBID_PREVIEWLib>::Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }

    return hr;
}

STDMETHODIMP CPreview::SetWallpaper(BSTR bstrPath)
{    
    return m_cwndPreview.SetWallpaper(bstrPath);
}

STDMETHODIMP CPreview::SaveAs(BSTR bstrPath)
{
    return m_cwndPreview.SaveAs(bstrPath);
}

BOOL CPreview::IsHostLocalZone(DWORD dwFlags, HRESULT * phr)
{
    HRESULT hr = E_ACCESSDENIED;
    CComPtr<IDefViewSafety> spDefViewSafety;
    if (SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_SFolderView,
            IID_PPV_ARG(IDefViewSafety, &spDefViewSafety))))
    {
        hr = spDefViewSafety->IsSafePage();
    }

    if (phr)
    {
        *phr = hr;
    }

    return (S_OK == hr) ? TRUE : FALSE;
}

STDMETHODIMP CPreview::_ProcessSelection(void)
{
    if (_pfv)
    {
        int iItem;
        if (S_OK == _pfv->GetFocusedItem(&iItem))
        {
            LPITEMIDLIST pidlFile;
            if (SUCCEEDED(_pfv->Item(iItem, &pidlFile)))
            {
                IShellFolder *psf;
                if (SUCCEEDED(_pfv->GetFolder(IID_PPV_ARG(IShellFolder, &psf))))
                {
                    TCHAR szPath[MAX_PATH];

                    if (SUCCEEDED(DisplayNameOf(psf, pidlFile, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
                    {
                        ShowFile(szPath, 1);
                    }

                    psf->Release();
                }

                ILFree(pidlFile);
            }
        }
        else
        {
            ShowFile(NULL, 0);
        }
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\prevctrl.h ===
// PrevCtrl.h : Declaration of the CPreview

#ifndef __PREVCTRL_H_
#define __PREVCTRL_H_

#include "resource.h"       // main symbols
#include "PrevWnd.h"
#include "Events.h"

int IsVK_TABCycler(MSG *pMsg);

/////////////////////////////////////////////////////////////////////////////
// CPreview
class ATL_NO_VTABLE CPreview :
        public CComObjectRootEx<CComSingleThreadModel>,
        public CComCoClass<CPreview, &CLSID_Preview>,
        public CComControl<CPreview>,
        public CStockPropImpl<CPreview, IPreview2, &IID_IPreview2, &LIBID_PREVIEWLib>,
        public CStockPropImpl<CPreview, IPreview3, &IID_IPreview3, &LIBID_PREVIEWLib>,
        public IProvideClassInfo2Impl<&CLSID_Preview, NULL, &LIBID_PREVIEWLib>,
        public IPersistPropertyBagImpl<CPreview>,           // So we can read <PARAM>'s from our object tag
        public IPersistStorageImpl<CPreview>,               // required for Embeddable objects
        public IOleObjectImpl<CPreview>,                    // required for Embeddable objects
        public IDataObjectImpl<CPreview>,                   // required for Embeddable objects
        public IQuickActivateImpl<CPreview>,
        public IOleControlImpl<CPreview>,   // REVIEW: will IOleControl::GetControlInfo help with my keyboard problems?
        public IOleInPlaceActiveObjectImpl<CPreview>,       // handles resizing, active state, TranslateAccelerator
        public IViewObjectExImpl<CPreview>,                 // for flicker-free drawing support
        public IOleInPlaceObjectWindowlessImpl<CPreview>,   // allow for windowless operation (we don't use windowless, should we be using this interface?)
        public CPreviewEvents<CPreview>,                    // our event code for sending events to our container
        public IConnectionPointContainerImpl<CPreview>,     // Connection Point Container for our outgoing event hooks.
        public IObjectSafetyImpl<CPreview, INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA>,// allows this control to be scripted
        public IPersistStreamInitImpl<CPreview>,
        public IObjectWithSiteImpl<CPreview>
{
private:

    DWORD _dwConnectionCookie;
    IFolderView *_pfv;

public:
    CPreviewWnd m_cwndPreview;

    CPreview()
    {
        // we want to be run in a window and never windowless
        m_bWindowOnly = TRUE;
        m_cwndPreview.Initialize(NULL, CONTROL_MODE, FALSE); // ISSUE: we don't handle failure of initialization in low-memory case
    }

    ~CPreview()
    {
        ATOMICRELEASE(_pfv);
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PREVIEW)

DECLARE_WND_CLASS( TEXT("ShImgVw:CPreview") );

BEGIN_COM_MAP(CPreview)
    COM_INTERFACE_ENTRY(IPreview2)
    COM_INTERFACE_ENTRY(IPreview3)
    COM_INTERFACE_ENTRY_IID(IID_IDispatch, IPreview2)
    COM_INTERFACE_ENTRY_IID(IID_IPreview, IPreview2)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistPropertyBag)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CPreview)
    CONNECTION_POINT_ENTRY(DIID_DPreviewEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CPreview)
    PROP_PAGE(CLSID_StockColorPage)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CPreview)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_ACTIVATE, OnActivate)
END_MSG_MAP()

    // IViewObjectEx
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus)
    {
        ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
        *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
        return S_OK;
    }

    // IOleInPlaceActiveObjectImpl
    STDMETHOD(TranslateAccelerator)( LPMSG lpmsg );
    STDMETHOD(OnFrameWindowActivate)( BOOL fActive );

    // IPersistPropertyBag
    STDMETHOD(Load)(IPropertyBag * pPropBag, IErrorLog * pErrorLog);
    STDMETHOD(Save)(IPropertyBag * pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties) {return S_OK;}

    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwSupportedOptions, DWORD dwEnabledOptions);

    // IPersistStreamInit
    STDMETHOD(Load)(IStream * pStm);
    STDMETHOD(Save)(IStream * pStm, BOOL fClearDirty) {return S_OK;}

    // IOleObject
    STDMETHODIMP SetClientSite(IOleClientSite *pClientSite);

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite);

    // IDispatch
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, 
                        VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

public:
    // Control message handlers
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    HRESULT OnDrawAdvanced(ATL_DRAWINFO& di);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    // IPreview, IPreview3
    STDMETHOD(get_printable)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_printable)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_cxImage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(get_cyImage)(/*[out, retval]*/ long *pVal);
    STDMETHOD(ShowFile)(BSTR bstrFileName, int iSelectCount);
    STDMETHOD(Show)(VARIANT var);

    // IPreview2, IPreview3
    STDMETHOD(Zoom)(/*[in]*/ int iSelectCount);
    STDMETHOD(BestFit)();
    STDMETHOD(ActualSize)();
    STDMETHOD(SlideShow)();

    // IPreview3
    STDMETHOD(Rotate)(/*[in]*/ DWORD dwAngle);
    STDMETHOD(SaveAs)(/*[in]*/BSTR bstrPath);
    STDMETHOD(SetWallpaper)(/*[in]*/BSTR bstrWallpaper);
    STDMETHOD(ShowFile)(BSTR bstrFileName);

private:
    BOOL IsHostLocalZone(DWORD dwFlags, HRESULT *phr);
    STDMETHOD(_ProcessSelection) (void);
};

#endif //__PREVCTRL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\prevwnd.h ===
#ifndef __PREVIEWWND_H_
#define __PREVIEWWND_H_

#include "resource.h"       // main symbols
#include "annotlib.h"
#include "tasks.h"
#include "ZoomWnd.h"
#include "SelTrack.h"
#include "Events.h"


// forward declaration
class CPreview;

#define NEWTOOLBAR_TOPMARGIN        8
#define NEWTOOLBAR_BOTTOMMARGIN     8
#define NEWTOOLBAR_BOTTOMMARGIN_CTRLMODE    12

#define TIMER_ANIMATION        42
#define TIMER_SLIDESHOW        43
#define TIMER_TOOLBAR          44
#define TIMER_DATAOBJECT       45
#define TIMER_BUSYCURSOR       46
#define TIMER_RESETSCREENSAVER 47

#define DEFAULT_SHIMGVW_TIMEOUT  5000 // five seconds


// IV_SCROLL message parameters
#define IVS_LEFT        (SB_LEFT)
#define IVS_RIGHT       (SB_RIGHT)
#define IVS_LINELEFT    (SB_LINELEFT)
#define IVS_LINERIGHT   (SB_LINERIGHT)
#define IVS_PAGELEFT    (SB_PAGELEFT)
#define IVS_PAGERIGHT   (SB_PAGERIGHT)
#define IVS_UP          (SB_LEFT<<16)
#define IVS_DOWN        (SB_RIGHT<<16)
#define IVS_LINEUP      (SB_LINELEFT<<16)
#define IVS_LINEDOWN    (SB_LINERIGHT<<16)
#define IVS_PAGEUP      (SB_PAGELEFT<<16)
#define IVS_PAGEDOWN    (SB_PAGERIGHT<<16)

// IV_ZOOM messages
#define IVZ_CENTER  0
#define IVZ_POINT   1
#define IVZ_RECT    2
#define IVZ_ZOOMIN  0x00000000
#define IVZ_ZOOMOUT 0x00010000

// IV_SETOPTIONS and IV_GETOPTIONS messages
#define IVO_TOOLBAR         0
#define IVO_PRINTBTN        1
#define IVO_FULLSCREENBTN   2
#define IVO_CONTEXTMENU     3
#define IVO_PRINTABLE       4
#define IVO_ALLOWGOONLINE   5
#define IVO_DISABLEEDIT     6

// three modes of preview control
#define CONTROL_MODE        0       // embedded in an activeX control
#define WINDOW_MODE         1       // regular window app window
#define SLIDESHOW_MODE      2       // full screen, no menu/title/hides tray

// priority levels for the various tasks
#define PRIORITY_PRIMARYDECODE  0x40000000
#define PRIORITY_FRAMECACHE     0x30000000
#define PRIORITY_LOOKAHEADCACHE 0x20000000
#define PRIORITY_SLIDESHOWENUM  0x10000000

// these values determine which buttons are hidden, enabled, or disabled based on multi-page state
#define MPCMD_HIDDEN        0
#define MPCMD_FIRSTPAGE     1
#define MPCMD_MIDDLEPAGE    2
#define MPCMD_LASTPAGE      3
#define MPCMD_DISABLED      4

#define GTIDFM_DECODE       0
#define GTIDFM_DRAW         1

void GetTaskIDFromMode(DWORD dwTask, DWORD dwMode, TASKOWNERID *ptoid);

enum EViewerToolbarButtons;

class CPreviewWnd : public INamespaceWalkCB, public IDropTarget, public CWindowImpl<CPreviewWnd>,
                    public IServiceProvider, public IImgCmdTarget
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // INamespaceWalkCB
    STDMETHODIMP FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHOD(InitializeProgressDialog)(LPWSTR *ppszTitle, LPWSTR *ppszCancel)
        { *ppszTitle = NULL; *ppszCancel = NULL; return E_NOTIMPL; }

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

    // IImgCmdTarget
    STDMETHODIMP GetMode(DWORD * pdw);
    STDMETHODIMP GetPageFlags(DWORD * pdw);
    STDMETHODIMP ZoomIn();
    STDMETHODIMP ZoomOut();
    STDMETHODIMP ActualSize();
    STDMETHODIMP BestFit();
    STDMETHODIMP Rotate(DWORD dwAngle);
    STDMETHODIMP NextPage();
    STDMETHODIMP PreviousPage();

    
    CGraphicsInit    m_cgi;  // we call gdi+ directly -- make sure GDI+ is ready for us 
    CContainedWindow m_ctlToolbar;
    CZoomWnd         m_ctlPreview;
    CContainedWindow m_ctlEdit;

    CPreviewWnd *m_pcwndSlideShow;

    CPreviewWnd();
    ~CPreviewWnd();

    HRESULT Initialize(CPreviewWnd* pother, DWORD dwMode, BOOL bExitApp);

    BOOL TryWindowReuse(IDataObject *pdtobj);
    BOOL TryWindowReuse(LPCTSTR pszFilename);

    void OpenFile(HWND hwnd, LPCTSTR pszFile);
    void OpenFileList(HWND hwnd, IDataObject *pdtobj);

    LRESULT ShowFile(LPCTSTR pszFile, UINT cItems, BOOL fReshow = false);
    HRESULT WalkItemsToPreview(IUnknown* punk);
    void PreviewItems();
    HRESULT PreviewItemsFromUnk(IUnknown *punk);

    BOOL CreateViewerWindow();
    BOOL CreateSlideshowWindow(UINT cWalkDepth);
    void SetNotify(CEvents * pEvents);
    void SetPalette(HPALETTE hpal);
    BOOL GetPrintable();
    int  TranslateAccelerator(LPMSG lpmsg);
    HRESULT SetSite(IUnknown *punk);
    HRESULT SaveAs(BSTR bstrPath);
    IUnknown *GetSite() {return m_punkSite;};
    HRESULT SetWallpaper(BSTR bstrPath);
    HRESULT StartSlideShow(IUnknown *punk);
    void StatusUpdate(int iStatus);   // used to set m_ctlPreview.m_iStrID to display correct status message
    void SetCaptionInfo(LPCTSTR szPath);

    // The following functions are called from the ZoomWnd
    BOOL OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL OnSetColor(HDC hdc);
    BOOL GetColor(COLORREF * pref);
    void OnDraw(HDC hdc); // called after the Zoomwnd has painted but before calling EndPaint
    void OnDrawComplete();

    DECLARE_WND_CLASS(TEXT("ShImgVw:CPreviewWnd"));

        
BEGIN_MSG_MAP(CPreviewWnd)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_CLOSE, OnClose)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_APPCOMMAND, OnAppCommand)
    MESSAGE_HANDLER(WM_MEASUREITEM, OnMenuMessage);
    MESSAGE_HANDLER(WM_DRAWITEM, OnMenuMessage);
    MESSAGE_HANDLER(WM_INITMENUPOPUP, OnMenuMessage);
    COMMAND_RANGE_HANDLER(ID_FIRSTTOOLBARCMD, ID_LASTTOOLBARCMD, OnToolbarCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTEDITCMD, ID_LASTEDITCMD, OnEditCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTPOSITIONCMD, ID_LASTPOSITIONCMD, OnPositionCommand)
    COMMAND_RANGE_HANDLER(ID_FIRSTSLIDESHOWCMD, ID_LASTSLIDESHOWCMD, OnSlideshowCommand)
    NOTIFY_CODE_HANDLER(TTN_NEEDTEXT, OnNeedText)
    NOTIFY_CODE_HANDLER(TBN_DROPDOWN, OnDropDown)
    MESSAGE_HANDLER(WM_MOUSEWHEEL, OnWheelTurn)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(IV_SETIMAGEDATA, IV_OnSetImageData)
    MESSAGE_HANDLER(IV_SCROLL, IV_OnIVScroll)
    MESSAGE_HANDLER(IV_SETOPTIONS, IV_OnSetOptions)
    MESSAGE_HANDLER(WM_COPYDATA, OnCopyData)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyEvent)
    MESSAGE_HANDLER(WM_CHAR, OnKeyEvent)
    MESSAGE_HANDLER(WM_ENTERMENULOOP, OnKeyEvent)
    MESSAGE_HANDLER(WM_PRINTCLIENT, OnPrintClient)
    MESSAGE_HANDLER(IV_ONCHANGENOTIFY, OnChangeNotify)
    MESSAGE_HANDLER(WM_SYSCOMMAND, OnSysCommand)
    MESSAGE_HANDLER(IV_ISAVAILABLE, OnIsAvailable)
ALT_MSG_MAP(1)
    // messages for the toolbar
    MESSAGE_HANDLER(WM_KEYDOWN, OnTBKeyEvent)
    MESSAGE_HANDLER(WM_KEYUP, OnTBKeyEvent)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnTBMouseMove)
    MESSAGE_HANDLER(WM_MOUSELEAVE, OnTBMouseLeave)
ALT_MSG_MAP(2)
    MESSAGE_HANDLER(WM_KEYDOWN, OnEditKeyEvent)
END_MSG_MAP()

    LRESULT IV_OnSetOptions(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

protected:
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnNeedText(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnDropDown(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnToolbarCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnEditCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPositionCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSlideshowCommand(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMenuMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCopyData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnChangeNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnIsAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    BOOL OnNonSlideShowTab();

    // Image generation message handlers and functions
    LRESULT IV_OnSetImageData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnShowFileMsg(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT IV_OnIVScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Toolbar message handlers (both toolbars)
    LRESULT OnPrintClient(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnTBMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // Edit control message handlers
    LRESULT OnEditKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    // DropDown handlers for the various dropdown buttons
    VOID _DropDownPageList(LPNMTOOLBAR pnmTB);

    BOOL         CreateToolbar();
    BOOL         _CreateViewerToolbar();
    void        _InitializeViewerToolbarButtons(HWND hwndToolbar, const TBBUTTON c_tbbuttons[], size_t c_nButtons, TBBUTTON tbbuttons[], size_t nButtons);
    inline UINT _IndexOfViewerToolbarButton(EViewerToolbarButtons eButton);
    BOOL        _CreateSlideshowToolbar();
    void        _InitializeToolbar(HWND hwndTB, int idLow, int idLowHot, int idHigh, int idHighHot);
    void        _UpdatePageNumber();
    void        _SetMultipageCommands();
    void        _SetMultiImagesCommands();
    void        _SetEditCommands();
    void        _ResetScreensaver();

    HRESULT _SaveAsCmd();
    void _PropertiesCmd();
    void _OpenCmd();
    BOOL _ReShowingSameFile(LPCTSTR pszFile);
    BOOL _VerbExists(LPCTSTR pszVerb);
    HRESULT _InvokeVerb(LPCTSTR pszVerb, LPCTSTR pszParameters=NULL);
    void _InvokePrintWizard();
//    void _InvokeVerbOnPidlArray(LPCSTR pszVerb);
    // Shared functions for Annotation and Cropping
    void _RefreshSelection(BOOL fDeselect = false);
    void _UpdateButtons(WORD wID);

    // Annotation Functions
    BOOL _CanAnnotate(CDecodeTask * pImageData);
    void _SetAnnotatingCommands(BOOL fEnableAnnotations);
    void _SetupAnnotatingTracker(CSelectionTracker& tracker, BOOL bEditing=FALSE);
    void _UpdateAnnotatingSelection(BOOL fDeselect = false);
    void _RemoveAnnotatingSelection();
    BOOL _OnMouseDownForAnnotating(UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnMouseDownForAnnotatingHelper(CPoint ptMouse, CRect rectImage);
    void _CreateAnnotation(CRect rect);
    void _CreateFreeHandAnnotation(CPoint ptMouse);
    void _StartEditing(BOOL bUpdateText = TRUE);
    void _HideEditing();
    void _StopEditing();
    static BOOL_PTR CALLBACK _AnnoPropsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

    //Cropping Functions
    BOOL _CanCrop(CDecodeTask * pImageData);
    void _SetCroppingCommands(BOOL fEnableCropping);
    void _SetupCroppingTracker(CSelectionTracker& tracker);
    void _UpdateCroppingSelection();
    BOOL _OnMouseDownForCropping(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // Other functions
    void _SetNewImage(CDecodeTask * pImageData);
    void _UpdateImage();

    // Private methods to create the webviewer
    HRESULT _CreateWebViewer();
    BOOL _IsThumbnail(LPCTSTR pszPath);
    HRESULT _CopyImages(IStorage* pstgSrc, IStorage* pstgDest, UINT cItems, HDPA hdpaItems);
    HRESULT _CopyImages_SetupProgress(IProgressDialog** ppProgress, LPWSTR pwszBanner);
    HRESULT _CopyThumbnails(LPITEMIDLIST pidlDest, UINT cItems, HDPA hdpaItems, BOOL* fThumbWritten);
    HRESULT _WriteThumbs(IStream* pstrm, UINT uiTemplateResource, UINT cItems, HDPA hdpaItems);

    LPSTR   _GetImageList(UINT cItems, HDPA hdpaItems, BOOL fAddSuffix);
    HRESULT _GetSelectedImages(HDPA* phdpaItems);
    HRESULT _FormatHTML(UINT cItems, HDPA hdpaItems, LPSTR pszTemplate, DWORD cbTemplateSize, LPSTR psz1, LPSTR psz2, UINT ui1, LPSTR* ppszOut);
    HRESULT _FormatHTMLNet(UINT cItems, HDPA hdpaItems, LPSTR pszTemplate, DWORD cbTemplateSize, LPSTR psz1, UINT ui1, LPSTR* ppszOut);
    HRESULT _WriteHTML(IStorage* pStgDest, UINT cItems, HDPA hdpaItems);
    DWORD   _GetFilterStringForSave(LPTSTR szFilter, size_t cbFilter, LPTSTR szExt);
    HRESULT _SaveIfDirty(BOOL fCanCancel = false);
    HRESULT _PreviewFromStream(IStream * pSteam, UINT iItem, BOOL fUpdateCaption);
    HRESULT _PreviewFromFile(LPCTSTR pszFilename, UINT iItem, BOOL fUpdateCaption);
    void    FlushBitmapMessages();
    HRESULT _ShowNextSlide(BOOL bGoBack);
    HRESULT _StartDecode(UINT iIndex, BOOL fUpdateCaption);
    HRESULT _PreLoadItem(UINT iIndex);
    HRESULT _PreviewItem(UINT iIndex);
    BOOL    _TrySetImage();
    void    _RemoveFromArray(UINT iItem);
    HRESULT _DeleteCurrentSlide();
    BOOL    _CloseSlideshowWindow();

    void SetCursorState(DWORD dwType);
    void ShowSSToolbar(BOOL bShow, BOOL bForce = FALSE);
    void TogglePlayState();
    void _ClearDPA();
    HRESULT _GetItem(UINT iItem, LPITEMIDLIST *ppidl);
    HRESULT GetCurrentIDList(LPITEMIDLIST *ppidl); // gets the dynamically generated title for this window
    HRESULT PathFromImageData(LPTSTR pszFile, UINT cch);
    HRESULT ImageDataSave(LPCTSTR pszFile, BOOL bShowUI);
    void MenuPoint(LPARAM lParam, int *px, int *py);
    BOOL _IsImageFile(LPCTSTR pszFileName);
    BOOL _BuildDecoderList();
    HRESULT _PrevNextPage(BOOL fForward);
    Image *_BurnAnnotations(IShellImageData *pSID);
    void _RegisterForChangeNotify(BOOL fRegister);
    BOOL _ShouldDisplayAnimations();

    BOOL m_fHidePrintBtn;
    BOOL m_fAllowContextMenu;
    BOOL m_fDisableEdit;        // if true, editing is disabled, defaults to FALSE.
    BOOL m_fCanSave;
    BOOL m_fShowToolbar;
    BOOL m_fWarnQuietSave;
    BOOL m_fWarnNoSave;

    BOOL m_fCanAnnotate;        // if true, allows annotation, defaults to FALSE.
    BOOL m_fAnnotating;         // if true, we are in annotating mode, default to false
    HDPA m_hdpaSelectedAnnotations;
    BOOL m_fDirty;
    WORD m_wNewAnnotation;
    HFONT m_hFont;
    BOOL m_fEditingAnnotation;

    BOOL m_fCanCrop;
    BOOL m_fCropping;
    CRect m_rectCropping;       // Cropping Rectangle in Image Coordinates.

    BOOL    m_fBusy;            // we are displaying the hourglass-and-pointer cursor
    HCURSOR m_hCurOld;
    HCURSOR m_hCurrent;
    BOOL    m_fClosed;

    BOOL            m_fPrintable;
    BOOL            m_fExitApp;
    DWORD           m_dwMode;           // three modes: CONTROL_MODE, WINDOW_MODE, SLIDESHOW_MODE
    BOOL            m_fIgnoreUITimers;  // should we ignore timer messages (used when context menu is up, don't hide toolbar)
    HACCEL          m_haccel;

    CEvents *       m_pEvents;          // pointer to our parent control event object.  NULL if we aren't running as a control.

    LPITEMIDLIST*   m_ppidls;           // pidls of already shown items
    UINT            m_cItems;           // # of items in m_ppidls
    UINT            m_iCurSlide;        // index into m_ppidls

    CDecodeTask* m_pImageData;          // The image data for the decoded image to be viewed
    HDPA        m_hdpaItems;            // pidls of already shown items
    BOOL        m_fPaused;              // slide show paused
    BOOL        m_fToolbarHidden;       // toolbar hidden in slide show mode
    BOOL        m_fGoBack;              // direction of the slide show
    BOOL        m_fTBTrack;             // true if we're tracking mouse for toolbar
    BOOL        m_fWasEdited;           // true if we edited the image
    UINT        m_uTimeout;
    int         m_iSSToolbarSelect;     // selection in toolbar (used for keyboard support in Whistler)
    IUnknown*   m_punkSite;

    HPALETTE    m_hpal;                 // the palette to use if in palette mode.

    IShellImageDataFactory * m_pImageFactory;  // for decoding images

    DWORD       m_dwMultiPageMode;      // for remembering the state of the prev/next page commands

    EXECUTION_STATE m_esFlags;          // execution flags, stored to restore after we re-enable monitor's power saving mode
    HWND _hWndPageList;

    IContextMenu3 *_pcm3;

    IShellTaskScheduler * m_pTaskScheduler;     // for managing a worker thread
    CDecodeTask *         m_pNextImageData;
    UINT                  m_iDecodingNextImage;

    ImageCodecInfo *m_pici;
    UINT m_cDecoders;

    IDataObject *_pdtobj; // reused data object for passing data from oncopydata to ontimer
    BOOL m_fPromptingUser;

    BOOL m_fFirstTime;
    BOOL m_fFirstItem;

    DWORD m_dwEffect;
    BOOL  m_fIgnoreNextNotify;
    ULONG m_uRegister;
    BOOL  m_fNoRestore;

private:
    BOOL m_bRTLMirrored;    // true if m_hWnd is RTL mirrored
    UINT m_cWalkDepth;
};


#define REGSTR_SHIMGVW      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellImageView")
#define REGSTR_MAXIMIZED    TEXT("Maximize")
#define REGSTR_BOUNDS       TEXT("Bounds")
#define REGSTR_FONT         TEXT("Font")
#define REGSTR_BACKCOLOR    TEXT("BackColor")
#define REGSTR_LINECOLOR    TEXT("LineColor")
#define REGSTR_TEXTCOLOR    TEXT("TextColor")
#define REGSTR_LINEWIDTH    TEXT("LineWidth")
#define REGSTR_TIMEOUT      TEXT("Timeout")

#define REGSTR_DONTSHOWME   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\DontShowMeThisDialogAgain")
#define REGSTR_SAVELESS     TEXT("ShellImageViewWarnOnSavelessRotate")
#define REGSTR_LOSSYROTATE  TEXT("ShellImageViewWarnOnLossyRotate")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\recompress.cpp ===
#include "precomp.h"
#include "prevwnd.h"
#pragma hdrstop


// class which implements IRecompress

class CImgRecompress : public IImageRecompress, public NonATLObject
{
public:
    CImgRecompress();
    ~CImgRecompress();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IImageRecompress
    STDMETHODIMP RecompressImage(IShellItem *psi, int cx, int cy, int iQuality, IStorage *pstg, IStream **ppstrmOut);
       
protected:
    LONG _cRef;                             // object lifetime

    IShellItem *_psi;                       // current shell item
    IShellImageDataFactory *_psidf;  

    HRESULT _FindEncoder(IShellItem *psi, IShellImageData *psid, IStorage *pstg, IStream **ppstrmOut, BOOL *pfChangeFmt, GUID *pDataFormat);
    HRESULT _InitRecompress(IShellItem *psi, IStream **ppstrm, STATSTG *pstatIn);
    HRESULT _SaveImage(IShellImageData *psid, int cx, int cy, int iQuality, GUID *pRawDataFmt, IStream *pstrm);
};


// Recompress interface
CImgRecompress::CImgRecompress() :
    _cRef(1), _psidf(NULL)
{
    _Module.Lock();
}

CImgRecompress::~CImgRecompress()
{
    ATOMICRELEASE(_psidf);
    _Module.Unlock();
}

STDMETHODIMP CImgRecompress::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CImgRecompress, IImageRecompress),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CImgRecompress::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CImgRecompress::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}


HRESULT CImgRecompress::_InitRecompress(IShellItem *psi, IStream **ppstrm, STATSTG *pstatIn)
{
    HRESULT hr = S_OK;

    if (!_psidf)
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellImageDataFactory, &_psidf));

    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(STGM_READ | STGM_SHARE_DENY_NONE, &pbc);
        if (SUCCEEDED(hr))
        {
            IStream *pstrm;
            hr = psi->BindToHandler(pbc, BHID_Stream, IID_PPV_ARG(IStream, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = pstrm->Stat(pstatIn, STATFLAG_NONAME);
                if (SUCCEEDED(hr))
                {
                    hr = pstrm->QueryInterface(IID_PPV_ARG(IStream, ppstrm));
                }
                pstrm->Release();
            }
            pbc->Release();
        }
    }

    return hr;
}


HRESULT CImgRecompress::RecompressImage(IShellItem *psi, int cx, int cy, int iQuality, IStorage *pstg, IStream **ppstrmOut)
{
    STATSTG statIn;
    IStream *pstrm;

    HRESULT hr = S_FALSE;
    if (SUCCEEDED(_InitRecompress(psi, &pstrm, &statIn)))
    {
        IShellImageData * psid;
        if (SUCCEEDED(_psidf->CreateImageFromStream(pstrm, &psid)))
        {
            // we need to decode the image before we can read its header - unfortunately
            if (SUCCEEDED(psid->Decode(SHIMGDEC_DEFAULT, 0, 0)))
            {
                BOOL fRecompress = FALSE;
                GUID guidDataFormat;
                if (S_OK == _FindEncoder(psi, psid, pstg, ppstrmOut, &fRecompress, &guidDataFormat))
                {
                    int cxOut = 0, cyOut = 0;

                    // lets compute to see if we need to recompress the image, we do this by
                    // looking at its size compared ot the size the caller has given us,
                    // we also compare based on the larger axis to ensure we keep aspect ratio.

                    SIZE szImage;
                    if (SUCCEEDED(psid->GetSize(&szImage)))
                    {
                        // If the image is too big scale it down to screen size (use large axis for threshold check)
                        if (szImage.cx > szImage.cy)
                        {
                            cxOut = min(szImage.cx, cx);
                            fRecompress |= szImage.cx > cx;
                        }
                        else
                        {
                            cyOut = min(szImage.cy, cy);
                            fRecompress |= szImage.cy > cy;
                        }
                    }

                    // if fRecompress then we generate the new stream, if the new stream is not 
                    // smaller than the current image that we started with then lets
                    // ignore it (always better to send the smaller of the two).
                    //

                    if (fRecompress)
                    {
                        hr = _SaveImage(psid, cxOut, cyOut, iQuality, &guidDataFormat, *ppstrmOut);

                        // If its not worth keeping then lets discard it (eg. 
                        // there was a failure, or new image is bigger than the original.

// tests have shown that this never gets hit, so I'm removing it b/c it will break
// the web publishing wizard's request to resize to this specific size.  a client
// of recompress can perform this check itself if it needs to.
#if 0
                        STATSTG statOut;
                        hr = (*ppstrmOut)->Stat(&statOut, STATFLAG_NONAME);
                        if (FAILED(hr) || (statOut.cbSize.QuadPart > statIn.cbSize.QuadPart))
                        {
                            hr = S_FALSE;
                        }
#endif
                    }

                    if (hr == S_OK)
                    {
                        (*ppstrmOut)->Commit(0);        // commit our changes to the stream

                        LARGE_INTEGER li0 = {0};        // seek to the head of the file so reading gives us bits
                        (*ppstrmOut)->Seek(li0, 0, NULL);
                    }
                    else if (*ppstrmOut)
                    {
                        (*ppstrmOut)->Release();
                        *ppstrmOut = NULL;
                    }
                }
            }
            psid->Release();
        }
        pstrm->Release();
    }
    return hr;
}


HRESULT CImgRecompress::_SaveImage(IShellImageData *psid, int cx, int cy, int iQuality, GUID *pRawDataFmt, IStream *pstrm)
{
    HRESULT hr = S_OK;

    // Scale the image
    if (cx || cy)
    {
        hr = psid->Scale(cx, cy, InterpolationModeHighQuality);
    }

    // Make a property bag containing the encoder parameters and set it (if we are changing format)
    if (SUCCEEDED(hr) && pRawDataFmt)
    {
        IPropertyBag *pbagEnc;
        hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbagEnc));
        if (SUCCEEDED(hr))
        {
            // write the encoder CLSID into the property bag
            VARIANT var;
            hr = InitVariantFromGUID(&var, *pRawDataFmt);
            if (SUCCEEDED(hr))
            {
                hr = pbagEnc->Write(SHIMGKEY_RAWFORMAT, &var);
                VariantClear(&var);
            }

            // write the quality value for the recompression into the property bag
            if (SUCCEEDED(hr))
                hr = SHPropertyBag_WriteInt(pbagEnc, SHIMGKEY_QUALITY, iQuality);

            // pass the parameters over to the encoder
            if (SUCCEEDED(hr))
                hr = psid->SetEncoderParams(pbagEnc);

            pbagEnc->Release();
        }
    }

    // Now persist the file away
    if (SUCCEEDED(hr))
    {
        IPersistStream *ppsImg;
        hr = psid->QueryInterface(IID_PPV_ARG(IPersistStream, &ppsImg));
        if (SUCCEEDED(hr))
        {
            hr = ppsImg->Save(pstrm, TRUE);
            ppsImg->Release();
        }
    }

    return hr;
}


HRESULT CImgRecompress::_FindEncoder(IShellItem *psi, IShellImageData *psid, IStorage *pstg, IStream **ppstrmOut, BOOL *pfChangeFmt, GUID *pDataFormat)
{
    GUID guidDataFormat;
    BOOL fChangeExt = FALSE;

    // read the relative name from the stream so that we can create a temporary one which maps
    LPWSTR pwszName;
    HRESULT hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEPARSING, &pwszName);
    if (SUCCEEDED(hr))
    {
        // get the data format from the image we are decompressing
        hr = psid->GetRawDataFormat(&guidDataFormat);
        if (SUCCEEDED(hr))
        {
            if (!IsEqualGUID(guidDataFormat, ImageFormatJPEG))
            {
                // ask the image about it's properties
                if ((S_FALSE == psid->IsMultipage()) &&
                    (S_FALSE == psid->IsVector()) &&
                    (S_FALSE == psid->IsTransparent()) &&
                    (S_FALSE == psid->IsAnimated()))
                {
                    guidDataFormat = ImageFormatJPEG;
                    fChangeExt = TRUE;
                }
                else
                {
                    hr = S_FALSE;                       // can't be translated
                }
            }

            // update the name accordingly before making a stream
            TCHAR szOutName[MAX_PATH];
            StrCpyNW(szOutName, pwszName, ARRAYSIZE(szOutName));
            if (fChangeExt)
            {
                PathRenameExtension(szOutName, TEXT(".jpg"));
            }

// TODO: need to get FILE_FLAG_DELETE_ON_CLOSE to happen on CreateFile
            hr = StgMakeUniqueName(pstg, szOutName, IID_PPV_ARG(IStream, ppstrmOut));
        }

        CoTaskMemFree(pwszName);
    }

    if (pfChangeFmt) 
        *pfChangeFmt = fChangeExt;

    *pDataFormat = guidDataFormat;

    return hr;
}


STDAPI CImgRecompress_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CImgRecompress *pr = new CImgRecompress();
    if (!pr)
    {
        *ppunk = NULL;          // incase of failure
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pr->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
    pr->Release();
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\precomp.h ===
// precomp.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once
#define STRICT

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_UUIDOF
#define _ATL_NO_DEBUG_CRT

// we have to provide ATLASSERT(x) with no debug crt
// we don't use it, so make it do nothing
#define ATLASSERT(x)

#pragma warning(disable : 4100 4310)

#include <windows.h>
#include <shellapi.h>
#include <port32.h>
#include <commctrl.h>
#include <wininet.h>
#include <shlobj.h>
#include <hlink.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlguidp.h>
#include <shdispid.h>
#include <ieguidp.h>
#include <ccstock.h>
#include "cfdefs.h"
#include <comctrlp.h>
#include <dpa.h>
#include "resource.h"
#include <gdiplus.h>
using namespace Gdiplus;

#include "shimgdata.h"
#include <shfusion.h>   // needs to be before ATL.

#include <varutil.h>
#include <shdguid.h>
#include <debug.h>
#include <atlbase.h>

// needs to be defined before including atlcom.
extern CComModule _Module;
#include <atlcom.h>

#include <atlctl.h>
#include <atlwin.h>
#define _ATL_TMP_NO_CSTRING
#include <atltmp.h>
#include "guids.h"

#include <gdithumb.h>
#include <docfile.h>
#include <mshtmhst.h>
#include <html.h>
#include <extmsg.h>

#include <runtask.h>

#pragma warning(default : 4100 4310)

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

#define MIN(x,y)        ((x<y)?x:y)
#define MAX(x,y)        ((x>y)?x:y)

#define SWAPLONG(a, b)  { LONG t; t = a; a = b; b = t; }

#define RECTWIDTH(rc)   ((rc).right-(rc).left)
#define RECTHEIGHT(rc)  ((rc).bottom-(rc).top)

STDAPI CImageData_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CImageDataFactory_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CPhotoVerbs_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CAutoplayForSlideShow_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
STDAPI CImgRecompress_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CGraphicsInit
{    
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        _token = 0;        
        GdiplusStartupInput gsi;            
        GdiplusStartup(&_token, &gsi, NULL);        
    };
    ~CGraphicsInit()
    {
        if (_token != 0)
        {
            GdiplusShutdown(_token);
        }           
    };
};

// All non-ATL COM objects must derive from this class so the
// DLL object reference count stays correct -- this ensures that
// DllCanUnloadNow returns the correct value.

class NonATLObject
{
public:
    NonATLObject() { _Module.Lock(); }
    ~NonATLObject() { _Module.Unlock(); }
};

//
// Helper function for loading SP1 strings
int LoadSPString(int idStr, LPTSTR pszString, int cch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\resource.h ===
// Used by shimgvw.rc
//
#define IDI_FULLSCREEN                  1
#define IDI_BITMAPFILE                  2
#define IDI_GIFFILE                     3
#define IDI_JPEGFILE                    4
#define IDI_TIFFILE                     5
#define IDI_MAIL                        7

#define IDR_VIEWERHTML                  10
#define IDR_VIEWERHTML_NET              11

#define IDA_PREVWND_SINGLEPAGE          50
#define IDA_PREVWND_MULTIPAGE           51
#define IDR_PREVIEW                     52
#define IDR_PHOTOVERBS                  53
#define IDR_MKSLIDE                     54
#define IDA_FILECOPY                    55
#define IDR_SHIMGDATAFACTORY            56
#define IDR_RECOMPRESS                  57

#define IDB_TOOLBAR                     104
#define IDB_TOOLBARHIGH                 105
#define IDB_TOOLBAR_HOT                 106
#define IDB_TOOLBARHIGH_HOT             107

#define IDB_SLIDESHOWTOOLBAR            108
#define IDB_SLIDESHOWTOOLBARHIGH        109
#define IDB_SLIDESHOWTOOLBAR_HOT        110
#define IDB_SLIDESHOWTOOLBARHIGH_HOT    111

#define IDA_ROTATEAVI                   112

#define IDS_PROJNAME                    200
#define IDS_NOPREVIEW                   201
#define IDS_LOADFAILED                  202
#define IDS_MULTISELECT                 203
#define IDS_LOADING                     204
#define IDS_SETUPFAILED                 205
#define IDS_ROTATE90                    209
#define IDS_ROTATE270                   210
#define IDS_ROTATETITLE                 211
#define IDS_ROTATEDLGTITLE              212

#define IDS_SAVEWARNING_MSGBOX          216
#define IDS_NAMETOOLONG_MSGBOX          217
#define IDS_SAVEFAILED_MSGBOX           218
#define IDS_WIDTHBAD_MSGBOX             219
#define IDS_NEW_FILENAME                221
#define IDS_SAVEAS_TITLE                222
#define IDS_DRAWFAILED                  223
#define IDS_DRAWING                     224
#define IDS_SAVE_WARN_TIFF              225

#define IDS_UNKNOWNIMAGE                300
#define IDS_EMFIMAGE                    301
#define IDS_GIFIMAGE                    302
#define IDS_JPEGIMAGE                   303
#define IDS_BITMAPIMAGE                 304
#define IDS_PNGIMAGE                    305
#define IDS_TIFIMAGE                    306
#define IDS_WMFIMAGE                    307

#define IDS_DIMENSIONS_FMT              308

#define IDS_SUMMARY                     311

#define IDC_OPENHAND                    300
#define IDC_CLOSEDHAND                  301
#define IDC_ZOOMOUT                     302
#define IDC_ZOOMIN                      303

#define IDC_DONTASKAGAIN                320

#define IDD_COMPSETTINGS                353
#define IDD_ANNOPROPS                   354

#define IDC_WIDTHTEXT                   384
#define IDC_WIDTH                       385
#define IDC_SPIN                        386
#define IDC_TRANSPARENT                 387
#define IDC_FONT                        388
#define IDC_COLOR                       389

// Toolbar Commands
#define NOBUTTON                          0
#define ID_FIRSTTOOLBARCMD              400
#define ID_ZOOMINCMD                    400
#define ID_ZOOMOUTCMD                   401
#define ID_SELECTCMD                    402
#define ID_BESTFITCMD                   403
#define ID_ACTUALSIZECMD                404
#define ID_PREVPAGECMD                  406
#define ID_NEXTPAGECMD                  407
#define ID_SLIDESHOWCMD                 408
#define ID_FREEHANDCMD                  409
#define ID_HIGHLIGHTCMD                 410
#define ID_LINECMD                      411
#define ID_FRAMECMD                     412
#define ID_RECTCMD                      413
#define ID_TEXTCMD                      414
#define ID_NOTECMD                      415
#define ID_NEXTIMGCMD                   416
#define ID_PREVIMGCMD                   417
#define ID_PRINTCMD                     418
#define ID_PROPERTIESCMD                419
#define ID_SAVEASCMD                    420
#define ID_EDITCMD                      421
#define ID_CROPCMD                      422
#define ID_HELPCMD                      423
#define ID_DELETECMD                    424
#define ID_OPENCMD                      425
#define ID_LASTTOOLBARCMD               425

                                        
#define ID_PAGELIST                     421

#define IDS_PRINTCMD                    490 // alternate string for IDI_PRINTCMD
#define IDS_ROTATE90CMD                 491 // alternate string for IDI_ROTATE90CMD
#define IDS_ROTATE270CMD                492 // alternate string for IDI_ROTATE270CMD
#define IDS_DELETECMD                   493 // alternate string for ID_DELETECMD on context menu
#define IDS_PROPERTIESCMD               494 // alternate string for ID_PROPERTIESCMD on context menu

// Commands that cause Auto Save
#define ID_FIRSTEDITCMD                 500
#define ID_ROTATE90CMD                  500
#define ID_ROTATE270CMD                 501
#define ID_FLIPXCMD                     502
#define ID_FLIPYCMD                     503
#define ID_LASTEDITCMD                  503

#define ID_FIRSTPOSITIONCMD             550
#define ID_MOVELEFTCMD                  550
#define ID_MOVERIGHTCMD                 551
#define ID_MOVEUPCMD                    552
#define ID_MOVEDOWNCMD                  553
#define ID_NUDGELEFTCMD                 554
#define ID_NUDGERIGHTCMD                555
#define ID_NUDGEUPCMD                   556
#define ID_NUDGEDOWNCMD                 557
#define ID_LASTPOSITIONCMD              557

// Context Menu Verbs 
#define IDS_PREVIEW_CTX                 550
#define IDS_ZOOMIN_CTX                  551
#define IDS_ZOOMOUT_CTX                 552
#define IDS_ACTUALSIZE_CTX              553
#define IDS_BESTFIT_CTX                 554
#define IDS_NEXTPAGE_CTX                555
#define IDS_PREVPAGE_CTX                556
#define IDS_ROTATE90_CTX                557
#define IDS_ROTATE270_CTX               558
#define IDS_PRINT_CTX                   559
#define IDS_WALLPAPER_CTX               560


// Slideshow Mode Commands              
#define ID_FIRSTSLIDESHOWCMD            600
#define ID_PLAYCMD                      600
#define ID_PAUSECMD                     601
#define ID_PREVCMD                      602
#define ID_NEXTCMD                      603
#define ID_CLOSECMD                     604
#define ID_LASTSLIDESHOWCMD             605

#define IDS_THUMBNAIL_MSGBOX            650
#define IDS_THUMBNAIL_MSGBOXTITLE       651
#define IDS_THUMBNAIL_PROGRESSTEXT      652
#define IDS_COPYIMAGES_MSGBOX           653
#define IDS_COPYIMAGES_MSGBOXTITLE      654
#define IDS_COPYIMAGES_PROGRESSTEXT     655
#define IDS_THUMBNAIL_SUFFIX            656
#define IDS_RECOMPRESS_CAPTION          657

// These seperators get an ID so they can be hidden
#define ID_PAGECMDSEP                   700
#define ID_SLIDESHOWSEP                 701
#define ID_ANNOTATESEP                  702
#define ID_VIEWCMDSEP                   703
#define ID_ROTATESEP                    704

#define IDS_CHOOSE_DIR                  802

#define IDS_GDITHUMBEXTRACT_DESC        892
#define IDS_DOCTHUMBEXTRACT_DESC        893
#define IDS_HTMLTHUMBEXTRACT_DESC       894

#define IDC_PICSMALL                    920
#define IDC_PICMEDIUM                   921
#define IDC_PICLARGE                    922
#define IDC_QUALITYGOOD                 923
#define IDC_QUALITYMEDIUM               924
#define IDC_QUALITYLOW                  925
#define IDC_SAVE                        926

#define IDS_ROTATE_CAPTION              1000
#define IDS_ROTATE_LOSS                 1003
#define IDS_ROTATE_ERROR                1004
#define IDS_ROTATE_CANTSAVE             1005
#define IDS_RESET_MSGBOX                1006
#define IDS_ROTATE_MESSAGE              1007
#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
// help IDs must have the same offset from IDH_HELP_FIRST as the menu offsets in photoverb.cpp
#define IDH_HELP_FIRST                  1500
#define IDH_HELP_OPEN                   IDH_HELP_FIRST+0
#define IDH_HELP_PRINTTO                IDH_HELP_FIRST+1
#define IDH_HELP_ROT90                  IDH_HELP_FIRST+2
#define IDH_HELP_ROT270                 IDH_HELP_FIRST+3
#define IDH_HELP_SETWALL                IDH_HELP_FIRST+4
#define IDH_HELP_ZOOMIN                 IDH_HELP_FIRST+5
#define IDH_HELP_ZOOMOUT                IDH_HELP_FIRST+6
#define IDH_HELP_ACTUALSIZE             IDH_HELP_FIRST+7
#define IDH_HELP_BESTFIT                IDH_HELP_FIRST+8
#define IDH_HELP_NEXTPAGE               IDH_HELP_FIRST+9
#define IDH_HELP_PREVPAGE               IDH_HELP_FIRST+10


#ifndef IDS_BASE_SHIMGVW
#define IDS_BASE_SHIMGVW                                    20000
#define IDS_BLOCK_NUM_SHIMGVW                                   2
#define IDS_SHIMGVW_ROTATE_CANTSAVE                         (IDS_BASE_SHIMGVW)
#define IDS_SHIMGVW_ROTATE_MESSAGE_EXT                      (IDS_BASE_SHIMGVW+1)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\prevwnd.cpp ===
#include "precomp.h"
#include "PrevWnd.h"
#include "PrevCtrl.h"
#include "resource.h"
#include <shimgdata.h>
#include "shutil.h"
#include "tasks.h"
#include <shellp.h>
#include <ccstock2.h>
#include <htmlhelp.h>

#include "prwiziid.h"
#pragma hdrstop

#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))
#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))

#define COPYDATATYPE_DATAOBJECT       1
#define COPYDATATYPE_FILENAME         2

int g_x = 0, g_y = 0; // mouse coordinates
BOOL g_bMirroredOS = FALSE;


#define HTMLHELP_FILENAME   TEXT("ImgPrev.chm")

static COLORREF g_crCustomColors[] = {
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255),
    RGB(255,255,255)
};

static void _RotateRect(CRect &rect, CAnnotation* pAnnotation)
{
    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    CTextAnnotation* pTextAnnotation = (CTextAnnotation*)pAnnotation;

    int nOrientation = pTextAnnotation->GetOrientation();
    if (nOrientation == 900 || nOrientation == 2700)
    {
        int nWidth = rect.Width();
        int nHeight = rect.Height();
        rect.right = rect.left + nHeight;
        rect.bottom = rect.top + nWidth;
    }
}

CPreviewWnd::CPreviewWnd() : m_ctlToolbar(NULL, this, 1), m_ctlPreview(this), m_ctlEdit(NULL, this, 2)
{
    // we are often created on the stack, so we can't be sure that we're zero initialized

    m_fCanCrop = FALSE;
    m_fCropping = FALSE;
    m_rectCropping.SetRectEmpty();

    m_fBusy = FALSE;
    m_hCurOld = NULL;
    m_hCurrent = NULL;
    m_fWarnQuietSave = TRUE;
    m_fWarnNoSave = TRUE;
    m_fPromptingUser = FALSE;
    m_fCanAnnotate = FALSE;
    m_fAnnotating = FALSE;
    m_fEditingAnnotation = FALSE;
    m_fDirty = FALSE;
    m_pEvents = 0;
    m_fPaused = FALSE;
    m_fGoBack = FALSE;
    m_fHidePrintBtn = FALSE;
    m_fPrintable = FALSE;
    m_fDisableEdit = FALSE;
    m_fCanSave = TRUE;
    m_fExitApp = FALSE;

    m_fAllowContextMenu = TRUE;     // full screen window always has a context menu
    m_iCurSlide = -1;

    m_iDecodingNextImage = -1;
    m_pNextImageData = NULL;

    m_fToolbarHidden = TRUE;
    m_dwMultiPageMode = MPCMD_HIDDEN;
    m_fIgnoreUITimers = FALSE;

    DWORD cbSize = sizeof(m_uTimeout);
    UINT uDefault = DEFAULT_SHIMGVW_TIMEOUT;
    SHRegGetUSValue(REGSTR_SHIMGVW, REGSTR_TIMEOUT, NULL, (void *)&m_uTimeout, &cbSize, FALSE, (void *)&uDefault, sizeof(uDefault));

    InitSelectionTracking();

    g_bMirroredOS = IS_MIRRORING_ENABLED(); // global????

    m_hdpaSelectedAnnotations = NULL;
    m_haccel = NULL;
    m_hpal = NULL;
    m_dwMode = 0;
    m_fShowToolbar = TRUE;
    m_punkSite = NULL;
    m_pImageFactory = NULL;
    m_pcwndSlideShow = NULL;
    m_hFont = NULL;
    m_pImageData = NULL;
    m_ppidls = NULL;
    m_cItems = 0;
    _pcm3 = NULL;

    m_pTaskScheduler = NULL;
    m_pici = NULL;

    _pdtobj = NULL;

    m_fFirstTime = TRUE;
    m_fFirstItem = FALSE;
    m_dwEffect = DROPEFFECT_NONE;
    m_fIgnoreNextNotify = FALSE;
    m_uRegister = 0;
    m_fNoRestore = FALSE;
    m_bRTLMirrored = FALSE;
    m_cWalkDepth = 0;
}

HRESULT CPreviewWnd::Initialize(CPreviewWnd* pother, DWORD dwMode, BOOL bExitApp)
{
    HRESULT hr = E_OUTOFMEMORY;

    m_hdpaSelectedAnnotations = DPA_Create(16);
    if (m_hdpaSelectedAnnotations)
    {
        hr = S_OK;
        m_dwMode = dwMode;
        m_fExitApp = bExitApp;

        // Set some defaults based on the mode
        if (CONTROL_MODE == m_dwMode)
        {
            m_fHidePrintBtn = TRUE;
        }

        if (pother)
        {
            m_fHidePrintBtn =       pother->m_fHidePrintBtn;
            m_fPrintable =          pother->m_fPrintable;
            m_fDisableEdit =        pother->m_fDisableEdit;
            m_fCanSave =            pother->m_fCanSave;
            m_haccel =              pother->m_haccel;
            m_dwMultiPageMode =     pother->m_dwMultiPageMode;
            m_hpal =                pother->m_hpal;
            m_iCurSlide =           pother->m_iCurSlide;

            m_uTimeout = pother->m_uTimeout;

            SetSite(pother->m_punkSite);

            // we grab a reference to the controlling objects m_pImageFactory
            // becaue it would be odd to create new ones.
            m_pImageFactory = pother->m_pImageFactory;
            if (m_pImageFactory)
            {
                m_pImageFactory->AddRef();
            }

            m_pTaskScheduler = pother->m_pTaskScheduler;
            if (m_pTaskScheduler)
            {
                m_pTaskScheduler->AddRef();
            }

            // lets copy the DPA of items also, and the current index
            if (pother->m_ppidls)
            {
                m_ppidls = (LPITEMIDLIST*)CoTaskMemAlloc(sizeof(LPITEMIDLIST)*pother->m_cItems);
                if (m_ppidls)
                {
                    for (int iItem = 0; iItem != pother->m_cItems; iItem++)
                    {
                        if (SUCCEEDED(pother->_GetItem(iItem, &m_ppidls[m_cItems])))
                        {
                            m_cItems++;
                        }
                    }
                }
            }
        }
    }
    return hr;
}

int ClearCB(void *p, void *pData);

CPreviewWnd::~CPreviewWnd()
{
    CleanupSelectionTracking();

    if (m_hdpaSelectedAnnotations != NULL)
        DPA_Destroy(m_hdpaSelectedAnnotations);

    ::DeleteObject(m_hFont);

    ATOMICRELEASE(m_pImageData);
    ATOMICRELEASE(m_pNextImageData);
    ATOMICRELEASE(m_pImageFactory);
    SetSite(NULL);
    ATOMICRELEASE(_pdtobj);
    ATOMICRELEASE(m_pTaskScheduler);


    _ClearDPA();

    if (m_pcwndSlideShow)
    {
        if (m_pcwndSlideShow->m_hWnd)
        {
            m_pcwndSlideShow->DestroyWindow();
        }
        delete m_pcwndSlideShow;
    }

    if (m_pici)
    {
        LocalFree(m_pici);
        m_pici = NULL;
    }
}

BOOL CPreviewWnd::CreateSlideshowWindow(UINT cWalkDepth)
{
    RECT rc = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };

    if (!Create(NULL, rc, NULL, WS_VISIBLE | WS_POPUP | WS_CLIPCHILDREN))
        return FALSE;

    WINDOWPLACEMENT wp = {0};

    wp.length = sizeof(wp);
    GetWindowPlacement(&wp);
    wp.showCmd = SW_MAXIMIZE;
    SetWindowPlacement(&wp);
    SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);

    //  when we get called from autoplay to do a slideshow, 
    //  we need to walk deeply to find everything 
    //  that the autoplay code may have found

    m_cWalkDepth = cWalkDepth;
    return TRUE;
}

BOOL CPreviewWnd::_CloseSlideshowWindow()
{
    if (m_fExitApp)
        PostQuitMessage(0);
    else
        PostMessage(WM_CLOSE, 0, 0);
    return TRUE;
}

BOOL CPreviewWnd::CreateViewerWindow()
{
    // create the window hidden, that way any sizing etc we perform doesn't reflect
    // until its actually visible.

    RECT rc = { CW_USEDEFAULT, CW_USEDEFAULT, 0, 0 };
    BOOL bRet = (NULL != Create(NULL, rc, NULL, WS_OVERLAPPEDWINDOW));
    m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_SINGLEPAGE));
    if (bRet)
    {
        // restore the window size based on the information we store in the registry.
        HKEY hk;
        if (ERROR_SUCCESS == RegOpenKey(HKEY_CURRENT_USER, REGSTR_SHIMGVW, &hk))
        {
            DWORD cbSize, dwType;

            // set the window placement, passing the restore rectangle for the window.

            WINDOWPLACEMENT wp = { 0 };
            wp.length = sizeof(wp);
            
            GetWindowPlacement(&wp);

            cbSize = sizeof(wp.rcNormalPosition);
            RegQueryValueEx(hk, REGSTR_BOUNDS, NULL, &dwType, (BYTE*)&wp.rcNormalPosition, &cbSize);

            BOOL fMaximize = TRUE;
            cbSize = sizeof(fMaximize);
            RegQueryValueEx(hk, REGSTR_MAXIMIZED, NULL, &dwType, (BYTE*)&fMaximize, &cbSize);
            if (fMaximize)
                wp.showCmd = SW_MAXIMIZE;

            SetWindowPlacement(&wp);
            RegCloseKey(hk);
        }        
        // now show the window having set its placement etc.
        SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
    }
    return bRet;
}


void ReplaceWindowIcon(HWND hwnd, int id, HICON hicon)
{
    HICON hiconOld = (HICON)SendMessage(hwnd, WM_SETICON, id, (LPARAM)hicon);
    if (hiconOld)
        DestroyIcon(hiconOld);
}

LRESULT CPreviewWnd::OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    HRESULT hr = S_OK;

    if (IS_BIDI_LOCALIZED_SYSTEM())
    {
        SHSetWindowBits(m_hWnd, GWL_EXSTYLE, WS_EX_LAYOUTRTL, WS_EX_LAYOUTRTL);
        m_bRTLMirrored = TRUE;
    }
    if (!m_pImageFactory)
    {
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC,
                              IID_PPV_ARG(IShellImageDataFactory, &m_pImageFactory));
        if (FAILED(hr))
            return -1;
    }

    if (!m_pTaskScheduler)
    {
        hr = IUnknown_QueryService(m_punkSite, SID_ShellTaskScheduler, IID_PPV_ARG(IShellTaskScheduler, &m_pTaskScheduler));
        if (FAILED(hr))
        {
            hr = CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                                  IID_PPV_ARG(IShellTaskScheduler, &m_pTaskScheduler));

            if (FAILED(hr))
                return -1;
        }
    }

    // figure out where to place the zoom window
    RECT rcWnd;
    GetClientRect(&rcWnd);

    if (m_fShowToolbar)
    {
        // Create a toolbar control and then subclass it
        if (!CreateToolbar())
            return -1;

        m_iSSToolbarSelect = 0;
    }

    HICON hicon = LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDI_FULLSCREEN));

    ReplaceWindowIcon(m_hWnd, ICON_SMALL, hicon);
    ReplaceWindowIcon(m_hWnd, ICON_BIG, hicon);    

    // Create the preview window
    DWORD dwExStyle = 0; // (WINDOW_MODE == m_dwMode) ? WS_EX_CLIENTEDGE : 0 ;
    if (m_ctlPreview.Create(m_hWnd, rcWnd, NULL, WS_CHILD|WS_VISIBLE|WS_CLIPCHILDREN|WS_CLIPSIBLINGS, dwExStyle))
    {
        // When the window is created its default mode should be NOACTION.  This call is needed
        // because the object might have a longer life cycle than the window.  If a new window
        // is created for the same object we want to reset the state.
        m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
        m_ctlPreview.SetScheduler(m_pTaskScheduler);
    }

    RegisterDragDrop(m_hWnd, SAFECAST(this, IDropTarget *));

    return 0;
}

HRESULT CPreviewWnd::_SaveIfDirty(BOOL fCanCancel)
{
    // Callers assume that _SaveIfDirty will either return S_OK or S_FALSE
    // since this function is designed to sit in a loop until the user gives
    // up saving (cancels) or save successfully.
    HRESULT hr = S_OK;
    if (m_fDirty)
    {
        CComBSTR bstrMsg, bstrTitle;

        if (bstrMsg.LoadString(IDS_SAVEWARNING_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
        {
            hr = E_FAIL;
            while (FAILED(hr))
            {
                UINT uFlags;
                if (fCanCancel)
                    uFlags = MB_YESNOCANCEL;
                else
                    uFlags = MB_YESNO;

                uFlags |= MB_ICONQUESTION | MB_DEFBUTTON1 | MB_APPLMODAL;
                
                m_fPromptingUser = TRUE;
                int iResult = MessageBox(bstrMsg, bstrTitle, uFlags);
                m_fPromptingUser = FALSE;
                
                if (iResult == IDYES)
                {
                    // if this fails we keep looping.
                    // if this returns S_OK we succeed
                    // if this returns S_FALSE we cancel
                    hr = _SaveAsCmd();
                }
                else if (iResult == IDCANCEL)
                {
                    hr = S_FALSE;
                }
                else
                {
                    hr = S_OK;
                }
            }
        }
        if (S_OK == hr)
            m_fDirty = FALSE;
    }
    return hr;
}

LRESULT CPreviewWnd::OnClose(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    // hack alert- if CONTROL is held down while pressing the close button, do the registry stuff.
    // make sure the E accelerator isn't being used (edit verb)!
    if (m_fPromptingUser)
    {
        SetForegroundWindow(m_hWnd);
        fHandled = TRUE;
        return 0;
    }
    if (!m_fNoRestore && GetKeyState(VK_CONTROL) & 0x8000)
    {
        CRegKey Key;
        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
        {
            Key.DeleteValue(REGSTR_LOSSYROTATE);
        }

        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_DONTSHOWME))
        {
            Key.DeleteValue(REGSTR_SAVELESS);
            Key.DeleteValue(REGSTR_LOSSYROTATE);
        }

        CComBSTR bstrMsg, bstrTitle;

        if (bstrMsg.LoadString(IDS_RESET_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
        {
            m_fPromptingUser = TRUE;
            MessageBox(bstrMsg, bstrTitle, MB_OK | MB_APPLMODAL);
            m_fPromptingUser = FALSE;
        }
    }

    fHandled = FALSE; // let it close
    HRESULT hr = _SaveIfDirty(TRUE);
    if (hr == S_FALSE) // _SaveIfDirty can only return S_OK and S_FALSE
    {
        m_fNoRestore = FALSE;
        fHandled = TRUE;
    }
    if (!fHandled)
    {
        m_fClosed = TRUE;
    }
    return 0;
}

// we only have to erase the portion not covered by the zoomwnd
// change this code if the toolbar is put back at the top of the window
LRESULT CPreviewWnd::OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    RECT rc;
    RECT rcZoomwnd;
    m_ctlPreview.GetClientRect(&rcZoomwnd);
    GetClientRect(&rc);
    rc.top = RECTHEIGHT(rcZoomwnd);
    SetBkColor((HDC)wParam, m_ctlPreview.GetBackgroundColor());
    ExtTextOut((HDC)wParam, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    fHandled = TRUE;
    return TRUE;
}

LRESULT CPreviewWnd::OnSize(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    int x =0, y =0, cx =0, cy =0;

    if (lParam == 0)
    {
        RECT rcClient;
        GetClientRect(&rcClient);
        cx = RECTWIDTH(rcClient);
        cy = RECTHEIGHT(rcClient);
    }
    else
    {
        cx = GET_X_LPARAM(lParam);
        cy = GET_Y_LPARAM(lParam);
    }

    if (m_fShowToolbar)
    {
        SIZE sizeToolbar;
        m_ctlToolbar.SendMessage(TB_GETMAXSIZE, 0, (LPARAM)&sizeToolbar);
        if (sizeToolbar.cx > cx)
            sizeToolbar.cx = cx;

        if (SLIDESHOW_MODE != m_dwMode)
        {
            // Center the toolbar horizontally
            LONG cyBottomMargin = (CONTROL_MODE == m_dwMode) ? NEWTOOLBAR_BOTTOMMARGIN_CTRLMODE : NEWTOOLBAR_BOTTOMMARGIN;
            LONG xNewToolbar = ( cx - sizeToolbar.cx ) / 2;
            LONG yNewToolbar = cy - ( cyBottomMargin + sizeToolbar.cy );

            ::SetWindowPos(m_ctlToolbar.m_hWnd, NULL, xNewToolbar, yNewToolbar, sizeToolbar.cx, sizeToolbar.cy, SWP_NOZORDER);

            // make the preview window shorter so the toolbar is below it
            cy -= ( NEWTOOLBAR_TOPMARGIN + sizeToolbar.cy + cyBottomMargin);
        }
        else
        {
            // Pin the toolbar to the upper right corner
            UINT uFlags = 0;
            if (m_fToolbarHidden)
                uFlags |= SWP_HIDEWINDOW;
            else
                uFlags |= SWP_SHOWWINDOW;

            ::SetWindowPos(m_ctlToolbar.m_hWnd, HWND_TOP, cx-sizeToolbar.cx, 0, sizeToolbar.cx, sizeToolbar.cy, uFlags);
        }
    }

    ::SetWindowPos(m_ctlPreview.m_hWnd, NULL, x, y, cx, cy, SWP_NOZORDER);
    return 0;
}


BOOL CPreviewWnd::_VerbExists(LPCTSTR pszVerb)
{
    // TODO: Create the context menu for the item and check it for the verb

    return TRUE;
}

// given a verb lets invoke it for the current file
HRESULT CPreviewWnd::_InvokeVerb(LPCTSTR pszVerb, LPCTSTR szParameters)
{
    SHELLEXECUTEINFO sei = {0};

    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_INVOKEIDLIST | SEE_MASK_HMONITOR;
    sei.hwnd = m_hWnd;
    sei.lpVerb = pszVerb;
    sei.nShow = SW_SHOW;
    sei.lpParameters = szParameters;
    sei.hMonitor = MonitorFromWindow(m_hWnd, MONITOR_DEFAULTTONEAREST);
    LPITEMIDLIST pidl = NULL;
    TCHAR szPath[MAX_PATH];
    HRESULT hr = GetCurrentIDList(&pidl);
    if (SUCCEEDED(hr))
    {
        sei.lpIDList = pidl;
    }
    else if (SUCCEEDED(hr = PathFromImageData(szPath, ARRAYSIZE(szPath))))
    {
        sei.lpFile = szPath;
    }
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
        if (!ShellExecuteEx(&sei))
            hr = E_FAIL;
    }
    ILFree(pidl);

    return hr;
}

// show the window and activate it
// if the window is minimized, restore it

void RestoreAndActivate(HWND hwnd)
{
    if (IsIconic(hwnd))
    {
        ShowWindow(hwnd, SW_RESTORE);
    }
    SetForegroundWindow(hwnd);
}

// Handles WM_COMMAND messages sent from the toolbar control

LRESULT CPreviewWnd::OnToolbarCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    switch (wID)
    {
    case ID_ZOOMINCMD:
        ZoomIn();
        break;

    case ID_ZOOMOUTCMD:
        ZoomOut();
        break;

    case ID_SELECTCMD:
        if (m_fCanAnnotate)
        {
            _UpdateButtons(wID);
        }
        break;

    case ID_CROPCMD:
        if (m_fCanCrop)
        {
            m_rectCropping.SetRectEmpty();
            _UpdateButtons(wID);
        }
        break;

    case ID_ACTUALSIZECMD:
        ActualSize();
        break;

    case ID_BESTFITCMD:
        BestFit();
        break;

    case ID_PRINTCMD:
        _RefreshSelection(FALSE);
        _InvokePrintWizard();
        break;

    case ID_PREVPAGECMD:
    case ID_NEXTPAGECMD:
        _PrevNextPage(ID_NEXTPAGECMD==wID);
        break;

    case ID_NEXTIMGCMD:
    case ID_PREVIMGCMD:
        _RefreshSelection(FALSE);
        if (WINDOW_MODE == m_dwMode)
        {
            HRESULT hr = _SaveIfDirty(TRUE);
            if (hr == S_FALSE)
                return 0;

            _ShowNextSlide(ID_PREVIMGCMD == wID);
        }
        else if (m_punkSite)
        {
            IFolderView* pfv;
            if (SUCCEEDED(IUnknown_QueryService(m_punkSite, SID_DefView, IID_PPV_ARG(IFolderView, &pfv))))
            {
                int iCurrent, cItems;
                if (SUCCEEDED(pfv->ItemCount(SVGIO_ALLVIEW, &cItems)) && (cItems > 1) &&
                    SUCCEEDED(pfv->GetFocusedItem(&iCurrent)))
                {
                    int iToSelect = iCurrent + ((ID_PREVIMGCMD == wID) ? -1 : 1);
                    if (iToSelect < 0)
                    {
                        iToSelect = cItems-1;
                    }
                    else if (iToSelect >= cItems)
                    {
                        iToSelect = 0;
                    }

                    pfv->SelectItem(iToSelect, SVSI_SELECTIONMARK | SVSI_SELECT
                            | SVSI_ENSUREVISIBLE | SVSI_DESELECTOTHERS | SVSI_FOCUSED);
                }
                pfv->Release();
            }
        }
        break;

    case ID_FREEHANDCMD:
    case ID_HIGHLIGHTCMD:
    case ID_LINECMD:
    case ID_FRAMECMD:
    case ID_RECTCMD:
    case ID_TEXTCMD:
    case ID_NOTECMD:
        if (m_fCanAnnotate)
        {
            _UpdateButtons(wID);
        }
        break;

    case ID_PROPERTIESCMD:
        _UpdateButtons(wID);
        _PropertiesCmd();
        break;

    case ID_SAVEASCMD:
        _UpdateButtons(wID);
        _SaveAsCmd();
        break;

    case ID_EDITCMD:
        _UpdateButtons(wID);
        if (m_fCanAnnotate && m_fAnnotating)
        {
            _StartEditing();
        }
        break;

    case ID_HELPCMD:
        _UpdateButtons(wID);
        HtmlHelp(::GetDesktopWindow(), HTMLHELP_FILENAME, HH_DISPLAY_TOPIC, NULL);
        break;

    case ID_OPENCMD:
        _UpdateButtons(wID);
        _OpenCmd();
        break;

    case ID_DELETECMD:
        _UpdateButtons(wID);
        if (m_fCanAnnotate && m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
        {
            _RemoveAnnotatingSelection();
        }
        else
        {
            _DeleteCurrentSlide();
        }
        break;
    case ID_SLIDESHOWCMD:
        if (!m_fFirstTime) // don't try to do this while the namespace walk is ongoing
        {
            StartSlideShow(NULL);
        }
        break;
    }
    return 0;
}


// OnEditCommand
//
// Handles picture editting(rotate/flip/save etc) WM_COMMAND messages

LRESULT CPreviewWnd::OnEditCommand(WORD , WORD wID, HWND , BOOL& )
{
    switch (wID)
    {
    case ID_ROTATE90CMD:
        Rotate(90);
        break;

    case ID_ROTATE270CMD:
        Rotate(270);
        break;
    }

    return 0;
}

LRESULT CPreviewWnd::OnPositionCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        switch (wID)
        {
        case ID_NUDGELEFTCMD:
            OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
            break;
        case ID_NUDGERIGHTCMD:
            OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
            break;
        default:
            break;
        }
    }
    else
    {
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0)
        {
            BOOL bDummy;
            switch (wID)
            {
            case ID_MOVELEFTCMD:
                m_ctlPreview.OnScroll(WM_HSCROLL, SB_PAGEUP, 0, fHandled);
                break;
            case ID_MOVERIGHTCMD:
                m_ctlPreview.OnScroll(WM_HSCROLL, SB_PAGEDOWN, 0, fHandled);
                break;
            case ID_MOVEUPCMD:
                m_ctlPreview.OnScroll(WM_VSCROLL, SB_PAGEUP, 0, fHandled);
                break;
            case ID_MOVEDOWNCMD:
                m_ctlPreview.OnScroll(WM_VSCROLL, SB_PAGEDOWN, 0, fHandled);
                break;
            case ID_NUDGELEFTCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_HSCROLL, SB_LINEUP, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_PREVIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGERIGHTCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_HSCROLL, SB_LINEDOWN, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_NEXTIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGEUPCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_VSCROLL, SB_LINEUP, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_PREVIMGCMD, m_hWnd, bDummy);
                }
                break;
            case ID_NUDGEDOWNCMD:
                if (m_ctlPreview.ScrollBarsPresent())
                {
                    m_ctlPreview.OnScroll(WM_VSCROLL, SB_LINEDOWN, 0, fHandled);
                }
                else
                {
                    OnToolbarCommand(0, ID_NEXTIMGCMD, m_hWnd, bDummy);
                }
                break;
            default:
                break;
            }
        }
        else
        {
            CRect rectImage;
            m_ctlPreview.GetVisibleImageWindowRect(rectImage);
            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
            rectImage.DeflateRect(5, 5);

            CSize size(0,0);

            switch (wID)
            {
            case ID_MOVELEFTCMD:
                size.cx = -25;
                break;
            case ID_MOVERIGHTCMD:
                size.cx = 25;
                break;
            case ID_MOVEUPCMD:
                size.cy = -25;
                break;
            case ID_MOVEDOWNCMD:
                size.cy = 25;
                break;
            case ID_NUDGELEFTCMD:
                size.cx = -1;
                break;
            case ID_NUDGERIGHTCMD:
                size.cx = 1;
                break;
            case ID_NUDGEUPCMD:
                size.cy = -1;
                break;
            case ID_NUDGEDOWNCMD:
                size.cy = 1;
                break;
            default:
                break;
            }

            if (size.cx == 0 && size.cy == 0)
                return 0;

            _UpdateAnnotatingSelection();

            CRect rect;
            CRect rectNewPos;
            BOOL bValidMove = TRUE;
            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
                pAnnotation->GetRect(rect);
                rect.NormalizeRect();
                rect.OffsetRect(size);

                if (!rectNewPos.IntersectRect(rectImage, rect))
                    bValidMove = FALSE;
            }

            if (!bValidMove)
                return 0;

            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
                pAnnotation->Move(size);
            }

            m_fDirty = TRUE;
            _UpdateAnnotatingSelection();
        }
    }
    return 0;
}


// call SetNewImage when the entire image has changed, call UpdateImage if it's the same image
// but it needs to be updated

void CPreviewWnd::_SetNewImage(CDecodeTask * pData)
{
    // store the new pointer
    if (m_pImageData)
    {
        _SaveIfDirty();
        // m_pImageData might be NULL after _SaveAsCmd
        ATOMICRELEASE(m_pImageData);
    }

    m_pImageData = pData;

    m_fWarnQuietSave = TRUE; // Reset for each image
    m_fWarnNoSave = TRUE;

    if (!m_pImageData)
    {
        StatusUpdate(IDS_LOADFAILED);
        return;
    }

    m_pImageData->AddRef();

    // Even if m_hpal is NULL it is still correct, so we always go ahead and set it.
    m_ctlPreview.SetPalette(m_hpal);

    if (SLIDESHOW_MODE != m_dwMode)
    {
        // update toolbar state
        _SetMultipageCommands();
        _SetMultiImagesCommands();

        BOOL fCanAnnotate = _CanAnnotate(m_pImageData);
        _SetAnnotatingCommands(fCanAnnotate);

        BOOL fCanCrop = _CanCrop(m_pImageData);
        _SetCroppingCommands(fCanCrop);

        _RefreshSelection(TRUE);

        _SetEditCommands();

        m_fPrintable = _VerbExists(TEXT("print"));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PRINTCMD, MAKELONG(m_fPrintable, 0));
        // we need to watch non-TIFFs for changes so we can reload.
        // TIFFs are problematic because we allow annotations, and reloading during annotation
        // would suck
        if (CONTROL_MODE != m_dwMode)
        {
            _RegisterForChangeNotify(TRUE);
        }
    }

    // notify our child
    m_ctlPreview.SetImageData(m_pImageData, TRUE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(FALSE, 0));

    // update our toolbar
    BOOL fHandled;
    OnSize(0x0, 0, 0, fHandled);
}

// for refreshing the current m_pImageData because it has changed in some
// way, i.e. it has advanced to the next frame, the next page, or was edited.

void CPreviewWnd::_UpdateImage()
{
    _RefreshSelection(TRUE);
    m_ctlPreview.SetImageData(m_pImageData, FALSE);
}

// Handles slidwshow (pause/resume, next/previous etc) WM_COMMAND messages

void CPreviewWnd::TogglePlayState()
{
    if (!m_fPaused)
    {
        KillTimer(TIMER_SLIDESHOW);
    }
    else
    {
        SetTimer(TIMER_SLIDESHOW, m_uTimeout);
    }
    m_fPaused = !m_fPaused;

    WPARAM wpCheck, wpUncheck;
    if (m_fPaused)
    {
        wpCheck = ID_PAUSECMD;
        wpUncheck = ID_PLAYCMD;
    }
    else
    {
        wpCheck = ID_PLAYCMD;
        wpUncheck = ID_PAUSECMD;
    }
    m_ctlToolbar.SendMessage(TB_SETSTATE, wpCheck, TBSTATE_ENABLED | TBSTATE_CHECKED);
    m_ctlToolbar.SendMessage(TB_SETSTATE, wpUncheck, TBSTATE_ENABLED);
}

LRESULT CPreviewWnd::OnMenuMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (_pcm3)
        _pcm3->HandleMenuMsg(uMsg, wParam, lParam);
    return 0;
}

LRESULT CPreviewWnd::OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    UINT cmd = GET_APPCOMMAND_LPARAM(lParam);
    DWORD dwKeys = GET_KEYSTATE_LPARAM(lParam);

    switch (cmd)
    {
    case APPCOMMAND_BROWSER_FORWARD:
        if (SLIDESHOW_MODE == m_dwMode)
            OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
        else
        {
            if ((dwKeys & MK_CONTROL) || (m_pImageData && !m_pImageData->IsMultipage()))
                OnToolbarCommand(0, ID_NEXTIMGCMD, NULL, fHandled);
            else
                NextPage();
        }
        break;

    case APPCOMMAND_BROWSER_BACKWARD:
        if (SLIDESHOW_MODE == m_dwMode)
            OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
        else
        {
            if ((dwKeys & MK_CONTROL) || (m_pImageData && !m_pImageData->IsMultipage()))
                OnToolbarCommand(0, ID_PREVIMGCMD, NULL, fHandled);
            else
                PreviousPage();
        }
        break;

    default:
        fHandled = FALSE;
    }
    return 0;
}

LRESULT CPreviewWnd::OnSlideshowCommand(WORD wNotifyCode, WORD wID, HWND hwnd, BOOL& fHandled)
{
    switch (wID)
    {
    case ID_PLAYCMD:
        m_iSSToolbarSelect = 0;
        if (m_fPaused)
        {
            m_fGoBack = FALSE;
            TogglePlayState();
            _ShowNextSlide(m_fGoBack);
        }
        fHandled = TRUE;
        break;

    case ID_PAUSECMD:
        m_iSSToolbarSelect = 1;
        if (!m_fPaused)
        {
            TogglePlayState();
        }
        fHandled = TRUE;
        break;

    case ID_NEXTCMD:
    case ID_PREVCMD:
        if (wID == ID_PREVCMD)
        {
            m_iSSToolbarSelect = 3;
            m_fGoBack = TRUE;
        }
        else
        {
            m_iSSToolbarSelect = 4;
            m_fGoBack = FALSE;
        }
        _ShowNextSlide(m_fGoBack);
        fHandled = TRUE;
        break;

    case ID_CLOSECMD:
        m_iSSToolbarSelect = 6;
        _CloseSlideshowWindow();
        break;
    }
    return 0;
}


BOOL CPreviewWnd::CreateToolbar()
{
    // ensure that the common controls are initialized
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_BAR_CLASSES;
    InitCommonControlsEx(&icc);

    return (SLIDESHOW_MODE == m_dwMode) ? _CreateSlideshowToolbar() : _CreateViewerToolbar();
}

static const TBBUTTON    c_tbSlideShow[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0, ID_PLAYCMD,        TBSTATE_ENABLED  | TBSTATE_CHECKED,  TBSTYLE_CHECKGROUP, {0,0}, 0, 0},
    { 1, ID_PAUSECMD,       TBSTATE_ENABLED,                     TBSTYLE_CHECKGROUP, {0,0}, 0, 0},
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 2, ID_PREVCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
    { 3, ID_NEXTCMD,        TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
#if 0
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 5, ID_DELETECMD,      TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
#endif
    { 0, 0,                 TBSTATE_ENABLED,                     TBSTYLE_SEP,        {0,0}, 0, 0},
    { 4, ID_CLOSECMD,       TBSTATE_ENABLED,                     TBSTYLE_BUTTON,     {0,0}, 0, 0},
};

BOOL CPreviewWnd::_CreateSlideshowToolbar()
{
    DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                    CCS_NODIVIDER | CCS_NORESIZE |
                    TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS;

    HWND hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 0, 0,
                                 m_hWnd, NULL, _Module.GetModuleInstance(), NULL);

    _InitializeToolbar(hwndTB, IDB_SLIDESHOWTOOLBAR, IDB_SLIDESHOWTOOLBAR_HOT, IDB_SLIDESHOWTOOLBARHIGH, IDB_SLIDESHOWTOOLBARHIGH_HOT);

    TBBUTTON tbSlideShow[ARRAYSIZE(c_tbSlideShow)];
    memcpy(tbSlideShow, c_tbSlideShow, sizeof(c_tbSlideShow));

    // Add the buttons, and then set the minimum and maximum button widths.
    ::SendMessage(hwndTB, TB_ADDBUTTONS, (UINT)ARRAYSIZE(c_tbSlideShow), (LPARAM)tbSlideShow);

    LRESULT dwSize = ::SendMessage(hwndTB, TB_GETBUTTONSIZE, 0, 0);
    SIZE size = {0, HIWORD(dwSize)};
    ::SendMessage(hwndTB, TB_GETIDEALSIZE, 0, (LPARAM)&size);

    RECT rcClient;
    RECT rcToolbar = {0, 0, size.cx, size.cy};

    GetClientRect(&rcClient);
    AdjustWindowRectEx(&rcToolbar, dwStyle, FALSE, WS_EX_TOOLWINDOW);
    ::SetWindowPos(hwndTB, HWND_TOP, RECTWIDTH(rcClient)-RECTWIDTH(rcToolbar), 0,
                                     RECTWIDTH(rcToolbar), RECTHEIGHT(rcToolbar), 0);

//> REVIEW This is a feature that CyraR would like to get into Whistler, but it doesn't seem to work. I will investigate more after Beta1
//  LONG lStyle = ::GetWindowLong(hwndTB, GWL_EXSTYLE);
//  ::SetWindowLong(hwndTB, GWL_EXSTYLE, lStyle | WS_EX_LAYERED);
//  if (::SetLayeredWindowAttributes(hwndTB, 0, 0, 0) == 0)
//  {
//      void *lpMsgBuf;
//      ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
//                      NULL, GetLastError(), MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &lpMsgBuf, 0, NULL);
//
//      MessageBox((LPCTSTR)lpMsgBuf, L"Error", MB_OK | MB_ICONINFORMATION);
//      ::LocalFree(lpMsgBuf);
//  }

    m_ctlToolbar.SubclassWindow(hwndTB);
    ShowSSToolbar(FALSE, TRUE);

    return (NULL != hwndTB);
}

enum EViewerToolbarButtons
{
    PREVIMGPOS = 0,
    NEXTIMGPOS,
    VIEWSEPPOS,         // seperator

    BESTFITPOS,
    ACTUALSIZEPOS,
    SLIDESHOWPOS,
    IMAGECMDSEPPOS,     // seperator

    ZOOMINPOS,
    ZOOMEOUTPOS,
    SELECTPOS,
    CROPPOS,

    ROTATESEPPOS,       // seperator
    ROTATE90POS,
    ROTATE270POS,

// these are all TIFF related
    PAGESEPPOS,
    PREVPAGEPOS,
    PAGELISTPOS,
    NEXTPAGEPOS,
    ANNOTATEPOS,
    FREEHANDPOS,
    HIGLIGHTPOS,
    LINEPOS,
    FRAMEPOS,
    RECTPOS,
    TEXTPOS,
    NOTEPOS,

    PRINTSEPPOS,
    DELETEPOS,
    PRINTPOS,
    PROPERTIESPOS,
    SAVEASPOS,
    OPENPOS,

    HELPSEPPOS,
    HELPPOS,

    MAXPOS,
};

static const TBBUTTON c_tbViewer[] =
{
    // override default toolbar width for separators; iBitmap member of
    // TBBUTTON struct is a union of bitmap index & separator width

    { 0,    ID_PREVIMGCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 1,    ID_NEXTIMGCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_VIEWCMDSEP,      TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 5,    ID_BESTFITCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 6,    ID_ACTUALSIZECMD,   TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 8,    ID_SLIDESHOWCMD,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 2,    ID_ZOOMINCMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 3,    ID_ZOOMOUTCMD,      TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 4,    ID_SELECTCMD,       TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 23,   ID_CROPCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_ROTATESEP,       TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 12,   ID_ROTATE90CMD,     TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 11,   ID_ROTATE270CMD,    TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    ID_PAGECMDSEP,      TBSTATE_HIDDEN,     TBSTYLE_SEP,    {0,0}, 0, -1},   //tiff
    { 9,    ID_PREVPAGECMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { I_IMAGENONE, ID_PAGELIST, TBSTATE_HIDDEN,     BTNS_WHOLEDROPDOWN | BTNS_SHOWTEXT | BTNS_AUTOSIZE, {0,0}, 0, -1},//tiff
    { 10,   ID_NEXTPAGECMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 0,    ID_ANNOTATESEP,     TBSTATE_HIDDEN,     TBSTYLE_SEP,    {0,0}, 0, -1},   //tiff
    { 13,   ID_FREEHANDCMD,     TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 14,   ID_HIGHLIGHTCMD,    TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 15,   ID_LINECMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 16,   ID_FRAMECMD,        TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 17,   ID_RECTCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 18,   ID_TEXTCMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff
    { 19,   ID_NOTECMD,         TBSTATE_HIDDEN,     TBSTYLE_BUTTON, {0,0}, 0, -1},   //tiff

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 25,   ID_DELETECMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 20,   ID_PRINTCMD,        TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 21,   ID_PROPERTIESCMD,   TBSTATE_HIDDEN,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 22,   ID_SAVEASCMD,       TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
    { 26,   ID_OPENCMD,         TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},

    { 0,    0,                  TBSTATE_ENABLED,    TBSTYLE_SEP,    {0,0}, 0, -1},
    { 24,   ID_HELPCMD,         TBSTATE_ENABLED,    TBSTYLE_BUTTON, {0,0}, 0, -1},
};

void CPreviewWnd::_InitializeViewerToolbarButtons(HWND hwndToolbar, const TBBUTTON c_tbbuttons[], size_t c_nButtons, TBBUTTON tbbuttons[], size_t nButtons)
{
    ASSERT(c_nButtons == nButtons); // Sanity check.
    ASSERT(c_nButtons <= 100);      // Sanity check.

    // Determine if running RTL mirrored and initialize toolbar accordingly.
    if (!m_bRTLMirrored)
    {
        //
        // Init LTR.
        //

        memcpy(tbbuttons, c_tbbuttons, c_nButtons * sizeof(TBBUTTON));
    }
    else
    {
        //
        // Init RTL.
        //

        // Toolbar window inherits RTL style from parent hwnd, but we don't
        // want full-blown RTL.  We do want the icons to have their positions
        // reversed in the toolbar, but we don't want the button bitmaps to
        // get blitted backwards.  So we turn of RTL for the toolbar hwnd
        // and do a manual reorder of the buttons in RTL fashion.

        // Remove RTL style from toolbar hwnd.
        DWORD dwStyle = ::GetWindowLong(hwndToolbar, GWL_EXSTYLE);
        DWORD dwNewStyle = (dwStyle & ~WS_EX_LAYOUTRTL);
        ASSERT(dwStyle != dwNewStyle);  // Sanity check.
        ::SetWindowLong(hwndToolbar, GWL_EXSTYLE, dwNewStyle);

        // Reverse toolbar button order.
        size_t iFrom = nButtons - 1;
        size_t iTo = 0;
        while (iTo < iFrom)
        {
            memcpy(&tbbuttons[iTo], &c_tbbuttons[iFrom], sizeof(TBBUTTON));
            memcpy(&tbbuttons[iFrom], &c_tbbuttons[iTo], sizeof(TBBUTTON));
            iFrom--;
            iTo++;
        }
        if (iTo == iFrom)
        {
            memcpy(&tbbuttons[iTo], &c_tbbuttons[iFrom], sizeof(TBBUTTON));
        }
    }
}

inline UINT CPreviewWnd::_IndexOfViewerToolbarButton(EViewerToolbarButtons eButton)
{
    ASSERT(eButton > 0);

    if (!m_bRTLMirrored)
    {
        return eButton;
    }
    else
    {
        return MAXPOS - eButton - 1;
    }
}

BOOL CPreviewWnd::_CreateViewerToolbar()
{
    DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                    CCS_NODIVIDER | CCS_NORESIZE |
                    TBSTYLE_LIST | TBSTYLE_FLAT | TBSTYLE_TOOLTIPS;

    HWND hwndTB = CreateWindowEx(0, TOOLBARCLASSNAME, NULL, dwStyle, 0, 0, 0, 0,
                                 m_hWnd, NULL, _Module.GetModuleInstance(), NULL);

    _InitializeToolbar(hwndTB, IDB_TOOLBAR, IDB_TOOLBAR_HOT, IDB_TOOLBARHIGH, IDB_TOOLBARHIGH_HOT);

    TBBUTTON tbbuttons[ARRAYSIZE(c_tbViewer)];
    _InitializeViewerToolbarButtons(hwndTB, c_tbViewer, ARRAYSIZE(c_tbViewer), tbbuttons, ARRAYSIZE(tbbuttons));

    if (CONTROL_MODE == m_dwMode)
    {
        ASSERT(ID_BESTFITCMD==tbbuttons[_IndexOfViewerToolbarButton(BESTFITPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(BESTFITPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ACTUALSIZECMD==tbbuttons[_IndexOfViewerToolbarButton(ACTUALSIZEPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ACTUALSIZEPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_SLIDESHOWCMD==tbbuttons[_IndexOfViewerToolbarButton(SLIDESHOWPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(SLIDESHOWPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ZOOMINCMD==tbbuttons[_IndexOfViewerToolbarButton(ZOOMINPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ZOOMINPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ZOOMOUTCMD==tbbuttons[_IndexOfViewerToolbarButton(ZOOMEOUTPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ZOOMEOUTPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_SAVEASCMD==tbbuttons[_IndexOfViewerToolbarButton(SAVEASPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(SAVEASPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_DELETECMD==tbbuttons[_IndexOfViewerToolbarButton(DELETEPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(DELETEPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_OPENCMD==tbbuttons[_IndexOfViewerToolbarButton(OPENPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(OPENPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_HELPCMD==tbbuttons[_IndexOfViewerToolbarButton(HELPPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(HELPPOS)].fsState = TBSTATE_HIDDEN;

        // remove a few seperators too:
        tbbuttons[_IndexOfViewerToolbarButton(VIEWSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(IMAGECMDSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(PRINTSEPPOS)].fsState = TBSTATE_HIDDEN;
        tbbuttons[_IndexOfViewerToolbarButton(HELPSEPPOS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_fHidePrintBtn)
    {
        ASSERT(ID_PRINTCMD==tbbuttons[_IndexOfViewerToolbarButton(PRINTPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(PRINTPOS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_fDisableEdit)
    {
        ASSERT(ID_ROTATESEP == tbbuttons[_IndexOfViewerToolbarButton(ROTATESEPPOS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATESEPPOS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ROTATE90CMD == tbbuttons[_IndexOfViewerToolbarButton(ROTATE90POS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATE90POS)].fsState = TBSTATE_HIDDEN;

        ASSERT(ID_ROTATE270CMD == tbbuttons[_IndexOfViewerToolbarButton(ROTATE270POS)].idCommand);
        tbbuttons[_IndexOfViewerToolbarButton(ROTATE270POS)].fsState = TBSTATE_HIDDEN;
    }

    if (m_bRTLMirrored)
    {
        UINT uTmp = tbbuttons[_IndexOfViewerToolbarButton(PREVIMGPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(PREVIMGPOS)].iBitmap = tbbuttons[_IndexOfViewerToolbarButton(NEXTIMGPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(NEXTIMGPOS)].iBitmap = uTmp;

        uTmp = tbbuttons[_IndexOfViewerToolbarButton(PREVPAGEPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(PREVPAGEPOS)].iBitmap = tbbuttons[_IndexOfViewerToolbarButton(NEXTPAGEPOS)].iBitmap;
        tbbuttons[_IndexOfViewerToolbarButton(NEXTPAGEPOS)].iBitmap = uTmp;
    }

    // Add the buttons, and then set the minimum and maximum button widths.
    ::SendMessage(hwndTB, TB_ADDBUTTONS, ARRAYSIZE(tbbuttons), (LPARAM)tbbuttons);

    // we just created the toolbar so we are now in the hidden state of the multipage buttons.
    m_dwMultiPageMode = MPCMD_HIDDEN;
    m_fCanAnnotate = FALSE;
    m_fCanCrop = FALSE;

    m_ctlToolbar.SubclassWindow(hwndTB);

    return (NULL != hwndTB);
}


void CPreviewWnd::_InitializeToolbar(HWND hwndTB, int idLow, int idLowHot, int idHigh, int idHighHot)
{
    int cxBitmap = 16, cyBitmap = 16;

    ::SendMessage(hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);
    ::SendMessage (hwndTB, TB_SETEXTENDEDSTYLE, 0, TBSTYLE_EX_HIDECLIPPEDBUTTONS | TBSTYLE_EX_MIXEDBUTTONS | TBSTYLE_EX_DOUBLEBUFFER);

    // Sets the size of the TBBUTTON structure.
    ::SendMessage(hwndTB, TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    // Set the maximum number of text rows and bitmap size.
    ::SendMessage(hwndTB, TB_SETMAXTEXTROWS, 1, 0);

    int nDepth = SHGetCurColorRes();
    HIMAGELIST himl = ImageList_LoadImage(_Module.GetModuleInstance(), 
                                          (nDepth > 8) ? MAKEINTRESOURCE(idHigh) : MAKEINTRESOURCE(idLow), 
                                          cxBitmap, 0, RGB(0, 255, 0), IMAGE_BITMAP, 
                                          (nDepth > 8) ? LR_CREATEDIBSECTION : LR_DEFAULTCOLOR);
    ::SendMessage(hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

    HIMAGELIST himlHot = ImageList_LoadImage(_Module.GetModuleInstance(), 
                                             (nDepth > 8) ? MAKEINTRESOURCE(idHighHot) : MAKEINTRESOURCE(idLowHot), 
                                              cxBitmap, 0, RGB(0, 255, 0), IMAGE_BITMAP, 
                                             (nDepth > 8) ? LR_CREATEDIBSECTION : LR_DEFAULTCOLOR);
    ::SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, (LPARAM)himlHot);

}

LRESULT CPreviewWnd::OnPrintClient(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    COLORREF bgClr = m_ctlPreview.GetBackgroundColor();

    RECT rcFill;
    GetClientRect(&rcFill);
    SHFillRectClr((HDC)wParam, &rcFill, bgClr);

    return TRUE;
}

LRESULT CPreviewWnd::OnNeedText(int , LPNMHDR pnmh, BOOL&)
{
    TOOLTIPTEXT *pTTT = (TOOLTIPTEXT *)pnmh;

    // tooltip text messages have the same string ID as the control ID
    pTTT->lpszText = MAKEINTRESOURCE(pTTT->hdr.idFrom);
    pTTT->hinst = _Module.GetModuleInstance();

    // Except in Control Mode due to a DUI Web View bug that's too hard to fix for Whistler...
    if (CONTROL_MODE == m_dwMode)
    {
        // keyboard accelerators are broken, so swap IDs around for the few that display them
        static const struct {
            UINT idCommand;
            UINT idsNewName;
        } map[] = {
            { ID_PRINTCMD, IDS_PRINTCMD },
            { ID_ROTATE90CMD, IDS_ROTATE90CMD },
            { ID_ROTATE270CMD, IDS_ROTATE270CMD }};

        for (int i = 0 ; i < ARRAYSIZE(map) ; i++)
        {
            if (map[i].idCommand == pTTT->hdr.idFrom)
            {
                pTTT->lpszText = MAKEINTRESOURCE(map[i].idsNewName);
                break;
            }
        }
    }

    return TRUE;
}

LRESULT CPreviewWnd::OnDropDown(int id, LPNMHDR pnmh, BOOL&)
{
    LPNMTOOLBAR pnmTB = (LPNMTOOLBAR)pnmh;
    switch (pnmTB->iItem)
    {
        case ID_PAGELIST:
            _DropDownPageList (pnmTB);
            break;

        default:
            return TRUE;
    }
    return FALSE;

}

void CPreviewWnd::_DropDownPageList(LPNMTOOLBAR pnmTB)
{
    HMENU hmenuPopup = CreatePopupMenu();
    if (hmenuPopup)
    {
        for (DWORD i = 1; i <= m_pImageData->_cImages; i++)
        {
            TCHAR szBuffer[10];
            wsprintf(szBuffer, TEXT("%d"), i);

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.wID = i;
            mii.dwTypeData = szBuffer;

            InsertMenuItem (hmenuPopup, i-1, TRUE, &mii);
        }

        RECT rc;
        ::SendMessage(pnmTB->hdr.hwndFrom, TB_GETRECT, (WPARAM)pnmTB->iItem, (LPARAM)&rc);
        ::MapWindowPoints(pnmTB->hdr.hwndFrom, HWND_DESKTOP, (LPPOINT)&rc, 2);

        TPMPARAMS tpm = { 0};
        tpm.cbSize = sizeof(TPMPARAMS);
        tpm.rcExclude = rc;

        BOOL bRet = ::TrackPopupMenuEx(hmenuPopup,
                                       TPM_RETURNCMD | TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_VERTICAL | TPM_NONOTIFY,
                                       rc.left, rc.bottom,
                                       m_hWnd, &tpm);
        if (bRet)
        {
            if (m_fDirty)
            {
                m_ctlPreview.CommitAnnotations();
            }
            m_pImageData->SelectPage((LONG)bRet-1);
            _UpdateImage();

            _SetMultipageCommands();
        }

        DestroyMenu(hmenuPopup);
    }
}

void CPreviewWnd::SetNotify(CEvents * pEvents)
{
    m_pEvents = pEvents;
}

void CPreviewWnd::SetPalette(HPALETTE hpal)
{
    m_hpal = hpal;
}

BOOL CPreviewWnd::GetPrintable()
{
    return m_fPrintable;
}

LRESULT CPreviewWnd::OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // REVIEW: Shouldn't this just be translated into a command?

    // this message is ALWAYS forwarded to the zoom window
    m_ctlPreview.SendMessage(uMsg, wParam, lParam);

    // Since we know that the mouse wheel will either ZoomIn or ZoomOut lets update the buttons if we are in Window Mode.
    if (WINDOW_MODE == m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(!m_ctlPreview.IsBestFit(), 0));
    }

    return 0;
}

BOOL CPreviewWnd::OnNonSlideShowTab()
{
    BOOL fHandled = FALSE;

    if ((SLIDESHOW_MODE != m_dwMode) && m_fShowToolbar)
    {
        if (GetFocus() != m_ctlToolbar.m_hWnd)
        {
            m_ctlToolbar.SetFocus();
            m_ctlToolbar.SetActiveWindow();
            m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
            m_iSSToolbarSelect = 0;
            fHandled = TRUE;
        }
    }

    return fHandled;
}

// Forwards WM_KEYUP and WM_KEYDOWN events to the zoom window but only if they are keys
// that the zoom window cares about.
// Activates the slideshow toolbar if needed
LRESULT CPreviewWnd::OnKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    MSG msg;
    msg.hwnd = m_hWnd;
    msg.message = uMsg;
    msg.wParam = wParam;
    msg.lParam = lParam;
    GetCursorPos (&msg.pt);
    fHandled = FALSE;
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (WM_KEYDOWN == uMsg)
        {
            switch (wParam)
            {
                case VK_TAB:
                    OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                    ShowSSToolbar(TRUE);
                    KillTimer(TIMER_TOOLBAR);
                    m_ctlToolbar.SetFocus();
                    m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
                    m_iSSToolbarSelect = 0;
                    fHandled = TRUE;
                    break;
                case VK_SPACE:
                    ShowSSToolbar(!m_fPaused); // if we are unpausing, hide the toolbar if it's shown.  if we are pausing, show the toolbar
                    OnSlideshowCommand(0, m_fPaused ? ID_PLAYCMD : ID_PAUSECMD, NULL, fHandled);
                    break;
                case VK_PRIOR: // PAGEUP
                case VK_UP:
                case VK_LEFT:
                case VK_BACK: // BACKSPACE
                    OnSlideshowCommand(0, ID_PREVCMD, NULL, fHandled);
                    break;
                case VK_NEXT: // PAGEDOWN
                case VK_RIGHT:
                case VK_DOWN:
                case VK_RETURN: // ENTER
                    OnSlideshowCommand(0, ID_NEXTCMD, NULL, fHandled);
                    break;
                case VK_DELETE:
                    _DeleteCurrentSlide();
                    fHandled = TRUE;
                    break;
                case 'K':
                    if (0x8000 & GetKeyState(VK_CONTROL))
                    {
                        OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                        Rotate(90);
                        fHandled = TRUE;
                    }
                    break;
                case 'L':
                    if (0x8000 & GetKeyState(VK_CONTROL))
                    {
                        OnSlideshowCommand(0, ID_PAUSECMD, NULL, fHandled);
                        Rotate(270);
                        fHandled = TRUE;
                    }
                    break;
                case VK_ESCAPE:
                    PostMessage(m_fExitApp ? WM_QUIT : WM_CLOSE, 0, 0);
                    fHandled = TRUE;
                    break;
            }
        }
    }
    else if (!TranslateAccelerator(&msg))   // Only translate accelerators in the non-slideshow case
                                            // Slideshow keys are handled explicitly above
    {
        switch (wParam)
        {
            case VK_SHIFT:
            case VK_CONTROL:
            case VK_PRIOR:
            case VK_NEXT:
            case VK_HOME:
            case VK_END:
            // these are forwarded to the zoom window
                m_ctlPreview.SendMessage(uMsg, wParam, lParam);
                break;

            case VK_TAB:
                fHandled = OnNonSlideShowTab();
                break;

            case VK_ESCAPE:
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                _UpdateButtons(NOBUTTON);
                fHandled = TRUE;
                break;
        }
    }
    return 0;
}

// OnTBKeyEvent
//

LRESULT CPreviewWnd::OnTBKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    fHandled = FALSE;

    if (SLIDESHOW_MODE == m_dwMode && m_fToolbarHidden)
    {
        ShowSSToolbar(TRUE);
        m_ctlToolbar.SetFocus();
        m_ctlToolbar.SendMessage(TB_SETHOTITEM, 0, 0);
        m_iSSToolbarSelect = 0;
        fHandled = TRUE;
    }
    else
    {
        switch (wParam)
        {
        case VK_ESCAPE:
            if (WM_KEYDOWN == uMsg)
            {
                if (SLIDESHOW_MODE == m_dwMode)
                {
                    PostMessage(m_fExitApp ? WM_QUIT : WM_CLOSE, 0, 0);
                }
                else
                {
                    m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                    _UpdateButtons(NOBUTTON);
                    SetFocus();
                    SetActiveWindow();
                }
            }
            break;

        case VK_SHIFT:
        case VK_CONTROL:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_HOME:
        case VK_END:
            // these are forwarded to the zoom window
            m_ctlPreview.SendMessage(uMsg, wParam, lParam);
            break;

        case VK_LEFT:
        case VK_RIGHT:
            if (WM_KEYDOWN == uMsg)
            {
                int iSel = (int)m_ctlToolbar.SendMessage(TB_GETHOTITEM, 0, 0);
                int iSize = (int)m_ctlToolbar.SendMessage(TB_BUTTONCOUNT, 0, 0);
                int iStepSize = (wParam == VK_RIGHT) ? 1 : iSize - 1; // ((pos + (size - 1))  % size) == left by 1
                if (iSel != -1)
                {
                    m_iSSToolbarSelect = iSel;
                }
                TBBUTTON tb = {0};
                do
                {
                    m_iSSToolbarSelect = (m_iSSToolbarSelect + iStepSize) % iSize;
                    m_ctlToolbar.SendMessage(TB_GETBUTTON, m_iSSToolbarSelect, (LPARAM)&tb);
                }
                while ((tb.fsStyle & TBSTYLE_SEP) || (tb.fsState & TBSTATE_HIDDEN) || !(tb.fsState & TBSTATE_ENABLED)); // don't stop on the separators
                m_ctlToolbar.SendMessage(TB_SETHOTITEM, m_iSSToolbarSelect, 0);
                fHandled = TRUE;
            }
            break;

        case VK_RETURN:
        case VK_SPACE:
            if ((WM_KEYDOWN == uMsg) && (SLIDESHOW_MODE == m_dwMode))
            {
                // to "press" the button, get its command id and sendmessage on it
                // TB_PRESSBUTTON doesn't work here, don't know why.
                // m_ctlToolbar.SendMessage(TB_PRESSBUTTON, m_iSSToolbarSelect, MAKELONG(TRUE, 0));
                TBBUTTON tbbutton;
                if (m_ctlToolbar.SendMessage(TB_GETBUTTON, m_iSSToolbarSelect, (LPARAM)&tbbutton))
                {
                    OnSlideshowCommand(0, (WORD)tbbutton.idCommand, NULL, fHandled);
                }
                fHandled = TRUE;
            }
            break;

        case VK_TAB:
            if ((WM_KEYDOWN == uMsg) && (CONTROL_MODE != m_dwMode))
            {
                // move focus back to the previewwnd
                SetFocus();
                fHandled = TRUE;
                ShowSSToolbar(FALSE);
                SetTimer(TIMER_TOOLBAR, m_uTimeout);
            }
            break;

        default:
            break;
        }
    }

    return 0;
}

LRESULT CPreviewWnd::OnSysCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    fHandled = FALSE;
    
    if ((SLIDESHOW_MODE == m_dwMode) &&
        ((SC_MONITORPOWER == wParam) || (SC_SCREENSAVE == wParam)))
    {
        fHandled = TRUE;
    }

    return 0;
}

HRESULT CPreviewWnd::_PreviewFromStream(IStream *pStream, UINT iItem, BOOL fUpdateCaption)
{
    IRunnableTask * pTask;

    if (fUpdateCaption)
    {
        // set the caption here in case decode fails
        STATSTG stat;
        if (SUCCEEDED(pStream->Stat(&stat, 0)))
        {
            SetCaptionInfo(stat.pwcsName);
            CoTaskMemFree(stat.pwcsName);
        }
        else
        {
            SetCaptionInfo(NULL);
        }
    }

    HRESULT hr = CDecodeTask::Create(pStream, NULL, iItem, m_pImageFactory, m_hWnd, &pTask);
    if (SUCCEEDED(hr))
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
        hr = m_pTaskScheduler->AddTask(pTask, toid, 0, ITSAT_DEFAULT_PRIORITY);
        pTask->Release();
    }
    return hr;
}

HRESULT CPreviewWnd::_PreviewFromFile(LPCTSTR pszFile, UINT iItem, BOOL fUpdateCaption)
{
    IRunnableTask * pTask;

    if (fUpdateCaption)
    {
        // set the caption here in case decode fails
        SetCaptionInfo(pszFile);
    }

    HRESULT hr = CDecodeTask::Create(NULL, pszFile, iItem, m_pImageFactory, m_hWnd, &pTask);
    if (SUCCEEDED(hr))
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
        hr = m_pTaskScheduler->AddTask(pTask, toid, 0, ITSAT_DEFAULT_PRIORITY);
        pTask->Release();
    }

    return hr;
}

#define SLIDESHOW_CURSOR_NOTBUSY    0x0
#define SLIDESHOW_CURSOR_BUSY       0x1
#define SLIDESHOW_CURSOR_HIDDEN     0x2
#define SLIDESHOW_CURSOR_NORMAL     0x3
#define SLIDESHOW_CURSOR_CURRENT    0x4

void CPreviewWnd::SetCursorState(DWORD dwType)
{
    switch (dwType)
    {
    case SLIDESHOW_CURSOR_NOTBUSY:
        KillTimer(TIMER_BUSYCURSOR);
        if (m_fBusy) // ignore multiple NOTBUSY, which we receive for the precaching
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
            m_fBusy = FALSE;
        }
        break;
    case SLIDESHOW_CURSOR_BUSY:
        if (!m_fBusy)
        {
            m_hCurrent = LoadCursor(NULL, IDC_APPSTARTING);
            m_hCurOld = SetCursor(m_hCurrent);
            m_fBusy = TRUE;
        }
        break;
    case SLIDESHOW_CURSOR_HIDDEN:
        m_hCurOld = NULL;
        if (!m_fBusy)
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
        }
        break;
    case SLIDESHOW_CURSOR_NORMAL:
        m_hCurOld = LoadCursor(NULL, IDC_ARROW);
        if (!m_fBusy)
        {
            m_hCurrent = m_hCurOld;
            SetCursor(m_hCurrent);
        }
        break;
    case SLIDESHOW_CURSOR_CURRENT:
        SetCursor(m_hCurrent);
        break;
    }
}

LRESULT CPreviewWnd::OnTimer(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (TIMER_ANIMATION == wParam)
    {
        KillTimer(TIMER_ANIMATION);
        if (m_pImageData && m_pImageData->IsAnimated() && _ShouldDisplayAnimations()) // might have switched pages between timer calls
        {
            if (m_pImageData->NextFrame())
            {
                SetTimer(TIMER_ANIMATION, m_pImageData->GetDelay());

                // paint the new image
                _UpdateImage();
            }
        }
    }
    else if (TIMER_DATAOBJECT == wParam)
    {
        KillTimer(TIMER_DATAOBJECT);    // on shot timer
        if (_pdtobj)
        {
            PreviewItemsFromUnk(_pdtobj);
            ATOMICRELEASE(_pdtobj);
        }
    }
    else if (TIMER_BUSYCURSOR == wParam)
    {
        SetCursorState(SLIDESHOW_CURSOR_BUSY);
    }
    else if (SLIDESHOW_MODE == m_dwMode)
    {
        if (TIMER_SLIDESHOW == wParam)
        {
            _ShowNextSlide(FALSE);  // always go forward?
        }
        else if (TIMER_TOOLBAR == wParam && !m_fIgnoreUITimers)
        {
            KillTimer(TIMER_TOOLBAR);
            ShowSSToolbar(FALSE);
        }
    }

    return 0;
}

void CPreviewWnd::ShowSSToolbar(BOOL bShow, BOOL fForce /*=FALSE*/)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (fForce)
        {
            POINT pt;
            RECT  rc;

            GetCursorPos(&pt);
            GetWindowRect(&rc);
            if (PtInRect(&rc, pt))
            {
                g_x = pt.x;
                g_y = pt.y;
            }
        }

        if (!bShow)
        {
            if (!m_fToolbarHidden || fForce)
            {
                //AnimateWindow(m_ctlToolbar.m_hWnd, 200, AW_VER_NEGATIVE | AW_SLIDE | AW_HIDE);
                m_ctlToolbar.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
                m_fToolbarHidden = TRUE;
                m_ctlToolbar.SendMessage(TB_SETHOTITEM, -1, 0);
                SetCursorState(SLIDESHOW_CURSOR_HIDDEN);
            }
        }
        else
        {
            KillTimer(TIMER_TOOLBAR);
            if (m_fToolbarHidden || fForce)
            {
                //AnimateWindow(m_ctlToolbar.m_hWnd, 200, AW_VER_POSITIVE | AW_SLIDE | AW_ACTIVATE);
                m_ctlToolbar.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
                m_fToolbarHidden = FALSE;
                SetCursorState(SLIDESHOW_CURSOR_NORMAL);
            }
            SetTimer(TIMER_TOOLBAR, m_uTimeout);
        }
    }
}

void CPreviewWnd::OnDraw(HDC hdc)
{
    if (m_fCropping)
    {
        CSelectionTracker tracker;
        _SetupCroppingTracker(tracker);

        CRect rectImage(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);
        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rectImage, 2);

        CRect rectCrop = m_rectCropping;
        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rectCrop, 2);

        HRGN hrgn = ::CreateRectRgn(0, 0, 0, 0);
        if (hrgn != NULL)
        {
            HRGN hrgnImage = ::CreateRectRgnIndirect(rectImage);
            if (hrgnImage != NULL)
            {
                HRGN hrgnCrop = ::CreateRectRgnIndirect(rectCrop);
                if (hrgnCrop != NULL)
                {
                    if (ERROR != ::CombineRgn(hrgn, hrgnImage, hrgnCrop, RGN_DIFF))
                    {
                        ::InvertRgn(hdc, hrgn);
                    }
                    ::DeleteObject(hrgnCrop);
                }
                ::DeleteObject(hrgnImage);
            }
            ::DeleteObject(hrgn);
        }

        tracker.Draw(hdc);
    }
    else
    {
        if (m_fAnnotating)
        {
            if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
            {
                CSelectionTracker tracker;
                _SetupAnnotatingTracker(tracker);

                tracker.Draw(hdc);
            }
        }
    }
}

void CPreviewWnd::OnDrawComplete()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (!m_fPaused)
            SetTimer(TIMER_SLIDESHOW, m_uTimeout);

        SetCursorState(SLIDESHOW_CURSOR_NOTBUSY);
    }
}

BOOL CPreviewWnd::OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (uMsg == WM_LBUTTONDOWN)
        {
            _ShowNextSlide(FALSE); // advance the slide (param is "go back?")

            return TRUE;
        }
    }
    else
    {
        if (m_fCropping)
            return _OnMouseDownForCropping(uMsg, wParam, lParam);
        else
            return _OnMouseDownForAnnotating(uMsg, wParam, lParam);
    }
    return FALSE;
}

BOOL CPreviewWnd::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        int xPos = GET_X_LPARAM(lParam);
        int yPos = GET_Y_LPARAM(lParam);
        int dx = xPos > g_x ? xPos - g_x : g_x - xPos;
        int dy = yPos > g_y ? yPos - g_y : g_y - yPos;

        if (dx > 10 || dy > 10)
        {
            ShowSSToolbar(TRUE);
        }

        g_x = xPos;
        g_y = yPos;
    }
    return TRUE;
}

LRESULT CPreviewWnd::OnTBMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_fTBTrack = FALSE;
        ShowSSToolbar(TRUE);
    }
    fHandled = FALSE;
    return 0;
}

LRESULT CPreviewWnd::OnTBMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (!m_fTBTrack)
        {
            TRACKMOUSEEVENT tme;

            tme.cbSize = sizeof(tme);
            tme.dwFlags = TME_LEAVE;
            tme.hwndTrack = m_ctlToolbar.m_hWnd;
            TrackMouseEvent(&tme);

            ShowSSToolbar(TRUE);
            KillTimer(TIMER_TOOLBAR); // we keep the toolbar down for as long as mouse is over it
            m_fTBTrack = TRUE;
        }
    }
    fHandled = FALSE;
    return 0;
}

BOOL CPreviewWnd::OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (m_fToolbarHidden)
        {
            SetCursorState(SLIDESHOW_CURSOR_HIDDEN);
        }
        else
        {
            SetCursorState(SLIDESHOW_CURSOR_NORMAL);
        }
        return TRUE;
    }
    else if (m_fAnnotating)
    {
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
        {
            CSelectionTracker tracker;
            _SetupAnnotatingTracker(tracker);

            if (tracker.SetCursor(m_ctlPreview.m_hWnd, lParam))
                return TRUE;
        }
        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return TRUE;
    }
    else if (m_fCropping)
    {
        CSelectionTracker tracker;
        _SetupCroppingTracker(tracker);

        if (tracker.SetCursor(m_ctlPreview.m_hWnd, lParam))
            return TRUE;

        SetCursor(LoadCursor(NULL, IDC_ARROW));
        return TRUE;
    }
    return FALSE;
}

BOOL CPreviewWnd::GetColor(COLORREF * pref)
{
    *pref = 0; // black
    if (SLIDESHOW_MODE == m_dwMode)
    {
        return TRUE;
    }
    return FALSE;
}

BOOL CPreviewWnd::OnSetColor(HDC hdc)
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        SetBkColor(hdc, 0); // black
        SetTextColor(hdc, 0xffffff); // white
        return TRUE;
    }
    return FALSE;
}

// IObjectWithSite
HRESULT CPreviewWnd::SetSite(IUnknown *punk)
{
    IUnknown_Set(&m_punkSite, punk);
    if (m_pcwndSlideShow)
    {
        m_pcwndSlideShow->SetSite(punk);
    }
    return S_OK;
}

// This function take the name of the file being previewed and converts it into a
// title for the Full Screen Preview window.  In converting the title it take into
// account user preference settings for how to display the filename.
void CPreviewWnd::SetCaptionInfo(LPCTSTR pszPath)
{
    TCHAR szTitle[MAX_PATH] = TEXT("");
    TCHAR szDisplayName[MAX_PATH] = TEXT("");
    SHFILEINFO sfi = {0};
    //
    // Default to pszPath for the caption
    // pszPath is non-null before the decode is attempted
    if (pszPath)
    {
        if (SHGetFileInfo(pszPath, 0, &sfi, sizeof(sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES))
        {
            StrCpyN(szTitle, sfi.szDisplayName, ARRAYSIZE(szTitle));
            StrCatBuff(szTitle, TEXT(" - "), ARRAYSIZE(szTitle));
        }
    }

    TCHAR szApp[64];
    szApp[0] = 0;
    LoadString(_Module.GetModuleInstance(), IDS_PROJNAME, szApp, ARRAYSIZE(szApp));
    StrCatBuff(szTitle, szApp, ARRAYSIZE(szTitle));

    SetWindowText(szTitle);
}

LRESULT CPreviewWnd::OnDestroy(UINT , WPARAM , LPARAM , BOOL& fHandled)
{
    RevokeDragDrop(m_hWnd);
    _RegisterForChangeNotify(FALSE);
    FlushBitmapMessages();
    fHandled = FALSE;

    // Make sure we don't leak icons
    ReplaceWindowIcon(m_hWnd, ICON_SMALL, NULL);
    ReplaceWindowIcon(m_hWnd, ICON_BIG, NULL);

    // release the image lists used by the toolbar.
    HWND hwndTB = m_ctlToolbar.m_hWnd;
    HIMAGELIST himl = (HIMAGELIST)::SendMessage(hwndTB, TB_GETHOTIMAGELIST, 0, 0);
    ::SendMessage(hwndTB, TB_SETHOTIMAGELIST, 0, NULL);
    ImageList_Destroy(himl);

    himl = (HIMAGELIST)::SendMessage(hwndTB, TB_GETIMAGELIST, 0, 0);
    ::SendMessage(hwndTB, TB_SETIMAGELIST, 0, NULL);
    ImageList_Destroy(himl);

    if (WINDOW_MODE == m_dwMode)
    {
        WINDOWPLACEMENT wp;
        wp.length = sizeof(wp);

        if (GetWindowPlacement(&wp))
        {
            HKEY hk;
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_SHIMGVW, 0, NULL,
                                                 REG_OPTION_NON_VOLATILE, KEY_WRITE,
                                                 NULL, &hk, NULL))
            {
                RegSetValueEx(hk, REGSTR_BOUNDS, NULL, REG_BINARY,
                                (BYTE*)&wp.rcNormalPosition, sizeof(wp.rcNormalPosition));

                BOOL fIsMaximized = (wp.showCmd == SW_SHOWMAXIMIZED);
                RegSetValueEx(hk, REGSTR_MAXIMIZED,  NULL, REG_BINARY,
                                (BYTE*)&fIsMaximized, sizeof(fIsMaximized));

                RegCloseKey(hk);
            }
        }

        PostQuitMessage(0);
    }

    return 0;
}

HRESULT CPreviewWnd::GetCurrentIDList(LPITEMIDLIST *ppidl)
{
    HRESULT hr = _GetItem(m_iCurSlide, ppidl);
    if (FAILED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = PathFromImageData(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            hr = SHILCreateFromPath(szPath, ppidl, NULL);
        }
    }
    return hr;
}

void CPreviewWnd::MenuPoint(LPARAM lParam, int *px, int *py)
{
    if (-1 == lParam)
    {
        // message is from the keyboard, figure out where to place the window
        RECT rc;
        ::GetWindowRect(m_hWnd, &rc);
        *px = ((rc.left + rc.right) / 2);
        *py = ((rc.top + rc.bottom) / 2);
    }
    else
    {
        *px = GET_X_LPARAM(lParam);
        *py = GET_Y_LPARAM(lParam);
    }
}

#define ID_FIRST            1               // Context Menu ID's
#define ID_LAST             0x7fff

LRESULT CPreviewWnd::OnContextMenu(UINT , WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (!m_fAllowContextMenu)
        return 0;

    if (m_fCanAnnotate && m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        HMENU hpopup = CreatePopupMenu();
        if (hpopup)
        {
            CComBSTR bstrDelete;
            CComBSTR bstrProperties;
            if (bstrDelete.LoadString(IDS_DELETECMD) &&
                bstrProperties.LoadString(IDS_PROPERTIESCMD))
            {
                if (AppendMenu(hpopup, MF_STRING, ID_DELETECMD, bstrDelete) &&
                    AppendMenu(hpopup, MF_STRING, ID_PROPERTIESCMD, bstrProperties))
                {
                    int x, y;
                    MenuPoint(lParam, &x, &y);
                    TrackPopupMenu(hpopup, TPM_RIGHTBUTTON | TPM_LEFTALIGN, x, y, 0, m_hWnd, NULL);
                }
            }
            DestroyMenu(hpopup);
        }
        return 0;
    }

    LPITEMIDLIST pidl;
    HRESULT hr = GetCurrentIDList(&pidl); // gets the dynamically generated title for this window
    if (SUCCEEDED(hr))
    {
        IContextMenu *pcm;
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            HMENU hpopup = CreatePopupMenu();
            if (hpopup)
            {
                // SetSite required if you want in place navigation
                IUnknown_SetSite(pcm, SAFECAST(this, IServiceProvider *));
                hr = pcm->QueryContextMenu(hpopup, 0, ID_FIRST, ID_LAST, CMF_NORMAL);
                if (SUCCEEDED(hr))
                {
                    int x, y;
                    MenuPoint(lParam, &x, &y);
                    ASSERT(_pcm3 == NULL);
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm3));
                    // if there's a separator after "copy", remove it
                    UINT uCopy = GetMenuIndexForCanonicalVerb(hpopup, pcm,ID_FIRST, L"copy");
                    if (uCopy != -1)
                    {
                        UINT uState = GetMenuState(hpopup, uCopy+1, MF_BYPOSITION);
                        if (-1 != uState && (uState & MF_SEPARATOR))
                        {
                            RemoveMenu(hpopup, uCopy+1, MF_BYPOSITION);
                        }
                    }
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"link");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"cut");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"copy");
                                        // the shell may have added a static Preview verb
                    ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, L"open");



                    if (!m_fPaused)
                    {
                        TogglePlayState();
                    }

                    if (SLIDESHOW_MODE == m_dwMode)
                    {
                        m_fIgnoreUITimers = TRUE;
                    }

                    int idCmd = TrackPopupMenu(hpopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                           x, y, 0, m_hWnd, NULL);

                    ATOMICRELEASE(_pcm3);

                    if (idCmd > 0)
                    {
                        CMINVOKECOMMANDINFO cmdInfo =
                        {
                            sizeof(cmdInfo),
                            0,
                            m_hWnd,
                            (LPSTR)MAKEINTRESOURCE(idCmd - ID_FIRST),
                            NULL,
                            NULL,
                            SW_NORMAL
                        };
                        TCHAR szCommandString[40] = TEXT("");

                        ContextMenu_GetCommandStringVerb(pcm, idCmd - ID_FIRST, szCommandString, ARRAYSIZE(szCommandString));
                            
                        if (lstrcmpi(szCommandString, TEXT("edit")) == 0)
                        {
                            hr = _SaveIfDirty(TRUE);
                            if (S_OK != hr)
                            {
                                hr = E_ABORT;
                            }                           
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lstrcmpi(szCommandString, TEXT("print")) == 0)
                            {
                                _RefreshSelection(FALSE);
                                _InvokePrintWizard();
                            }
                            else
                            {
                                hr = pcm->InvokeCommand(&cmdInfo);
                            }
                        }
                        if (SUCCEEDED(hr))
                        {
                            if (lstrcmpi(szCommandString, TEXT("delete")) == 0)
                            {
                                _RemoveFromArray(m_iCurSlide);
                                _ShowNextSlide(FALSE);
                            }
                            else if (lstrcmpi(szCommandString, TEXT("edit")) == 0)
                            {
                                m_fDirty = FALSE;
                                m_fNoRestore = TRUE;

                                // RAID 414238: Image Preview Control
                                //  Context menu "&Edit" causes image preview window
                                //  to close, wrecking Explorer when in 'control mode'.
                                if (m_dwMode != CONTROL_MODE)
                                {
                                    PostMessage(WM_CLOSE, 0, 0);
                                }
                            }                           
                        }
                    }

                    if (SLIDESHOW_MODE == m_dwMode)
                    {
                        SetTimer(TIMER_TOOLBAR, m_uTimeout);
                        m_fIgnoreUITimers = FALSE;
                    }
                }
                IUnknown_SetSite(pcm, NULL);
                DestroyMenu(hpopup);
            }
            pcm->Release();
        }
        ILFree(pidl);
    }
    return 0;
}

int ClearCB(void *p, void *pData)
{
    SHFree(p);
    return 1;
}

void CPreviewWnd::_ClearDPA()
{
    if (m_ppidls)
    {
        for (UINT i = 0; i < m_cItems; i++)
            ILFree(m_ppidls[i]);

        CoTaskMemFree(m_ppidls);
        m_ppidls = NULL;
    }
    m_cItems = 0;
    m_iCurSlide = 0;
}

HRESULT CPreviewWnd::SetWallpaper(BSTR pszPath)
{
    return SUCCEEDED(SetWallpaperHelper(pszPath)) ? S_OK : S_FALSE;
}


HRESULT CPreviewWnd::StartSlideShow(IUnknown *punkToView)
{
    HRESULT hr = E_FAIL;

    if (NULL == punkToView)
        punkToView = m_punkSite;

    if (SLIDESHOW_MODE == m_dwMode)
    {
        // these are required for slideshow
        KillTimer(TIMER_SLIDESHOW);
        SetCursorState(SLIDESHOW_CURSOR_HIDDEN);

        m_fGoBack = FALSE;
        // if slide show was reopened cancel any previous tracking
        TRACKMOUSEEVENT tme = {0};
        tme.cbSize = sizeof(tme);
        tme.dwFlags = TME_CANCEL | TME_LEAVE;
        tme.hwndTrack = m_ctlToolbar.m_hWnd;
        TrackMouseEvent(&tme);

        m_fTBTrack = FALSE;

        if (punkToView)
            hr = PreviewItemsFromUnk(punkToView);
        else
            hr = _PreviewItem(m_iCurSlide);

        if (SUCCEEDED(hr))
            m_fPaused = FALSE;
    }
    else
    {
        //create the slide show window

        // Full Screen
        if (m_pcwndSlideShow && m_pcwndSlideShow->m_hWnd)
        {
            RestoreAndActivate(m_pcwndSlideShow->m_hWnd);
        }
        else
        {
            // create the window
            if (!m_pcwndSlideShow)
            {
                m_pcwndSlideShow = new CPreviewWnd();
                if (!m_pcwndSlideShow)
                {
                    // out of memory
                    return E_OUTOFMEMORY;
                }
                else
                {
                    if (FAILED(m_pcwndSlideShow->Initialize(this, SLIDESHOW_MODE, FALSE)))
                    {
                        return E_OUTOFMEMORY;
                    }
                }
            }

            m_pcwndSlideShow->m_iCurSlide = m_iCurSlide;     // so the slide show stays in sync

            RECT rc = { 0,0,GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN)};
            m_pcwndSlideShow->Create(NULL, rc, NULL, WS_VISIBLE | WS_POPUP);
        }

        hr = m_pcwndSlideShow->StartSlideShow(NULL);
    }
    return hr;
}

HRESULT CPreviewWnd::_GetItem(UINT iItem, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_FAIL;
    if (iItem < m_cItems)
    {
        hr = SHILClone(m_ppidls[iItem], ppidl);
    }
    return hr;
}

void CPreviewWnd::_RemoveFromArray(UINT iItem)
{
    if (iItem < m_cItems)
    {
        ILFree(m_ppidls[iItem]);  // this one is now gone

        // slide all other pidls down in the array
        for (UINT i = iItem + 1; i < m_cItems; i++)
        {
            m_ppidls[i - 1] = m_ppidls[i];
        }
        m_cItems--;
        m_ppidls[m_cItems] = NULL;    // make sure stale ptr is now NULL

        // if we deleted an item before m_iCurSlide then we must adjust m_iCurSlide
        if (iItem < m_iCurSlide)
        {
            m_iCurSlide--;
        }
        else if (m_iCurSlide == m_cItems)
        {
            m_iCurSlide = 0;
        }
        // Now prepare for "ShowNextSlide"
        if (!m_iCurSlide)
        {
            m_iCurSlide = m_cItems ? m_cItems-1 : 0;
        }
        else
        {
            m_iCurSlide--;
        }
        // make sure the prefetch task has the right index
        if (m_pNextImageData)
        {
            if (!(m_pNextImageData->_iItem) && iItem && m_cItems)
            {
                m_pNextImageData->_iItem = m_cItems-1;
            }
            else if (m_pNextImageData->_iItem > iItem)
            {
                m_pNextImageData->_iItem--;
            }
            else
            {
                FlushBitmapMessages();
                ATOMICRELEASE(m_pNextImageData);            
            }                
        }
    }
}

HRESULT CPreviewWnd::_DeleteCurrentSlide()
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetItem(m_iCurSlide, &pidl);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH + 1] = {0}; // +1 and zero init for dbl NULL terminate extra terminator
        DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_STREAM;
        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath)-1, &dwAttribs);
        if (SUCCEEDED(hr))
        {
            BOOL fSuccess = TRUE;
            if (dwAttribs & SFGAO_FILESYSTEM)
            {
                SHFILEOPSTRUCT fo = {0};
                fo.hwnd = m_hWnd;
                fo.wFunc = FO_DELETE;
                fo.pFrom = szPath;
                fo.fFlags = FOF_ALLOWUNDO;
                fo.fAnyOperationsAborted = FALSE;
                if (SHFileOperation(&fo) == ERROR_SUCCESS)
                {
                    if (fo.fAnyOperationsAborted == TRUE)
                        fSuccess = FALSE;
                }
            }
            else
            {
                _InvokeVerb(TEXT("delete"));
                // We have to assume success since there is no way to know if the user
                // cancelled the confirmation dialog without hitting the camera again.
            }

            if (fSuccess)
            {
                m_fDirty = FALSE;
                _RemoveFromArray(m_iCurSlide);
                _ShowNextSlide(FALSE);
            }
        }

        ILFree(pidl);
    }
    return hr;
}

// index can be either current or next slide so that user can click multiple times on next/prev button
HRESULT CPreviewWnd::_ShowNextSlide(BOOL bGoBack)
{
    HRESULT hr = E_FAIL;

    if (m_cItems)
    {
        if (bGoBack)
        {
            if (m_iCurSlide)
                m_iCurSlide--;
            else
                m_iCurSlide = m_cItems - 1;
        }
        else
        {
            m_iCurSlide++;
            if (m_iCurSlide >= m_cItems)
                m_iCurSlide = 0;
        }
    

        if (!m_fPaused)
        {
            SetTimer(TIMER_SLIDESHOW, m_uTimeout);
        }
        SetTimer(TIMER_BUSYCURSOR, 500);

        LPITEMIDLIST pidl;
        // set the caption in case the load fails
        if (SUCCEEDED(_GetItem(m_iCurSlide, &pidl)))
        {
            TCHAR szPath[MAX_PATH];
            if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szPath, ARRAYSIZE(szPath)-1, NULL)))
            {
                SetCaptionInfo(szPath);
            }
            else
            {
                SetCaptionInfo(NULL);
            }
            ILFree(pidl);
        }
        hr = _PreviewItem(m_iCurSlide);

        if (SUCCEEDED(hr))
        {
            _PreLoadItem((m_iCurSlide + 1) % m_cItems);
        }
    }

    return hr;
}


HRESULT CPreviewWnd::_StartDecode(UINT iItem, BOOL fUpdateCaption)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetItem(iItem, &pidl);
    
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_STREAM;
        hr = SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), &dwAttribs);
        if (SUCCEEDED(hr) && (dwAttribs & SFGAO_FILESYSTEM))
        {
            hr = _PreviewFromFile(szPath, iItem, fUpdateCaption);
        }
        else if (dwAttribs & SFGAO_STREAM)
        {
            // this might not be a file system object, try to bind to it via IStream
            IStream *pstrm;

            hr = SHBindToObject(NULL, IID_X_PPV_ARG(IStream, pidl, &pstrm));
            if (SUCCEEDED(hr))
            {
                hr = _PreviewFromStream(pstrm, iItem, fUpdateCaption);
                pstrm->Release();
            }
        }
        else
        {
            // funky attributes?
            hr = S_FALSE;
        }
        ILFree(pidl);
    }
    return hr;
}

HRESULT CPreviewWnd::_PreLoadItem(UINT iItem)
{
    HRESULT hr = _StartDecode(iItem, FALSE);
    if (SUCCEEDED(hr))
    {
        m_iDecodingNextImage = iItem;
    }
    return hr;
}

HRESULT CPreviewWnd::_PreviewItem(UINT iItem)
{
    HRESULT hr = S_OK;

    if ((SLIDESHOW_MODE == m_dwMode) && (0 == m_cItems)) // if no more items, user just deleted the last one, so quit the slideshow
    {
        _CloseSlideshowWindow();
    }
    else
    {
        if (!_TrySetImage())
        {
            // If we are not currently already decoding this item, let's get cranking!
            if (m_iDecodingNextImage != iItem)
            {
                hr = _StartDecode(iItem, TRUE);
            }

            StatusUpdate((S_OK == hr) ? IDS_LOADING : IDS_LOADFAILED);
        }
    }

    return hr;
}

int CPreviewWnd::TranslateAccelerator(MSG *pmsg)
{
    if (IsVK_TABCycler(pmsg))
    {
        if (OnNonSlideShowTab())
        {
            return TRUE;
        }
    }
    else if (m_haccel)
    {
        ASSERT(m_hWnd);
        return ::TranslateAccelerator(m_hWnd, m_haccel, pmsg);
    }
    return FALSE;
}

// Sent when the image generation status has changed, once when the image is first
// being created and again if there is an error of any kind.  This should invalidate
// and free any left over bitmap and the cached copy of the previous m_ImgCtx
void CPreviewWnd::StatusUpdate(int iStatus)
{
    if (m_pImageData)
    {
        m_pImageData->Release();
        m_pImageData = NULL;
    }
    
    //
    // the caption is set at the first attempt to load an image
    m_ctlPreview.StatusUpdate(iStatus);

    _SetMultipageCommands();
    _SetMultiImagesCommands();
    _SetAnnotatingCommands(FALSE);
    _SetEditCommands();

    m_fPrintable = FALSE;
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PRINTCMD, MAKELONG(m_fPrintable, 0));

    // update our toolbar
    BOOL fHandled;
    OnSize(0x0, 0, 0, fHandled);
}

// Return:
//  S_OK    walk succeeded, image files found to preview:  display new images in preview
//  S_FALSE walk cancelled (by user):  display existing image in preview (no change)
//  E_XXXX  walk failed:  display no image in preview
//
HRESULT CPreviewWnd::WalkItemsToPreview(IUnknown* punk)
{
    HRESULT hr = _SaveIfDirty(TRUE);
    if (FAILED(hr) || hr == S_FALSE)
        return hr;

    
    m_fFirstItem = TRUE;
    
    
    _ClearDPA(); // clean up old stuff

    INamespaceWalk *pnsw;
    hr = CoCreateInstance(CLSID_NamespaceWalker, NULL, CLSCTX_INPROC, IID_PPV_ARG(INamespaceWalk, &pnsw));
    if (SUCCEEDED(hr))
    {
        // in control mode we only dislay one item at a time. lets setup our
        // state so this can work just like the other modes
        DWORD dwFlags = (CONTROL_MODE == m_dwMode) ? 0 : NSWF_ONE_IMPLIES_ALL | NSWF_NONE_IMPLIES_ALL;      
        m_fClosed = FALSE;
        hr = pnsw->Walk(punk, dwFlags, m_cWalkDepth, SAFECAST(this, INamespaceWalkCB *));
        // the window might have been closed during the namespace walk
        if (WINDOW_MODE == m_dwMode && m_fClosed)
        {
            hr = E_FAIL;
        }
        
        if (SUCCEEDED(hr))
        {
            hr = pnsw->GetIDArrayResult(&m_cItems, &m_ppidls);
            if (SUCCEEDED(hr) && (m_dwMode == WINDOW_MODE) && m_cItems && m_fFirstTime)
            {
                m_fFirstTime = FALSE;
                SHAddToRecentDocs(SHARD_PIDL, m_ppidls[0]);
            }
        }
        pnsw->Release();
    }
    

    // Clarification of INamespaceWalk return values:
    //  S_OK    walk has succeeded, and image files found to preview
    //  S_FALSE walk has succeeded, but no image files found to preview
    //          **** convert to E_FAIL to keep in line with return of function
    //  E_XXXX  walk has failed
    //
    return hr == S_FALSE ? E_FAIL : hr;
}

void CPreviewWnd::PreviewItems()
{
    if (WINDOW_MODE == m_dwMode)
    {
        RestoreAndActivate(m_hWnd);
    }
    _PreviewItem(0);
    if (SLIDESHOW_MODE == m_dwMode)
    {
        if (m_cItems > 1)
        {
            _PreLoadItem(1);
        }
    }
}

// build the _ppidl and m_cItems members and preview the first one
HRESULT CPreviewWnd::PreviewItemsFromUnk(IUnknown *punk)
{
    HRESULT hr = WalkItemsToPreview(punk);
    if (SUCCEEDED(hr))
    {
        if (S_FALSE != hr)
            PreviewItems();
    }
    else
    {
        StatusUpdate(IDS_LOADFAILED);
    }

    return hr;
}

// If the "new" image is the same as the old image, and the old image was recently edited then we assume that
// the reason we are getting a new ShowFile request is due to an FSChangeNotify on the file.  We also assume
// that we are the cause of this change notify.  Further we assume that we already have the correctly decoded
// image still ready.  These are assumptions which might not be TRUE 100%, in which case we will do really
// strange things, but they should be TRUE 99.9% of the time which is considered "good enough".  The reason we
// make these dangerous assumptions is to prevent decoding the image again and thus flickering between the
// old image, the "generating preview..." message, and the new (identical) image.

BOOL CPreviewWnd::_ReShowingSameFile(LPCTSTR pszNewFile)
{
    BOOL bIsSameFile = FALSE;
    if (m_pImageData)
    {
        if (pszNewFile && m_fWasEdited)
        {
            m_fWasEdited = FALSE;

            TCHAR szOldPath[MAX_PATH];
            if ((S_OK == PathFromImageData(szOldPath, ARRAYSIZE(szOldPath))) &&
                (0 == StrCmpI(szOldPath, pszNewFile)))
            {
                if (m_pEvents)
                    m_pEvents->OnPreviewReady();

                bIsSameFile = TRUE;
            }
        }

        if (!bIsSameFile)
        {
            m_pImageData->Release();    // need to start clean
            m_pImageData = NULL;
        }
    }
    return bIsSameFile;
}

// pszFile may be NULL. cItems expresses how many are selected so we can
// display "multiple items selected" and not display anything.

LRESULT CPreviewWnd::ShowFile(LPCTSTR pszFile, UINT cItems, BOOL fReshow)
{
    if (!m_hWnd)
        return S_FALSE;

    HRESULT hr = S_FALSE;

    TCHAR szLongName[MAX_PATH]; // short file names are UGLY
    if (GetLongPathName(pszFile, szLongName, ARRAYSIZE(szLongName)))
    {
        pszFile = szLongName;
    }

    if (!fReshow && _ReShowingSameFile(pszFile))
        return S_FALSE;

    // It is possible that there is already a bitmap message in our queue from the previous rendering.
    // If this is the case we should remove that message and release its bitmap before we continue.
    // If we do not then that message will get processed and will send the OnPreviewReady event to the
    // obejct container but this event might no longer be valid.
    FlushBitmapMessages();

    if (pszFile && *pszFile)
    {
        IDataObject *pdtobj;
        hr = GetUIObjectFromPath(pszFile, IID_PPV_ARG(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            hr = PreviewItemsFromUnk(pdtobj);
            m_fPaused = TRUE;
            pdtobj->Release();
        }
    }
    else
    {
        int iRetCode = (cItems > 1) ? IDS_MULTISELECT : IDS_NOPREVIEW;

        // Set the Return Code into all owned zoom windows.  This instructs these windows to disregard
        // their previous images and display the status message instead.
        StatusUpdate(iRetCode);
    }

    return hr;
}

LRESULT CPreviewWnd::IV_OnIVScroll(UINT , WPARAM , LPARAM lParam, BOOL&)
{
    DWORD nHCode = LOWORD(lParam);
    DWORD nVCode = HIWORD(lParam);
    if (nHCode)
    {
        m_ctlPreview.SendMessage(WM_HSCROLL, nHCode, NULL);
    }
    if (nVCode)
    {
        m_ctlPreview.SendMessage(WM_VSCROLL, nVCode, NULL);
    }
    return 0;
}


// IV_OnSetOptions
//
// This message is sent to turn on or off all the optional features of the image preview control.
// NOTE: When used as a control this function is called BEFORE the window is created.  Don't do
// anything in this function that will fail without a window unless you check for this condition.
LRESULT CPreviewWnd::IV_OnSetOptions(UINT , WPARAM wParam, LPARAM lParam, BOOL&)
{
    BOOL bResult = TRUE;

    // Boolify lParam just to be safe.
    lParam = lParam ? 1:0;

    switch (wParam)
    {
    case IVO_TOOLBAR:
        if ((BOOL)lParam != m_fShowToolbar)
        {
            m_fShowToolbar = (BOOL)lParam;
            if (m_hWnd)
            {
                if (m_fShowToolbar)
                {
                    if (!m_ctlToolbar)
                    {
                        bResult = CreateToolbar();
                        if (!bResult)
                        {
                            m_fShowToolbar = FALSE;
                            break;
                        }
                    }
                }
                else
                {
                    if (m_ctlToolbar)
                    {
                        m_ctlToolbar.DestroyWindow();
                    }
                }
            }
        }
        break;

    case IVO_PRINTBTN:
        if ((BOOL)lParam != m_fHidePrintBtn)
        {
            m_fHidePrintBtn = (BOOL)lParam;
            if (m_hWnd && m_ctlToolbar)
            {
                m_ctlToolbar.SendMessage(TB_HIDEBUTTON,ID_PRINTCMD,lParam);
            }
        }
        break;

    case IVO_CONTEXTMENU:
        m_fAllowContextMenu = (BOOL)lParam;
        break;

    case IVO_PRINTABLE:
        TraceMsg(TF_WARNING, "Obsolete IVO_PRINTABLE option received.");
        break;

    case IVO_DISABLEEDIT:
        m_fDisableEdit = (BOOL)lParam;
        break;

    default:
        break;
    }

    return bResult;
}

void CPreviewWnd::_SetEditCommands()
{
    if (CONTROL_MODE != m_dwMode)
    {
        // We can save if we have a file; the save dialog will show the available encoders
        BOOL fCanSave = m_pImageData ? TRUE : FALSE;

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_SAVEASCMD, MAKELONG(!fCanSave, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_SAVEASCMD, MAKELONG(fCanSave, 0));
    }

    BOOL fCanRotate = m_pImageData != NULL;
    if (CONTROL_MODE != m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATESEP, MAKELONG(!fCanRotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATE90CMD, MAKELONG(!fCanRotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ROTATE270CMD, MAKELONG(!fCanRotate, 0));
    }
    else
    {
        // we don't rotate multi-page images in control mode 
        fCanRotate = fCanRotate && !m_pImageData->IsMultipage();
    }

    // No matter where we are GDIPlus can't rotate WMF or EMF files. Curiously,
    // we will let you rotate ICO files, but because we don't have an encoder
    // we won't save them :)
    if (fCanRotate)
    {
        fCanRotate = !(IsEqualGUID(ImageFormatWMF, m_pImageData->_guidFormat) ||
                       IsEqualGUID(ImageFormatEMF, m_pImageData->_guidFormat) ||
                       m_pImageData->IsAnimated());
    }

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATESEP, MAKELONG(fCanRotate, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(fCanRotate, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(fCanRotate, 0));
    TCHAR szFile[MAX_PATH];
    BOOL fCanOpen = SUCCEEDED(PathFromImageData(szFile, ARRAYSIZE(szFile)));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_OPENCMD, MAKELONG(fCanOpen, 0));

}

void CPreviewWnd::_UpdatePageNumber()
{
    TCHAR szText[20];
    wsprintf(szText, TEXT("%d"), m_pImageData->_iCurrent+1);

    TBBUTTONINFO bi = {0};
    bi.cbSize = sizeof(bi);
    bi.dwMask = TBIF_TEXT | TBIF_STATE;
    bi.fsState = TBSTATE_ENABLED;
    bi.pszText = szText;
    m_ctlToolbar.SendMessage(TB_SETBUTTONINFO, ID_PAGELIST, (LPARAM)&bi);
}

void CPreviewWnd::_SetMultipageCommands()
{
    DWORD dwMode;

    // this code relies on the fact that TIFFs are the only multipage format we view
    if (!m_pImageData || m_pImageData->_guidFormat != ImageFormatTIFF )
    {
        dwMode = MPCMD_HIDDEN;
    }
    else if (!m_pImageData->IsMultipage())
    {
        dwMode = MPCMD_DISABLED;
    }
    else if (m_pImageData->IsFirstPage())
    {
        dwMode = MPCMD_FIRSTPAGE;
    }
    else if (m_pImageData->IsLastPage())
    {
        dwMode = MPCMD_LASTPAGE;
    }
    else
    {
        dwMode = MPCMD_MIDDLEPAGE;
    }

    // remember which buttons are enabled/hidden so we can quickly create our context menu
    if (dwMode != m_dwMultiPageMode)
    {
        m_dwMultiPageMode = dwMode;

        if (CONTROL_MODE != m_dwMode)
        {
            // Switch accelerator tables so that Page Up and Page Down work
            if (dwMode == MPCMD_HIDDEN || dwMode == MPCMD_DISABLED)
            {
                m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_SINGLEPAGE));
            }
            else
            {
                m_haccel = LoadAccelerators(_Module.GetModuleInstance(), MAKEINTRESOURCE(IDA_PREVWND_MULTIPAGE));
            }

            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PAGECMDSEP,  MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PREVPAGECMD, MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PAGELIST,    MAKELONG((MPCMD_HIDDEN==dwMode),0));
            m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NEXTPAGECMD, MAKELONG((MPCMD_HIDDEN==dwMode),0));

            if (MPCMD_HIDDEN != dwMode)
            {
                _UpdatePageNumber();

                m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PREVPAGECMD, MAKELONG((MPCMD_FIRSTPAGE!=dwMode && MPCMD_DISABLED!=dwMode),0));
                m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NEXTPAGECMD, MAKELONG((MPCMD_LASTPAGE !=dwMode && MPCMD_DISABLED!=dwMode),0));
            }
        }
    }
    else
    {
        if (CONTROL_MODE != m_dwMode)
        {
            if (dwMode == MPCMD_MIDDLEPAGE)
            {
                _UpdatePageNumber();
            }
        }
    }
}

void CPreviewWnd::_SetMultiImagesCommands()
{
    BOOL bHasFiles = m_cItems;
    if (CONTROL_MODE != m_dwMode)
    {
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PREVIMGCMD, MAKELONG(!bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NEXTIMGCMD, MAKELONG(!bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_VIEWCMDSEP, MAKELONG(!bHasFiles, 0));

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PREVIMGCMD, MAKELONG(bHasFiles, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NEXTIMGCMD, MAKELONG(bHasFiles, 0));
    }
}

HRESULT CPreviewWnd::PathFromImageData(LPTSTR pszFile, UINT cch)
{
    *pszFile = 0;

    IShellImageData *pSID;
    HRESULT hr = m_pImageData ? m_pImageData->Lock(&pSID) : E_FAIL;
    if (SUCCEEDED(hr))
    {
        IPersistFile *ppf;
        hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hr))
        {
            WCHAR *psz;
            hr = ppf->GetCurFile(&psz);
            if (SUCCEEDED(hr))
            {
                lstrcpyn(pszFile, psz, cch);
                CoTaskMemFree(psz);
            }
            ppf->Release();
        }
        m_pImageData->Unlock();
    }
    return hr;
}

HRESULT CPreviewWnd::ImageDataSave(LPCTSTR pszFile, BOOL bShowUI)
{
    IShellImageData * pSID = NULL;
    HRESULT hr = m_pImageData ? m_pImageData->Lock(&pSID) : E_FAIL;
    Image *pimgRestore = NULL;
    if (SUCCEEDED(hr))
    {
        GUID guidFmt = GUID_NULL;
        BOOL bSave = TRUE;
        BOOL bWarnBurn = FALSE;
        BOOL bRestoreParams = FALSE;
        pSID->GetRawDataFormat(&guidFmt);
        // if saving to a jpeg, set the image quality to high
        // if pszFile is NULL, we're saving the same file, so don't promote the image quality
        if (pszFile)
        {
            m_pImageFactory->GetDataFormatFromPath(pszFile, &guidFmt);
            if (guidFmt == ImageFormatJPEG )
            {
                IPropertyBag *ppb;
                if (SUCCEEDED(SHCreatePropertyBagOnMemory(STGM_READWRITE,
                                                          IID_PPV_ARG(IPropertyBag, &ppb))))
                {
                    // write the quality value for the recompression into the property bag
                    // we have to write the format too...CImageData relies on "all or nothing"
                    // from the encoder params property bag
                     VARIANT var;
                     hr = InitVariantFromGUID(&var, ImageFormatJPEG);
                     if (SUCCEEDED(hr))
                     {
                         ppb->Write(SHIMGKEY_RAWFORMAT, &var);
                         VariantClear(&var);
                     }
                     SHPropertyBag_WriteInt(ppb, SHIMGKEY_QUALITY, 100);
                     pSID->SetEncoderParams(ppb);
                     ppb->Release();
                     bRestoreParams = TRUE;
                 }
            }
        }
        if (bShowUI && pszFile)
        {
            // warn the user if saving from TIFF to something that will lose annotations

            BOOL bDestTiff = ImageFormatTIFF == guidFmt;
            BOOL bAnnot = m_ctlPreview.GetAnnotations()->GetCount() > 0;
            bWarnBurn = bAnnot && !bDestTiff;

            #if 0
            if (!bWarnBurn && S_OK == m_pImageData->IsMultipage() && !bDestTiff)
            {
                GUID guidFmt;
                bWarnBurn = TRUE;
                if (SUCCEEDED(m_pImageFactory->GetDataFormatFromPath(pszFile, &guidFmt)))
                {
                    bWarn = !FmtSupportsMultiPage(pSID, &guidFmt);
                }
            }
            #endif // 0 Put the multipage warning back in if needed, and change the wording of IDS_SAVE_WARN_TIFF
        }

        if (bWarnBurn)
        {
            m_fPromptingUser = TRUE;
            bSave = (IDYES == ShellMessageBox(_Module.GetModuleInstance(), m_hWnd,
                                                 MAKEINTRESOURCE(IDS_SAVE_WARN_TIFF),
                                                 MAKEINTRESOURCE(IDS_PROJNAME),
                                                 MB_YESNO | MB_ICONINFORMATION));
            m_fPromptingUser = FALSE;
            
            if (bSave)
            {
                // Save the current image frame to restore after the save to a different file is complete
                pimgRestore = _BurnAnnotations(pSID);
            }
        }
        if (bSave)
        {
            IPersistFile *ppf;
            hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                // if saving to the same file name, make sure
                // the changenotify code ignores the notify this will generate
                //
                if (!pszFile)
                {
                    m_fIgnoreNextNotify = TRUE;
                }
                hr = ppf->Save(pszFile, FALSE);
                if (SUCCEEDED(hr))
                {
                    m_fWasEdited = TRUE;
                }
                else if (!pszFile)
                {
                    m_fIgnoreNextNotify = FALSE;
                }
            }
            ppf->Release();
            if (pimgRestore)
            {
                pSID->ReplaceFrame(pimgRestore);
            }
        }
        else
        {
            hr = S_FALSE; // we did nothing
        }
        if (bRestoreParams)
        {
            pSID->SetEncoderParams(NULL);
        }
        m_pImageData->Unlock();
    }
    return hr;
}

HRESULT CPreviewWnd::_SaveAsCmd()
{
    if (m_pImageData == NULL)
        return S_OK;



    OPENFILENAME ofn = {0};
    TCHAR szOrgFile[MAX_PATH];
    TCHAR szExt[MAX_PATH] = {0};
    PathFromImageData(szOrgFile, ARRAYSIZE(szOrgFile));
    LPTSTR psz = PathFindExtension(szOrgFile);
    StrCpyN(szExt, psz, ARRAYSIZE(szExt));

    TCHAR szFile[MAX_PATH];
    if (!m_fDisableEdit && m_fCanSave && m_pImageData->IsEditable())
    {
        // If we haven't explicitly been told not to and the file is writeable then
        // suggest saving on top of the current image
        PathFromImageData(szFile, ARRAYSIZE(szFile));
    }
    else
    {
        // Otherwise suggest New Image.jpg
        LoadString(_Module.GetModuleInstance(), IDS_NEW_FILENAME, szFile, ARRAYSIZE(szFile));
    }

    CComBSTR bstrTitle;
    bstrTitle.LoadString(IDS_SAVEAS_TITLE);

    ofn.lStructSize = sizeof(ofn);
    PathRemoveExtension(szFile);
    TCHAR szFilter[MAX_PATH] = TEXT("\0");
    ofn.nFilterIndex = _GetFilterStringForSave(szFilter, ARRAYSIZE(szFilter), szExt);
    ofn.lpstrFilter = szFilter;
    ofn.hwndOwner = m_hWnd;
    ofn.lpstrFile = szFile;
    ofn.lpstrTitle = bstrTitle;
    ofn.nMaxFile = MAX_PATH - lstrlen(szExt);
    ofn.Flags = OFN_EXPLORER | OFN_OVERWRITEPROMPT | OFN_PATHMUSTEXIST | OFN_ENABLESIZING;
    ofn.lpstrDefExt = *szExt == TEXT('.') ? szExt + 1: szExt;

    m_fPromptingUser = TRUE;
    BOOL bResult = ::GetSaveFileName(&ofn);
    m_fPromptingUser = FALSE;

    if (bResult != 0)
    {
        m_ctlPreview.CommitAnnotations();
        HRESULT hr = ImageDataSave(szFile, TRUE);
        if (S_OK == hr)
        {
           if (lstrcmpi(szFile, szOrgFile) == 0)
           {
                _UpdateImage();
                ShowFile(szFile, 1);
                m_fDirty = FALSE;
           }
        }
        else if (FAILED(hr))
        {
            // If we failed to save then we are corrupt and need to be reloaded
            // If we were just copying then only show the message
            if (lstrcmpi(szFile, szOrgFile) == 0)
            {
                _UpdateImage();
                ShowFile(szOrgFile, 1, TRUE);
                m_fDirty = FALSE;
            }
            else
            {
                // delete the failed copy
                DeleteFile(szFile);
            }

            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_SAVEFAILED_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
                return E_FAIL;
            }
        }
    }
    else
    {
        DWORD dwResult = CommDlgExtendedError();
        if (dwResult == FNERR_BUFFERTOOSMALL)
        {
            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_NAMETOOLONG_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
            }
        }
        return S_FALSE; // User probably cancelled
    }
    return S_OK;
}

void CPreviewWnd::_PropertiesCmd()
{
    if (m_fAnnotating && DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

        if (!pAnnotation->HasWidth() && !pAnnotation->HasTransparent() && !pAnnotation->HasColor() && pAnnotation->HasFont())
        {
            CHOOSEFONT cf = {0};

            LOGFONT lfFont;
            pAnnotation->GetFont(lfFont);
            COLORREF crFont = pAnnotation->GetFontColor();

            cf.lStructSize = sizeof(cf);
            cf.hwndOwner = m_hWnd;
            cf.lpLogFont = &lfFont;
            cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
            cf.rgbColors = crFont;

            m_fPromptingUser = TRUE;
            BOOL bResult = ::ChooseFont(&cf);
            m_fPromptingUser = FALSE;
            
            if (bResult)
            {
                crFont = cf.rgbColors;
                lfFont.lfHeight = (lfFont.lfHeight > 0) ? lfFont.lfHeight : -lfFont.lfHeight;
                pAnnotation->SetFont(lfFont);
                pAnnotation->SetFontColor(crFont);
                m_fDirty = TRUE;

                CRegKey Key;
                if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                {
                    Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                }

                if (Key.m_hKey != NULL)
                {
                    Key.SetValue(crFont, REGSTR_TEXTCOLOR);
                    ::RegSetValueEx(Key, REGSTR_FONT, 0, REG_BINARY, (LPBYTE)&lfFont, sizeof(lfFont));
                }
                _RefreshSelection();
            }
        }
        else
        {
            m_fPromptingUser = TRUE;
            INT_PTR iResult = DialogBoxParam(_Module.GetModuleInstance(),
                                            MAKEINTRESOURCE(IDD_ANNOPROPS),
                                            m_hWnd, _AnnoPropsDlgProc, (LPARAM)this);
            m_fPromptingUser = FALSE;
        }
    }
    else
    {
        // Under these condition the has pressed Ctrl-I to get File Properties
        // So serve them up.
        CComBSTR bstrSummary;
        bstrSummary.LoadString(IDS_SUMMARY);
        _InvokeVerb(TEXT("properties"), bstrSummary);
    }
}

HRESULT _VerbMatches(LPCWSTR pszFile, LPCWSTR pszVerb, LPCTSTR pszOurs)
{
    TCHAR szTemp[MAX_PATH];
    DWORD cch = ARRAYSIZE(szTemp);
    HRESULT hr = AssocQueryString(ASSOCF_VERIFY, ASSOCSTR_COMMAND, pszFile, pszVerb, szTemp, &cch);
    if (SUCCEEDED(hr))
    {
        hr = (StrStrI(szTemp, pszOurs)) ? S_OK : S_FALSE;
    }
    return hr;
}

void CPreviewWnd::_OpenCmd()
{
    HRESULT hr = _SaveIfDirty(TRUE);
    LPCTSTR pszVerb;
    if (S_OK == hr)
    {
        TCHAR szFile[MAX_PATH];
        hr = PathFromImageData(szFile, ARRAYSIZE(szFile));
        if (SUCCEEDED(hr))
        {
            HRESULT hrOpen = _VerbMatches(szFile, L"open", TEXT("shimgvw.dll"));
            HRESULT hrEdit = _VerbMatches(szFile, L"edit", TEXT("mspaint.exe"));
            // if edit is empty, or if edit is mspaint and open is not shimgvw, use the open verb instead
            if (SUCCEEDED(hrEdit))
            {
                if (S_OK == hrEdit && hrOpen == S_FALSE)
                {
                    pszVerb = TEXT("open");
                }
                else
                {
                    pszVerb = TEXT("edit");
                }
            }
            else if (hrOpen == S_FALSE)
            {
                pszVerb = TEXT("open");
            }
            else
            {
                pszVerb = TEXT("openas");
            }
            hr = _InvokeVerb(pszVerb);
        }
        if (FAILED(hr))
            return;

        // set m_fNoRestore to avoid the rotation confirmation restoration popup-ation
        m_fNoRestore = TRUE;
        // The user had a chance to save but may have said no. Pretend we're not dirty
        m_fDirty = FALSE;
        PostMessage(WM_CLOSE, 0, 0);
    }
}

BOOL CPreviewWnd::_CanAnnotate(CDecodeTask * pImageData)
{
    // If we have an image and its encoder and we haven't been explicitly told not to allow editing
    // and the image is writeable
    if (m_pImageData && m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // then if its a TIFF we can annotate it
        return IsEqualGUID(ImageFormatTIFF, pImageData->_guidFormat);
    }
    return FALSE;
}

BOOL CPreviewWnd::_CanCrop(CDecodeTask * pImageData)
{
    if (m_pImageData != NULL)
    {
// REVIEW I added this for CyraR as a proof of concept. If we decide to support it
// we still need to catch all the places where we should save the croppped image and
// call GDIplus to accomplish the crop.
#ifdef SUPPORT_CROPPING
        if (S_OK != m_pImageData->IsEditable())
            return FALSE;

        LONG cPages;
        if (S_OK == m_pImageData->GetPageCount(&cPages))
        {
            if (cPages > 1)
                return FALSE;
        }
        return TRUE;
#endif
    }
    return FALSE;
}

// Called whenever the image changes to hide or show the annotation buttons.
void CPreviewWnd::_SetAnnotatingCommands(BOOL fEnableAnnotations)
{
    if (CONTROL_MODE != m_dwMode)
    {
        if (fEnableAnnotations)
        {
            m_fCanAnnotate = TRUE;
            m_fAnnotating = FALSE;
        }
        else
        {
            if (m_fAnnotating)
            {
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            }

            m_fCanAnnotate = FALSE;
            m_fAnnotating = FALSE;
        }

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_SELECTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_ANNOTATESEP, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_FREEHANDCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_HIGHLIGHTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_LINECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_FRAMECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_RECTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_TEXTCMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_NOTECMD, MAKELONG(!m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_PROPERTIESCMD, MAKELONG(!m_fCanAnnotate, 0));

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_SELECTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ANNOTATESEP, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_FREEHANDCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_HIGHLIGHTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_LINECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_FRAMECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_RECTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_TEXTCMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_NOTECMD, MAKELONG(m_fCanAnnotate, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(FALSE, 0));
    }
}

void CPreviewWnd::_SetCroppingCommands(BOOL fEnableCropping)
{
    if (CONTROL_MODE != m_dwMode)
    {
        if (fEnableCropping)
        {
            m_fCanCrop = TRUE;
            m_fCropping = FALSE;
        }
        else
        {
            if (m_fCropping)
            {
                m_ctlPreview.SetMode(CZoomWnd::MODE_NOACTION);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            }

            m_fCanCrop = FALSE;
            m_fCropping = FALSE;
        }

        m_ctlToolbar.SendMessage(TB_HIDEBUTTON, ID_CROPCMD, MAKELONG(!m_fCanCrop, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_CROPCMD, MAKELONG(m_fCanCrop, 0));
    }
}

// Called on Toolbar command to fix the state of the other buttons.
void CPreviewWnd::_UpdateButtons(WORD wID)
{
    if (CONTROL_MODE != m_dwMode)
    {
        switch (wID)
        {
        case NOBUTTON:
        case ID_ZOOMINCMD:
        case ID_ZOOMOUTCMD:
        case ID_SELECTCMD:
        case ID_CROPCMD:
            m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
            m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
            if (m_fCanAnnotate)
            {
                m_wNewAnnotation = 0;
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
                m_fAnnotating = (wID == ID_SELECTCMD);
            }
            if (m_fCanCrop)
            {
                m_fCropping = (wID == ID_CROPCMD);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_CROPCMD, TBSTATE_ENABLED);
            }

            _RefreshSelection(!m_fAnnotating);
            m_ctlToolbar.SendMessage(TB_SETSTATE, wID, TBSTATE_ENABLED|TBSTATE_CHECKED);
            break;
        case ID_FREEHANDCMD:
        case ID_LINECMD:
        case ID_FRAMECMD:
        case ID_RECTCMD:
        case ID_TEXTCMD:
        case ID_NOTECMD:
        case ID_HIGHLIGHTCMD:
            if (m_fCanAnnotate)
            {
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMINCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_ZOOMOUTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED|TBSTATE_CHECKED);
                m_fAnnotating = TRUE;
                _RefreshSelection(TRUE);
                m_ctlToolbar.SendMessage(TB_SETSTATE, wID, TBSTATE_ENABLED|TBSTATE_CHECKED);
                m_wNewAnnotation = wID;
            }
            break;
        default:
            if (m_fCanAnnotate)
            {
                m_wNewAnnotation = 0;
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_SELECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FREEHANDCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_HIGHLIGHTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_LINECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_FRAMECMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_RECTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_TEXTCMD, TBSTATE_ENABLED);
                m_ctlToolbar.SendMessage(TB_SETSTATE, ID_NOTECMD, TBSTATE_ENABLED);
            }
            break;
        }
    }
}

void CPreviewWnd::_RefreshSelection(BOOL fDeselect)
{
    if (m_fCropping)
        _UpdateCroppingSelection();
    _UpdateAnnotatingSelection(fDeselect);
}

BOOL CPreviewWnd::_ShouldDisplayAnimations()
{
    return !::GetSystemMetrics(SM_REMOTESESSION);
}

void CPreviewWnd::_UpdateAnnotatingSelection(BOOL fDeselect)
{
    BOOL bEditing = FALSE;
    if (m_ctlEdit.m_hWnd != NULL)
    {
        if (m_ctlEdit.IsWindowVisible())
        {
            _HideEditing();
            bEditing = TRUE;
        }
    }

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        CRect rectUpdate;
        CSelectionTracker tracker;
        _SetupAnnotatingTracker(tracker, bEditing);

        tracker.GetTrueRect(rectUpdate);

        // If we were editing or this was a straight line, we
        // need to get the bounding rect as well
        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
        {
            CRect rect;
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

            pAnnotation->GetRect(rect);
            m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);

            rectUpdate.UnionRect(rectUpdate, rect);
        }
        m_ctlPreview.InvalidateRect(&rectUpdate);

        if (m_fAnnotating && !fDeselect)
        {
            if (bEditing)
                _StartEditing(FALSE);
        }
        else
        {
            _StopEditing();
            DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        }
    }

    // Disable the properties button if there are 0 or 2 or more annotations selected
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1, 0));
}

void CPreviewWnd::_UpdateCroppingSelection()
{
    if (m_fCropping)
    {
        m_ctlPreview.InvalidateRect(NULL);
    }
}

void CPreviewWnd::_RemoveAnnotatingSelection()
{
    // Invalidate current selection and remove annotations
    _UpdateAnnotatingSelection();

    CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();

    for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
        pAnnotations->RemoveAnnotation(pAnnotation);
        delete pAnnotation;
        m_fDirty = TRUE;
    }
    
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_PROPERTIESCMD, MAKELONG(FALSE, 0));
    DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
}

void CPreviewWnd::_SetupAnnotatingTracker(CSelectionTracker& tracker, BOOL bEditing)
{
    CRect rect;
    rect.SetRectEmpty();

    if (!bEditing)
    {
        if (m_ctlEdit.m_hWnd != NULL)
            bEditing = m_ctlEdit.IsWindowVisible();
    }

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 0)
    {
        CAnnotation* pAnnotation;

        if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
        {
            pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

            // If this is a straight-line annotation then we need to get
            // to the actual points rather than the bounding rect
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
            {
                CLineMark* pLine = (CLineMark*)pAnnotation;
                pLine->GetPointsRect(rect);
            }
            else
            {
                pAnnotation->GetRect(rect);
            }

            if (bEditing)
                _RotateRect(rect, pAnnotation);
        }
        else
        {
            for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
            {
               CRect rectAnnotation;
                pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);

                pAnnotation->GetRect(rectAnnotation);
                rectAnnotation.NormalizeRect();
                rect.UnionRect(rect, rectAnnotation);
            }
        }

        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    }
    tracker.m_rect = rect;

    UINT uStyle = 0;

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 1)
    {
        uStyle = CSelectionTracker::hatchedBorder;
    }
    else if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 1)
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

        if (pAnnotation->CanResize())
        {
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
                uStyle = CSelectionTracker::resizeOutside | CSelectionTracker::lineSelection;
            else
                uStyle = CSelectionTracker::solidLine | CSelectionTracker::resizeOutside;
        }
        else
        {
            uStyle = CSelectionTracker::hatchedBorder;
        }
    }

    tracker.m_uStyle = uStyle;
}

void CPreviewWnd::_SetupCroppingTracker(CSelectionTracker& tracker)
{
    if (m_fCropping)
    {
        CRect rect(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);
        if (m_rectCropping.IsRectEmpty())
            m_rectCropping = rect;

        rect = m_rectCropping;

        m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);

        tracker.m_rect = rect;
        tracker.m_uStyle = CSelectionTracker::solidLine | CSelectionTracker::resizeOutside;
    }
}

BOOL CPreviewWnd::_OnMouseDownForCropping(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!m_fCropping)
        return FALSE;

    if (uMsg != WM_LBUTTONDOWN)
        return TRUE;

    CSelectionTracker tracker;
    CPoint point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));

    _SetupCroppingTracker(tracker);
    _RefreshSelection();

    if (tracker.HitTest(point) == CSelectionTracker::hitNothing)
        return TRUE;

    if (tracker.Track(m_ctlPreview.m_hWnd, point))
    {
        CRect rectNewPos;
        tracker.GetTrueRect(rectNewPos);

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectNewPos, 2);

        CRect rectImage(0, 0, m_ctlPreview.m_cxImage, m_ctlPreview.m_cyImage);

        if (rectNewPos.left < rectImage.left)
            m_rectCropping.left = rectImage.left;
        else
            m_rectCropping.left = rectNewPos.left;

        if (rectNewPos.top < rectImage.top)
            m_rectCropping.top = rectImage.top;
        else
            m_rectCropping.top = rectNewPos.top;

        if (rectNewPos.right > rectImage.right)
            m_rectCropping.right = rectImage.right;
        else
            m_rectCropping.right = rectNewPos.right;

        if (rectNewPos.bottom > rectImage.bottom)
            m_rectCropping.bottom = rectImage.bottom;
        else
            m_rectCropping.bottom = rectNewPos.bottom;

        m_fDirty = TRUE;
    }

    _RefreshSelection();

    return TRUE;
}

BOOL CPreviewWnd::_OnMouseDownForAnnotating(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!m_fAnnotating)
        return FALSE;

    if (uMsg != WM_LBUTTONDOWN)
        return TRUE;

    CRect rect;
    CRect rectImage;
    CPoint point(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
    CSelectionTracker tracker;

    m_ctlPreview.GetVisibleImageWindowRect(rectImage);

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0)
    {
        _OnMouseDownForAnnotatingHelper(point, rectImage);
        return TRUE;
    }

    _SetupAnnotatingTracker(tracker);
    tracker.GetTrueRect(rect);

    if (tracker.HitTest(point) == CSelectionTracker::hitNothing)
    {
        _RefreshSelection(TRUE);
        _OnMouseDownForAnnotatingHelper(point, rectImage);
        return TRUE;
    }

    if (!tracker.Track(m_ctlPreview.m_hWnd, point))
    {
        _StartEditing();
        return TRUE;
    }

    CRect rectNewPos;
    tracker.GetTrueRect(rectNewPos);

    rect.BottomRight() = rectNewPos.TopLeft();
    m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

    CSize size = rect.BottomRight() - rect.TopLeft();

    _RefreshSelection();

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) > 1)
    {
        if (size.cx == 0 && size.cy == 0)
            return TRUE;

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
        rectImage.DeflateRect(5, 5);

        BOOL bValidMove = TRUE;
        for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
        {
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);

            pAnnotation->GetRect(rect);
            rect.NormalizeRect();
            rect.OffsetRect(size);

            if (!rectNewPos.IntersectRect(rectImage, rect))
                bValidMove = FALSE;
        }

        if (!bValidMove)
            return TRUE;

        for (int i = 0; i < DPA_GetPtrCount(m_hdpaSelectedAnnotations); i++)
        {
            CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, i);
            pAnnotation->Move(size);
        }
    }
    else
    {
        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);
        if (pAnnotation->CanResize())
        {
            CRect rectTest;

            rect = tracker.m_rect;
            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

            rectTest = rect;

            // If the annotation being manipulated is a straight line then the rectangle
            // returned from the tracker could be empty (ie left=right or top=bottom)
            // In this case the IntersectRect test below would fail because windows
            // assumes empty rectangle don't intersect anything.
            if (pAnnotation->GetType() == MT_STRAIGHTLINE)
            {
                if (rectTest.left == rectTest.right)
                    rectTest.right++;
                if (rectTest.top == rectTest.bottom)
                    rectTest.bottom++;
            }
            rectTest.NormalizeRect();

            m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rectImage, 2);
            rectImage.DeflateRect(5, 5);

            if (!rectTest.IntersectRect(rectImage, rectTest))
                return TRUE;

            if (m_ctlEdit.m_hWnd != NULL)
            {
                if (m_ctlEdit.IsWindowVisible())
                {
                    _RotateRect(rect, pAnnotation);
                }
            }

            // If this is a line then the rect is assumed to be
            // a non-normalized array of points.
            pAnnotation->Resize(rect);

        }
        else
        {
            if (size.cx == 0 && size.cy == 0)
                return TRUE;

            pAnnotation->Move(size);
        }
    }
    m_fDirty = TRUE;
    _RefreshSelection();
    return TRUE;
}

void CPreviewWnd::_OnMouseDownForAnnotatingHelper(CPoint ptMouse, CRect rectImage)
{
    CRect rect;
    CSelectionTracker tracker;
    _SetupAnnotatingTracker(tracker);

    if (m_wNewAnnotation == ID_FREEHANDCMD)
    {
        _CreateFreeHandAnnotation(ptMouse);
        return;
    }

    // If we are creating a line then make sure the tracker has the lineSelection
    // style so we get the appropriate visual feedback.
    if (m_wNewAnnotation == ID_LINECMD)
    {
        tracker.m_uStyle = CSelectionTracker::resizeOutside | CSelectionTracker::lineSelection;
    }

    if (tracker.TrackRubberBand(m_ctlPreview.m_hWnd, ptMouse, TRUE))
    {
        rect = tracker.m_rect;
        rect.NormalizeRect();

        if ((rect.Width() > 10) || (rect.Height() > 10))
        {
            if (m_wNewAnnotation != 0)
            {
                _CreateAnnotation(tracker.m_rect);
            }
            else
            {
                CRect rectTest;
                CRect rectAnnotation;
                CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();

                m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);

                INT_PTR nCount = pAnnotations->GetCount();
                for (INT_PTR i = 0; i < nCount; i++)
                {
                    CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);

                    pAnnotation->GetRect(rectAnnotation);
                    rectAnnotation.NormalizeRect();
                    rectTest.UnionRect(rect, rectAnnotation);

                    if (rectTest == rect)
                    {
                        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);
                    }
                }
                _RefreshSelection(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0);
            }
        }
    }
    else
    {
        if (m_wNewAnnotation == 0)
        {
            if (PtInRect(rectImage, ptMouse))
            {
                m_ctlPreview.GetImageFromWindow(&ptMouse, 1);

                CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
                INT_PTR nCount = pAnnotations->GetCount();

                // if the user is clicking a single point then
                // we need to search the annotations in zorder 
                // from top to bottom
                for (INT_PTR i = nCount - 1; i >= 0; i--)
                {
                    CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);

                    pAnnotation->GetRect(rect);
                    rect.NormalizeRect();

                    if (PtInRect(rect, ptMouse))
                    {
                        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);
                        _RefreshSelection();
                        return;
                    }
                }
                _RefreshSelection(DPA_GetPtrCount(m_hdpaSelectedAnnotations) == 0);
            }
        }
        else
        {
            _UpdateButtons(ID_SELECTCMD);
        }
    }
}

void CPreviewWnd::_CreateAnnotation(CRect rect)
{
    if (m_wNewAnnotation == 0 || m_wNewAnnotation == ID_FREEHANDCMD)
        return;

    ULONG xDPI;
    ULONG yDPI;
    if (!(m_pImageData->GetResolution(&xDPI, &yDPI)))
        return;

    CAnnotation* pAnnotation = NULL;
    switch(m_wNewAnnotation)
    {
    case ID_LINECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_STRAIGHTLINE, yDPI);
        break;
    case ID_FRAMECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_HOLLOWRECT, yDPI);
        break;
    case ID_RECTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_FILLRECT, yDPI);
        break;
    case ID_TEXTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_TYPEDTEXT, yDPI);
        break;
    case ID_NOTECMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_ATTACHANOTE, yDPI);
        break;
    case ID_HIGHLIGHTCMD:
        pAnnotation = CAnnotation::CreateAnnotation(MT_FILLRECT, yDPI);
        if (pAnnotation != NULL)
            pAnnotation->SetTransparent(TRUE);
        break;
    }

    if (pAnnotation != NULL)
    {
        COLORREF crBackColor = RGB(255,255,0);
        COLORREF crLineColor = RGB(255,0,0);
        COLORREF crTextColor = RGB(0,0,0);
        LOGFONT lfFont = {12, 0, 0, 0, 400, 0, 0, 0, 0, 0, 0, 0, 0, TEXT("Arial") };

        DWORD dwWidth = 1;

        CRegKey Key;
        if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
        {
            Key.QueryValue(dwWidth, REGSTR_LINEWIDTH);
            Key.QueryValue(crBackColor, REGSTR_BACKCOLOR);
            Key.QueryValue(crLineColor, REGSTR_LINECOLOR);
            Key.QueryValue(crTextColor, REGSTR_TEXTCOLOR);

            DWORD dwType, cbSize;
            cbSize = sizeof(lfFont);
            ::RegQueryValueEx(Key, REGSTR_FONT, NULL, &dwType, (LPBYTE)&lfFont, &cbSize);
        }

        if (m_wNewAnnotation != ID_LINECMD)
            rect.NormalizeRect();

        m_ctlPreview.GetImageFromWindow((LPPOINT)(LPRECT)rect, 2);
        pAnnotation->Resize(rect);

        if (pAnnotation->HasWidth())
            pAnnotation->SetWidth(dwWidth);

        if (pAnnotation->HasColor())
        {
            if (m_wNewAnnotation == ID_LINECMD || m_wNewAnnotation == ID_FRAMECMD)
                pAnnotation->SetColor(crLineColor);
            else
                pAnnotation->SetColor(crBackColor);
        }

        if (pAnnotation->HasFont())
        {
            pAnnotation->SetFont(lfFont);
            pAnnotation->SetFontColor(crTextColor);
        }

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->AddAnnotation(pAnnotation);

        m_fDirty = TRUE;
    }
    _UpdateButtons(ID_SELECTCMD);
}

void CPreviewWnd::_CreateFreeHandAnnotation(CPoint ptMouse)
{
    if (m_wNewAnnotation != ID_FREEHANDCMD)
        return;

    // don't handle if capture already set
    if (::GetCapture() != NULL)
        return;

    // set capture to the window which received this message
    ::SetCapture(m_ctlPreview.m_hWnd);
    ASSERT(m_ctlPreview.m_hWnd == ::GetCapture());

    ::UpdateWindow(m_ctlPreview.m_hWnd);

    ULONG xDPI;
    ULONG yDPI;
    if (!(m_pImageData->GetResolution(&xDPI, &yDPI)))
        return;

    CLineMark* pAnnotation = (CLineMark*)CAnnotation::CreateAnnotation(MT_FREEHANDLINE, yDPI);
    if (pAnnotation == NULL)
        return;

    CDSA<POINT> Points;
    Points.Create(256);

    CPoint ptLast = ptMouse;
    m_ctlPreview.GetImageFromWindow(&ptMouse, 1);

    Points.AppendItem(&ptMouse);

    // get DC for drawing
    HDC hdcDraw;

    // otherwise, just use normal DC
    hdcDraw = ::GetDC(m_ctlPreview.m_hWnd);
    ASSERT(hdcDraw != NULL);

    COLORREF crLineColor = RGB(255,0,0);
    DWORD dwWidth = 1;

    CRegKey Key;
    if (ERROR_SUCCESS == Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
    {
        Key.QueryValue(dwWidth, REGSTR_LINEWIDTH);
        Key.QueryValue(crLineColor, REGSTR_LINECOLOR);
    }

    CRect rect(0,0,0,dwWidth);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    DWORD dwRenderWidth = rect.Height();

    HPEN hpen = ::CreatePen(PS_SOLID, dwRenderWidth, crLineColor);
    HPEN hOld =(HPEN)::SelectObject(hdcDraw, hpen);

    BOOL bCancel=FALSE;

    // get messages until capture lost or cancelled/accepted
    for (;;)
    {
        MSG msg;
        if (!::GetMessage(&msg, NULL, 0, 0))
        {
            ASSERT(FALSE);
        }

        if (m_ctlPreview.m_hWnd != ::GetCapture())
        {
            bCancel = TRUE;
            goto ExitLoop;
        }

        ptMouse.x = GET_X_LPARAM(msg.lParam);
        ptMouse.y = GET_Y_LPARAM(msg.lParam);

        switch (msg.message)
        {
        // handle movement/accept messages
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
            ::MoveToEx(hdcDraw, ptLast.x, ptLast.y, NULL);
            ::LineTo(hdcDraw, ptMouse.x, ptMouse.y);
            ptLast = ptMouse;

            m_ctlPreview.GetImageFromWindow(&ptMouse, 1);
            Points.AppendItem(&ptMouse);

            if (msg.message == WM_LBUTTONUP)
                goto ExitLoop;
            break;
        // handle cancel messages
        case WM_KEYDOWN:
            if (msg.wParam != VK_ESCAPE)
                break;
        //  else fall through
        case WM_RBUTTONDOWN:
            bCancel = TRUE;
            goto ExitLoop;
        default:
            ::DispatchMessage(&msg);
            break;
        }
    }
ExitLoop:

    ::SelectObject(hdcDraw, hOld);
    ::DeleteObject(hpen);
    ::ReleaseDC(m_ctlPreview.m_hWnd, hdcDraw);
    ::ReleaseCapture();

    if (!bCancel)
    {
        int nAnnoPoints = Points.GetItemCount();
        POINT* AnnoPoints  = new POINT[nAnnoPoints];
        if (AnnoPoints == NULL)
        {
            delete pAnnotation;
            Points.Destroy();
            _UpdateButtons(ID_SELECTCMD);
            return;
        }

        for (int i = 0; i < nAnnoPoints; i++)
        {
            CPoint pt;
            Points.GetItem(i, &pt);
            AnnoPoints[i].x = pt.x;
            AnnoPoints[i].y = pt.y;
        }

        Points.Destroy();

        pAnnotation->SetPoints(AnnoPoints, nAnnoPoints);
        pAnnotation->SetWidth(dwWidth);
        pAnnotation->SetColor(crLineColor);

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);
        DPA_AppendPtr(m_hdpaSelectedAnnotations, pAnnotation);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->AddAnnotation(pAnnotation);
        m_fDirty = TRUE;
    }
    _UpdateButtons(ID_SELECTCMD);
}

void CPreviewWnd::_StartEditing(BOOL bUpdateText)
{
    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) != 1)
        return;

    CTextAnnotation* pAnnotation = (CTextAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);

    if (!pAnnotation)
    {
        return;
    }
    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    if (m_ctlEdit.m_hWnd == NULL)
    {
        HWND hwndEdit = ::CreateWindow(TEXT("EDIT"), NULL, ES_LEFT | ES_MULTILINE | ES_AUTOVSCROLL |
                                    ES_WANTRETURN | WS_CHILD, 1, 1, 10, 10,
                                    m_ctlPreview.m_hWnd, (HMENU)1496, NULL, NULL);
        if (hwndEdit == NULL)
            return;

        m_ctlEdit.SubclassWindow(hwndEdit);
    }

    if (bUpdateText)
    {
        CComBSTR bstrText;
        bstrText.Attach(pAnnotation->GetText());
        if (bstrText.m_str != NULL)
            m_ctlEdit.SetWindowText(bstrText);
        else
            m_ctlEdit.SetWindowText(TEXT(""));
    }

    m_ctlEdit.EnableWindow(TRUE);

    LOGFONT lfFont;
    pAnnotation->GetFont(lfFont);

    HDC hdc = ::GetDC(NULL);
    LONG lHeight = pAnnotation->GetFontHeight(hdc);
    ::ReleaseDC(NULL, hdc);

    CRect rect(0,0,0,lHeight);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    lfFont.lfHeight = -rect.Height();

    HFONT hNewFont = ::CreateFontIndirect(&lfFont);
    if (hNewFont)
    {
        ::DeleteObject(m_hFont);
        m_hFont = hNewFont;
        m_ctlEdit.SendMessage(WM_SETFONT, (WPARAM)m_hFont, MAKELPARAM(TRUE,0));
    }

    pAnnotation->GetRect(rect);
    _RotateRect(rect, pAnnotation);
    m_ctlPreview.GetWindowFromImage((LPPOINT)(LPRECT)rect, 2);
    m_ctlEdit.SetWindowPos(NULL, rect.left, rect.top, rect.Width(), rect.Height(), SWP_NOZORDER);

    CSelectionTracker tracker;
    _SetupAnnotatingTracker(tracker, FALSE);

    CRect rectUpdate;
    tracker.GetTrueRect(rectUpdate);
    m_ctlPreview.InvalidateRect(rectUpdate);

    _SetupAnnotatingTracker(tracker, TRUE);
    tracker.GetTrueRect(rectUpdate);
    m_ctlPreview.InvalidateRect(rectUpdate);

    m_ctlEdit.ShowWindow(SW_SHOW);
    m_ctlEdit.SetFocus();

    m_fEditingAnnotation = TRUE;
}

void CPreviewWnd::_HideEditing()
{
    if (m_ctlEdit.m_hWnd == NULL)
        return;

    if (!m_ctlEdit.IsWindowVisible())
        return;

    SetFocus();
    m_ctlEdit.SetWindowPos(NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
    m_ctlEdit.EnableWindow(FALSE);
}

void CPreviewWnd::_StopEditing()
{
    if (m_ctlEdit.m_hWnd == NULL)
        return;

    _HideEditing();

    if (!m_fEditingAnnotation)
        return;

    m_fEditingAnnotation = FALSE;

    if (DPA_GetPtrCount(m_hdpaSelectedAnnotations) != 1)
        return;

    CTextAnnotation* pAnnotation = (CTextAnnotation*)DPA_GetPtr(m_hdpaSelectedAnnotations, 0);
    UINT uType = pAnnotation->GetType();

    if (uType != MT_TYPEDTEXT && uType != MT_FILETEXT && uType != MT_STAMP && uType != MT_ATTACHANOTE)
        return;

    // if the length greater than zero we save it
    // otherwise be blow away the annotation.
    int nLen = m_ctlEdit.GetWindowTextLength();
    if (nLen > 0)
    {
        CComBSTR bstrText(nLen+1);
        m_ctlEdit.GetWindowText(bstrText, nLen+1);
        pAnnotation->SetText(bstrText);
        m_fDirty = TRUE;
    }
    else
    {
        CSelectionTracker tracker;

        _SetupAnnotatingTracker(tracker, TRUE);

        CRect rectUpdate;
        tracker.GetTrueRect(rectUpdate);

        CRect rect;
        pAnnotation->GetRect(rect);
        rectUpdate.UnionRect(rectUpdate, rect);

        DPA_DeleteAllPtrs(m_hdpaSelectedAnnotations);

        CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
        pAnnotations->RemoveAnnotation(pAnnotation);
        delete pAnnotation;

        m_ctlPreview.InvalidateRect(rectUpdate);
        m_fDirty = TRUE;
    }
}

LRESULT CPreviewWnd::OnEditKeyEvent(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    switch (wParam)
    {
    case VK_ESCAPE:
        {
            CSelectionTracker tracker;
            _SetupAnnotatingTracker(tracker);
            CRect rectUpdate;
            tracker.GetTrueRect(rectUpdate);

            _HideEditing();

            m_ctlPreview.InvalidateRect(rectUpdate);
            _RefreshSelection();

            fHandled = TRUE;
        }
        break;

    default:
        fHandled = FALSE;
        break;
    }
    return 0;
}

BOOL_PTR CALLBACK CPreviewWnd::_AnnoPropsDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    static LOGFONT lfFont;
    static COLORREF crFont;
    static COLORREF crColor;
    CPreviewWnd* pThis;

    switch (msg)
    {
        case WM_INITDIALOG:
            {
                HWND hwndCtl = NULL;
                ::SetWindowLongPtr(hwnd, DWLP_USER, lParam);
                pThis = (CPreviewWnd*)lParam;

                CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(pThis->m_hdpaSelectedAnnotations, 0);

                hwndCtl = ::GetDlgItem(hwnd, IDC_WIDTHTEXT);
                if (!pAnnotation->HasWidth())
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                hwndCtl = ::GetDlgItem(hwnd, IDC_WIDTH);
                if (pAnnotation->HasWidth())
                {
                    UINT i = pAnnotation->GetWidth();
                    ::SetDlgItemInt(hwnd, IDC_WIDTH, i, FALSE);

                    hwndCtl = ::GetDlgItem(hwnd, IDC_SPIN);
                    ::SendMessage(hwndCtl, UDM_SETRANGE32, (WPARAM)1, (LPARAM)50);
                    ::SendMessage(hwndCtl, UDM_SETPOS32, 0, (LPARAM)i);
                }
                else
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                    hwndCtl = ::GetDlgItem(hwnd, IDC_SPIN);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                hwndCtl = ::GetDlgItem(hwnd, IDC_TRANSPARENT);
                if (pAnnotation->HasTransparent())
                {
                    BOOL bTransparent = pAnnotation->GetTransparent();
                    ::SendMessage(hwndCtl, BM_SETCHECK, (WPARAM)(bTransparent ? BST_CHECKED : BST_UNCHECKED), 0);
                }
                else
                {
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }

                if (pAnnotation->HasFont())
                {
                    pAnnotation->GetFont(lfFont);
                    crFont = pAnnotation->GetFontColor();
                }
                else
                {
                    hwndCtl = ::GetDlgItem(hwnd, IDC_FONT);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }


                if (pAnnotation->HasColor())
                {
                    crColor = pAnnotation->GetColor();
                }
                else
                {
                    hwndCtl = ::GetDlgItem(hwnd, IDC_COLOR);
                    ::EnableWindow(hwndCtl, FALSE);
                    ::ShowWindow(hwndCtl, SW_HIDE);
                }
            }
            break;

        case WM_COMMAND:
            pThis = (CPreviewWnd*)::GetWindowLongPtr(hwnd, DWLP_USER);

            switch (wParam)
            {
                case IDOK:
                    pThis->_RefreshSelection();
                    {
                        HWND hwndCtl = NULL;
                        CAnnotation* pAnnotation = (CAnnotation*)DPA_GetPtr(pThis->m_hdpaSelectedAnnotations, 0);

                        CRegKey Key;
                        if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
                        {
                            Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
                        }

                        if (pAnnotation->HasWidth())
                        {
                            UINT uWidth = ::GetDlgItemInt(hwnd, IDC_WIDTH, NULL, FALSE);

                            if (uWidth > 50 || uWidth < 1)
                            {
                                CComBSTR bstrMsg, bstrTitle;

                                if (bstrMsg.LoadString(IDS_WIDTHBAD_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
                                {
                                    ::MessageBox(hwnd, bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                                }

                                ::SetDlgItemInt(hwnd, IDC_WIDTH, 50, FALSE);
                                return FALSE;
                            }

                            pAnnotation->SetWidth(uWidth);
                            if (Key.m_hKey != NULL)
                            {
                                Key.SetValue(uWidth, REGSTR_LINEWIDTH);
                            }
                        }

                        if (pAnnotation->HasTransparent())
                        {
                            hwndCtl = ::GetDlgItem(hwnd, IDC_TRANSPARENT);
                            BOOL bTransparent = FALSE;
                            if (::SendMessage(hwndCtl, BM_GETCHECK, 0, 0) == BST_CHECKED)
                                bTransparent = TRUE;

                            pAnnotation->SetTransparent(bTransparent);
                        }

                        if (pAnnotation->HasFont())
                        {
                            lfFont.lfHeight = (lfFont.lfHeight > 0) ? lfFont.lfHeight : -lfFont.lfHeight;
                            pAnnotation->SetFont(lfFont);
                            pAnnotation->SetFontColor(crFont);
                            if (Key.m_hKey != NULL)
                            {
                                Key.SetValue(crFont, REGSTR_TEXTCOLOR);
                                ::RegSetValueEx(Key, REGSTR_FONT, 0, REG_BINARY, (LPBYTE)&lfFont, sizeof(lfFont));
                            }
                        }

                        if (pAnnotation->HasColor())
                        {
                            pAnnotation->SetColor(crColor);
                            UINT uType = pAnnotation->GetType();
                            if (Key.m_hKey != NULL)
                            {
                                if (uType == MT_STRAIGHTLINE || uType == MT_FREEHANDLINE || uType == MT_HOLLOWRECT)
                                    Key.SetValue(crColor, REGSTR_LINECOLOR);
                                else
                                    Key.SetValue(crColor, REGSTR_BACKCOLOR);
                            }
                        }

                    }
                    pThis->m_fDirty = TRUE;
                    pThis->_RefreshSelection();
                    EndDialog(hwnd, wParam);
                    return FALSE;
                case IDCANCEL:
                    EndDialog(hwnd, wParam);
                    return FALSE;
                case IDC_FONT:
                    {
                        CHOOSEFONT cf = {0};
                        LOGFONT lf;

                        lf = lfFont;

                        cf.lStructSize = sizeof(cf);
                        cf.hwndOwner = hwnd;
                        cf.lpLogFont = &lf;
                        cf.Flags = CF_SCREENFONTS | CF_EFFECTS | CF_INITTOLOGFONTSTRUCT | CF_NOVERTFONTS | CF_NOSCRIPTSEL;
                        cf.rgbColors = crFont;

                        if (::ChooseFont(&cf))
                        {
                            CopyMemory (&lfFont, &lf, sizeof(lf));
                            crFont = cf.rgbColors;
                        }
                    }
                    return FALSE;
                case IDC_COLOR:
                    {
                        CHOOSECOLOR cc = {0};

                        cc.lStructSize = sizeof(cc);
                        cc.hwndOwner = hwnd;
                        cc.rgbResult = crColor;
                        cc.lpCustColors = g_crCustomColors;
                        cc.Flags = CC_RGBINIT | CC_SOLIDCOLOR;

                        if (::ChooseColor(&cc))
                        {
                            crColor = cc.rgbResult;
                        }
                    }
                    return FALSE;
                default:
                    break;
            }
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

BOOL CPreviewWnd::_TrySetImage()
{
    BOOL fRet = FALSE;
    if (m_pNextImageData && m_pNextImageData->_iItem == m_iCurSlide)
    {
        if (SUCCEEDED(m_pNextImageData->_hr))
        {
            m_fCanSave = !m_pNextImageData->_fIsReadOnly;

            // update the toolbar state, our child windows, and our sibling windows
            _SetNewImage(m_pNextImageData);
            ATOMICRELEASE(m_pNextImageData);

            if (m_pImageData->IsAnimated() && _ShouldDisplayAnimations())
            {
                // start the animation timer
                SetTimer(TIMER_ANIMATION, m_pImageData->GetDelay());
            }

            // Notify anyone listening to our events that a preview has been completed
            // we only fire this upon success
            if (m_pEvents)
            {
                m_pEvents->OnPreviewReady();
            }
            fRet = TRUE;
        }
        else
        {
            // update the status to display an error message.  This will also update the toolbar state.
            StatusUpdate(IDS_LOADFAILED);

            //
            // We can't remove the item from the array because the user might try to delete it while
            // the "load failed" string is still visible for it.


            // even though the item failed to decode we must wait on the "Load Failed" state when we are in
            // windowed mode, otherwise "open with..." is broken when you open a corrupted image or non-image.
            // In slideshow mode we could simply skip to the next image.

            if (m_pEvents)
                m_pEvents->OnError();
        }
    }

    return fRet;
}

LRESULT CPreviewWnd::IV_OnSetImageData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    CDecodeTask * pData = (CDecodeTask *)wParam;

    ATOMICRELEASE(m_pNextImageData);

    m_pNextImageData = pData;

    if (m_pNextImageData && m_iDecodingNextImage == m_pNextImageData->_iItem)
    {
        // We have finished decoding now, let's remember this.
        m_iDecodingNextImage = -1;

        // Let 's prepare the drawing now. This draws in the back buffer. Don't start this if we want to see
        // the image now, as it would delay things.
        if (SUCCEEDED(m_pNextImageData->_hr) && m_pNextImageData->_iItem != m_iCurSlide)
        {
            m_ctlPreview.PrepareImageData(m_pNextImageData);
        }
    }

    _TrySetImage();
    return TRUE;
}


// Creation of the image data is asynchronous.  When our worker thread is done decoding
// an image it posts a IV_SETIMAGEDATA message with the image data object.  As a result,
// we must flush these messages when the window is destroyed to prevent leaking any handles.

void CPreviewWnd::FlushBitmapMessages()
{
    // Pass TRUE to wait for task to be removed before peeking out its messages
    // Otherwise, if the task is in the middle of running, our PeekMessage won't
    // see anything and we will return.  Then the task will finish, post its message,
    // and leak the data since we're not around to receive it.
    TASKOWNERID toid;
    GetTaskIDFromMode(GTIDFM_DECODE, m_dwMode, &toid);
    if (m_pTaskScheduler)
    {
        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
    }

    // if we were waiting for another image frame to be generated then cut it out, we don't care about that anymore
    // if we have an animation timer running then kill it and remove any WM_TIMER messages
    KillTimer(TIMER_ANIMATION);
    KillTimer(TIMER_SLIDESHOW);

    MSG msg;
    while (PeekMessage(&msg, m_hWnd, WM_TIMER, WM_TIMER, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already
        // Posted a quit message then PeekMessage will return a WM_QUIT message
        // regardless of the filter min and max and subsequent calls to
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }
    }

    // make sure any posted messages get flushed and we free the associated data
    while (PeekMessage(&msg, m_hWnd, IV_SETIMAGEDATA, IV_SETIMAGEDATA, PM_REMOVE))
    {
        // NTRAID#NTBUG9-359356-2001/04/05-seank
        // If the queue is empty when PeekMessage is called and we have already
        // Posted a quit message then PeekMessage will return a WM_QUIT message
        // regardless of the filter min and max and subsequent calls to
        // GetMessage will hang indefinitely see SEANK or JASONSCH for more
        // info.
        if (msg.message == WM_QUIT)
        {
            PostQuitMessage(0);
            return;
        }

        CDecodeTask * pData = (CDecodeTask *)msg.wParam;
        ATOMICRELEASE(pData);
    }
}

LRESULT CPreviewWnd::OnCopyData(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL&)
{
    // We can get into a situation where we are still trying to preview
    // the previous oncopydata because the previous window to that was a
    // tiff that was being annotated and is prompting you to save. In this
    // case throw away any future data

    if (_pdtobj != NULL || m_fPromptingUser)
        return TRUE;

    COPYDATASTRUCT *pcds = (COPYDATASTRUCT*)lParam;
    if (pcds)
    {
        HRESULT hr = E_FAIL;
        switch (pcds->dwData)
        {
        case COPYDATATYPE_DATAOBJECT:
            {
                IStream *pstm;
                if (SUCCEEDED(CreateStreamOnHGlobal(NULL, TRUE, &pstm)))
                {
                    const LARGE_INTEGER li = {0, 0};

                    pstm->Write(pcds->lpData, pcds->cbData, NULL);
                    pstm->Seek(li, STREAM_SEEK_SET, NULL);

                    // unfortunaly we can not program the data object here as we are in a
                    // SendMessage() and any calls made on the data object will fail because
                    // of this. instead we grab a ref to the data object and set a timer
                    // so we can handle this once we have unwound from the send.

                    hr = CoUnmarshalInterface(pstm, IID_PPV_ARG(IDataObject, &_pdtobj));
                    pstm->Release();
                }
            }
            break;
        case COPYDATATYPE_FILENAME:
            {
                hr = GetUIObjectFromPath((LPCTSTR)pcds->lpData, IID_PPV_ARG(IDataObject, &_pdtobj));
            }
            break;
        }
        // unfortunaly we can not program the data object here as we are in a
        // SendMessage() and any calls made on the data object will fail because
        // of this. instead we grab a ref to the data object and set a timer
        // so we can handle this once we have unwound from the send.

        if (SUCCEEDED(hr))
        {
            SetTimer(TIMER_DATAOBJECT, 100);    // do the real work here
        }
    }
    return TRUE;
}

DWORD MakeFilterFromCodecs(LPTSTR szFilter, size_t cbFilter, UINT nCodecs, ImageCodecInfo *pCodecs, LPTSTR szExt, BOOL fExcludeTIFF)
{
    size_t nOffset = 0;
    DWORD dwRet = 1;
    for (UINT i = 0; i < nCodecs && nOffset < cbFilter - 1; i++)
    {
        if (fExcludeTIFF && StrStrI(pCodecs->FilenameExtension, L"*.tif"))
        {
            continue;
        }
        // make sure there's space for nulls between strings and 2 at the end
        if (4+lstrlen(pCodecs->FormatDescription) + lstrlen(pCodecs->FilenameExtension) + nOffset < cbFilter)
        {           
            StrCpyN(szFilter+nOffset,pCodecs->FormatDescription, cbFilter -(nOffset + 1));
            nOffset+=lstrlen(pCodecs->FormatDescription)+1;
            StrCpyN(szFilter+nOffset,pCodecs->FilenameExtension, cbFilter -(nOffset + 1));
            nOffset+=lstrlen(pCodecs->FilenameExtension)+1;
            if (StrStrI(pCodecs->FilenameExtension, szExt))
            {
                dwRet = i + 1;
            }
            pCodecs++;
        }
    }
    szFilter[nOffset] = 0;
    return dwRet;
}

DWORD CPreviewWnd::_GetFilterStringForSave(LPTSTR szFilter, size_t cbFilter, LPTSTR szExt)
{
    UINT nCodecs = 0;
    UINT cbCodecs = 0;
    BYTE *pData;
    GetImageEncodersSize (&nCodecs, &cbCodecs);
    DWORD dwRet = 1; // ofn.nFilterIndex is 1-based
    if (cbCodecs)
    {
        pData = new BYTE[cbCodecs];
        if (pData)
        {
            ImageCodecInfo *pCodecs = reinterpret_cast<ImageCodecInfo*>(pData);
            if (Ok == GetImageEncoders (nCodecs, cbCodecs, pCodecs))
            {
                dwRet = MakeFilterFromCodecs(szFilter, cbFilter, nCodecs, pCodecs, szExt, m_pImageData->IsExtendedPixelFmt());
            }
            delete [] pData;
        }
    }
    return dwRet;
}

HRESULT CPreviewWnd::SaveAs(BSTR bstrPath)
{
    HRESULT hr = E_FAIL;

    if (m_pImageData && m_pImageFactory)
    {
        IShellImageData * pSID;
        hr = m_pImageData->Lock(&pSID);
        if (SUCCEEDED(hr))
        {
            GUID guidFmt;
            if (SUCCEEDED(m_pImageFactory->GetDataFormatFromPath(bstrPath, &guidFmt)))
            {
                IPropertyBag *pbagEnc;
                hr = SHCreatePropertyBagOnMemory(STGM_READWRITE, IID_PPV_ARG(IPropertyBag, &pbagEnc));
                if (SUCCEEDED(hr))
                {
                    VARIANT var;
                    hr = InitVariantFromGUID(&var, guidFmt);
                    if (SUCCEEDED(hr))
                    {
                        hr = pbagEnc->Write(SHIMGKEY_RAWFORMAT, &var);
                        if (SUCCEEDED(hr))
                        {
                            hr = pSID->SetEncoderParams(pbagEnc);
                        }
                        VariantClear(&var);
                    }
                    pbagEnc->Release();
                }
            }

            IPersistFile *ppf;
            hr = pSID->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
            if (SUCCEEDED(hr))
            {
                hr = ppf->Save(bstrPath, TRUE);
                ppf->Release();
            }
            m_pImageData->Unlock();
        }
    }

    return hr;
}

BOOL CPreviewWnd::_IsImageFile(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    if (m_pici || _BuildDecoderList())
    {
        bRet = (-1 != FindInDecoderList(m_pici, m_cDecoders, pszFile));
    }
    return bRet;
}

BOOL CPreviewWnd::_BuildDecoderList()
{
    UINT cb;
    BOOL bRet = FALSE;
    if (Ok == GetImageDecodersSize(&m_cDecoders, &cb))
    {
        m_pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
        if (m_pici)
        {
            if (Ok != GetImageDecoders(m_cDecoders, cb, m_pici))
            {
                LocalFree(m_pici);
                m_pici = NULL;
            }
            else
            {
                bRet = TRUE;
            }
        }
    }
    return bRet;
}

void CPreviewWnd::OpenFileList(HWND hwnd, IDataObject *pdtobj)
{
    if (NULL == hwnd)
        hwnd = m_hWnd;

    IStream *pstm;
    HRESULT hr = CreateStreamOnHGlobal(NULL, TRUE, &pstm);
    if (SUCCEEDED(hr))
    {
        hr = CoMarshalInterface(pstm, IID_IDataObject, pdtobj, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_NORMAL);
        if (SUCCEEDED(hr))
        {
            HGLOBAL hGlobal;
            hr = GetHGlobalFromStream(pstm, &hGlobal);
            if (SUCCEEDED(hr))
            {
                COPYDATASTRUCT cds = {0};
                cds.dwData = COPYDATATYPE_DATAOBJECT;
                cds.cbData = (DWORD)GlobalSize(hGlobal);
                cds.lpData = GlobalLock(hGlobal);
                SendMessage(hwnd, WM_COPYDATA, NULL, (LPARAM)&cds);
                SetForegroundWindow(hwnd);

                GlobalUnlock(hGlobal);
            }
        }
        pstm->Release();
    }
}

void CPreviewWnd::OpenFile(HWND hwnd, LPCTSTR pszFile)
{
    if (NULL == hwnd)
        hwnd = m_hWnd;

    COPYDATASTRUCT cds = {0};
    cds.dwData = COPYDATATYPE_FILENAME;
    cds.cbData = (lstrlen(pszFile)+1)*sizeof(TCHAR);
    cds.lpData = (void*)pszFile;
    SendMessage(hwnd, WM_COPYDATA, NULL, (LPARAM)&cds);
    SetForegroundWindow(hwnd);
}

// returns:
//      TRUE    window was re-used

BOOL CPreviewWnd::TryWindowReuse(IDataObject *pdtobj)
{
    BOOL bRet = FALSE;
    HWND hwnd = FindWindow(TEXT("ShImgVw:CPreviewWnd"), NULL);
    if (hwnd)
    {
        // window reuse can't always work because shortcuts are launched on a thread that 
        // is too short lived to support the marshalled IDataObject given to us via WM_COPYDATA
        // For now we'll try to close an existing window and open a new one.
        ::PostMessage(hwnd, WM_CLOSE, 0, 0);
    }
    return bRet;
}

// returns:
//      TRUE    window was re-used

BOOL CPreviewWnd::TryWindowReuse(LPCTSTR pszFileName)
{
    BOOL bRet = FALSE;
    HWND hwnd = FindWindow(TEXT("ShImgVw:CPreviewWnd"), NULL);
    if (hwnd)
    {
        DWORD_PTR dwResult = FALSE;
        SendMessageTimeout(hwnd, IV_ISAVAILABLE, 0, 0, SMTO_ABORTIFHUNG | SMTO_BLOCK, 1000, &dwResult);
        if (dwResult)
        {
            OpenFile(hwnd, pszFileName);            
            bRet = TRUE;
        }
    }
    return bRet;
}

STDMETHODIMP CPreviewWnd::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPreviewWnd, IDropTarget),
        QITABENT(CPreviewWnd, INamespaceWalkCB),
        QITABENT(CPreviewWnd, IServiceProvider),
        QITABENT(CPreviewWnd, IImgCmdTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPreviewWnd::AddRef()
{
    return 3;
}

STDMETHODIMP_(ULONG) CPreviewWnd::Release()
{
    return 2;
}

// INamespaceWalkCB
STDMETHODIMP CPreviewWnd::FoundItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_FALSE;

    if (m_fFirstItem && (WINDOW_MODE == m_dwMode))
    {
        // REVIEW: Do this in other modes too?
        StatusUpdate(IDS_LOADING);
        m_fFirstItem = FALSE;
        hr = S_OK;
    }
    else
    {
        TCHAR szName[MAX_PATH];
        DisplayNameOf(psf, pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
        if (_IsImageFile(szName))
        {
            hr = S_OK;
        }       
    
    }
    if (WINDOW_MODE == m_dwMode)
    {
        MSG msg;
        while (PeekMessage(&msg, m_hWnd, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);          
        }
    }
    return hr;
}

STDMETHODIMP CPreviewWnd::EnterFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

STDMETHODIMP CPreviewWnd::LeaveFolder(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    return S_OK;
}

// IDropTarget
STDMETHODIMP CPreviewWnd::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    m_dwEffect = DROPEFFECT_NONE;
    //
    // We only support CFSTR_SHELLIDLIST and CF_HDROP
    //
    static CLIPFORMAT cfidlist = 0;
    if (!cfidlist)
    {
        cfidlist = (CLIPFORMAT)RegisterClipboardFormat(CFSTR_SHELLIDLIST);
    }
    FORMATETC fmt = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->QueryGetData(&fmt)))
    {
        m_dwEffect = DROPEFFECT_COPY;
    }
    else
    {
        fmt.cfFormat = cfidlist;
        if (SUCCEEDED(pdtobj->QueryGetData(&fmt)))
        {
            m_dwEffect = DROPEFFECT_COPY;
        }
    }
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::DragLeave()
{
    m_dwEffect = DROPEFFECT_NONE;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (m_dwEffect != DROPEFFECT_NONE)
    {
        PreviewItemsFromUnk(pdtobj);
    }
    *pdwEffect &= m_dwEffect;
    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IServiceProvider
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPreviewWnd::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    if (SID_SImageView == guidService)
    {
        return QueryInterface(riid, ppv);
    }
    else if (m_punkSite)
    {
        return IUnknown_QueryService(m_punkSite, guidService, riid, ppv);
    }
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////////////////////////////////
//
// IImgCmdTarget
//
//////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CPreviewWnd::GetMode(DWORD * pdw)
{
    *pdw = m_dwMode;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::GetPageFlags(DWORD * pdw)
{
    *pdw = m_dwMultiPageMode;
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ZoomIn()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_ctlPreview.ZoomIn();
    }
    else
    {
        m_ctlPreview.SetMode(CZoomWnd::MODE_ZOOMIN);
        m_ctlPreview.ZoomIn();

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(TRUE, 0));

        _UpdateButtons(ID_ZOOMINCMD);
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ZoomOut()
{
    if (SLIDESHOW_MODE == m_dwMode)
    {
        m_ctlPreview.ZoomOut();
    }
    else
    {
        m_ctlPreview.SetMode(CZoomWnd::MODE_ZOOMOUT);
        m_ctlPreview.ZoomOut();

        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
        m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(!m_ctlPreview.IsBestFit(), 0));

        _UpdateButtons(ID_ZOOMOUTCMD);
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::ActualSize()
{
    _RefreshSelection(FALSE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(TRUE, 0));

    m_ctlPreview.ActualSize();
    if (m_pEvents)
    {
        m_pEvents->OnActualSizePress();
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::BestFit()
{
    _RefreshSelection(FALSE);
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ACTUALSIZECMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BESTFITCMD, MAKELONG(FALSE, 0));

    m_ctlPreview.BestFit();
    if (m_pEvents)
    {
        m_pEvents->OnBestFitPress();
    }
    return S_OK;
}

STDMETHODIMP CPreviewWnd::Rotate(DWORD dwAngle)
{
    WORD wRotate;
    switch (dwAngle)
    {
    case 90:
        wRotate = ID_ROTATE90CMD;
        break;

    case 270:
        wRotate = ID_ROTATE270CMD;
        break;

    default:
        return E_INVALIDARG;
    }

    // If we don't have an image yet, there is nothing for us to do.
    // Note:  The keyboard accelerator will hit this path if no image is selected
    if (!m_pImageData)
        return E_FAIL;

    // We quietly (the button is disabled but just in case you hit the
    // accelerator key) don't rotate WMF or EMF.
    if (IsEqualGUID(ImageFormatWMF, m_pImageData->_guidFormat) || IsEqualGUID(ImageFormatEMF, m_pImageData->_guidFormat))
        return E_FAIL;

    // Animated GIFs are not editable even though normal GIFs are.  This can
    // cause a lot of confusion, so provide some feedback if the user tries
    // to rotate an animated image.
    if (m_pImageData->IsAnimated())
    {
        TCHAR szPath[MAX_PATH];
        PathFromImageData(szPath, ARRAYSIZE(szPath));
        m_fPromptingUser = TRUE;
        ShellMessageBox(_Module.GetModuleInstance(), m_hWnd, MAKEINTRESOURCE(IDS_ROTATE_MESSAGE), MAKEINTRESOURCE(IDS_PROJNAME), MB_OK | MB_ICONERROR, szPath);
        m_fPromptingUser = FALSE;
        return E_FAIL;
    }

    // From here on out you need to goto ErrorCleanup rather than return
    _UpdateButtons(wRotate);
    SetCursorState(SLIDESHOW_CURSOR_BUSY);

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(FALSE, 0));
    m_ctlToolbar.UpdateWindow();

    if (m_pTaskScheduler)
    {
        TASKOWNERID toid;
        GetTaskIDFromMode(GTIDFM_DRAW, m_dwMode, &toid);
        m_pTaskScheduler->RemoveTasks(toid, ITSAT_DEFAULT_LPARAM, TRUE);
    }

    HRESULT hr = E_FAIL;
    SIZE sz;
    m_pImageData->GetSize(&sz);

    // if we're thinking we can quietly save
    if (m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // And the rotation might be lossy
        if (::IsEqualGUID(ImageFormatJPEG, m_pImageData->_guidFormat) && ((sz.cx % 16 != 0) || (sz.cy % 16 != 0)))
        {
            int nResult = IDOK;

            if (m_fWarnQuietSave)
            {
                CComBSTR bstrMsg, bstrTitle;
                if (bstrMsg.LoadString(IDS_ROTATE_LOSS) && bstrTitle.LoadString(IDS_PROJNAME))
                {
                    // Set default to return IDOK so we know if the user selected something or
                    // if the "don't show me this again" bit was respected
                    m_fPromptingUser = TRUE;
                    nResult = SHMessageBoxCheck(m_hWnd, bstrMsg, bstrTitle, MB_YESNO|MB_ICONWARNING, IDOK, REGSTR_LOSSYROTATE);
                    m_fPromptingUser = FALSE;
                }

                if (nResult != IDNO)
                    m_fWarnQuietSave = FALSE;
            }

            CRegKey Key;
            if (ERROR_SUCCESS != Key.Open(HKEY_CURRENT_USER, REGSTR_SHIMGVW))
            {
                Key.Create(HKEY_CURRENT_USER, REGSTR_SHIMGVW);
            }

            if (Key.m_hKey != NULL)
            {
                if (nResult == IDOK) // If hidden, then load last result from registry
                {
                    DWORD dwResult = 0;
                    Key.QueryValue(dwResult, REGSTR_LOSSYROTATE);
                    nResult = (int)dwResult;
                }
                else // Otherwise, write this as last result to registry
                {
                    DWORD dwResult = (DWORD)nResult;
                    Key.SetValue(dwResult, REGSTR_LOSSYROTATE);
                }
            }

            if (nResult == IDNO)
                goto ErrorCleanup;
        }
    }

    CAnnotationSet* pAnnotations = m_ctlPreview.GetAnnotations();
    INT_PTR nCount = pAnnotations->GetCount();
    for (INT_PTR i = 0; i < nCount; i++)
    {
        CAnnotation* pAnnotation = pAnnotations->GetAnnotation(i);
        pAnnotation->Rotate(m_ctlPreview.m_cyImage, m_ctlPreview.m_cxImage, (ID_ROTATE90CMD == wRotate));
    }

    m_ctlPreview.CommitAnnotations();

    hr = m_pImageData->Rotate(dwAngle);
    if (FAILED(hr))
        goto ErrorCleanup;

    // Only if we have an encoder and we haven't been explicitly told not to edit and the source is writeable
    if (m_pImageData->IsEditable() && !m_fDisableEdit && m_fCanSave)
    {
        // on successful edit we immediately save the result.  If we want to do multiple edits
        // before saving then you would simply need to wait and call Save later.

        // NB:  We currently only allow editing of items loaded from file system paths, no path means
        // no edit.  This is stupid, but that's how it is for now.
        hr = ImageDataSave(NULL, FALSE);
        if (SUCCEEDED(hr))
            m_fDirty = FALSE;
        else
        {
            // if we failed to save then go into can't save mode
            if (WINDOW_MODE == m_dwMode)
                m_fCanSave = FALSE;
        }
    }

    _UpdateImage();

    if ((!m_pImageData->IsEditable() || !m_fCanSave) && WINDOW_MODE == m_dwMode)
    {
        if (m_fWarnNoSave)
        {
            m_fWarnNoSave = FALSE;

            CComBSTR bstrMsg, bstrTitle;
            TCHAR szMsg[MAX_PATH];
            if (LoadSPString(IDS_SHIMGVW_ROTATE_CANTSAVE, szMsg, ARRAYSIZE(szMsg)) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                SHMessageBoxCheck(m_hWnd, szMsg, bstrTitle, MB_OK|MB_ICONWARNING, IDOK, REGSTR_SAVELESS);
                m_fPromptingUser = FALSE;
            }
        }
    }

ErrorCleanup:

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE90CMD, MAKELONG(TRUE, 0));
    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_ROTATE270CMD, MAKELONG(TRUE, 0));

    SetCursorState(SLIDESHOW_CURSOR_NOTBUSY);

    return hr;
}

STDMETHODIMP CPreviewWnd::NextPage()
{
    return _PrevNextPage(TRUE);
}

STDMETHODIMP CPreviewWnd::PreviousPage()
{
    return _PrevNextPage(FALSE);
}

HRESULT CPreviewWnd::_PrevNextPage(BOOL fForward)
{
    _RefreshSelection(FALSE);
    if (m_pImageData && m_pImageData->IsMultipage())
    {
        if (m_fDirty)
        {
            m_ctlPreview.CommitAnnotations();
        }
        if (fForward)
        {
            m_pImageData->NextPage();
        }
        else
        {
            m_pImageData->PrevPage();
        }
        _UpdateImage();
        _SetMultipageCommands();
    }
    return S_OK;
}


//
// When the user saves to a format other than TIFF and the current
// TIFF has annotations, we need to burn annotations
// into the current image frame before saving.
// If we ever support other multi-page format encoding besides TIFF, this
// code will get more complicated
// assumes the pSID is already locked
// note that the resulting image is always a color image. Eventually we should make
// the annotation rendering code respect the bit depth and palette of the
// current image.

Image *CPreviewWnd::_BurnAnnotations(IShellImageData *pSID)
{
    Image *pimg = NULL;

    if (SUCCEEDED(pSID->CloneFrame(&pimg)))
    {
        HDC hdc = ::GetDC(NULL);
        if (hdc)
        {
            LPVOID pBits;
            BITMAPINFO bi = {0};

            bi.bmiHeader.biBitCount = 24;
            bi.bmiHeader.biHeight = pimg->GetHeight();
            bi.bmiHeader.biWidth = pimg->GetWidth();
            bi.bmiHeader.biPlanes = 1;
            bi.bmiHeader.biCompression = BI_RGB;
            bi.bmiHeader.biSize = sizeof(bi.bmiHeader);

            HBITMAP hbm = CreateDIBSection(hdc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0);
            if (hbm)
            {
                //
                // For ROP codes to work we need to use pure GDI, then convert the new
                // DIBSection back to an Image object
                //
                HDC hdcMem = ::CreateCompatibleDC(hdc);
                Status s = GenericError;
                if (hdcMem)
                {
                    HBITMAP hbmOld = (HBITMAP)::SelectObject(hdcMem, hbm);
                    Graphics *g = Graphics::FromHDC(hdcMem);
                    if (g)
                    {
                        s = g->DrawImage(pimg, 0L, 0L, pimg->GetWidth(), pimg->GetHeight());
                        g->ReleaseHDC(hdcMem);
                        delete g;
                        // now draw the annotations
                        m_ctlPreview.GetAnnotations()->RenderAllMarks(hdcMem);
                    }
                    ::SelectObject(hdcMem, hbmOld);
                    ::DeleteDC(hdcMem);
                }
                if (Ok == s)
                {
                    //
                    // Now create a new Bitmap from our DIBSection
                    Bitmap *pbmNew = Bitmap::FromHBITMAP(hbm, NULL);
                    if (pbmNew)
                    {
                        pSID->ReplaceFrame(pbmNew);
                    }
                }
                DeleteObject(hbm);
            }
            ::ReleaseDC(NULL, hdc);
        }
    }
    return pimg;
}

void CPreviewWnd::_InvokePrintWizard()
{
    if (m_fPrintable)
    {
        HRESULT hr = S_OK;
        if (m_fDirty)
        {
            m_ctlPreview.CommitAnnotations();
            hr = ImageDataSave(NULL, FALSE);
        }
        if (SUCCEEDED(hr))
        {
            m_fDirty = FALSE;
            
            IPrintPhotosWizardSetInfo *pwiz;
            HRESULT hr = CoCreateInstance(CLSID_PrintPhotosWizard,
                                          NULL, CLSCTX_INPROC_SERVER,
                                          IID_PPV_ARG(IPrintPhotosWizardSetInfo, &pwiz));
            if (SUCCEEDED(hr))
            {
                if (m_pImageData != NULL && m_pImageData->_guidFormat == ImageFormatTIFF && m_pImageData->IsMultipage())
                    hr = pwiz->SetFileListArray(&(m_ppidls[m_iCurSlide]), 1, 0);
                else
                    hr = pwiz->SetFileListArray(m_ppidls, m_cItems, m_iCurSlide);
                
                if (SUCCEEDED(hr))
                {
                    m_fPromptingUser = TRUE;
                    hr = pwiz->RunWizard();
                    m_fPromptingUser = FALSE;
                }
                pwiz->Release();
            }
            // fall back to the shell if the wizard fails
            if (FAILED(hr))
            {
                _InvokeVerb(TEXT("print"));
            }
        }
        else
        {
            CComBSTR bstrMsg, bstrTitle;

            if (bstrMsg.LoadString(IDS_SAVEFAILED_MSGBOX) && bstrTitle.LoadString(IDS_PROJNAME))
            {
                m_fPromptingUser = TRUE;
                MessageBox(bstrMsg, bstrTitle, MB_OK | MB_ICONERROR | MB_APPLMODAL);
                m_fPromptingUser = FALSE;
            }
        }
    }
}

void GetTaskIDFromMode(DWORD dwTask, DWORD dwMode, TASKOWNERID *ptoid)
{
    switch (dwTask)
    {
    case GTIDFM_DECODE:
        *ptoid = (SLIDESHOW_MODE == dwMode) ? TOID_SlideshowDecode : TOID_PrimaryDecode;
        break;

    case GTIDFM_DRAW:
        *ptoid = (SLIDESHOW_MODE == dwMode) ? TOID_DrawSlideshowFrame : TOID_DrawFrame;
        break;

    default:
        ASSERTMSG(FALSE, "someone passed bad task to GetTaskIDFromMode");
        break;
    }
}


// Watch for changes in the file we are currently viewing. This ignores changes
// in the file being pre-fetched, but we'll live with that for now.
//
void CPreviewWnd::_RegisterForChangeNotify(BOOL fRegister)
{
    // always deregister the current pidl first
    if (m_uRegister)
    {
        SHChangeNotifyDeregister(m_uRegister);
        m_uRegister = 0;
    }
    if (fRegister)
    {
        SHChangeNotifyEntry cne = {0};
        if (SUCCEEDED(_GetItem(m_iCurSlide, (LPITEMIDLIST*)&cne.pidl)))
        {
            m_uRegister = SHChangeNotifyRegister(m_hWnd,
                                                 SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_NewDelivery,
                                                 SHCNE_DISKEVENTS,
                                                 IV_ONCHANGENOTIFY,
                                                 1, &cne);
            ILFree((LPITEMIDLIST)cne.pidl);
        }
    }
}

LRESULT CPreviewWnd::OnChangeNotify(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // We can assume this notify is for the currently viewed PIDL and the event
    // is one that would force us to reload
    //
    
    LONG lEvent;
    LPSHChangeNotificationLock pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, NULL, &lEvent);
    if (pshcnl)
    {
        // we can't render or manipulate deleted files so don't try
        if (!m_fDirty || lEvent == SHCNE_DELETE || lEvent == SHCNE_RENAMEITEM)
        {
            if (!m_fIgnoreNextNotify)
            {
                m_fDirty = FALSE;
                _PreviewItem(m_iCurSlide);
            }
            else
            {
                m_fIgnoreNextNotify = FALSE;
            }
            bHandled = TRUE;
        }

        SHChangeNotification_Unlock(pshcnl);
    }
    return 0;
}

LRESULT CPreviewWnd::OnIsAvailable(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    bHandled = TRUE;
    return !m_fPromptingUser;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\shutil.h ===
#include <objbase.h>
#include <assert.h>
#include <shlwapi.h>
#include <stdio.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <ccstock.h>
#include <shlwapip.h>
#include "tasks.h"

HRESULT SHStringFromCLSIDA(LPSTR szCLSID, DWORD cSize, REFCLSID rclsid);

#define SHStringFromCLSID(a,b,c)    StringFromGUID2(c, a, b)

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile);
HRESULT GetUIObjectFromPath(LPCTSTR pszFile, REFIID riid, void **ppv);
BOOL FmtSupportsMultiPage(IShellImageData *pData, GUID *pguidFmt);

// S_OK -> YES, S_FALSE -> NO, FAILED(hr) otherwise
STDAPI IsSameFile(LPCTSTR pszFile1, LPCTSTR pszFile2);

HRESULT SetWallpaperHelper(LPCWSTR szPath);

// Image options
#define IMAGEOPTION_CANROTATE    0x00000001
#define IMAGEOPTION_CANWALLPAPER 0x00000002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\shutil.cpp ===
#include "precomp.h"
#include "shutil.h"


HRESULT SHStringFromCLSIDA( LPSTR szCLSID, DWORD cSize, REFCLSID rCLSID )
{
    if ( cSize < 39 )
    {
        return E_INVALIDARG;
    }
    
    WCHAR szWCLSID[40];

    HRESULT hr = StringFromGUID2( rCLSID, szWCLSID, 40 );
    if ( FAILED( hr ))
    {
        return hr;
    }
    
    WideCharToMultiByte( CP_ACP, 0, szWCLSID, -1, szCLSID, cSize, 0, 0);
    return hr;
}

HRESULT GetFileInfoByHandle(LPCTSTR pszFile, BY_HANDLE_FILE_INFORMATION *pInfo)
{
    HRESULT hr;
    HANDLE hFile = CreateFile(pszFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        if (GetFileInformationByHandle(hFile, pInfo))
        {
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        CloseHandle(hFile);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    return hr;
}

// S_OK -> YES, S_FALSE -> NO, FAILED(hr) otherwise

STDAPI IsSameFile(LPCTSTR pszFile1, LPCTSTR pszFile2)
{
    HRESULT hr;
    // use CRT str cmp semantics as localized strcmp should not be used for the file system
    if (0 == StrCmpIC(pszFile1, pszFile2))
    {
        hr = S_OK;  // test the names
    }
    else
    {
        // very clever here... we can test for alias names that map to the same
        // file. for example the short name vs long name of the same file
        // the UNC name vs drive letter version of the name
        BY_HANDLE_FILE_INFORMATION hfi1;
        hr = GetFileInfoByHandle(pszFile1, &hfi1);
        if (SUCCEEDED(hr))
        {
            BY_HANDLE_FILE_INFORMATION hfi2;
            hr = GetFileInfoByHandle(pszFile2, &hfi2);
            if (SUCCEEDED(hr))
            {
                if (hfi1.dwVolumeSerialNumber == hfi2.dwVolumeSerialNumber && 
                    hfi1.nFileIndexHigh == hfi2.nFileIndexHigh && 
                    hfi1.nFileIndexLow == hfi2.nFileIndexLow)
                {
                    hr = S_OK;  // same!
                }
                else
                {
                    hr = S_FALSE;   // different
                }
            }
        }
    }
    return hr;
}

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);    // speed up PathMatchSpec calls
        
    // look at the list of decoders to see if this format is there
    for (UINT i = 0; i < cDecoders; i++)
    {
        if (PathMatchSpec(pszExt, pici[i].FilenameExtension))
            return i;
    }
    return (UINT)-1;    // not found!
}


HRESULT GetUIObjectFromPath(LPCTSTR pszFile, REFIID riid, void **ppv)
{
    *ppv = NULL;
    LPITEMIDLIST pidl;
    HRESULT hr = SHILCreateFromPath(pszFile, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        hr = SHGetUIObjectFromFullPIDL(pidl, NULL, riid, ppv);
        ILFree(pidl);
    }
    return hr;
}

BOOL FmtSupportsMultiPage(IShellImageData *pData, GUID *pguidFmt)
{
    BOOL bRet = FALSE;

    EncoderParameters *pencParams;
    if (SUCCEEDED(pData->GetEncoderParams(pguidFmt, &pencParams)))
    {
        for (UINT i=0;!bRet && i<pencParams->Count;i++)
        {
            if (EncoderSaveFlag == pencParams->Parameter[i].Guid)
            {
                if (EncoderValueMultiFrame == *((ULONG*)pencParams->Parameter[i].Value))
                {
                    bRet = TRUE;
                }
            }
        }
        CoTaskMemFree(pencParams);
    }
    return bRet;
}

HRESULT SetWallpaperHelper(LPCWSTR pszPath)
{
    IActiveDesktop* pad;
    HRESULT hr = CoCreateInstance(CLSID_ActiveDesktop, NULL, CLSCTX_INPROC, IID_PPV_ARG(IActiveDesktop, &pad));
    if (SUCCEEDED(hr))
    {
        IShellImageDataFactory* pidf;
        hr = CoCreateInstance(CLSID_ShellImageDataFactory, NULL, CLSCTX_INPROC, IID_PPV_ARG(IShellImageDataFactory, &pidf));
        if (SUCCEEDED(hr))
        {
            IShellImageData* pid;
            hr = pidf->CreateImageFromFile(pszPath, &pid);
            if (SUCCEEDED(hr))
            {
                hr = pid->Decode(SHIMGDEC_DEFAULT, 0,0);
                if (SUCCEEDED(hr))
                {
                    // we are basing this on a best fit to the primary screen
                    ULONG cxScreen = GetSystemMetrics(SM_CXSCREEN);
                    ULONG cyScreen = GetSystemMetrics(SM_CYSCREEN);

                    SIZE szImg;
                    pid->GetSize(&szImg);

                    hr = pad->SetWallpaper(pszPath, 0);
                    if (SUCCEEDED(hr))
                    {
                        WALLPAPEROPT wpo;
                        wpo.dwSize = sizeof(wpo);
                        wpo.dwStyle = WPSTYLE_CENTER;

                        // if the image is small on either axis then tile
                        if (((ULONG)szImg.cx*2 < cxScreen) || ((ULONG)szImg.cy*2 < cyScreen))
                        {
                            wpo.dwStyle = WPSTYLE_TILE;
                        }
                        // if the image is larger than the screen then stretch
                        else if ((ULONG)szImg.cx > cxScreen && (ULONG)szImg.cy > cyScreen)
                        {
                            wpo.dwStyle = WPSTYLE_STRETCH;
                        }
                        else
                        {
                            // If the aspect ratio matches the screen then stretch.
                            // I'm checking is the aspect ratios are *close* to matching.
                            // Here's the logic behind this:
                            //
                            // a / b == c / d
                            // a * d == c * b
                            // (a * d) / (c * b) == 1
                            // 0.75 <= (a * d) / (c * b) < 1.25     <-- our *close* factor
                            // 3 <= 4 * (a * d) / (c * b) < 5
                            //
                            // We do an integer division which will floor the result meaning
                            // that if the result is 3 or 4 we are inside the rang we want.

                            DWORD dwRes = (4 * (ULONG)szImg.cx * cyScreen) / (cxScreen * (ULONG)szImg.cy);
                            if (dwRes == 4 || dwRes == 3)
                                wpo.dwStyle = WPSTYLE_STRETCH;
                        }
                
                        hr = pad->SetWallpaperOptions(&wpo, 0);
                        if (SUCCEEDED(hr))
                        {
                            hr = pad->ApplyChanges(AD_APPLY_ALL | AD_APPLY_DYNAMICREFRESH);
                        }
                    }
                }
                pid->Release();
            }
            pidf->Release();
        }
        pad->Release();
    }
    
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\seltrack.h ===
#ifndef _SELTRACK_H_
#define _SELTRACK_H_

// This file defines the class used to handle the selection rectangle
// complete with resize handles

BOOL InitSelectionTracking();
void CleanupSelectionTracking();

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker - simple rectangular tracking rectangle w/resize handles

class CSelectionTracker
{
public:
// Constructor / Destructor
	CSelectionTracker();
	virtual ~CSelectionTracker();

	BOOL Init(); // You must call Init after construction

// Style Flags
	enum StyleFlags
	{
		solidLine = 1, dottedLine = 2, hatchedBorder = 4,
		resizeInside = 8, resizeOutside = 16, hatchInside = 32,
		lineSelection = 64
	};

// Hit-Test codes
	enum TrackerHit
	{
		hitNothing = -1,
		hitTopLeft = 0, hitTopRight = 1, hitBottomRight = 2, hitBottomLeft = 3,
		hitTop = 4, hitRight = 5, hitBottom = 6, hitLeft = 7, hitMiddle = 8
	};

// Attributes
	UINT m_uStyle;      // current state
	CRect m_rect;        // current position (always in pixels)
	CSize m_sizeMin;    // minimum X and Y size during track operation
	int m_nHandleSize;  // size of resize handles (default from WIN.INI)

// Operations
	void Draw(HDC hdc) const;
	void GetTrueRect(LPRECT lpTrueRect) const;
	BOOL SetCursor(HWND hwnd,  LPARAM lParam) const;
	BOOL Track(HWND hwnd, CPoint point, BOOL bAllowInvert = FALSE,
		HWND hwndClipTo = NULL);
	BOOL TrackRubberBand(HWND hwnd, CPoint point, BOOL bAllowInvert = TRUE);
	int HitTest(CPoint point) const;
	int NormalizeHit(int nHandle) const;

private:

	BOOL _bAllowInvert;    // flag passed to Track or TrackRubberBand
	CRect _rectLast;
	CSize _sizeLast;
	CSize _sizeMin;
	BOOL _bErase;          // TRUE if _DrawTrackerRect is called for erasing
	BOOL _bFinalErase;     // TRUE if _DragTrackerRect called for final erase

	// implementation helpers
	void _DrawTrackerRect(LPCRECT lpRect, HWND hwndClipTo, HDC hdc, HWND hwnd);
	void _AdjustRect(int nHandle, LPRECT lpRect);
	void _OnChangedRect(const CRect& rectOld);
	UINT _GetHandleMask() const;
	int _HitTestHandles(CPoint point) const;
	void _GetHandleRect(int nHandle, CRect* pHandleRect) const;
	void _GetModifyPointers(int nHandle, int** ppx, int** ppy, int* px, int*py);
	int _GetHandleSize(LPCRECT lpRect = NULL) const;
	BOOL _TrackHandle(int nHandle, HWND hwnd, CPoint point, HWND hwndClipTo);
	void _DrawDragRect(HDC hdc, LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\sources.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

TARGETNAME=shimgvw
TARGETPATH=obj
TARGETTYPE=DYNLINK

#VERIFY_LC = 1
LC_PATH   = $(PROJECT_ROOT)\lcinf

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h

DLLENTRY=DllMain
DLLDEF=..\shimgvw.def

SELFREGNAME= $(O)\shimgvw_selfreg.inf
MISCFILES= $(MISCFILES) $(O)\shimgvw_selfreg.inf

NTTARGETFILE0   = $(SELFREGNAME)

EXPECTED_WINVER=4.0
NOT_LEAN_AND_MEAN=1
USE_MSVCRT=0

USE_STATIC_ATL=1

MSC_WARNING_LEVEL=/WX /W3

GDIPLUS_LIB_PATH=$(SDK_LIB_PATH)

C_DEFINES =$(C_DEFINES) -DDCR_USE_NEW_105760 -DDCR_USE_NEW_127084 -DDCR_USE_NEW_135429 -DDCR_USE_NEW_140782 -DDCR_USE_NEW_140855 -DDCR_USE_NEW_140857 -DDCR_USE_NEW_140861 -DDCR_USE_NEW_145135 -DDCR_USE_NEW_145138 -DDCR_USE_NEW_145139 -DDCR_USE_NEW_145804 -DDCR_USE_NEW_146933 -DDCR_USE_NEW_152154

INCLUDES = \
    ..; \
    $(SDK_INC_PATH)\atl21; \
    $(CCSHELL_DIR)\inc; \
    $(CCSHELL_DIR)\lib\$(O); \
    $(CCSHELL_DIR)\shell32; \
    $(SDK_INC_PATH)\gdiplus; \
    $(PRINTSCAN_INC_PATH);\
    $(QFE_INC_PATH);\
    $(O)

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)

SOURCES= \
    ..\Atl.cpp         \
    ..\autoplay.cpp    \
    ..\docfile.cpp     \
    ..\Events.cpp      \
    ..\extmsg.mc       \
    ..\gdithumb.cpp    \
    ..\html.cpp        \
    ..\htmlgen.cpp     \
    ..\imgdata.cpp     \
    ..\photoverb.cpp   \
    ..\PrevCtrl.cpp    \
    ..\PrevWnd.cpp     \
    ..\recompress.cpp  \
    ..\shimgvw.cpp     \
    ..\shimgvw.rc      \
    ..\shutil.cpp      \
    ..\tasks.cpp       \
    ..\thumbutil.cpp   \
    ..\ZoomWnd.cpp     \
    ..\SelTrack.cpp    \
    ..\imgprop.cpp

DELAYLOAD = urlmon.dll
DLOAD_ERROR_HANDLER = kernel32

# Dynamically loading comctl32 through shfusion. Need to ignore "locally defined symbol imported" error
LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217


TARGETLIBS= \
    $(SDK_LIB_PATH)\kernel32.lib        \
    $(SDK_LIB_PATH)\user32.lib          \
    $(SDK_LIB_PATH)\gdi32.lib           \
    $(SDK_LIB_PATH)\winspool.lib        \
    $(SDK_LIB_PATH)\advapi32.lib        \
    $(SHELL_LIB_PATH)\shlwapip.lib      \
    $(SDK_LIB_PATH)\shell32.lib         \
    $(SDK_LIB_PATH)\htmlhelp.lib        \
    $(SDK_LIB_PATH)\ole32.lib           \
    $(SDK_LIB_PATH)\oleaut32.lib        \
    $(CCSHELL_DIR)\lib\$O\shguid.lib    \
    $(CCSHELL_DIR)\lib\$O\shguidp.lib   \
    $(CCSHELL_DIR)\lib\$O\ieguidp.lib   \
    $(SDK_LIB_PATH)\uuid.lib            \
    $(SHELL_LIB_PATH)\shfusion.lib      \
    $(SDK_LIB_PATH)\urlmon.lib          \
    $(SHELL_LIB_PATH)\shell32p.lib      \
    $(SHELL_LIB_PATH)\uxthemep.lib      \
    $(GDIPLUS_LIB_PATH)\gdiplus.lib     \
    $(CCSHELL_DIR)\lib\$O\stock4.lib    \
    $(PRINTSCAN_LIB_PATH)\annotlib.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\seltrack.cpp ===
#include "precomp.h"
#include "seltrack.h"

#ifndef _countof
#define _countof(array) (sizeof(array)/sizeof(array[0]))
#endif

#define CX_BORDER   1
#define CY_BORDER   1

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker global state

// various GDI objects we need to draw

class Statics
{
public:
    HCURSOR hCursors[10];
    HBRUSH hHatchBrush;
    HBRUSH hHalftoneBrush;
    HPEN hBlackDottedPen;
    int nHandleSize;
    int nRefCount;

    Statics()
    {
        hCursors[0] = 0;
        hCursors[1] = 0;
        hCursors[2] = 0;
        hCursors[3] = 0;
        hCursors[4] = 0;
        hCursors[5] = 0;
        hCursors[6] = 0;
        hCursors[7] = 0;
        hCursors[8] = 0;
        hCursors[9] = 0;
        hHatchBrush = 0;
        hHalftoneBrush = 0;
        hBlackDottedPen = 0;
        nHandleSize = 0;
        nRefCount=0;
    }

    ~Statics()
    {
        if (hHatchBrush != 0)
            ::DeleteObject(hHatchBrush);
        if (hHalftoneBrush != 0)
            ::DeleteObject(hHalftoneBrush);
        if (hBlackDottedPen != 0)
            ::DeleteObject(hBlackDottedPen);
    };
};

static Statics* s_pStatics = NULL;

// the struct below is used to determine the qualities of a particular handle
struct HANDLEINFO
{
    size_t nOffsetX;    // offset within RECT for X coordinate
    size_t nOffsetY;    // offset within RECT for Y coordinate
    int nCenterX;       // adjust X by Width()/2 * this number
    int nCenterY;       // adjust Y by Height()/2 * this number
    int nHandleX;       // adjust X by handle size * this number
    int nHandleY;       // adjust Y by handle size * this number
    int nInvertX;       // handle converts to this when X inverted
    int nInvertY;       // handle converts to this when Y inverted
};

// this array describes all 8 handles (clock-wise)
static const HANDLEINFO c_HandleInfo[] =
{
    // corner handles (top-left, top-right, bottom-right, bottom-left
    { offsetof(RECT, left), offsetof(RECT, top),        0, 0,  0,  0, 1, 3 },
    { offsetof(RECT, right), offsetof(RECT, top),       0, 0, -1,  0, 0, 2 },
    { offsetof(RECT, right), offsetof(RECT, bottom),    0, 0, -1, -1, 3, 1 },
    { offsetof(RECT, left), offsetof(RECT, bottom),     0, 0,  0, -1, 2, 0 },

    // side handles (top, right, bottom, left)
    { offsetof(RECT, left), offsetof(RECT, top),        1, 0,  0,  0, 4, 6 },
    { offsetof(RECT, right), offsetof(RECT, top),       0, 1, -1,  0, 7, 5 },
    { offsetof(RECT, left), offsetof(RECT, bottom),     1, 0,  0, -1, 6, 4 },
    { offsetof(RECT, left), offsetof(RECT, top),        0, 1,  0,  0, 5, 7 }
};

// the struct below gives us information on the layout of a RECT struct and
//  the relationship between its members
struct RECTINFO
{
    size_t nOffsetAcross;   // offset of opposite point (ie. left->right)
    int nSignAcross;        // sign relative to that point (ie. add/subtract)
};

// this array is indexed by the offset of the RECT member / sizeof(int)
static const RECTINFO c_RectInfo[] =
{
    { offsetof(RECT, right), +1 },
    { offsetof(RECT, bottom), +1 },
    { offsetof(RECT, left), -1 },
    { offsetof(RECT, top), -1 },
};

/////////////////////////////////////////////////////////////////////////////
// SelectionTracking intitialization / cleanup

BOOL InitSelectionTracking()
{
    // Only call this once.
    // Synchronization is the responsibility of the caller.
    if (s_pStatics != NULL)
    {
        s_pStatics->nRefCount++;
        return true;
    }

    s_pStatics = new Statics;

    // sanity checks for assumptions we make in the code
    ASSERT(sizeof(((RECT*)NULL)->left) == sizeof(int));
    ASSERT(offsetof(RECT, top) > offsetof(RECT, left));
    ASSERT(offsetof(RECT, right) > offsetof(RECT, top));
    ASSERT(offsetof(RECT, bottom) > offsetof(RECT, right));

    // create the hatch pattern + bitmap
    WORD hatchPattern[8];
    WORD wPattern = 0x1111;
    for (int i = 0; i < 4; i++)
    {
        hatchPattern[i] = wPattern;
        hatchPattern[i+4] = wPattern;
        wPattern <<= 1;
    }

    HBITMAP hatchBitmap = ::CreateBitmap(8, 8, 1, 1, &hatchPattern);
    if (hatchBitmap == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // create black hatched brush
    s_pStatics->hHatchBrush = ::CreatePatternBrush(hatchBitmap);
    DeleteObject(hatchBitmap);

    if (s_pStatics->hHatchBrush == NULL)
    {
        delete s_pStatics;
        return false;
    }

    WORD grayPattern[8];
    for (int i = 0; i < 8; i++)
        grayPattern[i] = (WORD)(0x5555 << (i & 1));

    HBITMAP grayBitmap = ::CreateBitmap(8, 8, 1, 1, &grayPattern);
    if (grayBitmap == NULL)
    {
        delete s_pStatics;
        return false;
    }

    s_pStatics->hHalftoneBrush = ::CreatePatternBrush(grayBitmap);
    DeleteObject(grayBitmap);
    if (s_pStatics->hHalftoneBrush == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // create black dotted pen
    s_pStatics->hBlackDottedPen = ::CreatePen(PS_DOT, 0, RGB(0, 0, 0));
    if (s_pStatics->hBlackDottedPen == NULL)
    {
        delete s_pStatics;
        return false;
    }

    // initialize the cursor array
    s_pStatics->hCursors[0] = ::LoadCursor(NULL, IDC_SIZENWSE);
    s_pStatics->hCursors[1] = ::LoadCursor(NULL, IDC_SIZENESW);
    s_pStatics->hCursors[2] = s_pStatics->hCursors[0];
    s_pStatics->hCursors[3] = s_pStatics->hCursors[1];
    s_pStatics->hCursors[4] = ::LoadCursor(NULL, IDC_SIZENS);
    s_pStatics->hCursors[5] = ::LoadCursor(NULL, IDC_SIZEWE);
    s_pStatics->hCursors[6] = s_pStatics->hCursors[4];
    s_pStatics->hCursors[7] = s_pStatics->hCursors[5];
    s_pStatics->hCursors[8] = ::LoadCursor(NULL, IDC_SIZEALL);
    s_pStatics->hCursors[9] = s_pStatics->hCursors[8];

    s_pStatics->nHandleSize = 6;

    s_pStatics->nRefCount = 1;
    return true;
}

void CleanupSelectionTracking()
{
    // Only call this once.
    // Synchronization is the responsibility of the caller.
    if (s_pStatics != NULL)
    {
        s_pStatics->nRefCount--;
        if (s_pStatics->nRefCount == 0)
        {
            delete s_pStatics;
            s_pStatics = NULL;
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker intitialization

CSelectionTracker::CSelectionTracker()
{
    ASSERT(s_pStatics != NULL);

    m_uStyle = 0;
    m_nHandleSize = s_pStatics->nHandleSize;
    m_sizeMin.cy = m_sizeMin.cx = m_nHandleSize*2;

    m_rect.SetRectEmpty();

    _rectLast.SetRectEmpty();
    _sizeLast.cx = _sizeLast.cy = 0;
    _bErase = false;
    _bFinalErase =  false;
    _bAllowInvert = true;
}


CSelectionTracker::~CSelectionTracker()
{
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker operations

void CSelectionTracker::Draw(HDC hdc) const
{
    ASSERT(s_pStatics != NULL);

    // set initial DC state
    if (::SaveDC(hdc) == 0)
    {
        ASSERT(false);
    }

    ::SetMapMode(hdc, MM_TEXT);
    ::SetViewportOrgEx(hdc, 0, 0, NULL);
    ::SetWindowOrgEx(hdc, 0, 0, NULL);

    // get normalized rectangle
    CRect rect = m_rect;
    rect.NormalizeRect();

    HPEN hOldPen = NULL;
    HBRUSH hOldBrush = NULL;
    HGDIOBJ hTemp;
    int nOldROP;

    // draw lines
    if ((m_uStyle & (dottedLine|solidLine)) != 0)
    {
        if (m_uStyle & dottedLine)
        {
            hOldPen = (HPEN)::SelectObject(hdc, s_pStatics->hBlackDottedPen);
        }
        else
        {
            hOldPen = (HPEN)::SelectObject(hdc, GetStockObject(BLACK_PEN));
        }

        hOldBrush = (HBRUSH)::SelectObject(hdc, GetStockObject(NULL_BRUSH));

        nOldROP = ::SetROP2(hdc, R2_COPYPEN);
        rect.InflateRect(+1, +1); // borders are one pixel outside

        ::Rectangle(hdc, rect.left, rect.top, rect.right, rect.bottom);
        ::SetROP2(hdc, nOldROP);
    }

    // if hatchBrush is going to be used, need to unrealize it
    if ((m_uStyle & (hatchInside|hatchedBorder)) != 0)
        ::UnrealizeObject(s_pStatics->hHatchBrush);

    // hatch inside
    if ((m_uStyle & hatchInside) != 0)
    {
        hTemp = ::SelectObject(hdc, GetStockObject(NULL_PEN));
        if (hOldPen == NULL)
            hOldPen = (HPEN)hTemp;
        hTemp = ::SelectObject(hdc, s_pStatics->hHatchBrush);
        if (hOldBrush == NULL)
            hOldBrush = (HBRUSH)hTemp;

        ::SetBkMode(hdc, TRANSPARENT);
        nOldROP = ::SetROP2(hdc, R2_MASKNOTPEN);

        ::Rectangle(hdc, rect.left+1, rect.top+1, rect.right, rect.bottom);
        ::SetROP2(hdc, nOldROP);
    }

    // draw hatched border
    if ((m_uStyle & hatchedBorder) != 0)
    {
        hTemp = ::SelectObject(hdc, s_pStatics->hHatchBrush);
        if (hOldBrush == NULL)
            hOldBrush = (HBRUSH)hTemp;
        ::SetBkMode(hdc, OPAQUE);
        CRect rectTrue;
        GetTrueRect(&rectTrue);

        ::PatBlt(hdc, rectTrue.left, rectTrue.top, rectTrue.Width(), rect.top-rectTrue.top, 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rectTrue.left, rect.bottom, rectTrue.Width(), rectTrue.bottom-rect.bottom, 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rectTrue.left, rect.top, rect.left-rectTrue.left, rect.Height(), 0x000F0001 /* Pn */);
        ::PatBlt(hdc, rect.right, rect.top, rectTrue.right-rect.right, rect.Height(), 0x000F0001 /* Pn */);
    }

    // draw resize handles
    if ((m_uStyle & (resizeInside|resizeOutside)) != 0)
    {
        UINT mask = _GetHandleMask();
        for (int i = 0; i < 8; ++i)
        {
            if (mask & (1<<i))
            {
                _GetHandleRect((TrackerHit)i, &rect);
                ::SetBkColor(hdc, RGB(0, 0, 0));
                ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
            }
        }
    }

    // cleanup pDC state
    if (hOldPen != NULL)
        ::SelectObject(hdc, hOldPen);
    if (hOldBrush != NULL)
        ::SelectObject(hdc, hOldBrush);

    if (::RestoreDC(hdc, -1) == 0)
    {
        ASSERT(false);
    }
}

BOOL CSelectionTracker::SetCursor(HWND hwnd, LPARAM lParam) const
{
    ASSERT(s_pStatics != NULL);

    UINT uHitTest = (short)LOWORD(lParam);

    // trackers should only be in client area
    if (uHitTest != HTCLIENT)
        return FALSE;

    // convert cursor position to client co-ordinates
    CPoint point;
    ::GetCursorPos(&point);
    ::ScreenToClient(hwnd, &point);

    // do hittest and normalize hit
    int nHandle = _HitTestHandles(point);
    if (nHandle < 0)
        return FALSE;

    // need to normalize the hittest such that we get proper cursors
    nHandle = NormalizeHit(nHandle);

    // handle special case of hitting area between handles
    //  (logically the same -- handled as a move -- but different cursor)
    if (nHandle == hitMiddle && !m_rect.PtInRect(point))
    {
        // only for trackers with hatchedBorder (ie. in-place resizing)
        if (m_uStyle & hatchedBorder)
            nHandle = (TrackerHit)9;
    }

    ASSERT(nHandle < _countof(s_pStatics->hCursors));
    ::SetCursor(s_pStatics->hCursors[nHandle]);
    return TRUE;
}

int CSelectionTracker::HitTest(CPoint point) const
{
    ASSERT(s_pStatics != NULL);

    TrackerHit hitResult = hitNothing;

    CRect rectTrue;
    GetTrueRect(&rectTrue);
    ASSERT(rectTrue.left <= rectTrue.right);
    ASSERT(rectTrue.top <= rectTrue.bottom);
    if (rectTrue.PtInRect(point))
    {
        if ((m_uStyle & (resizeInside|resizeOutside)) != 0)
            hitResult = (TrackerHit)_HitTestHandles(point);
        else
            hitResult = hitMiddle;
    }
    return hitResult;
}

int CSelectionTracker::NormalizeHit(int nHandle) const
{
    ASSERT(s_pStatics != NULL);

    ASSERT(nHandle <= 8 && nHandle >= -1);
    if (nHandle == hitMiddle || nHandle == hitNothing)
        return nHandle;
    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    if (m_rect.Width() < 0)
    {
        nHandle = (TrackerHit)pHandleInfo->nInvertX;
        pHandleInfo = &c_HandleInfo[nHandle];
    }
    if (m_rect.Height() < 0)
        nHandle = (TrackerHit)pHandleInfo->nInvertY;
    return nHandle;
}

BOOL CSelectionTracker::Track(HWND hwnd, CPoint point, BOOL bAllowInvert, HWND hwndClipTo)
{
    ASSERT(s_pStatics != NULL);

    // perform hit testing on the handles
    int nHandle = _HitTestHandles(point);
    if (nHandle < 0)
    {
        // didn't hit a handle, so just return FALSE
        return FALSE;
    }

    if (m_uStyle & lineSelection)
    {
        bAllowInvert = true;
        _sizeMin = CSize(0, 0);
    }
    else
    {
        _sizeMin = m_sizeMin;
    }

    // otherwise, call helper function to do the tracking
    _bAllowInvert = bAllowInvert;
    return _TrackHandle(nHandle, hwnd, point, hwndClipTo);
}

BOOL CSelectionTracker::TrackRubberBand(HWND hwnd, CPoint point, BOOL bAllowInvert)
{
    ASSERT(s_pStatics != NULL);

    // simply call helper function to track from bottom right handle

    if (m_uStyle & lineSelection)
    {
        bAllowInvert = true;
        _sizeMin = CSize(0, 0);
    }
    else
    {
        _sizeMin = m_sizeMin;
    }
    _bAllowInvert = bAllowInvert;
    m_rect.SetRect(point.x, point.y, point.x, point.y);
    return _TrackHandle(hitBottomRight, hwnd, point, NULL);
}

void CSelectionTracker::_DrawTrackerRect(LPCRECT lpRect, HWND hwndClipTo, HDC hdc, HWND hwnd)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(lpRect != NULL);

    // first, normalize the rectangle for drawing
    CRect rect(0,0,0,0);
    if (lpRect)
        rect = *lpRect;

    if (!(m_uStyle & lineSelection))
    {
        rect.NormalizeRect();
    }

    // convert to client coordinates
    if (hwndClipTo != NULL)
    {
        ::ClientToScreen(hwnd, (LPPOINT)(LPRECT)&rect);
        ::ClientToScreen(hwnd, ((LPPOINT)(LPRECT)&rect)+1);
        if (IS_WINDOW_RTL_MIRRORED(hwnd))
        {
            LONG temp = rect.left;
            rect.left = rect.right;
            rect.right = temp;
        }

        ::ScreenToClient(hwndClipTo, (LPPOINT)(LPRECT)&rect);
        ::ScreenToClient(hwndClipTo, ((LPPOINT)(LPRECT)&rect)+1);
        if (IS_WINDOW_RTL_MIRRORED(hwndClipTo))
        {
            LONG temp = rect.left;
            rect.left = rect.right;
            rect.right = temp;
        }
    }

    CSize size(0, 0);
    if (!_bFinalErase)
    {
        // otherwise, size depends on the style
        if (m_uStyle & hatchedBorder)
        {
            size.cx = size.cy = max(1, _GetHandleSize(rect)-1);
            rect.InflateRect(size);
        }
        else
        {
            size.cx = CX_BORDER;
            size.cy = CY_BORDER;
        }
    }

    // and draw it
    if ((_bFinalErase || !_bErase) && hdc)
        _DrawDragRect(hdc, rect, size, _rectLast, _sizeLast);

    // remember last rectangles
    _rectLast = rect;
    _sizeLast = size;
}

void CSelectionTracker::_AdjustRect(int nHandle, LPRECT)
{
    ASSERT(s_pStatics != NULL);

    if (nHandle == hitMiddle)
        return;

    // convert the handle into locations within m_rect
    int *px, *py;
    _GetModifyPointers(nHandle, &px, &py, NULL, NULL);

    // enforce minimum width
    int nNewWidth = m_rect.Width();
    int nAbsWidth = _bAllowInvert ? abs(nNewWidth) : nNewWidth;
    if (px != NULL && nAbsWidth < _sizeMin.cx)
    {
        nNewWidth = nAbsWidth != 0 ? nNewWidth / nAbsWidth : 1;
        ASSERT((int*)px - (int*)&m_rect < _countof(c_RectInfo));
        const RECTINFO* pRectInfo = &c_RectInfo[(int*)px - (int*)&m_rect];
        *px = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
            nNewWidth * _sizeMin.cx * -pRectInfo->nSignAcross;
    }

    // enforce minimum height
    int nNewHeight = m_rect.Height();
    int nAbsHeight = _bAllowInvert ? abs(nNewHeight) : nNewHeight;
    if (py != NULL && nAbsHeight < _sizeMin.cy)
    {
        nNewHeight = nAbsHeight != 0 ? nNewHeight / nAbsHeight : 1;
        ASSERT((int*)py - (int*)&m_rect < _countof(c_RectInfo));
        const RECTINFO* pRectInfo = &c_RectInfo[(int*)py - (int*)&m_rect];
        *py = *(int*)((BYTE*)&m_rect + pRectInfo->nOffsetAcross) +
            nNewHeight * _sizeMin.cy * -pRectInfo->nSignAcross;
    }
}

void CSelectionTracker::GetTrueRect(LPRECT lpTrueRect) const
{
    ASSERT(s_pStatics != NULL);

    CRect rect = m_rect;
    rect.NormalizeRect();
    int nInflateBy = 0;
    if ((m_uStyle & (resizeOutside|hatchedBorder)) != 0)
        nInflateBy += _GetHandleSize() - 1;
    if ((m_uStyle & (solidLine|dottedLine)) != 0)
        ++nInflateBy;
    rect.InflateRect(nInflateBy, nInflateBy);
    *lpTrueRect = rect;
}

/////////////////////////////////////////////////////////////////////////////
// CSelectionTracker implementation helpers

void CSelectionTracker::_GetHandleRect(int nHandle, CRect* pHandleRect) const
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle < 8);

    // get normalized rectangle of the tracker
    CRect rectT = m_rect;
    rectT.NormalizeRect();
    if ((m_uStyle & (solidLine|dottedLine)) != 0)
        rectT.InflateRect(+1, +1);

    // since the rectangle itself was normalized, we also have to invert the
    //  resize handles.
    nHandle = NormalizeHit(nHandle);

    // handle case of resize handles outside the tracker
    int size = _GetHandleSize();
    if (m_uStyle & resizeOutside)
        rectT.InflateRect(size-1, size-1);

    // calculate position of the resize handle
    int nWidth = rectT.Width();
    int nHeight = rectT.Height();
    CRect rect;
    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    rect.left = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetX);
    rect.top = *(int*)((BYTE*)&rectT + pHandleInfo->nOffsetY);
    rect.left += size * pHandleInfo->nHandleX;
    rect.top += size * pHandleInfo->nHandleY;
    rect.left += pHandleInfo->nCenterX * (nWidth - size) / 2;
    rect.top += pHandleInfo->nCenterY * (nHeight - size) / 2;
    rect.right = rect.left + size;
    rect.bottom = rect.top + size;

    *pHandleRect = rect;
}

int CSelectionTracker::_GetHandleSize(LPCRECT lpRect) const
{
    ASSERT(s_pStatics != NULL);

    if (lpRect == NULL)
        lpRect = &m_rect;

    int size = m_nHandleSize;
    if (!(m_uStyle & resizeOutside))
    {
        // make sure size is small enough for the size of the rect
        int sizeMax = min(abs(lpRect->right - lpRect->left),
            abs(lpRect->bottom - lpRect->top));
        if (size * 2 > sizeMax)
            size = sizeMax / 2;
    }
    return size;
}

int CSelectionTracker::_HitTestHandles(CPoint point) const
{
    ASSERT(s_pStatics != NULL);

    CRect rect;
    UINT mask = _GetHandleMask();

    // see if hit anywhere inside the tracker
    GetTrueRect(&rect);
    if (!rect.PtInRect(point))
        return hitNothing;  // totally missed

    // see if we hit a handle
    for (int i = 0; i < 8; ++i)
    {
        if (mask & (1<<i))
        {
            _GetHandleRect((TrackerHit)i, &rect);
            if (rect.PtInRect(point))
                return (TrackerHit)i;
        }
    }

    // last of all, check for non-hit outside of object, between resize handles
    if ((m_uStyle & hatchedBorder) == 0)
    {
        CRect rect = m_rect;
        rect.NormalizeRect();
        if ((m_uStyle & dottedLine|solidLine) != 0)
            rect.InflateRect(+1, +1);
        if (!rect.PtInRect(point))
            return hitNothing;  // must have been between resize handles
    }
    return hitMiddle;   // no handle hit, but hit object (or object border)
}

BOOL CSelectionTracker::_TrackHandle(int nHandle, HWND hwnd, CPoint point, HWND hwndClipTo)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle >= 0 && nHandle <= 8);   // handle 8 is inside the rect

    // don't handle if capture already set
    if (::GetCapture() != NULL)
        return FALSE;

    ASSERT(!_bFinalErase);

    // save original width & height in pixels
    int nWidth = m_rect.Width();
    int nHeight = m_rect.Height();

    // set capture to the window which received this message
    ::SetCapture(hwnd);
    ASSERT(hwnd == ::GetCapture());

    UpdateWindow(hwnd);

    if (hwndClipTo != NULL)
        UpdateWindow(hwndClipTo);

    CRect rectSave = m_rect;

    // find out what x/y coords we are supposed to modify
    int *px, *py;
    int xDiff, yDiff;
    _GetModifyPointers(nHandle, &px, &py, &xDiff, &yDiff);
    xDiff = point.x - xDiff;
    yDiff = point.y - yDiff;

    // get DC for drawing
    HDC hdcDraw;
    if (hwndClipTo != NULL)
    {
        // clip to arbitrary window by using adjusted Window DC
        hdcDraw = ::GetDCEx(hwndClipTo, NULL, DCX_CACHE);
    }
    else
    {
        // otherwise, just use normal DC
        hdcDraw = ::GetDC(hwnd);
    }
    ASSERT(hdcDraw != NULL);

    CRect rectOld;
    BOOL bMoved = FALSE;

    // get messages until capture lost or cancelled/accepted
    for (;;)
    {
        MSG msg;
        if (!::GetMessage(&msg, NULL, 0, 0))
        {
            ASSERT(false);
        }

        if (hwnd != ::GetCapture())
            break;

        switch (msg.message)
        {
        // handle movement/accept messages
        case WM_LBUTTONUP:
        case WM_MOUSEMOVE:
            rectOld = m_rect;
            // handle resize cases (and part of move)
            if (px != NULL)
                *px = (int)(short)LOWORD(msg.lParam) - xDiff;
            if (py != NULL)
                *py = (int)(short)HIWORD(msg.lParam) - yDiff;

            // handle move case
            if (nHandle == hitMiddle)
            {
                m_rect.right = m_rect.left + nWidth;
                m_rect.bottom = m_rect.top + nHeight;
            }
            // allow caller to adjust the rectangle if necessary
            _AdjustRect(nHandle, &m_rect);

            // only redraw and callback if the rect actually changed!
            _bFinalErase = (msg.message == WM_LBUTTONUP);
            if (!rectOld.EqualRect(&m_rect) || _bFinalErase)
            {
                if (bMoved)
                {
                    _bErase = TRUE;
                    _DrawTrackerRect(&rectOld, hwndClipTo, hdcDraw, hwnd);
                }
                if (msg.message != WM_LBUTTONUP)
                    bMoved = TRUE;
            }
            if (_bFinalErase)
                goto ExitLoop;

            if (!rectOld.EqualRect(&m_rect))
            {
                _bErase = FALSE;
                _DrawTrackerRect(&m_rect, hwndClipTo, hdcDraw, hwnd);
            }
            break;

        // handle cancel messages
        case WM_KEYDOWN:
            if (msg.wParam != VK_ESCAPE)
                break;
        case WM_RBUTTONDOWN:
            if (bMoved)
            {
                _bErase = _bFinalErase = TRUE;
                _DrawTrackerRect(&m_rect, hwndClipTo, hdcDraw, hwnd);
            }
            m_rect = rectSave;
            goto ExitLoop;

        // just dispatch rest of the messages
        default:
            ::DispatchMessage(&msg);
            break;
        }
    }

ExitLoop:
    if (hdcDraw != NULL)
    {
        if (hwndClipTo != NULL)
            ::ReleaseDC(hwndClipTo, hdcDraw);
        else
            ::ReleaseDC(hwnd, hdcDraw);
    }

    ::ReleaseCapture();

    // restore rect in case bMoved is still FALSE
    if (!bMoved)
        m_rect = rectSave;
    _bFinalErase = FALSE;
    _bErase = FALSE;

    // return TRUE only if rect has changed
    return !rectSave.EqualRect(&m_rect);
}

void CSelectionTracker::_GetModifyPointers(int nHandle, int** ppx, int** ppy, int* px, int* py)
{
    ASSERT(s_pStatics != NULL);
    ASSERT(nHandle >= 0 && nHandle <= 8);

    if (nHandle == hitMiddle)
        nHandle = hitTopLeft;   // same as hitting top-left

    *ppx = NULL;
    *ppy = NULL;

    // fill in the part of the rect that this handle modifies
    //  (Note: handles that map to themselves along a given axis when that
    //   axis is inverted don't modify the value on that axis)

    const HANDLEINFO* pHandleInfo = &c_HandleInfo[nHandle];
    if (pHandleInfo->nInvertX != nHandle)
    {
        *ppx = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetX);
        if (px != NULL)
            *px = **ppx;
    }
    else
    {
        // middle handle on X axis
        if (px != NULL)
            *px = m_rect.left + abs(m_rect.Width()) / 2;
    }
    if (pHandleInfo->nInvertY != nHandle)
    {
        *ppy = (int*)((BYTE*)&m_rect + pHandleInfo->nOffsetY);
        if (py != NULL)
            *py = **ppy;
    }
    else
    {
        // middle handle on Y axis
        if (py != NULL)
            *py = m_rect.top + abs(m_rect.Height()) / 2;
    }
}

UINT CSelectionTracker::_GetHandleMask() const
{
    ASSERT(s_pStatics != NULL);
    UINT mask;

    if (m_uStyle & lineSelection)
    {
        mask = 0x05;
    }
    else
    {
        mask = 0x0F;   // always have 4 corner handles

        int size = m_nHandleSize*3;
        if (abs(m_rect.Width()) - size > 4)
            mask |= 0x50;
        if (abs(m_rect.Height()) - size > 4)
            mask |= 0xA0;
    }
    return mask;
}

void CSelectionTracker::_DrawDragRect(HDC hdc, LPCRECT lpRect, SIZE size, LPCRECT lpRectLast, SIZE sizeLast)
{
    if (m_uStyle & lineSelection)
    {
        int nOldROP = ::SetROP2(hdc, R2_NOTXORPEN);
        HPEN hOldPen =(HPEN)::SelectObject(hdc, (HPEN)s_pStatics->hBlackDottedPen);

        if (lpRectLast != NULL)
        {
            CRect rectLast = *lpRectLast;

            ::MoveToEx(hdc, rectLast.left, rectLast.top, NULL);
            ::LineTo(hdc, rectLast.right, rectLast.bottom);
        }
        
        CRect rect = *lpRect;

        ::MoveToEx(hdc, rect.left, rect.top, NULL);
        ::LineTo(hdc, rect.right, rect.bottom);

        ::SelectObject(hdc, hOldPen);
        ::SetROP2(hdc, nOldROP);
    }
    else
    {
        // first, determine the update region and select it
        HRGN hrgnOutside = ::CreateRectRgnIndirect(lpRect);

        CRect rect = *lpRect;
        rect.InflateRect(-size.cx, -size.cy);
        rect.IntersectRect(rect, lpRect);

        HRGN hrgnInside = ::CreateRectRgnIndirect(&rect);
        HRGN hrgnNew = ::CreateRectRgn(0, 0, 0, 0);
        ::CombineRgn(hrgnNew, hrgnOutside, hrgnInside, RGN_XOR);

        HRGN hrgnLast = NULL;
        HRGN hrgnUpdate = NULL;

        if (lpRectLast != NULL)
        {
            // find difference between new region and old region
            hrgnLast = ::CreateRectRgn(0, 0, 0, 0);
            ::SetRectRgn(hrgnOutside, lpRectLast->left, lpRectLast->top, lpRectLast->right, lpRectLast->bottom);
            rect = *lpRectLast;
            rect.InflateRect(-sizeLast.cx, -sizeLast.cy);
            rect.IntersectRect(rect, lpRectLast);
            ::SetRectRgn(hrgnInside, rect.left, rect.top, rect.right, rect.bottom);
            ::CombineRgn(hrgnLast, hrgnOutside, hrgnInside, RGN_XOR);
            hrgnUpdate = ::CreateRectRgn(0, 0, 0, 0);
            ::CombineRgn(hrgnUpdate, hrgnLast, hrgnNew, RGN_XOR);
        }

        // draw into the update/new region
        if (hrgnUpdate != NULL)
            ::SelectClipRgn(hdc, hrgnUpdate);
        else
            ::SelectClipRgn(hdc, hrgnNew);

        ::GetClipBox(hdc, &rect);

        HBRUSH hBrushOld = (HBRUSH)::SelectObject(hdc, s_pStatics->hHalftoneBrush);
        ::PatBlt(hdc, rect.left, rect.top, rect.Width(), rect.Height(), PATINVERT);
        ::SelectObject(hdc, hBrushOld);

        ::SelectClipRgn(hdc, NULL);

        if (hrgnOutside != NULL)
            ::DeleteObject(hrgnOutside);
        if (hrgnInside != NULL)
            ::DeleteObject(hrgnInside);
        if (hrgnNew != NULL)
            ::DeleteObject(hrgnNew);
        if (hrgnLast != NULL)
            ::DeleteObject(hrgnLast);
        if (hrgnUpdate != NULL)
            ::DeleteObject(hrgnUpdate);
    }
}


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\shimgvw.cpp ===
// shimgvw.cpp : Implementation of DLL Exports.

#include "precomp.h"
#include "resource.h"
#include "cfdefs.h"
#include "advpub.h"

#include "initguid.h"
#include "shimgvw.h"
#include "guids.h"
#include "shutil.h"
#include <gdiplusImaging.h>

#define  DECLARE_DEBUG
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "Shell Image View"
#define  SZ_MODULE          "SHIMGVW"
#include <debug.h>

#define DECL_CRTFREE
#include <crtfree.h>

#include "prevCtrl.h"           // for CPreview

#define IIDSTR_IExtractImage        "{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}"
#define REGSTR_APPROVED             "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"

LPCSTR const c_rgszDocFileExts[] =
{
    ".doc",
    ".dot",
    ".xls",
    ".xlt",
    ".obd",
    ".obt",
    ".ppt",
    ".pot",
    ".mic",
    ".mix",
    ".fpx",
    ".mpp"
};

LPCSTR const c_rgszHtmlExts[] =
{
    ".html",
    ".htm",
    ".url",
    ".mhtml",
    ".mht",
    ".xml",
    ".nws",
    ".eml"
};

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_Preview, CPreview)
    OBJECT_ENTRY(CLSID_GdiThumbnailExtractor, CGdiPlusThumb)
    OBJECT_ENTRY(CLSID_DocfileThumbnailHandler, CDocFileThumb)
    OBJECT_ENTRY(CLSID_HtmlThumbnailExtractor, CHtmlThumb)
END_OBJECT_MAP()

CF_TABLE_BEGIN(g_ObjectInfo)
    CF_TABLE_ENTRY(&CLSID_ShellImageDataFactory, CImageDataFactory_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_PhotoVerbs, CPhotoVerbs_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_AutoplayForSlideShow, CAutoplayForSlideShow_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_ImagePropertyHandler, CImageData_CreateInstance, COCREATEONLY),
    CF_TABLE_ENTRY(&CLSID_ImageRecompress, CImgRecompress_CreateInstance, COCREATEONLY),
CF_TABLE_END(g_ObjectInfo)


/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModule(hInstance);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

//  some types can only wallpaper on win32
#ifdef _WIN64
#define IMAGEOPTION_CANWALLPAPER_WIN32  0
#else
#define IMAGEOPTION_CANWALLPAPER_WIN32  IMAGEOPTION_CANWALLPAPER
#endif

#define IMGOPT_ALL      (IMAGEOPTION_CANWALLPAPER | IMAGEOPTION_CANROTATE)
#define IMGOPT_ALLW32   (IMAGEOPTION_CANWALLPAPER_WIN32 | IMAGEOPTION_CANROTATE)
#define IMGOPT_NONE     0
/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

typedef struct { LPTSTR szExt; LPTSTR pszContentType; LPTSTR szProgId; LPTSTR szProgram; DWORD dwOpts;} FILETYPEINFO;
//  { ".EXT",       "progid",                   old program,            IMGOPT
FILETYPEINFO g_rgExtentions[] = {
    { TEXT(".bmp"), TEXT("image/bmp"),      TEXT("Paint.Picture"),      TEXT("mspaint.exe"),    IMGOPT_ALL,     },
    { TEXT(".dib"), TEXT("image/bmp"),      TEXT("Paint.Picture"),      TEXT("mspaint.exe"),    IMGOPT_ALL,     },
    { TEXT(".emf"), NULL,                   TEXT("emffile"),            TEXT(""),               IMGOPT_NONE,    },
    { TEXT(".gif"), TEXT("image/gif"),      TEXT("giffile"),            TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jfif"),TEXT("image/jpeg"),     TEXT("pjpegfile"),          TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpg"), TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpe"), TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".jpeg"),TEXT("image/jpeg"),     TEXT("jpegfile"),           TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".png"), TEXT("image/png"),      TEXT("pngfile"),            TEXT("iexplore.exe"),   IMGOPT_ALLW32   },
    { TEXT(".tif"), TEXT("image/tiff"),     TEXT("TIFImage.Document"),  TEXT("KodakPrv.exe"),   IMGOPT_NONE,    },
    { TEXT(".tiff"),TEXT("image/tiff"),     TEXT("TIFImage.Document"),  TEXT("KodakPrv.exe"),   IMGOPT_NONE,    },
    { TEXT(".wmf"), NULL,                   TEXT("wmffile"),            TEXT(""),               IMGOPT_NONE,    },
};

const TCHAR c_szBitmapIcon[] =  TEXT("shimgvw.dll,1");
const TCHAR c_szDefaultIcon[] = TEXT("shimgvw.dll,2");
const TCHAR c_szJPegIcon[] =    TEXT("shimgvw.dll,3");
const TCHAR c_szTifIcon[] =     TEXT("shimgvw.dll,4");

// we might have to create a missing Prog ID so we need to know its default info.
typedef struct { LPCTSTR szProgID; int iResId; LPCTSTR szIcon; BOOL fDone; } PROGIDINFO;
//  { "ProgID"                  "Description"   "DefaultIcon"       done?   }
PROGIDINFO g_rgProgIDs[] = {
    { TEXT("emffile"),          IDS_EMFIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("giffile"),          IDS_GIFIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("jpegfile"),         IDS_JPEGIMAGE,   c_szJPegIcon,      FALSE   },
    { TEXT("Paint.Picture"),    IDS_BITMAPIMAGE, c_szBitmapIcon,    FALSE   },
    { TEXT("pjpegfile"),        IDS_JPEGIMAGE,   c_szJPegIcon,      FALSE   },
    { TEXT("pngfile"),          IDS_PNGIMAGE,    c_szDefaultIcon,   FALSE   },
    { TEXT("TIFImage.Document"),IDS_TIFIMAGE,    c_szTifIcon,       FALSE   },
    { TEXT("wmffile"),          IDS_WMFIMAGE,    c_szDefaultIcon,   FALSE   },
};

BOOL _ShouldSlamVerb(HKEY hkProgid, BOOL fForce, PCWSTR pszKey, PCWSTR pszApp, PCWSTR pszModule)
{
    if (!fForce)
    {
        TCHAR szOld[MAX_PATH*2];
        DWORD cbOld = sizeof(szOld);
        if (ERROR_SUCCESS == SHGetValue(hkProgid, pszKey, NULL, NULL, szOld, &cbOld) && *szOld)
        {
            // if we know about this app, then blow it away
            if ((*pszApp && StrStrI(szOld, pszApp))
            || StrStrI(szOld, pszModule)
            || StrStrI(szOld, TEXT("wangimg.exe"))) // NT4 app
            {
                fForce = TRUE;
            }
        }
        else
        {
            fForce = TRUE;
        }
    }

    return fForce;
}

BOOL _ExtIsProgid(PCTSTR pszExt, PCTSTR pszProgid, DWORD dwOpts)
{
    //  default to take-over
    BOOL fRet = TRUE;
    TCHAR sz[MAX_PATH];
    //  make sure this is in the openwith list
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("%s\\OpenWithProgids"), pszExt);
    SHSetValue(HKEY_CLASSES_ROOT, sz, pszProgid, REG_NONE, NULL, NULL);
    // make sure the flags are set for our verbs to show up
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("SystemFileAssociations\\%s"), pszExt);
    SHSetValue(HKEY_CLASSES_ROOT, sz, TEXT("ImageOptionFlags"), REG_DWORD, &dwOpts, sizeof(dwOpts));

    SHSetValue(HKEY_CLASSES_ROOT, pszExt, TEXT("PerceivedType"), REG_SZ, TEXT("image"), sizeof(TEXT("image")));
    
    DWORD cb = sizeof(sz);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, sz, &cb))
    {
        //  empty or match is good
        fRet = (!*sz || 0 == StrCmpI(sz, pszProgid));
    }

    // always remove bogus Trident IExtractImage entries
    wnsprintf(sz, ARRAYSIZE(sz), TEXT("%s\\shellex\\{BB2E617C-0920-11d1-9A0B-00C04FC2D6C1}"), pszExt);
    SHDeleteKey(HKEY_CLASSES_ROOT, sz);
    PathRemoveFileSpec(sz);
    SHDeleteEmptyKey(HKEY_CLASSES_ROOT, sz);
    
    return fRet;
}

PROGIDINFO *_ShouldSetupProgid(FILETYPEINFO *pfti, BOOL fForce)
{
    PROGIDINFO *ppi = NULL;
    if (_ExtIsProgid(pfti->szExt, pfti->szProgId, pfti->dwOpts) || fForce)
    {
        //  take it over
        SHSetValue(HKEY_CLASSES_ROOT, pfti->szExt, NULL, REG_SZ, pfti->szProgId, CbFromCch(lstrlen(pfti->szProgId)+1));
        if (pfti->pszContentType)
        {
            SHSetValue(HKEY_CLASSES_ROOT, pfti->szExt, TEXT("Content Type"), REG_SZ, pfti->pszContentType, CbFromCch(lstrlen(pfti->pszContentType)+1));
        }
        
        // we now know that szProgID is the ProgID for this extention.
        // look up the index into the ProgID table to see if we did this one already.
        int iProgIdIndex;
        for (iProgIdIndex=0; iProgIdIndex<ARRAYSIZE(g_rgProgIDs); iProgIdIndex++)
        {
            if (0 == StrCmpI(g_rgProgIDs[iProgIdIndex].szProgID, pfti->szProgId))
            {
                if (!g_rgProgIDs[iProgIdIndex].fDone)
                    ppi = &g_rgProgIDs[iProgIdIndex];
                break;
            }
        }
    }
    return ppi;
}


void RegisterFileType(FILETYPEINFO *pfti, BOOL fForce)
{
    PROGIDINFO *ppi = _ShouldSetupProgid(pfti, fForce);
    if (ppi)
    {
        // this ProgID is in our table 
        HKEY hkeyProgId;
        LRESULT lres = RegCreateKeyEx(HKEY_CLASSES_ROOT,
                                pfti->szProgId,
                                0, NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_READ|KEY_WRITE, NULL,
                                &hkeyProgId, NULL);

        if (ERROR_SUCCESS == lres)
        {
            LPCTSTR pszIcon = ppi->szIcon;
            TCHAR szModPath[MAX_PATH];
            GetModuleFileName(_Module.GetModuleInstance(), szModPath, ARRAYSIZE(szModPath));
            PCWSTR pszModule = PathFindFileName(szModPath);
            TCHAR szCmd[MAX_PATH * 2];
            // should we slam the default value?
            //  to progid = "EXT file"
            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\open\\command", pfti->szProgram, pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\open"));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("rundll32.exe %s,ImageView_Fullscreen %%1"), szModPath);
                SHRegSetPath(hkeyProgId, TEXT("shell\\open\\command"), NULL, szCmd, 0);
                SHStringFromGUID(CLSID_PhotoVerbs, szCmd, ARRAYSIZE(szCmd));
                SHSetValue(hkeyProgId, TEXT("shell\\open\\DropTarget"), TEXT("Clsid"), REG_SZ, szCmd, CbFromCch(lstrlen(szCmd)+1));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("@%s,%d"), pszModule, -IDS_PREVIEW_CTX);
                SHSetValue(hkeyProgId, TEXT("shell\\open"), TEXT("MuiVerb"), REG_SZ, szCmd, CbFromCch(lstrlen(szCmd)+1));
                SHRegSetPath(hkeyProgId, TEXT("DefaultIcon"), NULL, pszIcon, 0);
            }

            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\printto\\command", TEXT("mspaint.exe"), pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\printto"));
                wnsprintf(szCmd, ARRAYSIZE(szCmd), TEXT("rundll32.exe %s,ImageView_PrintTo /pt \"%%1\" \"%%2\" \"%%3\" \"%%4\""), szModPath);
                SHRegSetPath(hkeyProgId, TEXT("shell\\printto\\command"), NULL, szCmd, 0);
            }

            //  this will delete print verb
            //  print is added in selfreg under HKCR\SystemFileAssociations\image\Print
            if (_ShouldSlamVerb(hkeyProgId, fForce, L"shell\\print\\command", TEXT("mspaint.exe"), pszModule))
            {
                SHDeleteKey(hkeyProgId, TEXT("shell\\print"));
            }

            // Modify the EditFlags: it's okay to run these without prompting...
            DWORD dwEditFlags = 0;
            DWORD cbEditFlags = sizeof(dwEditFlags);
            SHGetValue(hkeyProgId, NULL, TEXT("EditFlags"), NULL, &dwEditFlags, &cbEditFlags);
            dwEditFlags |= 0x00010000; // turn on the "okay to run without prompt" flag
            SHSetValue(hkeyProgId, NULL, TEXT("EditFlags"), REG_DWORD, &dwEditFlags, sizeof(dwEditFlags));
            
            RegCloseKey(hkeyProgId);
        }
        ppi->fDone = TRUE;
    }
}

HRESULT _CallRegInstall(LPCSTR szSection, BOOL bUninstall)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

            hr = pfnri(_Module.GetModuleInstance(), szSection, &stReg);
            if (bUninstall)
            {
                // ADVPACK will return E_UNEXPECTED if you try to uninstall 
                // (which does a registry restore) on an INF section that was 
                // never installed.  We uninstall sections that may never have
                // been installed, so ignore this error
                hr = ((E_UNEXPECTED == hr) ? S_OK : hr);
            }
        }
        FreeLibrary(hinstAdvPack);
    }
    return hr;
}

void _FixupProgid(PCSTR pszExt, PCSTR pszProgid)
{
    HKEY hk;
    DWORD dwRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, pszExt, 0, KEY_QUERY_VALUE, &hk);
    if (dwRet == ERROR_SUCCESS)
    {
        //  if its empty, then we need to fix it up.
        CHAR sz[MAX_PATH];
        DWORD cb = sizeof(sz);
        if (ERROR_SUCCESS == SHGetValueA(hk, NULL, NULL, NULL, sz, &cb) && !*sz)
        {
            SHSetValueA(hk, NULL, NULL, REG_SZ, pszProgid, CbFromCchA(lstrlenA(pszProgid)+1));
        }
    }
}

HRESULT RegisterHandler(const LPCSTR *ppszExts, UINT cExts, LPCSTR pszIID, LPCSTR pszCLSID)
{
    for (UINT cKey = 0; cKey < cExts; cKey ++)
    {
        CHAR szKey[MAX_PATH];
        wnsprintfA(szKey, ARRAYSIZE(szKey), "SystemFileAssociations\\%s\\shellex\\%s", *ppszExts, pszIID);
        SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
        SHSetValueA(HKEY_CLASSES_ROOT, szKey, NULL, REG_SZ, pszCLSID, CbFromCch(lstrlenA(pszCLSID)+1));
        ppszExts++;
    }
    return S_OK;
}

HRESULT UnregisterHandler(const LPCSTR *ppszExts, UINT cExts, LPCSTR pszIID, LPCSTR pszCLSID)
{
    for (UINT cKey = 0; cKey < cExts; cKey ++)
    {
        CHAR szKey[MAX_PATH];
        CHAR szCLSID[256];
        DWORD dwSize = sizeof(szCLSID);
        wnsprintfA(szKey, ARRAYSIZE(szKey), "SystemFileAssociations\\%s\\shellex\\%s", *ppszExts, pszIID);
        if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, szKey, NULL, NULL, &szCLSID, &dwSize))
        {
            if (!StrCmpIA(szCLSID, pszCLSID))
            {
                SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
            }
        }
        dwSize = sizeof(szCLSID);
        wnsprintfA(szKey, ARRAYSIZE(szKey), "%s\\shellex\\%s", *ppszExts, pszIID);
        if (ERROR_SUCCESS == SHGetValueA(HKEY_CLASSES_ROOT, szKey, NULL, NULL, &szCLSID, &dwSize))
        {
            if (!StrCmpIA(szCLSID, pszCLSID))
            {
                SHDeleteKeyA(HKEY_CLASSES_ROOT, szKey);
            }
        }
        ppszExts++;
    }
    return S_OK;
}

STDAPI DllRegisterServer(void)
{
    // REVIEW: should this be done only in DLLInstall?
    for (int i=0; i<ARRAYSIZE(g_rgExtentions); i++)
    {
        RegisterFileType(g_rgExtentions+i, FALSE);
    }

    RegisterHandler(c_rgszDocFileExts, ARRAYSIZE(c_rgszDocFileExts), IIDSTR_IExtractImage, CLSIDSTR_DocfileThumbnailHandler);
    UnregisterHandler(c_rgszHtmlExts, ARRAYSIZE(c_rgszHtmlExts), IIDSTR_IExtractImage, CLSIDSTR_HtmlThumbnailExtractor);

    _CallRegInstall("RegDll", TRUE);

    //  powerpoint gets freaked by empty extension keys.
    _FixupProgid(".ppt", "Powerpoint.Show.7");
    _FixupProgid(".pot", "Powerpoint.Template");

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    UnregisterHandler(c_rgszDocFileExts, ARRAYSIZE(c_rgszDocFileExts), IIDSTR_IExtractImage, CLSIDSTR_DocfileThumbnailHandler);
    UnregisterHandler(c_rgszHtmlExts, ARRAYSIZE(c_rgszHtmlExts), IIDSTR_IExtractImage, CLSIDSTR_HtmlThumbnailExtractor);

    _CallRegInstall("UnRegDll", TRUE);

    return S_OK;
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    if (bInstall)
    {
        BOOL fForce = StrStrIW(pszCmdLine, L"/FORCE") != 0;
        for (int i=0; i<ARRAYSIZE(g_rgExtentions); i++)
        {
            RegisterFileType(g_rgExtentions+i, fForce);
        }
    }
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

//
// This array holds information needed for ClassFacory.
// OLEMISC_ flags are used by shembed and shocx.
//
// PERF: this table should be ordered in most-to-least used order
//
#define OIF_ALLOWAGGREGATION  0x0001

// constructor for CObjectInfo.

CObjectInfo::CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein, IID const* piidIn,
                         IID const* piidEventsIn, long lVersionIn, DWORD dwOleMiscFlagsIn,
                         DWORD dwClassFactFlagsIn)
{
    pclsid            = pclsidin;
    pfnCreateInstance = pfnCreatein;
    piid              = piidIn;
    piidEvents        = piidEventsIn;
    lVersion          = lVersionIn;
    dwOleMiscFlags    = dwOleMiscFlagsIn;
    dwClassFactFlags  = dwClassFactFlagsIn;
}

// static class factory (no allocs!)

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (void *)GET_ICLASSFACTORY(this);
        _Module.Lock();
        return S_OK;
    }

    *ppvObj = NULL;
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    _Module.Lock();
    return 2;
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    _Module.Unlock();
    return 1;
}

STDMETHODIMP CClassFactory::CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (punkOuter && !IsEqualIID(riid, IID_IUnknown))
    {
        // It is technically illegal to aggregate an object and request
        // any interface other than IUnknown. Enforce this.
        //
        return CLASS_E_NOAGGREGATION;
    }
    else
    {
        LPOBJECTINFO pthisobj = (LPOBJECTINFO)this;

        if (punkOuter && !(pthisobj->dwClassFactFlags & OIF_ALLOWAGGREGATION))
            return CLASS_E_NOAGGREGATION;

        IUnknown *punk;
        HRESULT hres = pthisobj->pfnCreateInstance(punkOuter, &punk, pthisobj);
        if (SUCCEEDED(hres))
        {
            hres = punk->QueryInterface(riid, ppv);
            punk->Release();
        }

        return hres;
    }
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        _Module.Lock();
    else
        _Module.Unlock();

    return S_OK;
}


// Object constructor 

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    // handle non-ATL objects first
    if (IsEqualIID(riid, IID_IClassFactory) || IsEqualIID(riid, IID_IUnknown))
    {
        for (LPCOBJECTINFO pcls = g_ObjectInfo; pcls->pclsid; pcls++)
        {
            if (IsEqualGUID(rclsid, *(pcls->pclsid)))
            {
                *ppv = (void*)pcls;
                _Module.Lock();
                return S_OK;
            }
        }
    }

    // Try the ATL way....
    return _Module.GetClassObject(rclsid, riid, ppv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\tasks.cpp ===
#include "precomp.h"
#include "tasks.h"
#include "prevwnd.h"


void DeleteBuffer(Buffer * pBuf)
{
    if (pBuf)
    {
        if (pBuf->hbmOld)
            SelectObject(pBuf->hdc, pBuf->hbmOld);
        if (pBuf->hPalOld)
            SelectPalette(pBuf->hdc, pBuf->hPalOld, FALSE);
        if (pBuf->hbm)
            DeleteObject(pBuf->hbm);
        if (pBuf->hPal)
            DeleteObject(pBuf->hPal);   
        if (pBuf->hdc)
            DeleteDC(pBuf->hdc);    
        delete pBuf;
    }
}


////////////////////////////////////////////////////////////////////////////
//
// CDecodeTask
//
////////////////////////////////////////////////////////////////////////////

CDecodeTask::CDecodeTask() : CRunnableTask(RTF_DEFAULT)
{
    InitializeCriticalSection(&_cs);
};

CDecodeTask::~CDecodeTask()
{
    ATOMICRELEASE(_pstrm);
    ATOMICRELEASE(_pfactory);
    if (_pszFilename)
        LocalFree(_pszFilename);
    ATOMICRELEASE(_pSID);
    DeleteCriticalSection(&_cs);
    if (_ppi)
        delete [] _ppi;
}

HRESULT CDecodeTask::Create(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd, IRunnableTask ** ppTask)
{
    *ppTask = NULL;
    CDecodeTask * pTask = new CDecodeTask();
    if (!pTask)
        return E_OUTOFMEMORY;

    HRESULT hr = pTask->_Initialize(pstrm, pszFilename, iItem, pFactory, hwnd);
    if (SUCCEEDED(hr))
    {
        *ppTask = (IRunnableTask*)pTask;
    }
    else
    {
        pTask->Release();
    }
    return hr;
}

HRESULT CDecodeTask::_Initialize(IStream *pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory *pFactory, HWND hwnd)
{
    if (pstrm)
    {
        STATSTG stat;
        if (SUCCEEDED(pstrm->Stat(&stat, 0)))
        {
            _pszFilename = StrDup(stat.pwcsName);
            _fIsReadOnly = !(stat.grfMode & STGM_WRITE);
            CoTaskMemFree(stat.pwcsName);
        }
        _pstrm = pstrm;
        _pstrm->AddRef();
    }
    else
    {
        _pszFilename = StrDup(pszFilename);
        if (!_pszFilename)
            return E_OUTOFMEMORY;
    }
    if (!_pstrm && _pszFilename)
    {
        SHGetFileInfo(_pszFilename, 0, &_sfi, sizeof(_sfi), SHGFI_DISPLAYNAME | SHGFI_USEFILEATTRIBUTES);
    }
    else
    {
        ZeroMemory(&_sfi, sizeof(_sfi));
    }
    _pfactory = pFactory;
    _pfactory->AddRef();

    _hwndNotify = hwnd;
    _iItem = iItem;

    return S_OK;
}

HRESULT CDecodeTask::RunInitRT()
{
    HRESULT hr;

    EnterCriticalSection(&_cs);
    if (_pstrm)
    {
        hr = _pfactory->CreateImageFromStream(_pstrm, &_pSID);
    }
    else
    {
        hr = _pfactory->CreateImageFromFile(_pszFilename, &_pSID);
        _fIsReadOnly = (GetFileAttributes(_pszFilename) & FILE_ATTRIBUTE_READONLY);
    }

    if (SUCCEEDED(hr))
    {
        hr = _pSID->Decode(SHIMGDEC_LOADFULL,0,0);
        if (SUCCEEDED(hr))
        {
            _pSID->GetPageCount(&_cImages);
            _ppi = new PageInfo[_cImages];

            if (_ppi)
            {
                _iCurrent = 0;
                _fAnimated = (S_OK == _pSID->IsAnimated());
                _fEditable = (S_OK == _pSID->IsEditable());
                PixelFormat pf;
                _pSID->GetPixelFormat(&pf);
                _fExtendedPF = IsExtendedPixelFormat(pf);
                _pSID->GetRawDataFormat(&_guidFormat);
                for (ULONG i = 0; i < _cImages; i++)
                {
                    _pSID->SelectPage(i);   // this works for animated and multipage
                    _pSID->GetSize(&_ppi[i].szImage);
                    _pSID->GetResolution(&_ppi[i].xDPI, &_ppi[i].yDPI);
                    if (_fAnimated)
                        _pSID->GetDelay(&_ppi[i].dwDelay);
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }

        if (FAILED(hr))
        {
            ATOMICRELEASE(_pSID);
        }
    }
    LeaveCriticalSection(&_cs);

    AddRef();
    _hr = hr;
    if (!PostMessage(_hwndNotify, IV_SETIMAGEDATA, (WPARAM)this, NULL))
    {
        Release();
    }

    return S_OK;
}

BOOL CDecodeTask::GetSize(SIZE * psz)
{
    if (!_ppi)
        return FALSE;
    *psz = _ppi[_iCurrent].szImage;
    return TRUE;
 }

BOOL CDecodeTask::GetResolution(ULONG * px, ULONG * py)
{
    if (!_ppi)
        return FALSE;
    *px = _ppi[_iCurrent].xDPI;
    *py = _ppi[_iCurrent].yDPI;
    return TRUE;
}

DWORD CDecodeTask::GetDelay()
{
    if (!_ppi)
        return 0;
    return _ppi[_iCurrent].dwDelay;
}

BOOL CDecodeTask::NextPage()
{
    if (_iCurrent >= _cImages-1)
        return FALSE;

    _iCurrent++;
    return TRUE;
}


BOOL CDecodeTask::PrevPage()
{
    if (_iCurrent == 0)
        return FALSE;

    _iCurrent--;
    return TRUE;
}

BOOL CDecodeTask::NextFrame()
{
    EnterCriticalSection(&_cs);
    HRESULT hr = _pSID->NextFrame();
    LeaveCriticalSection(&_cs);

    if (S_OK==hr)
    {
        _iCurrent = (_iCurrent+1) % _cImages;
    }
    return (S_OK == hr);
}

BOOL CDecodeTask::SelectPage(ULONG nPage)
{
    if (nPage >= _cImages)
        return FALSE;

    _iCurrent = nPage;
    return TRUE;
}

BOOL CDecodeTask::ChangePage(CAnnotationSet& Annotations)
{
    BOOL bResult = FALSE;
    EnterCriticalSection(&_cs);
    HRESULT hr = _pSID->SelectPage(_iCurrent);
    if (SUCCEEDED(hr))
    {
        // If we are moving onto a page that was previously rotated
        // but not saved then our cached size and resolution will be wrong
        _pSID->GetSize(&_ppi[_iCurrent].szImage);
        _pSID->GetResolution(&_ppi[_iCurrent].xDPI, &_ppi[_iCurrent].yDPI);
        
        Annotations.SetImageData(_pSID);
        bResult = TRUE;
    }
    LeaveCriticalSection(&_cs);

    return bResult;
}

HRESULT CDecodeTask::Rotate(DWORD dwAngle)
{
    HRESULT hr;
    EnterCriticalSection(&_cs);
    hr = _pSID->Rotate(dwAngle);
    if (SUCCEEDED(hr))
    {
        ULONG dwTmp = _ppi[_iCurrent].szImage.cx;
        _ppi[_iCurrent].szImage.cx = _ppi[_iCurrent].szImage.cy;
        _ppi[_iCurrent].szImage.cy = dwTmp;
        if (dwAngle == 90 || dwAngle == 270)
        {
            dwTmp = _ppi[_iCurrent].xDPI;
            _ppi[_iCurrent].xDPI =_ppi[_iCurrent].yDPI;
            _ppi[_iCurrent].yDPI = dwTmp;
        }
        
    }
    LeaveCriticalSection(&_cs);
    return hr;
}

HRESULT CDecodeTask::Lock(IShellImageData ** ppSID)
{
    if (_pSID)
    {
        EnterCriticalSection(&_cs);
        *ppSID = _pSID;
        return S_OK;
    }

    *ppSID = NULL;
    return E_FAIL;
}

HRESULT CDecodeTask::Unlock()
{
    LeaveCriticalSection(&_cs);
    return S_OK;
}

BOOL CDecodeTask::DisplayName(LPTSTR psz, UINT cch)
{
    // TODO:  Just call the _pSID->DisplayName
    if (_sfi.szDisplayName[0])
    {   
        StrCpyN(psz, _sfi.szDisplayName, cch);
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
// CDrawTask
//
////////////////////////////////////////////////////////////////////////////

CDrawTask::CDrawTask() : CRunnableTask(RTF_SUPPORTKILLSUSPEND)
{
}

CDrawTask::~CDrawTask()
{
    if (_pImgData)
        _pImgData->Release();

    // DeleteBuffer is going to check for NULL anyway
    DeleteBuffer(_pBuf);
}

HRESULT CDrawTask::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (riid == IID_IShellImageDataAbort)
    {
        *ppvObj = static_cast<IShellImageDataAbort*>(this);
        AddRef();
        return S_OK;
    }

    return CRunnableTask::QueryInterface(riid, ppvObj);
}


HRESULT CDrawTask::Create(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg, IRunnableTask ** ppTask)
{
    *ppTask = NULL;

    CDrawTask * pTask = new CDrawTask();
    if (!pTask)
        return E_OUTOFMEMORY;

    HRESULT hr = pTask->_Initialize(pImageData, clr, rcSrc, rcDest, hwnd, uMsg);
    if (SUCCEEDED(hr))
    {
        *ppTask = (IRunnableTask*)pTask;
    }
    else
    {
        pTask->Release();
    }
    return hr;
}

HRESULT CDrawTask::_Initialize(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg)
{
    _pImgData = pImageData;
    _pImgData->AddRef();
    _dwPage = _pImgData->_iCurrent;
    _clrBkgnd = clr;
    _rcSrc = rcSrc;
    _hwndNotify = hwnd;
    _uMsgNotify = uMsg;
    _pBuf = new Buffer;
    if (!_pBuf)
        return E_OUTOFMEMORY;

    _pBuf->rc = rcDest;
    _pBuf->hPal = NULL;
    return S_OK;
}

typedef RGBQUAD RGBQUAD8[256];

HBITMAP _CreateBitmap(HDC hdcWnd, Buffer *pBuf, SIZE *pSize)
{
    int bpp = GetDeviceCaps(hdcWnd, BITSPIXEL);
    HBITMAP hbm = NULL;
    if (8==bpp)
    {
        PVOID pvBits = NULL;
        struct 
        {
            BITMAPINFOHEADER bmih;
            RGBQUAD8 rgbquad8;
        } bmi;
        bmi.bmih.biSize = sizeof(bmi.bmih);
        bmi.bmih.biWidth = (int)pSize->cx;
        bmi.bmih.biHeight = (int)pSize->cy;
        bmi.bmih.biPlanes = 1;
        bmi.bmih.biBitCount = 8;
        bmi.bmih.biCompression = BI_RGB;
        bmi.bmih.biSizeImage = 0;
        bmi.bmih.biXPelsPerMeter = 0;
        bmi.bmih.biYPelsPerMeter = 0;
        bmi.bmih.biClrUsed = 0;             // only used for <= 16bpp
        bmi.bmih.biClrImportant = 0;
        //
        // Use the halftone palette
        //
        pBuf->hPal = DllExports::GdipCreateHalftonePalette();
        pBuf->hPalOld = SelectPalette(pBuf->hdc, pBuf->hPal, FALSE);
        
        BYTE aj[sizeof(PALETTEENTRY) * 256];
        LPPALETTEENTRY lppe = (LPPALETTEENTRY) aj;
        RGBQUAD *prgb = (RGBQUAD *) &bmi.rgbquad8;
        
        if (GetPaletteEntries(pBuf->hPal, 0, 256, lppe))
        {
            UINT i;

            for (i = 0; i < 256; i++)
            {
                prgb[i].rgbRed      = lppe[i].peRed;
                prgb[i].rgbGreen    = lppe[i].peGreen;
                prgb[i].rgbBlue     = lppe[i].peBlue;
                prgb[i].rgbReserved = 0;
            }
        }
        hbm = CreateDIBSection(hdcWnd,(BITMAPINFO*)&bmi,DIB_RGB_COLORS,&pvBits,NULL,0);
    }
    else
    {
        hbm = CreateCompatibleBitmap(hdcWnd,pSize->cx, pSize->cy);
    }
    return hbm;
}

HRESULT CDrawTask::InternalResumeRT()
{
    HRESULT hr = E_FAIL;

    HDC hdcScreen = GetDC(NULL);
    if (!_pBuf->hdc)
    {
        _pBuf->hdc = CreateCompatibleDC(hdcScreen);
    }
    if (_pBuf->hdc)
    {
        SIZE sz = {RECTWIDTH(_pBuf->rc), RECTHEIGHT(_pBuf->rc)};

        // If we were suspended and resumed, we will already have
        // a GDI bitmap from last time so don't make another one.
        if (!_pBuf->hbm)
        {
            BITMAP bm = {0};
            _pBuf->hbm = _CreateBitmap(hdcScreen, _pBuf, &sz);
            _pBuf->hbmOld = (HBITMAP)SelectObject(_pBuf->hdc, _pBuf->hbm);            
        }

        if (_pBuf->hbm)
        {
            RECT rc = {0,0,sz.cx, sz.cy};
            
            SetBkColor(_pBuf->hdc, _clrBkgnd);
            ExtTextOut(_pBuf->hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);           
            IShellImageData * pSID;
            if (SUCCEEDED(_pImgData->Lock(&pSID)))
            {
                pSID->SelectPage(_dwPage);
                IShellImageDataAbort *pAbortPrev = NULL;
                pSID->RegisterAbort(this, &pAbortPrev);
                hr = pSID->Draw(_pBuf->hdc, &rc, &_rcSrc);              
                pSID->RegisterAbort(pAbortPrev, NULL);
                _pImgData->Unlock();
            }
        }
    }
    if (hdcScreen)
    {
        ReleaseDC(NULL, hdcScreen);
    }

    if (QueryAbort() == S_FALSE)
    {
        // We were cancelled or suspended, so don't notify our parent
        // because we have nothing to show for our efforts.
        hr = (_lState == IRTIR_TASK_SUSPENDED) ? E_PENDING : E_FAIL;
    }
    else
    {
        // Ran to completion - clean up and notify main thread
        UINT iIndex = _pImgData->_iItem;
        ATOMICRELEASE(_pImgData);
        if (FAILED(hr))
        {
            DeleteBuffer(_pBuf);
            _pBuf = NULL;
        }
        if (PostMessage(_hwndNotify, _uMsgNotify, (WPARAM)_pBuf, (LPARAM)IntToPtr(iIndex)))
        {
            _pBuf = NULL;
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CDrawTask::QueryAbort()
{
    // BUGBUG not rady for prime tome - need to return E_PENDING
    // if state is SUSPENDED
    if (WaitForSingleObject(_hDone, 0) == WAIT_OBJECT_0)
    {
        return S_FALSE; // Abort
    }
    return S_OK;
}

int LoadSPString(int idStr, LPTSTR pszString, int cch)
{
    int iRet = 0;
    if (pszString && cch > 0)
    {
        *pszString = 0;
    }
    HINSTANCE hinst = LoadLibraryEx(TEXT("xpsp1res.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);
    if (hinst)
    {
        iRet = LoadString(hinst, idStr, pszString, cch);
        FreeLibrary(hinst);
    }
    // Change this if the XP string changes are approved
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\tasks.h ===
#pragma once

// forward declaration to make things easy
class CAnnotationSet;

typedef struct
{
    SIZE  szImage;
    ULONG xDPI;
    ULONG yDPI;
    DWORD dwDelay;
} PageInfo;

typedef struct
{
    DWORD   dwID;
    RECT    rc;
    HBITMAP hbm;
    HPALETTE hPal;
    HDC hdc;
    HPALETTE hPalOld;
    HBITMAP hbmOld;
} Buffer;

void DeleteBuffer(Buffer * pBuf);

class CDecodeTask : public CRunnableTask
{
public:
    static HRESULT Create(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd, IRunnableTask ** pTask);
    STDMETHOD(RunInitRT)();

    inline BOOL IsEditable()  { return (_fEditable); }
    inline BOOL IsMultipage() { return (!_fAnimated && (_cImages > 1)); }
    inline BOOL IsFirstPage() { return (0==_iCurrent); }
    inline BOOL IsLastPage()  { return (_iCurrent == _cImages-1); }
    inline BOOL IsAnimated()  { return (_fAnimated); }
    inline BOOL IsExtendedPixelFmt () { return _fExtendedPF; }

    LPCWSTR GetName() { return _pszFilename; }
    BOOL GetSize(SIZE * psz);
    BOOL GetResolution(ULONG * px, ULONG * py);
    DWORD GetDelay();
    BOOL PrevPage();
    BOOL NextPage();
    BOOL NextFrame();
    BOOL SelectPage(ULONG nPage);
    BOOL ChangePage(CAnnotationSet& pAnnotations);
    HRESULT Print(BOOL fShowUI, LPWSTR szPrinterName, HWND hwndOwner);
    HRESULT Rotate(DWORD dwAngle);
    
    HRESULT Lock(IShellImageData ** ppSID);
    HRESULT Unlock();
    BOOL DisplayName(LPTSTR psz, UINT cch);

    // general image data
    ULONG _cImages;
    ULONG _iCurrent;
    BOOL  _fAnimated;
    BOOL  _fEditable;
    GUID  _guidFormat;
    UINT  _iItem;
    BOOL  _fIsReadOnly;
    HRESULT _hr;

    // properties of page _iCurrent
    PageInfo * _ppi;

private:
    CDecodeTask();
    ~CDecodeTask();
    HRESULT _Initialize(IStream * pstrm, LPCWSTR pszFilename, UINT iItem, IShellImageDataFactory * pFactory, HWND hwnd);

    // initialization info
    IStream *_pstrm;
    LPWSTR _pszFilename;
    IShellImageDataFactory * _pfactory;
    HWND _hwndNotify;

    // protected data
    CRITICAL_SECTION _cs;
    IShellImageData *_pSID;
    SHFILEINFO       _sfi;
    BOOL             _fExtendedPF;
};

class CDrawTask : public CRunnableTask, public IShellImageDataAbort
{
public:
    // CRunnableTask
    static HRESULT Create(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg, IRunnableTask ** ppTask);
    STDMETHOD(RunInitRT)() { return S_OK; }
    STDMETHOD(InternalResumeRT)();

    // *** IUnknown ***
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void) { return CRunnableTask::AddRef(); }
    STDMETHODIMP_(ULONG) Release(void)  { return CRunnableTask::Release(); }

    // *** IShellImageDataAbort ***
    STDMETHOD(QueryAbort)();

private:
    CDrawTask();
    ~CDrawTask();
    HRESULT _Initialize(CDecodeTask * pImageData, COLORREF clr, RECT & rcSrc, RECT & rcDest, HWND hwnd, ULONG uMsg);
    static BOOL _Abort(void *pvRef);

    CDecodeTask * _pImgData;
    DWORD _dwPage;
    COLORREF _clrBkgnd;
    RECT _rcSrc;
    Buffer * _pBuf;
    HWND _hwndNotify;
    ULONG _uMsgNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\thumbutil.h ===
STDAPI_(void) CalculateAspectRatio(const SIZE *prgSize, RECT *pRect);
STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits,
                                const SIZE *prgSize, RECT rect,
                                DWORD dwClrDepth, HPALETTE hPal, BOOL fOrigSize,
                                COLORREF clrBk, HBITMAP *phBmpThumbnail);
STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwClrDepth, HPALETTE hpal, UINT uiSharpPct, BOOL fOrigImage);
STDAPI_(BOOL) CreateSizedDIBSECTION(const SIZE *prgSize, DWORD dwClrDepth, HPALETTE hpal,
                                    const BITMAPINFO *pCurInfo, HBITMAP *phbmp, BITMAPINFO **pBMI, void **ppBits);
STDAPI_(void *) CalcBitsOffsetInDIB(BITMAPINFO *pBMI);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\zoomwnd.h ===
#ifndef __ZOOMWND_H_
#define __ZOOMWND_H_

#define ZW_DRAWCOMPLETE         (WM_USER+99)    // PRIVATE
#define ZW_BACKDRAWCOMPLETE     (WM_USER+100)    // PRIVATE
// messages for the Preview Window
#define IV_SETIMAGEDATA     (WM_USER+101)
#define IV_SCROLL           (WM_USER+102)
#define IV_SETOPTIONS       (WM_USER+104)
#define IV_ONCHANGENOTIFY   (WM_USER+106)
#define IV_ISAVAILABLE      (WM_USER+107)
typedef struct
{
    LONG    x;
    LONG    y;
    LONG    cx;
    LONG    cy;
} PTSZ;

class CPreviewWnd;

class CZoomWnd : public CWindowImpl<CZoomWnd>
{
public:
    enum MODE { MODE_PAN, MODE_ZOOMIN, MODE_ZOOMOUT, MODE_NOACTION };

    // public accessor functions
    void ZoomIn();          // Does a zoom in, handles contraints
    void ZoomOut();         // does a zoom out, handles boundry conditions and constraints
    void ActualSize();      // show image at full size (crop if needed)
    void BestFit();         // show full image in window (scale down if needed)
    BOOL IsBestFit() { return m_fBestFit; }

    void SetImageData(CDecodeTask * pImageData, BOOL bUpdate=TRUE);   // used to set an image for display
    HRESULT PrepareImageData(CDecodeTask * pImageData);    // Draw an image in the back buffer
    void SetPalette( HPALETTE hpal );   // If in palette mode, set this to the palette to use
    void StatusUpdate( int iStatus );   // used to set m_iStrID to display correct status message
    void Zoom( WPARAM wParam, LPARAM lParam );
    BOOL SetMode( MODE modeNew );
    BOOL ScrollBarsPresent();
    BOOL SetScheduler(IShellTaskScheduler * pTaskScheduler);
    int  QueryStatus() { return m_iStrID; }

    // Annotation Functions
    void GetVisibleImageWindowRect(LPRECT prectImage);
    void GetImageFromWindow(LPPOINT ppoint, int cSize);
    void GetWindowFromImage(LPPOINT ppoint, int cSize);
    CAnnotationSet* GetAnnotations() { return &m_Annotations; }
    void CommitAnnotations();

    DWORD GetBackgroundColor();
    
    CZoomWnd(CPreviewWnd *pPreview);
    ~CZoomWnd();

    DECLARE_WND_CLASS( TEXT("ShImgVw:CZoomWnd") );

protected:
BEGIN_MSG_MAP(CZoomWnd)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_MBUTTONDOWN, OnMouseDown)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnMouseDown)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_MBUTTONUP, OnMouseUp)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_SETCURSOR, OnSetCursor)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_KEYUP, OnKeyUp)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_HSCROLL, OnScroll)
    MESSAGE_HANDLER(WM_VSCROLL, OnScroll)
    MESSAGE_HANDLER(WM_MOUSEWHEEL, OnWheelTurn)
    MESSAGE_HANDLER(ZW_DRAWCOMPLETE, OnDrawComplete)
    MESSAGE_HANDLER(ZW_BACKDRAWCOMPLETE, OnBackDrawComplete)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
END_MSG_MAP()

    // message handlers
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnPaint(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnKeyUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnMouseUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetCursor(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnWheelTurn(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnBackDrawComplete(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

public:
    // This is lazy.  These are used by CPreview so I made them public when they probably shouldn't be.
    LRESULT OnScroll(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    int m_cxImage;      // width of bitmap referenced by m_pImageData
    int m_cyImage;      // height of bitmap referenced by m_pImageData
    float m_cxImgPhys;    // actual width of the image in inches
    float m_cyImgPhys;    // actual height of the image in inches
    int   m_cxImgPix;     // width of the image in screen pixels
    int   m_cyImgPix;     // height of the image in screen pixels
    float m_imgDPIx;
    float m_imgDPIy;
    float m_winDPIx;
    float m_winDPIy;
    

protected:
    BOOL m_fBestFit;    // True if we are in Bets Fit mode
    CDecodeTask * m_pImageData;// Handle to a IShellImageData object with render info

    int m_cxCenter;     // point to center on relative to image
    int m_cyCenter;     // point to center on relative to image

    int m_cxVScroll;    // width of a scroll bar
    int m_cyHScroll;    // height of a scroll bar
    int m_cxWindow;     // width of our client area + scroll width if scroll bar is visible
    int m_cyWindow;     // height of our client area + scroll height if scroll bar is visible
    float m_cxWinPhys;    // actual width of the client area in inches
    float m_cyWinPhys;    // actual height of the client in inches
    int m_xPosMouse;    // used to track mouse movement when dragging the LMB
    int m_yPosMouse;    // used to track mouse movement when dragging the LMB

    MODE m_modeDefault; // The zoom or pan mode when the shift key isn't pressed
    PTSZ m_ptszDest;    // the point and size of the destination rectangle (window coordinates)
    RECT m_rcCut;       // the rectangle of the part of the image that will be visible (image coordinates)
    RECT m_rcBleed;     // the rectangle adjusted for pixelation effects (window coordinates)
    BOOL m_fPanning;    // true when we are panning (implies left mouse button is down)
    BOOL m_fCtrlDown;   // a mode modifier ( zoom <=> pan ), true if Ctrl Key is down
    BOOL m_fShiftDown;  // a mode modifier ( zoom in <=> zoom out), true if Shift Key is down
    
    
    BOOL m_fTimerReady; // reset each time SetImageData is called, unset when timer is reset after OnDrawComplete

    int m_iStrID;       // string to display when no bitmap available

    BOOL  m_fFoundBackgroundColor;
    DWORD m_dwBackgroundColor;

    HPALETTE m_hpal;

    CPreviewWnd *m_pPreview; //  do not delete this

    CAnnotationSet m_Annotations;

    Buffer * m_pFront;
    Buffer * m_pBack;
    UINT     m_iIndex; // Index corresponding to the back buffer.

    IShellTaskScheduler * m_pTaskScheduler;

    // protected methods
    void AdjustRectPlacement(); // applies constraints for centering, ensureinging maximum visibility, etc
    void CalcCut();             // calculates the cut region that will be visible after a zoom
    void CalcCut(PTSZ ptszDest, int cxImage, int cyImage, RECT &rcCut, RECT &rcBleed);
    void GetPTSZForBestFit(int cxImgPix, int cyImgPix, float cxImgPhys, float cyImgPhys, PTSZ &ptszDest);
    void SetScrollBars();       // ensures scroll bar state is correct.  Used after window resize or zoom.
    HRESULT PrepareDraw();      // draw the image in the background thread
    void FlushDrawMessages();   // remove any pending draw tasks and messages
    BOOL SwitchBuffers(UINT iIndex);
    void _UpdatePhysicalSize();
};

#include "prevwnd.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shscrap\ids.h ===
// icon resource ids
#define IDI_ICON		100
#define IDI_TEMPLATE		101
#define IDI_SCRAP		102

// dialog box resource IDs
#define IDD_VIEW		100

// control IDs
#define IDI_SCRAPVIEW		100

// string resource ids
#define IDS_TITLE			0x100
#define IDS_TITLE_ERR			0x101
#define IDS_FILETYPE                    0x102

#define IDS_ERR_DOVERB			0x110
#define IDS_ERR_DOVERB_F 		0x111
#define IDS_ERR_COMMIT			0x112
#define IDS_ERR_COMMIT_F 		0x113
#define IDS_ERR_SCRAPSAVE		0x114
#define IDS_ERR_SCRAPSAVE_F 		0x115
#define IDS_ERR_CREATESTORAGE		0x116
#define IDS_ERR_CREATESTORAGE_F 	0x117
#define IDS_ERR_CREATEDOCFILE		0x118
#define IDS_ERR_CREATEDOCFILE_F 	0x119

#define IDS_BOOKMARK_S		0x200
#define IDS_BOOKMARK_L		0x201
#define IDS_FINDINVALIDFILENAME 0x202
#define IDS_NEWLINK             0x202
#define IDS_SCRAP_S		0x203
#define IDS_SCRAP_L		0x204
#define IDS_TEMPSCRAP		0x205
#define IDS_TEMPLINK		0x206

#define IDS_WOULDYOUSAVEAS	0x210
#define IDS_MOVEFAILED		0x211
#define IDS_SCRAPFILTER         0x212

#define IDS_HRES_MIN			0x400
#define IDS_HRES_MAX			0x800
#define IDS_HRES_INVALID_SCRAPFILE	0x400

#define IDR_FANCYERR		0x100

// reserved up to 0x1fff
#define IDS_FANCYERR		0x1000
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\ext\shimgvw\thumbutil.cpp ===
#include "precomp.h"
#include "ocmm.h"
#include "thumbutil.h"

typedef UCHAR BGR3[3];

class CThumbnailMaker
{
public:
    CThumbnailMaker();
    ~CThumbnailMaker();

    void Scale(BGR3 *pDst, UINT uiDstWidth, int iDstStep, const BGR3 *pSrc, UINT uiSrcWidth, int iSrcStep);
    HRESULT Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight);
    HRESULT AddScanline(UCHAR *pucSrc, UINT uiY);
    HRESULT AddDIB(BITMAPINFO *pBMI);
    HRESULT AddDIBSECTION(BITMAPINFO *pBMI, void *pBits);
    HRESULT GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize);
    HRESULT GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize);

private:
    UINT _uiDstWidth, _uiDstHeight;
    UINT _uiSrcWidth, _uiSrcHeight;
    BGR3 *_pImH;
};

CThumbnailMaker::CThumbnailMaker()
{
    _pImH = NULL;
}

CThumbnailMaker::~CThumbnailMaker()
{
    if (_pImH)
        delete[] _pImH;
}

HRESULT CThumbnailMaker::Init(UINT uiDstWidth, UINT uiDstHeight, UINT uiSrcWidth, UINT uiSrcHeight)
{
    _uiDstWidth = uiDstWidth;
    _uiDstHeight = uiDstHeight;
    _uiSrcWidth = uiSrcWidth;
    _uiSrcHeight = uiSrcHeight;

    if (_uiDstWidth < 1 || _uiDstHeight < 1 ||
        _uiSrcWidth < 1 || _uiSrcHeight < 1)
        return E_INVALIDARG;

    if (_pImH)
        delete[] _pImH;

    _pImH = new BGR3[_uiDstWidth * _uiSrcHeight];
    if (_pImH == NULL)
        return E_OUTOFMEMORY;

    return S_OK;
}

void CThumbnailMaker::Scale(      BGR3 *pDst, UINT dxDst, int iDstBytStep, 
                            const BGR3 *pSrc, UINT dxSrc, int iSrcBytStep)
{
    int mnum = dxSrc;
    int mden = dxDst;

    // Scaling up, use a triangle filter.
    if (mden >= mnum)
    {
        int frac = 0;

        // Adjust the slope so that we calculate the fraction of the
        // "next" pixel to use (i.e. should be 0 for the first and
        // last dst pixel).
        --mnum;
        if (--mden == 0)
            mden = 0; // avoid div by 0

        BGR3 *pSrc1 = (BGR3 *)(((UCHAR *)pSrc) + iSrcBytStep);

        for (UINT x = 0; x < dxDst; x++)
        {
            if (frac == 0)
            {
                (*pDst)[0] = (*pSrc)[0];
                (*pDst)[1] = (*pSrc)[1];
                (*pDst)[2] = (*pSrc)[2];
            }
            else
            {
                (*pDst)[0] = ((mden - frac) * (*pSrc)[0] + frac * (*pSrc1)[0]) / mden;
                (*pDst)[1] = ((mden - frac) * (*pSrc)[1] + frac * (*pSrc1)[1]) / mden;
                (*pDst)[2] = ((mden - frac) * (*pSrc)[2] + frac * (*pSrc1)[2]) / mden;
            }

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);

            frac += mnum;
            if (frac >= mden)
            {
                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
                pSrc1 = (BGR3 *)((UCHAR *)pSrc1 + iSrcBytStep);
            }
        }
    }
    // Scaling down, use a box filter.
    else
    {
        int frac = 0;

        for (UINT x = 0; x < dxDst; x++)
        {
            UINT uiSum[3] = {0, 0, 0};
            UINT uiCnt = 0;

            frac += mnum;
            while (frac >= mden)
            {
                uiSum[0] += (*pSrc)[0];
                uiSum[1] += (*pSrc)[1];
                uiSum[2] += (*pSrc)[2];
                uiCnt++;

                frac -= mden;
                pSrc = (BGR3 *)((UCHAR *)pSrc + iSrcBytStep);
            }

            (*pDst)[0] = uiSum[0] / uiCnt;
            (*pDst)[1] = uiSum[1] / uiCnt;
            (*pDst)[2] = uiSum[2] / uiCnt;

            pDst = (BGR3 *)((UCHAR *)pDst + iDstBytStep);
        }
    }
}

//
// For AddScanline, we scale the input horizontally into our temporary
// image buffer.
//
HRESULT CThumbnailMaker::AddScanline(UCHAR *pSrc, UINT uiY)
{
    if (pSrc == NULL || uiY >= _uiSrcHeight)
        return E_INVALIDARG;

    Scale(_pImH + uiY * _uiDstWidth, _uiDstWidth, sizeof(BGR3), (BGR3 *)pSrc, _uiSrcWidth, sizeof(BGR3));

    return S_OK;
}

// For GetBITMAPINFO, we complete the scaling vertically and return the
// result as a DIB.
HRESULT CThumbnailMaker::GetBITMAPINFO(BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
    *ppBMInfo = NULL;

    DWORD dwBPL = (((_uiDstWidth * 24) + 31) >> 3) & ~3;
    DWORD dwTotSize = sizeof(BITMAPINFOHEADER) + dwBPL * _uiDstHeight;

    BITMAPINFO *pBMI = (BITMAPINFO *)CoTaskMemAlloc(dwTotSize);
    if (pBMI == NULL)
        return E_OUTOFMEMORY;

    BITMAPINFOHEADER *pBMIH = &pBMI->bmiHeader;
    pBMIH->biSize = sizeof(*pBMIH);
    pBMIH->biWidth = _uiDstWidth;
    pBMIH->biHeight = _uiDstHeight;
    pBMIH->biPlanes = 1;
    pBMIH->biBitCount = 24;
    pBMIH->biCompression = BI_RGB;
    pBMIH->biXPelsPerMeter = 0;
    pBMIH->biYPelsPerMeter = 0;
    pBMIH->biSizeImage = dwBPL * _uiDstHeight;
    pBMIH->biClrUsed = 0;
    pBMIH->biClrImportant = 0;

    UCHAR *pDst = (UCHAR *)pBMIH + pBMIH->biSize + (_uiDstHeight - 1) * dwBPL;

    for (UINT x = 0; x < _uiDstWidth; x++)
    {
        Scale((BGR3 *)pDst + x, _uiDstHeight, -(int)dwBPL,
              _pImH + x, _uiSrcHeight, _uiDstWidth * sizeof(BGR3));
    }

    *ppBMInfo = pBMI;
    *pdwSize = dwTotSize;

    return S_OK;
}

HRESULT CThumbnailMaker::GetSharpenedBITMAPINFO(UINT uiSharpPct, BITMAPINFO **ppBMInfo, DWORD *pdwSize)
{
#define SCALE 10000

    if (uiSharpPct > 100)
        return E_INVALIDARG;

    // Get the unsharpened bitmap.
    DWORD dwSize;
    HRESULT hr = GetBITMAPINFO(ppBMInfo, &dwSize);
    if (FAILED(hr))
        return hr;

    *pdwSize = dwSize;

    // Create a duplicate to serve as the original.
    BITMAPINFO *pBMISrc = (BITMAPINFO *)new UCHAR[dwSize];
    if (pBMISrc == NULL)
    {
        delete *ppBMInfo;
        return E_OUTOFMEMORY;
    }
    memcpy(pBMISrc, *ppBMInfo, dwSize);

    int bpl = (pBMISrc->bmiHeader.biWidth * 3 + 3) & ~3;

    //
    // Sharpen inside a 1 pixel border
    //
    UCHAR *pucDst = (UCHAR *)*ppBMInfo + sizeof(BITMAPINFOHEADER);
    UCHAR *pucSrc[3];
    pucSrc[0] = (UCHAR *)pBMISrc + sizeof(BITMAPINFOHEADER);
    pucSrc[1] = pucSrc[0] + bpl;
    pucSrc[2] = pucSrc[1] + bpl;

    int wdiag = (10355 * uiSharpPct) / 100;
    int wadj = (14645 * uiSharpPct) / 100;
    int wcent = 4 * (wdiag + wadj);

    for (int y = 1; y < pBMISrc->bmiHeader.biHeight-1; ++y)
    {
        for (int x = 3*(pBMISrc->bmiHeader.biWidth-2); x >= 3; --x)
        {
            int v = pucDst[x] +
                (pucSrc[1][x] * wcent -
                 ((pucSrc[0][x - 3] +
                   pucSrc[0][x + 3] +
                   pucSrc[2][x - 3] +
                   pucSrc[2][x + 3]) * wdiag +
                  (pucSrc[0][x] +
                   pucSrc[1][x - 3] +
                   pucSrc[1][x + 3] +
                   pucSrc[2][x]) * wadj)) / SCALE;

            pucDst[x] = v < 0 ? 0 : v > 255 ? 255 : v;
        }

        pucDst += bpl;
        pucSrc[0] = pucSrc[1];
        pucSrc[1] = pucSrc[2];
        pucSrc[2] += bpl;
    }

    delete[] pBMISrc;

    return S_OK;
#undef SCALE
}

HRESULT ThumbnailMaker_Create(CThumbnailMaker **ppThumbMaker)
{
    *ppThumbMaker  = new CThumbnailMaker;
    return *ppThumbMaker ? S_OK : E_OUTOFMEMORY;
}

HRESULT CThumbnailMaker::AddDIB(BITMAPINFO *pBMI)
{
    int ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;
        
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            ncolors = 3;
        }
    }

    UCHAR *pBits = (UCHAR *)&pBMI->bmiColors[0] + ncolors * sizeof(RGBQUAD);

    return AddDIBSECTION(pBMI, (void *) pBits);
}

HRESULT CThumbnailMaker::AddDIBSECTION(BITMAPINFO *pBMI, void *pBits)
{
    RGBQUAD *pRGBQ, *pQ;
    UCHAR *pucBits0, *pucBits, *pB, *pucBits240, *pucBits24, *pB24;
    int bpl;
    int x, y, ncolors;
    ULONG rmask, gmask, bmask;
    int rshift, gshift, bshift;
    HRESULT hr;

    //
    // Make sure that thumbnail maker has been properly initialized.
    //
    if (pBMI == NULL)
        return E_INVALIDARG;

    if (pBMI->bmiHeader.biWidth != (LONG)_uiSrcWidth ||
        pBMI->bmiHeader.biHeight != (LONG)_uiSrcHeight)
        return E_INVALIDARG;

    //
    // Don't handle RLE.
    //
    if (pBMI->bmiHeader.biCompression != BI_RGB &&
        pBMI->bmiHeader.biCompression != BI_BITFIELDS)
        return E_INVALIDARG;

    pRGBQ = (RGBQUAD *)&pBMI->bmiColors[0];

    ncolors = pBMI->bmiHeader.biClrUsed;
    if (ncolors == 0 && pBMI->bmiHeader.biBitCount <= 8)
        ncolors = 1 << pBMI->bmiHeader.biBitCount;

    //
    // Decode 16/32bpp with masks.
    //
    if (pBMI->bmiHeader.biBitCount == 16 ||
        pBMI->bmiHeader.biBitCount == 32)
    {
        if (pBMI->bmiHeader.biCompression == BI_BITFIELDS)
        {
            rmask = ((ULONG *)pRGBQ)[0];
            gmask = ((ULONG *)pRGBQ)[1];
            bmask = ((ULONG *)pRGBQ)[2];
            ncolors = 3;
        }
        else if (pBMI->bmiHeader.biBitCount == 16)
        {
            rmask = 0x7c00;
            gmask = 0x03e0;
            bmask = 0x001f;
        }
        else /* 32 */
        {
            rmask = 0xff0000;
            gmask = 0x00ff00;
            bmask = 0x0000ff;
        }

        for (rshift = 0; (rmask & 1) == 0; rmask >>= 1, ++rshift);
        if (rmask == 0)
            rmask = 1;
        for (gshift = 0; (gmask & 1) == 0; gmask >>= 1, ++gshift);
        if (gmask == 0)
            gmask = 1;
        for (bshift = 0; (bmask & 1) == 0; bmask >>= 1, ++bshift);
        if (bmask == 0)
            bmask = 1;
    }

    bpl = ((pBMI->bmiHeader.biBitCount * _uiSrcWidth + 31) >> 3) & ~3;

    pucBits0 = (UCHAR *) pBits;
    pucBits = pucBits0;

    if (pBMI->bmiHeader.biBitCount == 24)
        pucBits240 = pucBits;
    else
    {
        int bpl24 = (_uiSrcWidth * 3 + 3) & ~3;

        pucBits240 = new UCHAR[bpl24];
        if (pucBits240 == NULL)
            return E_OUTOFMEMORY;
    }
    pucBits24 = pucBits240;

    hr = S_OK;

    for (y = 0; y < (int)_uiSrcHeight; ++y)
    {
        pB = pucBits;
        pB24 = pucBits24;

        switch (pBMI->bmiHeader.biBitCount)
        {
        case 1:
            for (x = _uiSrcWidth; x >= 8; x -= 8)
            {
                pQ = &pRGBQ[(*pB >> 7) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 6) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 5) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 4) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 3) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 2) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB >> 1) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[(*pB++) & 1];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                int shf = 8;

                do
                {
                    pQ = &pRGBQ[(*pB >> --shf) & 1];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
                while (--x);
            }

            break;

        case 4:
            for (x = _uiSrcWidth; x >= 2; x -= 2)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                pQ = &pRGBQ[*pB++ & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            if (x > 0)
            {
                pQ = &pRGBQ[(*pB >> 4) & 0xf];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;

                if (x > 1)
                {
                    pQ = &pRGBQ[*pB & 0xf];
                    *pB24++ = pQ->rgbBlue;
                    *pB24++ = pQ->rgbGreen;
                    *pB24++ = pQ->rgbRed;
                }
            }

            break;

        case 8:
            for (x = _uiSrcWidth; x--;)
            {
                pQ = &pRGBQ[*pB++];
                *pB24++ = pQ->rgbBlue;
                *pB24++ = pQ->rgbGreen;
                *pB24++ = pQ->rgbRed;
            }

            break;

        case 16:
        {
            USHORT *pW = (USHORT *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG w = *pW++;

                *pB24++ = (UCHAR)
                     ((((w >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((w >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((w >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        case 24:
            pucBits24 = pucBits;
            break;

        case 32:
        {
            ULONG *pD;

            pD = (ULONG *)pucBits;

            for (x = _uiSrcWidth; x--;)
            {
                ULONG d = *pD++;

                *pB24++ = (UCHAR)
                     ((((d >> bshift) & bmask) * 255) / bmask);
                *pB24++ = (UCHAR)
                     ((((d >> gshift) & gmask) * 255) / gmask);
                *pB24++ = (UCHAR)
                     ((((d >> rshift) & rmask) * 255) / rmask);
            }

            break;
        }

        default:
            delete[] pucBits24;
            return E_INVALIDARG;
        }

        hr = AddScanline(pucBits24, (_uiSrcHeight-1) - y);
        if (FAILED(hr))
            break;

        pucBits += bpl;
    }

    if (pucBits240 != pucBits0)
        delete[] pucBits240;

    return hr;
}

UINT CalcImageSize(const SIZE *prgSize, DWORD dwClrDepth)
{
    UINT uSize = prgSize->cx * dwClrDepth;
    
    uSize *= (prgSize->cy < 0) ? (- prgSize->cy) : prgSize->cy;
    // divide by 8
    UINT uRetVal = uSize >> 3;

    if (uSize & 7)
    {
        uRetVal++;
    }

    return uRetVal;
}

// exported as helper for thumbnail implementations (used to come from thumbvw.dll)
//
// this code also currently lives in shell32. that should be converted to
// import these APIs (or expose via COM object)

STDAPI_(BOOL) ConvertDIBSECTIONToThumbnail(BITMAPINFO *pbi, void *pBits,
                                           HBITMAP *phBmpThumbnail, const SIZE *prgSize,
                                           DWORD dwRecClrDepth, HPALETTE hpal, 
                                           UINT uiSharpPct, BOOL fOrigSize)
{
    BITMAPINFO *pbiScaled = pbi, *pbiUsed = pbi;
    BITMAPINFOHEADER *pbih = (BITMAPINFOHEADER *)pbi;
    BOOL bRetVal = FALSE, bInverted = FALSE;
    RECT rect;
    HRESULT hr;
    void *pScaledBits = pBits;

    // the scaling code doesn't handle inverted bitmaps, so we treat
    // them as if they were normal, by inverting the height here and
    // then setting it back before doing a paint.
    if (pbi->bmiHeader.biHeight < 0)
    {
        pbi->bmiHeader.biHeight *= -1;
        bInverted = TRUE;
    }

    rect.left = 0;
    rect.top = 0;
    rect.right = pbih->biWidth;
    rect.bottom = pbih->biHeight;
    
    CalculateAspectRatio(prgSize, &rect);

    // only bother with the scaling and sharpening if we are messing with the size...
    if ((rect.right - rect.left != pbih->biWidth) || (rect.bottom - rect.top != pbih->biHeight))
    {
        CThumbnailMaker *pThumbMaker;
        hr = ThumbnailMaker_Create(&pThumbMaker);
        if (SUCCEEDED(hr))
        {
            // initialize thumbnail maker. 
            hr = pThumbMaker->Init(rect.right - rect.left, rect.bottom - rect.top, 
                                    pbi->bmiHeader.biWidth, abs(pbi->bmiHeader.biHeight));
            if (SUCCEEDED(hr))
            {
                // scale image.
                hr = pThumbMaker->AddDIBSECTION(pbiUsed, pBits);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSize;
                    hr = pThumbMaker->GetSharpenedBITMAPINFO(uiSharpPct, &pbiScaled, &dwSize);
                    if (SUCCEEDED(hr))
                    {
                        pScaledBits = (LPBYTE)pbiScaled + sizeof(BITMAPINFOHEADER);
                    }
                }
            }
            delete pThumbMaker;
        }

        if (FAILED(hr))
        {
            return FALSE;
        }
    }

    // set the height back to negative if that's the way it was before.
    if (bInverted == TRUE)
        pbiScaled->bmiHeader.biHeight *= -1;

    // now if they have asked for origsize rather than the boxed one, and the colour depth is OK, then 
    // return it...
    if (fOrigSize && pbiScaled->bmiHeader.biBitCount <= dwRecClrDepth)
    {
        SIZE rgCreateSize = { pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight };
        void *pNewBits;
        
        // turn the PbiScaled DIB into a HBITMAP...., note we pass the old biInfo so that it can get the palette form
        // it if need be.
        bRetVal = CreateSizedDIBSECTION(&rgCreateSize, pbiScaled->bmiHeader.biBitCount, NULL, pbiScaled, phBmpThumbnail, NULL, &pNewBits);

        if (bRetVal)
        {
            // copy the image data accross...
            CopyMemory(pNewBits, pScaledBits, CalcImageSize(&rgCreateSize, pbiScaled->bmiHeader.biBitCount)); 
        }
        
        return bRetVal;
    }
    
    bRetVal = FactorAspectRatio(pbiScaled, pScaledBits, prgSize, rect,
                                 dwRecClrDepth, hpal, fOrigSize, GetSysColor(COLOR_WINDOW), phBmpThumbnail);

    if (pbiScaled != pbi)
    {
        // free the allocated image...
        CoTaskMemFree(pbiScaled);
    }

    return bRetVal;
}

// This function makes no assumption about whether the thumbnail is square, so 
// it calculates the scaling ratio for both dimensions and the uses that as
// the scaling to maintain the aspect ratio.
//
// WINDOWS RAID 135065 (toddb): Use of MulDiv should simplify this code
//
void CalcAspectScaledRect(const SIZE *prgSize, RECT *pRect)
{
    ASSERT(pRect->left == 0);
    ASSERT(pRect->top == 0);

    int iWidth = pRect->right;
    int iHeight = pRect->bottom;
    int iXRatio = (iWidth * 1000) / prgSize->cx;
    int iYRatio = (iHeight * 1000) / prgSize->cy;

    if (iXRatio > iYRatio)
    {
        pRect->right = prgSize->cx;
        
        // work out the blank space and split it evenly between the top and the bottom...
        int iNewHeight = ((iHeight * 1000) / iXRatio); 
        if (iNewHeight == 0)
        {
            iNewHeight = 1;
        }
        
        int iRemainder = prgSize->cy - iNewHeight;

        pRect->top = iRemainder / 2;
        pRect->bottom = iNewHeight + pRect->top;
    }
    else
    {
        pRect->bottom = prgSize->cy;

        // work out the blank space and split it evenly between the left and the right...
        int iNewWidth = ((iWidth * 1000) / iYRatio);
        if (iNewWidth == 0)
        {
            iNewWidth = 1;
        }
        int iRemainder = prgSize->cx - iNewWidth;
        
        pRect->left = iRemainder / 2;
        pRect->right = iNewWidth + pRect->left;
    }
}
    
void CalculateAspectRatio(const SIZE *prgSize, RECT *pRect)
{
    int iHeight = abs(pRect->bottom - pRect->top);
    int iWidth = abs(pRect->right - pRect->left);

    // check if the initial bitmap is larger than the size of the thumbnail.
    if (iWidth > prgSize->cx || iHeight > prgSize->cy)
    {
        pRect->left = 0;
        pRect->top = 0;
        pRect->right = iWidth;
        pRect->bottom = iHeight;

        CalcAspectScaledRect(prgSize, pRect);
    }
    else
    {
        // if the bitmap was smaller than the thumbnail, just center it.
        pRect->left = (prgSize->cx - iWidth) / 2;
        pRect->top = (prgSize->cy- iHeight) / 2;
        pRect->right = pRect->left + iWidth;
        pRect->bottom = pRect->top + iHeight;
    }
}

LPBYTE g_pbCMAP = NULL;

STDAPI_(BOOL) FactorAspectRatio(BITMAPINFO *pbiScaled, void *pScaledBits, 
                                const SIZE *prgSize, RECT rect, DWORD dwClrDepth, 
                                HPALETTE hpal, BOOL fOrigSize, COLORREF clrBk, HBITMAP *phBmpThumbnail)
{
    HDC                 hdc = CreateCompatibleDC(NULL);
    BITMAPINFOHEADER    *pbih = (BITMAPINFOHEADER *)pbiScaled;
    BOOL                bRetVal = FALSE;
    int                 iRetVal = GDI_ERROR;
    BITMAPINFO *        pDitheredInfo = NULL;
    void *              pDitheredBits = NULL;
    HBITMAP             hbmpDithered = NULL;
    
    if (hdc)
    {
        if (dwClrDepth == 8)
        {
            RGBQUAD *pSrcColors = NULL;
            LONG nSrcPitch = pbiScaled->bmiHeader.biWidth;
            
            // we are going to 8 bits per pixel, we had better dither everything 
            // to the same palette.
            GUID guidType = CLSID_NULL;
            switch(pbiScaled->bmiHeader.biBitCount)
            {
            case 32:
                guidType = BFID_RGB_32;
                nSrcPitch *= sizeof(DWORD);
                break;
                
            case 24:
                guidType = BFID_RGB_24;
                nSrcPitch *= 3;
                break;
                
            case 16:
                // default is 555
                guidType = BFID_RGB_555;
                
                // 5-6-5 bitfields has the second DWORD (the green component) as 0x7e00
                if (pbiScaled->bmiHeader.biCompression == BI_BITFIELDS && 
                    pbiScaled->bmiColors[1].rgbGreen == 0x7E)
                {
                    guidType = BFID_RGB_565;
                }
                nSrcPitch *= sizeof(WORD);
                break;
                
            case 8:
                guidType = BFID_RGB_8;
                pSrcColors = pbiScaled->bmiColors;
                
                // nSrcPitch is already in bytes...
                break;
            };
            
            if (nSrcPitch % 4)
            {
                // round up to the nearest DWORD...
                nSrcPitch = nSrcPitch + 4 - (nSrcPitch %4);
            }
            
            // we are going to 8bpp
            LONG nDestPitch = pbiScaled->bmiHeader.biWidth;
            if (nDestPitch % 4)
            {
                // round up to the nearest DWORD...
                nDestPitch = nDestPitch + 4 - (nDestPitch % 4);
            }
            
            if (guidType != CLSID_NULL)
            {
                if (g_pbCMAP == NULL)
                {
                    // we are always going to the shell halftone palette right now, otherwise
                    // computing this inverse colour map consumes a lot of time (approx 2 seconds on
                    // a p200)
                    if (FAILED(SHGetInverseCMAP((BYTE *)&g_pbCMAP, sizeof(g_pbCMAP))))
                    {
                        return FALSE;
                    }
                }   
                
                SIZE rgDithered = {pbiScaled->bmiHeader.biWidth, pbiScaled->bmiHeader.biHeight};
                if (rgDithered.cy < 0)
                {
                    // invert it
                    rgDithered.cy = -rgDithered.cy;
                }
                
                if (CreateSizedDIBSECTION(&rgDithered, dwClrDepth, hpal, NULL, &hbmpDithered, &pDitheredInfo, &pDitheredBits))
                {
                    ASSERT(pDitheredInfo && pDitheredBits);
                    
                    // dither....
                    IIntDitherer *pDither;
                    HRESULT hr = CoCreateInstance(CLSID_IntDitherer, NULL, CLSCTX_INPROC_SERVER,
                        IID_PPV_ARG(IIntDitherer, &pDither));
                    
                    if (SUCCEEDED(hr))
                    {
                        hr = pDither->DitherTo8bpp((LPBYTE) pDitheredBits, nDestPitch, 
                            (LPBYTE) pScaledBits, nSrcPitch, guidType, 
                            pDitheredInfo->bmiColors, pSrcColors,
                            g_pbCMAP, 0, 0, rgDithered.cx, rgDithered.cy,
                            -1, -1);
                        
                        pDither->Release();
                    }
                    if (SUCCEEDED(hr))
                    {
                        // if the height was inverted, then invert it in the destination bitmap
                        if (rgDithered.cy != pbiScaled->bmiHeader.biHeight)
                        {
                            pDitheredInfo->bmiHeader.biHeight = - rgDithered.cy;
                        }
                        
                        // switch to the new image .....
                        pbiScaled = pDitheredInfo;
                        pScaledBits = pDitheredBits;
                    }
                }
            }
        }
        
        // create thumbnail bitmap and copy image into it.
        if (CreateSizedDIBSECTION(prgSize, dwClrDepth, hpal, NULL, phBmpThumbnail, NULL, NULL))
        {
            HBITMAP hBmpOld = (HBITMAP) SelectObject(hdc, *phBmpThumbnail);
            
            SetStretchBltMode(hdc, COLORONCOLOR);
            
            HGDIOBJ hBrush = CreateSolidBrush(clrBk);
            HGDIOBJ hPen = GetStockObject(WHITE_PEN);
            
            HGDIOBJ hOldBrush = SelectObject(hdc, hBrush);
            HGDIOBJ hOldPen = SelectObject(hdc, hPen);
            
            HPALETTE hpalOld;
            if (hpal)
            {
                hpalOld = SelectPalette(hdc, hpal, TRUE);
    